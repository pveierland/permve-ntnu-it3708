(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.flatland = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Network = exports.Network = function () {
    function Network(layers) {
        _classCallCheck(this, Network);

        this.layers = layers;
    }

    _createClass(Network, [{
        key: "evaluate",
        value: function evaluate(inputs) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = this.layers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var layer = _step.value;

                    inputs = layer.propagate(inputs);
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            return inputs;
        }
    }]);

    return Network;
}();

var Layer = exports.Layer = function () {
    function Layer(bias, weights, activationFunction) {
        _classCallCheck(this, Layer);

        this.bias = bias;
        this.weights = weights;
        this.activationFunction = activationFunction;

        this.outputs = new Array(this.size);
    }

    _createClass(Layer, [{
        key: "propagate",
        value: function propagate(inputs) {
            var inputSize = inputs.length;
            var outputSize = this.outputs.length;

            for (var j = 0; j < outputSize; j += 1) {
                var sum = this.bias[j];

                for (var i = 0; i < inputSize; i += 1) {
                    sum += this.weights[j * inputSize + i] * inputs[i];
                }

                this.outputs[j] = this.activationFunction(sum);
            }

            return this.outputs;
        }
    }, {
        key: "size",
        get: function get() {
            return this.bias.length;
        }
    }]);

    return Layer;
}();

},{}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.feedforward = undefined;

var _feedforward = require('./src/feedforward');

var feedforward = _interopRequireWildcard(_feedforward);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.feedforward = feedforward;

},{"./src/feedforward":1}],3:[function(require,module,exports){
module.exports = require('./lib/core/core');
},{"./lib/core/core":6}],4:[function(require,module,exports){
var core = require('./core');

/**
 * math.js factory function. Creates a new instance of math.js
 *
 * @param {Object} [config] Available configuration options:
 *                            {number} epsilon
 *                              Minimum relative difference between two
 *                              compared values, used by all comparison functions.
 *                            {string} matrix
 *                              A string 'matrix' (default) or 'array'.
 *                            {string} number
 *                              A string 'number' (default), 'bignumber', or
 *                              'fraction'
 *                            {number} precision
 *                              The number of significant digits for BigNumbers.
 *                              Not applicable for Numbers.
 *                            {boolean} predictable
 *                              Predictable output type of functions. When true,
 *                              output type depends only on the input types. When
 *                              false (default), output type can vary depending
 *                              on input values. For example `math.sqrt(-2)`
 *                              returns `NaN` when predictable is false, and
 *                              returns `complex('2i')` when true.
 */
function create (config) {
  // create a new math.js instance
  var math = core.create(config);
  math.create = create;

  // import data types, functions, constants, expression parser, etc.
  math['import'](require('./lib'));

  return math;
}

// return a new instance of math.js
module.exports = create();

},{"./core":3,"./lib":409}],5:[function(require,module,exports){
'use strict';

var object = require('./utils/object');
var bigConstants = require('./utils/bignumber/constants');

function factory (type, config, load, typed, math) {
  // listen for changed in the configuration, automatically reload
  // constants when needed
  math.on('config', function (curr, prev) {
    if (curr.number !== prev.number) {
      factory(type, config, load, typed, math);
    }
  });

  math['true']     = true;
  math['false']    = false;
  math['null']     = null;
  math['uninitialized'] = require('./utils/array').UNINITIALIZED;

  if (config.number === 'BigNumber') {
    math['Infinity'] = new type.BigNumber(Infinity);
    math['NaN']      = new type.BigNumber(NaN);

    object.lazy(math, 'pi',  function () {return bigConstants.pi(type.BigNumber)});
    object.lazy(math, 'tau', function () {return bigConstants.tau(type.BigNumber)});
    object.lazy(math, 'e',   function () {return bigConstants.e(type.BigNumber)});
    object.lazy(math, 'phi', function () {return bigConstants.phi(type.BigNumber)}); // golden ratio, (1+sqrt(5))/2

    // uppercase constants (for compatibility with built-in Math)
    object.lazy(math, 'E',       function () {return math.e;});
    object.lazy(math, 'LN2',     function () {return new type.BigNumber(2).ln();});
    object.lazy(math, 'LN10',    function () {return new type.BigNumber(10).ln()});
    object.lazy(math, 'LOG2E',   function () {return new type.BigNumber(1).div(new type.BigNumber(2).ln());});
    object.lazy(math, 'LOG10E',  function () {return new type.BigNumber(1).div(new type.BigNumber(10).ln())});
    object.lazy(math, 'PI',      function () {return math.pi});
    object.lazy(math, 'SQRT1_2', function () {return new type.BigNumber('0.5').sqrt()});
    object.lazy(math, 'SQRT2',   function () {return new type.BigNumber(2).sqrt()});
  }
  else {
    math['Infinity'] = Infinity;
    math['NaN']      = NaN;

    math.pi  = Math.PI;
    math.tau = Math.PI * 2;
    math.e   = Math.E;
    math.phi = 1.61803398874989484820458683436563811772030917980576286213545; // golden ratio, (1+sqrt(5))/2

    // uppercase constants (for compatibility with built-in Math)
    math.E           = math.e;
    math.LN2         = Math.LN2;
    math.LN10        = Math.LN10;
    math.LOG2E       = Math.LOG2E;
    math.LOG10E      = Math.LOG10E;
    math.PI          = math.pi;
    math.SQRT1_2     = Math.SQRT1_2;
    math.SQRT2       = Math.SQRT2;
  }

  // complex i
  math.i = type.Complex.I;

  // meta information
  math.version = require('./version');
}

exports.factory = factory;
exports.lazy = false;  // no lazy loading of constants, the constants themselves are lazy when needed
exports.math = true;   // request access to the math namespace
},{"./utils/array":461,"./utils/bignumber/constants":467,"./utils/object":484,"./version":487}],6:[function(require,module,exports){
var isFactory = require('./../utils/object').isFactory;
var deepExtend = require('./../utils/object').deepExtend;
var typedFactory = require('./typed');
var emitter = require('./../utils/emitter');

var importFactory = require('./function/import');
var configFactory = require('./function/config');

/**
 * Math.js core. Creates a new, empty math.js instance
 * @param {Object} [options] Available options:
 *                            {number} epsilon
 *                              Minimum relative difference between two
 *                              compared values, used by all comparison functions.
 *                            {string} matrix
 *                              A string 'Matrix' (default) or 'Array'.
 *                            {string} number
 *                              A string 'number' (default), 'BigNumber', or 'Fraction'
 *                            {number} precision
 *                              The number of significant digits for BigNumbers.
 *                              Not applicable for Numbers.
 *                            {boolean} predictable
 *                              Predictable output type of functions. When true,
 *                              output type depends only on the input types. When
 *                              false (default), output type can vary depending
 *                              on input values. For example `math.sqrt(-2)`
 *                              returns `NaN` when predictable is false, and
 *                              returns `complex('2i')` when true.
 * @returns {Object} Returns a bare-bone math.js instance containing
 *                   functions:
 *                   - `import` to add new functions
 *                   - `config` to change configuration
 *                   - `on`, `off`, `once`, `emit` for events
 */
exports.create = function create (options) {
  // simple test for ES5 support
  if (typeof Object.create !== 'function') {
    throw new Error('ES5 not supported by this JavaScript engine. ' +
    'Please load the es5-shim and es5-sham library for compatibility.');
  }

  // cached factories and instances
  var factories = [];
  var instances = [];

  // create a namespace for the mathjs instance, and attach emitter functions
  var math = emitter.mixin({});
  math.type = {};
  math.expression = {
    transform: Object.create(math)
  };

  // create a new typed instance
  math.typed = typedFactory.create(math.type);

  // create configuration options. These are private
  var _config = {
    // minimum relative difference between two compared values,
    // used by all comparison functions
    epsilon: 1e-12,

    // type of default matrix output. Choose 'matrix' (default) or 'array'
    matrix: 'Matrix',

    // type of default number output. Choose 'number' (default) 'BigNumber', or 'Fraction
    number: 'number',

    // number of significant digits in BigNumbers
    precision: 64,

    // predictable output type of functions. When true, output type depends only
    // on the input types. When false (default), output type can vary depending
    // on input values. For example `math.sqrt(-2)` returns `NaN` when
    // predictable is false, and returns `complex('2i')` when true.
    predictable: false
  };

  /**
   * Load a function or data type from a factory.
   * If the function or data type already exists, the existing instance is
   * returned.
   * @param {{type: string, name: string, factory: Function}} factory
   * @returns {*}
   */
  function load (factory) {
    if (!isFactory(factory)) {
      throw new Error('Factory object with properties `type`, `name`, and `factory` expected');
    }

    var index = factories.indexOf(factory);
    var instance;
    if (index === -1) {
      // doesn't yet exist
      if (factory.math === true) {
        // pass with math namespace
        instance = factory.factory(math.type, _config, load, math.typed, math);
      }
      else {
        instance = factory.factory(math.type, _config, load, math.typed);
      }

      // append to the cache
      factories.push(factory);
      instances.push(instance);
    }
    else {
      // already existing function, return the cached instance
      instance = instances[index];
    }

    return instance;
  }

  // load the import and config functions
  math['import'] = load(importFactory);
  math['config'] = load(configFactory);

  // apply options
  if (options) {
    math.config(options);
  }

  return math;
};

},{"./../utils/emitter":479,"./../utils/object":484,"./function/config":7,"./function/import":8,"./typed":9}],7:[function(require,module,exports){
'use strict';

var object = require('../../utils/object');

function factory (type, config, load, typed, math) {
  var MATRIX = ['Matrix', 'Array'];                   // valid values for option matrix
  var NUMBER = ['number', 'BigNumber', 'Fraction'];   // valid values for option number

  /**
   * Set configuration options for math.js, and get current options.
   * Will emit a 'config' event, with arguments (curr, prev).
   *
   * Syntax:
   *
   *     math.config(config: Object): Object
   *
   * Examples:
   *
   *     math.config().number;                // outputs 'number'
   *     math.eval('0.4');                    // outputs number 0.4
   *     math.config({number: 'Fraction'});
   *     math.eval('0.4');                    // outputs Fraction 2/5
   *
   * @param {Object} [options] Available options:
   *                            {number} epsilon
   *                              Minimum relative difference between two
   *                              compared values, used by all comparison functions.
   *                            {string} matrix
   *                              A string 'Matrix' (default) or 'Array'.
   *                            {string} number
   *                              A string 'number' (default), 'BigNumber', or 'Fraction'
   *                            {number} precision
   *                              The number of significant digits for BigNumbers.
   *                              Not applicable for Numbers.
   *                            {string} parenthesis
   *                              How to display parentheses in LaTeX and string
   *                              output.
   * @return {Object} Returns the current configuration
   */
  function _config(options) {
    if (options) {
      var prev = object.clone(config);

      // validate some of the options
      validateOption(options, 'matrix', MATRIX);
      validateOption(options, 'number', NUMBER);

      // merge options
      object.deepExtend(config, options);

      var curr = object.clone(config);

      // emit 'config' event
      math.emit('config', curr, prev);

      return curr;
    }
    else {
      return object.clone(config);
    }
  }

  // attach the valid options to the function so they can be extended
  _config.MATRIX = MATRIX;
  _config.NUMBER = NUMBER;

  return _config;
}

/**
 * Test whether an Array contains a specific item.
 * @param {Array.<string>} array
 * @param {string} item
 * @return {boolean}
 */
function contains (array, item) {
  return array.indexOf(item) !== -1;
}

/**
 * Find a string in an array. Case insensitive search
 * @param {Array.<string>} array
 * @param {string} item
 * @return {number} Returns the index when found. Returns -1 when not found
 */
function findIndex (array, item) {
  return array
      .map(function (i) {
        return i.toLowerCase();
      })
      .indexOf(item.toLowerCase());
}

/**
 * Validate an option
 * @param {Object} options         Object with options
 * @param {string} name            Name of the option to validate
 * @param {Array.<string>} values  Array with valid values for this option
 */
function validateOption(options, name, values) {
  if (options[name] !== undefined && !contains(values, options[name])) {
    var index = findIndex(values, options[name]);
    if (index !== -1) {
      // right value, wrong casing
      // TODO: lower case values are deprecated since v3, remove this warning some day.
      console.warn('Warning: Wrong casing for configuration option "' + name + '", should be "' + values[index] + '" instead of "' + options[name] + '".');

      options[name] = values[index]; // change the option to the right casing
    }
    else {
      // unknown value
      console.warn('Warning: Unknown value "' + options[name] + '" for configuration option "' + name + '". Available options: ' + values.map(JSON.stringify).join(', ') + '.');
    }
  }
}

exports.name = 'config';
exports.math = true; // request the math namespace as fifth argument
exports.factory = factory;

},{"../../utils/object":484}],8:[function(require,module,exports){
'use strict';

var lazy = require('../../utils/object').lazy;
var isFactory = require('../../utils/object').isFactory;
var traverse = require('../../utils/object').traverse;
var extend = require('../../utils/object').extend;
var ArgumentsError = require('../../error/ArgumentsError');

function factory (type, config, load, typed, math) {
  /**
   * Import functions from an object or a module
   *
   * Syntax:
   *
   *    math.import(object)
   *    math.import(object, options)
   *
   * Where:
   *
   * - `object: Object`
   *   An object with functions to be imported.
   * - `options: Object` An object with import options. Available options:
   *   - `override: boolean`
   *     If true, existing functions will be overwritten. False by default.
   *   - `silent: boolean`
   *     If true, the function will not throw errors on duplicates or invalid
   *     types. False by default.
   *   - `wrap: boolean`
   *     If true, the functions will be wrapped in a wrapper function
   *     which converts data types like Matrix to primitive data types like Array.
   *     The wrapper is needed when extending math.js with libraries which do not
   *     support these data type. False by default.
   *
   * Examples:
   *
   *    // define new functions and variables
   *    math.import({
   *      myvalue: 42,
   *      hello: function (name) {
   *        return 'hello, ' + name + '!';
   *      }
   *    });
   *
   *    // use the imported function and variable
   *    math.myvalue * 2;               // 84
   *    math.hello('user');             // 'hello, user!'
   *
   *    // import the npm module 'numbers'
   *    // (must be installed first with `npm install numbers`)
   *    math.import(require('numbers'), {wrap: true});
   *
   *    math.fibonacci(7); // returns 13
   *
   * @param {Object | Array} object   Object with functions to be imported.
   * @param {Object} [options]        Import options.
   */
  function math_import(object, options) {
    var num = arguments.length;
    if (num != 1 && num != 2) {
      throw new ArgumentsError('import', num, 1, 2);
    }

    if (!options) {
      options = {};
    }

    if (isFactory(object)) {
      _importFactory(object, options);
    }
    // TODO: allow a typed-function with name too
    else if (Array.isArray(object)) {
      object.forEach(function (entry) {
        math_import(entry, options);
      });
    }
    else if (typeof object === 'object') {
      // a map with functions
      for (var name in object) {
        if (object.hasOwnProperty(name)) {
          var value = object[name];
          if (isSupportedType(value)) {
            _import(name, value, options);
          }
          else if (isFactory(object)) {
            _importFactory(object, options);
          }
          else {
            math_import(value, options);
          }
        }
      }
    }
    else {
      if (!options.silent) {
        throw new TypeError('Factory, Object, or Array expected');
      }
    }
  }

  /**
   * Add a property to the math namespace and create a chain proxy for it.
   * @param {string} name
   * @param {*} value
   * @param {Object} options  See import for a description of the options
   * @private
   */
  function _import(name, value, options) {
    if (options.wrap && typeof value === 'function') {
      // create a wrapper around the function
      value = _wrap(value);
    }

    if (isTypedFunction(math[name]) && isTypedFunction(value)) {
      if (options.override) {
        // give the typed function the right name
        value = typed(name, value.signatures);
      }
      else {
        // merge the existing and typed function
        value = typed(math[name], value);
      }

      math[name] = value;
      _importTransform(name, value);
      math.emit('import', name, function resolver() {
        return value;
      });
      return;
    }

    if (math[name] === undefined || options.override) {
      math[name] = value;
      _importTransform(name, value);
      math.emit('import', name, function resolver() {
        return value;
      });
      return;
    }

    if (!options.silent) {
      throw new Error('Cannot import "' + name + '": already exists');
    }
  }

  function _importTransform (name, value) {
    if (value && typeof value.transform === 'function') {
      math.expression.transform[name] = value.transform;
    }
  }

  /**
   * Create a wrapper a round an function which converts the arguments
   * to their primitive values (like convert a Matrix to Array)
   * @param {Function} fn
   * @return {Function} Returns the wrapped function
   * @private
   */
  function _wrap (fn) {
    var wrapper = function wrapper () {
      var args = [];
      for (var i = 0, len = arguments.length; i < len; i++) {
        var arg = arguments[i];
        args[i] = arg && arg.valueOf();
      }
      return fn.apply(math, args);
    };

    if (fn.transform) {
      wrapper.transform = fn.transform;
    }

    return wrapper;
  }

  /**
   * Import an instance of a factory into math.js
   * @param {{factory: Function, name: string, path: string, math: boolean}} factory
   * @param {Object} options  See import for a description of the options
   * @private
   */
  function _importFactory(factory, options) {
    if (typeof factory.name === 'string') {
      var name = factory.name;
      var namespace = factory.path ? traverse(math, factory.path) : math;
      var existing = namespace.hasOwnProperty(name) ? namespace[name] : undefined;

      var resolver = function () {
        var instance = load(factory);

        if (isTypedFunction(existing) && isTypedFunction(instance)) {
          if (options.override) {
            // replace the existing typed function (nothing to do)
          }
          else {
            // merge the existing and new typed function
            instance = typed(existing, instance);
          }

          return instance;
        }

        if (existing === undefined || options.override) {
          return instance;
        }

        if (!options.silent) {
          throw new Error('Cannot import "' + name + '": already exists');
        }
      };

      if (factory.lazy !== false) {
        lazy(namespace, name, resolver);
      }
      else {
        namespace[name] = resolver();
      }

      math.emit('import', name, resolver, factory.path);
    }
    else {
      // unnamed factory.
      // no lazy loading
      load(factory);
    }
  }

  /**
   * Check whether given object is a type which can be imported
   * @param {Function | number | string | boolean | null | Unit | Complex} object
   * @return {boolean}
   * @private
   */
  function isSupportedType(object) {
    return typeof object == 'function'
        || typeof object === 'number'
        || typeof object === 'string'
        || typeof object === 'boolean'
        || object === null
        || (object && object.isUnit === true)
        || (object && object.isComplex === true)
        || (object && object.isBigNumber === true)
        || (object && object.isFraction === true)
        || (object && object.isMatrix === true)
        || (object && Array.isArray(object) === true)
  }

  /**
   * Test whether a given thing is a typed-function
   * @param {*} fn
   * @return {boolean} Returns true when `fn` is a typed-function
   */
  function isTypedFunction (fn) {
    return typeof fn === 'function' && typeof fn.signatures === 'object';
  }

  return math_import;
}

exports.math = true; // request access to the math namespace as 5th argument of the factory function
exports.name = 'import';
exports.factory = factory;
exports.lazy = true;

},{"../../error/ArgumentsError":10,"../../utils/object":484}],9:[function(require,module,exports){
var typedFunction = require('typed-function');
var digits = require('./../utils/number').digits;

// returns a new instance of typed-function
var createTyped = function () {
  // initially, return the original instance of typed-function
  // consecutively, return a new instance from typed.create.
  createTyped = typedFunction.create;
  return typedFunction;
};

/**
 * Factory function for creating a new typed instance
 * @param {Object} type   Object with data types like Complex and BigNumber
 * @returns {Function}
 */
exports.create = function create(type) {
  // TODO: typed-function must be able to silently ignore signatures with unknown data types

  // get a new instance of typed-function
  var typed = createTyped();

  // define all types. The order of the types determines in which order function
  // arguments are type-checked (so for performance it's important to put the
  // most used types first).
  typed.types = [
    { name: 'number',               test: function (x) { return typeof x === 'number'; } },
    { name: 'Complex',              test: function (x) { return x && x.isComplex; } },
    { name: 'BigNumber',            test: function (x) { return x && x.isBigNumber; } },
    { name: 'Fraction',             test: function (x) { return x && x.isFraction; } },
    { name: 'Unit',                 test: function (x) { return x && x.isUnit; } },
    { name: 'string',               test: function (x) { return typeof x === 'string'; } },
    { name: 'Array',                test: Array.isArray },
    { name: 'Matrix',               test: function (x) { return x && x.isMatrix; } },
    { name: 'DenseMatrix',          test: function (x) { return x && x.isDenseMatrix; } },
    { name: 'SparseMatrix',         test: function (x) { return x && x.isSparseMatrix; } },
    { name: 'ImmutableDenseMatrix', test: function (x) { return x && x.isImmutableDenseMatrix; } },
    { name: 'Range',                test: function (x) { return x && x.isRange; } },
    { name: 'Index',                test: function (x) { return x && x.isIndex; } },
    { name: 'boolean',              test: function (x) { return typeof x === 'boolean'; } },
    { name: 'ResultSet',            test: function (x) { return x && x.isResultSet; } },
    { name: 'Help',                 test: function (x) { return x && x.isHelp; } },
    { name: 'function',             test: function (x) { return typeof x === 'function';} },
    { name: 'Date',                 test: function (x) { return x instanceof Date; } },
    { name: 'RegExp',               test: function (x) { return x instanceof RegExp; } },
    { name: 'Object',               test: function (x) { return typeof x === 'object'; } },
    { name: 'null',                 test: function (x) { return x === null; } },
    { name: 'undefined',            test: function (x) { return x === undefined; } }
  ];

  // TODO: add conversion from BigNumber to number?
  typed.conversions = [
    {
      from: 'number',
      to: 'BigNumber',
      convert: function (x) {
        // note: conversion from number to BigNumber can fail if x has >15 digits
        if (digits(x) > 15) {
          throw new TypeError('Cannot implicitly convert a number with >15 significant digits to BigNumber ' +
          '(value: ' + x + '). ' +
          'Use function bignumber(x) to convert to BigNumber.');
        }
        return new type.BigNumber(x);
      }
    }, {
      from: 'number',
      to: 'Complex',
      convert: function (x) {
        return new type.Complex(x, 0);
      }
    }, {
      from: 'number',
      to: 'string',
      convert: function (x) {
        return x + '';
      }
    }, {
      from: 'BigNumber',
      to: 'Complex',
      convert: function (x) {
        return new type.Complex(x.toNumber(), 0);
      }
    }, {
      from: 'Fraction',
      to: 'Complex',
      convert: function (x) {
        return new type.Complex(x.valueOf(), 0);
      }
    }, {
      from: 'number',
      to: 'Fraction',
      convert: function (x) {
        if (digits(x) > 15) {
          throw new TypeError('Cannot implicitly convert a number with >15 significant digits to Fraction ' +
              '(value: ' + x + '). ' +
              'Use function fraction(x) to convert to Fraction.');
        }
        return new type.Fraction(x);
      }
    }, {
    // FIXME: add conversion from Fraction to number, for example for `sqrt(fraction(1,3))`
    //  from: 'Fraction',
    //  to: 'number',
    //  convert: function (x) {
    //    return x.valueOf();
    //  }
    //}, {
      from: 'string',
      to: 'number',
      convert: function (x) {
        var n = Number(x);
        if (isNaN(n)) {
          throw new Error('Cannot convert "' + x + '" to a number');
        }
        return n;
      }
    }, {
      from: 'boolean',
      to: 'number',
      convert: function (x) {
        return +x;
      }
    }, {
      from: 'boolean',
      to: 'BigNumber',
      convert: function (x) {
        return new type.BigNumber(+x);
      }
    }, {
      from: 'boolean',
      to: 'Fraction',
      convert: function (x) {
        return new type.Fraction(+x);
      }
    }, {
      from: 'boolean',
      to: 'string',
      convert: function (x) {
        return +x;
      }
    }, {
      from: 'null',
      to: 'number',
      convert: function () {
        return 0;
      }
    }, {
      from: 'null',
      to: 'string',
      convert: function () {
        return 'null';
      }
    }, {
      from: 'null',
      to: 'BigNumber',
      convert: function () {
        return new type.BigNumber(0);
      }
    }, {
      from: 'null',
      to: 'Fraction',
      convert: function () {
        return new type.Fraction(0);
      }
    }, {
      from: 'Array',
      to: 'Matrix',
      convert: function (array) {
        // TODO: how to decide on the right type of matrix to create?
        return new type.DenseMatrix(array);
      }
    }, {
      from: 'Matrix',
      to: 'Array',
      convert: function (matrix) {
        return matrix.valueOf();
      }
    }
  ];

  return typed;
};

},{"./../utils/number":483,"typed-function":492}],10:[function(require,module,exports){
'use strict';

/**
 * Create a syntax error with the message:
 *     'Wrong number of arguments in function <fn> (<count> provided, <min>-<max> expected)'
 * @param {string} fn     Function name
 * @param {number} count  Actual argument count
 * @param {number} min    Minimum required argument count
 * @param {number} [max]  Maximum required argument count
 * @extends Error
 */
function ArgumentsError(fn, count, min, max) {
  if (!(this instanceof ArgumentsError)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  this.fn = fn;
  this.count = count;
  this.min = min;
  this.max = max;

  this.message = 'Wrong number of arguments in function ' + fn +
      ' (' + count + ' provided, ' +
      min + ((max != undefined) ? ('-' + max) : '') + ' expected)';

  this.stack = (new Error()).stack;
}

ArgumentsError.prototype = new Error();
ArgumentsError.prototype.constructor = Error;
ArgumentsError.prototype.name = 'ArgumentsError';
ArgumentsError.prototype.isArgumentsError = true;

module.exports = ArgumentsError;

},{}],11:[function(require,module,exports){
'use strict';

/**
 * Create a range error with the message:
 *     'Dimension mismatch (<actual size> != <expected size>)'
 * @param {number | number[]} actual        The actual size
 * @param {number | number[]} expected      The expected size
 * @param {string} [relation='!=']          Optional relation between actual
 *                                          and expected size: '!=', '<', etc.
 * @extends RangeError
 */
function DimensionError(actual, expected, relation) {
  if (!(this instanceof DimensionError)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  this.actual   = actual;
  this.expected = expected;
  this.relation = relation;

  this.message = 'Dimension mismatch (' +
      (Array.isArray(actual) ? ('[' + actual.join(', ') + ']') : actual) +
      ' ' + (this.relation || '!=') + ' ' +
      (Array.isArray(expected) ? ('[' + expected.join(', ') + ']') : expected) +
      ')';

  this.stack = (new Error()).stack;
}

DimensionError.prototype = new RangeError();
DimensionError.prototype.constructor = RangeError;
DimensionError.prototype.name = 'DimensionError';
DimensionError.prototype.isDimensionError = true;

module.exports = DimensionError;

},{}],12:[function(require,module,exports){
'use strict';

/**
 * Create a range error with the message:
 *     'Index out of range (index < min)'
 *     'Index out of range (index < max)'
 *
 * @param {number} index     The actual index
 * @param {number} [min=0]   Minimum index (included)
 * @param {number} [max]     Maximum index (excluded)
 * @extends RangeError
 */
function IndexError(index, min, max) {
  if (!(this instanceof IndexError)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  this.index = index;
  if (arguments.length < 3) {
    this.min = 0;
    this.max = min;
  }
  else {
    this.min = min;
    this.max = max;
  }

  if (this.min !== undefined && this.index < this.min) {
    this.message = 'Index out of range (' + this.index + ' < ' + this.min + ')';
  }
  else if (this.max !== undefined && this.index >= this.max) {
    this.message = 'Index out of range (' + this.index + ' > ' + (this.max - 1) + ')';
  }
  else {
    this.message = 'Index out of range (' + this.index + ')';
  }

  this.stack = (new Error()).stack;
}

IndexError.prototype = new RangeError();
IndexError.prototype.constructor = RangeError;
IndexError.prototype.name = 'IndexError';
IndexError.prototype.isIndexError = true;

module.exports = IndexError;

},{}],13:[function(require,module,exports){
'use strict';

var ArgumentsError = require('./ArgumentsError');
var DimensionError = require('./DimensionError');
var IndexError = require('./IndexError');

module.exports = [
  {
    name: 'ArgumentsError', path: 'error',
    factory: function () {
      return ArgumentsError;
    }
  },
  {
    name: 'DimensionError',
    path: 'error',
    factory: function () {
      return DimensionError;
    }
  },
  {
    name: 'IndexError',
    path: 'error',
    factory: function () {
      return IndexError;
    }
  }
];

// TODO: implement an InvalidValueError?

},{"./ArgumentsError":10,"./DimensionError":11,"./IndexError":12}],14:[function(require,module,exports){
'use strict';

var object = require('../utils/object');
var string = require('../utils/string');

function factory (type, config, load, typed) {
  var parser = load(require('./function/parser'))();

  /**
   * Documentation object
   * @param {Object} doc  Object containing properties:
   *                      {string} name
   *                      {string} category
   *                      {string} description
   *                      {string[]} syntax
   *                      {string[]} examples
   *                      {string[]} seealso
   * @constructor
   */
  function Help(doc) {
    if (!(this instanceof Help)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    if (!doc)  throw new Error('Argument "doc" missing');

    this.doc = doc;
  }

  /**
   * Attach type information
   */
  Help.prototype.type = 'Help';
  Help.prototype.isHelp = true;

  /**
   * Generate a string representation of the Help object
   * @return {string} Returns a string
   * @private
   */
  Help.prototype.toString = function () {
    var doc = this.doc || {};
    var desc = '\n';

    if (doc.name) {
      desc += 'Name: ' + doc.name + '\n\n';
    }
    if (doc.category) {
      desc += 'Category: ' + doc.category + '\n\n';
    }
    if (doc.description) {
      desc += 'Description:\n    ' + doc.description + '\n\n';
    }
    if (doc.syntax) {
      desc += 'Syntax:\n    ' + doc.syntax.join('\n    ') + '\n\n';
    }
    if (doc.examples) {
      desc += 'Examples:\n';
      for (var i = 0; i < doc.examples.length; i++) {
        var expr = doc.examples[i];
        desc += '    ' + expr + '\n';

        var res;
        try {
          res = parser.eval(expr);
        }
        catch (e) {
          res = e;
        }
        if (res && !res.isHelp) {
          desc += '        ' + string.format(res, {precision: 14}) + '\n';
        }
      }
      desc += '\n';
    }
    if (doc.seealso) {
      desc += 'See also: ' + doc.seealso.join(', ') + '\n';
    }

    return desc;
  };

  /**
   * Export the help object to JSON
   */
  Help.prototype.toJSON = function () {
    var obj = object.clone(this.doc);
    obj.mathjs = 'Help';
    return obj;
  };

  /**
   * Instantiate a Help object from a JSON object
   * @param {Object} json
   * @returns {Help} Returns a new Help object
   */
  Help.fromJSON = function (json) {
    var doc = {};
    for (var prop in json) {
      if (prop !== 'mathjs') { // ignore mathjs field
        doc[prop] = json[prop];
      }
    }
    return new Help(doc);
  };

  /**
   * Returns a string representation of the Help object
   */
  Help.prototype.valueOf = Help.prototype.toString;

  return Help;
}

exports.name = 'Help';
exports.path = 'type';
exports.factory = factory;

},{"../utils/object":484,"../utils/string":485,"./function/parser":193}],15:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed, math) {
  var _parse = load(require('./parse'));

  /**
   * @constructor Parser
   * Parser contains methods to evaluate or parse expressions, and has a number
   * of convenience methods to get, set, and remove variables from memory. Parser
   * keeps a scope containing variables in memory, which is used for all
   * evaluations.
   *
   * Methods:
   *    var result = parser.eval(expr);    // evaluate an expression
   *    var value = parser.get(name);      // retrieve a variable from the parser
   *    parser.set(name, value);           // set a variable in the parser
   *    parser.remove(name);               // clear a variable from the
   *                                       // parsers scope
   *    parser.clear();                    // clear the parsers scope
   *
   * Example usage:
   *    var parser = new Parser();
   *    // Note: there is a convenience method which can be used instead:
   *    // var parser = new math.parser();
   *
   *    // evaluate expressions
   *    parser.eval('sqrt(3^2 + 4^2)');         // 5
   *    parser.eval('sqrt(-4)');                // 2i
   *    parser.eval('2 inch in cm');            // 5.08 cm
   *    parser.eval('cos(45 deg)');             // 0.7071067811865476
   *
   *    // define variables and functions
   *    parser.eval('x = 7 / 2');               // 3.5
   *    parser.eval('x + 3');                   // 6.5
   *    parser.eval('function f(x, y) = x^y');  // f(x, y)
   *    parser.eval('f(2, 3)');                 // 8
   *
   *    // get and set variables and functions
   *    var x = parser.get('x');                // 7
   *    var f = parser.get('f');                // function
   *    var g = f(3, 2);                        // 9
   *    parser.set('h', 500);
   *    var i = parser.eval('h / 2');           // 250
   *    parser.set('hello', function (name) {
   *        return 'hello, ' + name + '!';
   *    });
   *    parser.eval('hello("user")');           // "hello, user!"
   *
   *    // clear defined functions and variables
   *    parser.clear();
   *
   */
  function Parser() {
    if (!(this instanceof Parser)) {
      throw new SyntaxError(
          'Constructor must be called with the new operator');
    }
    this.scope = {};
  }

  /**
   * Attach type information
   */
  Parser.prototype.type = 'Parser';
  Parser.prototype.isParser = true;

  /**
   * Parse an expression and return the parsed function node.
   * The node tree can be compiled via `code = node.compile(math)`,
   * and the compiled code can be executed as `code.eval([scope])`
   * @param {string} expr
   * @return {Node} node
   * @throws {Error}
   */
  Parser.prototype.parse = function (expr) {
    throw new Error('Parser.parse is deprecated. Use math.parse instead.');
  };

  /**
   * Parse and compile an expression, return the compiled javascript code.
   * The node can be evaluated via code.eval([scope])
   * @param {string} expr
   * @return {{eval: function}} code
   * @throws {Error}
   */
  Parser.prototype.compile = function (expr) {
    throw new Error('Parser.compile is deprecated. Use math.compile instead.');
  };

  /**
   * Parse and evaluate the given expression
   * @param {string} expr   A string containing an expression, for example "2+3"
   * @return {*} result     The result, or undefined when the expression was empty
   * @throws {Error}
   */
  Parser.prototype.eval = function (expr) {
    // TODO: validate arguments
    return _parse(expr)
        .compile()
        .eval(this.scope);
  };

  /**
   * Get a variable (a function or variable) by name from the parsers scope.
   * Returns undefined when not found
   * @param {string} name
   * @return {* | undefined} value
   */
  Parser.prototype.get = function (name) {
    // TODO: validate arguments
    return this.scope[name];
  };

  /**
   * Set a symbol (a function or variable) by name from the parsers scope.
   * @param {string} name
   * @param {* | undefined} value
   */
  Parser.prototype.set = function (name, value) {
    // TODO: validate arguments
    return this.scope[name] = value;
  };

  /**
   * Remove a variable from the parsers scope
   * @param {string} name
   */
  Parser.prototype.remove = function (name) {
    // TODO: validate arguments
    delete this.scope[name];
  };

  /**
   * Clear the scope with variables and functions
   */
  Parser.prototype.clear = function () {
    for (var name in this.scope) {
      if (this.scope.hasOwnProperty(name)) {
        delete this.scope[name];
      }
    }
  };

  return Parser;
}

exports.name = 'Parser';
exports.path = 'expression';
exports.factory = factory;
exports.math = true; // requires the math namespace as 5th argument

},{"./parse":216}],16:[function(require,module,exports){
module.exports = {
  'name': 'Infinity',
  'category': 'Constants',
  'syntax': [
    'Infinity'
  ],
  'description': 'Infinity, a number which is larger than the maximum number that can be handled by a floating point number.',
  'examples': [
    'Infinity',
    '1 / 0'
  ],
  'seealso': []
};

},{}],17:[function(require,module,exports){
module.exports = {
  'name': 'LN10',
  'category': 'Constants',
  'syntax': [
    'LN10'
  ],
  'description': 'Returns the natural logarithm of 10, approximately equal to 2.302',
  'examples': [
    'LN10',
    'log(10)'
  ],
  'seealso': []
};

},{}],18:[function(require,module,exports){
module.exports = {
  'name': 'LN2',
  'category': 'Constants',
  'syntax': [
    'LN2'
  ],
  'description': 'Returns the natural logarithm of 2, approximately equal to 0.693',
  'examples': [
    'LN2',
    'log(2)'
  ],
  'seealso': []
};

},{}],19:[function(require,module,exports){
module.exports = {
  'name': 'LOG10E',
  'category': 'Constants',
  'syntax': [
    'LOG10E'
  ],
  'description': 'Returns the base-10 logarithm of E, approximately equal to 0.434',
  'examples': [
    'LOG10E',
    'log(e, 10)'
  ],
  'seealso': []
};

},{}],20:[function(require,module,exports){
module.exports = {
  'name': 'LOG2E',
  'category': 'Constants',
  'syntax': [
    'LOG2E'
  ],
  'description': 'Returns the base-2 logarithm of E, approximately equal to 1.442',
  'examples': [
    'LOG2E',
    'log(e, 2)'
  ],
  'seealso': []
};

},{}],21:[function(require,module,exports){
module.exports = {
  'name': 'NaN',
  'category': 'Constants',
  'syntax': [
    'NaN'
  ],
  'description': 'Not a number',
  'examples': [
    'NaN',
    '0 / 0'
  ],
  'seealso': []
};

},{}],22:[function(require,module,exports){
module.exports = {
  'name': 'SQRT1_2',
  'category': 'Constants',
  'syntax': [
    'SQRT1_2'
  ],
  'description': 'Returns the square root of 1/2, approximately equal to 0.707',
  'examples': [
    'SQRT1_2',
    'sqrt(1/2)'
  ],
  'seealso': []
};

},{}],23:[function(require,module,exports){
module.exports = {
  'name': 'SQRT2',
  'category': 'Constants',
  'syntax': [
    'SQRT2'
  ],
  'description': 'Returns the square root of 2, approximately equal to 1.414',
  'examples': [
    'SQRT2',
    'sqrt(2)'
  ],
  'seealso': []
};

},{}],24:[function(require,module,exports){
module.exports = {
  'name': 'e',
  'category': 'Constants',
  'syntax': [
    'e'
  ],
  'description': 'Euler\'s number, the base of the natural logarithm. Approximately equal to 2.71828',
  'examples': [
    'e',
    'e ^ 2',
    'exp(2)',
    'log(e)'
  ],
  'seealso': ['exp']
};

},{}],25:[function(require,module,exports){
module.exports = {
  'name': 'false',
  'category': 'Constants',
  'syntax': [
    'false'
  ],
  'description': 'Boolean value false',
  'examples': [
    'false'
  ],
  'seealso': ['true']
};

},{}],26:[function(require,module,exports){
module.exports = {
  'name': 'i',
  'category': 'Constants',
  'syntax': [
    'i'
  ],
  'description': 'Imaginary unit, defined as i*i=-1. A complex number is described as a + b*i, where a is the real part, and b is the imaginary part.',
  'examples': [
    'i',
    'i * i',
    'sqrt(-1)'
  ],
  'seealso': []
};

},{}],27:[function(require,module,exports){
module.exports = {
  'name': 'null',
  'category': 'Constants',
  'syntax': [
    'null'
  ],
  'description': 'Value null',
  'examples': [
    'null'
  ],
  'seealso': ['true', 'false']
};

},{}],28:[function(require,module,exports){
module.exports = {
  'name': 'phi',
  'category': 'Constants',
  'syntax': [
    'phi'
  ],
  'description': 'Phi is the golden ratio. Two quantities are in the golden ratio if their ratio is the same as the ratio of their sum to the larger of the two quantities. Phi is defined as `(1 + sqrt(5)) / 2` and is approximately 1.618034...',
  'examples': [
    'tau'
  ],
  'seealso': []
};

},{}],29:[function(require,module,exports){
module.exports = {
  'name': 'pi',
  'category': 'Constants',
  'syntax': [
    'pi'
  ],
  'description': 'The number pi is a mathematical constant that is the ratio of a circle\'s circumference to its diameter, and is approximately equal to 3.14159',
  'examples': [
    'pi',
    'sin(pi/2)'
  ],
  'seealso': ['tau']
};

},{}],30:[function(require,module,exports){
module.exports = {
  'name': 'tau',
  'category': 'Constants',
  'syntax': [
    'tau'
  ],
  'description': 'Tau is the ratio constant of a circle\'s circumference to radius, equal to 2 * pi, approximately 6.2832.',
  'examples': [
    'tau',
    '2 * pi'
  ],
  'seealso': ['pi']
};

},{}],31:[function(require,module,exports){
module.exports = {
  'name': 'true',
  'category': 'Constants',
  'syntax': [
    'true'
  ],
  'description': 'Boolean value true',
  'examples': [
    'true'
  ],
  'seealso': ['false']
};

},{}],32:[function(require,module,exports){
module.exports = {
  'name': 'version',
  'category': 'Constants',
  'syntax': [
    'version'
  ],
  'description': 'A string with the version number of math.js',
  'examples': [
    'version'
  ],
  'seealso': []
};

},{}],33:[function(require,module,exports){
module.exports = {
  'name': 'bignumber',
  'category': 'Construction',
  'syntax': [
    'bignumber(x)'
  ],
  'description':
      'Create a big number from a number or string.',
  'examples': [
    '0.1 + 0.2',
    'bignumber(0.1) + bignumber(0.2)',
    'bignumber("7.2")',
    'bignumber("7.2e500")',
    'bignumber([0.1, 0.2, 0.3])'
  ],
  'seealso': [
    'boolean', 'complex', 'fraction', 'index', 'matrix', 'string', 'unit'
  ]
};

},{}],34:[function(require,module,exports){
module.exports = {
  'name': 'boolean',
  'category': 'Construction',
  'syntax': [
    'x',
    'boolean(x)'
  ],
  'description':
      'Convert a string or number into a boolean.',
  'examples': [
    'boolean(0)',
    'boolean(1)',
    'boolean(3)',
    'boolean("true")',
    'boolean("false")',
    'boolean([1, 0, 1, 1])'
  ],
  'seealso': [
    'bignumber', 'complex', 'index', 'matrix', 'number', 'string', 'unit'
  ]
};

},{}],35:[function(require,module,exports){
module.exports = {
  'name': 'complex',
  'category': 'Construction',
  'syntax': [
    'complex()',
    'complex(re, im)',
    'complex(string)'
  ],
  'description':
      'Create a complex number.',
  'examples': [
    'complex()',
    'complex(2, 3)',
    'complex("7 - 2i")'
  ],
  'seealso': [
    'bignumber', 'boolean', 'index', 'matrix', 'number', 'string', 'unit'
  ]
};

},{}],36:[function(require,module,exports){
module.exports = {
  'name': 'fraction',
  'category': 'Construction',
  'syntax': [
    'fraction(num)',
    'fraction(num,den)'
  ],
  'description':
    'Create a fraction from a number or from a numerator and denominator.',
  'examples': [
    'fraction(0.125)',
    'fraction(1, 3) + fraction(2, 5)'
  ],
  'seealso': [
    'bignumber', 'boolean', 'complex', 'index', 'matrix', 'string', 'unit'
  ]
};

},{}],37:[function(require,module,exports){
module.exports = {
  'name': 'index',
  'category': 'Construction',
  'syntax': [
    '[start]',
    '[start:end]',
    '[start:step:end]',
    '[start1, start 2, ...]',
    '[start1:end1, start2:end2, ...]',
    '[start1:step1:end1, start2:step2:end2, ...]'
  ],
  'description':
      'Create an index to get or replace a subset of a matrix',
  'examples': [
    '[]',
    '[1, 2, 3]',
    'A = [1, 2, 3; 4, 5, 6]',
    'A[1, :]',
    'A[1, 2] = 50',
    'A[0:2, 0:2] = ones(2, 2)'
  ],
  'seealso': [
    'bignumber', 'boolean', 'complex', 'matrix,', 'number', 'range', 'string', 'unit'
  ]
};

},{}],38:[function(require,module,exports){
module.exports = {
  'name': 'matrix',
  'category': 'Construction',
  'syntax': [
    '[]',
    '[a1, b1, ...; a2, b2, ...]',
    'matrix()',
    'matrix("dense")',
    'matrix([...])'
  ],
  'description':
      'Create a matrix.',
  'examples': [
    '[]',
    '[1, 2, 3]',
    '[1, 2, 3; 4, 5, 6]',
    'matrix()',
    'matrix([3, 4])',
    'matrix([3, 4; 5, 6], "sparse")',
    'matrix([3, 4; 5, 6], "sparse", "number")'
  ],
  'seealso': [
    'bignumber', 'boolean', 'complex', 'index', 'number', 'string', 'unit', 'sparse'
  ]
};

},{}],39:[function(require,module,exports){
module.exports = {
  'name': 'number',
  'category': 'Construction',
  'syntax': [
    'x',
    'number(x)'
  ],
  'description':
      'Create a number or convert a string or boolean into a number.',
  'examples': [
    '2',
    '2e3',
    '4.05',
    'number(2)',
    'number("7.2")',
    'number(true)',
    'number([true, false, true, true])',
    'number("52cm", "m")'
  ],
  'seealso': [
    'bignumber', 'boolean', 'complex', 'fraction', 'index', 'matrix', 'string', 'unit'
  ]
};

},{}],40:[function(require,module,exports){
module.exports = {
  'name': 'sparse',
  'category': 'Construction',
  'syntax': [
    'sparse()',
    'sparse([a1, b1, ...; a1, b2, ...])',
    'sparse([a1, b1, ...; a1, b2, ...], "number")'
  ],
  'description':
  'Create a sparse matrix.',
  'examples': [
    'sparse()',
    'sparse([3, 4; 5, 6])',
    'sparse([3, 0; 5, 0], "number")'
  ],
  'seealso': [
    'bignumber', 'boolean', 'complex', 'index', 'number', 'string', 'unit', 'matrix'
  ]
};

},{}],41:[function(require,module,exports){
module.exports = {
  'name': 'string',
  'category': 'Construction',
  'syntax': [
    '"text"',
    'string(x)'
  ],
  'description':
      'Create a string or convert a value to a string',
  'examples': [
    '"Hello World!"',
    'string(4.2)',
    'string(3 + 2i)'
  ],
  'seealso': [
    'bignumber', 'boolean', 'complex', 'index', 'matrix', 'number', 'unit'
  ]
};

},{}],42:[function(require,module,exports){
module.exports = {
  'name': 'unit',
  'category': 'Construction',
  'syntax': [
    'value unit',
    'unit(value, unit)',
    'unit(string)'
  ],
  'description':
      'Create a unit.',
  'examples': [
    '5.5 mm',
    '3 inch',
    'unit(7.1, "kilogram")',
    'unit("23 deg")'
  ],
  'seealso': [
    'bignumber', 'boolean', 'complex', 'index', 'matrix', 'number', 'string'
  ]
};

},{}],43:[function(require,module,exports){
module.exports = {
  'name': 'config',
  'category': 'Core',
  'syntax': [
    'config()',
    'config(options)'
  ],
  'description': 'Get configuration or change configuration.',
  'examples': [
    'config()',
    '1/3 + 1/4',
    'config({number: "Fraction"})',
    '1/3 + 1/4'
  ],
  'seealso': []
};

},{}],44:[function(require,module,exports){
module.exports = {
  'name': 'import',
  'category': 'Core',
  'syntax': [
    'import(functions)',
    'import(functions, options)'
  ],
  'description': 'Import functions or constants from an object.',
  'examples': [
    'import({myFn: f(x)=x^2, myConstant: 32 })',
    'myFn(2)',
    'myConstant'
  ],
  'seealso': []
};

},{}],45:[function(require,module,exports){
module.exports = {
  'name': 'typed',
  'category': 'Core',
  'syntax': [
    'typed(signatures)',
    'typed(name, signatures)'
  ],
  'description': 'Create a typed function.',
  'examples': [
    'double = typed({ "number, number": f(x)=x+x })',
    'double(2)',
    'double("hello")'
  ],
  'seealso': []
};

},{}],46:[function(require,module,exports){
module.exports = {
  'name': 'lsolve',
  'category': 'Algebra',
  'syntax': [
    'x=lsolve(L, b)'
  ],
  'description':
  'Solves the linear system L * x = b where L is an [n x n] lower triangular matrix and b is a [n] column vector.',
  'examples': [
    'a = [-2, 3; 2, 1]',
    'b = [11, 9]',
    'x = lsolve(a, b)'
  ],
  'seealso': [
    'lup', 'lusolve', 'usolve', 'matrix', 'sparse'
  ]
};

},{}],47:[function(require,module,exports){
module.exports = {
  'name': 'lup',
  'category': 'Algebra',
  'syntax': [
    'lup(m)'
  ],
  'description':
  'Calculate the Matrix LU decomposition with partial pivoting. Matrix A is decomposed in three matrices (L, U, P) where P * A = L * U',
  'examples': [
    'lup([[2, 1], [1, 4]])',
    'lup(matrix([[2, 1], [1, 4]]))',
    'lup(sparse([[2, 1], [1, 4]]))'
  ],
  'seealso': [
    'lusolve', 'lsolve', 'usolve', 'matrix', 'sparse', 'slu'
  ]
};

},{}],48:[function(require,module,exports){
module.exports = {
  'name': 'lusolve',
  'category': 'Algebra',
  'syntax': [
    'x=lusolve(A, b)',
    'x=lusolve(lu, b)'
  ],
  'description': 'Solves the linear system A * x = b where A is an [n x n] matrix and b is a [n] column vector.',
  'examples': [
    'a = [-2, 3; 2, 1]',
    'b = [11, 9]',
    'x = lusolve(a, b)'
  ],
  'seealso': [
    'lup', 'slu', 'lsolve', 'usolve', 'matrix', 'sparse'
  ]
};

},{}],49:[function(require,module,exports){
module.exports = {
  'name': 'slu',
  'category': 'Algebra',
  'syntax': [
    'slu(A, order, threshold)'
  ],
  'description': 'Calculate the Matrix LU decomposition with full pivoting. Matrix A is decomposed in two matrices (L, U) and two permutation vectors (pinv, q) where P * A * Q = L * U',
  'examples': [
    'slu(sparse([4.5, 0, 3.2, 0; 3.1, 2.9, 0, 0.9; 0, 1.7, 3, 0; 3.5, 0.4, 0, 1]), 1, 0.001)'
  ],
  'seealso': [
    'lusolve', 'lsolve', 'usolve', 'matrix', 'sparse', 'lup'
  ]
};

},{}],50:[function(require,module,exports){
module.exports = {
  'name': 'usolve',
  'category': 'Algebra',
  'syntax': [
    'x=usolve(U, b)'
  ],
  'description':
  'Solves the linear system U * x = b where U is an [n x n] upper triangular matrix and b is a [n] column vector.',
  'examples': [
    'x=usolve(sparse([1, 1, 1, 1; 0, 1, 1, 1; 0, 0, 1, 1; 0, 0, 0, 1]), [1; 2; 3; 4])'
  ],
  'seealso': [
    'lup', 'lusolve', 'lsolve', 'matrix', 'sparse'
  ]
};

},{}],51:[function(require,module,exports){
module.exports = {
  'name': 'abs',
  'category': 'Arithmetic',
  'syntax': [
    'abs(x)'
  ],
  'description': 'Compute the absolute value.',
  'examples': [
    'abs(3.5)',
    'abs(-4.2)'
  ],
  'seealso': ['sign']
};

},{}],52:[function(require,module,exports){
module.exports = {
  'name': 'add',
  'category': 'Operators',
  'syntax': [
    'x + y',
    'add(x, y)'
  ],
  'description': 'Add two values.',
  'examples': [
    'a = 2.1 + 3.6',
    'a - 3.6',
    '3 + 2i',
    '3 cm + 2 inch',
    '"2.3" + "4"'
  ],
  'seealso': [
    'subtract'
  ]
};

},{}],53:[function(require,module,exports){
module.exports = {
  'name': 'cbrt',
  'category': 'Arithmetic',
  'syntax': [
    'cbrt(x)',
    'cbrt(x, allRoots)'
  ],
  'description':
      'Compute the cubic root value. If x = y * y * y, then y is the cubic root of x. When `x` is a number or complex number, an optional second argument `allRoots` can be provided to return all three cubic roots. If not provided, the principal root is returned',
  'examples': [
    'cbrt(64)',
    'cube(4)',
    'cbrt(-8)',
    'cbrt(2 + 3i)',
    'cbrt(8i)',
    'cbrt(8i, true)',
    'cbrt(27 m^3)'
  ],
  'seealso': [
    'square',
    'sqrt',
    'cube',
    'multiply'
  ]
};

},{}],54:[function(require,module,exports){
module.exports = {
  'name': 'ceil',
  'category': 'Arithmetic',
  'syntax': [
    'ceil(x)'
  ],
  'description':
      'Round a value towards plus infinity. If x is complex, both real and imaginary part are rounded towards plus infinity.',
  'examples': [
    'ceil(3.2)',
    'ceil(3.8)',
    'ceil(-4.2)'
  ],
  'seealso': ['floor', 'fix', 'round']
};

},{}],55:[function(require,module,exports){
module.exports = {
  'name': 'cube',
  'category': 'Arithmetic',
  'syntax': [
    'cube(x)'
  ],
  'description': 'Compute the cube of a value. The cube of x is x * x * x.',
  'examples': [
    'cube(2)',
    '2^3',
    '2 * 2 * 2'
  ],
  'seealso': [
    'multiply',
    'square',
    'pow'
  ]
};

},{}],56:[function(require,module,exports){
module.exports = {
  'name': 'divide',
  'category': 'Operators',
  'syntax': [
    'x / y',
    'divide(x, y)'
  ],
  'description': 'Divide two values.',
  'examples': [
    'a = 2 / 3',
    'a * 3',
    '4.5 / 2',
    '3 + 4 / 2',
    '(3 + 4) / 2',
    '18 km / 4.5'
  ],
  'seealso': [
    'multiply'
  ]
};

},{}],57:[function(require,module,exports){
module.exports = {
  'name': 'dotDivide',
  'category': 'Operators',
  'syntax': [
    'x ./ y',
    'dotDivide(x, y)'
  ],
  'description': 'Divide two values element wise.',
  'examples': [
    'a = [1, 2, 3; 4, 5, 6]',
    'b = [2, 1, 1; 3, 2, 5]',
    'a ./ b'
  ],
  'seealso': [
    'multiply',
    'dotMultiply',
    'divide'
  ]
};

},{}],58:[function(require,module,exports){
module.exports = {
  'name': 'dotMultiply',
  'category': 'Operators',
  'syntax': [
    'x .* y',
    'dotMultiply(x, y)'
  ],
  'description': 'Multiply two values element wise.',
  'examples': [
    'a = [1, 2, 3; 4, 5, 6]',
    'b = [2, 1, 1; 3, 2, 5]',
    'a .* b'
  ],
  'seealso': [
    'multiply',
    'divide',
    'dotDivide'
  ]
};

},{}],59:[function(require,module,exports){
module.exports = {
  'name': 'dotpow',
  'category': 'Operators',
  'syntax': [
    'x .^ y',
    'dotpow(x, y)'
  ],
  'description':
      'Calculates the power of x to y element wise.',
  'examples': [
    'a = [1, 2, 3; 4, 5, 6]',
    'a .^ 2'
  ],
  'seealso': [
    'pow'
  ]
};

},{}],60:[function(require,module,exports){
module.exports = {
  'name': 'exp',
  'category': 'Arithmetic',
  'syntax': [
    'exp(x)'
  ],
  'description': 'Calculate the exponent of a value.',
  'examples': [
    'exp(1.3)',
    'e ^ 1.3',
    'log(exp(1.3))',
    'x = 2.4',
    '(exp(i*x) == cos(x) + i*sin(x))   # Euler\'s formula'
  ],
  'seealso': [
    'pow',
    'log'
  ]
};

},{}],61:[function(require,module,exports){
module.exports = {
  'name': 'fix',
  'category': 'Arithmetic',
  'syntax': [
    'fix(x)'
  ],
  'description':
      'Round a value towards zero. If x is complex, both real and imaginary part are rounded towards zero.',
  'examples': [
    'fix(3.2)',
    'fix(3.8)',
    'fix(-4.2)',
    'fix(-4.8)'
  ],
  'seealso': ['ceil', 'floor', 'round']
};

},{}],62:[function(require,module,exports){
module.exports = {
  'name': 'floor',
  'category': 'Arithmetic',
  'syntax': [
    'floor(x)'
  ],
  'description':
      'Round a value towards minus infinity.If x is complex, both real and imaginary part are rounded towards minus infinity.',
  'examples': [
    'floor(3.2)',
    'floor(3.8)',
    'floor(-4.2)'
  ],
  'seealso': ['ceil', 'fix', 'round']
};

},{}],63:[function(require,module,exports){
module.exports = {
  'name': 'gcd',
  'category': 'Arithmetic',
  'syntax': [
    'gcd(a, b)',
    'gcd(a, b, c, ...)'
  ],
  'description': 'Compute the greatest common divisor.',
  'examples': [
    'gcd(8, 12)',
    'gcd(-4, 6)',
    'gcd(25, 15, -10)'
  ],
  'seealso': [ 'lcm', 'xgcd' ]
};

},{}],64:[function(require,module,exports){
module.exports = {
  'name': 'hypot',
  'category': 'Arithmetic',
  'syntax': [
    'hypot(a, b, c, ...)',
    'hypot([a, b, c, ...])'
  ],
  'description': 'Calculate the hypotenusa of a list with values. ',
  'examples': [
    'hypot(3, 4)',
    'sqrt(3^2 + 4^2)',
    'hypot(-2)',
    'hypot([3, 4, 5])'
  ],
  'seealso': [ 'abs', 'norm' ]
};

},{}],65:[function(require,module,exports){
module.exports = {
  'name': 'lcm',
  'category': 'Arithmetic',
  'syntax': [
    'lcm(x, y)'
  ],
  'description': 'Compute the least common multiple.',
  'examples': [
    'lcm(4, 6)',
    'lcm(6, 21)',
    'lcm(6, 21, 5)'
  ],
  'seealso': [ 'gcd' ]
};

},{}],66:[function(require,module,exports){
module.exports = {
  'name': 'log',
  'category': 'Arithmetic',
  'syntax': [
    'log(x)',
    'log(x, base)'
  ],
  'description': 'Compute the logarithm of a value. If no base is provided, the natural logarithm of x is calculated. If base if provided, the logarithm is calculated for the specified base. log(x, base) is defined as log(x) / log(base).',
  'examples': [
    'log(3.5)',
    'a = log(2.4)',
    'exp(a)',
    '10 ^ 4',
    'log(10000, 10)',
    'log(10000) / log(10)',
    'b = log(1024, 2)',
    '2 ^ b'
  ],
  'seealso': [
    'exp',
    'log10'
  ]
};
},{}],67:[function(require,module,exports){
module.exports = {
  'name': 'log10',
  'category': 'Arithmetic',
  'syntax': [
    'log10(x)'
  ],
  'description': 'Compute the 10-base logarithm of a value.',
  'examples': [
    'log10(0.00001)',
    'log10(10000)',
    '10 ^ 4',
    'log(10000) / log(10)',
    'log(10000, 10)'
  ],
  'seealso': [
    'exp',
    'log'
  ]
};

},{}],68:[function(require,module,exports){
module.exports = {
  'name': 'mod',
  'category': 'Operators',
  'syntax': [
    'x % y',
    'x mod y',
    'mod(x, y)'
  ],
  'description':
      'Calculates the modulus, the remainder of an integer division.',
  'examples': [
    '7 % 3',
    '11 % 2',
    '10 mod 4',
    'function isOdd(x) = x % 2',
    'isOdd(2)',
    'isOdd(3)'
  ],
  'seealso': ['divide']
};

},{}],69:[function(require,module,exports){
module.exports = {
  'name': 'multiply',
  'category': 'Operators',
  'syntax': [
    'x * y',
    'multiply(x, y)'
  ],
  'description': 'multiply two values.',
  'examples': [
    'a = 2.1 * 3.4',
    'a / 3.4',
    '2 * 3 + 4',
    '2 * (3 + 4)',
    '3 * 2.1 km'
  ],
  'seealso': [
    'divide'
  ]
};

},{}],70:[function(require,module,exports){
module.exports = {
  'name': 'norm',
  'category': 'Arithmetic',
  'syntax': [
    'norm(x)',
    'norm(x, p)'
  ],
  'description': 'Calculate the norm of a number, vector or matrix.',
  'examples': [
    'abs(-3.5)',
    'norm(-3.5)',
    'norm(3 - 4i))',
    'norm([1, 2, -3], Infinity)',
    'norm([1, 2, -3], -Infinity)',
    'norm([3, 4], 2)',
    'norm([[1, 2], [3, 4]], 1)',
    'norm([[1, 2], [3, 4]], \'inf\')',
    'norm([[1, 2], [3, 4]], \'fro\')'
  ]
};

},{}],71:[function(require,module,exports){
module.exports = {
  'name': 'nthRoot',
  'category': 'Arithmetic',
  'syntax': [
    'nthRoot(a)',
    'nthRoot(a, root)'
  ],
  'description': 'Calculate the nth root of a value. ' +
      'The principal nth root of a positive real number A, ' +
      'is the positive real solution of the equation "x^root = A".',
  'examples': [
    '4 ^ 3',
    'nthRoot(64, 3)',
    'nthRoot(9, 2)',
    'sqrt(9)'
  ],
  'seealso': [
    'sqrt',
    'pow'
  ]
};
},{}],72:[function(require,module,exports){
module.exports = {
  'name': 'pow',
  'category': 'Operators',
  'syntax': [
    'x ^ y',
    'pow(x, y)'
  ],
  'description':
      'Calculates the power of x to y, x^y.',
  'examples': [
    '2^3 = 8',
    '2*2*2',
    '1 + e ^ (pi * i)'
  ],
  'seealso': [ 'multiply' ]
};

},{}],73:[function(require,module,exports){
module.exports = {
  'name': 'round',
  'category': 'Arithmetic',
  'syntax': [
    'round(x)',
    'round(x, n)'
  ],
  'description':
      'round a value towards the nearest integer.If x is complex, both real and imaginary part are rounded towards the nearest integer. When n is specified, the value is rounded to n decimals.',
  'examples': [
    'round(3.2)',
    'round(3.8)',
    'round(-4.2)',
    'round(-4.8)',
    'round(pi, 3)',
    'round(123.45678, 2)'
  ],
  'seealso': ['ceil', 'floor', 'fix']
};

},{}],74:[function(require,module,exports){
module.exports = {
  'name': 'sign',
  'category': 'Arithmetic',
  'syntax': [
    'sign(x)'
  ],
  'description':
      'Compute the sign of a value. The sign of a value x is 1 when x>1, -1 when x<0, and 0 when x=0.',
  'examples': [
    'sign(3.5)',
    'sign(-4.2)',
    'sign(0)'
  ],
  'seealso': [
    'abs'
  ]
};

},{}],75:[function(require,module,exports){
module.exports = {
  'name': 'sqrt',
  'category': 'Arithmetic',
  'syntax': [
    'sqrt(x)'
  ],
  'description':
      'Compute the square root value. If x = y * y, then y is the square root of x.',
  'examples': [
    'sqrt(25)',
    '5 * 5',
    'sqrt(-1)'
  ],
  'seealso': [
    'square',
    'multiply'
  ]
};

},{}],76:[function(require,module,exports){
module.exports = {
  'name': 'square',
  'category': 'Arithmetic',
  'syntax': [
    'square(x)'
  ],
  'description':
      'Compute the square of a value. The square of x is x * x.',
  'examples': [
    'square(3)',
    'sqrt(9)',
    '3^2',
    '3 * 3'
  ],
  'seealso': [
    'multiply',
    'pow',
    'sqrt',
    'cube'
  ]
};

},{}],77:[function(require,module,exports){
module.exports = {
  'name': 'subtract',
  'category': 'Operators',
  'syntax': [
    'x - y',
    'subtract(x, y)'
  ],
  'description': 'subtract two values.',
  'examples': [
    'a = 5.3 - 2',
    'a + 2',
    '2/3 - 1/6',
    '2 * 3 - 3',
    '2.1 km - 500m'
  ],
  'seealso': [
    'add'
  ]
};

},{}],78:[function(require,module,exports){
module.exports = {
  'name': 'unaryMinus',
  'category': 'Operators',
  'syntax': [
    '-x',
    'unaryMinus(x)'
  ],
  'description':
      'Inverse the sign of a value. Converts booleans and strings to numbers.',
  'examples': [
    '-4.5',
    '-(-5.6)',
    '-"22"'
  ],
  'seealso': [
    'add', 'subtract', 'unaryPlus'
  ]
};

},{}],79:[function(require,module,exports){
module.exports = {
  'name': 'unaryPlus',
  'category': 'Operators',
  'syntax': [
    '+x',
    'unaryPlus(x)'
  ],
  'description':
      'Converts booleans and strings to numbers.',
  'examples': [
    '+true',
    '+"2"'
  ],
  'seealso': [
    'add', 'subtract', 'unaryMinus'
  ]
};

},{}],80:[function(require,module,exports){
module.exports = {
  'name': 'xgcd',
  'category': 'Arithmetic',
  'syntax': [
    'xgcd(a, b)'
  ],
  'description': 'Calculate the extended greatest common divisor for two values',
  'examples': [
    'xgcd(8, 12)',
    'gcd(8, 12)',
    'xgcd(36163, 21199)'
  ],
  'seealso': [ 'gcd', 'lcm' ]
};

},{}],81:[function(require,module,exports){
module.exports = {
  'name': 'bitAnd',
  'category': 'Bitwise',
  'syntax': [
    'x & y',
    'bitAnd(x, y)'
  ],
  'description': 'Bitwise AND operation. Performs the logical AND operation on each pair of the corresponding bits of the two given values by multiplying them. If both bits in the compared position are 1, the bit in the resulting binary representation is 1, otherwise, the result is 0',
  'examples': [
    '5 & 3',
    'bitAnd(53, 131)',
    '[1, 12, 31] & 42'
  ],
  'seealso': [
    'bitNot', 'bitOr', 'bitXor', 'leftShift', 'rightArithShift', 'rightLogShift'
  ]
};

},{}],82:[function(require,module,exports){
module.exports = {
  'name': 'bitNot',
  'category': 'Bitwise',
  'syntax': [
    '~x',
    'bitNot(x)'
  ],
  'description': 'Bitwise NOT operation. Performs a logical negation on each bit of the given value. Bits that are 0 become 1, and those that are 1 become 0.',
  'examples': [
    '~1',
    '~2',
    'bitNot([2, -3, 4])'
  ],
  'seealso': [
    'bitAnd', 'bitOr', 'bitXor', 'leftShift', 'rightArithShift', 'rightLogShift'
  ]
};

},{}],83:[function(require,module,exports){
module.exports = {
  'name': 'bitOr',
  'category': 'Bitwise',
  'syntax': [
    'x | y',
    'bitOr(x, y)'
  ],
  'description': 'Bitwise OR operation. Performs the logical inclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if the first bit is 1 or the second bit is 1 or both bits are 1, otherwise, the result is 0.',
  'examples': [
    '5 | 3',
    'bitOr([1, 2, 3], 4)'
  ],
  'seealso': [
    'bitAnd', 'bitNot', 'bitXor', 'leftShift', 'rightArithShift', 'rightLogShift'
  ]
};

},{}],84:[function(require,module,exports){
module.exports = {
  'name': 'bitXor',
  'category': 'Bitwise',
  'syntax': [
    'bitXor(x, y)'
  ],
  'description': 'Bitwise XOR operation, exclusive OR. Performs the logical exclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if only the first bit is 1 or only the second bit is 1, but will be 0 if both are 0 or both are 1.',
  'examples': [
    'bitOr(1, 2)',
    'bitXor([2, 3, 4], 4)'
  ],
  'seealso': [
    'bitAnd', 'bitNot', 'bitOr', 'leftShift', 'rightArithShift', 'rightLogShift'
  ]
};

},{}],85:[function(require,module,exports){
module.exports = {
  'name': 'leftShift',
  'category': 'Bitwise',
  'syntax': [
    'x << y',
    'leftShift(x, y)'
  ],
  'description': 'Bitwise left logical shift of a value x by y number of bits.',
  'examples': [
    '4 << 1',
    '8 >> 1'
  ],
  'seealso': [
    'bitAnd', 'bitNot', 'bitOr', 'bitXor', 'rightArithShift', 'rightLogShift'
  ]
};

},{}],86:[function(require,module,exports){
module.exports = {
  'name': 'rightArithShift',
  'category': 'Bitwise',
  'syntax': [
    'x >> y',
    'leftShift(x, y)'
  ],
  'description': 'Bitwise right arithmetic shift of a value x by y number of bits.',
  'examples': [
    '8 >> 1',
    '4 << 1',
    '-12 >> 2'
  ],
  'seealso': [
    'bitAnd', 'bitNot', 'bitOr', 'bitXor', 'leftShift', 'rightLogShift'
  ]
};

},{}],87:[function(require,module,exports){
module.exports = {
  'name': 'rightLogShift',
  'category': 'Bitwise',
  'syntax': [
    'x >> y',
    'leftShift(x, y)'
  ],
  'description': 'Bitwise right logical shift of a value x by y number of bits.',
  'examples': [
    '8 >>> 1',
    '4 << 1',
    '-12 >>> 2'
  ],
  'seealso': [
    'bitAnd', 'bitNot', 'bitOr', 'bitXor', 'leftShift', 'rightArithShift'
  ]
};

},{}],88:[function(require,module,exports){
module.exports = {
  'name': 'bellNumbers',
  'category': 'Combinatorics',
  'syntax': [
    'bellNumbers(n)'
  ],
  'description': 'The Bell Numbers count the number of partitions of a set. A partition is a pairwise disjoint subset of S whose union is S. `bellNumbers` only takes integer arguments. The following condition must be enforced: n >= 0.',
  'examples': [
    'bellNumbers(3)',
    'bellNumbers(8)'
  ],
  'seealso': ['stirlingS2']
};
},{}],89:[function(require,module,exports){
module.exports = {
  'name': 'catalan',
  'category': 'Combinatorics',
  'syntax': [
    'catalan(n)'
  ],
  'description': 'The Catalan Numbers enumerate combinatorial structures of many different types. catalan only takes integer arguments. The following condition must be enforced: n >= 0.',
  'examples': [
    'catalan(3)',
    'catalan(8)'
  ],
  'seealso': ['bellNumbers']
};
},{}],90:[function(require,module,exports){
module.exports = {
  'name': 'composition',
  'category': 'Combinatorics',
  'syntax': [
    'composition(n, k)'
  ],
  'description': 'The composition counts of n into k parts. composition only takes integer arguments. The following condition must be enforced: k <= n.',
  'examples': [
    'composition(5, 3)'
  ],
  'seealso': ['combinations']
};
},{}],91:[function(require,module,exports){
module.exports = {
  'name': 'stirlingS2',
  'category': 'Combinatorics',
  'syntax': [
    'stirlingS2(n, k)'
  ],
  'description': 'he Stirling numbers of the second kind, counts the number of ways to partition a set of n labelled objects into k nonempty unlabelled subsets. `stirlingS2` only takes integer arguments. The following condition must be enforced: k <= n. If n = k or k = 1, then s(n,k) = 1.',
  'examples': [
    'stirlingS2(5, 3)'
  ],
  'seealso': ['bellNumbers']
};

},{}],92:[function(require,module,exports){
module.exports = {
  'name': 'arg',
  'category': 'Complex',
  'syntax': [
    'arg(x)'
  ],
  'description':
      'Compute the argument of a complex value. If x = a+bi, the argument is computed as atan2(b, a).',
  'examples': [
    'arg(2 + 2i)',
    'atan2(3, 2)',
    'arg(2 + 3i)'
  ],
  'seealso': [
    're',
    'im',
    'conj',
    'abs'
  ]
};

},{}],93:[function(require,module,exports){
module.exports = {
  'name': 'conj',
  'category': 'Complex',
  'syntax': [
    'conj(x)'
  ],
  'description':
      'Compute the complex conjugate of a complex value. If x = a+bi, the complex conjugate is a-bi.',
  'examples': [
    'conj(2 + 3i)',
    'conj(2 - 3i)',
    'conj(-5.2i)'
  ],
  'seealso': [
    're',
    'im',
    'abs',
    'arg'
  ]
};

},{}],94:[function(require,module,exports){
module.exports = {
  'name': 'im',
  'category': 'Complex',
  'syntax': [
    'im(x)'
  ],
  'description': 'Get the imaginary part of a complex number.',
  'examples': [
    'im(2 + 3i)',
    're(2 + 3i)',
    'im(-5.2i)',
    'im(2.4)'
  ],
  'seealso': [
    're',
    'conj',
    'abs',
    'arg'
  ]
};

},{}],95:[function(require,module,exports){
module.exports = {
  'name': 're',
  'category': 'Complex',
  'syntax': [
    're(x)'
  ],
  'description': 'Get the real part of a complex number.',
  'examples': [
    're(2 + 3i)',
    'im(2 + 3i)',
    're(-5.2i)',
    're(2.4)'
  ],
  'seealso': [
    'im',
    'conj',
    'abs',
    'arg'
  ]
};

},{}],96:[function(require,module,exports){
module.exports = {
  'name': 'eval',
  'category': 'Expression',
  'syntax': [
    'eval(expression)',
    'eval([expr1, expr2, expr3, ...])'
  ],
  'description': 'Evaluate an expression or an array with expressions.',
  'examples': [
    'eval("2 + 3")',
    'eval("sqrt(" + 4 + ")")'
  ],
  'seealso': []
};

},{}],97:[function(require,module,exports){
module.exports = {
  'name': 'help',
  'category': 'Expression',
  'syntax': [
    'help(object)',
    'help(string)'
  ],
  'description': 'Display documentation on a function or data type.',
  'examples': [
    'help(sqrt)',
    'help("complex")'
  ],
  'seealso': []
};

},{}],98:[function(require,module,exports){
module.exports = {
  'name': 'distance',
  'category': 'Geometry',
  'syntax': [
    'distance([x1, y1], [x2, y2])',
    'distance([[x1, y1], [x2, y2])'
  ],
  'description': 'Calculates the Euclidean distance between two points.',
  'examples': [
    'distance([0,0], [4,4])',
    'distance([[0,0], [4,4]])'
  ],
  'seealso': []
};

},{}],99:[function(require,module,exports){
module.exports = {
  'name': 'intersect',
  'category': 'Geometry',
  'syntax': [
    'intersect(expr1, expr2, expr3, expr4)',
    'intersect(expr1, expr2, expr3)'
  ],
  'description': 'Computes the intersection point of lines and/or planes.',
  'examples': [
    'intersect([0, 0], [10, 10], [10, 0], [0, 10])',
    'intersect([1, 0, 1],  [4, -2, 2], [1, 1, 1, 6])'
  ],
  'seealso': []
};

},{}],100:[function(require,module,exports){
module.exports = {
  'name': 'and',
  'category': 'Logical',
  'syntax': [
    'x and y',
    'and(x, y)'
  ],
  'description': 'Logical and. Test whether two values are both defined with a nonzero/nonempty value.',
  'examples': [
    'true and false',
    'true and true',
    '2 and 4'
  ],
  'seealso': [
    'not', 'or', 'xor'
  ]
};

},{}],101:[function(require,module,exports){
module.exports = {
  'name': 'not',
  'category': 'Logical',
  'syntax': [
    'not x',
    'not(x)'
  ],
  'description': 'Logical not. Flips the boolean value of given argument.',
  'examples': [
    'not true',
    'not false',
    'not 2',
    'not 0'
  ],
  'seealso': [
    'and', 'or', 'xor'
  ]
};

},{}],102:[function(require,module,exports){
module.exports = {
  'name': 'or',
  'category': 'Logical',
  'syntax': [
    'x or y',
    'or(x, y)'
  ],
  'description': 'Logical or. Test if at least one value is defined with a nonzero/nonempty value.',
  'examples': [
    'true or false',
    'false or false',
    '0 or 4'
  ],
  'seealso': [
    'not', 'and', 'xor'
  ]
};

},{}],103:[function(require,module,exports){
module.exports = {
  'name': 'xor',
  'category': 'Logical',
  'syntax': [
    'x or y',
    'or(x, y)'
  ],
  'description': 'Logical exclusive or, xor. Test whether one and only one value is defined with a nonzero/nonempty value.',
  'examples': [
    'true xor false',
    'false xor false',
    'true xor true',
    '0 or 4'
  ],
  'seealso': [
    'not', 'and', 'or'
  ]
};

},{}],104:[function(require,module,exports){
module.exports = {
  'name': 'concat',
  'category': 'Matrix',
  'syntax': [
    'concat(A, B, C, ...)',
    'concat(A, B, C, ..., dim)'
  ],
  'description': 'Concatenate matrices. By default, the matrices are concatenated by the last dimension. The dimension on which to concatenate can be provided as last argument.',
  'examples': [
    'A = [1, 2; 5, 6]',
    'B = [3, 4; 7, 8]',
    'concat(A, B)',
    'concat(A, B, 1)',
    'concat(A, B, 2)'
  ],
  'seealso': [
    'det', 'diag', 'eye', 'inv', 'ones', 'range', 'size', 'squeeze', 'subset', 'trace', 'transpose', 'zeros'
  ]
};

},{}],105:[function(require,module,exports){
module.exports = {
  'name': 'cross',
  'category': 'Matrix',
  'syntax': [
    'cross(A, B)'
  ],
  'description': 'Calculate the cross product for two vectors in three dimensional space.',
  'examples': [
    'cross([1, 1, 0],  [0, 1, 1])',
    'cross([3, -3, 1], [4, 9, 2])',
    'cross([2, 3, 4],  [5, 6, 7])'
  ],
  'seealso': [
    'multiply',
    'dot'
  ]
};

},{}],106:[function(require,module,exports){
module.exports = {
  'name': 'det',
  'category': 'Matrix',
  'syntax': [
    'det(x)'
  ],
  'description': 'Calculate the determinant of a matrix',
  'examples': [
    'det([1, 2; 3, 4])',
    'det([-2, 2, 3; -1, 1, 3; 2, 0, -1])'
  ],
  'seealso': [
    'concat', 'diag', 'eye', 'inv', 'ones', 'range', 'size', 'squeeze', 'subset', 'trace', 'transpose', 'zeros'
  ]
};

},{}],107:[function(require,module,exports){
module.exports = {
  'name': 'diag',
  'category': 'Matrix',
  'syntax': [
    'diag(x)',
    'diag(x, k)'
  ],
  'description': 'Create a diagonal matrix or retrieve the diagonal of a matrix. When x is a vector, a matrix with the vector values on the diagonal will be returned. When x is a matrix, a vector with the diagonal values of the matrix is returned. When k is provided, the k-th diagonal will be filled in or retrieved, if k is positive, the values are placed on the super diagonal. When k is negative, the values are placed on the sub diagonal.',
  'examples': [
    'diag(1:3)',
    'diag(1:3, 1)',
    'a = [1, 2, 3; 4, 5, 6; 7, 8, 9]',
    'diag(a)'
  ],
  'seealso': [
    'concat', 'det', 'eye', 'inv', 'ones', 'range', 'size', 'squeeze', 'subset', 'trace', 'transpose', 'zeros'
  ]
};

},{}],108:[function(require,module,exports){
module.exports = {
  'name': 'dot',
  'category': 'Matrix',
  'syntax': [
    'dot(A, B)'
  ],
  'description': 'Calculate the dot product of two vectors. ' +
      'The dot product of A = [a1, a2, a3, ..., an] and B = [b1, b2, b3, ..., bn] ' +
      'is defined as dot(A, B) = a1 * b1 + a2 * b2 + a3 * b3 + ... + an * bn',
  'examples': [
    'dot([2, 4, 1], [2, 2, 3])',
    '[2, 4, 1] * [2, 2, 3]'
  ],
  'seealso': [
    'multiply',
    'cross'
  ]
};

},{}],109:[function(require,module,exports){
module.exports = {
  'name': 'eye',
  'category': 'Matrix',
  'syntax': [
    'eye(n)',
    'eye(m, n)',
    'eye([m, n])',
    'eye'
  ],
  'description': 'Returns the identity matrix with size m-by-n. The matrix has ones on the diagonal and zeros elsewhere.',
  'examples': [
    'eye(3)',
    'eye(3, 5)',
    'a = [1, 2, 3; 4, 5, 6]',
    'eye(size(a))'
  ],
  'seealso': [
    'concat', 'det', 'diag', 'inv', 'ones', 'range', 'size', 'squeeze', 'subset', 'trace', 'transpose', 'zeros'
  ]
};

},{}],110:[function(require,module,exports){
module.exports = {
  'name': 'filter',
  'category': 'Matrix',
  'syntax': [
    'filter(x, test)'
  ],
  'description': 'Filter items in a matrix.',
  'examples': [
    'isPositive(x) = x > 0',
    'filter([6, -2, -1, 4, 3], isPositive)',
    'filter([6, -2, 0, 1, 0], x != 0)'
  ],
  'seealso': ['sort', 'map', 'forEach']
};

},{}],111:[function(require,module,exports){
module.exports = {
  'name': 'flatten',
  'category': 'Matrix',
  'syntax': [
    'flatten(x)'
  ],
  'description': 'Flatten a multi dimensional matrix into a single dimensional matrix.',
  'examples': [
    'a = [1, 2, 3; 4, 5, 6]',
    'size(a)',
    'b = flatten(a)',
    'size(b)'
  ],
  'seealso': [
    'concat', 'resize', 'size', 'squeeze'
  ]
};

},{}],112:[function(require,module,exports){
module.exports = {
  'name': 'forEach',
  'category': 'Matrix',
  'syntax': [
    'forEach(x, callback)'
  ],
  'description': 'Iterates over all elements of a matrix/array, and executes the given callback function.',
  'examples': [
    'forEach([1, 2, 3], function(val) { console.log(val) })'
  ],
  'seealso': ['map', 'sort', 'filter']
};

},{}],113:[function(require,module,exports){
module.exports = {
  'name': 'inv',
  'category': 'Matrix',
  'syntax': [
    'inv(x)'
  ],
  'description': 'Calculate the inverse of a matrix',
  'examples': [
    'inv([1, 2; 3, 4])',
    'inv(4)',
    '1 / 4'
  ],
  'seealso': [
    'concat', 'det', 'diag', 'eye', 'ones', 'range', 'size', 'squeeze', 'subset', 'trace', 'transpose', 'zeros'
  ]
};

},{}],114:[function(require,module,exports){
module.exports = {
  'name': 'map',
  'category': 'Matrix',
  'syntax': [
    'map(x, callback)'
  ],
  'description': 'Create a new matrix or array with the results of the callback function executed on each entry of the matrix/array.',
  'examples': [
    'map([1, 2, 3], function(val) { return value * value })'
  ],
  'seealso': ['filter', 'forEach']
};

},{}],115:[function(require,module,exports){
module.exports = {
  'name': 'ones',
  'category': 'Matrix',
  'syntax': [
    'ones(m)',
    'ones(m, n)',
    'ones(m, n, p, ...)',
    'ones([m])',
    'ones([m, n])',
    'ones([m, n, p, ...])',
    'ones'
  ],
  'description': 'Create a matrix containing ones.',
  'examples': [
    'ones(3)',
    'ones(3, 5)',
    'ones([2,3]) * 4.5',
    'a = [1, 2, 3; 4, 5, 6]',
    'ones(size(a))'
  ],
  'seealso': [
    'concat', 'det', 'diag', 'eye', 'inv', 'range', 'size', 'squeeze', 'subset', 'trace', 'transpose', 'zeros'
  ]
};

},{}],116:[function(require,module,exports){
module.exports = {
  'name': 'partitionSelect',
  'category': 'Matrix',
  'syntax': [
    'partitionSelect(x, k)',
    'partitionSelect(x, k, compare)'
  ],
  'description': 'Partition-based selection of an array or 1D matrix. Will find the kth smallest value, and mutates the input array. Uses Quickselect.',
  'examples': [
    'partitionSelect([5, 10, 1], 2)',
    'partitionSelect(["C", "B", "A", "D"], 1)'
  ],
  'seealso': ['sort']
};

},{}],117:[function(require,module,exports){
module.exports = {
  'name': 'range',
  'category': 'Type',
  'syntax': [
    'start:end',
    'start:step:end',
    'range(start, end)',
    'range(start, end, step)',
    'range(string)'
  ],
  'description':
      'Create a range. Lower bound of the range is included, upper bound is excluded.',
  'examples': [
    '1:5',
    '3:-1:-3',
    'range(3, 7)',
    'range(0, 12, 2)',
    'range("4:10")',
    'a = [1, 2, 3, 4; 5, 6, 7, 8]',
    'a[1:2, 1:2]'
  ],
  'seealso': [
    'concat', 'det', 'diag', 'eye', 'inv', 'ones', 'size', 'squeeze', 'subset', 'trace', 'transpose', 'zeros'
  ]
};

},{}],118:[function(require,module,exports){
module.exports = {
  'name': 'resize',
  'category': 'Matrix',
  'syntax': [
    'resize(x, size)',
    'resize(x, size, defaultValue)'
  ],
  'description': 'Resize a matrix.',
  'examples': [
    'resize([1,2,3,4,5], [3])',
    'resize([1,2,3], [5])',
    'resize([1,2,3], [5], -1)',
    'resize(2, [2, 3])',
    'resize("hello", [8], "!")'
  ],
  'seealso': [
    'size', 'subset', 'squeeze'
  ]
};

},{}],119:[function(require,module,exports){
module.exports = {
  'name': 'size',
  'category': 'Matrix',
  'syntax': [
    'size(x)'
  ],
  'description': 'Calculate the size of a matrix.',
  'examples': [
    'size(2.3)',
    'size("hello world")',
    'a = [1, 2; 3, 4; 5, 6]',
    'size(a)',
    'size(1:6)'
  ],
  'seealso': [
    'concat', 'det', 'diag', 'eye', 'inv', 'ones', 'range', 'squeeze', 'subset', 'trace', 'transpose', 'zeros'
  ]
};

},{}],120:[function(require,module,exports){
module.exports = {
  'name': 'sort',
  'category': 'Matrix',
  'syntax': [
    'sort(x)',
    'sort(x, compare)'
  ],
  'description': 'Sort the items in a matrix. Compare can be a string "asc" or "desc", or a custom sort function.',
  'examples': [
    'sort([5, 10, 1])',
    'sort(["C", "B", "A", "D"])',
    'sortByLength(a, b) = size(a)[1] - size(b)[1]',
    'sort(["Langdon", "Tom", "Sara"], sortByLength)'
  ],
  'seealso': ['map', 'filter', 'forEach']
};

},{}],121:[function(require,module,exports){
module.exports = {
  'name': 'squeeze',
  'category': 'Matrix',
  'syntax': [
    'squeeze(x)'
  ],
  'description': 'Remove inner and outer singleton dimensions from a matrix.',
  'examples': [
    'a = zeros(3,2,1)',
    'size(squeeze(a))',
    'b = zeros(1,1,3)',
    'size(squeeze(b))'
  ],
  'seealso': [
    'concat', 'det', 'diag', 'eye', 'inv', 'ones', 'range', 'size', 'subset', 'trace', 'transpose', 'zeros'
  ]
};

},{}],122:[function(require,module,exports){
module.exports = {
  'name': 'subset',
  'category': 'Matrix',
  'syntax': [
    'value(index)',
    'value(index) = replacement',
    'subset(value, [index])',
    'subset(value, [index], replacement)'
  ],
  'description': 'Get or set a subset of a matrix or string. ' +
      'Indexes are one-based. ' +
      'Both the ranges lower-bound and upper-bound are included.',
  'examples': [
    'd = [1, 2; 3, 4]',
    'e = []',
    'e[1, 1:2] = [5, 6]',
    'e[2, :] = [7, 8]',
    'f = d * e',
    'f[2, 1]',
    'f[:, 1]'
  ],
  'seealso': [
    'concat', 'det', 'diag', 'eye', 'inv', 'ones', 'range', 'size', 'squeeze', 'trace', 'transpose', 'zeros'
  ]
};

},{}],123:[function(require,module,exports){
module.exports = {
  'name': 'trace',
  'category': 'Matrix',
  'syntax': [
    'trace(A)'
  ],
  'description': 'Calculate the trace of a matrix: the sum of the elements on the main diagonal of a square matrix.',
  'examples': [
    'A = [1, 2, 3; -1, 2, 3; 2, 0, 3]',
    'trace(A)'
  ],
  'seealso': [
    'concat', 'det', 'diag', 'eye', 'inv', 'ones', 'range', 'size', 'squeeze', 'subset', 'transpose', 'zeros'
  ]
};

},{}],124:[function(require,module,exports){
module.exports = {
  'name': 'transpose',
  'category': 'Matrix',
  'syntax': [
    'x\'',
    'transpose(x)'
  ],
  'description': 'Transpose a matrix',
  'examples': [
    'a = [1, 2, 3; 4, 5, 6]',
    'a\'',
    'transpose(a)'
  ],
  'seealso': [
    'concat', 'det', 'diag', 'eye', 'inv', 'ones', 'range', 'size', 'squeeze', 'subset', 'trace', 'zeros'
  ]
};

},{}],125:[function(require,module,exports){
module.exports = {
  'name': 'zeros',
  'category': 'Matrix',
  'syntax': [
    'zeros(m)',
    'zeros(m, n)',
    'zeros(m, n, p, ...)',
    'zeros([m])',
    'zeros([m, n])',
    'zeros([m, n, p, ...])',
    'zeros'
  ],
  'description': 'Create a matrix containing zeros.',
  'examples': [
    'zeros(3)',
    'zeros(3, 5)',
    'a = [1, 2, 3; 4, 5, 6]',
    'zeros(size(a))'
  ],
  'seealso': [
    'concat', 'det', 'diag', 'eye', 'inv', 'ones', 'range', 'size', 'squeeze', 'subset', 'trace', 'transpose'
  ]
};

},{}],126:[function(require,module,exports){
module.exports = {
  'name': 'combinations',
  'category': 'Probability',
  'syntax': [
    'combinations(n, k)'
  ],
  'description': 'Compute the number of combinations of n items taken k at a time',
  'examples': [
    'combinations(7, 5)'
  ],
  'seealso': ['permutations', 'factorial']
};

},{}],127:[function(require,module,exports){
module.exports = {
  'name': 'factorial',
  'category': 'Probability',
  'syntax': [
    'kldivergence(x, y)'
  ],
  'description': 'Compute the factorial of a value',
  'examples': [
    '5!',
    '5 * 4 * 3 * 2 * 1',
    '3!'
  ],
  'seealso': ['combinations', 'permutations', 'gamma']
};

},{}],128:[function(require,module,exports){
module.exports = {
  'name': 'gamma',
  'category': 'Probability',
  'syntax': [
    'gamma(n)'
  ],
  'description': 'Compute the gamma function. For small values, the Lanczos approximation is used, and for large values the extended Stirling approximation.',
  'examples': [
    'gamma(4)',
    '3!',
    'gamma(1/2)',
    'sqrt(pi)'
  ],
  'seealso': ['factorial']
};

},{}],129:[function(require,module,exports){
module.exports = {
  'name': 'kldivergence',
  'category': 'Probability',
  'syntax': [
    'n!',
    'factorial(n)'
  ],
  'description': 'Calculate the Kullback-Leibler (KL) divergence  between two distributions.',
  'examples': [
    'math.kldivergence([0.7,0.5,0.4], [0.2,0.9,0.5])'
  ],
  'seealso': []
};

},{}],130:[function(require,module,exports){
module.exports = {
  'name': 'multinomial',
  'category': 'Probability',
  'syntax': [
    'multinomial(A)'
  ],
  'description': 'Multinomial Coefficients compute the number of ways of picking a1, a2, ..., ai unordered outcomes from `n` possibilities. multinomial takes one array of integers as an argument. The following condition must be enforced: every ai <= 0.',
  'examples': [
    'multinomial([1, 2, 1])'
  ],
  'seealso': ['combinations', 'factorial']
};
},{}],131:[function(require,module,exports){
module.exports = {
  'name': 'permutations',
  'category': 'Probability',
  'syntax': [
    'permutations(n)',
    'permutations(n, k)'
  ],
  'description': 'Compute the number of permutations of n items taken k at a time',
  'examples': [
    'permutations(5)',
    'permutations(5, 3)'
  ],
  'seealso': ['combinations', 'factorial']
};

},{}],132:[function(require,module,exports){
module.exports = {
  'name': 'pickRandom',
  'category': 'Probability',
  'syntax': [
    'pickRandom(array)'
  ],
  'description':
      'Pick a random entry from a given array.',
  'examples': [
    'pickRandom(0:10)',
    'pickRandom([1, 3, 1, 6])'
  ],
  'seealso': ['random', 'randomInt']
};

},{}],133:[function(require,module,exports){
module.exports = {
  'name': 'random',
  'category': 'Probability',
  'syntax': [
    'random()',
    'random(max)',
    'random(min, max)',
    'random(size)',
    'random(size, max)',
    'random(size, min, max)'
  ],
  'description':
      'Return a random number.',
  'examples': [
    'random()',
    'random(10, 20)',
    'random([2, 3])'
  ],
  'seealso': ['pickRandom', 'randomInt']
};

},{}],134:[function(require,module,exports){
module.exports = {
  'name': 'randInt',
  'category': 'Probability',
  'syntax': [
    'randInt(max)',
    'randInt(min, max)',
    'randInt(size)',
    'randInt(size, max)',
    'randInt(size, min, max)'
  ],
  'description':
      'Return a random integer number',
  'examples': [
    'randInt(10, 20)',
    'randInt([2, 3], 10)'
  ],
  'seealso': ['pickRandom', 'random']
};
},{}],135:[function(require,module,exports){
module.exports = {
  'name': 'compare',
  'category': 'Relational',
  'syntax': [
    'compare(x, y)'
  ],
  'description':
      'Compare two values. Returns 1 if x is larger than y, -1 if x is smaller than y, and 0 if x and y are equal.',
  'examples': [
    'compare(2, 3)',
    'compare(3, 2)',
    'compare(2, 2)',
    'compare(5cm, 40mm)',
    'compare(2, [1, 2, 3])'
  ],
  'seealso': [
    'equal', 'unequal', 'smaller', 'smallerEq', 'largerEq'
  ]
};

},{}],136:[function(require,module,exports){
module.exports = {
  'name': 'deepEqual',
  'category': 'Relational',
  'syntax': [
    'deepEqual(x, y)'
  ],
  'description':
      'Check equality of two matrices element wise. Returns true if the size of both matrices is equal and when and each of the elements are equal.',
  'examples': [
    '[1,3,4] == [1,3,4]',
    '[1,3,4] == [1,3]'
  ],
  'seealso': [
    'equal', 'unequal', 'smaller', 'larger', 'smallerEq', 'largerEq', 'compare'
  ]
};

},{}],137:[function(require,module,exports){
module.exports = {
  'name': 'equal',
  'category': 'Relational',
  'syntax': [
    'x == y',
    'equal(x, y)'
  ],
  'description':
      'Check equality of two values. Returns true if the values are equal, and false if not.',
  'examples': [
    '2+2 == 3',
    '2+2 == 4',
    'a = 3.2',
    'b = 6-2.8',
    'a == b',
    '50cm == 0.5m'
  ],
  'seealso': [
    'unequal', 'smaller', 'larger', 'smallerEq', 'largerEq', 'compare', 'deepEqual'
  ]
};

},{}],138:[function(require,module,exports){
module.exports = {
  'name': 'larger',
  'category': 'Relational',
  'syntax': [
    'x > y',
    'larger(x, y)'
  ],
  'description':
      'Check if value x is larger than y. Returns true if x is larger than y, and false if not.',
  'examples': [
    '2 > 3',
    '5 > 2*2',
    'a = 3.3',
    'b = 6-2.8',
    '(a > b)',
    '(b < a)',
    '5 cm > 2 inch'
  ],
  'seealso': [
    'equal', 'unequal', 'smaller', 'smallerEq', 'largerEq', 'compare'
  ]
};

},{}],139:[function(require,module,exports){
module.exports = {
  'name': 'largerEq',
  'category': 'Relational',
  'syntax': [
    'x >= y',
    'largerEq(x, y)'
  ],
  'description':
      'Check if value x is larger or equal to y. Returns true if x is larger or equal to y, and false if not.',
  'examples': [
    '2 > 1+1',
    '2 >= 1+1',
    'a = 3.2',
    'b = 6-2.8',
    '(a > b)'
  ],
  'seealso': [
    'equal', 'unequal', 'smallerEq', 'smaller', 'largerEq', 'compare'
  ]
};

},{}],140:[function(require,module,exports){
module.exports = {
  'name': 'smaller',
  'category': 'Relational',
  'syntax': [
    'x < y',
    'smaller(x, y)'
  ],
  'description':
      'Check if value x is smaller than value y. Returns true if x is smaller than y, and false if not.',
  'examples': [
    '2 < 3',
    '5 < 2*2',
    'a = 3.3',
    'b = 6-2.8',
    '(a < b)',
    '5 cm < 2 inch'
  ],
  'seealso': [
    'equal', 'unequal', 'larger', 'smallerEq', 'largerEq', 'compare'
  ]
};

},{}],141:[function(require,module,exports){
module.exports = {
  'name': 'smallerEq',
  'category': 'Relational',
  'syntax': [
    'x <= y',
    'smallerEq(x, y)'
  ],
  'description':
      'Check if value x is smaller or equal to value y. Returns true if x is smaller than y, and false if not.',
  'examples': [
    '2 < 1+1',
    '2 <= 1+1',
    'a = 3.2',
    'b = 6-2.8',
    '(a < b)'
  ],
  'seealso': [
    'equal', 'unequal', 'larger', 'smaller', 'largerEq', 'compare'
  ]
};

},{}],142:[function(require,module,exports){
module.exports = {
  'name': 'unequal',
  'category': 'Relational',
  'syntax': [
    'x != y',
    'unequal(x, y)'
  ],
  'description':
      'Check unequality of two values. Returns true if the values are unequal, and false if they are equal.',
  'examples': [
    '2+2 != 3',
    '2+2 != 4',
    'a = 3.2',
    'b = 6-2.8',
    'a != b',
    '50cm != 0.5m',
    '5 cm != 2 inch'
  ],
  'seealso': [
    'equal', 'smaller', 'larger', 'smallerEq', 'largerEq', 'compare', 'deepEqual'
  ]
};

},{}],143:[function(require,module,exports){
module.exports = {
  'name': 'max',
  'category': 'Statistics',
  'syntax': [
    'max(a, b, c, ...)',
    'max(A)',
    'max(A, dim)'
  ],
  'description': 'Compute the maximum value of a list of values.',
  'examples': [
    'max(2, 3, 4, 1)',
    'max([2, 3, 4, 1])',
    'max([2, 5; 4, 3])',
    'max([2, 5; 4, 3], 1)',
    'max([2, 5; 4, 3], 2)',
    'max(2.7, 7.1, -4.5, 2.0, 4.1)',
    'min(2.7, 7.1, -4.5, 2.0, 4.1)'
  ],
  'seealso': [
    'mean',
    'median',
    'min',
    'prod',
    'std',
    'sum',
    'var'
  ]
};

},{}],144:[function(require,module,exports){
module.exports = {
  'name': 'mean',
  'category': 'Statistics',
  'syntax': [
    'mean(a, b, c, ...)',
    'mean(A)',
    'mean(A, dim)'
  ],
  'description': 'Compute the arithmetic mean of a list of values.',
  'examples': [
    'mean(2, 3, 4, 1)',
    'mean([2, 3, 4, 1])',
    'mean([2, 5; 4, 3])',
    'mean([2, 5; 4, 3], 1)',
    'mean([2, 5; 4, 3], 2)',
    'mean([1.0, 2.7, 3.2, 4.0])'
  ],
  'seealso': [
    'max',
    'median',
    'min',
    'prod',
    'std',
    'sum',
    'var'
  ]
};

},{}],145:[function(require,module,exports){
module.exports = {
  'name': 'median',
  'category': 'Statistics',
  'syntax': [
    'median(a, b, c, ...)',
    'median(A)'
  ],
  'description': 'Compute the median of all values. The values are sorted and the middle value is returned. In case of an even number of values, the average of the two middle values is returned.',
  'examples': [
    'median(5, 2, 7)',
    'median([3, -1, 5, 7])'
  ],
  'seealso': [
    'max',
    'mean',
    'min',
    'prod',
    'std',
    'sum',
    'var'
  ]
};

},{}],146:[function(require,module,exports){
module.exports = {
  'name': 'min',
  'category': 'Statistics',
  'syntax': [
    'min(a, b, c, ...)',
    'min(A)',
    'min(A, dim)'
  ],
  'description': 'Compute the minimum value of a list of values.',
  'examples': [
    'min(2, 3, 4, 1)',
    'min([2, 3, 4, 1])',
    'min([2, 5; 4, 3])',
    'min([2, 5; 4, 3], 1)',
    'min([2, 5; 4, 3], 2)',
    'min(2.7, 7.1, -4.5, 2.0, 4.1)',
    'max(2.7, 7.1, -4.5, 2.0, 4.1)'
  ],
  'seealso': [
    'max',
    'mean',
    'median',
    'prod',
    'std',
    'sum',
    'var'
  ]
};

},{}],147:[function(require,module,exports){
module.exports = {
  'name': 'mode',
  'category': 'Statistics',
  'syntax': [
    'mode(a, b, c, ...)',
    'mode(A)',
    'mode(A, a, b, B, c, ...)'
  ],
  'description': 'Computes the mode of all values as an array. In case mode being more than one, multiple values are returned in an array.',
  'examples': [
    'mode(5, 2, 7)',
    'mode([3, -1, 5, 7])'
  ],
  'seealso': [
    'max',
    'mean',
    'min',
    'median',
    'prod',
    'std',
    'sum',
    'var'
  ]
};

},{}],148:[function(require,module,exports){
module.exports = {
  'name': 'prod',
  'category': 'Statistics',
  'syntax': [
    'prod(a, b, c, ...)',
    'prod(A)'
  ],
  'description': 'Compute the product of all values.',
  'examples': [
    'prod(2, 3, 4)',
    'prod([2, 3, 4])',
    'prod([2, 5; 4, 3])'
  ],
  'seealso': [
    'max',
    'mean',
    'min',
    'median',
    'min',
    'std',
    'sum',
    'var'
  ]
};

},{}],149:[function(require,module,exports){
module.exports = {
  'name': 'quantileSeq',
  'category': 'Statistics',
  'syntax': [
    'quantileSeq(A, prob[, sorted])',
    'quantileSeq(A, [prob1, prob2, ...][, sorted])',
    'quantileSeq(A, N[, sorted])'
  ],
  'description': 'Compute the prob order quantile of a matrix or a list with values. The sequence is sorted and the middle value is returned. Supported types of sequence values are: Number, BigNumber, Unit Supported types of probablity are: Number, BigNumber. \n\nIn case of a (multi dimensional) array or matrix, the prob order quantile of all elements will be calculated.',
  'examples': [
    'quantileSeq([3, -1, 5, 7], 0.5)',
    'quantileSeq([3, -1, 5, 7], [1/3, 2/3])',
    'quantileSeq([3, -1, 5, 7], 2)',
    'quantileSeq([-1, 3, 5, 7], 0.5, true)'
  ],
  'seealso': [
    'mean',
    'median',
    'min',
    'max',
    'prod',
    'std',
    'sum',
    'var'
  ]
};
},{}],150:[function(require,module,exports){
module.exports = {
  'name': 'std',
  'category': 'Statistics',
  'syntax': [
    'std(a, b, c, ...)',
    'std(A)',
    'std(A, normalization)'
  ],
  'description': 'Compute the standard deviation of all values, defined as std(A) = sqrt(var(A)). Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
  'examples': [
    'std(2, 4, 6)',
    'std([2, 4, 6, 8])',
    'std([2, 4, 6, 8], "uncorrected")',
    'std([2, 4, 6, 8], "biased")',
    'std([1, 2, 3; 4, 5, 6])'
  ],
  'seealso': [
    'max',
    'mean',
    'min',
    'median',
    'min',
    'prod',
    'sum',
    'var'
  ]
};

},{}],151:[function(require,module,exports){
module.exports = {
  'name': 'sum',
  'category': 'Statistics',
  'syntax': [
    'sum(a, b, c, ...)',
    'sum(A)'
  ],
  'description': 'Compute the sum of all values.',
  'examples': [
    'sum(2, 3, 4, 1)',
    'sum([2, 3, 4, 1])',
    'sum([2, 5; 4, 3])'
  ],
  'seealso': [
    'max',
    'mean',
    'median',
    'min',
    'prod',
    'std',
    'sum',
    'var'
  ]
};

},{}],152:[function(require,module,exports){
module.exports = {
  'name': 'var',
  'category': 'Statistics',
  'syntax': [
    'var(a, b, c, ...)',
    'var(A)',
    'var(A, normalization)'
  ],
  'description': 'Compute the variance of all values. Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
  'examples': [
    'var(2, 4, 6)',
    'var([2, 4, 6, 8])',
    'var([2, 4, 6, 8], "uncorrected")',
    'var([2, 4, 6, 8], "biased")',
    'var([1, 2, 3; 4, 5, 6])'
  ],
  'seealso': [
    'max',
    'mean',
    'min',
    'median',
    'min',
    'prod',
    'std',
    'sum'
  ]
};

},{}],153:[function(require,module,exports){
module.exports = {
  'name': 'acos',
  'category': 'Trigonometry',
  'syntax': [
    'acos(x)'
  ],
  'description': 'Compute the inverse cosine of a value in radians.',
  'examples': [
    'acos(0.5)',
    'acos(cos(2.3))'
  ],
  'seealso': [
    'cos',
    'atan',
    'asin'
  ]
};

},{}],154:[function(require,module,exports){
module.exports = {
  'name': 'acosh',
  'category': 'Trigonometry',
  'syntax': [
    'acosh(x)'
  ],
  'description': 'Calculate the hyperbolic arccos of a value, defined as `acosh(x) = ln(sqrt(x^2 - 1) + x)`.',
  'examples': [
    'acosh(1.5)'
  ],
  'seealso': [
    'cosh',
    'asinh',
    'atanh'
  ]
};
},{}],155:[function(require,module,exports){
module.exports = {
  'name': 'acot',
  'category': 'Trigonometry',
  'syntax': [
    'acot(x)'
  ],
  'description': 'Calculate the inverse cotangent of a value.',
  'examples': [
    'acot(0.5)',
    'acot(cot(0.5))',
    'acot(2)'
  ],
  'seealso': [
    'cot',
    'atan'
  ]
};

},{}],156:[function(require,module,exports){
module.exports = {
  'name': 'acoth',
  'category': 'Trigonometry',
  'syntax': [
    'acoth(x)'
  ],
  'description': 'Calculate the hyperbolic arccotangent of a value, defined as `acoth(x) = (ln((x+1)/x) + ln(x/(x-1))) / 2`.',
  'examples': [
    'acoth(0.5)'
  ],
  'seealso': [
    'acsch',
    'asech'
  ]
};
},{}],157:[function(require,module,exports){
module.exports = {
  'name': 'acsc',
  'category': 'Trigonometry',
  'syntax': [
    'acsc(x)'
  ],
  'description': 'Calculate the inverse cotangent of a value.',
  'examples': [
    'acsc(0.5)',
    'acsc(csc(0.5))',
    'acsc(2)'
  ],
  'seealso': [
    'csc',
    'asin',
    'asec'
  ]
};

},{}],158:[function(require,module,exports){
module.exports = {
  'name': 'acsch',
  'category': 'Trigonometry',
  'syntax': [
    'acsch(x)'
  ],
  'description': 'Calculate the hyperbolic arccosecant of a value, defined as `acsch(x) = ln(1/x + sqrt(1/x^2 + 1))`.',
  'examples': [
    'acsch(0.5)'
  ],
  'seealso': [
    'asech',
    'acoth'
  ]
};

},{}],159:[function(require,module,exports){
module.exports = {
  'name': 'asec',
  'category': 'Trigonometry',
  'syntax': [
    'asec(x)'
  ],
  'description': 'Calculate the inverse secant of a value.',
  'examples': [
    'asec(0.5)',
    'asec(sec(0.5))',
    'asec(2)'
  ],
  'seealso': [
    'acos',
    'acot',
    'acsc'
  ]
};

},{}],160:[function(require,module,exports){
module.exports = {
  'name': 'asech',
  'category': 'Trigonometry',
  'syntax': [
    'asech(x)'
  ],
  'description': 'Calculate the inverse secant of a value.',
  'examples': [
    'asech(0.5)'
  ],
  'seealso': [
    'acsch',
    'acoth'
  ]
};

},{}],161:[function(require,module,exports){
module.exports = {
  'name': 'asin',
  'category': 'Trigonometry',
  'syntax': [
    'asin(x)'
  ],
  'description': 'Compute the inverse sine of a value in radians.',
  'examples': [
    'asin(0.5)',
    'asin(sin(2.3))'
  ],
  'seealso': [
    'sin',
    'acos',
    'atan'
  ]
};

},{}],162:[function(require,module,exports){
module.exports = {
  'name': 'asinh',
  'category': 'Trigonometry',
  'syntax': [
    'asinh(x)'
  ],
  'description': 'Calculate the hyperbolic arcsine of a value, defined as `asinh(x) = ln(x + sqrt(x^2 + 1))`.',
  'examples': [
    'asinh(0.5)'
  ],
  'seealso': [
    'acosh',
    'atanh'
  ]
};

},{}],163:[function(require,module,exports){
module.exports = {
  'name': 'atan',
  'category': 'Trigonometry',
  'syntax': [
    'atan(x)'
  ],
  'description': 'Compute the inverse tangent of a value in radians.',
  'examples': [
    'atan(0.5)',
    'atan(tan(2.3))'
  ],
  'seealso': [
    'tan',
    'acos',
    'asin'
  ]
};

},{}],164:[function(require,module,exports){
module.exports = {
  'name': 'atan2',
  'category': 'Trigonometry',
  'syntax': [
    'atan2(y, x)'
  ],
  'description':
      'Computes the principal value of the arc tangent of y/x in radians.',
  'examples': [
    'atan2(2, 2) / pi',
    'angle = 60 deg in rad',
    'x = cos(angle)',
    'y = sin(angle)',
    'atan2(y, x)'
  ],
  'seealso': [
    'sin',
    'cos',
    'tan'
  ]
};

},{}],165:[function(require,module,exports){
module.exports = {
  'name': 'atanh',
  'category': 'Trigonometry',
  'syntax': [
    'atanh(x)'
  ],
  'description': 'Calculate the hyperbolic arctangent of a value, defined as `atanh(x) = ln((1 + x)/(1 - x)) / 2`.',
  'examples': [
    'atanh(0.5)'
  ],
  'seealso': [
    'acosh',
    'asinh'
  ]
};

},{}],166:[function(require,module,exports){
module.exports = {
  'name': 'cos',
  'category': 'Trigonometry',
  'syntax': [
    'cos(x)'
  ],
  'description': 'Compute the cosine of x in radians.',
  'examples': [
    'cos(2)',
    'cos(pi / 4) ^ 2',
    'cos(180 deg)',
    'cos(60 deg)',
    'sin(0.2)^2 + cos(0.2)^2'
  ],
  'seealso': [
    'acos',
    'sin',
    'tan'
  ]
};

},{}],167:[function(require,module,exports){
module.exports = {
  'name': 'cosh',
  'category': 'Trigonometry',
  'syntax': [
    'cosh(x)'
  ],
  'description': 'Compute the hyperbolic cosine of x in radians.',
  'examples': [
    'cosh(0.5)'
  ],
  'seealso': [
    'sinh',
    'tanh',
    'coth'
  ]
};

},{}],168:[function(require,module,exports){
module.exports = {
  'name': 'cot',
  'category': 'Trigonometry',
  'syntax': [
    'cot(x)'
  ],
  'description': 'Compute the cotangent of x in radians. Defined as 1/tan(x)',
  'examples': [
    'cot(2)',
    '1 / tan(2)'
  ],
  'seealso': [
    'sec',
    'csc',
    'tan'
  ]
};

},{}],169:[function(require,module,exports){
module.exports = {
  'name': 'coth',
  'category': 'Trigonometry',
  'syntax': [
    'coth(x)'
  ],
  'description': 'Compute the hyperbolic cotangent of x in radians.',
  'examples': [
    'coth(2)',
    '1 / tanh(2)'
  ],
  'seealso': [
    'sech',
    'csch',
    'tanh'
  ]
};

},{}],170:[function(require,module,exports){
module.exports = {
  'name': 'csc',
  'category': 'Trigonometry',
  'syntax': [
    'csc(x)'
  ],
  'description': 'Compute the cosecant of x in radians. Defined as 1/sin(x)',
  'examples': [
    'csc(2)',
    '1 / sin(2)'
  ],
  'seealso': [
    'sec',
    'cot',
    'sin'
  ]
};

},{}],171:[function(require,module,exports){
module.exports = {
  'name': 'csch',
  'category': 'Trigonometry',
  'syntax': [
    'csch(x)'
  ],
  'description': 'Compute the hyperbolic cosecant of x in radians. Defined as 1/sinh(x)',
  'examples': [
    'csch(2)',
    '1 / sinh(2)'
  ],
  'seealso': [
    'sech',
    'coth',
    'sinh'
  ]
};

},{}],172:[function(require,module,exports){
module.exports = {
  'name': 'sec',
  'category': 'Trigonometry',
  'syntax': [
    'sec(x)'
  ],
  'description': 'Compute the secant of x in radians. Defined as 1/cos(x)',
  'examples': [
    'sec(2)',
    '1 / cos(2)'
  ],
  'seealso': [
    'cot',
    'csc',
    'cos'
  ]
};

},{}],173:[function(require,module,exports){
module.exports = {
  'name': 'sech',
  'category': 'Trigonometry',
  'syntax': [
    'sech(x)'
  ],
  'description': 'Compute the hyperbolic secant of x in radians. Defined as 1/cosh(x)',
  'examples': [
    'sech(2)',
    '1 / cosh(2)'
  ],
  'seealso': [
    'coth',
    'csch',
    'cosh'
  ]
};

},{}],174:[function(require,module,exports){
module.exports = {
  'name': 'sin',
  'category': 'Trigonometry',
  'syntax': [
    'sin(x)'
  ],
  'description': 'Compute the sine of x in radians.',
  'examples': [
    'sin(2)',
    'sin(pi / 4) ^ 2',
    'sin(90 deg)',
    'sin(30 deg)',
    'sin(0.2)^2 + cos(0.2)^2'
  ],
  'seealso': [
    'asin',
    'cos',
    'tan'
  ]
};

},{}],175:[function(require,module,exports){
module.exports = {
  'name': 'sinh',
  'category': 'Trigonometry',
  'syntax': [
    'sinh(x)'
  ],
  'description': 'Compute the hyperbolic sine of x in radians.',
  'examples': [
    'sinh(0.5)'
  ],
  'seealso': [
    'cosh',
    'tanh'
  ]
};

},{}],176:[function(require,module,exports){
module.exports = {
  'name': 'tan',
  'category': 'Trigonometry',
  'syntax': [
    'tan(x)'
  ],
  'description': 'Compute the tangent of x in radians.',
  'examples': [
    'tan(0.5)',
    'sin(0.5) / cos(0.5)',
    'tan(pi / 4)',
    'tan(45 deg)'
  ],
  'seealso': [
    'atan',
    'sin',
    'cos'
  ]
};

},{}],177:[function(require,module,exports){
module.exports = {
  'name': 'tanh',
  'category': 'Trigonometry',
  'syntax': [
    'tanh(x)'
  ],
  'description': 'Compute the hyperbolic tangent of x in radians.',
  'examples': [
    'tanh(0.5)',
    'sinh(0.5) / cosh(0.5)'
  ],
  'seealso': [
    'sinh',
    'cosh'
  ]
};

},{}],178:[function(require,module,exports){
module.exports = {
  'name': 'to',
  'category': 'Units',
  'syntax': [
    'x to unit',
    'to(x, unit)'
  ],
  'description': 'Change the unit of a value.',
  'examples': [
    '5 inch to cm',
    '3.2kg to g',
    '16 bytes in bits'
  ],
  'seealso': []
};

},{}],179:[function(require,module,exports){
module.exports = {
  'name': 'clone',
  'category': 'Utils',
  'syntax': [
    'clone(x)'
  ],
  'description': 'Clone a variable. Creates a copy of primitive variables,and a deep copy of matrices',
  'examples': [
    'clone(3.5)',
    'clone(2 - 4i)',
    'clone(45 deg)',
    'clone([1, 2; 3, 4])',
    'clone("hello world")'
  ],
  'seealso': []
};

},{}],180:[function(require,module,exports){
module.exports = {
  'name': 'format',
  'category': 'Utils',
  'syntax': [
    'format(value)',
    'format(value, precision)'
  ],
  'description': 'Format a value of any type as string.',
  'examples': [
    'format(2.3)',
    'format(3 - 4i)',
    'format([])',
    'format(pi, 3)'
  ],
  'seealso': ['print']
};

},{}],181:[function(require,module,exports){
module.exports = {
  'name': 'isInteger',
  'category': 'Utils',
  'syntax': [
    'isInteger(x)'
  ],
  'description': 'Test whether a value is an integer number.',
  'examples': [
    'isInteger(2)',
    'isInteger(3.5)',
    'isInteger([3, 0.5, -2])'
  ],
  'seealso': ['isNegative', 'isNumeric', 'isPositive', 'isZero']
};

},{}],182:[function(require,module,exports){
module.exports = {
  'name': 'isNegative',
  'category': 'Utils',
  'syntax': [
    'isNegative(x)'
  ],
  'description': 'Test whether a value is negative: smaller than zero.',
  'examples': [
    'isNegative(2)',
    'isNegative(0)',
    'isNegative(-4)',
    'isNegative([3, 0.5, -2])'
  ],
  'seealso': ['isInteger', 'isNumeric', 'isPositive', 'isZero']
};

},{}],183:[function(require,module,exports){
module.exports = {
  'name': 'isNumeric',
  'category': 'Utils',
  'syntax': [
    'isNumeric(x)'
  ],
  'description': 'Test whether a value is a numeric value. ' +
    'Returns true when the input is a number, BigNumber, Fraction, or boolean.',
  'examples': [
    'isNumeric(2)',
    'isNumeric(0)',
    'isNumeric(bignumber(500))',
    'isNumeric(fraction(0.125))',
    'isNumeric("3")',
    'isNumeric(2 + 3i)',
    'isNumeric([2.3, "foo", false])'
  ],
  'seealso': ['isInteger', 'isZero', 'isNegative', 'isPositive']
};

},{}],184:[function(require,module,exports){
module.exports = {
  'name': 'isPositive',
  'category': 'Utils',
  'syntax': [
    'isPositive(x)'
  ],
  'description': 'Test whether a value is positive: larger than zero.',
  'examples': [
    'isPositive(2)',
    'isPositive(0)',
    'isPositive(-4)',
    'isPositive([3, 0.5, -2])'
  ],
  'seealso': ['isInteger', 'isNumeric', 'isNegative', 'isZero']
};

},{}],185:[function(require,module,exports){
module.exports = {
  'name': 'isZero',
  'category': 'Utils',
  'syntax': [
    'isZero(x)'
  ],
  'description': 'Test whether a value is zero.',
  'examples': [
    'isZero(2)',
    'isZero(0)',
    'isZero(-4)',
    'isZero([3, 0, -2, 0])'
  ],
  'seealso': ['isInteger', 'isNumeric', 'isNegative', 'isPositive']
};

},{}],186:[function(require,module,exports){
module.exports = {
  'name': 'typeof',
  'category': 'Utils',
  'syntax': [
    'typeof(x)'
  ],
  'description': 'Get the type of a variable.',
  'examples': [
    'typeof(3.5)',
    'typeof(2 - 4i)',
    'typeof(45 deg)',
    'typeof("hello world")'
  ],
  'seealso': []
};

},{}],187:[function(require,module,exports){
function factory (construction, config, load, typed) {
  var docs = {};


  // construction functions
  docs.bignumber = require('./construction/bignumber');
  docs['boolean'] = require('./construction/boolean');
  docs.complex = require('./construction/complex');
  docs.fraction = require('./construction/fraction');
  docs.index = require('./construction/index');
  docs.matrix = require('./construction/matrix');
  docs.number = require('./construction/number');
  docs.sparse = require('./construction/sparse');
  docs.string = require('./construction/string');
  docs.unit = require('./construction/unit');

  // constants
  docs.e = require('./constants/e');
  docs.E = require('./constants/e');
  docs['false'] = require('./constants/false');
  docs.i = require('./constants/i');
  docs['Infinity'] = require('./constants/Infinity');
  docs.LN2 = require('./constants/LN2');
  docs.LN10 = require('./constants/LN10');
  docs.LOG2E = require('./constants/LOG2E');
  docs.LOG10E = require('./constants/LOG10E');
  docs.NaN = require('./constants/NaN');
  docs['null'] = require('./constants/null');
  docs.pi = require('./constants/pi');
  docs.PI = require('./constants/pi');
  docs.phi = require('./constants/phi');
  docs.SQRT1_2 = require('./constants/SQRT1_2');
  docs.SQRT2 = require('./constants/SQRT2');
  docs.tau = require('./constants/tau');
  docs['true'] = require('./constants/true');
  docs.version = require('./constants/version');

  // physical constants
  // TODO: more detailed docs for physical constants
  docs.speedOfLight = {description: 'Speed of light in vacuum', examples: ['speedOfLight']};
  docs.gravitationConstant = {description: 'Newtonian constant of gravitation', examples: ['gravitationConstant']};
  docs.planckConstant = {description: 'Planck constant', examples: ['planckConstant']};
  docs.reducedPlanckConstant = {description: 'Reduced Planck constant', examples: ['reducedPlanckConstant']};

  docs.magneticConstant = {description: 'Magnetic constant (vacuum permeability)', examples: ['magneticConstant']};
  docs.electricConstant = {description: 'Electric constant (vacuum permeability)', examples: ['electricConstant']};
  docs.vacuumImpedance = {description: 'Characteristic impedance of vacuum', examples: ['vacuumImpedance']};
  docs.coulomb = {description: 'Coulomb\'s constant', examples: ['coulomb']};
  docs.elementaryCharge = {description: 'Elementary charge', examples: ['elementaryCharge']};
  docs.bohrMagneton = {description: 'Borh magneton', examples: ['bohrMagneton']};
  docs.conductanceQuantum = {description: 'Conductance quantum', examples: ['conductanceQuantum']};
  docs.inverseConductanceQuantum = {description: 'Inverse conductance quantum', examples: ['inverseConductanceQuantum']};
  //docs.josephson = {description: 'Josephson constant', examples: ['josephson']};
  docs.magneticFluxQuantum = {description: 'Magnetic flux quantum', examples: ['magneticFluxQuantum']};
  docs.nuclearMagneton = {description: 'Nuclear magneton', examples: ['nuclearMagneton']};
  docs.klitzing = {description: 'Von Klitzing constant', examples: ['klitzing']};

  docs.bohrRadius = {description: 'Borh radius', examples: ['bohrRadius']};
  docs.classicalElectronRadius = {description: 'Classical electron radius', examples: ['classicalElectronRadius']};
  docs.electronMass = {description: 'Electron mass', examples: ['electronMass']};
  docs.fermiCoupling = {description: 'Fermi coupling constant', examples: ['fermiCoupling']};
  docs.fineStructure = {description: 'Fine-structure constant', examples: ['fineStructure']};
  docs.hartreeEnergy = {description: 'Hartree energy', examples: ['hartreeEnergy']};
  docs.protonMass = {description: 'Proton mass', examples: ['protonMass']};
  docs.deuteronMass = {description: 'Deuteron Mass', examples: ['deuteronMass']};
  docs.neutronMass = {description: 'Neutron mass', examples: ['neutronMass']};
  docs.quantumOfCirculation = {description: 'Quantum of circulation', examples: ['quantumOfCirculation']};
  docs.rydberg = {description: 'Rydberg constant', examples: ['rydberg']};
  docs.thomsonCrossSection = {description: 'Thomson cross section', examples: ['thomsonCrossSection']};
  docs.weakMixingAngle = {description: 'Weak mixing angle', examples: ['weakMixingAngle']};
  docs.efimovFactor = {description: 'Efimov factor', examples: ['efimovFactor']};

  docs.atomicMass = {description: 'Atomic mass constant', examples: ['atomicMass']};
  docs.avogadro = {description: 'Avogadro\'s number', examples: ['avogadro']};
  docs.boltzmann = {description: 'Boltzmann constant', examples: ['boltzmann']};
  docs.faraday = {description: 'Faraday constant', examples: ['faraday']};
  docs.firstRadiation = {description: 'First radiation constant', examples: ['firstRadiation']};
  docs.loschmidt = {description: 'Loschmidt constant at T=273.15 K and p=101.325 kPa', examples: ['loschmidt']};
  docs.gasConstant = {description: 'Gas constant', examples: ['gasConstant']};
  docs.molarPlanckConstant = {description: 'Molar Planck constant', examples: ['molarPlanckConstant']};
  docs.molarVolume = {description: 'Molar volume of an ideal gas at T=273.15 K and p=101.325 kPa', examples: ['molarVolume']};
  docs.sackurTetrode = {description: 'Sackur-Tetrode constant at T=1 K and p=101.325 kPa', examples: ['sackurTetrode']};
  docs.secondRadiation = {description: 'Second radiation constant', examples: ['secondRadiation']};
  docs.stefanBoltzmann = {description: 'Stefan-Boltzmann constant', examples: ['stefanBoltzmann']};
  docs.wienDisplacement = {description: 'Wien displacement law constant', examples: ['wienDisplacement']};
  //docs.spectralRadiance = {description: 'First radiation constant for spectral radiance', examples: ['spectralRadiance']};

  docs.molarMass = {description: 'Molar mass constant', examples: ['molarMass']};
  docs.molarMassC12 = {description: 'Molar mass constant of carbon-12', examples: ['molarMassC12']};
  docs.gravity = {description: 'Standard acceleration of gravity (standard acceleration of free-fall on Earth)', examples: ['gravity']};

  docs.planckLength = {description: 'Planck length', examples: ['planckLength']};
  docs.planckMass = {description: 'Planck mass', examples: ['planckMass']};
  docs.planckTime = {description: 'Planck time', examples: ['planckTime']};
  docs.planckCharge = {description: 'Planck charge', examples: ['planckCharge']};
  docs.planckTemperature = {description: 'Planck temperature', examples: ['planckTemperature']};

  // functions - algebra
  docs.lsolve = require('./function/algebra/lsolve');
  docs.lup = require('./function/algebra/lup');
  docs.lusolve = require('./function/algebra/lusolve');
  docs.slu = require('./function/algebra/slu');
  docs.usolve = require('./function/algebra/usolve');

  // functions - arithmetic
  docs.abs = require('./function/arithmetic/abs');
  docs.add = require('./function/arithmetic/add');
  docs.cbrt = require('./function/arithmetic/cbrt');
  docs.ceil = require('./function/arithmetic/ceil');
  docs.cube = require('./function/arithmetic/cube');
  docs.divide = require('./function/arithmetic/divide');
  docs.dotDivide = require('./function/arithmetic/dotDivide');
  docs.dotMultiply = require('./function/arithmetic/dotMultiply');
  docs.dotPow = require('./function/arithmetic/dotPow');
  docs.exp = require('./function/arithmetic/exp');
  docs.fix = require('./function/arithmetic/fix');
  docs.floor = require('./function/arithmetic/floor');
  docs.gcd = require('./function/arithmetic/gcd');
  docs.hypot = require('./function/arithmetic/hypot');
  docs.lcm = require('./function/arithmetic/lcm');
  docs.log = require('./function/arithmetic/log');
  docs.log10 = require('./function/arithmetic/log10');
  docs.mod = require('./function/arithmetic/mod');
  docs.multiply = require('./function/arithmetic/multiply');
  docs.norm = require('./function/arithmetic/norm');
  docs.nthRoot = require('./function/arithmetic/nthRoot');
  docs.pow = require('./function/arithmetic/pow');
  docs.round = require('./function/arithmetic/round');
  docs.sign = require('./function/arithmetic/sign');
  docs.sqrt = require('./function/arithmetic/sqrt');
  docs.square = require('./function/arithmetic/square');
  docs.subtract = require('./function/arithmetic/subtract');
  docs.unaryMinus = require('./function/arithmetic/unaryMinus');
  docs.unaryPlus = require('./function/arithmetic/unaryPlus');
  docs.xgcd = require('./function/arithmetic/xgcd');

  // functions - bitwise
  docs.bitAnd = require('./function/bitwise/bitAnd');
  docs.bitNot = require('./function/bitwise/bitNot');
  docs.bitOr = require('./function/bitwise/bitOr');
  docs.bitXor = require('./function/bitwise/bitXor');
  docs.leftShift = require('./function/bitwise/leftShift');
  docs.rightArithShift = require('./function/bitwise/rightArithShift');
  docs.rightLogShift = require('./function/bitwise/rightLogShift');

  // functions - combinatorics
  docs.bellNumbers = require('./function/combinatorics/bellNumbers');
  docs.catalan = require('./function/combinatorics/catalan');
  docs.composition = require('./function/combinatorics/composition');
  docs.stirlingS2 = require('./function/combinatorics/stirlingS2');

  // functions - core
  docs['config'] =  require('./core/config');
  docs['import'] =  require('./core/import');
  docs['typed'] =  require('./core/typed');

  // functions - complex
  docs.arg = require('./function/complex/arg');
  docs.conj = require('./function/complex/conj');
  docs.re = require('./function/complex/re');
  docs.im = require('./function/complex/im');

  // functions - expression
  docs['eval'] =  require('./function/expression/eval');
  docs.help =  require('./function/expression/help');

  // functions - geometry
  docs.distance = require('./function/geometry/distance');
  docs.intersect = require('./function/geometry/intersect');

  // functions - logical
  docs['and'] = require('./function/logical/and');
  docs['not'] = require('./function/logical/not');
  docs['or'] = require('./function/logical/or');
  docs['xor'] = require('./function/logical/xor');

  // functions - matrix
  docs['concat'] = require('./function/matrix/concat');
  docs.cross = require('./function/matrix/cross');
  docs.det = require('./function/matrix/det');
  docs.diag = require('./function/matrix/diag');
  docs.dot = require('./function/matrix/dot');
  docs.eye = require('./function/matrix/eye');
  docs.filter =  require('./function/matrix/filter');
  docs.flatten = require('./function/matrix/flatten');
  docs.forEach =  require('./function/matrix/forEach');
  docs.inv = require('./function/matrix/inv');
  docs.map =  require('./function/matrix/map');
  docs.ones = require('./function/matrix/ones');
  docs.partitionSelect =  require('./function/matrix/partitionSelect');
  docs.range = require('./function/matrix/range');
  docs.resize = require('./function/matrix/resize');
  docs.size = require('./function/matrix/size');
  docs.sort =  require('./function/matrix/sort');
  docs.squeeze = require('./function/matrix/squeeze');
  docs.subset = require('./function/matrix/subset');
  docs.trace = require('./function/matrix/trace');
  docs.transpose = require('./function/matrix/transpose');
  docs.zeros = require('./function/matrix/zeros');

  // functions - probability
  docs.combinations = require('./function/probability/combinations');
  //docs.distribution = require('./function/probability/distribution');
  docs.factorial = require('./function/probability/factorial');
  docs.gamma = require('./function/probability/gamma');
  docs.kldivergence = require('./function/probability/kldivergence');
  docs.multinomial = require('./function/probability/multinomial');
  docs.permutations = require('./function/probability/permutations');
  docs.pickRandom = require('./function/probability/pickRandom');
  docs.random = require('./function/probability/random');
  docs.randomInt = require('./function/probability/randomInt');

  // functions - relational
  docs.compare = require('./function/relational/compare');
  docs.deepEqual = require('./function/relational/deepEqual');
  docs['equal'] = require('./function/relational/equal');
  docs.larger = require('./function/relational/larger');
  docs.largerEq = require('./function/relational/largerEq');
  docs.smaller = require('./function/relational/smaller');
  docs.smallerEq = require('./function/relational/smallerEq');
  docs.unequal = require('./function/relational/unequal');

  // functions - statistics
  docs.max = require('./function/statistics/max');
  docs.mean = require('./function/statistics/mean');
  docs.median = require('./function/statistics/median');
  docs.min = require('./function/statistics/min');
  docs.mode = require('./function/statistics/mode');
  docs.prod = require('./function/statistics/prod');
  docs.quantileSeq = require('./function/statistics/quantileSeq');
  docs.std = require('./function/statistics/std');
  docs.sum = require('./function/statistics/sum');
  docs['var'] = require('./function/statistics/var');

  // functions - trigonometry
  docs.acos = require('./function/trigonometry/acos');
  docs.acosh = require('./function/trigonometry/acosh');
  docs.acot = require('./function/trigonometry/acot');
  docs.acoth = require('./function/trigonometry/acoth');
  docs.acsc = require('./function/trigonometry/acsc');
  docs.acsch = require('./function/trigonometry/acsch');
  docs.asec = require('./function/trigonometry/asec');
  docs.asech = require('./function/trigonometry/asech');
  docs.asin = require('./function/trigonometry/asin');
  docs.asinh = require('./function/trigonometry/asinh');
  docs.atan = require('./function/trigonometry/atan');
  docs.atanh = require('./function/trigonometry/atanh');
  docs.atan2 = require('./function/trigonometry/atan2');
  docs.cos = require('./function/trigonometry/cos');
  docs.cosh = require('./function/trigonometry/cosh');
  docs.cot = require('./function/trigonometry/cot');
  docs.coth = require('./function/trigonometry/coth');
  docs.csc = require('./function/trigonometry/csc');
  docs.csch = require('./function/trigonometry/csch');
  docs.sec = require('./function/trigonometry/sec');
  docs.sech = require('./function/trigonometry/sech');
  docs.sin = require('./function/trigonometry/sin');
  docs.sinh = require('./function/trigonometry/sinh');
  docs.tan = require('./function/trigonometry/tan');
  docs.tanh = require('./function/trigonometry/tanh');

  // functions - units
  docs.to = require('./function/units/to');

  // functions - utils
  docs.clone =  require('./function/utils/clone');
  docs.format =  require('./function/utils/format');
  docs.isInteger =  require('./function/utils/isInteger');
  docs.isNegative =  require('./function/utils/isNegative');
  docs.isNumeric =  require('./function/utils/isNumeric');
  docs.isPositive =  require('./function/utils/isPositive');
  docs.isZero =  require('./function/utils/isZero');
  // docs.print =  require('./function/utils/print'); // TODO: add documentation for print as soon as the parser supports objects.
  docs['typeof'] =  require('./function/utils/typeof');

  return docs;
}

exports.name = 'docs';
exports.path = 'expression';
exports.factory = factory;

},{"./constants/Infinity":16,"./constants/LN10":17,"./constants/LN2":18,"./constants/LOG10E":19,"./constants/LOG2E":20,"./constants/NaN":21,"./constants/SQRT1_2":22,"./constants/SQRT2":23,"./constants/e":24,"./constants/false":25,"./constants/i":26,"./constants/null":27,"./constants/phi":28,"./constants/pi":29,"./constants/tau":30,"./constants/true":31,"./constants/version":32,"./construction/bignumber":33,"./construction/boolean":34,"./construction/complex":35,"./construction/fraction":36,"./construction/index":37,"./construction/matrix":38,"./construction/number":39,"./construction/sparse":40,"./construction/string":41,"./construction/unit":42,"./core/config":43,"./core/import":44,"./core/typed":45,"./function/algebra/lsolve":46,"./function/algebra/lup":47,"./function/algebra/lusolve":48,"./function/algebra/slu":49,"./function/algebra/usolve":50,"./function/arithmetic/abs":51,"./function/arithmetic/add":52,"./function/arithmetic/cbrt":53,"./function/arithmetic/ceil":54,"./function/arithmetic/cube":55,"./function/arithmetic/divide":56,"./function/arithmetic/dotDivide":57,"./function/arithmetic/dotMultiply":58,"./function/arithmetic/dotPow":59,"./function/arithmetic/exp":60,"./function/arithmetic/fix":61,"./function/arithmetic/floor":62,"./function/arithmetic/gcd":63,"./function/arithmetic/hypot":64,"./function/arithmetic/lcm":65,"./function/arithmetic/log":66,"./function/arithmetic/log10":67,"./function/arithmetic/mod":68,"./function/arithmetic/multiply":69,"./function/arithmetic/norm":70,"./function/arithmetic/nthRoot":71,"./function/arithmetic/pow":72,"./function/arithmetic/round":73,"./function/arithmetic/sign":74,"./function/arithmetic/sqrt":75,"./function/arithmetic/square":76,"./function/arithmetic/subtract":77,"./function/arithmetic/unaryMinus":78,"./function/arithmetic/unaryPlus":79,"./function/arithmetic/xgcd":80,"./function/bitwise/bitAnd":81,"./function/bitwise/bitNot":82,"./function/bitwise/bitOr":83,"./function/bitwise/bitXor":84,"./function/bitwise/leftShift":85,"./function/bitwise/rightArithShift":86,"./function/bitwise/rightLogShift":87,"./function/combinatorics/bellNumbers":88,"./function/combinatorics/catalan":89,"./function/combinatorics/composition":90,"./function/combinatorics/stirlingS2":91,"./function/complex/arg":92,"./function/complex/conj":93,"./function/complex/im":94,"./function/complex/re":95,"./function/expression/eval":96,"./function/expression/help":97,"./function/geometry/distance":98,"./function/geometry/intersect":99,"./function/logical/and":100,"./function/logical/not":101,"./function/logical/or":102,"./function/logical/xor":103,"./function/matrix/concat":104,"./function/matrix/cross":105,"./function/matrix/det":106,"./function/matrix/diag":107,"./function/matrix/dot":108,"./function/matrix/eye":109,"./function/matrix/filter":110,"./function/matrix/flatten":111,"./function/matrix/forEach":112,"./function/matrix/inv":113,"./function/matrix/map":114,"./function/matrix/ones":115,"./function/matrix/partitionSelect":116,"./function/matrix/range":117,"./function/matrix/resize":118,"./function/matrix/size":119,"./function/matrix/sort":120,"./function/matrix/squeeze":121,"./function/matrix/subset":122,"./function/matrix/trace":123,"./function/matrix/transpose":124,"./function/matrix/zeros":125,"./function/probability/combinations":126,"./function/probability/factorial":127,"./function/probability/gamma":128,"./function/probability/kldivergence":129,"./function/probability/multinomial":130,"./function/probability/permutations":131,"./function/probability/pickRandom":132,"./function/probability/random":133,"./function/probability/randomInt":134,"./function/relational/compare":135,"./function/relational/deepEqual":136,"./function/relational/equal":137,"./function/relational/larger":138,"./function/relational/largerEq":139,"./function/relational/smaller":140,"./function/relational/smallerEq":141,"./function/relational/unequal":142,"./function/statistics/max":143,"./function/statistics/mean":144,"./function/statistics/median":145,"./function/statistics/min":146,"./function/statistics/mode":147,"./function/statistics/prod":148,"./function/statistics/quantileSeq":149,"./function/statistics/std":150,"./function/statistics/sum":151,"./function/statistics/var":152,"./function/trigonometry/acos":153,"./function/trigonometry/acosh":154,"./function/trigonometry/acot":155,"./function/trigonometry/acoth":156,"./function/trigonometry/acsc":157,"./function/trigonometry/acsch":158,"./function/trigonometry/asec":159,"./function/trigonometry/asech":160,"./function/trigonometry/asin":161,"./function/trigonometry/asinh":162,"./function/trigonometry/atan":163,"./function/trigonometry/atan2":164,"./function/trigonometry/atanh":165,"./function/trigonometry/cos":166,"./function/trigonometry/cosh":167,"./function/trigonometry/cot":168,"./function/trigonometry/coth":169,"./function/trigonometry/csc":170,"./function/trigonometry/csch":171,"./function/trigonometry/sec":172,"./function/trigonometry/sech":173,"./function/trigonometry/sin":174,"./function/trigonometry/sinh":175,"./function/trigonometry/tan":176,"./function/trigonometry/tanh":177,"./function/units/to":178,"./function/utils/clone":179,"./function/utils/format":180,"./function/utils/isInteger":181,"./function/utils/isNegative":182,"./function/utils/isNumeric":183,"./function/utils/isPositive":184,"./function/utils/isZero":185,"./function/utils/typeof":186}],188:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  var parse = load(require('../parse'));

  /**
   * Parse and compile an expression.
   * Returns a an object with a function `eval([scope])` to evaluate the
   * compiled expression.
   *
   * Syntax:
   *
   *     math.compile(expr)                       // returns one node
   *     math.compile([expr1, expr2, expr3, ...]) // returns an array with nodes
   *
   * Examples:
   *
   *     var code = math.compile('sqrt(3^2 + 4^2)');
   *     code.eval(); // 5
   *
   *     var scope = {a: 3, b: 4}
   *     var code = math.compile('a * b'); // 12
   *     code.eval(scope); // 12
   *     scope.a = 5;
   *     code.eval(scope); // 20
   *
   *     var nodes = math.compile(['a = 3', 'b = 4', 'a * b']);
   *     nodes[2].eval(); // 12
   *
   * See also:
   *
   *    parse, eval
   *
   * @param {string | string[] | Array | Matrix} expr
   *            The expression to be compiled
   * @return {{eval: Function} | Array.<{eval: Function}>} code
   *            An object with the compiled expression
   * @throws {Error}
   */
  return typed('compile', {
    'string': function (expr) {
      return parse(expr).compile();
    },

    'Array | Matrix': function (expr) {
      return deepMap(expr, function (entry) {
        return parse(entry).compile();
      });
    }
  });
}

exports.name = 'compile';
exports.factory = factory;

},{"../../utils/collection/deepMap":475,"../parse":216}],189:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  var parse = load(require('../parse'));

  /**
   * Evaluate an expression.
   *
   * Syntax:
   *
   *     math.eval(expr)
   *     math.eval(expr, scope)
   *     math.eval([expr1, expr2, expr3, ...])
   *     math.eval([expr1, expr2, expr3, ...], scope)
   *
   * Example:
   *
   *     math.eval('(2+3)/4');                // 1.25
   *     math.eval('sqrt(3^2 + 4^2)');        // 5
   *     math.eval('sqrt(-4)');               // 2i
   *     math.eval(['a=3', 'b=4', 'a*b']);,   // [3, 4, 12]
   *
   *     var scope = {a:3, b:4};
   *     math.eval('a * b', scope);           // 12
   *
   * See also:
   *
   *    parse, compile
   *
   * @param {string | string[] | Matrix} expr   The expression to be evaluated
   * @param {Object} [scope]                    Scope to read/write variables
   * @return {*} The result of the expression
   * @throws {Error}
   */
  return typed('compile', {
    'string': function (expr) {
      var scope = {};
      return parse(expr).compile().eval(scope);
    },

    'string, Object': function (expr, scope) {
      return parse(expr).compile().eval(scope);
    },

    'Array | Matrix': function (expr) {
      var scope = {};
      return deepMap(expr, function (entry) {
        return parse(entry).compile().eval(scope);
      });
    },

    'Array | Matrix, Object': function (expr, scope) {
      return deepMap(expr, function (entry) {
        return parse(entry).compile().eval(scope);
      });
    }
  });
}

exports.name = 'eval';
exports.factory = factory;
},{"../../utils/collection/deepMap":475,"../parse":216}],190:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed, math) {
  var docs = load(require('../docs'));

  /**
   * Retrieve help on a function or data type.
   * Help files are retrieved from the documentation in math.expression.docs.
   *
   * Syntax:
   *
   *    math.help(search)
   *
   * Examples:
   *
   *    console.log(math.help('sin').toString());
   *    console.log(math.help(math.add).toString());
   *    console.log(math.help(math.add).toJSON());
   *
   * @param {Function | string | Object} search   A function or function name
   *                                              for which to get help
   * @return {Help} A help object
   */
  return typed('help', {
    'any': function (search) {
      var prop;
      var name = search;

      if (typeof search !== 'string') {
        for (prop in math) {
          // search in functions and constants
          if (math.hasOwnProperty(prop) && (search === math[prop])) {
            name = prop;
            break;
          }
        }

        /* TODO: implement help for data types
         if (!text) {
         // search data type
         for (prop in math.type) {
         if (math.type.hasOwnProperty(prop)) {
         if (search === math.type[prop]) {
         text = prop;
         break;
         }
         }
         }
         }
         */
      }

      var doc = docs[name];
      if (!doc) {
        throw new Error('No documentation found on "' + name + '"');
      }
      return new type.Help(doc);
    }
  });
}

exports.math = true; // request access to the math namespace as 5th argument of the factory function
exports.name = 'help';
exports.factory = factory;

},{"../docs":187}],191:[function(require,module,exports){
module.exports = [
  require('./compile'),
  require('./eval'),
  require('./help'),
  require('./parse'),
  require('./parser')
];

},{"./compile":188,"./eval":189,"./help":190,"./parse":192,"./parser":193}],192:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  var parse = load(require('../parse'));

  /**
   * Parse an expression. Returns a node tree, which can be evaluated by
   * invoking node.eval();
   *
   * Syntax:
   *
   *     math.parse(expr)
   *     math.parse(expr, options)
   *     math.parse([expr1, expr2, expr3, ...])
   *     math.parse([expr1, expr2, expr3, ...], options)
   *
   * Example:
   *
   *     var node = math.parse('sqrt(3^2 + 4^2)');
   *     node.compile().eval(); // 5
   *
   *     var scope = {a:3, b:4}
   *     var node = math.parse('a * b'); // 12
   *     var code = node.compile();
   *     code.eval(scope); // 12
   *     scope.a = 5;
   *     code.eval(scope); // 20
   *
   *     var nodes = math.parse(['a = 3', 'b = 4', 'a * b']);
   *     nodes[2].compile().eval(); // 12
   *
   * See also:
   *
   *     eval, compile
   *
   * @param {string | string[] | Matrix} expr          Expression to be parsed
   * @param {{nodes: Object<string, Node>}} [options]  Available options:
   *                                                   - `nodes` a set of custom nodes
   * @return {Node | Node[]} node
   * @throws {Error}
   */
  return typed('parse', {
    'string | Array | Matrix': parse,
    'string | Array | Matrix, Object': parse
  });
}

exports.name = 'parse';
exports.factory = factory;

},{"../parse":216}],193:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed, math) {
  var Parser = load(require('../Parser'));

  /**
   * Create a parser. The function creates a new `math.expression.Parser` object.
   *
   * Syntax:
   *
   *    math.parser()
   *
   * Examples:
   *
   *     var parser = new math.parser();
   *
   *     // evaluate expressions
   *     var a = parser.eval('sqrt(3^2 + 4^2)'); // 5
   *     var b = parser.eval('sqrt(-4)');        // 2i
   *     var c = parser.eval('2 inch in cm');    // 5.08 cm
   *     var d = parser.eval('cos(45 deg)');     // 0.7071067811865476
   *
   *     // define variables and functions
   *     parser.eval('x = 7 / 2');               // 3.5
   *     parser.eval('x + 3');                   // 6.5
   *     parser.eval('function f(x, y) = x^y');  // f(x, y)
   *     parser.eval('f(2, 3)');                 // 8
   *
   *     // get and set variables and functions
   *     var x = parser.get('x');                // 7
   *     var f = parser.get('f');                // function
   *     var g = f(3, 2);                        // 9
   *     parser.set('h', 500);
   *     var i = parser.eval('h / 2');           // 250
   *     parser.set('hello', function (name) {
   *       return 'hello, ' + name + '!';
   *     });
   *     parser.eval('hello("user")');           // "hello, user!"
   *
   *     // clear defined functions and variables
   *     parser.clear();
   *
   * See also:
   *
   *    eval, compile, parse
   *
   * @return {Parser} Parser
   */
  return typed('parser', {
    '': function () {
      return new Parser(math);
    }
  });
}

exports.name = 'parser';
exports.factory = factory;
exports.math = true; // requires the math namespace as 5th argument

},{"../Parser":15}],194:[function(require,module,exports){
module.exports = [
  require('./docs'),
  require('./function'),
  require('./node'),
  require('./transform'),

  require('./Help'),
  require('./parse'),
  require('./Parser')
];

},{"./Help":14,"./Parser":15,"./docs":187,"./function":191,"./node":212,"./parse":216,"./transform":221}],195:[function(require,module,exports){
'use strict';

// Reserved keywords not allowed to use in the parser
module.exports = {
  end: true
};

},{}],196:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  var Node = load(require('./Node'));
  var access = load(require('./utils/access'));

  /**
   * @constructor AccessorNode
   * @extends {Node}
   * Access an object property or get a matrix subset
   *
   * @param {Node} object                 The object from which to retrieve
   *                                      a property or subset.
   * @param {IndexNode} index             IndexNode containing ranges
   */
  function AccessorNode(object, index) {
    if (!(this instanceof AccessorNode)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    if (!(object && object.isNode)) {
      throw new TypeError('Node expected for parameter "object"');
    }
    if (!(index && index.isIndexNode)) {
      throw new TypeError('IndexNode expected for parameter "index"');
    }

    this.object = object || null;
    this.index = index;

    // readonly property name
    Object.defineProperty(this, 'name', {
      get: function () {
        if (this.index) {
          return (this.index.isObjectProperty())
              ? this.index.getObjectProperty()
              : '';
        }
        else {
          return this.object.name || '';
        }
      }.bind(this),
      set: function () {
        throw new Error('Cannot assign a new name, name is read-only');
      }
    });
  }

  AccessorNode.prototype = new Node();

  AccessorNode.prototype.type = 'AccessorNode';

  AccessorNode.prototype.isAccessorNode = true;

  /**
   * Compile the node to javascript code
   * @param {Object} defs     Object which can be used to define functions
   *                          or constants globally available for the compiled
   *                          expression
   * @param {Object} args     Object with local function arguments, the key is
   *                          the name of the argument, and the value is `true`.
   *                          The object may not be mutated, but must be
   *                          extended instead.
   * @return {string} js
   * @private
   */
  AccessorNode.prototype._compile = function (defs, args) {
    defs.access = access;

    var object = this.object._compile(defs, args);
    var index = this.index._compile(defs, args);

    if (this.index.isObjectProperty()) {
      return object + '["' + this.index.getObjectProperty() + '"]';
    }
    else if (this.index.needsSize()) {
      // if some parameters use the 'end' parameter, we need to calculate the size
      return '(function () {' +
          '  var object = ' + object + ';' +
          '  var size = math.size(object).valueOf();' +
          '  return access(object, ' + index + ');' +
          '})()';
    }
    else {
      return 'access(' + object + ', ' + index + ')';
    }
  };

  /**
   * Execute a callback for each of the child nodes of this node
   * @param {function(child: Node, path: string, parent: Node)} callback
   */
  AccessorNode.prototype.forEach = function (callback) {
    callback(this.object, 'object', this);
    callback(this.index, 'index', this);
  };

  /**
   * Create a new AccessorNode having it's childs be the results of calling
   * the provided callback function for each of the childs of the original node.
   * @param {function(child: Node, path: string, parent: Node): Node} callback
   * @returns {AccessorNode} Returns a transformed copy of the node
   */
  AccessorNode.prototype.map = function (callback) {
    return new AccessorNode(
        this._ifNode(callback(this.object, 'object', this)),
        this._ifNode(callback(this.index, 'index', this))
    );
  };

  /**
   * Create a clone of this node, a shallow copy
   * @return {AccessorNode}
   */
  AccessorNode.prototype.clone = function () {
    return new AccessorNode(this.object, this.index);
  };

  /**
   * Get string representation
   * @param {Object} options
   * @return {string}
   */
  AccessorNode.prototype._toString = function (options) {
    var object = this.object.toString(options);
    if (needParenthesis(this.object)) {
      object = '(' + object + ')';
    }

    return object + this.index.toString(options);
  };

  /**
   * Get LaTeX representation
   * @param {Object} options
   * @return {string}
   */
  AccessorNode.prototype._toTex = function (options) {
    var object = this.object.toTex(options);
    if (needParenthesis(this.object)) {
      object = '\\left(' + object + '\\right)';
    }

    return object + this.index.toTex(options);
  };

  /**
   * Are parenthesis needed?
   * @private
   */
  function needParenthesis(node) {
    // TODO: maybe make a method on the nodes which tells whether they need parenthesis?
    return !(node.isAccessorNode || node.isArrayNode || node.isConstantNode
        || node.isFunctionNode || node.isObjectNode || node.isParenthesisNode
        || node.isSymbolNode);
  }

  return AccessorNode;
}

exports.name = 'AccessorNode';
exports.path = 'expression.node';
exports.factory = factory;

},{"./Node":205,"./utils/access":213}],197:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  var Node = load(require('./Node'));

  /**
   * @constructor ArrayNode
   * @extends {Node}
   * Holds an 1-dimensional array with items
   * @param {Node[]} [items]   1 dimensional array with items
   */
  function ArrayNode(items) {
    if (!(this instanceof ArrayNode)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    this.items = items || [];

    // validate input
    if (!Array.isArray(this.items)
        || !this.items.every(function (item) {return item && item.isNode;})) {
      throw new TypeError('Array containing Nodes expected');
    }

    // TODO: deprecated since v3, remove some day
    var deprecated = function () {
      throw new Error('Property `ArrayNode.nodes` is deprecated, use `ArrayNode.items` instead');
    };
    Object.defineProperty(this, 'nodes', { get: deprecated, set: deprecated });
  }

  ArrayNode.prototype = new Node();

  ArrayNode.prototype.type = 'ArrayNode';

  ArrayNode.prototype.isArrayNode = true;

  /**
   * Compile the node to javascript code
   * @param {Object} defs     Object which can be used to define functions
   *                          or constants globally available for the compiled
   *                          expression
   * @param {Object} args     Object with local function arguments, the key is
   *                          the name of the argument, and the value is `true`.
   *                          The object may not be mutated, but must be
   *                          extended instead.
   * @private
   */
  ArrayNode.prototype._compile = function (defs, args) {
    var asMatrix = (defs.math.config().matrix !== 'Array');

    var items = this.items.map(function (node) {
      return node._compile(defs, args);
    });

    return (asMatrix ? 'math.matrix([' : '[') +
        items.join(',') +
        (asMatrix ? '])' : ']');
  };

  /**
   * Execute a callback for each of the child nodes of this node
   * @param {function(child: Node, path: string, parent: Node)} callback
   */
  ArrayNode.prototype.forEach = function (callback) {
    for (var i = 0; i < this.items.length; i++) {
      var node = this.items[i];
      callback(node, 'items[' + i + ']', this);
    }
  };

  /**
   * Create a new ArrayNode having it's childs be the results of calling
   * the provided callback function for each of the childs of the original node.
   * @param {function(child: Node, path: string, parent: Node): Node} callback
   * @returns {ArrayNode} Returns a transformed copy of the node
   */
  ArrayNode.prototype.map = function (callback) {
    var items = [];
    for (var i = 0; i < this.items.length; i++) {
      items[i] = this._ifNode(callback(this.items[i], 'items[' + i + ']', this));
    }
    return new ArrayNode(items);
  };

  /**
   * Create a clone of this node, a shallow copy
   * @return {ArrayNode}
   */
  ArrayNode.prototype.clone = function() {
    return new ArrayNode(this.items.slice(0));
  };

  /**
   * Get string representation
   * @param {Object} options
   * @return {string} str
   * @override
   */
  ArrayNode.prototype._toString = function(options) {
    var items = this.items.map(function (node) {
      return node.toString(options);
    });
    return '[' + items.join(', ') + ']';
  };

  /**
   * Get LaTeX representation
   * @param {Object} options
   * @return {string} str
   */
  ArrayNode.prototype._toTex = function(options) {
    var s = '\\begin{bmatrix}';

    this.items.forEach(function(node) {
      if (node.items) {
        s += node.items.map(function(childNode) {
          return childNode.toTex(options);
        }).join('&');
      }
      else {
        s += node.toTex(options);
      }

      // new line
      s += '\\\\';
    });
    s += '\\end{bmatrix}';
    return s;
  };

  return ArrayNode;
}

exports.name = 'ArrayNode';
exports.path = 'expression.node';
exports.factory = factory;

},{"./Node":205}],198:[function(require,module,exports){
'use strict';

var latex = require('../../utils/latex');

function factory (type, config, load, typed) {
  var Node = load(require('./Node'));
  var ArrayNode = load(require('./ArrayNode'));
  var matrix = load(require('../../type/matrix/function/matrix'));
  var assign = load(require('./utils/assign'));
  var access = load(require('./utils/access'));

  var keywords = require('../keywords');
  var operators = require('../operators');

  /**
   * @constructor AssignmentNode
   * @extends {Node}
   *
   * Define a symbol, like `a=3.2`, update a property like `a.b=3.2`, or
   * replace a subset of a matrix like `A[2,2]=42`.
   *
   * Syntax:
   *
   *     new AssignmentNode(symbol, value)
   *     new AssignmentNode(object, index, value)
   *
   * Usage:
   *
   *    new AssignmentNode(new SymbolNode('a'), new ConstantNode(2));                      // a=2
   *    new AssignmentNode(new SymbolNode('a'), new IndexNode('b'), new ConstantNode(2))   // a.b=2
   *    new AssignmentNode(new SymbolNode('a'), new IndexNode(1, 2), new ConstantNode(3))  // a[1,2]=3
   *
   * @param {SymbolNode | AccessorNode} object  Object on which to assign a value
   * @param {IndexNode} [index=null]            Index, property name or matrix
   *                                            index. Optional. If not provided
   *                                            and `object` is a SymbolNode,
   *                                            the property is assigned to the
   *                                            global scope.
   * @param {Node} value                        The value to be assigned
   */
  function AssignmentNode(object, index, value) {
    if (!(this instanceof AssignmentNode)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    this.object = object;
    this.index = value ? index : null;
    this.value = value ? value : index;

    // validate input
    if (!object || !(object.isSymbolNode || object.isAccessorNode)) {
      throw new TypeError('SymbolNode or AccessorNode expected as "object"');
    }
    if (object && object.isSymbolNode && object.name === 'end') {
      throw new Error('Cannot assign to symbol "end"');
    }
    if (this.index && !this.index.isIndexNode) {
      throw new TypeError('IndexNode expected as "index"');
    }
    if (!this.value || !this.value.isNode) {
      throw new TypeError('Node expected as "value"');
    }

    // readonly property name
    Object.defineProperty(this, 'name', {
      get: function () {
        if (this.index) {
          return (this.index.isObjectProperty())
              ? this.index.getObjectProperty()
              : '';
        }
        else {
          return this.object.name || '';
        }
      }.bind(this),
      set: function () {
        throw new Error('Cannot assign a new name, name is read-only');
      }
    });
  }

  AssignmentNode.prototype = new Node();

  AssignmentNode.prototype.type = 'AssignmentNode';

  AssignmentNode.prototype.isAssignmentNode = true;

  /**
   * Compile the node to javascript code
   * @param {Object} defs     Object which can be used to define functions
   *                          or constants globally available for the compiled
   *                          expression
   * @param {Object} args     Object with local function arguments, the key is
   *                          the name of the argument, and the value is `true`.
   *                          The object may not be mutated, but must be
   *                          extended instead.
   * @private
   */
  AssignmentNode.prototype._compile = function (defs, args) {
    defs.assign = assign;
    defs.access = access;

    var size;
    var object = this.object._compile(defs, args);
    var index = this.index ? this.index._compile(defs, args) : null;
    var value = this.value._compile(defs, args);

    if (!this.index) {
      // apply a variable to the scope, for example `a=2`
      if (!this.object.isSymbolNode) {
        throw new TypeError('SymbolNode expected as object');
      }

      return 'scope["' + this.object.name + '"] = ' + value;
    }
    else if (this.index.isObjectProperty()) {
      // apply an object property for example `a.b=2`
      return object + '["' + this.index.getObjectProperty() + '"] = ' + value;
    }
    else if (this.object.isSymbolNode) {
      // update a matrix subset, for example `a[2]=3`
      size = this.index.needsSize() ? 'var size = math.size(object).valueOf();' : '';

      // apply updated object to scope
      return '(function () {' +
          '  var object = ' + object + ';' +
          '  var value = ' + value + ';' +
          '  ' + size +
          '  scope["' + this.object.name + '"] = assign(object, ' + index + ', value);' +
          '  return value;' +
          '})()';
    }
    else { // this.object.isAccessorNode === true
      // update a matrix subset, for example `a.b[2]=3`
      size = this.index.needsSize() ? 'var size = math.size(object).valueOf();' : '';

      // we will not use the _compile of the AccessorNode, but compile it
      // ourselves here as we need the parent object of the AccessorNode:
      // wee need to apply the updated object to parent object
      var parentObject = this.object.object._compile(defs, args);

      if (this.object.index.isObjectProperty()) {
        var parentProperty = '["' + this.object.index.getObjectProperty() + '"]';
        return '(function () {' +
            '  var parent = ' + parentObject + ';' +
            '  var object = parent' + parentProperty + ';' + // parentIndex is a property
            '  var value = ' + value + ';' +
            size +
            '  parent' + parentProperty + ' = assign(object, ' + index + ', value);' +
            '  return value;' +
            '})()';
      }
      else {
        // if some parameters use the 'end' parameter, we need to calculate the size
        var parentSize = this.object.index.needsSize() ? 'var size = math.size(parent).valueOf();' : '';
        var parentIndex = this.object.index._compile(defs, args);

        return '(function () {' +
            '  var parent = ' + parentObject + ';' +
            '  ' + parentSize +
            '  var parentIndex = ' + parentIndex + ';' +
            '  var object = access(parent, parentIndex);' +
            '  var value = ' + value + ';' +
            '  ' + size +
            '  assign(parent, parentIndex, assign(object, ' + index + ', value));' +
            '  return value;' +
            '})()';
      }
    }
  };


  /**
   * Execute a callback for each of the child nodes of this node
   * @param {function(child: Node, path: string, parent: Node)} callback
   */
  AssignmentNode.prototype.forEach = function (callback) {
    callback(this.object, 'object', this);
    if (this.index) {
      callback(this.index, 'index', this);
    }
    callback(this.value, 'value', this);
  };

  /**
   * Create a new AssignmentNode having it's childs be the results of calling
   * the provided callback function for each of the childs of the original node.
   * @param {function(child: Node, path: string, parent: Node): Node} callback
   * @returns {AssignmentNode} Returns a transformed copy of the node
   */
  AssignmentNode.prototype.map = function (callback) {
    var object = this._ifNode(callback(this.object, 'object', this));
    var index = this.index
        ? this._ifNode(callback(this.index, 'index', this))
        : null;
    var value = this._ifNode(callback(this.value, 'value', this));

    return new AssignmentNode(object, index, value);
  };

  /**
   * Create a clone of this node, a shallow copy
   * @return {AssignmentNode}
   */
  AssignmentNode.prototype.clone = function() {
    return new AssignmentNode(this.object, this.index, this.value);
  };

  /*
   * Is parenthesis needed?
   * @param {node} node
   * @param {string} [parenthesis='keep']
   * @private
   */
  function needParenthesis(node, parenthesis) {
    if (!parenthesis) {
      parenthesis = 'keep';
    }

    var precedence = operators.getPrecedence(node, parenthesis);
    var exprPrecedence = operators.getPrecedence(node.value, parenthesis);
    return (parenthesis === 'all')
      || ((exprPrecedence !== null) && (exprPrecedence <= precedence));
  }

  /**
   * Get string representation
   * @param {Object} options
   * @return {string}
   */
  AssignmentNode.prototype._toString = function(options) {
    var object = this.object.toString(options);
    var index = this.index ? this.index.toString(options) : '';
    var value = this.value.toString(options);
    if (needParenthesis(this, options && options.parenthesis)) {
      value = '(' + value + ')';
    }

    return object + index + ' = ' + value;
  };

  /**
   * Get LaTeX representation
   * @param {Object} options
   * @return {string}
   */
  AssignmentNode.prototype._toTex = function(options) {
    var object = this.object.toTex(options);
    var index = this.index ? this.index.toTex(options) : '';
    var value = this.value.toTex(options);
    if (needParenthesis(this, options && options.parenthesis)) {
      value = '\\left(' + value + '\\right)';
    }

    return object + index + ':=' + value;
  };

  return AssignmentNode;
}

exports.name = 'AssignmentNode';
exports.path = 'expression.node';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../utils/latex":482,"../keywords":195,"../operators":215,"./ArrayNode":197,"./Node":205,"./utils/access":213,"./utils/assign":214}],199:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  var Node = load(require('./Node'));
  var ResultSet = load(require('../../type/resultset/ResultSet'));

  /**
   * @constructor BlockNode
   * @extends {Node}
   * Holds a set with blocks
   * @param {Array.<{node: Node} | {node: Node, visible: boolean}>} blocks
   *            An array with blocks, where a block is constructed as an Object
   *            with properties block, which is a Node, and visible, which is
   *            a boolean. The property visible is optional and is true by default
   */
  function BlockNode(blocks) {
    if (!(this instanceof BlockNode)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    // validate input, copy blocks
    if (!Array.isArray(blocks)) throw new Error('Array expected');
    this.blocks = blocks.map(function (block) {
      var node = block && block.node;
      var visible = block && block.visible !== undefined ? block.visible : true;

      if (!(node && node.isNode))      throw new TypeError('Property "node" must be a Node');
      if (typeof visible !== 'boolean') throw new TypeError('Property "visible" must be a boolean');

      return {
        node: node,
        visible: visible
      }
    });
  }

  BlockNode.prototype = new Node();

  BlockNode.prototype.type = 'BlockNode';

  BlockNode.prototype.isBlockNode = true;

  /**
   * Compile the node to javascript code
   * @param {Object} defs     Object which can be used to define functions
   *                          or constants globally available for the compiled
   *                          expression
   * @param {Object} args     Object with local function arguments, the key is
   *                          the name of the argument, and the value is `true`.
   *                          The object may not be mutated, but must be
   *                          extended instead.
   * @return {string} js
   * @private
   */
  BlockNode.prototype._compile = function (defs, args) {
    defs.ResultSet = ResultSet;
    var blocks = this.blocks.map(function (param) {
      var js = param.node._compile(defs, args);
      if (param.visible) {
        return 'results.push(' + js + ');';
      }
      else {
        return js + ';';
      }
    });

    return '(function () {' +
        'var results = [];' +
        blocks.join('') +
        'return new ResultSet(results);' +
        '})()';
  };

  /**
   * Execute a callback for each of the child blocks of this node
   * @param {function(child: Node, path: string, parent: Node)} callback
   */
  BlockNode.prototype.forEach = function (callback) {
    for (var i = 0; i < this.blocks.length; i++) {
      callback(this.blocks[i].node, 'blocks[' + i + '].node', this);
    }
  };

  /**
   * Create a new BlockNode having it's childs be the results of calling
   * the provided callback function for each of the childs of the original node.
   * @param {function(child: Node, path: string, parent: Node): Node} callback
   * @returns {BlockNode} Returns a transformed copy of the node
   */
  BlockNode.prototype.map = function (callback) {
    var blocks = [];
    for (var i = 0; i < this.blocks.length; i++) {
      var block = this.blocks[i];
      var node = this._ifNode(callback(block.node, 'blocks[' + i + '].node', this));
      blocks[i] = {
        node: node,
        visible: block.visible
      };
    }
    return new BlockNode(blocks);
  };

  /**
   * Create a clone of this node, a shallow copy
   * @return {BlockNode}
   */
  BlockNode.prototype.clone = function () {
    var blocks = this.blocks.map(function (block) {
      return {
        node: block.node,
        visible: block.visible
      };
    });

    return new BlockNode(blocks);
  };

  /**
   * Get string representation
   * @param {Object} options
   * @return {string} str
   * @override
   */
  BlockNode.prototype._toString = function (options) {
    return this.blocks.map(function (param) {
      return param.node.toString(options) + (param.visible ? '' : ';');
    }).join('\n');
  };

  /**
   * Get LaTeX representation
   * @param {Object} options
   * @return {string} str
   */
  BlockNode.prototype._toTex = function (options) {
    return this.blocks.map(function (param) {
      return param.node.toTex(options) + (param.visible ? '' : ';');
    }).join('\\;\\;\n');
  };

  return BlockNode;
}

exports.name = 'BlockNode';
exports.path = 'expression.node';
exports.factory = factory;

},{"../../type/resultset/ResultSet":453,"./Node":205}],200:[function(require,module,exports){
'use strict';

var latex = require('../../utils/latex');
var operators = require('../operators');

function factory (type, config, load, typed) {
  var Node = load(require('./Node'));

  /**
   * A lazy evaluating conditional operator: 'condition ? trueExpr : falseExpr'
   *
   * @param {Node} condition   Condition, must result in a boolean
   * @param {Node} trueExpr    Expression evaluated when condition is true
   * @param {Node} falseExpr   Expression evaluated when condition is true
   *
   * @constructor ConditionalNode
   * @extends {Node}
   */
  function ConditionalNode(condition, trueExpr, falseExpr) {
    if (!(this instanceof ConditionalNode)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }
    if (!(condition && condition.isNode)) throw new TypeError('Parameter condition must be a Node');
    if (!(trueExpr && trueExpr.isNode))  throw new TypeError('Parameter trueExpr must be a Node');
    if (!(falseExpr && falseExpr.isNode)) throw new TypeError('Parameter falseExpr must be a Node');

    this.condition = condition;
    this.trueExpr = trueExpr;
    this.falseExpr = falseExpr;
  }

  ConditionalNode.prototype = new Node();

  ConditionalNode.prototype.type = 'ConditionalNode';

  ConditionalNode.prototype.isConditionalNode = true;

  /**
   * Compile the node to javascript code
   * @param {Object} defs     Object which can be used to define functions
   *                          or constants globally available for the compiled
   *                          expression
   * @param {Object} args     Object with local function arguments, the key is
   *                          the name of the argument, and the value is `true`.
   *                          The object may not be mutated, but must be
   *                          extended instead.
   * @return {string} js
   * @private
   */
  ConditionalNode.prototype._compile = function (defs, args) {
    /**
     * Test whether a condition is met
     * @param {*} condition
     * @returns {boolean} true if condition is true or non-zero, else false
     */
    defs.testCondition = function (condition) {
      if (typeof condition === 'number'
          || typeof condition === 'boolean'
          || typeof condition === 'string') {
        return condition ? true : false;
      }

      if (condition) {
        if (condition.isBigNumber === true) {
          return condition.isZero() ? false : true;
        }

        if (condition.isComplex === true) {
          return (condition.re || condition.im) ? true : false;
        }

        if (condition.isUnit === true) {
          return condition.value ? true : false;
        }
      }

      if (condition === null || condition === undefined) {
        return false;
      }

      throw new TypeError('Unsupported type of condition "' + defs.math['typeof'](condition) + '"');
    };

    return (
      'testCondition(' + this.condition._compile(defs, args) + ') ? ' +
      '( ' + this.trueExpr._compile(defs, args) + ') : ' +
      '( ' + this.falseExpr._compile(defs, args) + ')'
    );
  };

  /**
   * Execute a callback for each of the child nodes of this node
   * @param {function(child: Node, path: string, parent: Node)} callback
   */
  ConditionalNode.prototype.forEach = function (callback) {
    callback(this.condition, 'condition', this);
    callback(this.trueExpr, 'trueExpr', this);
    callback(this.falseExpr, 'falseExpr', this);
  };

  /**
   * Create a new ConditionalNode having it's childs be the results of calling
   * the provided callback function for each of the childs of the original node.
   * @param {function(child: Node, path: string, parent: Node): Node} callback
   * @returns {ConditionalNode} Returns a transformed copy of the node
   */
  ConditionalNode.prototype.map = function (callback) {
    return new ConditionalNode(
        this._ifNode(callback(this.condition, 'condition', this)),
        this._ifNode(callback(this.trueExpr, 'trueExpr', this)),
        this._ifNode(callback(this.falseExpr, 'falseExpr', this))
    );
  };

  /**
   * Create a clone of this node, a shallow copy
   * @return {ConditionalNode}
   */
  ConditionalNode.prototype.clone = function () {
    return new ConditionalNode(this.condition, this.trueExpr, this.falseExpr);
  };

  /**
   * Get string representation
   * @param {Object} options
   * @return {string} str
   */
  ConditionalNode.prototype._toString = function (options) {
    var parenthesis = (options && options.parenthesis) ? options.parenthesis : 'keep';
    var precedence = operators.getPrecedence(this, parenthesis);

    //Enclose Arguments in parentheses if they are an OperatorNode
    //or have lower or equal precedence
    //NOTE: enclosing all OperatorNodes in parentheses is a decision
    //purely based on aesthetics and readability
    var condition = this.condition.toString(options);
    var conditionPrecedence = operators.getPrecedence(this.condition, parenthesis);
    if ((parenthesis === 'all')
        || (this.condition.type === 'OperatorNode')
        || ((conditionPrecedence !== null) && (conditionPrecedence <= precedence))) {
      condition = '(' + condition + ')';
    }

    var trueExpr = this.trueExpr.toString(options);
    var truePrecedence = operators.getPrecedence(this.trueExpr, parenthesis);
    if ((parenthesis === 'all')
        || (this.trueExpr.type === 'OperatorNode')
        || ((truePrecedence !== null) && (truePrecedence <= precedence))) {
      trueExpr = '(' + trueExpr + ')';
    }

    var falseExpr = this.falseExpr.toString(options);
    var falsePrecedence = operators.getPrecedence(this.falseExpr, parenthesis);
    if ((parenthesis === 'all')
        || (this.falseExpr.type === 'OperatorNode')
        || ((falsePrecedence !== null) && (falsePrecedence <= precedence))) {
      falseExpr = '(' + falseExpr + ')';
    }
    return condition + ' ? ' + trueExpr + ' : ' + falseExpr;
  };

  /**
   * Get LaTeX representation
   * @param {Object} options
   * @return {string} str
   */
  ConditionalNode.prototype._toTex = function (options) {
    return '\\begin{cases} {'
        + this.trueExpr.toTex(options) + '}, &\\quad{\\text{if }\\;'
        + this.condition.toTex(options)
        + '}\\\\{' + this.falseExpr.toTex(options)
        + '}, &\\quad{\\text{otherwise}}\\end{cases}';
  };

  return ConditionalNode;
}

exports.name = 'ConditionalNode';
exports.path = 'expression.node';
exports.factory = factory;

},{"../../utils/latex":482,"../operators":215,"./Node":205}],201:[function(require,module,exports){
'use strict';

var getType = require('../../utils/types').type;

function factory (type, config, load, typed) {
  var Node = load(require('./Node'));

  /**
   * A ConstantNode holds a constant value like a number or string. A ConstantNode
   * stores a stringified version of the value and uses this to compile to
   * JavaScript.
   *
   * In case of a stringified number as input, this may be compiled to a BigNumber
   * when the math instance is configured for BigNumbers.
   *
   * Usage:
   *
   *     // stringified values with type
   *     new ConstantNode('2.3', 'number');
   *     new ConstantNode('true', 'boolean');
   *     new ConstantNode('hello', 'string');
   *
   *     // non-stringified values, type will be automatically detected
   *     new ConstantNode(2.3);
   *     new ConstantNode('hello');
   *
   * @param {string | number | boolean | null | undefined} value
   *                            When valueType is provided, value must contain
   *                            an uninterpreted string representing the value.
   *                            When valueType is undefined, value can be a
   *                            number, string, boolean, null, or undefined, and
   *                            the type will be determined automatically.
   * @param {string} [valueType]  The type of value. Choose from 'number', 'string',
   *                              'boolean', 'undefined', 'null'
   * @constructor ConstantNode
   * @extends {Node}
   */
  function ConstantNode(value, valueType) {
    if (!(this instanceof ConstantNode)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    if (valueType) {
      if (typeof valueType !== 'string') {
        throw new TypeError('String expected for parameter "valueType"');
      }
      if (typeof value !== 'string') {
        throw new TypeError('String expected for parameter "value"');
      }

      this.value = value;
      this.valueType = valueType;
    }
    else {
      // stringify the value and determine the type
      this.value = value + '';
      this.valueType = getType(value);
    }

    if (!SUPPORTED_TYPES[this.valueType]) {
      throw new TypeError('Unsupported type of value "' + this.valueType + '"');
    }
  }

  var SUPPORTED_TYPES = {
    'number': true,
    'string': true,
    'boolean': true,
    'undefined': true,
    'null': true
  };

  ConstantNode.prototype = new Node();

  ConstantNode.prototype.type = 'ConstantNode';

  ConstantNode.prototype.isConstantNode = true;

  /**
   * Compile the node to javascript code
   * @param {Object} defs     Object which can be used to define functions
   *                          or constants globally available for the compiled
   *                          expression
   * @param {Object} args     Object with local function arguments, the key is
   *                          the name of the argument, and the value is `true`.
   *                          The object may not be mutated, but must be
   *                          extended instead.
   * @return {string} js
   * @private
   */
  ConstantNode.prototype._compile = function (defs, args) {
    switch (this.valueType) {
      case 'number':
        // TODO: replace this with using config.number
        var numConfig = defs.math.config().number;
        if (numConfig === 'BigNumber') {
          return 'math.bignumber("' + this.value + '")';
        }
        else if (numConfig === 'Fraction') {
          return 'math.fraction("' + this.value + '")';
        }
        else {
          // remove leading zeros like '003.2' which are not allowed by JavaScript
          return this.value.replace(/^(0*)[0-9]/, function (match, zeros) {
            return match.substring(zeros.length);
          });
        }

      case 'string':
        return '"' + this.value + '"';

      case 'boolean':
        return this.value;

      case 'undefined':
        return this.value;

      case 'null':
        return this.value;

      default:
        // TODO: move this error to the constructor?
        throw new TypeError('Unsupported type of constant "' + this.valueType + '"');
    }
  };

  /**
   * Execute a callback for each of the child nodes of this node
   * @param {function(child: Node, path: string, parent: Node)} callback
   */
  ConstantNode.prototype.forEach = function (callback) {
    // nothing to do, we don't have childs
  };


  /**
   * Create a new ConstantNode having it's childs be the results of calling
   * the provided callback function for each of the childs of the original node.
   * @param {function(child: Node, path: string, parent: Node) : Node} callback
   * @returns {ConstantNode} Returns a clone of the node
   */
  ConstantNode.prototype.map = function (callback) {
    return this.clone();
  };

  /**
   * Create a clone of this node, a shallow copy
   * @return {ConstantNode}
   */
  ConstantNode.prototype.clone = function () {
    return new ConstantNode(this.value, this.valueType);
  };

  /**
   * Get string representation
   * @param {Object} options
   * @return {string} str
   */
  ConstantNode.prototype._toString = function (options) {
    switch (this.valueType) {
      case 'string':
        return '"' + this.value + '"';

      default:
        return this.value;
    }
  };

  /**
   * Get LaTeX representation
   * @param {Object} options
   * @return {string} str
   */
  ConstantNode.prototype._toTex = function (options) {
    var value = this.value,
        index;
    switch (this.valueType) {
      case 'string':
        return '\\mathtt{"' + value + '"}';

      case 'number':
        index = value.toLowerCase().indexOf('e');
        if (index !== -1) {
          return value.substring(0, index) + '\\cdot10^{' +
              value.substring(index + 1) + '}';
        }
        return value;

      default:
        return value;
    }
  };

  return ConstantNode;
}

exports.name = 'ConstantNode';
exports.path = 'expression.node';
exports.factory = factory;

},{"../../utils/types":486,"./Node":205}],202:[function(require,module,exports){
'use strict';

var keywords = require('../keywords');
var latex = require('../../utils/latex');
var operators = require('../operators');

function isString (x) {
  return typeof x === 'string';
}

function factory (type, config, load, typed) {
  var Node = load(require('./Node'));

  /**
   * @constructor FunctionAssignmentNode
   * @extends {Node}
   * Function assignment
   *
   * @param {string} name           Function name
   * @param {string[]} params       Function parameter names
   * @param {Node} expr             The function expression
   */
  function FunctionAssignmentNode(name, params, expr) {
    if (!(this instanceof FunctionAssignmentNode)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    // validate input
    if (typeof name !== 'string') throw new TypeError('String expected for parameter "name"');
    if (!Array.isArray(params) || !params.every(isString))  throw new TypeError('Array containing strings expected for parameter "params"');
    if (!(expr && expr.isNode)) throw new TypeError('Node expected for parameter "expr"');
    if (name in keywords) throw new Error('Illegal function name, "' + name + '" is a reserved keyword');

    this.name = name;
    this.params = params;
    this.expr = expr;
  }

  FunctionAssignmentNode.prototype = new Node();

  FunctionAssignmentNode.prototype.type = 'FunctionAssignmentNode';

  FunctionAssignmentNode.prototype.isFunctionAssignmentNode = true;

  /**
   * Compile the node to javascript code
   * @param {Object} defs     Object which can be used to define functions
   *                          or constants globally available for the compiled
   *                          expression
   * @param {Object} args     Object with local function arguments, the key is
   *                          the name of the argument, and the value is `true`.
   *                          The object may not be mutated, but must be
   *                          extended instead.
   * @return {string} js
   * @private
   */
  FunctionAssignmentNode.prototype._compile = function (defs, args) {
    // we extend the original args and add the args to the child object
    var childArgs = Object.create(args);
    this.params.forEach(function (variable) {
      childArgs[variable] = true;
    });

    // compile the function expression with the child args
    var jsExpr = this.expr._compile(defs, childArgs);

    return 'scope["' + this.name + '"] = ' +
        '  (function () {' +
        '    var fn = function ' + this.name + '(' + this.params.join(',') + ') {' +
        '      if (arguments.length != ' + this.params.length + ') {' +
          // TODO: use util.error.ArgumentsError here?
          // TODO: test arguments error
        '        throw new SyntaxError("Wrong number of arguments in function ' + this.name + ' (" + arguments.length + " provided, ' + this.params.length + ' expected)");' +
        '      }' +
        '      return ' + jsExpr + '' +
        '    };' +
        '    fn.syntax = "' + this.name + '(' + this.params.join(', ') + ')";' +
        '    return fn;' +
        '  })()';
  };

  /**
   * Execute a callback for each of the child nodes of this node
   * @param {function(child: Node, path: string, parent: Node)} callback
   */
  FunctionAssignmentNode.prototype.forEach = function (callback) {
    callback(this.expr, 'expr', this);
  };

  /**
   * Create a new FunctionAssignmentNode having it's childs be the results of calling
   * the provided callback function for each of the childs of the original node.
   * @param {function(child: Node, path: string, parent: Node): Node} callback
   * @returns {FunctionAssignmentNode} Returns a transformed copy of the node
   */
  FunctionAssignmentNode.prototype.map = function (callback) {
    var expr = this._ifNode(callback(this.expr, 'expr', this));

    return new FunctionAssignmentNode(this.name, this.params.slice(0), expr);
  };

  /**
   * Create a clone of this node, a shallow copy
   * @return {FunctionAssignmentNode}
   */
  FunctionAssignmentNode.prototype.clone = function () {
    return new FunctionAssignmentNode(this.name, this.params.slice(0), this.expr);
  };

  /**
   * Is parenthesis needed?
   * @param {Node} node
   * @param {Object} parenthesis
   * @private
   */
  function needParenthesis(node, parenthesis) {
    var precedence = operators.getPrecedence(node, parenthesis);
    var exprPrecedence = operators.getPrecedence(node.expr, parenthesis);

    return (parenthesis === 'all')
      || ((exprPrecedence !== null) && (exprPrecedence <= precedence));
  }

  /**
   * get string representation
   * @param {Object} options
   * @return {string} str
   */
  FunctionAssignmentNode.prototype._toString = function (options) {
    var parenthesis = (options && options.parenthesis) ? options.parenthesis : 'keep';
    var expr = this.expr.toString(options);
    if (needParenthesis(this, parenthesis)) {
      expr = '(' + expr + ')';
    }
    return 'function ' + this.name +
        '(' + this.params.join(', ') + ') = ' + expr;
  };

  /**
   * get LaTeX representation
   * @param {Object} options
   * @return {string} str
   */
  FunctionAssignmentNode.prototype._toTex = function (options) {
    var parenthesis = (options && options.parenthesis) ? options.parenthesis : 'keep';
    var expr = this.expr.toTex(options);
    if (needParenthesis(this, parenthesis)) {
      expr = '\\left(' + expr + '\\right)';
    }

    return '\\mathrm{' + this.name
        + '}\\left(' + this.params.map(latex.toSymbol).join(',') + '\\right):=' + expr;
  };

  return FunctionAssignmentNode;
}
exports.name = 'FunctionAssignmentNode';
exports.path = 'expression.node';
exports.factory = factory;

},{"../../utils/latex":482,"../keywords":195,"../operators":215,"./Node":205}],203:[function(require,module,exports){
'use strict';

var latex = require('../../utils/latex');

function factory (type, config, load, typed, math) {
  var Node = load(require('./Node'));
  var SymbolNode = load(require('./SymbolNode'));

  /**
   * @constructor FunctionNode
   * @extends {./Node}
   * invoke a list with arguments on a node
   * @param {./Node} fn       Node resolving with a function on which to invoke
   *                          the arguments, typically a SymboNode or AccessorNode
   * @param {./Node[]} args
   */
  function FunctionNode(fn, args) {
    if (!(this instanceof FunctionNode)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    // TODO deprecated since v3.0, cleanup some day
    if (typeof fn === 'string') {
      console.warn('WARNING: passing a string to FunctionNode is deprecated, pass a SymbolNode instead.');
      fn = new SymbolNode(fn);
    }

    // validate input
    if (!fn || !fn.isNode) throw new TypeError('Node expected as parameter "fn"');
    if (!Array.isArray(args)
        || !args.every(function (arg) {return arg && arg.isNode;})) {
      throw new TypeError('Array containing Nodes expected for parameter "args"');
    }

    this.fn = fn;
    this.args = args || [];

    // readonly property name
    Object.defineProperty(this, 'name', {
      get: function () {
        return this.fn.name || '';
      }.bind(this),
      set: function () {
        throw new Error('Cannot assign a new name, name is read-only');
      }
    });

    // TODO: deprecated since v3, remove some day
    var deprecated = function () {
      throw new Error('Property `FunctionNode.object` is deprecated, use `FunctionNode.fn` instead');
    };
    Object.defineProperty(this, 'object', { get: deprecated, set: deprecated });
  }

  FunctionNode.prototype = new Node();

  FunctionNode.prototype.type = 'FunctionNode';

  FunctionNode.prototype.isFunctionNode = true;

  /**
   * Compile the node to javascript code
   * @param {Object} defs     Object which can be used to define functions
   *                          or constants globally available for the compiled
   *                          expression
   * @param {Object} args     Object with local function arguments, the key is
   *                          the name of the argument, and the value is `true`.
   *                          The object may not be mutated, but must be
   *                          extended instead.
   * @return {string} js
   * @private
   */
  FunctionNode.prototype._compile = function (defs, args) {
    // compile fn and arguments
    var jsFn = this.fn._compile(defs, args);
    var jsArgs = this.args.map(function (arg) {
      return arg._compile(defs, args);
    });
    var argsName;

    if (this.fn.isSymbolNode) {
      // we can statically determine whether the function has an rawArgs property
      var name = this.fn.name;
      var fn = defs.math[name];
      var isRaw = (typeof fn === 'function') && (fn.rawArgs == true);

      if (isRaw) {
        // pass unevaluated parameters (nodes) to the function
        argsName = this._getUniqueArgumentsName(defs);
        defs[argsName] = this.args;

        return jsFn + '(' + argsName + ', math, scope)';
      }
      else {
        // "regular" evaluation
        return jsFn + '(' + jsArgs.join(', ') + ')';
      }
    }
    else if (this.fn.isAccessorNode && this.fn.index.isObjectProperty()) {
      // execute the function with the right context: the object of the AccessorNode
      argsName = this._getUniqueArgumentsName(defs);
      defs[argsName] = this.args;

      var jsObject = this.fn.object._compile(defs, args);
      var prop = this.fn.index.getObjectProperty();

      return '(function () {' +
          'var object = ' + jsObject + ';' +
          'return (object["' + prop + '"] && object["' + prop + '"].rawArgs) ' +
          ' ? object["' + prop + '"](' + argsName + ', math, scope)' +
          ' : object["' + prop + '"](' + jsArgs.join(', ') + ')' +
          '})()';
    }
    else { // this.fn.isAccessorNode && !this.fn.index.isObjectProperty()
      // we have to dynamically determine whether the function has a rawArgs property
      argsName = this._getUniqueArgumentsName(defs);
      defs[argsName] = this.args;

      return '(function () {' +
          'var fn = ' + jsFn + ';' +
          'return (fn && fn.rawArgs) ' +
          ' ? fn(' + argsName + ', math, scope)' +
          ' : fn(' + jsArgs.join(', ') + ')' +
          '})()';
    }
  };

  /**
   * Get a unique name for a arguments to store in defs
   * @param {Object} defs
   * @return {string} A string like 'args1', 'args2', ...
   * @private
   */
  FunctionNode.prototype._getUniqueArgumentsName = function (defs) {
    var argsName;
    var i = 0;

    do {
      argsName = 'args' + i;
      i++;
    }
    while (argsName in defs);

    return argsName;
  };

  /**
   * Execute a callback for each of the child nodes of this node
   * @param {function(child: Node, path: string, parent: Node)} callback
   */
  FunctionNode.prototype.forEach = function (callback) {
    for (var i = 0; i < this.args.length; i++) {
      callback(this.args[i], 'args[' + i + ']', this);
    }
  };

  /**
   * Create a new FunctionNode having it's childs be the results of calling
   * the provided callback function for each of the childs of the original node.
   * @param {function(child: Node, path: string, parent: Node): Node} callback
   * @returns {FunctionNode} Returns a transformed copy of the node
   */
  FunctionNode.prototype.map = function (callback) {
    var fn = this.fn.map(callback);
    var args = [];
    for (var i = 0; i < this.args.length; i++) {
      args[i] = this._ifNode(callback(this.args[i], 'args[' + i + ']', this));
    }
    return new FunctionNode(fn, args);
  };

  /**
   * Create a clone of this node, a shallow copy
   * @return {FunctionNode}
   */
  FunctionNode.prototype.clone = function () {
    return new FunctionNode(this.fn, this.args.slice(0));
  };

  //backup Node's toString function
  //@private
  var nodeToString = FunctionNode.prototype.toString;

  /**
   * Get string representation. (wrapper function)
   * This overrides parts of Node's toString function.
   * If callback is an object containing callbacks, it
   * calls the correct callback for the current node,
   * otherwise it falls back to calling Node's toString
   * function.
   *
   * @param {Object} options
   * @return {string} str
   * @override
   */
  FunctionNode.prototype.toString = function (options) {
    var customString;
    var name = this.fn.toString();
    if (options && (typeof options.handler === 'object') && options.handler.hasOwnProperty(name)) {
      //callback is a map of callback functions
      customString = options.handler[name](this, options);
    }

    if (typeof customString !== 'undefined') {
      return customString;
    }

    //fall back to Node's toString
    return nodeToString.call(this, options);
  };

  /**
   * Get string representation
   * @param {Object} options
   * @return {string} str
   */
  FunctionNode.prototype._toString = function (options) {
    // format the parameters like "add(2, 4.2)"
    return this.fn.toString() + '(' + this.args.join(', ') + ')';
  };

  /*
   * Expand a LaTeX template
   *
   * @param {string} template
   * @param {Node} node
   * @param {Object} options
   * @private
   **/
  function expandTemplate(template, node, options) {
    var latex = '';

    // Match everything of the form ${identifier} or ${identifier[2]} or $$
    // while submatching identifier and 2 (in the second case)
    var regex = new RegExp('\\$(?:\\{([a-z_][a-z_0-9]*)(?:\\[([0-9]+)\\])?\\}|\\$)', 'ig');

    var inputPos = 0;   //position in the input string
    var match;
    while ((match = regex.exec(template)) !== null) {   //go through all matches
      // add everything in front of the match to the LaTeX string
      latex += template.substring(inputPos, match.index);
      inputPos = match.index;

      if (match[0] === '$$') { // escaped dollar sign
        latex += '$';
        inputPos++;
      }
      else { // template parameter
        inputPos += match[0].length;
        var property = node[match[1]];
        if (!property) {
          throw new ReferenceError('Template: Property ' + match[1] + ' does not exist.');
        }
        if (match[2] === undefined) { //no square brackets
          switch (typeof property) {
            case 'string':
              latex += property;
              break;
            case 'object':
              if (property.isNode) {
                latex += property.toTex(options);
              }
              else if (Array.isArray(property)) {
                //make array of Nodes into comma separated list
                latex += property.map(function (arg, index) {
                  if (arg && arg.isNode) {
                    return arg.toTex(options);
                  }
                  throw new TypeError('Template: ' + match[1] + '[' + index + '] is not a Node.');
                }).join(',');
              }
              else {
                throw new TypeError('Template: ' + match[1] + ' has to be a Node, String or array of Nodes');
              }
              break;
            default:
              throw new TypeError('Template: ' + match[1] + ' has to be a Node, String or array of Nodes');
          }
        }
        else { //with square brackets
          if (property[match[2]] && property[match[2]].isNode) {
            latex += property[match[2]].toTex(options);
          }
          else {
            throw new TypeError('Template: ' + match[1] + '[' + match[2] + '] is not a Node.');
          }
        }
      }
    }
    latex += template.slice(inputPos);  //append rest of the template

    return latex;
  }

  //backup Node's toTex function
  //@private
  var nodeToTex = FunctionNode.prototype.toTex;

  /**
   * Get LaTeX representation. (wrapper function)
   * This overrides parts of Node's toTex function.
   * If callback is an object containing callbacks, it
   * calls the correct callback for the current node,
   * otherwise it falls back to calling Node's toTex
   * function.
   *
   * @param {Object} options
   * @return {string}
   */
  FunctionNode.prototype.toTex = function (options) {
    var customTex;
    if (options && (typeof options.handler === 'object') && options.handler.hasOwnProperty(this.name)) {
      //callback is a map of callback functions
      customTex = options.handler[this.name](this, options);
    }

    if (typeof customTex !== 'undefined') {
      return customTex;
    }

    //fall back to Node's toTex
    return nodeToTex.call(this, options);
  };

  /**
   * Get LaTeX representation
   * @param {Object} options
   * @return {string} str
   */
  FunctionNode.prototype._toTex = function (options) {
    var parenthesis = (options && options.parenthesis) ? options.parenthesis : 'keep';


    var args = this.args.map(function (arg) { //get LaTeX of the arguments
      return arg.toTex(options);
    });

    var latexConverter;

    if (math[this.name] && ((typeof math[this.name].toTex === 'function') || (typeof math[this.name].toTex === 'object') || (typeof math[this.name].toTex === 'string'))) {
      //.toTex is a callback function
      latexConverter = math[this.name].toTex;
    }

    var customToTex;
    switch (typeof latexConverter) {
      case 'function': //a callback function
        customToTex = latexConverter(this, options);
        break;
      case 'string': //a template string
        customToTex = expandTemplate(latexConverter, this, options);
        break;
      case 'object': //an object with different "converters" for different numbers of arguments
        switch (typeof latexConverter[args.length]) {
          case 'function':
            customToTex = latexConverter[args.length](this, options);
            break;
          case 'string':
            customToTex = expandTemplate(latexConverter[args.length], this, options);
            break;
        }
    }

    if (typeof customToTex !== 'undefined') {
      return customToTex;
    }

    return expandTemplate(latex.defaultTemplate, this, options);
  };

  /**
   * Get identifier.
   * @return {string}
   */
  FunctionNode.prototype.getIdentifier = function () {
    return this.type + ':' + this.name;
  };

  return FunctionNode;
}

exports.name = 'FunctionNode';
exports.path = 'expression.node';
exports.math = true; // request access to the math namespace as 5th argument of the factory function
exports.factory = factory;

},{"../../utils/latex":482,"./Node":205,"./SymbolNode":210}],204:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  var Node = load(require('./Node'));
  var RangeNode = load(require('./RangeNode'));
  var SymbolNode = load(require('./SymbolNode'));

  var Range = load(require('../../type/matrix/Range'));

  var isArray = Array.isArray;

  /**
   * @constructor IndexNode
   * @extends Node
   *
   * Describes a subset of a matrix or an object property.
   * Cannot be used on its own, needs to be used within an AccessorNode or
   * AssignmentNode.
   *
   * @param {Node[]} dimensions
   * @param {boolean} [dotNotation=false]  Optional property describing whether
   *                                       this index was written using dot
   *                                       notation like `a.b`, or using bracket
   *                                       notation like `a["b"]` (default).
   *                                       Used to stringify an IndexNode.
   */
  function IndexNode(dimensions, dotNotation) {
    if (!(this instanceof IndexNode)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    this.dimensions = dimensions;
    this.dotNotation = dotNotation || false;

    // validate input
    if (!isArray(dimensions)
        || !dimensions.every(function (range) {return range && range.isNode;})) {
      throw new TypeError('Array containing Nodes expected for parameter "dimensions"');
    }
    if (this.dotNotation && !this.isObjectProperty()) {
      throw new Error('dotNotation only applicable for object properties');
    }

    // TODO: deprecated since v3, remove some day
    var deprecated = function () {
      throw new Error('Property `IndexNode.object` is deprecated, use `IndexNode.fn` instead');
    };
    Object.defineProperty(this, 'object', { get: deprecated, set: deprecated });
  }

  IndexNode.prototype = new Node();

  IndexNode.prototype.type = 'IndexNode';

  IndexNode.prototype.isIndexNode = true;

  /**
   * Compile all range nodes
   *
   * When some of the dimensions has `end` defined, the IndexNode requires
   * a variable `size` to be defined in the current closure, and must contain
   * the size of the matrix that's being handled. To check whether the `size`
   * variable is needed, call IndexNode.needsSize().
   *
   * @param {Object} defs           Object which can be used to define functions
   *                                or constants globally available for the
   *                                compiled expression
   * @param {Object} args           Object with local function arguments, the key is
   *                                the name of the argument, and the value is `true`.
   *                                The object may not be mutated, but must be
   *                                extended instead.
   * @return {string} code
   */
  IndexNode.prototype._compile = function (defs, args) {
    // args can be mutated by IndexNode, when dimensions use `end`
    var childArgs = Object.create(args);

    // helper function to create a Range from start, step and end
    defs.range = function (start, end, step) {
      return new Range(
          (start && start.isBigNumber === true) ? start.toNumber() : start,
          (end   && end.isBigNumber === true)   ? end.toNumber()   : end,
          (step  && step.isBigNumber === true)  ? step.toNumber()  : step
      );
    };

    // TODO: implement support for bignumber (currently bignumbers are silently
    //       reduced to numbers when changing the value to zero-based)

    // TODO: Optimization: when the range values are ConstantNodes,
    //       we can beforehand resolve the zero-based value

    // optimization for a simple object property
    var dimensions = this.dimensions.map(function (range, i) {
      if (range && range.isRangeNode) {
        if (range.needsEnd()) {
          childArgs.end = true;

          // resolve end and create range
          return '(function () {' +
              'var end = size[' + i + ']; ' +
              'return range(' +
              range.start._compile(defs, childArgs) + ', ' +
              range.end._compile(defs, childArgs) + ', ' +
              (range.step ? range.step._compile(defs, childArgs) : '1') +
              '); ' +
              '})()';
        }
        else {
          // create range
          return 'range(' +
              range.start._compile(defs, childArgs) + ', ' +
              range.end._compile(defs, childArgs) + ', ' +
              (range.step ? range.step._compile(defs, childArgs) : '1') +
              ')';
        }
      }
      if (range.isSymbolNode && range.name === 'end') {
        childArgs.end = true;

        // resolve the parameter 'end'
        return '(function () {' +
            'var end = size[' + i + ']; ' +
            'return ' + range._compile(defs, childArgs) + '; ' +
            '})()'
      }
      else { // ConstantNode
        return range._compile(defs, childArgs);
      }
    });

    return 'math.index(' + dimensions.join(', ') + ')';
  };

  /**
   * Execute a callback for each of the child nodes of this node
   * @param {function(child: Node, path: string, parent: Node)} callback
   */
  IndexNode.prototype.forEach = function (callback) {
    for (var i = 0; i < this.dimensions.length; i++) {
      callback(this.dimensions[i], 'dimensions[' + i + ']', this);
    }
  };

  /**
   * Create a new IndexNode having it's childs be the results of calling
   * the provided callback function for each of the childs of the original node.
   * @param {function(child: Node, path: string, parent: Node): Node} callback
   * @returns {IndexNode} Returns a transformed copy of the node
   */
  IndexNode.prototype.map = function (callback) {
    var dimensions = [];
    for (var i = 0; i < this.dimensions.length; i++) {
      dimensions[i] = this._ifNode(callback(this.dimensions[i], 'dimensions[' + i + ']', this));
    }

    return new IndexNode(dimensions);
  };

  /**
   * Create a clone of this node, a shallow copy
   * @return {IndexNode}
   */
  IndexNode.prototype.clone = function () {
    return new IndexNode(this.dimensions.slice(0));
  };

  /**
   * Test whether this IndexNode contains a single property name
   * @return {boolean}
   */
  IndexNode.prototype.isObjectProperty = function () {
    return this.dimensions.length === 1 &&
        this.dimensions[0].isConstantNode &&
        this.dimensions[0].valueType === 'string';
  };

  /**
   * Returns the property name if IndexNode contains a property.
   * If not, returns null.
   * @return {string | null}
   */
  IndexNode.prototype.getObjectProperty = function () {
    return this.isObjectProperty() ? this.dimensions[0].value : null;
  };

  /**
   * Get string representation
   * @param {Object} options
   * @return {string} str
   */
  IndexNode.prototype._toString = function (options) {
    // format the parameters like "[1, 0:5]"
    return this.dotNotation
        ? ('.' + this.getObjectProperty())
        : ('[' + this.dimensions.join(', ') + ']');
  };

  /**
   * Get LaTeX representation
   * @param {Object} options
   * @return {string} str
   */
  IndexNode.prototype._toTex = function (options) {
    var dimensions = this.dimensions.map(function (range) {
      return range.toTex(options);
    });

    return this.dotNotation
        ? ('.' + this.getObjectProperty() + '')
        : ('_{' + dimensions.join(',') + '}');
  };

  /**
   * Test whether this IndexNode needs the object size, size of the Matrix
   * @return {boolean}
   */
  IndexNode.prototype.needsSize = function () {
    return this.dimensions.some(function (range) {
      return (range.isRangeNode && range.needsEnd()) ||
          (range.isSymbolNode && range.name === 'end');
    });
  };

  return IndexNode;
}

exports.name = 'IndexNode';
exports.path = 'expression.node';
exports.factory = factory;

},{"../../type/matrix/Range":431,"./Node":205,"./RangeNode":209,"./SymbolNode":210}],205:[function(require,module,exports){
'use strict';

var keywords = require('../keywords');
var extend = require('../../utils/object').extend;

function factory (type, config, load, typed, math) {
  /**
   * Node
   */
  function Node() {
    if (!(this instanceof Node)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }
  }

  /**
   * Evaluate the node
   * @param {Object} [scope]  Scope to read/write variables
   * @return {*}              Returns the result
   */
  Node.prototype.eval = function(scope) {
    return this.compile().eval(scope);
  };

  Node.prototype.type = 'Node';

  Node.prototype.isNode = true;

  /**
   * Compile the node to javascript code
   * @return {{eval: function}} expr  Returns an object with a function 'eval',
   *                                  which can be invoked as expr.eval([scope]),
   *                                  where scope is an optional object with
   *                                  variables.
   */
  Node.prototype.compile = function () {
    // TODO: calling compile(math) is deprecated since version 2.0.0. Remove this warning some day
    if (arguments.length > 0) {
      throw new Error('Calling compile(math) is deprecated. Call the function as compile() instead.');
    }

    // definitions globally available inside the closure of the compiled expressions
    var defs = {
      math: math.expression.transform,
      args: {}, // can be filled with names of FunctionAssignment arguments
      _validateScope: _validateScope
    };

    // will be used to put local function arguments
    var args = {};

    var code = this._compile(defs, args);

    var defsCode = Object.keys(defs).map(function (name) {
      return '    var ' + name + ' = defs["' + name + '"];';
    });

    var factoryCode =
        defsCode.join(' ') +
        'return {' +
        '  "eval": function (scope) {' +
        '    if (scope) _validateScope(scope);' +
        '    scope = scope || {};' +
        '    return ' + code + ';' +
        '  }' +
        '};';

    var factory = new Function('defs', factoryCode);
    return factory(defs);
  };

  /**
   * Compile the node to javascript code
   * @param {Object} defs     Object which can be used to define functions
   *                          and constants globally available inside the closure
   *                          of the compiled expression
   * @param {Object} args     Object with local function arguments, the key is
   *                          the name of the argument, and the value is `true`.
   *                          The object may not be mutated, but must be
   *                          extended instead.
   * @return {string} js
   * @private
   */
  Node.prototype._compile = function (defs, args) {
    // must be implemented by each of the Node implementations
    throw new Error('Cannot compile a Node interface');
  };

  /**
   * Execute a callback for each of the child nodes of this node
   * @param {function(child: Node, path: string, parent: Node)} callback
   */
  Node.prototype.forEach = function (callback) {
    // must be implemented by each of the Node implementations
    throw new Error('Cannot run forEach on a Node interface');
  };

  /**
   * Create a new Node having it's childs be the results of calling
   * the provided callback function for each of the childs of the original node.
   * @param {function(child: Node, path: string, parent: Node): Node} callback
   * @returns {OperatorNode} Returns a transformed copy of the node
   */
  Node.prototype.map = function (callback) {
    // must be implemented by each of the Node implementations
    throw new Error('Cannot run map on a Node interface');
  };

  /**
   * Validate whether an object is a Node, for use with map
   * @param {Node} node
   * @returns {Node} Returns the input if it's a node, else throws an Error
   * @protected
   */
  Node.prototype._ifNode = function (node) {
    if (!(node && node.isNode)) {
      throw new TypeError('Callback function must return a Node');
    }

    return node;
  };

  /**
   * Recursively traverse all nodes in a node tree. Executes given callback for
   * this node and each of its child nodes.
   * @param {function(node: Node, path: string, parent: Node)} callback
   *          A callback called for every node in the node tree.
   */
  Node.prototype.traverse = function (callback) {
    // execute callback for itself
    callback(this, null, null);

    // recursively traverse over all childs of a node
    function _traverse(node, callback) {
      node.forEach(function (child, path, parent) {
        callback(child, path, parent);
        _traverse(child, callback);
      });
    }

    _traverse(this, callback);
  };

  /**
   * Recursively transform a node tree via a transform function.
   *
   * For example, to replace all nodes of type SymbolNode having name 'x' with a
   * ConstantNode with value 2:
   *
   *     var res = Node.transform(function (node, path, parent) {
   *       if (node && node.isSymbolNode) && (node.name == 'x')) {
   *         return new ConstantNode(2);
   *       }
   *       else {
   *         return node;
   *       }
   *     });
   *
   * @param {function(node: Node, path: string, parent: Node) : Node} callback
   *          A mapping function accepting a node, and returning
   *          a replacement for the node or the original node.
   *          Signature: callback(node: Node, index: string, parent: Node) : Node
   * @return {Node} Returns the original node or its replacement
   */
  Node.prototype.transform = function (callback) {
    // traverse over all childs
    function _transform (node, callback) {
      return node.map(function(child, path, parent) {
        var replacement = callback(child, path, parent);
        return _transform(replacement, callback);
      });
    }

    var replacement = callback(this, null, null);
    return _transform(replacement, callback);
  };

  /**
   * Find any node in the node tree matching given filter function. For example, to
   * find all nodes of type SymbolNode having name 'x':
   *
   *     var results = Node.filter(function (node) {
   *       return (node && node.isSymbolNode) && (node.name == 'x');
   *     });
   *
   * @param {function(node: Node, path: string, parent: Node) : Node} callback
   *            A test function returning true when a node matches, and false
   *            otherwise. Function signature:
   *            callback(node: Node, index: string, parent: Node) : boolean
   * @return {Node[]} nodes       An array with nodes matching given filter criteria
   */
  Node.prototype.filter = function (callback) {
    var nodes = [];

    this.traverse(function (node, path, parent) {
      if (callback(node, path, parent)) {
        nodes.push(node);
      }
    });

    return nodes;
  };

  // TODO: deprecated since version 1.1.0, remove this some day
  Node.prototype.find = function () {
    throw new Error('Function Node.find is deprecated. Use Node.filter instead.');
  };

  // TODO: deprecated since version 1.1.0, remove this some day
  Node.prototype.match = function () {
    throw new Error('Function Node.match is deprecated. See functions Node.filter, Node.transform, Node.traverse.');
  };

  /**
   * Create a clone of this node, a shallow copy
   * @return {Node}
   */
  Node.prototype.clone = function () {
    // must be implemented by each of the Node implementations
    throw new Error('Cannot clone a Node interface');
  };

  /**
  /**
   * Get string representation. (wrapper function)
   *
   * This function can get an object of the following form:
   * {
   *    handler: //This can be a callback function of the form
   *             // "function callback(node, options)"or
   *             // a map that maps function names (used in FunctionNodes)
   *             // to callbacks
   *    parenthesis: "keep" //the parenthesis option (This is optional)
   * }
   *
   * @param {Object} [options]
   * @return {string}
   */
  Node.prototype.toString = function (options) {
    var customString;
    if (options && typeof options == "object") {
        switch (typeof options.handler) {
          case 'object':
          case 'undefined':
            break;
          case 'function':
            customString = options.handler(this, options);
            break;
          default:
            throw new TypeError('Object or function expected as callback');
        }
    }

    if (typeof customString !== 'undefined') {
      return customString;
    }

    return this._toString(options);
  };

  /**
   * Internal function to generate the string output.
   * This has to be implemented by every Node
   *
   * @throws {Error}
   */
  Node.prototype._toString = function () {
    //must be implemented by each of the Node implementations
    throw new Error('_toString not implemented for ' + this.type);
  };

  /**
   * Get LaTeX representation. (wrapper function)
   *
   * This function can get an object of the following form:
   * {
   *    handler: //This can be a callback function of the form
   *             // "function callback(node, options)"or
   *             // a map that maps function names (used in FunctionNodes)
   *             // to callbacks
   *    parenthesis: "keep" //the parenthesis option (This is optional)
   * }
   *
   * @param {Object} [options]
   * @return {string}
   */
  Node.prototype.toTex = function (options) {
    var customTex;
    if (options && typeof options == 'object') {
      switch (typeof options.handler) {
        case 'object':
        case 'undefined':
          break;
        case 'function':
          customTex = options.handler(this, options);
          break;
        default:
          throw new TypeError('Object or function expected as callback');
      }
    }

    if (typeof customTex !== 'undefined') {
      return customTex;
    }

    return this._toTex(options);
  };

  /**
   * Internal function to generate the LaTeX output.
   * This has to be implemented by every Node
   *
   * @param {Object} [options]
   * @throws {Error}
   */
  Node.prototype._toTex = function (options) {
    //must be implemented by each of the Node implementations
    throw new Error('_toTex not implemented for ' + this.type);
  };

  /**
   * Get identifier.
   * @return {string}
   */
  Node.prototype.getIdentifier = function () {
    return this.type;
  };

  /**
   * Get the content of the current Node.
   * @return {Node} node
   **/
  Node.prototype.getContent = function () {
    return this;
  };

  /**
   * Validate the symbol names of a scope.
   * Throws an error when the scope contains an illegal symbol.
   * @param {Object} scope
   */
  function _validateScope(scope) {
    for (var symbol in scope) {
      if (scope.hasOwnProperty(symbol)) {
        if (symbol in keywords) {
          throw new Error('Scope contains an illegal symbol, "' + symbol + '" is a reserved keyword');
        }
      }
    }
  }

  return Node;
}

exports.name = 'Node';
exports.path = 'expression.node';
exports.math = true; // request access to the math namespace as 5th argument of the factory function
exports.factory = factory;

},{"../../utils/object":484,"../keywords":195}],206:[function(require,module,exports){
'use strict';

var string = require('../../utils/string');

function factory (type, config, load, typed) {
  var Node = load(require('./Node'));

  /**
   * @constructor ObjectNode
   * @extends {Node}
   * Holds an object with keys/values
   * @param {Object.<string, Node>} [properties]   array with key/value pairs
   */
  function ObjectNode(properties) {
    if (!(this instanceof ObjectNode)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    this.properties = properties || {};

    // validate input
    if (properties) {
      if (!(typeof properties === 'object') || Object.keys(properties).some(function (key) {
            return !properties[key] || !properties[key].isNode;
          })) {
        throw new TypeError('Object containing Nodes expected');
      }
    }
  }

  ObjectNode.prototype = new Node();

  ObjectNode.prototype.type = 'ObjectNode';

  ObjectNode.prototype.isObjectNode = true;

  /**
   * Compile the node to javascript code
   * @param {Object} defs     Object which can be used to define functions
   *                          or constants globally available for the compiled
   *                          expression
   * @param {Object} args     Object with local function arguments, the key is
   *                          the name of the argument, and the value is `true`.
   *                          The object may not be mutated, but must be
   *                          extended instead.
   * @return {string} code
   * @private
   */
  ObjectNode.prototype._compile = function (defs, args) {
    var entries = [];
    for (var key in this.properties) {
      if (this.properties.hasOwnProperty(key)) {
        entries.push('"' + key + '": ' + this.properties[key]._compile(defs, args));
      }
    }
    return '{' + entries.join(', ') + '}';
  };

  /**
   * Execute a callback for each of the child nodes of this node
   * @param {function(child: Node, path: string, parent: Node)} callback
   */
  ObjectNode.prototype.forEach = function (callback) {
    for (var key in this.properties) {
      if (this.properties.hasOwnProperty(key)) {
        callback(this.properties[key], 'properties["' + key + '"]', this);
      }
    }
  };

  /**
   * Create a new ObjectNode having it's childs be the results of calling
   * the provided callback function for each of the childs of the original node.
   * @param {function(child: Node, path: string, parent: Node): Node} callback
   * @returns {ObjectNode} Returns a transformed copy of the node
   */
  ObjectNode.prototype.map = function (callback) {
    var properties = {};
    for (var key in this.properties) {
      if (this.properties.hasOwnProperty(key)) {
        properties[key] = this._ifNode(callback(this.properties[key], 'properties["' + key + '"]', this));
      }
    }
    return new ObjectNode(properties);
  };

  /**
   * Create a clone of this node, a shallow copy
   * @return {ObjectNode}
   */
  ObjectNode.prototype.clone = function() {
    var properties = {};
    for (var key in this.properties) {
      if (this.properties.hasOwnProperty(key)) {
        properties[key] = this.properties[key];
      }
    }
    return new ObjectNode(properties);
  };

  /**
   * Get string representation
   * @param {Object} options
   * @return {string} str
   * @override
   */
  ObjectNode.prototype._toString = function(options) {
    var entries = [];
    for (var key in this.properties) {
      if (this.properties.hasOwnProperty(key)) {
        entries.push('"' + key + '": ' + this.properties[key].toString(options));
      }
    }
    return '{' + entries.join(', ') + '}';
  };

  /**
   * Get LaTeX representation
   * @param {Object} options
   * @return {string} str
   */
  ObjectNode.prototype._toTex = function(options) {
    var entries = [];
    for (var key in this.properties) {
      if (this.properties.hasOwnProperty(key)) {
        entries.push("\\mathbf{" + key + ':} & ' + this.properties[key].toTex(options) + "\\\\");
      }
    }
    return '\\left\\{\\begin{array}{ll}' + entries.join('\n') + '\\end{array}\\right\\}';
  };

  return ObjectNode;
}

exports.name = 'ObjectNode';
exports.path = 'expression.node';
exports.factory = factory;

},{"../../utils/string":485,"./Node":205}],207:[function(require,module,exports){
'use strict';

var latex = require('../../utils/latex');
var operators = require('../operators');

function factory (type, config, load, typed, math) {
  var Node         = load(require('./Node'));
  var ConstantNode = load(require('./ConstantNode'));
  var SymbolNode   = load(require('./SymbolNode'));
  var FunctionNode = load(require('./FunctionNode'));

  /**
   * @constructor OperatorNode
   * @extends {Node}
   * An operator with two arguments, like 2+3
   *
   * @param {string} op       Operator name, for example '+'
   * @param {string} fn       Function name, for example 'add'
   * @param {Node[]} args     Operator arguments
   * @param {boolean} implicit Is this an implicit multiplication?
   */
  function OperatorNode(op, fn, args, implicit) {
    if (!(this instanceof OperatorNode)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    //validate input
    if (typeof op !== 'string') {
      throw new TypeError('string expected for parameter "op"');
    }
    if (typeof fn !== 'string') {
      throw new TypeError('string expected for parameter "fn"');
    }
    if (!Array.isArray(args)
        || !args.every(function (node) {return node && node.isNode;})) {
      throw new TypeError('Array containing Nodes expected for parameter "args"');
    }

    this.implicit = (implicit === true);
    this.op = op;
    this.fn = fn;
    this.args = args || [];
  }

  OperatorNode.prototype = new Node();

  OperatorNode.prototype.type = 'OperatorNode';

  OperatorNode.prototype.isOperatorNode = true;

  /**
   * Compile the node to javascript code
   * @param {Object} defs     Object which can be used to define functions
   *                          or constants globally available for the compiled
   *                          expression
   * @param {Object} args     Object with local function arguments, the key is
   *                          the name of the argument, and the value is `true`.
   *                          The object may not be mutated, but must be
   *                          extended instead.
   * @return {string} js
   * @private
   */
  OperatorNode.prototype._compile = function (defs, args) {
    if (!defs.math[this.fn]) {
      throw new Error('Function ' + this.fn + ' missing in provided namespace "math"');
    }

    var jsArgs = this.args.map(function (arg) {
      return arg._compile(defs, args);
    });

    return 'math.' + this.fn + '(' + jsArgs.join(', ') + ')';
  };

  /**
   * Execute a callback for each of the child nodes of this node
   * @param {function(child: Node, path: string, parent: Node)} callback
   */
  OperatorNode.prototype.forEach = function (callback) {
    for (var i = 0; i < this.args.length; i++) {
      callback(this.args[i], 'args[' + i + ']', this);
    }
  };

  /**
   * Create a new OperatorNode having it's childs be the results of calling
   * the provided callback function for each of the childs of the original node.
   * @param {function(child: Node, path: string, parent: Node): Node} callback
   * @returns {OperatorNode} Returns a transformed copy of the node
   */
  OperatorNode.prototype.map = function (callback) {
    var args = [];
    for (var i = 0; i < this.args.length; i++) {
      args[i] = this._ifNode(callback(this.args[i], 'args[' + i + ']', this));
    }
    return new OperatorNode(this.op, this.fn, args);
  };

  /**
   * Create a clone of this node, a shallow copy
   * @return {OperatorNode}
   */
  OperatorNode.prototype.clone = function () {
    return new OperatorNode(this.op, this.fn, this.args.slice(0));
  };

  /**
   * Calculate which parentheses are necessary. Gets an OperatorNode
   * (which is the root of the tree) and an Array of Nodes
   * (this.args) and returns an array where 'true' means that an argument
   * has to be enclosed in parentheses whereas 'false' means the opposite.
   *
   * @param {OperatorNode} root
   * @param {string} parenthesis
   * @param {Node[]} args
   * @param {boolean} latex
   * @return {boolean[]}
   * @private
   */
  function calculateNecessaryParentheses(root, parenthesis, args, latex) {
    //precedence of the root OperatorNode
    var precedence = operators.getPrecedence(root, parenthesis);
    var associativity = operators.getAssociativity(root, parenthesis);

    if ((parenthesis === 'all') || (args.length > 2)) {
      var parens = [];
      args.forEach(function (arg) {
        switch (arg.getContent().type) { //Nodes that don't need extra parentheses
          case 'ArrayNode':
          case 'ConstantNode':
          case 'SymbolNode':
          case 'ParenthesisNode':
            parens.push(false);
            break;
          default:
            parens.push(true);
        }
      });
      return parens;
    }

    switch (args.length) {
      case 0:
        return [];
      case 1: //unary operators
              //precedence of the operand
        var operandPrecedence = operators.getPrecedence(args[0], parenthesis);

        //handle special cases for LaTeX, where some of the parentheses aren't needed
        if (latex && (operandPrecedence !== null)) {
          var operandIdentifier;
          var rootIdentifier;
          if (parenthesis === 'keep') {
            operandIdentifier = args[0].getIdentifier();
            rootIdentifier = root.getIdentifier();
          }
          else {
            //Ignore Parenthesis Nodes when not in 'keep' mode
            operandIdentifier = args[0].getContent().getIdentifier();
            rootIdentifier = root.getContent().getIdentifier();
          }
          if (operators.properties[precedence][rootIdentifier].latexLeftParens === false) {
            return [false];
          }

          if (operators.properties[operandPrecedence][operandIdentifier].latexParens === false) {
            return [false];
          }
        }

        if (operandPrecedence === null) {
          //if the operand has no defined precedence, no parens are needed
          return [false];
        }

        if (operandPrecedence <= precedence) {
          //if the operands precedence is lower, parens are needed
          return [true];
        }

        //otherwise, no parens needed
        return [false];

      case 2: //binary operators
        var lhsParens; //left hand side needs parenthesis?
        //precedence of the left hand side
        var lhsPrecedence = operators.getPrecedence(args[0], parenthesis);
        //is the root node associative with the left hand side
        var assocWithLhs = operators.isAssociativeWith(root, args[0], parenthesis);

        if (lhsPrecedence === null) {
          //if the left hand side has no defined precedence, no parens are needed
          //FunctionNode for example
          lhsParens = false;
        }
        else if ((lhsPrecedence === precedence) && (associativity === 'right') && !assocWithLhs) {
          //In case of equal precedence, if the root node is left associative
          // parens are **never** necessary for the left hand side.
          //If it is right associative however, parens are necessary
          //if the root node isn't associative with the left hand side
          lhsParens = true;
        }
        else if (lhsPrecedence < precedence) {
          lhsParens = true;
        }
        else {
          lhsParens = false;
        }

        var rhsParens; //right hand side needs parenthesis?
        //precedence of the right hand side
        var rhsPrecedence = operators.getPrecedence(args[1], parenthesis);
        //is the root node associative with the right hand side?
        var assocWithRhs = operators.isAssociativeWith(root, args[1], parenthesis);

        if (rhsPrecedence === null) {
          //if the right hand side has no defined precedence, no parens are needed
          //FunctionNode for example
          rhsParens = false;
        }
        else if ((rhsPrecedence === precedence) && (associativity === 'left') && !assocWithRhs) {
          //In case of equal precedence, if the root node is right associative
          // parens are **never** necessary for the right hand side.
          //If it is left associative however, parens are necessary
          //if the root node isn't associative with the right hand side
          rhsParens = true;
        }
        else if (rhsPrecedence < precedence) {
          rhsParens = true;
        }
        else {
          rhsParens = false;
        }

        //handle special cases for LaTeX, where some of the parentheses aren't needed
        if (latex) {
          var rootIdentifier;
          var lhsIdentifier;
          var rhsIdentifier;
          if (parenthesis === 'keep') {
            rootIdentifier = root.getIdentifier();
            lhsIdentifier = root.args[0].getIdentifier();
            rhsIdentifier = root.args[1].getIdentifier();
          }
          else {
            //Ignore ParenthesisNodes when not in 'keep' mode
            rootIdentifier = root.getContent().getIdentifier();
            lhsIdentifier = root.args[0].getContent().getIdentifier();
            rhsIdentifier = root.args[1].getContent().getIdentifier();
          }

          if (lhsPrecedence !== null) {
            if (operators.properties[precedence][rootIdentifier].latexLeftParens === false) {
              lhsParens = false;
            }

            if (operators.properties[lhsPrecedence][lhsIdentifier].latexParens === false) {
              lhsParens = false;
            }
          }

          if (rhsPrecedence !== null) {
            if (operators.properties[precedence][rootIdentifier].latexRightParens === false) {
              rhsParens = false;
            }

            if (operators.properties[rhsPrecedence][rhsIdentifier].latexParens === false) {
              rhsParens = false;
            }
          }
        }

        return [lhsParens, rhsParens];
    }
  }

  /**
   * Get string representation.
   * @param {Object} options
   * @return {string} str
   */
  OperatorNode.prototype._toString = function (options) {
    var parenthesis = (options && options.parenthesis) ? options.parenthesis : 'keep';
    var implicit = (options && options.implicit) ? options.implicit : 'hide';
    var args = this.args;
    var parens = calculateNecessaryParentheses(this, parenthesis, args, false);

    switch (args.length) {
      case 1: //unary operators
        var assoc = operators.getAssociativity(this, parenthesis);

        var operand = args[0].toString(options);
        if (parens[0]) {
          operand = '(' + operand + ')';
        }

        if (assoc === 'right') { //prefix operator
          return this.op + operand;
        }
        else if (assoc === 'left') { //postfix
          return operand + this.op;
        }

        //fall back to postfix
        return operand + this.op;

      case 2:
        var lhs = args[0].toString(options); //left hand side
        var rhs = args[1].toString(options); //right hand side
        if (parens[0]) { //left hand side in parenthesis?
          lhs = '(' + lhs + ')';
        }
        if (parens[1]) { //right hand side in parenthesis?
          rhs = '(' + rhs + ')';
        }

        if (this.implicit && (this.getIdentifier() === 'OperatorNode:multiply') && (implicit == 'hide')) {
          return lhs + ' ' + rhs;
        }

        return lhs + ' ' + this.op + ' ' + rhs;

      default:
        //fallback to formatting as a function call
        return this.fn + '(' + this.args.join(', ') + ')';
    }
  };

  /**
   * Get LaTeX representation
   * @param {Object} options
   * @return {string} str
   */
  OperatorNode.prototype._toTex = function (options) {
    var parenthesis = (options && options.parenthesis) ? options.parenthesis : 'keep';
    var implicit = (options && options.implicit) ? options.implicit : 'hide';
    var args = this.args;
    var parens = calculateNecessaryParentheses(this, parenthesis, args, true);
    var op = latex.operators[this.fn];
    op = typeof op === 'undefined' ? this.op : op; //fall back to using this.op

    switch (args.length) {
      case 1: //unary operators
        var assoc = operators.getAssociativity(this, parenthesis);

        var operand = args[0].toTex(options);
        if (parens[0]) {
          operand = '\\left(' + operand + '\\right)';
        }

        if (assoc === 'right') { //prefix operator
          return op + operand;
        }
        else if (assoc === 'left') { //postfix operator
          return operand + op;
        }

        //fall back to postfix
        return operand + op;

      case 2: //binary operators
        var lhs = args[0]; //left hand side
        var lhsTex = lhs.toTex(options);
        if (parens[0]) {
          lhsTex = '\\left(' + lhsTex + '\\right)';
        }

        var rhs = args[1]; //right hand side
        var rhsTex = rhs.toTex(options);
        if (parens[1]) {
          rhsTex = '\\left(' + rhsTex + '\\right)';
        }

        //handle some exceptions (due to the way LaTeX works)
        var lhsIdentifier;
        if (parenthesis === 'keep') {
          lhsIdentifier = lhs.getIdentifier();
        }
        else {
          //Ignore ParenthesisNodes if in 'keep' mode
          lhsIdentifier = lhs.getContent().getIdentifier();
        }
        switch (this.getIdentifier()) {
          case 'OperatorNode:divide':
            //op contains '\\frac' at this point
            return op + '{' + lhsTex + '}' + '{' + rhsTex + '}';
          case 'OperatorNode:pow':
            lhsTex = '{' + lhsTex + '}';
            rhsTex = '{' + rhsTex + '}';
            switch (lhsIdentifier) {
              case 'ConditionalNode': //
              case 'OperatorNode:divide':
                lhsTex = '\\left(' + lhsTex + '\\right)';
            }
          case 'OperatorNode:multiply':
            if (this.implicit && (implicit === 'hide')) {
              return lhsTex + '~' + rhsTex;
            }
        }
        return lhsTex + op + rhsTex;

      default:
        //fall back to formatting as a function call
        //as this is a fallback, it doesn't use
        //fancy function names
        return '\\mathrm{' + this.fn + '}\\left('
            + args.map(function (arg) {
              return arg.toTex(options);
            }).join(',') + '\\right)';
    }
  };

  /**
   * Get identifier.
   * @return {string}
   */
  OperatorNode.prototype.getIdentifier = function () {
    return this.type + ':' + this.fn;
  };

  return OperatorNode;
}

exports.name = 'OperatorNode';
exports.path = 'expression.node';
exports.math = true; // request access to the math namespace as 5th argument of the factory function
exports.factory = factory;

},{"../../utils/latex":482,"../operators":215,"./ConstantNode":201,"./FunctionNode":203,"./Node":205,"./SymbolNode":210}],208:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  var Node = load(require('./Node'));

  /**
   * @constructor ParenthesisNode
   * @extends {Node}
   * A parenthesis node describes manual parenthesis from the user input
   * @param {Node} content
   * @extends {Node}
   */
  function ParenthesisNode(content) {
    if (!(this instanceof ParenthesisNode)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    // validate input
    if (!(content && content.isNode)) {
      throw new TypeError('Node expected for parameter "content"');
    }

    this.content = content;
  }

  ParenthesisNode.prototype = new Node();

  ParenthesisNode.prototype.type = 'ParenthesisNode';

  ParenthesisNode.prototype.isParenthesisNode = true;

  /**
   * Compile the node to javascript code
   * @param {Object} defs     Object which can be used to define functions
   *                          or constants globally available for the compiled
   *                          expression
   * @param {Object} args     Object with local function arguments, the key is
   *                          the name of the argument, and the value is `true`.
   *                          The object may not be mutated, but must be
   *                          extended instead.
   * @return {string} js
   * @private
   */
  ParenthesisNode.prototype._compile = function (defs, args) {
    return this.content._compile(defs, args);
  };

  /**
   * Get the content of the current Node.
   * @return {Node} content
   * @override
   **/
  ParenthesisNode.prototype.getContent = function () {
    return this.content.getContent();
  };

  /**
   * Execute a callback for each of the child nodes of this node
   * @param {function(child: Node, path: string, parent: Node)} callback
   */
  ParenthesisNode.prototype.forEach = function (callback) {
    callback(this.content, 'content', this);
  };

  /**
   * Create a new ParenthesisNode having it's childs be the results of calling
   * the provided callback function for each of the childs of the original node.
   * @param {function(child: Node, path: string, parent: Node) : Node} callback
   * @returns {ParenthesisNode} Returns a clone of the node
   */
  ParenthesisNode.prototype.map = function (callback) {
    var content = callback(this.content, 'content', this);
    return new ParenthesisNode(content);
  };

  /**
   * Create a clone of this node, a shallow copy
   * @return {ParenthesisNode}
   */
  ParenthesisNode.prototype.clone = function() {
    return new ParenthesisNode(this.content);
  };

  /**
   * Get string representation
   * @param {Object} options
   * @return {string} str
   * @override
   */
  ParenthesisNode.prototype._toString = function(options) {
    if ((!options) || (options && !options.parenthesis) || (options && options.parenthesis === 'keep')) {
      return '(' + this.content.toString(options) + ')';
    }
    return this.content.toString(options);
  };

  /**
   * Get LaTeX representation
   * @param {Object} options
   * @return {string} str
   * @override
   */
  ParenthesisNode.prototype._toTex = function(options) {
    if ((!options) || (options && !options.parenthesis) || (options && options.parenthesis === 'keep')) {
      return '\\left(' + this.content.toTex(options) + '\\right)';
    }
    return this.content.toTex(options);
  };

  return ParenthesisNode;
}

exports.name = 'ParenthesisNode';
exports.path = 'expression.node';
exports.factory = factory;

},{"./Node":205}],209:[function(require,module,exports){
'use strict';

var operators = require('../operators');

function factory (type, config, load, typed) {
  var Node = load(require('./Node'));

  /**
   * @constructor RangeNode
   * @extends {Node}
   * create a range
   * @param {Node} start  included lower-bound
   * @param {Node} end    included upper-bound
   * @param {Node} [step] optional step
   */
  function RangeNode(start, end, step) {
    if (!(this instanceof RangeNode)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    // validate inputs
    if (!(start && start.isNode)) throw new TypeError('Node expected');
    if (!(end && end.isNode)) throw new TypeError('Node expected');
    if (step && !(step && step.isNode)) throw new TypeError('Node expected');
    if (arguments.length > 3) throw new Error('Too many arguments');

    this.start = start;         // included lower-bound
    this.end = end;           // included upper-bound
    this.step = step || null;  // optional step
  }

  RangeNode.prototype = new Node();

  RangeNode.prototype.type = 'RangeNode';

  RangeNode.prototype.isRangeNode = true;

  /**
   * Check whether the RangeNode needs the `end` symbol to be defined.
   * This end is the size of the Matrix in current dimension.
   * @return {boolean}
   */
  RangeNode.prototype.needsEnd = function () {
    // find all `end` symbols in this RangeNode
    var endSymbols = this.filter(function (node) {
      return (node && node.isSymbolNode) && (node.name == 'end');
    });

    return endSymbols.length > 0;
  };

  /**
   * Compile the node to javascript code
   *
   * When the range has a symbol `end` defined, the RangeNode requires
   * a variable `end` to be defined in the current closure, which must contain
   * the length of the of the matrix that's being handled in the range's
   * dimension. To check whether the `end` variable is needed, call
   * RangeNode.needsEnd().
   *
   * @param {Object} defs     Object which can be used to define functions
   *                          or constants globally available for the compiled
   *                          expression
   * @param {Object} args     Object with local function arguments, the key is
   *                          the name of the argument, and the value is `true`.
   *                          The object may not be mutated, but must be
   *                          extended instead.
   * @return {string} js
   * @private
   */
  RangeNode.prototype._compile = function (defs, args) {
    return 'math.range(' +
        this.start._compile(defs, args) + ', ' +
        this.end._compile(defs, args) +
        (this.step ? (', ' + this.step._compile(defs, args)) : '') +
        ')';
  };

  /**
   * Execute a callback for each of the child nodes of this node
   * @param {function(child: Node, path: string, parent: Node)} callback
   */
  RangeNode.prototype.forEach = function (callback) {
    callback(this.start, 'start', this);
    callback(this.end, 'end', this);
    if (this.step) {
      callback(this.step, 'step', this);
    }
  };

  /**
   * Create a new RangeNode having it's childs be the results of calling
   * the provided callback function for each of the childs of the original node.
   * @param {function(child: Node, path: string, parent: Node): Node} callback
   * @returns {RangeNode} Returns a transformed copy of the node
   */
  RangeNode.prototype.map = function (callback) {
    return new RangeNode(
        this._ifNode(callback(this.start, 'start', this)),
        this._ifNode(callback(this.end, 'end', this)),
        this.step && this._ifNode(callback(this.step, 'step', this))
    );
  };

  /**
   * Create a clone of this node, a shallow copy
   * @return {RangeNode}
   */
  RangeNode.prototype.clone = function () {
    return new RangeNode(this.start, this.end, this.step && this.step);
  };

  /**
   * Calculate the necessary parentheses
   * @param {Node} node
   * @param {string} parenthesis
   * @return {Object} parentheses
   * @private
   */
  function calculateNecessaryParentheses(node, parenthesis) {
    var precedence = operators.getPrecedence(node, parenthesis);
    var parens = {};

    var startPrecedence = operators.getPrecedence(node.start, parenthesis);
    parens.start = ((startPrecedence !== null) && (startPrecedence <= precedence))
      || (parenthesis === 'all');

    if (node.step) {
      var stepPrecedence = operators.getPrecedence(node.step, parenthesis);
      parens.step = ((stepPrecedence !== null) && (stepPrecedence <= precedence))
        || (parenthesis === 'all');
    }

    var endPrecedence = operators.getPrecedence(node.end, parenthesis);
    parens.end = ((endPrecedence !== null) && (endPrecedence <= precedence))
      || (parenthesis === 'all');

    return parens;
  }

  /**
   * Get string representation
   * @param {Object} options
   * @return {string} str
   */
  RangeNode.prototype._toString = function (options) {
    var parenthesis = (options && options.parenthesis) ? options.parenthesis : 'keep';
    var parens = calculateNecessaryParentheses(this, parenthesis);

    //format string as start:step:stop
    var str;

    var start = this.start.toString(options);
    if (parens.start) {
      start = '(' + start + ')';
    }
    str = start;

    if (this.step) {
      var step = this.step.toString(options);
      if (parens.step) {
        step = '(' + step + ')';
      }
      str += ':' + step;
    }

    var end = this.end.toString(options);
    if (parens.end) {
      end = '(' + end + ')';
    }
    str += ':' + end;

    return str;
  };

  /**
   * Get LaTeX representation
   * @params {Object} options
   * @return {string} str
   */
  RangeNode.prototype._toTex = function (options) {
    var parenthesis = (options && options.parenthesis) ? options.parenthesis : 'keep';
    var parens = calculateNecessaryParentheses(this, parenthesis);

    var str = this.start.toTex(options);
    if (parens.start) {
      str = '\\left(' + str + '\\right)';
    }

    if (this.step) {
      var step = this.step.toTex(options);
      if (parens.step) {
        step = '\\left(' + step + '\\right)';
      }
      str += ':' + step;
    }

    var end = this.end.toTex(options);
    if (parens.end) {
      end = '\\left(' + end + '\\right)';
    }
    str += ':' + end;

    return str;
  };

  return RangeNode;
}

exports.name = 'RangeNode';
exports.path = 'expression.node';
exports.factory = factory;

},{"../operators":215,"./Node":205}],210:[function(require,module,exports){
'use strict';

var latex = require('../../utils/latex');

function factory (type, config, load, typed, math) {
  var Node = load(require('./Node'));

  var Unit = load(require('../../type/unit/Unit'));

  /**
   * @constructor SymbolNode
   * @extends {Node}
   * A symbol node can hold and resolve a symbol
   * @param {string} name
   * @extends {Node}
   */
  function SymbolNode(name) {
    if (!(this instanceof SymbolNode)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    // validate input
    if (typeof name !== 'string')  throw new TypeError('String expected for parameter "name"');

    this.name = name;
  }

  SymbolNode.prototype = new Node();

  SymbolNode.prototype.type = 'SymbolNode';

  SymbolNode.prototype.isSymbolNode = true;

  /**
   * Compile the node to javascript code
   * @param {Object} defs     Object which can be used to define functions
   *                          or constants globally available for the compiled
   *                          expression
   * @param {Object} args     Object with local function arguments, the key is
   *                          the name of the argument, and the value is `true`.
   *                          The object may not be mutated, but must be
   *                          extended instead.
   * @return {string} js
   * @private
   */
  SymbolNode.prototype._compile = function (defs, args) {
    // add a function to the definitions
    defs['undef'] = undef;
    defs['Unit'] = Unit;

    if (args[this.name]) {
      // this is a FunctionAssignment argument
      // (like an x when inside the expression of a function assignment `f(x) = ...`)
      return this.name;
    }
    else if (this.name in defs.math) {
      return '("' + this.name + '" in scope ? scope["' + this.name + '"] : math["' + this.name + '"])';
    }
    else {
      return '(' +
          '"' + this.name + '" in scope ? scope["' + this.name + '"] : ' +
          (Unit.isValuelessUnit(this.name) ?
          'new Unit(null, "' + this.name + '")' :
          'undef("' + this.name + '")') +
          ')';
    }
  };

  /**
   * Execute a callback for each of the child nodes of this node
   * @param {function(child: Node, path: string, parent: Node)} callback
   */
  SymbolNode.prototype.forEach = function (callback) {
    // nothing to do, we don't have childs
  };

  /**
   * Create a new SymbolNode having it's childs be the results of calling
   * the provided callback function for each of the childs of the original node.
   * @param {function(child: Node, path: string, parent: Node) : Node} callback
   * @returns {SymbolNode} Returns a clone of the node
   */
  SymbolNode.prototype.map = function (callback) {
    return this.clone();
  };

  /**
   * Throws an error 'Undefined symbol {name}'
   * @param {string} name
   */
  function undef (name) {
    throw new Error('Undefined symbol ' + name);
  }

  /**
   * Create a clone of this node, a shallow copy
   * @return {SymbolNode}
   */
  SymbolNode.prototype.clone = function() {
    return new SymbolNode(this.name);
  };

  /**
   * Get string representation
   * @param {Object} options
   * @return {string} str
   * @override
   */
  SymbolNode.prototype._toString = function(options) {
    return this.name;
  };

  /**
   * Get LaTeX representation
   * @param {Object} options
   * @return {string} str
   * @override
   */
  SymbolNode.prototype._toTex = function(options) {
    var isUnit = false;
    if ((typeof math[this.name] === 'undefined') && Unit.isValuelessUnit(this.name)) {
      isUnit = true;
    }
    var symbol = latex.toSymbol(this.name, isUnit);
    if (symbol[0] === '\\') {
      //no space needed if the symbol starts with '\'
      return symbol;
    }
    //the space prevents symbols from breaking stuff like '\cdot' if it's written right before the symbol
    return ' ' + symbol;
  };

  return SymbolNode;
}

exports.name = 'SymbolNode';
exports.path = 'expression.node';
exports.math = true; // request access to the math namespace as 5th argument of the factory function
exports.factory = factory;

},{"../../type/unit/Unit":456,"../../utils/latex":482,"./Node":205}],211:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  /**
   * @constructor UpdateNode
   */
  function UpdateNode() {
    // TODO: deprecated since v3. Cleanup some day
    throw new Error('UpdateNode is deprecated. Use AssignmentNode instead.');
  }

  return UpdateNode;
}

exports.name = 'UpdateNode';
exports.path = 'expression.node';
exports.factory = factory;

},{}],212:[function(require,module,exports){
module.exports = [
  require('./AccessorNode'),
  require('./ArrayNode'),
  require('./AssignmentNode'),
  require('./BlockNode'),
  require('./ConditionalNode'),
  require('./ConstantNode'),
  require('./IndexNode'),
  require('./FunctionAssignmentNode'),
  require('./FunctionNode'),
  require('./Node'),
  require('./ObjectNode'),
  require('./OperatorNode'),
  require('./ParenthesisNode'),
  require('./RangeNode'),
  require('./SymbolNode'),
  require('./UpdateNode')
];

},{"./AccessorNode":196,"./ArrayNode":197,"./AssignmentNode":198,"./BlockNode":199,"./ConditionalNode":200,"./ConstantNode":201,"./FunctionAssignmentNode":202,"./FunctionNode":203,"./IndexNode":204,"./Node":205,"./ObjectNode":206,"./OperatorNode":207,"./ParenthesisNode":208,"./RangeNode":209,"./SymbolNode":210,"./UpdateNode":211}],213:[function(require,module,exports){
'use strict';

var errorTransform = require('../../transform/error.transform').transform;

function factory (type, config, load, typed) {
  var subset = load(require('../../../function/matrix/subset'));
  var matrix = load(require('../../../type/matrix/function/matrix'));

  /**
   * Retrieve part of an object:
   *
   * - Retrieve a property from an object
   * - Retrieve a part of a string
   * - Retrieve a matrix subset
   *
   * @param {Object | Array | Matrix | string} object
   * @param {Index} index
   * @return {Object | Array | Matrix | string} Returns the subset
   */
  return function access(object, index) {
    try {
      if (Array.isArray(object)) {
        return matrix(object).subset(index).valueOf();
      }
      else if (object && typeof object.subset === 'function') { // Matrix
        return object.subset(index);
      }
      else if (typeof object === 'string') {
        // TODO: move getStringSubset into a separate util file, use that
        return subset(object, index);
      }
      else if (typeof object === 'object') {
        if (!index.isObjectProperty()) {
          throw TypeError('Cannot apply a numeric index as object property');
        }
        return object[index.getObjectProperty()];
      }
      else {
        throw new TypeError('Cannot apply index: unsupported type of object');
      }
    }
    catch (err) {
      throw errorTransform(err);
    }
  }
}

exports.factory = factory;

},{"../../../function/matrix/subset":334,"../../../type/matrix/function/matrix":435,"../../transform/error.transform":218}],214:[function(require,module,exports){
'use strict';

var errorTransform = require('../../transform/error.transform').transform;

function factory (type, config, load, typed) {
  var subset = load(require('../../../function/matrix/subset'));
  var matrix = load(require('../../../type/matrix/function/matrix'));

  /**
   * Replace part of an object:
   *
   * - Assign a property to an object
   * - Replace a part of a string
   * - Replace a matrix subset
   *
   * @param {Object | Array | Matrix | string} object
   * @param {Index} index
   * @param {*} value
   * @return {Object | Array | Matrix | string} Returns the original object
   *                                            except in case of a string
   */
  return function assign(object, index, value) {
    try {
      if (Array.isArray(object)) {
        return matrix(object).subset(index, value).valueOf();
      }
      else if (object && typeof object.subset === 'function') { // Matrix
        return object.subset(index, value);
      }
      else if (typeof object === 'string') {
        // TODO: move setStringSubset into a separate util file, use that
        return subset(object, index, value);
      }
      else if (typeof object === 'object') {
        if (!index.isObjectProperty()) {
          throw TypeError('Cannot apply a numeric index as object property');
        }
        object[index.getObjectProperty()] = value;
        return object;
      }
      else {
        throw new TypeError('Cannot apply index: unsupported type of object');
      }
    }
    catch (err) {
        throw errorTransform(err);
    }
  }
}

exports.factory = factory;

},{"../../../function/matrix/subset":334,"../../../type/matrix/function/matrix":435,"../../transform/error.transform":218}],215:[function(require,module,exports){
'use strict'

//list of identifiers of nodes in order of their precedence
//also contains information about left/right associativity
//and which other operator the operator is associative with
//Example:
// addition is associative with addition and subtraction, because:
// (a+b)+c=a+(b+c)
// (a+b)-c=a+(b-c)
//
// postfix operators are left associative, prefix operators 
// are right associative
//
//It's also possible to set the following properties:
// latexParens: if set to false, this node doesn't need to be enclosed
//              in parentheses when using LaTeX
// latexLeftParens: if set to false, this !OperatorNode's! 
//                  left argument doesn't need to be enclosed
//                  in parentheses
// latexRightParens: the same for the right argument
var properties = [
  { //assignment
    'AssignmentNode': {},
    'FunctionAssignmentNode': {}
  },
  { //conditional expression
    'ConditionalNode': {
      latexLeftParens: false,
      latexRightParens: false,
      latexParens: false
      //conditionals don't need parentheses in LaTeX because
      //they are 2 dimensional
    }
  },
  { //logical or
    'OperatorNode:or': {
      associativity: 'left',
      associativeWith: []
    }

  },
  { //logical xor
    'OperatorNode:xor': {
      associativity: 'left',
      associativeWith: []
    }
  },
  { //logical and
    'OperatorNode:and': {
      associativity: 'left',
      associativeWith: []
    }
  },
  { //bitwise or
    'OperatorNode:bitOr': {
      associativity: 'left',
      associativeWith: []
    }
  },
  { //bitwise xor
    'OperatorNode:bitXor': {
      associativity: 'left',
      associativeWith: []
    }
  },
  { //bitwise and
    'OperatorNode:bitAnd': {
      associativity: 'left',
      associativeWith: []
    }
  },
  { //relational operators
    'OperatorNode:equal': {
      associativity: 'left',
      associativeWith: []
    },
    'OperatorNode:unequal': {
      associativity: 'left',
      associativeWith: []
    },
    'OperatorNode:smaller': {
      associativity: 'left',
      associativeWith: []
    },
    'OperatorNode:larger': {
      associativity: 'left',
      associativeWith: []
    },
    'OperatorNode:smallerEq': {
      associativity: 'left',
      associativeWith: []
    },
    'OperatorNode:largerEq': {
      associativity: 'left',
      associativeWith: []
    }
  },
  { //bitshift operators
    'OperatorNode:leftShift': {
      associativity: 'left',
      associativeWith: []
    },
    'OperatorNode:rightArithShift': {
      associativity: 'left',
      associativeWith: []
    },
    'OperatorNode:rightLogShift': {
      associativity: 'left',
      associativeWith: []
    }
  },
  { //unit conversion
    'OperatorNode:to': {
      associativity: 'left',
      associativeWith: []
    }
  },
  { //range
    'RangeNode': {}
  },
  { //addition, subtraction
    'OperatorNode:add': {
      associativity: 'left',
      associativeWith: ['OperatorNode:add', 'OperatorNode:subtract']
    },
    'OperatorNode:subtract': {
      associativity: 'left',
      associativeWith: []
    }
  },
  { //multiply, divide, modulus
    'OperatorNode:multiply': {
      associativity: 'left',
      associativeWith: [
        'OperatorNode:multiply',
        'OperatorNode:divide',
        'Operator:dotMultiply',
        'Operator:dotDivide'
      ]
    },
    'OperatorNode:divide': {
      associativity: 'left',
      associativeWith: [],
      latexLeftParens: false,
      latexRightParens: false,
      latexParens: false
      //fractions don't require parentheses because
      //they're 2 dimensional, so parens aren't needed
      //in LaTeX
    },
    'OperatorNode:dotMultiply': {
      associativity: 'left',
      associativeWith: [
        'OperatorNode:multiply',
        'OperatorNode:divide',
        'OperatorNode:dotMultiply',
        'OperatorNode:doDivide'
      ]
    },
    'OperatorNode:dotDivide': {
      associativity: 'left',
      associativeWith: []
    },
    'OperatorNode:mod': {
      associativity: 'left',
      associativeWith: []
    }
  },
  { //unary prefix operators
    'OperatorNode:unaryPlus': {
      associativity: 'right'
    },
    'OperatorNode:unaryMinus': {
      associativity: 'right'
    },
    'OperatorNode:bitNot': {
      associativity: 'right'
    },
    'OperatorNode:not': {
      associativity: 'right'
    }
  },
  { //exponentiation
    'OperatorNode:pow': {
      associativity: 'right',
      associativeWith: [],
      latexRightParens: false
      //the exponent doesn't need parentheses in
      //LaTeX because it's 2 dimensional
      //(it's on top)
    },
    'OperatorNode:dotPow': {
      associativity: 'right',
      associativeWith: []
    }
  },
  { //factorial
    'OperatorNode:factorial': {
      associativity: 'left'
    }
  },
  { //matrix transpose
    'OperatorNode:transpose': {
      associativity: 'left'
    }
  }
];

/**
 * Get the precedence of a Node.
 * Higher number for higher precedence, starting with 0.
 * Returns null if the precedence is undefined.
 *
 * @param {Node}
 * @param {string} parenthesis
 * @return {number|null}
 */
function getPrecedence (_node, parenthesis) {
  var node = _node;
  if (parenthesis !== 'keep') {
    //ParenthesisNodes are only ignored when not in 'keep' mode
    node = _node.getContent();
  }
  var identifier = node.getIdentifier();
  for (var i = 0; i < properties.length; i++) {
    if (identifier in properties[i]) {
      return i;
    }
  }
  return null;
}

/**
 * Get the associativity of an operator (left or right).
 * Returns a string containing 'left' or 'right' or null if
 * the associativity is not defined.
 *
 * @param {Node}
 * @param {string} parenthesis
 * @return {string|null}
 * @throws {Error}
 */
function getAssociativity (_node, parenthesis) {
  var node = _node;
  if (parenthesis !== 'keep') {
    //ParenthesisNodes are only ignored when not in 'keep' mode
    node = _node.getContent();
  }
  var identifier = node.getIdentifier();
  var index = getPrecedence(node, parenthesis);
  if (index === null) {
    //node isn't in the list
    return null;
  }
  var property = properties[index][identifier];

  if (property.hasOwnProperty('associativity')) {
    if (property.associativity === 'left') {
      return 'left';
    }
    if (property.associativity === 'right') {
      return 'right';
    }
    //associativity is invalid
    throw Error('\'' + identifier + '\' has the invalid associativity \''
                + property.associativity + '\'.');
  }

  //associativity is undefined
  return null;
}

/**
 * Check if an operator is associative with another operator.
 * Returns either true or false or null if not defined.
 *
 * @param {Node} nodeA
 * @param {Node} nodeB
 * @param {string} parenthesis
 * @return {bool|null}
 */
function isAssociativeWith (nodeA, nodeB, parenthesis) {
  var a = nodeA;
  var b = nodeB;
  if (parenthesis !== 'keep') {
    //ParenthesisNodes are only ignored when not in 'keep' mode
    var a = nodeA.getContent();
    var b = nodeB.getContent();
  }
  var identifierA = a.getIdentifier();
  var identifierB = b.getIdentifier();
  var index = getPrecedence(a, parenthesis);
  if (index === null) {
    //node isn't in the list
    return null;
  }
  var property = properties[index][identifierA];

  if (property.hasOwnProperty('associativeWith')
      && (property.associativeWith instanceof Array)) {
    for (var i = 0; i < property.associativeWith.length; i++) {
      if (property.associativeWith[i] === identifierB) {
        return true;
      }
    }
    return false;
  }

  //associativeWith is not defined
  return null;
}

module.exports.properties = properties;
module.exports.getPrecedence = getPrecedence;
module.exports.getAssociativity = getAssociativity;
module.exports.isAssociativeWith = isAssociativeWith;

},{}],216:[function(require,module,exports){
'use strict';

var ArgumentsError = require('../error/ArgumentsError');
var deepMap = require('../utils/collection/deepMap');

function factory (type, config, load, typed) {
  var AccessorNode            = load(require('./node/AccessorNode'));
  var ArrayNode               = load(require('./node/ArrayNode'));
  var AssignmentNode          = load(require('./node/AssignmentNode'));
  var BlockNode               = load(require('./node/BlockNode'));
  var ConditionalNode         = load(require('./node/ConditionalNode'));
  var ConstantNode            = load(require('./node/ConstantNode'));
  var FunctionAssignmentNode  = load(require('./node/FunctionAssignmentNode'));
  var IndexNode               = load(require('./node/IndexNode'));
  var ObjectNode              = load(require('./node/ObjectNode'));
  var OperatorNode            = load(require('./node/OperatorNode'));
  var ParenthesisNode         = load(require('./node/ParenthesisNode'));
  var FunctionNode            = load(require('./node/FunctionNode'));
  var RangeNode               = load(require('./node/RangeNode'));
  var SymbolNode              = load(require('./node/SymbolNode'));


  /**
   * Parse an expression. Returns a node tree, which can be evaluated by
   * invoking node.eval();
   *
   * Syntax:
   *
   *     parse(expr)
   *     parse(expr, options)
   *     parse([expr1, expr2, expr3, ...])
   *     parse([expr1, expr2, expr3, ...], options)
   *
   * Example:
   *
   *     var node = parse('sqrt(3^2 + 4^2)');
   *     node.compile(math).eval(); // 5
   *
   *     var scope = {a:3, b:4}
   *     var node = parse('a * b'); // 12
   *     var code = node.compile(math);
   *     code.eval(scope); // 12
   *     scope.a = 5;
   *     code.eval(scope); // 20
   *
   *     var nodes = math.parse(['a = 3', 'b = 4', 'a * b']);
   *     nodes[2].compile(math).eval(); // 12
   *
   * @param {string | string[] | Matrix} expr
   * @param {{nodes: Object<string, Node>}} [options]  Available options:
   *                                                   - `nodes` a set of custom nodes
   * @return {Node | Node[]} node
   * @throws {Error}
   */
  function parse (expr, options) {
    if (arguments.length != 1 && arguments.length != 2) {
      throw new ArgumentsError('parse', arguments.length, 1, 2);
    }

    // pass extra nodes
    extra_nodes = (options && options.nodes) ? options.nodes : {};

    if (typeof expr === 'string') {
      // parse a single expression
      expression = expr;
      return parseStart();
    }
    else if (Array.isArray(expr) || expr instanceof type.Matrix) {
      // parse an array or matrix with expressions
      return deepMap(expr, function (elem) {
        if (typeof elem !== 'string') throw new TypeError('String expected');

        expression = elem;
        return parseStart();
      });
    }
    else {
      // oops
      throw new TypeError('String or matrix expected');
    }
  }

  // token types enumeration
  var TOKENTYPE = {
    NULL : 0,
    DELIMITER : 1,
    NUMBER : 2,
    SYMBOL : 3,
    UNKNOWN : 4
  };

  // map with all delimiters
  var DELIMITERS = {
    ',': true,
    '(': true,
    ')': true,
    '[': true,
    ']': true,
    '{': true,
    '}': true,
    '\"': true,
    ';': true,

    '+': true,
    '-': true,
    '*': true,
    '.*': true,
    '/': true,
    './': true,
    '%': true,
    '^': true,
    '.^': true,
    '~': true,
    '!': true,
    '&': true,
    '|': true,
    '^|': true,
    '\'': true,
    '=': true,
    ':': true,
    '?': true,

    '==': true,
    '!=': true,
    '<': true,
    '>': true,
    '<=': true,
    '>=': true,

    '<<': true,
    '>>': true,
    '>>>': true
  };

  // map with all named delimiters
  var NAMED_DELIMITERS = {
    'mod': true,
    'to': true,
    'in': true,
    'and': true,
    'xor': true,
    'or': true,
    'not': true
  };

  var extra_nodes = {};             // current extra nodes
  var expression = '';              // current expression
  var index = 0;                    // current index in expr
  var c = '';                       // current token character in expr
  var token = '';                   // current token
  var token_type = TOKENTYPE.NULL;  // type of the token
  var nesting_level = 0;            // level of nesting inside parameters, used to ignore newline characters
  var conditional_level = null;     // when a conditional is being parsed, the level of the conditional is stored here

  /**
   * Get the first character from the expression.
   * The character is stored into the char c. If the end of the expression is
   * reached, the function puts an empty string in c.
   * @private
   */
  function first() {
    index = 0;
    c = expression.charAt(0);
    nesting_level = 0;
    conditional_level = null;
  }

  /**
   * Get the next character from the expression.
   * The character is stored into the char c. If the end of the expression is
   * reached, the function puts an empty string in c.
   * @private
   */
  function next() {
    index++;
    c = expression.charAt(index);
  }

  /**
   * Preview the next character from the expression.
   * @return {string} cNext
   * @private
   */
  function nextPreview() {
    return expression.charAt(index + 1);
  }

  /**
   * Preview the second next character from the expression.
   * @return {string} cNext
   * @private
   */
  function nextNextPreview() {
    return expression.charAt(index + 2);
  }

  /**
   * Get next token in the current string expr.
   * The token and token type are available as token and token_type
   * @private
   */
  function getToken() {
    token_type = TOKENTYPE.NULL;
    token = '';

    // skip over whitespaces
    // space, tab, and newline when inside parameters
    while (c == ' ' || c == '\t' || (c == '\n' && nesting_level)) {
      // TODO: also take '\r' carriage return as newline? Or does that give problems on mac?
      next();
    }

    // skip comment
    if (c == '#') {
      while (c != '\n' && c != '') {
        next();
      }
    }

    // check for end of expression
    if (c == '') {
      // token is still empty
      token_type = TOKENTYPE.DELIMITER;
      return;
    }

    // check for new line character
    if (c == '\n' && !nesting_level) {
      token_type = TOKENTYPE.DELIMITER;
      token = c;
      next();
      return;
    }

    // check for delimiters consisting of 3 characters
    var c2 = c + nextPreview();
    var c3 = c2 + nextNextPreview();
    if (c3.length == 3 && DELIMITERS[c3]) {
      token_type = TOKENTYPE.DELIMITER;
      token = c3;
      next();
      next();
      next();
      return;
    }

    // check for delimiters consisting of 2 characters
    if (c2.length == 2 && DELIMITERS[c2]) {
      token_type = TOKENTYPE.DELIMITER;
      token = c2;
      next();
      next();
      return;
    }

    // check for delimiters consisting of 1 character
    if (DELIMITERS[c]) {
      token_type = TOKENTYPE.DELIMITER;
      token = c;
      next();
      return;
    }

    // check for a number
    if (isDigitDot(c)) {
      token_type = TOKENTYPE.NUMBER;

      // get number, can have a single dot
      if (c == '.') {
        token += c;
        next();

        if (!isDigit(c)) {
          // this is no legal number, it is just a dot
          token_type = TOKENTYPE.UNKNOWN;
        }
      }
      else {
        while (isDigit(c)) {
          token += c;
          next();
        }
        if (c == '.') {
          token += c;
          next();
        }
      }
      while (isDigit(c)) {
        token += c;
        next();
      }

      // check for exponential notation like "2.3e-4", "1.23e50" or "2e+4"
      c2 = nextPreview();
      if ((c == 'E' || c == 'e') && (isDigit(c2) || c2 == '-' || c2 == '+')) {
        token += c;
        next();

        if (c == '+' || c == '-') {
          token += c;
          next();
        }

        // Scientific notation MUST be followed by an exponent
        if (!isDigit(c)) {
          // this is no legal number, exponent is missing.
          token_type = TOKENTYPE.UNKNOWN;
        }

        while (isDigit(c)) {
          token += c;
          next();
        }
      }

      return;
    }

    // check for variables, functions, named operators
    if (currentIsAlpha()) {
      while (currentIsAlpha() || isDigit(c)) {
        token += c;
        next();
      }

      if (NAMED_DELIMITERS.hasOwnProperty(token)) {
        token_type = TOKENTYPE.DELIMITER;
      }
      else {
        token_type = TOKENTYPE.SYMBOL;
      }

      return;
    }

    // something unknown is found, wrong characters -> a syntax error
    token_type = TOKENTYPE.UNKNOWN;
    while (c != '') {
      token += c;
      next();
    }
    throw createSyntaxError('Syntax error in part "' + token + '"');
  }

  /**
   * Get next token and skip newline tokens
   */
  function getTokenSkipNewline () {
    do {
      getToken();
    }
    while (token == '\n');
  }

  /**
   * Open parameters.
   * New line characters will be ignored until closeParams() is called
   */
  function openParams() {
    nesting_level++;
  }

  /**
   * Close parameters.
   * New line characters will no longer be ignored
   */
  function closeParams() {
    nesting_level--;
  }

  /**
   * Checks whether the current character `c` is a valid alpha character:
   *
   * - A latin letter (upper or lower case) Ascii: a-z, A-Z
   * - A underscore                         Ascii: _
   * - A latin letter with accents          Unicode: \u00C0 - \u02AF
   * - A greek letter                       Unicode: \u0370 - \u03FF
   * - A mathematical alphanumeric symbol   Unicode: \u{1D400} - \u{1D7FF} excluding invalid code points
   *
   * @return {boolean}
   * @private
   */
  function currentIsAlpha () {
    // http://unicode-table.com/en/
    // http://www.wikiwand.com/en/Mathematical_operators_and_symbols_in_Unicode
    //
    // Note: In ES6 will be unicode aware:
    //   http://stackoverflow.com/questions/280712/javascript-unicode-regexes
    //   https://mathiasbynens.be/notes/es6-unicode-regex
    var cPrev = expression.charAt(index - 1);
    var cNext = expression.charAt(index + 1);

    var isValidLatinOrGreek = function (p) {
      return /^[a-zA-Z_\u00C0-\u02AF\u0370-\u03FF]$/.test(p);
    };

    var isValidMathSymbol = function (high, low) {
      return /^[\uD835]$/.test(high) &&
          /^[\uDC00-\uDFFF]$/.test(low) &&
          /^[^\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]$/.test(low);
    };

    return isValidLatinOrGreek(c)
        || isValidMathSymbol(c, cNext)
        || isValidMathSymbol(cPrev, c);
  }

  /**
   * checks if the given char c is a digit or dot
   * @param {string} c   a string with one character
   * @return {boolean}
   * @private
   */
  function isDigitDot (c) {
    return ((c >= '0' && c <= '9') || c == '.');
  }

  /**
   * checks if the given char c is a digit
   * @param {string} c   a string with one character
   * @return {boolean}
   * @private
   */
  function isDigit (c) {
    return (c >= '0' && c <= '9');
  }

  /**
   * Start of the parse levels below, in order of precedence
   * @return {Node} node
   * @private
   */
  function parseStart () {
    // get the first character in expression
    first();

    getToken();

    var node = parseBlock();

    // check for garbage at the end of the expression
    // an expression ends with a empty character '' and token_type DELIMITER
    if (token != '') {
      if (token_type == TOKENTYPE.DELIMITER) {
        // user entered a not existing operator like "//"

        // TODO: give hints for aliases, for example with "<>" give as hint " did you mean != ?"
        throw createError('Unexpected operator ' + token);
      }
      else {
        throw createSyntaxError('Unexpected part "' + token + '"');
      }
    }

    return node;
  }

  /**
   * Parse a block with expressions. Expressions can be separated by a newline
   * character '\n', or by a semicolon ';'. In case of a semicolon, no output
   * of the preceding line is returned.
   * @return {Node} node
   * @private
   */
  function parseBlock () {
    var node;
    var blocks = [];
    var visible;

    if (token == '') {
      // empty expression
      return new ConstantNode('undefined', 'undefined');
    }

    if (token != '\n' && token != ';') {
      node = parseAssignment();
    }

    // TODO: simplify this loop
    while (token == '\n' || token == ';') {
      if (blocks.length == 0 && node) {
        visible = (token != ';');
        blocks.push({
          node: node,
          visible: visible
        });
      }

      getToken();
      if (token != '\n' && token != ';' && token != '') {
        node = parseAssignment();

        visible = (token != ';');
        blocks.push({
          node: node,
          visible: visible
        });
      }
    }

    if (blocks.length > 0) {
      return new BlockNode(blocks);
    }
    else {
      return node;
    }
  }

  /**
   * Assignment of a function or variable,
   * - can be a variable like 'a=2.3'
   * - or a updating an existing variable like 'matrix(2,3:5)=[6,7,8]'
   * - defining a function like 'f(x) = x^2'
   * @return {Node} node
   * @private
   */
  function parseAssignment () {
    var name, args, value, valid;

    var node = parseConditional();

    if (token == '=') {
      if (node && node.isSymbolNode) {
        // parse a variable assignment like 'a = 2/3'
        name = node.name;
        getTokenSkipNewline();
        value = parseAssignment();
        return new AssignmentNode(new SymbolNode(name), value);
      }
      else if (node && node.isAccessorNode) {
        // parse a matrix subset assignment like 'A[1,2] = 4'
        getTokenSkipNewline();
        value = parseAssignment();
        return new AssignmentNode(node.object, node.index, value);
      }
      else if (node && node.isFunctionNode) {
        // parse function assignment like 'f(x) = x^2'
        valid = true;
        args = [];

        name = node.name;
        node.args.forEach(function (arg, index) {
          if (arg && arg.isSymbolNode) {
            args[index] = arg.name;
          }
          else {
            valid = false;
          }
        });

        if (valid) {
          getTokenSkipNewline();
          value = parseAssignment();
          return new FunctionAssignmentNode(name, args, value);
        }
      }

      throw createSyntaxError('Invalid left hand side of assignment operator =');
    }

    return node;
  }

  /**
   * conditional operation
   *
   *     condition ? truePart : falsePart
   *
   * Note: conditional operator is right-associative
   *
   * @return {Node} node
   * @private
   */
  function parseConditional () {
    var node = parseLogicalOr();

    while (token == '?') {
      // set a conditional level, the range operator will be ignored as long
      // as conditional_level == nesting_level.
      var prev = conditional_level;
      conditional_level = nesting_level;
      getTokenSkipNewline();

      var condition = node;
      var trueExpr = parseAssignment();

      if (token != ':') throw createSyntaxError('False part of conditional expression expected');

      conditional_level = null;
      getTokenSkipNewline();

      var falseExpr = parseAssignment(); // Note: check for conditional operator again, right associativity

      node = new ConditionalNode(condition, trueExpr, falseExpr);

      // restore the previous conditional level
      conditional_level = prev;
    }

    return node;
  }

  /**
   * logical or, 'x or y'
   * @return {Node} node
   * @private
   */
  function parseLogicalOr() {
    var node = parseLogicalXor();

    while (token == 'or') {
      getTokenSkipNewline();
      node = new OperatorNode('or', 'or', [node, parseLogicalXor()]);
    }

    return node;
  }

  /**
   * logical exclusive or, 'x xor y'
   * @return {Node} node
   * @private
   */
  function parseLogicalXor() {
    var node = parseLogicalAnd();

    while (token == 'xor') {
      getTokenSkipNewline();
      node = new OperatorNode('xor', 'xor', [node, parseLogicalAnd()]);
    }

    return node;
  }

  /**
   * logical and, 'x and y'
   * @return {Node} node
   * @private
   */
  function parseLogicalAnd() {
    var node = parseBitwiseOr();

    while (token == 'and') {
      getTokenSkipNewline();
      node = new OperatorNode('and', 'and', [node, parseBitwiseOr()]);
    }

    return node;
  }

  /**
   * bitwise or, 'x | y'
   * @return {Node} node
   * @private
   */
  function parseBitwiseOr() {
    var node = parseBitwiseXor();

    while (token == '|') {
      getTokenSkipNewline();
      node = new OperatorNode('|', 'bitOr', [node, parseBitwiseXor()]);
    }

    return node;
  }

  /**
   * bitwise exclusive or (xor), 'x ^| y'
   * @return {Node} node
   * @private
   */
  function parseBitwiseXor() {
    var node = parseBitwiseAnd();

    while (token == '^|') {
      getTokenSkipNewline();
      node = new OperatorNode('^|', 'bitXor', [node, parseBitwiseAnd()]);
    }

    return node;
  }

  /**
   * bitwise and, 'x & y'
   * @return {Node} node
   * @private
   */
  function parseBitwiseAnd () {
    var node = parseRelational();

    while (token == '&') {
      getTokenSkipNewline();
      node = new OperatorNode('&', 'bitAnd', [node, parseRelational()]);
    }

    return node;
  }

  /**
   * relational operators
   * @return {Node} node
   * @private
   */
  function parseRelational () {
    var node, operators, name, fn, params;

    node = parseShift();

    operators = {
      '==': 'equal',
      '!=': 'unequal',
      '<': 'smaller',
      '>': 'larger',
      '<=': 'smallerEq',
      '>=': 'largerEq'
    };
    while (token in operators) {
      name = token;
      fn = operators[name];

      getTokenSkipNewline();
      params = [node, parseShift()];
      node = new OperatorNode(name, fn, params);
    }

    return node;
  }

  /**
   * Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift
   * @return {Node} node
   * @private
   */
  function parseShift () {
    var node, operators, name, fn, params;

    node = parseConversion();

    operators = {
      '<<' : 'leftShift',
      '>>' : 'rightArithShift',
      '>>>' : 'rightLogShift'
    };

    while (token in operators) {
      name = token;
      fn = operators[name];

      getTokenSkipNewline();
      params = [node, parseConversion()];
      node = new OperatorNode(name, fn, params);
    }

    return node;
  }

  /**
   * conversion operators 'to' and 'in'
   * @return {Node} node
   * @private
   */
  function parseConversion () {
    var node, operators, name, fn, params;

    node = parseRange();

    operators = {
      'to' : 'to',
      'in' : 'to'   // alias of 'to'
    };

    while (token in operators) {
      name = token;
      fn = operators[name];

      getTokenSkipNewline();
      params = [node, parseRange()];
      node = new OperatorNode(name, fn, params);
    }

    return node;
  }

  /**
   * parse range, "start:end", "start:step:end", ":", "start:", ":end", etc
   * @return {Node} node
   * @private
   */
  function parseRange () {
    var node, params = [];

    if (token == ':') {
      // implicit start=1 (one-based)
      node = new ConstantNode('1', 'number');
    }
    else {
      // explicit start
      node = parseAddSubtract();
    }

    if (token == ':' && (conditional_level !== nesting_level)) {
      // we ignore the range operator when a conditional operator is being processed on the same level
      params.push(node);

      // parse step and end
      while (token == ':' && params.length < 3) {
        getTokenSkipNewline();

        if (token == ')' || token == ']' || token == ',' || token == '') {
          // implicit end
          params.push(new SymbolNode('end'));
        }
        else {
          // explicit end
          params.push(parseAddSubtract());
        }
      }

      if (params.length == 3) {
        // params = [start, step, end]
        node = new RangeNode(params[0], params[2], params[1]); // start, end, step
      }
      else { // length == 2
        // params = [start, end]
        node = new RangeNode(params[0], params[1]); // start, end
      }
    }

    return node;
  }

  /**
   * add or subtract
   * @return {Node} node
   * @private
   */
  function parseAddSubtract ()  {
    var node, operators, name, fn, params;

    node = parseMultiplyDivide();

    operators = {
      '+': 'add',
      '-': 'subtract'
    };
    while (token in operators) {
      name = token;
      fn = operators[name];

      getTokenSkipNewline();
      params = [node, parseMultiplyDivide()];
      node = new OperatorNode(name, fn, params);
    }

    return node;
  }

  /**
   * multiply, divide, modulus
   * @return {Node} node
   * @private
   */
  function parseMultiplyDivide () {
    var node, last, operators, name, fn;

    node = parseUnary();
    last = node;

    operators = {
      '*': 'multiply',
      '.*': 'dotMultiply',
      '/': 'divide',
      './': 'dotDivide',
      '%': 'mod',
      'mod': 'mod'
    };

    while (true) {
      if (token in operators) {
        // explicit operators
        name = token;
        fn = operators[name];

        getTokenSkipNewline();

        last = parseUnary();
        node = new OperatorNode(name, fn, [node, last]);
      }
      else if ((token_type == TOKENTYPE.SYMBOL) ||
          (token == 'in' && (node && node.isConstantNode)) ||
          (token_type == TOKENTYPE.NUMBER && !last.isConstantNode) ||
          (token == '(')) {
        // parse implicit multiplication
        //
        // symbol:      implicit multiplication like '2a', '(2+3)a', 'a b'
        // number:      implicit multiplication like '(2+3)2'
        // parenthesis: implicit multiplication like '2(3+4)', '(3+4)(1+2)'
        last = parseUnary();
        node = new OperatorNode('*', 'multiply', [node, last], true /*implicit*/);
      }
      else {
        break;
      }
    }

    return node;
  }

  /**
   * Unary plus and minus, and logical and bitwise not
   * @return {Node} node
   * @private
   */
  function parseUnary () {
    var name, params;
    var fn = {
      '-': 'unaryMinus',
      '+': 'unaryPlus',
      '~': 'bitNot',
      'not': 'not'
    }[token];

    if (fn) {
      name = token;

      getTokenSkipNewline();
      params = [parseUnary()];

      return new OperatorNode(name, fn, params);
    }

    return parsePow();
  }

  /**
   * power
   * Note: power operator is right associative
   * @return {Node} node
   * @private
   */
  function parsePow () {
    var node, name, fn, params;

    node = parseLeftHandOperators();

    if (token == '^' || token == '.^') {
      name = token;
      fn = (name == '^') ? 'pow' : 'dotPow';

      getTokenSkipNewline();
      params = [node, parseUnary()]; // Go back to unary, we can have '2^-3'
      node = new OperatorNode(name, fn, params);
    }

    return node;
  }

  /**
   * Left hand operators: factorial x!, transpose x'
   * @return {Node} node
   * @private
   */
  function parseLeftHandOperators ()  {
    var node, operators, name, fn, params;

    node = parseCustomNodes();

    operators = {
      '!': 'factorial',
      '\'': 'transpose'
    };

    while (token in operators) {
      name = token;
      fn = operators[name];

      getToken();
      params = [node];

      node = new OperatorNode(name, fn, params);
      node = parseAccessors(node);
    }

    return node;
  }

  /**
   * Parse a custom node handler. A node handler can be used to process
   * nodes in a custom way, for example for handling a plot.
   *
   * A handler must be passed as second argument of the parse function.
   * - must extend math.expression.node.Node
   * - must contain a function _compile(defs: Object) : string
   * - must contain a function find(filter: Object) : Node[]
   * - must contain a function toString() : string
   * - the constructor is called with a single argument containing all parameters
   *
   * For example:
   *
   *     nodes = {
   *       'plot': PlotHandler
   *     };
   *
   * The constructor of the handler is called as:
   *
   *     node = new PlotHandler(params);
   *
   * The handler will be invoked when evaluating an expression like:
   *
   *     node = math.parse('plot(sin(x), x)', nodes);
   *
   * @return {Node} node
   * @private
   */
  function parseCustomNodes () {
    var params = [], handler;

    if (token_type == TOKENTYPE.SYMBOL && extra_nodes[token]) {
      handler = extra_nodes[token];

      getToken();

      // parse parameters
      if (token == '(') {
        params = [];

        openParams();
        getToken();

        if (token != ')') {
          params.push(parseAssignment());

          // parse a list with parameters
          while (token == ',') {
            getToken();
            params.push(parseAssignment());
          }
        }

        if (token != ')') {
          throw createSyntaxError('Parenthesis ) expected');
        }
        closeParams();
        getToken();
      }

      // create a new node handler
      //noinspection JSValidateTypes
      return new handler(params);
    }

    return parseSymbol();
  }

  /**
   * parse symbols: functions, variables, constants, units
   * @return {Node} node
   * @private
   */
  function parseSymbol () {
    var node, name;

    if (token_type == TOKENTYPE.SYMBOL ||
        (token_type == TOKENTYPE.DELIMITER && token in NAMED_DELIMITERS)) {
      name = token;

      getToken();

      // parse function parameters and matrix index
      node = new SymbolNode(name);
      node = parseAccessors(node);
      return node;
    }

    return parseString();
  }

  /**
   * parse accessors:
   * - function invocation in round brackets (...), for example sqrt(2)
   * - index enclosed in square brackets [...], for example A[2,3]
   * - dot notation for properties, like foo.bar
   * @param {Node} node    Node on which to apply the parameters. If there
   *                       are no parameters in the expression, the node
   *                       itself is returned
   * @param {string[]} [types]  Filter the types of notations
   *                            can be ['(', '[', '.']
   * @return {Node} node
   * @private
   */
  function parseAccessors (node, types) {
    var params;

    while ((token == '(' || token == '[' || token == '.') &&
        (!types || types.indexOf(token) !== -1)) {
      params = [];

      if (token == '(') {
        if (node.isSymbolNode || node.isAccessorNode) {
          // function invocation like fn(2, 3)
          openParams();
          getToken();

          if (token != ')') {
            params.push(parseAssignment());

            // parse a list with parameters
            while (token == ',') {
              getToken();
              params.push(parseAssignment());
            }
          }

          if (token != ')') {
            throw createSyntaxError('Parenthesis ) expected');
          }
          closeParams();
          getToken();

          node = new FunctionNode(node, params);
        }
        else {
          // implicit multiplication like (2+3)(4+5)
          // next parse operation is parseUnary, the one after parseMultiplyDivide
          node = new OperatorNode('*', 'multiply', [node, parseUnary()], true /*implicit*/);
        }
      }
      else if (token == '[') {
        // index notation like variable[2, 3]
        openParams();
        getToken();

        if (token != ']') {
          params.push(parseAssignment());

          // parse a list with parameters
          while (token == ',') {
            getToken();
            params.push(parseAssignment());
          }
        }

        if (token != ']') {
          throw createSyntaxError('Parenthesis ] expected');
        }
        closeParams();
        getToken();

        node = new AccessorNode(node, new IndexNode(params));
      }
      else {
        // dot notation like variable.prop
        getToken();

        if (token_type != TOKENTYPE.SYMBOL) {
          throw createSyntaxError('Property name expected after dot');
        }
        params.push(new ConstantNode(token));
        getToken();

        var dotNotation = true;
        node = new AccessorNode(node, new IndexNode(params, dotNotation));
      }
    }

    return node;
  }

  /**
   * parse a string.
   * A string is enclosed by double quotes
   * @return {Node} node
   * @private
   */
  function parseString () {
    var node, str;

    if (token == '"') {
      str = parseStringToken();

      // create constant
      node = new ConstantNode(str, 'string');

      // parse index parameters
      node = parseAccessors(node);

      return node;
    }

    return parseMatrix();
  }

  /**
   * Parse a string surrounded by double quotes "..."
   * @return {string}
   */
  function parseStringToken () {
    var str = '';
    var tPrev = '';

    while (c != '' && (c != '\"' || tPrev == '\\')) { // also handle escape character
      str += c;
      tPrev = c;
      next();
    }

    getToken();
    if (token != '"') {
      throw createSyntaxError('End of string " expected');
    }
    getToken();

    return str;
  }

  /**
   * parse the matrix
   * @return {Node} node
   * @private
   */
  function parseMatrix () {
    var array, params, rows, cols;

    if (token == '[') {
      // matrix [...]
      openParams();
      getToken();

      if (token != ']') {
        // this is a non-empty matrix
        var row = parseRow();

        if (token == ';') {
          // 2 dimensional array
          rows = 1;
          params = [row];

          // the rows of the matrix are separated by dot-comma's
          while (token == ';') {
            getToken();

            params[rows] = parseRow();
            rows++;
          }

          if (token != ']') {
            throw createSyntaxError('End of matrix ] expected');
          }
          closeParams();
          getToken();

          // check if the number of columns matches in all rows
          cols = params[0].items.length;
          for (var r = 1; r < rows; r++) {
            if (params[r].items.length != cols) {
              throw createError('Column dimensions mismatch ' +
                  '(' + params[r].items.length + ' != ' + cols + ')');
            }
          }

          array = new ArrayNode(params);
        }
        else {
          // 1 dimensional vector
          if (token != ']') {
            throw createSyntaxError('End of matrix ] expected');
          }
          closeParams();
          getToken();

          array = row;
        }
      }
      else {
        // this is an empty matrix "[ ]"
        closeParams();
        getToken();
        array = new ArrayNode([]);
      }

      return parseAccessors(array);
    }

    return parseObject();
  }

  /**
   * Parse a single comma-separated row from a matrix, like 'a, b, c'
   * @return {ArrayNode} node
   */
  function parseRow () {
    var params = [parseAssignment()];
    var len = 1;

    while (token == ',') {
      getToken();

      // parse expression
      params[len] = parseAssignment();
      len++;
    }

    return new ArrayNode(params);
  }

  /**
   * parse an object, enclosed in angle brackets{...}, for example {value: 2}
   * @return {Node} node
   * @private
   */
  function parseObject () {
    if (token == '{') {
      var key;

      var properties = {};
      do {
        getToken();

        if (token != '}') {
          // parse key
          if (token == '"') {
            key = parseStringToken();
          }
          else if (token_type == TOKENTYPE.SYMBOL) {
            key = token;
            getToken();
          }
          else {
            throw createSyntaxError('Symbol or string expected as object key');
          }

          // parse key/value separator
          if (token != ':') {
            throw createSyntaxError('Colon : expected after object key');
          }
          getToken();

          // parse key
          properties[key] = parseAssignment();
        }
      }
      while (token == ',');

      if (token != '}') {
        throw createSyntaxError('Comma , or bracket } expected after object value');
      }
      getToken();

      var node = new ObjectNode(properties);

      // parse index parameters
      node = parseAccessors(node);

      return node;
    }

    return parseNumber();
  }

  /**
   * parse a number
   * @return {Node} node
   * @private
   */
  function parseNumber () {
    var number;

    if (token_type == TOKENTYPE.NUMBER) {
      // this is a number
      number = token;
      getToken();

      return new ConstantNode(number, 'number');
    }

    return parseParentheses();
  }

  /**
   * parentheses
   * @return {Node} node
   * @private
   */
  function parseParentheses () {
    var node;

    // check if it is a parenthesized expression
    if (token == '(') {
      // parentheses (...)
      openParams();
      getToken();

      node = parseAssignment(); // start again

      if (token != ')') {
        throw createSyntaxError('Parenthesis ) expected');
      }
      closeParams();
      getToken();

      node = new ParenthesisNode(node);
      node = parseAccessors(node);
      return node;
    }

    return parseEnd();
  }

  /**
   * Evaluated when the expression is not yet ended but expected to end
   * @return {Node} res
   * @private
   */
  function parseEnd () {
    if (token == '') {
      // syntax error or unexpected end of expression
      throw createSyntaxError('Unexpected end of expression');
    } else {
      throw createSyntaxError('Value expected');
    }
  }

  /**
   * Shortcut for getting the current row value (one based)
   * Returns the line of the currently handled expression
   * @private
   */
  /* TODO: implement keeping track on the row number
  function row () {
    return null;
  }
  */

  /**
   * Shortcut for getting the current col value (one based)
   * Returns the column (position) where the last token starts
   * @private
   */
  function col () {
    return index - token.length + 1;
  }

  /**
   * Create an error
   * @param {string} message
   * @return {SyntaxError} instantiated error
   * @private
   */
  function createSyntaxError (message) {
    var c = col();
    var error = new SyntaxError(message + ' (char ' + c + ')');
    error['char'] = c;

    return error;
  }

  /**
   * Create an error
   * @param {string} message
   * @return {Error} instantiated error
   * @private
   */
  function createError (message) {
    var c = col();
    var error = new SyntaxError(message + ' (char ' + c + ')');
    error['char'] = c;

    return error;
  }

  return parse;
};

exports.name = 'parse';
exports.path = 'expression';
exports.factory = factory;

},{"../error/ArgumentsError":10,"../utils/collection/deepMap":475,"./node/AccessorNode":196,"./node/ArrayNode":197,"./node/AssignmentNode":198,"./node/BlockNode":199,"./node/ConditionalNode":200,"./node/ConstantNode":201,"./node/FunctionAssignmentNode":202,"./node/FunctionNode":203,"./node/IndexNode":204,"./node/ObjectNode":206,"./node/OperatorNode":207,"./node/ParenthesisNode":208,"./node/RangeNode":209,"./node/SymbolNode":210}],217:[function(require,module,exports){
'use strict';

var errorTransform = require('./error.transform').transform;

/**
 * Attach a transform function to math.range
 * Adds a property transform containing the transform function.
 *
 * This transform changed the last `dim` parameter of function concat
 * from one-based to zero based
 */
function factory (type, config, load, typed) {
  var concat = load(require('../../function/matrix/concat'));

  // @see: comment of concat itself
 return typed('concat', {
    '...any': function (args) {
      // change last argument from one-based to zero-based
      var lastIndex = args.length - 1;
      var last = args[lastIndex];
      if (typeof last === 'number') {
        args[lastIndex] = last - 1;
      }
      else if (last && last.isBigNumber === true) {
        args[lastIndex] = last.minus(1);
      }

      try {
        return concat.apply(null, args);
      }
      catch (err) {
        throw errorTransform(err);
      }
    }
  });
}

exports.name = 'concat';
exports.path = 'expression.transform';
exports.factory = factory;

},{"../../function/matrix/concat":315,"./error.transform":218}],218:[function(require,module,exports){
var IndexError = require('../../error/IndexError');

/**
 * Transform zero-based indices to one-based indices in errors
 * @param {Error} err
 * @returns {Error} Returns the transformed error
 */
exports.transform = function (err) {
  if (err && err.isIndexError) {
    return new IndexError(
        err.index + 1,
        err.min + 1,
        err.max !== undefined ? err.max + 1 : undefined);
  }

  return err;
};

},{"../../error/IndexError":12}],219:[function(require,module,exports){
'use strict';

/**
 * Attach a transform function to math.filter
 * Adds a property transform containing the transform function.
 *
 * This transform adds support for equations as test function for math.filter,
 * so you can do something like 'filter([3, -2, 5], x > 0)'.
 */
function factory (type, config, load, typed) {
  var filter = load(require('../../function/matrix/filter'));
  var SymbolNode = load(require('../node/SymbolNode'));

  function filterTransform(args, math, scope) {
    var x, test;

    if (args[0]) {
      x = args[0].compile().eval(scope);
    }

    if (args[1]) {
      if (args[1] && args[1].isSymbolNode) {
        // a function pointer, like filter([3, -2, 5], myTestFunction);
        test = args[1].compile().eval(scope);
      }
      else {
        // an equation like filter([3, -2, 5], x > 0)

        // find an undefined symbol
        var _scope = scope || {};
        var symbol = args[1]
            .filter(function (node) {
              return (node && node.isSymbolNode) &&
                  !(node.name in math) &&
                  !(node.name in _scope);
            })[0];

        // create a test function for this equation
        var sub = Object.create(_scope);
        var eq = args[1].compile();
        if (symbol) {
          var name = symbol.name;
          test = function (x) {
            sub[name] = x;
            return eq.eval(sub);
          }
        }
        else {
          throw new Error('No undefined variable found in filter equation');
        }
      }
    }

    return filter(x, test);
  }

  filterTransform.rawArgs = true;

  return filterTransform;
}

exports.name = 'filter';
exports.path = 'expression.transform';
exports.factory = factory;

},{"../../function/matrix/filter":321,"../node/SymbolNode":210}],220:[function(require,module,exports){
'use strict';

/**
 * Attach a transform function to math.forEach
 * Adds a property transform containing the transform function.
 *
 * This transform creates a one-based index instead of a zero-based index
 */
function factory (type, config, load, typed) {
  var forEach = load(require('../../function/matrix/forEach'));

  return typed('forEach', {
    'Array | Matrix, function': function (array, callback) {
      var recurse = function (value, index) {
        if (Array.isArray(value)) {
          value.forEach(function (child, i) {
            // we create a copy of the index array and append the new index value
            recurse(child, index.concat(i + 1)); // one based index, hence i+1
          });
        }
        else {
          callback(value, index, array);
        }
      };
      recurse(array.valueOf(), []); // pass Array
    }
  });
}

exports.name = 'forEach';
exports.path = 'expression.transform';
exports.factory = factory;

},{"../../function/matrix/forEach":323}],221:[function(require,module,exports){
module.exports = [
  require('./concat.transform'),
  require('./filter.transform'),
  require('./forEach.transform'),
  require('./index.transform'),
  require('./map.transform'),
  require('./max.transform'),
  require('./mean.transform'),
  require('./min.transform'),
  require('./range.transform'),
  require('./subset.transform')
];

},{"./concat.transform":217,"./filter.transform":219,"./forEach.transform":220,"./index.transform":222,"./map.transform":223,"./max.transform":224,"./mean.transform":225,"./min.transform":226,"./range.transform":227,"./subset.transform":228}],222:[function(require,module,exports){
'use strict';

var isArray = Array.isArray;

/**
 * Attach a transform function to math.index
 * Adds a property transform containing the transform function.
 *
 * This transform creates a one-based index instead of a zero-based index
 */
function factory (type, config, load) {
  var indexFactory = load(require('../../type/matrix/function/index'));

  return function indexTransform() {
    var args = [];
    for (var i = 0, ii = arguments.length; i < ii; i++) {
      var arg = arguments[i];

      // change from one-based to zero based, and convert BigNumber to number
      if (arg && arg.isRange === true) {
        arg.start--;
        arg.end -= (arg.step > 0 ? 0 : 2);
      }
      else if (arg && arg.isSet === true) {
        arg = arg.map(function (v) { return v - 1; });
      }
      else if (arg && (arg.isArray === true || arg.isMatrix)) {
        arg = arg.map(function (v) { return v - 1; });
      }
      else if (typeof arg === 'number') {
        arg--;
      }
      else if (arg && arg.isBigNumber === true) {
        arg = arg.toNumber() - 1;
      }
      else if (typeof arg === 'string') {
        // leave as is
      }
      else {
        throw new TypeError('Dimension must be an Array, Matrix, number, string, or Range');
      }

      args[i] = arg;
    }

    var res = new type.Index();
    type.Index.apply(res, args);
    return res;
  };
}

exports.name = 'index';
exports.path = 'expression.transform';
exports.factory = factory;

},{"../../type/matrix/function/index":434}],223:[function(require,module,exports){
'use strict';

/**
 * Attach a transform function to math.map
 * Adds a property transform containing the transform function.
 *
 * This transform creates a one-based index instead of a zero-based index
 */
function factory (type, config, load, typed) {
  var map = load(require('../../function/matrix/map'));
  var matrix = load(require('../../type/matrix/function/matrix'));

  return typed('max', {
    'Array, function': function (x, callback) {
      return _map(x, callback, x);
    },

    'Matrix, function': function (x, callback) {
      return matrix(_map(x.valueOf(), callback, x));
    }
  });
}

/**
 * Map for a multi dimensional array. One-based indexes
 * @param {Array} array
 * @param {function} callback
 * @param {Array} orig
 * @return {Array}
 * @private
 */
function _map (array, callback, orig) {
  function recurse(value, index) {
    if (Array.isArray(value)) {
      return value.map(function (child, i) {
        // we create a copy of the index array and append the new index value
        return recurse(child, index.concat(i + 1)); // one based index, hence i + 1
      });
    }
    else {
      return callback(value, index, orig);
    }
  }

  return recurse(array, []);
}

exports.name = 'map';
exports.path = 'expression.transform';
exports.factory = factory;

},{"../../function/matrix/map":326,"../../type/matrix/function/matrix":435}],224:[function(require,module,exports){
'use strict';

var errorTransform = require('./error.transform').transform;
var isCollection = require('../../utils/collection/isCollection');

/**
 * Attach a transform function to math.max
 * Adds a property transform containing the transform function.
 *
 * This transform changed the last `dim` parameter of function max
 * from one-based to zero based
 */
function factory (type, config, load, typed) {
  var max = load(require('../../function/statistics/max'));

  return typed('max', {
    '...any': function (args) {
      // change last argument dim from one-based to zero-based
      if (args.length == 2 && isCollection(args[0])) {
        var dim = args[1];
        if (typeof dim === 'number') {
          args[1] = dim - 1;
        }
        else if (dim && dim.isBigNumber === true) {
          args[1] = dim.minus(1);
        }
      }

      try {
        return max.apply(null, args);
      }
      catch (err) {
        throw errorTransform(err);
      }
    }
  });
}

exports.name = 'max';
exports.path = 'expression.transform';
exports.factory = factory;

},{"../../function/statistics/max":360,"../../utils/collection/isCollection":476,"./error.transform":218}],225:[function(require,module,exports){
'use strict';

var errorTransform = require('./error.transform').transform;
var isCollection = require('../../utils/collection/isCollection');

/**
 * Attach a transform function to math.mean
 * Adds a property transform containing the transform function.
 *
 * This transform changed the last `dim` parameter of function mean
 * from one-based to zero based
 */
function factory (type, config, load, typed) {
  var mean = load(require('../../function/statistics/mean'));

  return typed('mean', {
    '...any': function (args) {
      // change last argument dim from one-based to zero-based
      if (args.length == 2 && isCollection(args[0])) {
        var dim = args[1];
        if (typeof dim === 'number') {
          args[1] = dim - 1;
        }
        else if (dim && dim.isBigNumber === true) {
          args[1] = dim.minus(1);
        }
      }

      try {
        return mean.apply(null, args);
      }
      catch (err) {
        throw errorTransform(err);
      }
    }
  });
}

exports.name = 'mean';
exports.path = 'expression.transform';
exports.factory = factory;

},{"../../function/statistics/mean":361,"../../utils/collection/isCollection":476,"./error.transform":218}],226:[function(require,module,exports){
'use strict';

var errorTransform = require('./error.transform').transform;
var isCollection = require('../../utils/collection/isCollection');

/**
 * Attach a transform function to math.min
 * Adds a property transform containing the transform function.
 *
 * This transform changed the last `dim` parameter of function min
 * from one-based to zero based
 */
function factory (type, config, load, typed) {
  var min = load(require('../../function/statistics/min'));

  return typed('min', {
    '...any': function (args) {
      // change last argument dim from one-based to zero-based
      if (args.length == 2 && isCollection(args[0])) {
        var dim = args[1];
        if (typeof dim === 'number') {
          args[1] = dim - 1;
        }
        else if (dim && dim.isBigNumber === true) {
          args[1] = dim.minus(1);
        }
      }

      try {
        return min.apply(null, args);
      }
      catch (err) {
        throw errorTransform(err);
      }
    }
  });
}

exports.name = 'min';
exports.path = 'expression.transform';
exports.factory = factory;

},{"../../function/statistics/min":363,"../../utils/collection/isCollection":476,"./error.transform":218}],227:[function(require,module,exports){
'use strict';

/**
 * Attach a transform function to math.range
 * Adds a property transform containing the transform function.
 *
 * This transform creates a range which includes the end value
 */
function factory (type, config, load, typed) {
  var range = load(require('../../function/matrix/range'));

  return typed('range', {
    '...any': function (args) {
      var lastIndex = args.length - 1;
      var last = args[lastIndex];
      if (typeof last !== 'boolean') {
        // append a parameter includeEnd=true
        args.push(true);
      }

      return range.apply(null, args);
    }
  });
}

exports.name = 'range';
exports.path = 'expression.transform';
exports.factory = factory;

},{"../../function/matrix/range":329}],228:[function(require,module,exports){
'use strict';

var errorTransform = require('./error.transform').transform;

/**
 * Attach a transform function to math.subset
 * Adds a property transform containing the transform function.
 *
 * This transform creates a range which includes the end value
 */
function factory (type, config, load, typed) {
  var subset = load(require('../../function/matrix/subset'));

  return typed('subset', {
    '...any': function (args) {
      try {
        return subset.apply(null, args);
      }
      catch (err) {
        throw errorTransform(err);
      }
    }
  });
}

exports.name = 'subset';
exports.path = 'expression.transform';
exports.factory = factory;

},{"../../function/matrix/subset":334,"./error.transform":218}],229:[function(require,module,exports){
'use strict';

var util = require('../../../utils/index');

var object = util.object;

function factory (type, config, load, typed) {

  var matrix = load(require('../../../type/matrix/function/matrix'));
  var abs = load(require('../../arithmetic/abs'));
  var addScalar = load(require('../../arithmetic/addScalar'));
  var divideScalar = load(require('../../arithmetic/divideScalar'));
  var multiplyScalar = load(require('../../arithmetic/multiplyScalar'));
  var subtract = load(require('../../arithmetic/subtract'));
  var larger = load(require('../../relational/larger'));
  var equalScalar = load(require('../../relational/equalScalar'));
  var unaryMinus = load(require('../../arithmetic/unaryMinus'));
  
  var SparseMatrix = type.SparseMatrix;
  var DenseMatrix = type.DenseMatrix;
  var Spa = type.Spa;
  
  /**
   * Calculate the Matrix LU decomposition with partial pivoting. Matrix `A` is decomposed in two matrices (`L`, `U`) and a
   * row permutation vector `p` where `A[p,:] = L * U`
   *
   * Syntax:
   *
   *    math.lup(A);
   *
   * Example:
   *
   *    var m = [[2, 1], [1, 4]];
   *    var r = math.lup();
   *    // r = {
   *    //   L: [[1, 0], [0.5, 1]],
   *    //   U: [[2, 1], [0, 3.5]],
   *    //   P: [0, 1]
   *    // }
   *
   * See also:
   *
   *    slu, lsolve, lusolve, usolve
   *
   * @param {Matrix | Array} A    A two dimensional matrix or array for which to get the LUP decomposition.
   *
   * @return {Array<Matrix>}      The lower triangular matrix, the upper triangular matrix and the permutation matrix.
   */
  var lup = typed('lup', {

    'DenseMatrix': function (m) {
      return _denseLUP(m);
    },
    
    'SparseMatrix': function (m) {
      return _sparseLUP(m);
    },

    'Array': function (a) {
      // create dense matrix from array
      var m = matrix(a);
      // lup, use matrix implementation
      var r = _denseLUP(m);
      // result
      return {
        L: r.L.valueOf(),
        U: r.U.valueOf(),
        p: r.p
      };
    }
  });

  var _denseLUP = function (m) {
    // rows & columns
    var rows = m._size[0];
    var columns = m._size[1];
    // minimum rows and columns
    var n = Math.min(rows, columns);
    // matrix array, clone original data
    var data = object.clone(m._data);
    // l matrix arrays
    var ldata = [];
    var lsize = [rows, n];
    // u matrix arrays
    var udata = [];
    var usize = [n, columns];
    // vars
    var i, j, k;
    // permutation vector    
    var p = [];
    for (i = 0; i < rows; i++)
      p[i] = i;    
    // loop columns
    for (j = 0; j < columns; j++) {
      // skip first column in upper triangular matrix
      if (j > 0) {
        // loop rows
        for (i = 0; i < rows; i++) {
          // min i,j
          var min = Math.min(i, j);
          // v[i, j]
          var s = 0;
          // loop up to min
          for (k = 0; k < min; k++) {
            // s = l[i, k] - data[k, j]
            s = addScalar(s, multiplyScalar(data[i][k], data[k][j]));
          }
          data[i][j] = subtract(data[i][j], s);
        }
      }      
      // row with larger value in cvector, row >= j
      var pi = j;
      var pabsv = 0;
      var vjj = 0;
      // loop rows
      for (i = j; i < rows; i++) {
        // data @ i, j
        var v = data[i][j];
        // absolute value
        var absv = abs(v);
        // value is greater than pivote value
        if (larger(absv, pabsv)) {
          // store row
          pi = i;
          // update max value
          pabsv = absv;
          // value @ [j, j]
          vjj = v;
        }
      }
      // swap rows (j <-> pi)
      if (j !== pi) {
        // swap values j <-> pi in p
        p[j] = [p[pi], p[pi] = p[j]][0];
        // swap j <-> pi in data
        DenseMatrix._swapRows(j, pi, data);
      }
      // check column is in lower triangular matrix
      if (j < rows) {
        // loop rows (lower triangular matrix)
        for (i = j + 1; i < rows; i++) {
          // value @ i, j
          var vij = data[i][j];
          if (!equalScalar(vij, 0)) {
            // update data
            data[i][j] = divideScalar(data[i][j], vjj);
          }
        }
      }
    }
    // loop columns
    for (j = 0; j < columns; j++) {
      // loop rows
      for (i = 0; i < rows; i++) {
        // initialize row in arrays
        if (j === 0) {
          // check row exists in upper triangular matrix
          if (i < columns) {
            // U
            udata[i] = [];
          }
          // L
          ldata[i] = [];
        }
        // check we are in the upper triangular matrix
        if (i < j) {
          // check row exists in upper triangular matrix
          if (i < columns) {
            // U
            udata[i][j] = data[i][j];
          }
          // check column exists in lower triangular matrix
          if (j < rows) {
            // L
            ldata[i][j] = 0;
          }
          continue;
        }
        // diagonal value
        if (i === j) {
          // check row exists in upper triangular matrix
          if (i < columns) {
            // U
            udata[i][j] = data[i][j];
          }
          // check column exists in lower triangular matrix
          if (j < rows) {
            // L
            ldata[i][j] = 1;
          }
          continue;
        }
        // check row exists in upper triangular matrix
        if (i < columns) {
          // U
          udata[i][j] = 0;
        }
        // check column exists in lower triangular matrix
        if (j < rows) {
          // L
          ldata[i][j] = data[i][j];
        }
      }
    }
    // l matrix
    var l =  new DenseMatrix({
      data: ldata,
      size: lsize
    });
    // u matrix
    var u =  new DenseMatrix({
      data: udata,
      size: usize
    });
    // p vector
    var pv = [];
    for (i = 0, n = p.length; i < n; i++)
      pv[p[i]] = i;
    // return matrices
    return { 
      L: l, 
      U: u, 
      p: pv, 
      toString: function () {
        return 'L: ' + this.L.toString() + '\nU: ' + this.U.toString() + '\nP: ' + this.p;
      }
    };
  };
  
  var _sparseLUP = function (m) {
    // rows & columns
    var rows = m._size[0];
    var columns = m._size[1];
    // minimum rows and columns
    var n = Math.min(rows, columns);
    // matrix arrays (will not be modified, thanks to permutation vector)
    var values = m._values;
    var index = m._index;
    var ptr = m._ptr;
    // l matrix arrays
    var lvalues = [];
    var lindex = [];
    var lptr = [];
    var lsize = [rows, n];
    // u matrix arrays
    var uvalues = [];
    var uindex = [];
    var uptr = [];
    var usize = [n, columns];
    // vars
    var i, j, k;
    // permutation vectors, (current index -> original index) and (original index -> current index)
    var pv_co = [];
    var pv_oc = [];
    for (i = 0; i < rows; i++) {
      pv_co[i] = i;
      pv_oc[i] = i;
    }
    // swap indices in permutation vectors (condition x < y)!
    var swapIndeces = function (x, y) {      
      // find pv indeces getting data from x and y
      var kx = pv_oc[x];
      var ky = pv_oc[y];
      // update permutation vector current -> original
      pv_co[kx] = y;
      pv_co[ky] = x;
      // update permutation vector original -> current
      pv_oc[x] = ky;
      pv_oc[y] = kx;
    };
    // loop columns
    for (j = 0; j < columns; j++) {
      // sparse accumulator
      var spa = new Spa();            
      // check lower triangular matrix has a value @ column j
      if (j < rows) {
        // update ptr
        lptr.push(lvalues.length);
        // first value in j column for lower triangular matrix
        lvalues.push(1);
        lindex.push(j);
      }
      // update ptr
      uptr.push(uvalues.length);
      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
      var k0 = ptr[j];
      var k1 = ptr[j + 1];
      // copy column j into sparse accumulator
      for (k = k0; k < k1; k++) {
        // row
        i = index[k];
        // copy column values into sparse accumulator (use permutation vector)
        spa.set(pv_co[i], values[k]);
      }
      // skip first column in upper triangular matrix
      if (j > 0) {
        // loop rows in column j (above diagonal)
        spa.forEach(0, j - 1, function (k, vkj) {
          // loop rows in column k (L)
          SparseMatrix._forEachRow(k, lvalues, lindex, lptr, function (i, vik) {
            // check row is below k
            if (i > k) {
              // update spa value
              spa.accumulate(i, unaryMinus(multiplyScalar(vik, vkj)));
            }
          });
        });        
      }
      // row with larger value in spa, row >= j
      var pi = j;
      var vjj = spa.get(j);
      var pabsv = abs(vjj);      
      // loop values in spa (order by row, below diagonal)
      spa.forEach(j + 1, rows - 1, function (x, v) {
        // absolute value
        var absv = abs(v);
        // value is greater than pivote value
        if (larger(absv, pabsv)) {
          // store row
          pi = x;
          // update max value
          pabsv = absv;
          // value @ [j, j]
          vjj = v;
        }
      });
      // swap rows (j <-> pi)
      if (j !== pi) {
        // swap values j <-> pi in L
        SparseMatrix._swapRows(j, pi, lsize[1], lvalues, lindex, lptr);
        // swap values j <-> pi in U
        SparseMatrix._swapRows(j, pi, usize[1], uvalues, uindex, uptr);
        // swap values in spa
        spa.swap(j, pi);
        // update permutation vector (swap values @ j, pi)
        swapIndeces(j, pi);
      }
      // loop values in spa (order by row)
      spa.forEach(0, rows - 1, function (x, v) {
        // check we are above diagonal
        if (x <= j) {
          // update upper triangular matrix
          uvalues.push(v);
          uindex.push(x);
        }
        else {
          // update value
          v = divideScalar(v, vjj);
          // check value is non zero
          if (!equalScalar(v, 0)) {
            // update lower triangular matrix
            lvalues.push(v);
            lindex.push(x);
          }
        }
      });
    }
    // update ptrs
    uptr.push(uvalues.length);
    lptr.push(lvalues.length);

    // return matrices
    return {
      L: new SparseMatrix({
        values: lvalues,
        index: lindex,
        ptr: lptr,
        size: lsize
      }), 
      U: new SparseMatrix({
        values: uvalues,
        index: uindex,
        ptr: uptr,
        size: usize
      }),
      p: pv_co,
      toString: function () {
        return 'L: ' + this.L.toString() + '\nU: ' + this.U.toString() + '\nP: ' + this.p;
      }
    };
  };
  
  return lup;
}

exports.name = 'lup';
exports.factory = factory;

},{"../../../type/matrix/function/matrix":435,"../../../utils/index":481,"../../arithmetic/abs":254,"../../arithmetic/addScalar":256,"../../arithmetic/divideScalar":261,"../../arithmetic/multiplyScalar":276,"../../arithmetic/subtract":284,"../../arithmetic/unaryMinus":285,"../../relational/equalScalar":352,"../../relational/larger":354}],230:[function(require,module,exports){
'use strict';

var util = require('../../../utils/index');

var number = util.number,
    
    isInteger = number.isInteger;

function factory (type, config, load, typed) {

  var cs_sqr = load(require('../../algebra/sparse/cs_sqr'));
  var cs_lu = load(require('../../algebra/sparse/cs_lu'));

  /**
   * Calculate the Sparse Matrix LU decomposition with full pivoting. Sparse Matrix `A` is decomposed in two matrices (`L`, `U`) and two permutation vectors (`pinv`, `q`) where
   *
   * `P * A * Q = L * U`
   *
   * Syntax:
   *
   *    math.slu(A, order, threshold);
   *
   * See also:
   *
   *    lup, lsolve, usolve, lusolve
   *
   * @param {SparseMatrix} A              A two dimensional sparse matrix for which to get the LU decomposition.
   * @param {Number}       order          The Symbolic Ordering and Analysis order:
   *                                       0 - Natural ordering, no permutation vector q is returned
   *                                       1 - Matrix must be square, symbolic ordering and analisis is performed on M = A + A'
   *                                       2 - Symbolic ordering and analisis is performed on M = A' * A. Dense columns from A' are dropped, A recreated from A'. 
   *                                           This is appropriatefor LU factorization of unsymmetric matrices.
   *                                       3 - Symbolic ordering and analisis is performed on M = A' * A. This is best used for LU factorization is matrix M has no dense rows.
   *                                           A dense row is a row with more than 10*sqr(columns) entries.
   * @param {Number}       threshold       Partial pivoting threshold (1 for partial pivoting)
   *
   * @return {Object} The lower triangular matrix, the upper triangular matrix and the permutation vectors.
   */
  var slu = typed('slu', {

    'SparseMatrix, number, number': function (a, order, threshold) {
      // verify order
      if (!isInteger(order) || order < 0 || order > 3)
        throw new Error('Symbolic Ordering and Analysis order must be an integer number in the interval [0, 3]');
      // verify threshold
      if (threshold < 0 || threshold > 1)
        throw new Error('Partial pivoting threshold must be a number from 0 to 1');
      
      // perform symbolic ordering and analysis
      var s = cs_sqr(order, a, false);
      
      // perform lu decomposition
      var f = cs_lu(a, s, threshold);
      
      // return decomposition
      return {
        L: f.L,
        U: f.U,
        p: f.pinv,
        q: s.q,
        toString: function () {
          return 'L: ' + this.L.toString() + '\nU: ' + this.U.toString() + '\np: ' + this.p.toString() + (this.q ? '\nq: ' + this.q.toString() : '') + '\n';
        }
      };
    }
  });

  return slu;
}

exports.name = 'slu';
exports.factory = factory;

},{"../../../utils/index":481,"../../algebra/sparse/cs_lu":244,"../../algebra/sparse/cs_sqr":251}],231:[function(require,module,exports){
module.exports = [
  // decomposition
  require('./decomposition/lup'),
  require('./decomposition/slu'),

  // solver
  require('./solver/lsolve'),
  require('./solver/lusolve'),
  require('./solver/usolve')
];

},{"./decomposition/lup":229,"./decomposition/slu":230,"./solver/lsolve":232,"./solver/lusolve":233,"./solver/usolve":234}],232:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {

  var matrix = load(require('../../../type/matrix/function/matrix'));
  var divideScalar = load(require('../../arithmetic/divideScalar'));
  var multiplyScalar = load(require('../../arithmetic/multiplyScalar'));
  var subtract = load(require('../../arithmetic/subtract'));
  var equalScalar = load(require('../../relational/equalScalar'));

  var solveValidation = load(require('./utils/solveValidation'));

  var DenseMatrix = type.DenseMatrix;

  /** 
   * Solves the linear equation system by forwards substitution. Matrix must be a lower triangular matrix.
   *
   * `L * x = b`
   *
   * Syntax:
   *
   *    math.lsolve(L, b);
   *
   * Examples:
   *
   *    var a = [[-2, 3], [2, 1]];
   *    var b = [11, 9];
   *    var x = lsolve(a, b);  // [[-5.5], [20]]
   *
   * See also:
   *
   *    lup, slu, usolve, lusolve
   *
   * @param {Matrix, Array} L       A N x N matrix or array (L)
   * @param {Matrix, Array} b       A column vector with the b values
   *
   * @return {DenseMatrix | Array}  A column vector with the linear system solution (x)
   */
  var lsolve = typed('lsolve', {

    'SparseMatrix, Array | Matrix': function (m, b) {
      // process matrix
      return _sparseForwardSubstitution(m, b);
    },
    
    'DenseMatrix, Array | Matrix': function (m, b) {
      // process matrix
      return _denseForwardSubstitution(m, b);
    },
    
    'Array, Array | Matrix': function (a, b) {
      // create dense matrix from array
      var m = matrix(a);
      // use matrix implementation
      var r = _denseForwardSubstitution(m, b);
      // result
      return r.valueOf();
    }
  });

  var _denseForwardSubstitution = function (m, b) {
    // validate matrix and vector, return copy of column vector b
    b = solveValidation(m, b, true);
    // column vector data
    var bdata = b._data;
    // rows & columns
    var rows = m._size[0];
    var columns = m._size[1];
    // result
    var x = [];
    // data
    var data = m._data;
    // forward solve m * x = b, loop columns
    for (var j = 0; j < columns; j++) {
      // b[j]
      var bj = bdata[j][0] || 0;
      // x[j]
      var xj;
      // forward substitution (outer product) avoids inner looping when bj == 0
      if (!equalScalar(bj, 0)) {
        // value @ [j, j]
        var vjj = data[j][j];
        // check vjj
        if (equalScalar(vjj, 0)) {
          // system cannot be solved
          throw new Error('Linear system cannot be solved since matrix is singular');
        }
        // calculate xj
        xj = divideScalar(bj, vjj);
        // loop rows
        for (var i = j + 1; i < rows; i++) {
          // update copy of b
          bdata[i] = [subtract(bdata[i][0] || 0, multiplyScalar(xj, data[i][j]))];
        }
      }
      else {
        // zero @ j
        xj = 0;
      }
      // update x
      x[j] = [xj];
    }
    // return vector
    return new DenseMatrix({
      data: x,
      size: [rows, 1]
    });
  };

  var _sparseForwardSubstitution = function (m, b) {
    // validate matrix and vector, return copy of column vector b
    b = solveValidation(m, b, true);
    // column vector data
    var bdata = b._data;
    // rows & columns
    var rows = m._size[0];
    var columns = m._size[1];
    // matrix arrays
    var values = m._values;
    var index = m._index;
    var ptr = m._ptr;
    // vars
    var i, k;
    // result
    var x = [];
    // forward solve m * x = b, loop columns
    for (var j = 0; j < columns; j++) {
      // b[j]
      var bj = bdata[j][0] || 0;
      // forward substitution (outer product) avoids inner looping when bj == 0
      if (!equalScalar(bj, 0)) {
        // value @ [j, j]
        var vjj = 0;
        // lower triangular matrix values & index (column j)
        var jvalues = [];
        var jindex = [];
        // last index in column
        var l = ptr[j + 1];
        // values in column, find value @ [j, j]
        for (k = ptr[j]; k < l; k++) {
          // row
          i = index[k];
          // check row (rows are not sorted!)
          if (i === j) {
            // update vjj
            vjj = values[k];
          }
          else if (i > j) {
            // store lower triangular
            jvalues.push(values[k]);
            jindex.push(i);
          }
        }
        // at this point we must have a value @ [j, j]
        if (equalScalar(vjj, 0)) {
          // system cannot be solved, there is no value @ [j, j]
          throw new Error('Linear system cannot be solved since matrix is singular');
        }
        // calculate xj
        var xj = divideScalar(bj, vjj);
        // loop lower triangular
        for (k = 0, l = jindex.length; k < l; k++) {
          // row
          i = jindex[k];
          // update copy of b
          bdata[i] = [subtract(bdata[i][0] || 0, multiplyScalar(xj, jvalues[k]))];
        }
        // update x
        x[j] = [xj];
      }
      else {
        // update x
        x[j] = [0];
      }
    }
    // return vector
    return new DenseMatrix({
      data: x,
      size: [rows, 1]
    });
  };

  return lsolve;
}

exports.name = 'lsolve';
exports.factory = factory;

},{"../../../type/matrix/function/matrix":435,"../../arithmetic/divideScalar":261,"../../arithmetic/multiplyScalar":276,"../../arithmetic/subtract":284,"../../relational/equalScalar":352,"./utils/solveValidation":235}],233:[function(require,module,exports){
'use strict';

var isArray = Array.isArray;

function factory (type, config, load, typed) {
  
  var matrix = load(require('../../../type/matrix/function/matrix'));
  var lup = load(require('../decomposition/lup'));
  var slu = load(require('../decomposition/slu'));
  var cs_ipvec = load(require('../sparse/cs_ipvec'));

  var solveValidation = load(require('./utils/solveValidation'));

  var usolve = load(require('./usolve'));
  var lsolve = load(require('./lsolve'));

  /**
   * Solves the linear system `A * x = b` where `A` is an [n x n] matrix and `b` is a [n] column vector.
   *
   * Syntax:
   *
   *    math.lusolve(A, b)     // returns column vector with the solution to the linear system A * x = b
   *    math.lusolve(lup, b)   // returns column vector with the solution to the linear system A * x = b, lup = math.lup(A)
   *
   * Examples:
   *
   *    var m = [[1, 0, 0, 0], [0, 2, 0, 0], [0, 0, 3, 0], [0, 0, 0, 4]];
   *
   *    var x = math.lusolve(m, [-1, -1, -1, -1]);        // x = [[-1], [-0.5], [-1/3], [-0.25]]
   *
   *    var f = math.lup(m);
   *    var x1 = math.lusolve(f, [-1, -1, -1, -1]);       // x1 = [[-1], [-0.5], [-1/3], [-0.25]]
   *    var x2 = math.lusolve(f, [1, 2, 1, -1]);          // x2 = [[1], [1], [1/3], [-0.25]]
   *
   *    var a = [[-2, 3], [2, 1]];
   *    var b = [11, 9];
   *    var x = lusolve(a, b);  // [[-5.5], [20]]
   *
   * See also:
   *
   *    lup, slu, lsolve, usolve
   *
   * @param {Matrix | Array | Object} A      Invertible Matrix or the Matrix LU decomposition
   * @param {Matrix | Array} b               Column Vector
   * @param {number} [order]                 The Symbolic Ordering and Analysis order, see slu for details. Matrix must be a SparseMatrix
   * @param {Number} [threshold]             Partial pivoting threshold (1 for partial pivoting), see slu for details. Matrix must be a SparseMatrix.
   *
   * @return {DenseMatrix | Array}           Column vector with the solution to the linear system A * x = b
   */
  var lusolve = typed('lusolve', {
    
    'Array, Array | Matrix': function (a, b) {
      // convert a to matrix
      a = matrix(a);
      // matrix lup decomposition
      var d = lup(a);
      // solve
      var x = _lusolve(d.L, d.U, d.p, null, b);
      // convert result to array
      return x.valueOf();
    },
    
    'DenseMatrix, Array | Matrix': function (a, b) {
      // matrix lup decomposition
      var d = lup(a);
      // solve
      return _lusolve(d.L, d.U, d.p, null, b);
    },
    
    'SparseMatrix, Array | Matrix': function (a, b) {
      // matrix lup decomposition
      var d = lup(a);
      // solve
      return _lusolve(d.L, d.U, d.p, null, b);
    },
    
    'SparseMatrix, Array | Matrix, number, number': function (a, b, order, threshold) {
      // matrix lu decomposition
      var d = slu(a, order, threshold);
      // solve
      return _lusolve(d.L, d.U, d.p, d.q, b);
    },

    'Object, Array | Matrix': function (d, b) {
      // solve
      return _lusolve(d.L, d.U, d.p, d.q, b);
    }
  });
  
  var _toMatrix = function (a) {
    // check it is a matrix
    if (a && a.isMatrix === true)
      return a;
    // check array
    if (isArray(a))
      return matrix(a);
    // throw
    throw new TypeError('Invalid Matrix LU decomposition');
  };
  
  var _lusolve = function (l, u, p, q, b) {
    // verify L, U, P
    l = _toMatrix(l);
    u = _toMatrix(u);
    // validate matrix and vector
    b = solveValidation(l, b, false);
    // apply row permutations if needed (b is a DenseMatrix)
    if (p)
      b._data = cs_ipvec(p, b._data);
    // use forward substitution to resolve L * y = b
    var y = lsolve(l, b);
    // use backward substitution to resolve U * x = y
    var x = usolve(u, y);
    // apply column permutations if needed (x is a DenseMatrix)
    if (q)
      x._data = cs_ipvec(q, x._data);
    // return solution
    return x;
  };

  return lusolve;
}

exports.name = 'lusolve';
exports.factory = factory;

},{"../../../type/matrix/function/matrix":435,"../decomposition/lup":229,"../decomposition/slu":230,"../sparse/cs_ipvec":242,"./lsolve":232,"./usolve":234,"./utils/solveValidation":235}],234:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {

  var matrix = load(require('../../../type/matrix/function/matrix'));
  var divideScalar = load(require('../../arithmetic/divideScalar'));
  var multiplyScalar = load(require('../../arithmetic/multiplyScalar'));
  var subtract = load(require('../../arithmetic/subtract'));
  var equalScalar = load(require('../../relational/equalScalar'));

  var solveValidation = load(require('./utils/solveValidation'));
  
  var DenseMatrix = type.DenseMatrix;

  /**
   * Solves the linear equation system by backward substitution. Matrix must be an upper triangular matrix.
   *
   * `U * x = b`
   *
   * Syntax:
   *
   *    math.usolve(U, b);
   *
   * Examples:
   *
   *    var a = [[-2, 3], [2, 1]];
   *    var b = [11, 9];
   *    var x = usolve(a, b);  // [[8], [9]]
   *
   * See also:
   *
   *    lup, slu, usolve, lusolve
   *
   * @param {Matrix, Array} U       A N x N matrix or array (U)
   * @param {Matrix, Array} b       A column vector with the b values
   *
   * @return {DenseMatrix | Array}  A column vector with the linear system solution (x)
   */
  var usolve = typed('usolve', {
    
    'SparseMatrix, Array | Matrix': function (m, b) {
      // process matrix
      return _sparseBackwardSubstitution(m, b);
    },

    'DenseMatrix, Array | Matrix': function (m, b) {
      // process matrix
      return _denseBackwardSubstitution(m, b);
    },

    'Array, Array | Matrix': function (a, b) {
      // create dense matrix from array
      var m = matrix(a);
      // use matrix implementation
      var r = _denseBackwardSubstitution(m, b);
      // result
      return r.valueOf();
    }
  });

  var _denseBackwardSubstitution = function (m, b) {
    // validate matrix and vector, return copy of column vector b
    b = solveValidation(m, b, true);
    // column vector data
    var bdata = b._data;
    // rows & columns
    var rows = m._size[0];
    var columns = m._size[1];
    // result
    var x = [];
    // arrays
    var data = m._data;
    // backward solve m * x = b, loop columns (backwards)
    for (var j = columns - 1; j >= 0 ; j--) {
      // b[j]
      var bj = bdata[j][0] || 0;
      // x[j]
      var xj;
      // backward substitution (outer product) avoids inner looping when bj == 0
      if (!equalScalar(bj, 0)) {
        // value @ [j, j]
        var vjj = data[j][j];
        // check vjj
        if (equalScalar(vjj, 0)) {
          // system cannot be solved
          throw new Error('Linear system cannot be solved since matrix is singular');
        }
        // calculate xj
        xj = divideScalar(bj, vjj);        
        // loop rows
        for (var i = j - 1; i >= 0; i--) {
          // update copy of b
          bdata[i] = [subtract(bdata[i][0] || 0, multiplyScalar(xj, data[i][j]))];
        }
      }
      else {
        // zero value @ j
        xj = 0;
      }
      // update x
      x[j] = [xj];
    }
    // return column vector
    return new DenseMatrix({
      data: x,
      size: [rows, 1]
    });
  };
  
  var _sparseBackwardSubstitution = function (m, b) {
    // validate matrix and vector, return copy of column vector b
    b = solveValidation(m, b, true);
    // column vector data
    var bdata = b._data;
    // rows & columns
    var rows = m._size[0];
    var columns = m._size[1];
    // matrix arrays
    var values = m._values;
    var index = m._index;
    var ptr = m._ptr;
    // vars
    var i, k;
    // result
    var x = [];
    // backward solve m * x = b, loop columns (backwards)
    for (var j = columns - 1; j >= 0 ; j--) {
      // b[j]
      var bj = bdata[j][0] || 0;
      // backward substitution (outer product) avoids inner looping when bj == 0
      if (!equalScalar(bj, 0)) {
        // value @ [j, j]
        var vjj = 0;
        // upper triangular matrix values & index (column j)
        var jvalues = [];
        var jindex = [];
        // first & last indeces in column
        var f = ptr[j];
        var l = ptr[j + 1];
        // values in column, find value @ [j, j], loop backwards
        for (k = l - 1; k >= f; k--) {
          // row
          i = index[k];
          // check row
          if (i === j) {
            // update vjj
            vjj = values[k];
          }
          else if (i < j) {
            // store upper triangular
            jvalues.push(values[k]);
            jindex.push(i);
          }
        }
        // at this point we must have a value @ [j, j]
        if (equalScalar(vjj, 0)) {
          // system cannot be solved, there is no value @ [j, j]
          throw new Error('Linear system cannot be solved since matrix is singular');
        }
        // calculate xj
        var xj = divideScalar(bj, vjj);
        // loop upper triangular
        for (k = 0, l = jindex.length; k < l; k++) {
          // row
          i = jindex[k];
          // update copy of b
          bdata[i] = [subtract(bdata[i][0], multiplyScalar(xj, jvalues[k]))];
        }
        // update x
        x[j] = [xj];
      }
      else {
        // update x
        x[j] = [0];
      }
    }
    // return vector
    return new DenseMatrix({
      data: x,
      size: [rows, 1]
    });
  };
  
  return usolve;
}

exports.name = 'usolve';
exports.factory = factory;

},{"../../../type/matrix/function/matrix":435,"../../arithmetic/divideScalar":261,"../../arithmetic/multiplyScalar":276,"../../arithmetic/subtract":284,"../../relational/equalScalar":352,"./utils/solveValidation":235}],235:[function(require,module,exports){
'use strict';

var util = require('../../../../utils/index');

var string = util.string;
var array = util.array;

var isArray = Array.isArray;

function factory (type) {
  
  var DenseMatrix = type.DenseMatrix;

  /**
   * Validates matrix and column vector b for backward/forward substitution algorithms.
   *
   * @param {Matrix} m            An N x N matrix
   * @param {Array | Matrix} b    A column vector
   * @param {Boolean} copy        Return a copy of vector b
   *
   * @return {DenseMatrix}        Dense column vector b
   */
  var solveValidation = function (m, b, copy) {
    // matrix size
    var size = m.size();
    // validate matrix dimensions
    if (size.length !== 2)
      throw new RangeError('Matrix must be two dimensional (size: ' + string.format(size) + ')');
    // rows & columns
    var rows = size[0];
    var columns = size[1];    
    // validate rows & columns
    if (rows !== columns) 
      throw new RangeError('Matrix must be square (size: ' + string.format(size) + ')');
    // vars
    var data, i, bdata;
    // check b is matrix
    if (b && b.isMatrix === true) {
      // matrix size
      var msize = b.size();
      // vector
      if (msize.length === 1) {
        // check vector length
        if (msize[0] !== rows)
          throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');
        // create data array
        data = [];
        // matrix data (DenseMatrix)
        bdata = b._data;
        // loop b data
        for (i = 0; i < rows; i++) {
          // row array
          data[i] = [bdata[i]];
        }
        // return Dense Matrix
        return new DenseMatrix({
          data: data,
          size: [rows, 1],
          datatype: b._datatype
        });
      }
      // two dimensions
      if (msize.length === 2) {
        // array must be a column vector
        if (msize[0] !== rows || msize[1] !== 1)
          throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');
        // check matrix type
        if (b.isDenseMatrix === true) {
          // check a copy is needed
          if (copy) {
            // create data array
            data = [];
            // matrix data (DenseMatrix)
            bdata = b._data;
            // loop b data
            for (i = 0; i < rows; i++) {
              // row array
              data[i] = [bdata[i][0]];
            }
            // return Dense Matrix
            return new DenseMatrix({
              data: data,
              size: [rows, 1],
              datatype: b._datatype
            });
          }
          // b is already a column vector
          return b;
        }
        // create data array
        data = [];
        for (i = 0; i < rows; i++)
          data[i] = [0];
        // sparse matrix arrays
        var values = b._values;
        var index = b._index;
        var ptr = b._ptr;
        // loop values in column 0
        for (var k1 = ptr[1], k = ptr[0]; k < k1; k++) {
          // row
          i = index[k];
          // add to data
          data[i][0] = values[k]; 
        }
        // return Dense Matrix
        return new DenseMatrix({
          data: data,
          size: [rows, 1],
          datatype: b._datatype
        });
      }
      // throw error
      throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');
    }
    // check b is array
    if (isArray(b)) {
      // size
      var asize = array.size(b);
      // check matrix dimensions, vector
      if (asize.length === 1) {
        // check vector length
        if (asize[0] !== rows)
          throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');        
        // create data array
        data = [];
        // loop b
        for (i = 0; i < rows; i++) {
          // row array
          data[i] = [b[i]];
        }
        // return Dense Matrix
        return new DenseMatrix({
          data: data,
          size: [rows, 1]
        });
      }
      if (asize.length === 2) {
        // array must be a column vector
        if (asize[0] !== rows || asize[1] !== 1)
          throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');
        // create data array
        data = [];
        // loop b data
        for (i = 0; i < rows; i++) {
          // row array
          data[i] = [b[i][0]];
        }
        // return Dense Matrix
        return new DenseMatrix({
          data: data,
          size: [rows, 1]
        });
      }
      // throw error
      throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');      
    }
  };
  
  return solveValidation;
}

exports.factory = factory;
},{"../../../../utils/index":481}],236:[function(require,module,exports){
'use strict';

function factory (type, config, load) {

  var cs_flip = load(require('./cs_flip'));
  var cs_fkeep = load(require('./cs_fkeep'));
  var cs_tdfs = load(require('./cs_tdfs'));
  
  var add       = load(require('../../arithmetic/add'));
  var multiply  = load(require('../../arithmetic/multiply'));
  var transpose = load(require('../../matrix/transpose'));

  /**
   * Approximate minimum degree ordering. The minimum degree algorithm is a widely used 
   * heuristic for finding a permutation P so that P*A*P' has fewer nonzeros in its factorization
   * than A. It is a gready method that selects the sparsest pivot row and column during the course
   * of a right looking sparse Cholesky factorization.
   *
   * Reference: http://faculty.cse.tamu.edu/davis/publications.html
   *
   * @param {Number} order    0: Natural, 1: Cholesky, 2: LU, 3: QR
   * @param {Matrix} m        Sparse Matrix
   *
   * Reference: http://faculty.cse.tamu.edu/davis/publications.html
   */
  var cs_amd = function (order, a) {
    // check input parameters
    if (!a || order <= 0 || order > 3)
      return null;
    // a matrix arrays
    var asize = a._size;
    // rows and columns
    var m = asize[0];
    var n = asize[1];    
    // initialize vars
    var lemax = 0;
    // dense threshold
    var dense = Math.max(16, 10 * Math.sqrt(n));
    dense = Math.min(n - 2, dense);
    // create target matrix C
    var cm = _createTargetMatrix(order, a, m, n, dense);
    // drop diagonal entries
    cs_fkeep(cm, _diag, null);
    // C matrix arrays
    var cindex = cm._index;
    var cptr = cm._ptr;

    // number of nonzero elements in C
    var cnz = cptr[n];
    
    // allocate result (n+1)
    var P = [];
    
    // create workspace (8 * (n + 1))
    var W = [];
    var len = 0; // first n + 1 entries
    var nv = n + 1; // next n + 1 entries
    var next = 2 * (n + 1); // next n + 1 entries
    var head = 3 * (n + 1);  // next n + 1 entries
    var elen = 4 * (n + 1);  // next n + 1 entries
    var degree = 5 * (n + 1);  // next n + 1 entries
    var w = 6 * (n + 1);  // next n + 1 entries
    var hhead = 7 * (n + 1);  // last n + 1 entries    

    // use P as workspace for last
    var last = P;
    
    // initialize quotient graph
    var mark = _initializeQuotientGraph(n, cptr, W, len, head, last, next, hhead, nv, w, elen, degree);
    
    // initialize degree lists
    var nel = _initializeDegreeLists(n, cptr, W, degree, elen, w, dense, nv, head, last, next);
    
    // minimum degree node
    var mindeg = 0;
    
    // vars
    var i, j, k, k1, k2, e, pj, ln, nvi, pk, eln, p1, p2, pn, h, d;
    
    // while (selecting pivots) do
    while (nel < n) {
      // select node of minimum approximate degree. amd() is now ready to start eliminating the graph. It first
      // finds a node k of minimum degree and removes it from its degree list. The variable nel keeps track of thow
      // many nodes have been eliminated.
      for (k = -1; mindeg < n && (k = W[head + mindeg]) == -1; mindeg++);      
      if (W[next + k] != -1) 
        last[W[next + k]] = -1;
      // remove k from degree list
      W[head + mindeg] = W[next + k];
      // elenk = |Ek|
      var elenk = W[elen + k];
      // # of nodes k represents
      var nvk = W[nv + k];
      // W[nv + k] nodes of A eliminated
      nel += nvk;

      // Construct a new element. The new element Lk is constructed in place if |Ek| = 0. nv[i] is 
      // negated for all nodes i in Lk to flag them as members of this set. Each node i is removed from the
      // degree lists. All elements e in Ek are absorved into element k.
      var dk = 0;
      // flag k as in Lk
      W[nv + k] = -nvk;
      var p = cptr[k];
      // do in place if W[elen + k] == 0
      var pk1 = (elenk === 0) ? p : cnz;
      var pk2 = pk1;
      for (k1 = 1; k1 <= elenk + 1; k1++) {
        if (k1 > elenk) {
          // search the nodes in k
          e = k;
          // list of nodes starts at cindex[pj]
          pj = p;
          // length of list of nodes in k
          ln = W[len + k] - elenk;
        }
        else {
          // search the nodes in e
          e = cindex[p++];
          pj = cptr[e];
          // length of list of nodes in e
          ln = W[len + e];
        }
        for (k2 = 1; k2 <= ln; k2++) {
          i = cindex[pj++];
          // check  node i dead, or seen
          if ((nvi = W[nv + i]) <= 0) 
            continue;
          // W[degree + Lk] += size of node i
          dk += nvi;
          // negate W[nv + i] to denote i in Lk
          W[nv + i] = -nvi;
          // place i in Lk
          cindex[pk2++] = i;
          if (W[next + i] != -1) 
            last[W[next + i]] = last[i];
          // check we need to remove i from degree list
          if (last[i] != -1) 
            W[next + last[i]] = W[next + i];
          else
            W[head + W[degree + i]] = W[next + i];
        }
        if (e != k) {
          // absorb e into k
          cptr[e] = cs_flip(k);
          // e is now a dead element
          W[w + e] = 0;
        }
      }
      // cindex[cnz...nzmax] is free
      if (elenk !== 0) 
        cnz = pk2;
      // external degree of k - |Lk\i|
      W[degree + k] = dk;
      // element k is in cindex[pk1..pk2-1]
      cptr[k] = pk1;
      W[len + k] = pk2 - pk1;
      // k is now an element
      W[elen + k] = -2;
            
      // Find set differences. The scan1 function now computes the set differences |Le \ Lk| for all elements e. At the start of the
      // scan, no entry in the w array is greater than or equal to mark.
      
      // clear w if necessary
      mark = _wclear(mark, lemax, W, w, n);
      // scan 1: find |Le\Lk|
      for (pk = pk1; pk < pk2; pk++) {
        i = cindex[pk];
        // check if W[elen + i] empty, skip it
        if ((eln = W[elen + i]) <= 0) 
          continue;
        // W[nv + i] was negated
        nvi = -W[nv + i];
        var wnvi = mark - nvi;
        // scan Ei
        for (p = cptr[i], p1 = cptr[i] + eln - 1; p <= p1; p++) {
          e = cindex[p];
          if (W[w + e] >= mark) {
            // decrement |Le\Lk|
            W[w + e] -= nvi;
          }
          else if (W[w + e] !== 0) {
            // ensure e is a live element, 1st time e seen in scan 1
            W[w + e] = W[degree + e] + wnvi;
          }
        }
      }
      
      // degree update
      // The second pass computes the approximate degree di, prunes the sets Ei and Ai, and computes a hash
      // function h(i) for all nodes in Lk.
      
      // scan2: degree update
      for (pk = pk1; pk < pk2; pk++) {
        // consider node i in Lk
        i = cindex[pk];
        p1 = cptr[i];
        p2 = p1 + W[elen + i] - 1;
        pn = p1;
        // scan Ei
        for (h = 0, d = 0, p = p1; p <= p2; p++) {
          e = cindex[p];
          // check e is an unabsorbed element
          if (W[w + e] !== 0) {
            // dext = |Le\Lk|
            var dext = W[w + e] - mark;
            if (dext > 0) {
              // sum up the set differences
              d += dext;
              // keep e in Ei
              cindex[pn++] = e;
              // compute the hash of node i
              h += e;
            }
            else {
              // aggressive absorb. e->k
              cptr[e] = cs_flip(k);
              // e is a dead element
              W[w + e] = 0;
            }
          }
        }
        // W[elen + i] = |Ei|
        W[elen + i] = pn - p1 + 1;
        var p3 = pn;
        var p4 = p1 + W[len + i];
        // prune edges in Ai
        for (p = p2 + 1; p < p4; p++) {
          j = cindex[p];
          // check node j dead or in Lk
          var nvj = W[nv + j];
          if (nvj <= 0) 
            continue;
          // degree(i) += |j|
          d += nvj;
          // place j in node list of i
          cindex[pn++] = j;
          // compute hash for node i
          h += j;
        }
        // check for mass elimination
        if (d === 0) {
          // absorb i into k
          cptr[i] = cs_flip(k);
          nvi = -W[nv + i];
          // |Lk| -= |i|
          dk -= nvi;
          // |k| += W[nv + i]
          nvk += nvi;
          nel += nvi;
          W[nv + i] = 0;
          // node i is dead
          W[elen + i] = -1;
        }
        else {
          // update degree(i)
          W[degree + i] = Math.min(W[degree + i], d);
          // move first node to end
          cindex[pn] = cindex[p3];
          // move 1st el. to end of Ei
          cindex[p3] = cindex[p1];
          // add k as 1st element in of Ei
          cindex[p1] = k;
          // new len of adj. list of node i
          W[len + i] = pn - p1 + 1;
          // finalize hash of i
          h = (h < 0 ? -h : h) % n;
          // place i in hash bucket
          W[next + i] = W[hhead + h];
          W[hhead + h] = i;
          // save hash of i in last[i]
          last[i] = h;
        }
      }
      // finalize |Lk|
      W[degree + k] = dk;
      lemax = Math.max(lemax, dk);
      // clear w
      mark = _wclear(mark + lemax, lemax, W, w, n);
      
      // Supernode detection. Supernode detection relies on the hash function h(i) computed for each node i.
      // If two nodes have identical adjacency lists, their hash functions wil be identical.
      for (pk = pk1; pk < pk2; pk++) {
        i = cindex[pk];
        // check i is dead, skip it
        if (W[nv + i] >= 0) 
          continue;
        // scan hash bucket of node i
        h = last[i];
        i = W[hhead + h];
        // hash bucket will be empty
        W[hhead + h] = -1;
        for (; i != -1 && W[next + i] != -1; i = W[next + i], mark++) {
          ln = W[len + i];
          eln = W[elen + i];
          for (p = cptr[i] + 1; p <= cptr[i] + ln - 1; p++) 
            W[w + cindex[p]] = mark;
          var jlast = i;
          // compare i with all j
          for (j = W[next + i]; j != -1; ) {
            var ok = W[len + j] === ln && W[elen + j] === eln;
            for (p = cptr[j] + 1; ok && p <= cptr[j] + ln - 1; p++) {
              // compare i and j
              if (W[w + cindex[p]] != mark) 
                ok = 0;
            }
            // check i and j are identical
            if (ok) {
              // absorb j into i
              cptr[j] = cs_flip(i);
              W[nv + i] += W[nv + j];
              W[nv + j] = 0;
              // node j is dead
              W[elen + j] = -1;
              // delete j from hash bucket
              j = W[next + j];
              W[next + jlast] = j;
            }
            else {
              // j and i are different
              jlast = j;
              j = W[next + j];
            }
          }
        }
      }
      
      // Finalize new element. The elimination of node k is nearly complete. All nodes i in Lk are scanned one last time.
      // Node i is removed from Lk if it is dead. The flagged status of nv[i] is cleared.
      for (p = pk1, pk = pk1; pk < pk2; pk++) {
        i = cindex[pk];
        // check  i is dead, skip it
        if ((nvi = -W[nv + i]) <= 0) 
          continue;
        // restore W[nv + i]
        W[nv + i] = nvi;
        // compute external degree(i)
        d = W[degree + i] + dk - nvi;
        d = Math.min(d, n - nel - nvi);
        if (W[head + d] != -1) 
          last[W[head + d]] = i;
        // put i back in degree list
        W[next + i] = W[head + d];
        last[i] = -1;
        W[head + d] = i;
        // find new minimum degree
        mindeg = Math.min(mindeg, d);
        W[degree + i] = d;
        // place i in Lk
        cindex[p++] = i;
      }
      // # nodes absorbed into k
      W[nv + k] = nvk;
      // length of adj list of element k
      if ((W[len + k] = p - pk1) === 0) {
        // k is a root of the tree
        cptr[k] = -1;
        // k is now a dead element
        W[w + k] = 0;
      }
      if (elenk !== 0) {
        // free unused space in Lk
        cnz = p;
      }
    }
    
    // Postordering. The elimination is complete, but no permutation has been computed. All that is left 
    // of the graph is the assembly tree (ptr) and a set of dead nodes and elements (i is a dead node if
    // nv[i] is zero and a dead element if nv[i] > 0). It is from this information only that the final permutation
    // is computed. The tree is restored by unflipping all of ptr.
    
    // fix assembly tree
    for (i = 0; i < n; i++) 
      cptr[i] = cs_flip(cptr[i]);
    for (j = 0; j <= n; j++) 
      W[head + j] = -1;
    // place unordered nodes in lists
    for (j = n; j >= 0; j--) {
      // skip if j is an element
      if (W[nv + j] > 0)
        continue;
      // place j in list of its parent
      W[next + j] = W[head + cptr[j]];
      W[head + cptr[j]] = j;
    }
    // place elements in lists
    for (e = n; e >= 0; e--) {
      // skip unless e is an element
      if (W[nv + e] <= 0)
        continue;
      if (cptr[e] != -1) {
        // place e in list of its parent
        W[next + e] = W[head + cptr[e]];
        W[head + cptr[e]] = e;
      }
    }
    // postorder the assembly tree
    for (k = 0, i = 0; i <= n; i++) {
      if (cptr[i] == -1) 
        k = cs_tdfs(i, k, W, head, next, P, w);
    }
    // remove last item in array
    P.splice(P.length - 1, 1);
    // return P
    return P;
  };
  
  /**
   * Creates the matrix that will be used by the approximate minimum degree ordering algorithm. The function accepts the matrix M as input and returns a permutation
   * vector P. The amd algorithm operates on a symmetrix matrix, so one of three symmetric matrices is formed.
   *
   * Order: 0
   *   A natural ordering P=null matrix is returned.
   *
   * Order: 1
   *   Matrix must be square. This is appropriate for a Cholesky or LU factorization.
   *   P = M + M'
   *
   * Order: 2
   *   Dense columns from M' are dropped, M recreated from M'. This is appropriatefor LU factorization of unsymmetric matrices.
   *   P = M' * M
   * 
   * Order: 3
   *   This is best used for QR factorization or LU factorization is matrix M has no dense rows. A dense row is a row with more than 10*sqr(columns) entries.
   *   P = M' * M
   */
  var _createTargetMatrix = function (order, a, m, n, dense) {
    // compute A'
    var at = transpose(a);

    // check order = 1, matrix must be square
    if (order === 1 && n === m) {
      // C = A + A'
      return add(a, at);
    }
    
    // check order = 2, drop dense columns from M'
    if (order == 2) {
      // transpose arrays
      var tindex = at._index;
      var tptr = at._ptr;
      // new column index
      var p2 = 0;
      // loop A' columns (rows)
      for (var j = 0; j < m; j++) {
        // column j of AT starts here
        var p = tptr[j];
        // new column j starts here
        tptr[j] = p2;
        // skip dense col j
        if (tptr[j + 1] - p > dense) 
          continue;
        // map rows in column j of A
        for (var p1 = tptr[j + 1]; p < p1; p++) 
          tindex[p2++] = tindex[p];
      }
      // finalize AT
      tptr[m] = p2;
      // recreate A from new transpose matrix
      a = transpose(at);
      // use A' * A
      return multiply(at, a);
    }
    
    // use A' * A, square or rectangular matrix
    return multiply(at, a);
  };

  /**
   * Initialize quotient graph. There are four kind of nodes and elements that must be represented:
   *
   *  - A live node is a node i (or a supernode) that has not been selected as a pivot nad has not been merged into another supernode.
   *  - A dead node i is one that has been removed from the graph, having been absorved into r = flip(ptr[i]).
   *  - A live element e is one that is in the graph, having been formed when node e was selected as the pivot.
   *  - A dead element e is one that has benn absorved into a subsequent element s = flip(ptr[e]).
   */
  var _initializeQuotientGraph = function (n, cptr, W, len, head, last, next, hhead, nv, w, elen, degree) {
    // Initialize quotient graph
    for (var k = 0; k < n; k++) 
      W[len + k] = cptr[k + 1] - cptr[k];
    W[len + n] = 0;
    // initialize workspace
    for (var i = 0; i <= n; i++) {
      // degree list i is empty
      W[head + i] = -1;
      last[i] = -1;
      W[next + i] = -1;
      // hash list i is empty
      W[hhead + i] = -1;
      // node i is just one node
      W[nv + i] = 1;
      // node i is alive
      W[w + i] = 1;
      // Ek of node i is empty
      W[elen + i] = 0;
      // degree of node i
      W[degree + i] = W[len + i];
    }
    // clear w
    var mark = _wclear(0, 0, W, w, n);
    // n is a dead element
    W[elen + n] = -2;
    // n is a root of assembly tree
    cptr[n] = -1;
    // n is a dead element
    W[w + n] = 0;
    // return mark
    return mark;
  };

  /**
   * Initialize degree lists. Each node is placed in its degree lists. Nodes of zero degree are eliminated immediately. Nodes with 
   * degree >= dense are alsol eliminated and merged into a placeholder node n, a dead element. Thes nodes will appera last in the
   * output permutation p.
   */
  var _initializeDegreeLists = function (n, cptr, W, degree, elen, w, dense, nv, head, last, next) {
    // result
    var nel = 0;
    // loop columns
    for (var i = 0; i < n; i++) {
      // degree @ i
      var d = W[degree + i];
      // check node i is empty
      if (d === 0) {
        // element i is dead
        W[elen + i] = -2;
        nel++;
        // i is a root of assembly tree
        cptr[i] = -1;
        W[w + i] = 0;
      }
      else if (d > dense) {
        // absorb i into element n
        W[nv + i] = 0;
        // node i is dead
        W[elen + i] = -1;
        nel++;
        cptr[i] = cs_flip(n);
        W[nv + n]++;
      }
      else {
        var h = W[head + d];
        if (h != -1)
          last[h] = i;
        // put node i in degree list d
        W[next + i] = W[head + d];
        W[head + d] = i;
      }
    }
    return nel;
  };

  var _wclear = function(mark, lemax, W, w, n) {
    if (mark < 2 || (mark + lemax < 0)) {
      for (var k = 0; k < n; k++) {
        if (W[w + k] !== 0)
          W[w + k] = 1;
      }
      mark = 2 ;
    }
    // at this point, W [0..n-1] < mark holds
    return mark;
  };
  
  var _diag = function (i, j) { 
    return i != j;
  };
  
  return cs_amd;
}

exports.name = 'cs_amd';
exports.path = 'sparse';
exports.factory = factory;

},{"../../arithmetic/add":255,"../../arithmetic/multiply":275,"../../matrix/transpose":336,"./cs_fkeep":240,"./cs_flip":241,"./cs_tdfs":252}],237:[function(require,module,exports){
'use strict';

function factory (type, config, load) {

  var transpose = load(require('../../matrix/transpose'));
  
  var cs_leaf = load(require('./cs_leaf'));

  /**
   * Computes the column counts using the upper triangular part of A.
   * It transposes A internally, none of the input parameters are modified.
   *
   * @param {Matrix} a           The sparse matrix A
   *
   * @param {Matrix} ata         Count the columns of A'A instead
   *
   * @return                     An array of size n of the column counts or null on error
   *
   * Reference: http://faculty.cse.tamu.edu/davis/publications.html
   */
  var cs_counts = function (a, parent, post, ata) {
    // check inputs
    if (!a || !parent || !post) 
      return null;
    // a matrix arrays
    var asize = a._size;
    // rows and columns
    var m = asize[0];
    var n = asize[1];   
    // variables
    var i, j, k,  J,  p, p0, p1;
    
    // workspace size
    var s = 4 * n + (ata ? (n + m + 1) : 0);
    // allocate workspace
    var w = []; // (s)
    var ancestor = 0; // first n entries
    var maxfirst = n; // next n entries
    var prevleaf = 2 * n; // next n entries
    var first = 3 * n; // next n entries
    var head = 4 * n; // next n + 1 entries (used when ata is true)
    var next = 5 * n + 1; // last entries in workspace
    // clear workspace w[0..s-1]
    for (k = 0; k < s; k++) 
      w[k] = -1;
    
    // allocate result
    var colcount = []; // (n);
    
    // AT = A'
    var at = transpose(a);
    // at arrays
    var tindex = at._index;
    var tptr = at._ptr;

    // find w[first + j]
    for (k = 0; k < n; k++) {
      j = post[k];
      // colcount[j]=1 if j is a leaf
      colcount[j] = (w[first + j] == -1) ? 1 : 0;
      for (; j != -1 && w[first + j] == -1; j = parent[j]) 
        w[first + j] = k;
    }

    // initialize ata if needed
    if (ata) {
      // invert post
      for (k = 0; k < n; k++) 
        w[post[k]] = k;
      // loop rows (columns in AT)
      for (i = 0; i < m; i++) {
        // values in column i of AT
        for (k = n, p0 = tptr[i], p1 = tptr[i + 1], p = p0; p < p1; p++) 
          k = Math.min(k, w[tindex[p]]);
        // place row i in linked list k
        w[next + i] = w[head + k];
        w[head + k] = i;
      }
    }
    
    // each node in its own set
    for (i = 0; i < n; i++) 
      w[ancestor + i] = i;
    
    for (k = 0; k < n; k++) {
      // j is the kth node in postordered etree
      j = post[k];
      // check j is not a root
      if (parent[j] != -1) 
        colcount[parent[j]]--;
      
      // J=j for LL'=A case
      for (J = (ata ? w[head + k] : j); J != -1; J = (ata ? w[next + J] : -1)) {
        for (p = tptr[J]; p < tptr[J+1]; p++) {
          i = tindex[p];
          var r = cs_leaf(i, j, w, first, maxfirst, prevleaf, ancestor);
          // check A(i,j) is in skeleton
          if (r.jleaf >= 1) 
            colcount[j]++;
          // check account for overlap in q
          if (r.jleaf == 2) 
            colcount[r.q]--;
        }
      }
      if (parent[j] != -1) 
        w[ancestor + j] = parent[j];
    }
    // sum up colcount's of each child
    for (j = 0; j < n; j++) {
      if (parent[j] != -1) 
        colcount[parent[j]] += colcount[j];
    }
    return colcount;
  };

  return cs_counts;
}

exports.name = 'cs_counts';
exports.path = 'sparse';
exports.factory = factory;

},{"../../matrix/transpose":336,"./cs_leaf":243}],238:[function(require,module,exports){
'use strict';

function factory (type, config, load) {

  var cs_marked = load(require('./cs_marked'));
  var cs_mark   = load(require('./cs_mark'));
  var cs_unflip = load(require('./cs_unflip'));

  /**
   * Depth-first search computes the nonzero pattern xi of the directed graph G (Matrix) starting
   * at nodes in B (see cs_reach()).
   *
   * @param {Number}  j               The starting node for the DFS algorithm
   * @param {Matrix}  g               The G matrix to search, ptr array modified, then restored
   * @param {Number}  top             Start index in stack xi[top..n-1]
   * @param {Number}  k               The kth column in B
   * @param {Array}   xi              The nonzero pattern xi[top] .. xi[n - 1], an array of size = 2 * n
   *                                  The first n entries is the nonzero pattern, the last n entries is the stack
   * @param {Array}   pinv            The inverse row permutation vector, must be null for L * x = b
   *
   * @return {Number}                 New value of top
   *
   * Reference: http://faculty.cse.tamu.edu/davis/publications.html
   */
  var cs_dfs = function (j, g, top, xi, pinv) {
    // g arrays
    var index = g._index;
    var ptr = g._ptr;
    var size = g._size;
    // columns
    var n = size[1];
    // vars
    var i, p, p2;
    // initialize head
    var head = 0;
    // initialize the recursion stack
    xi[0] = j;
    // loop
    while (head >= 0) {
      // get j from the top of the recursion stack
      j = xi[head];
      // apply permutation vector
      var jnew = pinv ? pinv[j] : j;
      // check node j is marked
      if (!cs_marked(ptr, j)) {
        // mark node j as visited
        cs_mark(ptr, j);
        // update stack (last n entries in xi)
        xi[n + head] = jnew < 0 ? 0 : cs_unflip(ptr[jnew]);
      }
      // node j done if no unvisited neighbors
      var done = 1;
      // examine all neighbors of j, stack (last n entries in xi)
      for (p = xi[n + head], p2 = jnew < 0 ? 0 : cs_unflip(ptr[jnew+1]); p < p2; p++) {
        // consider neighbor node i
        i = index[p];
        // check we have visited node i, skip it
        if (cs_marked(ptr, i)) 
          continue;
        // pause depth-first search of node j, update stack (last n entries in xi)
        xi[n + head] = p;
        // start dfs at node i
        xi[++head] = i;
        // node j is not done
        done = 0;
        // break, to start dfs(i)
        break;
      }
      // check depth-first search at node j is done
      if (done) {
        // remove j from the recursion stack
        head--;
        // and place in the output stack
        xi[--top] = j;
      }
    }
    return top;    
  };

  return cs_dfs;
}

exports.name = 'cs_dfs';
exports.path = 'sparse';
exports.factory = factory;

},{"./cs_mark":245,"./cs_marked":246,"./cs_unflip":253}],239:[function(require,module,exports){
'use strict';

function factory () {

  /**
   * Computes the elimination tree of Matrix A (using triu(A)) or the 
   * elimination tree of A'A without forming A'A.
   *
   * @param {Matrix}  a               The A Matrix
   * @param {boolean} ata             A value of true the function computes the etree of A'A
   *
   * Reference: http://faculty.cse.tamu.edu/davis/publications.html
   */
  var cs_etree = function (a, ata) {
    // check inputs
    if (!a)
      return null;
    // a arrays
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    // rows & columns
    var m = asize[0];
    var n = asize[1];
    
    // allocate result
    var parent = []; // (n)
    
    // allocate workspace
    var w = []; // (n + (ata ? m : 0))
    var ancestor = 0; // first n entries in w
    var prev = n; // last m entries (ata = true)
    
    var i, inext;
    
    // check we are calculating A'A
    if (ata) {
      // initialize workspace
      for (i = 0; i < m; i++) 
        w[prev + i] = -1;
    }
    // loop columns
    for (var k = 0; k < n; k++) {
      // node k has no parent yet
      parent[k] = -1;
      // nor does k have an ancestor
      w[ancestor + k] = -1;
      // values in column k
      for (var p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {
        // row
        var r = aindex[p];
        // node
        i = ata ? (w[prev + r]) : r;
        // traverse from i to k 
        for (; i != -1 && i < k; i = inext) {
          // inext = ancestor of i
          inext = w[ancestor + i];
          // path compression
          w[ancestor + i] = k;
          // check no anc., parent is k
          if (inext == -1) 
            parent[i] = k;
        }
        if (ata) 
          w[prev + r] = k;
      }
    }
    return parent;
  };

  return cs_etree;
}

exports.name = 'cs_etree';
exports.path = 'sparse';
exports.factory = factory;

},{}],240:[function(require,module,exports){
'use strict';

function factory () {

  /**
   * Keeps entries in the matrix when the callback function returns true, removes the entry otherwise
   *
   * @param {Matrix}   a              The sparse matrix
   * @param {function} callback       The callback function, function will be invoked with the following args:
   *                                    - The entry row
   *                                    - The entry column
   *                                    - The entry value
   *                                    - The state parameter
   * @param {any}      other          The state
   *
   * @return                          The number of nonzero elements in the matrix
   *
   * Reference: http://faculty.cse.tamu.edu/davis/publications.html
   */
  var cs_fkeep = function (a, callback, other) {
    // a arrays
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    // columns
    var n = asize[1];
    // nonzero items
    var nz = 0;
    // loop columns
    for (var j = 0; j < n; j++) {
      // get current location of col j
      var p = aptr[j];
      // record new location of col j
      aptr[j] = nz;
      for (; p < aptr[j+1]; p++) {
        // check we need to keep this item
        if (callback(aindex[p], j, avalues ? avalues[p] : 1, other)) {
          // keep A(i,j)
          aindex[nz] = aindex[p];
          // check we need to process values (pattern only)
          if (avalues) 
            avalues[nz] = avalues[p];
          // increment nonzero items
          nz++;
        }
      }
    }
    // finalize A
    aptr[n] = nz;
    // trim arrays
    aindex.splice(nz, aindex.length - nz);
    // check we need to process values (pattern only)
    if (avalues)
      avalues.splice(nz, avalues.length - nz);    
    // return number of nonzero items
    return (nz);
  };
  
  return cs_fkeep;
}

exports.name = 'cs_fkeep';
exports.path = 'sparse';
exports.factory = factory;

},{}],241:[function(require,module,exports){
'use strict';

function factory () {

  /**
   * This function "flips" its input about the integer -1.
   *
   * @param {Number}  i               The value to flip
   *
   * Reference: http://faculty.cse.tamu.edu/davis/publications.html
   */
  var cs_flip = function (i) {
    // flip the value
    return -i - 2;
  };

  return cs_flip;
}

exports.name = 'cs_flip';
exports.path = 'sparse';
exports.factory = factory;

},{}],242:[function(require,module,exports){
'use strict';

function factory () {

  /**
   * Permutes a vector; x = P'b. In MATLAB notation, x(p)=b.
   *
   * @param {Array} p           The permutation vector of length n. null value denotes identity
   * @param {Array} b           The input vector
   *
   * @return {Array}            The output vector x = P'b
   */
  var cs_ipvec = function (p, b, n) {
    // vars 
    var k;
    var n = b.length;
    var x = [];
    // check permutation vector was provided, p = null denotes identity
    if (p) {
      // loop vector
      for (k = 0; k < n; k++) {
        // apply permutation
        x[p[k]] = b[k];
      }
    }
    else {
      // loop vector
      for (k = 0; k < n; k++) {
        // x[i] = b[i]
        x[k] = b[k];
      }
    }
    return x;
  };

  return cs_ipvec;
}

exports.name = 'cs_ipvec';
exports.path = 'sparse';
exports.factory = factory;

},{}],243:[function(require,module,exports){
'use strict';

function factory () {

  /**
   * This function determines if j is a leaf of the ith row subtree.
   * Consider A(i,j), node j in ith row subtree and return lca(jprev,j)
   *
   * @param {Number}  i               The ith row subtree
   * @param {Number}  j               The node to test
   * @param {Array}   w               The workspace array
   * @param {Number}  first           The index offset within the workspace for the first array
   * @param {Number}  maxfirst        The index offset within the workspace for the maxfirst array
   * @param {Number}  prevleaf        The index offset within the workspace for the prevleaf array
   * @param {Number}  ancestor        The index offset within the workspace for the ancestor array
   *
   * @return {Object}
   *
   * Reference: http://faculty.cse.tamu.edu/davis/publications.html
   */
  var cs_leaf = function (i, j, w, first, maxfirst, prevleaf, ancestor) {
    
    var s, sparent, jprev;
    
    // our result
    var jleaf = 0;
    var q;
    
    // check j is a leaf
    if (i <= j || w[first + j] <= w[maxfirst + i]) 
      return (-1);
    // update max first[j] seen so far
    w[maxfirst + i] = w[first + j];
    // jprev = previous leaf of ith subtree
    jprev = w[prevleaf + i];
    w[prevleaf + i] = j;
    
    // check j is first or subsequent leaf
    if (jprev === -1) {
      // 1st leaf, q = root of ith subtree
      jleaf = 1;
      q = i;
    }
    else {
      // update jleaf
      jleaf = 2;
      // q = least common ancester (jprev,j)
      for (q = jprev; q != w[ancestor + q]; q = w[ancestor + q]);
      for (s = jprev; s != q; s = sparent) {
        // path compression
        sparent = w[ancestor + s];
        w[ancestor + s] = q;
      }      
    }
    return {
      jleaf: jleaf,
      q: q
    };
  };

  return cs_leaf;
}

exports.name = 'cs_leaf';
exports.path = 'sparse';
exports.factory = factory;

},{}],244:[function(require,module,exports){
'use strict';

function factory (type, config, load) {

  var abs = load(require('../../arithmetic/abs'));
  var divideScalar = load(require('../../arithmetic/divideScalar'));
  var multiply = load(require('../../arithmetic/multiply'));
  
  var larger = load(require('../../relational/larger'));
  var largerEq = load(require('../../relational/largerEq'));
  
  var cs_spsolve = load(require('./cs_spsolve'));

  var SparseMatrix = type.SparseMatrix;

  /**
   * Computes the numeric LU factorization of the sparse matrix A. Implements a Left-looking LU factorization
   * algorithm that computes L and U one column at a tume. At the kth step, it access columns 1 to k-1 of L 
   * and column k of A. Given the fill-reducing column ordering q (see parameter s) computes L, U and pinv so
   * L * U = A(p, q), where p is the inverse of pinv.
   *
   * @param {Matrix}  m               The A Matrix to factorize
   * @param {Object}  s               The symbolic analysis from cs_sqr(). Provides the fill-reducing 
   *                                  column ordering q
   * @param {Number}  tol             Partial pivoting threshold (1 for partial pivoting)
   *
   * @return {Number}                 The numeric LU factorization of A or null
   *
   * Reference: http://faculty.cse.tamu.edu/davis/publications.html
   */
  var cs_lu = function (m, s, tol) {
    // validate input
    if (!m)
      return null;
    // m arrays
    var size = m._size;
    // columns
    var n = size[1];
    // symbolic analysis result
    var q;
    var lnz = 100;
    var unz = 100;
    // update symbolic analysis parameters
    if (s) {
      q = s.q;
      lnz = s.lnz || lnz;
      unz = s.unz || unz;
    }
    // L arrays
    var lvalues = []; // (lnz)
    var lindex = []; // (lnz);
    var lptr = []; // (n + 1);
    // L
    var L = new SparseMatrix({
      values: lvalues,
      index: lindex,
      ptr: lptr,
      size: [n, n]
    });
    // U arrays
    var uvalues = []; // (unz);
    var uindex = []; // (unz);
    var uptr = []; // (n + 1);
    // U
    var U = new SparseMatrix({
      values: uvalues,
      index: uindex,
      ptr: uptr,
      size: [n, n]
    });
    // inverse of permutation vector
    var pinv = []; // (n);
    // vars 
    var i, p;
    // allocate arrays
    var x = []; // (n);
    var xi = []; // (2 * n);
    // initialize variables
    for (i = 0; i < n; i++) {
      // clear workspace
      x[i] = 0;
      // no rows pivotal yet
      pinv[i] = -1;
      // no cols of L yet
      lptr[i + 1] = 0;
    }
    // reset number of nonzero elements in L and U
    lnz = 0;
    unz = 0;
    // compute L(:,k) and U(:,k)
    for (var k = 0; k < n; k++) {
      // update ptr
      lptr[k] = lnz;
      uptr[k] = unz;
      // apply column permutations if needed
      var col = q ? q[k] : k;
      // solve triangular system, x = L\A(:,col)
      var top = cs_spsolve(L, m, col, xi, x, pinv, 1);
      // find pivot
      var ipiv = -1;
      var a = -1;
      // loop xi[] from top -> n
      for (p = top; p < n; p++) {
        // x[i] is nonzero
        i = xi[p];
        // check row i is not yet pivotal
        if (pinv[i] < 0) {
          // absolute value of x[i]          
          var xabs = abs(x[i]);
          // check absoulte value is greater than pivot value
          if (larger(xabs, a)) {
            // largest pivot candidate so far
            a = xabs;
            ipiv = i;
          }
        }
        else {
          // x(i) is the entry U(pinv[i],k)
          uindex[unz] = pinv[i];
          uvalues[unz++] = x[i];
        }
      }
      // validate we found a valid pivot
      if (ipiv == -1 || a <= 0) 
        return null;
      // update actual pivot column, give preference to diagonal value
      if (pinv[col] < 0 && largerEq(abs(x[col]), multiply(a, tol)))
        ipiv = col;
      // the chosen pivot
      var pivot = x[ipiv];
      // last entry in U(:,k) is U(k,k)
      uindex[unz] = k;
      uvalues[unz++] = pivot;
      // ipiv is the kth pivot row
      pinv[ipiv] = k;
      // first entry in L(:,k) is L(k,k) = 1
      lindex[lnz] = ipiv;
      lvalues[lnz++] = 1;
      // L(k+1:n,k) = x / pivot      
      for (p = top; p < n; p++) {
        // row
        i = xi[p];
        // check x(i) is an entry in L(:,k)
        if (pinv[i] < 0) {
          // save unpermuted row in L
          lindex[lnz] = i;
          // scale pivot column
          lvalues[lnz++] = divideScalar(x[i], pivot);
        }
        // x[0..n-1] = 0 for next k
        x[i] = 0;
      }
    }
    // update ptr
    lptr[n] = lnz;
    uptr[n] = unz;
    // fix row indices of L for final pinv
    for (p = 0; p < lnz; p++) 
      lindex[p] = pinv[lindex[p]];
    // trim arrays
    lvalues.splice(lnz, lvalues.length - lnz);
    lindex.splice(lnz, lindex.length - lnz);
    uvalues.splice(unz, uvalues.length - unz);
    uindex.splice(unz, uindex.length - unz);    
    // return LU factor
    return {
      L: L,
      U: U,
      pinv: pinv
    };
  };

  return cs_lu;
}

exports.name = 'cs_lu';
exports.path = 'sparse';
exports.factory = factory;

},{"../../arithmetic/abs":254,"../../arithmetic/divideScalar":261,"../../arithmetic/multiply":275,"../../relational/larger":354,"../../relational/largerEq":355,"./cs_spsolve":250}],245:[function(require,module,exports){
'use strict';

function factory (type, config, load) {

  var cs_flip = load(require('./cs_flip'));

  /**
   * Marks the node at w[j]
   *
   * @param {Array}   w               The array
   * @param {Number}  j               The array index
   *
   * Reference: http://faculty.cse.tamu.edu/davis/publications.html
   */
  var cs_mark = function (w, j) {
    // mark w[j]
    w[j] = cs_flip(w [j]);
  };

  return cs_mark;
}

exports.name = 'cs_mark';
exports.path = 'sparse';
exports.factory = factory;

},{"./cs_flip":241}],246:[function(require,module,exports){
'use strict';

function factory () {

  /**
   * Checks if the node at w[j] is marked
   *
   * @param {Array}   w               The array
   * @param {Number}  j               The array index
   *
   * Reference: http://faculty.cse.tamu.edu/davis/publications.html
   */
  var cs_marked = function (w, j) {
    // check node is marked
    return w[j] < 0;
  };

  return cs_marked;
}

exports.name = 'cs_marked';
exports.path = 'sparse';
exports.factory = factory;

},{}],247:[function(require,module,exports){
'use strict';

function factory (type) {

  var SparseMatrix = type.SparseMatrix;

  /**
   * Permutes a sparse matrix C = P * A * Q
   *
   * @param {Matrix}  a               The Matrix A
   * @param {Array}   pinv            The row permutation vector
   * @param {Array}   q               The column permutation vector
   * @param {boolean} values          Create a pattern matrix (false), values and pattern otherwise
   *
   * @return {Matrix}                 C = P * A * Q, null on error
   *
   * Reference: http://faculty.cse.tamu.edu/davis/publications.html
   */
  var cs_permute = function (a, pinv, q, values) {
    // a arrays
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var adt = a._datatype;
    // rows & columns
    var m = asize[0];
    var n = asize[1];
    // c arrays
    var cvalues = values && a._values ? [] : null;
    var cindex = []; // (aptr[n]);
    var cptr = []; // (n + 1);
    // initialize vars
    var nz = 0;
    // loop columns    
    for (var k = 0; k < n; k++) {
      // column k of C is column q[k] of A
      cptr[k] = nz;
      // apply column permutation
      var j = q ? (q[k]) : k;
      // loop values in column j of A
      for (var t0 = aptr[j], t1 = aptr[j + 1], t = t0; t < t1; t++) {
        // row i of A is row pinv[i] of C
        var r = pinv ? pinv[aindex[t]] : aindex[t];
        // index
        cindex[nz] = r;
        // check we need to populate values
        if (cvalues) 
          cvalues[nz] = avalues[t];
        // increment number of nonzero elements
        nz++;
      }
    }
    // finalize the last column of C
    cptr[n] = nz;
    // return C matrix
    return new SparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [m, n],
      datatype: adt
    });
  };

  return cs_permute;
}

exports.name = 'cs_permute';
exports.path = 'sparse';
exports.factory = factory;

},{}],248:[function(require,module,exports){
'use strict';

function factory (type, config, load) {

  var cs_tdfs = load(require('./cs_tdfs'));

  /**
   * Post order a tree of forest
   *
   * @param {Array}   parent          The tree or forest
   * @param {Number}  n               Number of columns
   *
   * Reference: http://faculty.cse.tamu.edu/davis/publications.html
   */
  var cs_post = function (parent, n) {
    // check inputs
    if (!parent) 
      return null;
    // vars 
    var k = 0;
    var j;
    // allocate result
    var post = []; // (n);
    // workspace, head: first n entries, next: next n entries, stack: last n entries
    var w = []; // (3 * n);
    var head = 0; 
    var next = n; 
    var stack = 2 * n;
    // initialize workspace
    for (j = 0; j < n; j++) {
      // empty linked lists
      w[head + j] = -1;
    }
    // traverse nodes in reverse order
    for (j = n-1; j >= 0; j--) {
      // check j is a root
      if (parent[j] == -1) 
        continue;
      // add j to list of its parent
      w[next + j] = w[head + parent[j]];
      w[head + parent[j]] = j;
    }
    // loop nodes
    for (j = 0; j < n; j++) {
      // skip j if it is not a root
      if (parent[j] != -1) 
        continue;
      // depth-first search
      k = cs_tdfs(j, k, w, head, next, post, stack);
    }
    return post;
  };

  return cs_post;
}

exports.name = 'cs_post';
exports.path = 'sparse';
exports.factory = factory;

},{"./cs_tdfs":252}],249:[function(require,module,exports){
'use strict';

function factory (type, config, load) {

  var cs_dfs = load(require('./cs_dfs'));
  var cs_marked = load(require('./cs_marked'));
  var cs_mark = load(require('./cs_mark'));

  /**
   * The cs_reach function computes X = Reach(B), where B is the nonzero pattern of the n-by-1 
   * sparse column of vector b. The function returns the set of nodes reachable from any node in B. The
   * nonzero pattern xi of the solution x to the sparse linear system Lx=b is given by X=Reach(B).
   *
   * @param {Matrix}  g               The G matrix
   * @param {Matrix}  b               The B matrix
   * @param {Number}  k               The kth column in B
   * @param {Array}   xi              The nonzero pattern xi[top] .. xi[n - 1], an array of size = 2 * n
   *                                  The first n entries is the nonzero pattern, the last n entries is the stack
   * @param {Array}   pinv            The inverse row permutation vector
   *
   * @return {Number}                 The index for the nonzero pattern
   *
   * Reference: http://faculty.cse.tamu.edu/davis/publications.html
   */
  var cs_reach = function (g, b, k, xi, pinv) {
    // g arrays
    var gptr = g._ptr;
    var gsize = g._size;
    // b arrays
    var bindex = b._index;
    var bptr = b._ptr;
    // columns
    var n = gsize[1];
    // vars
    var p, p0, p1;
    // initialize top
    var top = n;
    // loop column indeces in B
    for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {
      // node i
      var i = bindex[p];
      // check node i is marked
      if (!cs_marked(gptr, i)) {
        // start a dfs at unmarked node i
        top = cs_dfs(i, g, top, xi, pinv);
      }
    }
    // loop columns from top -> n - 1
    for (p = top; p < n; p++) {
      // restore G
      cs_mark(gptr, xi[p]);
    }
    return top;
  };

  return cs_reach;
}

exports.name = 'cs_reach';
exports.path = 'sparse';
exports.factory = factory;

},{"./cs_dfs":238,"./cs_mark":245,"./cs_marked":246}],250:[function(require,module,exports){
'use strict';

function factory (type, config, load) {

  var divideScalar = load(require('../../arithmetic/divideScalar'));
  var multiply = load(require('../../arithmetic/multiply'));
  var subtract = load(require('../../arithmetic/subtract'));

  var cs_reach = load(require('./cs_reach'));

  /**
   * The function cs_spsolve() computes the solution to G * x = bk, where bk is the
   * kth column of B. When lo is true, the function assumes G = L is lower triangular with the
   * diagonal entry as the first entry in each column. When lo is true, the function assumes G = U 
   * is upper triangular with the diagonal entry as the last entry in each column.
   *
   * @param {Matrix}  g               The G matrix
   * @param {Matrix}  b               The B matrix
   * @param {Number}  k               The kth column in B
   * @param {Array}   xi              The nonzero pattern xi[top] .. xi[n - 1], an array of size = 2 * n
   *                                  The first n entries is the nonzero pattern, the last n entries is the stack
   * @param {Array}   x               The soluton to the linear system G * x = b
   * @param {Array}   pinv            The inverse row permutation vector, must be null for L * x = b
   * @param {boolean} lo              The lower (true) upper triangular (false) flag
   *
   * @return {Number}                 The index for the nonzero pattern
   *
   * Reference: http://faculty.cse.tamu.edu/davis/publications.html
   */
  var cs_spsolve = function (g, b, k, xi, x, pinv, lo) {
    // g arrays
    var gvalues = g._values;
    var gindex = g._index;
    var gptr = g._ptr;
    var gsize = g._size;
    // columns
    var n = gsize[1];
    // b arrays
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    // vars
    var p, p0, p1, q;
    // xi[top..n-1] = cs_reach(B(:,k))
    var top = cs_reach(g, b, k, xi, pinv);
    // clear x
    for (p = top; p < n; p++) 
      x[xi[p]] = 0;
    // scatter b
    for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) 
      x[bindex[p]] = bvalues[p];
    // loop columns
    for (var px = top; px < n; px++) {
      // x array index for px
      var j = xi[px];
      // apply permutation vector (U x = b), j maps to column J of G
      var J = pinv ? pinv[j] : j;
      // check column J is empty
      if (J < 0)
        continue;
      // column value indeces in G, p0 <= p < p1
      p0 = gptr[J];
      p1 = gptr[J + 1];
      // x(j) /= G(j,j)
      x[j] = divideScalar(x[j], gvalues[lo ? p0 : (p1 - 1)]);
      // first entry L(j,j)
      p = lo ? (p0 + 1) : p0;
      q = lo ? (p1) : (p1 - 1);
      // loop
      for ( ; p < q ; p++) {
        // row
        var i = gindex[p];
        // x(i) -= G(i,j) * x(j)
        x[i] = subtract(x[i], multiply(gvalues[p], x[j]));
      }
    }
    // return top of stack
    return top;
  };
  
  return cs_spsolve;
}

exports.name = 'cs_spsolve';
exports.path = 'sparse';
exports.factory = factory;

},{"../../arithmetic/divideScalar":261,"../../arithmetic/multiply":275,"../../arithmetic/subtract":284,"./cs_reach":249}],251:[function(require,module,exports){
'use strict';

function factory (type, config, load) {

  var cs_amd = load(require('./cs_amd'));
  var cs_permute = load(require('./cs_permute'));
  var cs_etree = load(require('./cs_etree'));
  var cs_post = load(require('./cs_post'));
  var cs_counts = load(require('./cs_counts'));

  /**
   * Symbolic ordering and analysis for QR and LU decompositions.
   *
   * @param {Number}  order           The ordering strategy (see cs_amd for more details)
   * @param {Matrix}  a               The A matrix
   * @param {boolean} qr              Symbolic ordering and analysis for QR decomposition (true) or
   *                                  symbolic ordering and analysis for LU decomposition (false)
   *
   * @return {Object}                 The Symbolic ordering and analysis for matrix A
   *
   * Reference: http://faculty.cse.tamu.edu/davis/publications.html
   */
  var cs_sqr = function (order, a, qr) {
    // a arrays
    var aptr = a._ptr;
    var asize = a._size;
    // columns
    var n = asize[1];
    // vars
    var k;
    // symbolic analysis result
    var s = {};    
    // fill-reducing ordering
    s.q = cs_amd(order, a);
    // validate results
    if (order && !s.q) 
      return null;
    // QR symbolic analysis
    if (qr) {
      // apply permutations if needed
      var c = order ? cs_permute(a, null, s.q, 0) : a;
      // etree of C'*C, where C=A(:,q)
      s.parent = cs_etree(c, 1);
      // post order elimination tree
      var post = cs_post (s.parent, n);
      // col counts chol(C'*C)
      s.cp = cs_counts(c, s.parent, post, 1);
      // check we have everything needed to calculate number of nonzero elements
      if (c && s.parent && s.cp && _vcount(c, s)) {
        // calculate number of nonzero elements
        for (s.unz = 0, k = 0; k < n; k++) 
          s.unz += s.cp[k];
      }
    }
    else {
      // for LU factorization only, guess nnz(L) and nnz(U)
      s.unz = 4 * (aptr[n]) + n;
      s.lnz = s.unz;
    }
    // return result S
    return s;
  };
  
  /**
   * Compute nnz(V) = s.lnz, s.pinv, s.leftmost, s.m2 from A and s.parent
   */
  var _vcount = function (a, s) {
    // a arrays
    var aptr = a._ptr;
    var aindex = a._index;
    var asize = a._size;
    // rows & columns
    var m = asize[0];
    var n = asize[1];
    // initialize s arrays
    s.pinv = []; // (m + n);
    s.leftmost = []; // (m);
    // vars
    var parent = s.parent;
    var pinv = s.pinv;
    var leftmost = s.leftmost;
    // workspace, next: first m entries, head: next n entries, tail: next n entries, nque: next n entries
    var w = []; // (m + 3 * n);
    var next = 0;
    var head = m;
    var tail = m + n;
    var nque = m + 2 * n;
    // vars
    var i, k, p, p0, p1;
    // initialize w
    for (k = 0; k < n; k++) {
      // queue k is empty
      w[head + k] = -1;
      w[tail + k] = -1;
      w[nque + k] = 0;
    }
    // initialize row arrays
    for (i = 0; i < m; i++) 
      leftmost[i] = -1;
    // loop columns backwards    
    for (k = n - 1; k >= 0; k--) {
      // values & index for column k
      for (p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {
        // leftmost[i] = min(find(A(i,:)))
        leftmost[aindex[p]] = k;
      }
    }
    // scan rows in reverse order
    for (i = m - 1; i >= 0; i--) {
      // row i is not yet ordered
      pinv[i] = -1;
      k = leftmost[i];
      // check row i is empty
      if (k == -1) 
        continue;
      // first row in queue k
      if (w[nque + k]++ === 0) 
        w[tail + k] = i;
      // put i at head of queue k
      w[next + i] = w[head + k];
      w[head + k] = i;
    }
    s.lnz = 0;
    s.m2 = m;
    // find row permutation and nnz(V)
    for (k = 0; k < n; k++) {
      // remove row i from queue k
      i = w[head + k];
      // count V(k,k) as nonzero
      s.lnz++;
      // add a fictitious row
      if (i < 0) 
        i = s.m2++;
      // associate row i with V(:,k)
      pinv[i] = k;
      // skip if V(k+1:m,k) is empty
      if (--nque[k] <= 0) 
        continue;
      // nque[k] is nnz (V(k+1:m,k))
      s.lnz += w[nque + k];
      // move all rows to parent of k
      var pa = parent[k];
      if (pa != -1) {
        if (w[nque + pa] === 0) 
          w[tail + pa] = w[tail + k];
        w[next + w[tail + k]] = w[head + pa];
        w[head + pa] = w[next + i];
        w[nque + pa] += w[nque + k];
      }
    }
    for (i = 0; i < m; i++) {
      if (pinv[i] < 0) 
        pinv[i] = k++;
    }
    return true;
  };

  return cs_sqr;
}

exports.name = 'cs_sqr';
exports.path = 'sparse';
exports.factory = factory;

},{"./cs_amd":236,"./cs_counts":237,"./cs_etree":239,"./cs_permute":247,"./cs_post":248}],252:[function(require,module,exports){
'use strict';

function factory () {

  /**
   * Depth-first search and postorder of a tree rooted at node j
   *
   * @param {Number}  j               The tree node
   * @param {Number}  k               
   * @param {Array}   w               The workspace array
   * @param {Number}  head            The index offset within the workspace for the head array
   * @param {Number}  next            The index offset within the workspace for the next array
   * @param {Array}   post            The post ordering array
   * @param {Number}  stack           The index offset within the workspace for the stack array
   *
   * Reference: http://faculty.cse.tamu.edu/davis/publications.html
   */
  var cs_tdfs = function (j, k, w, head, next, post, stack) {
    // variables
    var top = 0;
    // place j on the stack
    w[stack] = j;
    // while (stack is not empty) 
    while (top >= 0) {
      // p = top of stack
      var p = w[stack + top];
      // i = youngest child of p
      var i = w[head + p];
      if (i == -1) {
        // p has no unordered children left
        top--;
        // node p is the kth postordered node
        post[k++] = p;
      }
      else {
        // remove i from children of p
        w[head + p] = w[next + i];
        // increment top
        ++top;
        // start dfs on child node i
        w[stack + top] = i;
      }
    }
    return k;
  };

  return cs_tdfs;
}

exports.name = 'cs_tdfs';
exports.path = 'sparse';
exports.factory = factory;

},{}],253:[function(require,module,exports){
'use strict';

function factory (type, config, load) {

  var cs_flip = load(require('./cs_flip'));
  
  /**
   * Flips the value if it is negative of returns the same value otherwise.
   *
   * @param {Number}  i               The value to flip
   *
   * Reference: http://faculty.cse.tamu.edu/davis/publications.html
   */
  var cs_unflip = function (i) {
    // flip the value if it is negative
    return i < 0 ? cs_flip(i) : i;
  };

  return cs_unflip;
}

exports.name = 'cs_unflip';
exports.path = 'sparse';
exports.factory = factory;

},{"./cs_flip":241}],254:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Calculate the absolute value of a number. For matrices, the function is
   * evaluated element wise.
   *
   * Syntax:
   *
   *    math.abs(x)
   *
   * Examples:
   *
   *    math.abs(3.5);                // returns number 3.5
   *    math.abs(-4.2);               // returns number 4.2
   *
   *    math.abs([3, -5, -1, 0, 2]);  // returns Array [3, 5, 1, 0, 2]
   *
   * See also:
   *
   *    sign
   *
   * @param  {number | BigNumber | Fraction | Complex | Array | Matrix | Unit} x
   *            A number or matrix for which to get the absolute value
   * @return {number | BigNumber | Fraction | Complex | Array | Matrix | Unit}
   *            Absolute value of `x`
   */
  var abs = typed('abs', {
    'number': Math.abs,

    'Complex': function (x) {
      return x.abs();
    },

    'BigNumber': function (x) {
      return x.abs();
    },

    'Fraction': function (x) {
      return x.abs();
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since abs(0) = 0
      return deepMap(x, abs, true);
    },

    'Unit': function(x) {
      return x.abs();
    }
  });

  abs.toTex = '\\left|${args[0]}\\right|';

  return abs;
}

exports.name = 'abs';
exports.factory = factory;

},{"../../utils/collection/deepMap":475}],255:[function(require,module,exports){
'use strict';

var extend = require('../../utils/object').extend;

function factory (type, config, load, typed) {

  var matrix = load(require('../../type/matrix/function/matrix'));
  var addScalar = load(require('./addScalar'));
  var latex = require('../../utils/latex.js');
  
  var algorithm01 = load(require('../../type/matrix/utils/algorithm01'));
  var algorithm04 = load(require('../../type/matrix/utils/algorithm04'));
  var algorithm10 = load(require('../../type/matrix/utils/algorithm10'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

  /**
   * Add two values, `x + y`.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.add(x, y)
   *
   * Examples:
   *
   *    math.add(2, 3);               // returns number 5
   *
   *    var a = math.complex(2, 3);
   *    var b = math.complex(-4, 1);
   *    math.add(a, b);               // returns Complex -2 + 4i
   *
   *    math.add([1, 2, 3], 4);       // returns Array [5, 6, 7]
   *
   *    var c = math.unit('5 cm');
   *    var d = math.unit('2.1 mm');
   *    math.add(c, d);               // returns Unit 52.1 mm
   *
   *    math.add("2.3", "4");         // returns number 6.3
   *
   * See also:
   *
   *    subtract
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x First value to add
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Second value to add
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} Sum of `x` and `y`
   */
  var add = typed('add', extend({
    // we extend the signatures of addScalar with signatures dealing with matrices

    'Matrix, Matrix': function (x, y) {
      // result
      var c;
      
      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse + sparse
              c = algorithm04(x, y, addScalar);
              break;
            default:
              // sparse + dense
              c = algorithm01(y, x, addScalar, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense + sparse
              c = algorithm01(x, y, addScalar, false);
              break;
            default:
              // dense + dense
              c = algorithm13(x, y, addScalar);
              break;
          }
          break;
      }
      return c;
    },
    
    'Array, Array': function (x, y) {
      // use matrix implementation
      return add(matrix(x), matrix(y)).valueOf();
    },
    
    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return add(matrix(x), y);
    },
    
    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return add(x, matrix(y));
    },
    
    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm10(x, y, addScalar, false);
          break;
        default:
          c = algorithm14(x, y, addScalar, false);
          break;
      }
      return c;
    },
    
    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm10(y, x, addScalar, true);
          break;
        default:
          c = algorithm14(y, x, addScalar, true);
          break;
      }
      return c;
    },
    
    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, addScalar, false).valueOf();
    },

    'any, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, addScalar, true).valueOf();
    }
  }, addScalar.signatures));

  add.toTex = '\\left(${args[0]}' + latex.operators['add'] + '${args[1]}\\right)';
  
  return add;
}

exports.name = 'add';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../type/matrix/utils/algorithm01":438,"../../type/matrix/utils/algorithm04":441,"../../type/matrix/utils/algorithm10":447,"../../type/matrix/utils/algorithm13":450,"../../type/matrix/utils/algorithm14":451,"../../utils/latex.js":482,"../../utils/object":484,"./addScalar":256}],256:[function(require,module,exports){
'use strict';

function factory(type, config, load, typed) {

  /**
   * Add two scalar values, `x + y`.
   * This function is meant for internal use: it is used by the public function
   * `add`
   *
   * This function does not support collections (Array or Matrix), and does
   * not validate the number of of inputs.
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit} x   First value to add
   * @param  {number | BigNumber | Fraction | Complex} y          Second value to add
   * @return {number | BigNumber | Fraction | Complex | Unit}                      Sum of `x` and `y`
   * @private
   */
  var add = typed('add', {

    'number, number': function (x, y) {
      return x + y;
    },

    'Complex, Complex': function (x, y) {
      return x.add(y);
    },

    'BigNumber, BigNumber': function (x, y) {
      return x.plus(y);
    },

    'Fraction, Fraction': function (x, y) {
      return x.add(y);
    },

    'Unit, Unit': function (x, y) {
      if (x.value == null) throw new Error('Parameter x contains a unit with undefined value');
      if (y.value == null) throw new Error('Parameter y contains a unit with undefined value');
      if (!x.equalBase(y)) throw new Error('Units do not match');

      var res = x.clone();
      res.value = add(res.value, y.value);
      res.fixPrefix = false;
      return res;
    }
  });

  return add;
}

exports.factory = factory;

},{}],257:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  var unaryMinus = load(require('./unaryMinus'));
  var isNegative = load(require('../utils/isNegative'));
  var matrix = load(require('../../type/matrix/function/matrix'));

  /**
   * Calculate the cubic root of a value.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.cbrt(x)
   *    math.cbrt(x, allRoots)
   *
   * Examples:
   *
   *    math.cbrt(27);                  // returns 3
   *    math.cube(3);                   // returns 27
   *    math.cbrt(-64);                 // returns -4
   *    math.cbrt(math.unit('27 m^3')); // returns Unit 3 m
   *    math.cbrt([27, 64, 125]);       // returns [3, 4, 5]
   *
   *    var x = math.complex('8i');
   *    math.cbrt(x);                   // returns Complex 1.7320508075689 + i
   *    math.cbrt(x, true);             // returns Matrix [
   *                                    //    1.7320508075689 + i
   *                                    //   -1.7320508075689 + i
   *                                    //   -2i
   *                                    // ]
   *
   * See also:
   *
   *    square, sqrt, cube
   *
   * @param {number | BigNumber | Complex | Unit | Array | Matrix} x
   *            Value for which to calculate the cubic root.
   * @param {boolean} [allRoots]  Optional, false by default. Only applicable
   *            when `x` is a number or complex number. If true, all complex
   *            roots are returned, if false (default) the principal root is
   *            returned.
   * @return {number | BigNumber | Complex | Unit | Array | Matrix}
   *            Returns the cubic root of `x`
   */
  var cbrt = typed('cbrt', {
    'number': _cbrtNumber,
    // note: signature 'number, boolean' is also supported,
    //       created by typed as it knows how to convert number to Complex

    'Complex': _cbrtComplex,

    'Complex, boolean': _cbrtComplex,

    'BigNumber': function (x) {
      return x.cbrt();
    },

    'Unit': _cbrtUnit,

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since cbrt(0) = 0
      return deepMap(x, cbrt, true);
    }
  });

  /**
   * Calculate cbrt for a number
   *
   * Code from es6-shim.js:
   *   https://github.com/paulmillr/es6-shim/blob/master/es6-shim.js#L1564-L1577
   *
   * @param {number} x
   * @returns {number | Complex} Returns the cubic root of x
   * @private
   */
  function _cbrtNumber(x) {
    if (x === 0) {
      return x;
    }

    var negate = x < 0;
    var result;
    if (negate) {
      x = -x;
    }

    if (isFinite(x)) {
      result = Math.exp(Math.log(x) / 3);
      // from http://en.wikipedia.org/wiki/Cube_root#Numerical_methods
      result = (x / (result * result) + (2 * result)) / 3;
    } else {
      result = x;
    }

    return negate ? -result : result;
  }

  /**
   * Calculate the cubic root for a complex number
   * @param {Complex} x
   * @param {boolean} [allRoots]   If true, the function will return an array
   *                               with all three roots. If false or undefined,
   *                               the principal root is returned.
   * @returns {Complex | Array.<Complex> | Matrix.<Complex>} Returns the cubic root(s) of x
   * @private
   */
  function _cbrtComplex(x, allRoots) {
    // https://www.wikiwand.com/en/Cube_root#/Complex_numbers

    var arg_3 = x.arg() / 3;
    var abs = x.abs();

    // principal root:
    var principal = new type.Complex(_cbrtNumber(abs), 0).mul(
        new type.Complex(0, arg_3).exp());

    if (allRoots) {
      var all = [
          principal,
          new type.Complex(_cbrtNumber(abs), 0).mul(
            new type.Complex(0, arg_3 + Math.PI * 2 / 3).exp()),
          new type.Complex(_cbrtNumber(abs), 0).mul(
            new type.Complex(0, arg_3 - Math.PI * 2 / 3).exp())
      ];

      return (config.matrix === 'Array') ? all : matrix(all);
    }
    else {
      return principal;
    }
  }

  /**
   * Calculate the cubic root for a Unit
   * @param {Unit} x
   * @return {Unit} Returns the cubic root of x
   * @private
   */
  function _cbrtUnit(x) {
    if(x.value && x.value.isComplex) {
      var result = x.clone();
      result.value = 1.0;
      result = result.pow(1.0/3);           // Compute the units
      result.value = _cbrtComplex(x.value); // Compute the value
      return result;
    }
    else {
      var negate = isNegative(x.value);
      if (negate) {
        x.value = unaryMinus(x.value);
      }

      // TODO: create a helper function for this
      var third;
      if (x.value && x.value.isBigNumber) {
        third = new type.BigNumber(1).div(3);
      }
      else if (x.value && x.value.isFraction) {
        third = new type.Fraction(1, 3);
      }
      else {
        third = 1/3;
      }

      var result = x.pow(third);

      if (negate) {
        result.value = unaryMinus(result.value);
      }

      return result;
    }
  }

  cbrt.toTex = '\\sqrt[3]{${args[0]}}';

  return cbrt;
}

exports.name = 'cbrt';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../utils/collection/deepMap":475,"../utils/isNegative":404,"./unaryMinus":285}],258:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Round a value towards plus infinity
   * If `x` is complex, both real and imaginary part are rounded towards plus infinity.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.ceil(x)
   *
   * Examples:
   *
   *    math.ceil(3.2);               // returns number 4
   *    math.ceil(3.8);               // returns number 4
   *    math.ceil(-4.2);              // returns number -4
   *    math.ceil(-4.7);              // returns number -4
   *
   *    var c = math.complex(3.2, -2.7);
   *    math.ceil(c);                 // returns Complex 4 - 2i
   *
   *    math.ceil([3.2, 3.8, -4.7]);  // returns Array [4, 4, -4]
   *
   * See also:
   *
   *    floor, fix, round
   *
   * @param  {number | BigNumber | Fraction | Complex | Array | Matrix} x  Number to be rounded
   * @return {number | BigNumber | Fraction | Complex | Array | Matrix} Rounded value
   */
  var ceil = typed('ceil', {
    'number': Math.ceil,

    'Complex': function (x) {
      return x.ceil();
    },

    'BigNumber': function (x) {
      return x.ceil();
    },

    'Fraction': function (x) {
      return x.ceil();
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since ceil(0) = 0
      return deepMap(x, ceil, true);
    }
  });

  ceil.toTex = '\\left\\lceil${args[0]}\\right\\rceil';

  return ceil;
}

exports.name = 'ceil';
exports.factory = factory;

},{"../../utils/collection/deepMap":475}],259:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {

  /**
   * Compute the cube of a value, `x * x * x`.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.cube(x)
   *
   * Examples:
   *
   *    math.cube(2);            // returns number 8
   *    math.pow(2, 3);          // returns number 8
   *    math.cube(4);            // returns number 64
   *    4 * 4 * 4;               // returns number 64
   *
   *    math.cube([1, 2, 3, 4]); // returns Array [1, 8, 27, 64]
   *
   * See also:
   *
   *    multiply, square, pow, cbrt
   *
   * @param  {number | BigNumber | Fraction | Complex | Array | Matrix | Unit} x  Number for which to calculate the cube
   * @return {number | BigNumber | Fraction | Complex | Array | Matrix | Unit} Cube of x
   */
  var cube = typed('cube', {
    'number': function (x) {
      return x * x * x;
    },

    'Complex': function (x) {
      return x.mul(x).mul(x); // Is faster than pow(x, 3)
    },

    'BigNumber': function (x) {
      return x.times(x).times(x);
    },

    'Fraction': function (x) {
      return x.pow(3); // Is faster than mul()mul()mul()
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since cube(0) = 0
      return deepMap(x, cube, true);
    },

    'Unit': function(x) {
      return x.pow(3);
    }
  });

  cube.toTex = '\\left(${args[0]}\\right)^3';

  return cube;
}

exports.name = 'cube';
exports.factory = factory;

},{"../../utils/collection/deepMap":475}],260:[function(require,module,exports){
'use strict';

var extend = require('../../utils/object').extend;

function factory (type, config, load, typed) {

  var divideScalar = load(require('./divideScalar'));
  var multiply     = load(require('./multiply'));
  var inv          = load(require('../matrix/inv'));
  var matrix       = load(require('../../type/matrix/function/matrix'));

  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));
  
  /**
   * Divide two values, `x / y`.
   * To divide matrices, `x` is multiplied with the inverse of `y`: `x * inv(y)`.
   *
   * Syntax:
   *
   *    math.divide(x, y)
   *
   * Examples:
   *
   *    math.divide(2, 3);            // returns number 0.6666666666666666
   *
   *    var a = math.complex(5, 14);
   *    var b = math.complex(4, 1);
   *    math.divide(a, b);            // returns Complex 2 + 3i
   *
   *    var c = [[7, -6], [13, -4]];
   *    var d = [[1, 2], [4, 3]];
   *    math.divide(c, d);            // returns Array [[-9, 4], [-11, 6]]
   *
   *    var e = math.unit('18 km');
   *    math.divide(e, 4.5);          // returns Unit 4 km
   *
   * See also:
   *
   *    multiply
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x   Numerator
   * @param  {number | BigNumber | Fraction | Complex | Array | Matrix} y          Denominator
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}                      Quotient, `x / y`
   */
  var divide = typed('divide', extend({
    // we extend the signatures of divideScalar with signatures dealing with matrices

    'Array | Matrix, Array | Matrix': function (x, y) {
      // TODO: implement matrix right division using pseudo inverse
      // http://www.mathworks.nl/help/matlab/ref/mrdivide.html
      // http://www.gnu.org/software/octave/doc/interpreter/Arithmetic-Ops.html
      // http://stackoverflow.com/questions/12263932/how-does-gnu-octave-matrix-division-work-getting-unexpected-behaviour
      return multiply(x, inv(y));
    },

    'Matrix, any': function (x, y) {
      // result
      var c;

      // process storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm11(x, y, divideScalar, false);
          break;
        case 'dense':
          c = algorithm14(x, y, divideScalar, false);
          break;
      }
      return c;
    },
    
    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, divideScalar, false).valueOf();
    },

    'any, Array | Matrix': function (x, y) {
      return multiply(x, inv(y));
    }
  }, divideScalar.signatures));

  divide.toTex = '\\frac{${args[0]}}{${args[1]}}';

  return divide;
}

exports.name = 'divide';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../type/matrix/utils/algorithm11":448,"../../type/matrix/utils/algorithm14":451,"../../utils/object":484,"../matrix/inv":325,"./divideScalar":261,"./multiply":275}],261:[function(require,module,exports){
'use strict';

function factory(type, config, load, typed) {
  var multiplyScalar = load(require('./multiplyScalar'));

  /**
   * Divide two scalar values, `x / y`.
   * This function is meant for internal use: it is used by the public functions
   * `divide` and `inv`.
   *
   * This function does not support collections (Array or Matrix), and does
   * not validate the number of of inputs.
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit} x   Numerator
   * @param  {number | BigNumber | Fraction | Complex} y          Denominator
   * @return {number | BigNumber | Fraction | Complex | Unit}                      Quotient, `x / y`
   * @private
   */
  var divideScalar = typed('divide', {
    'number, number': function (x, y) {
      return x / y;
    },

    'Complex, Complex': function (x, y) {
      return x.div(y);
    },

    'BigNumber, BigNumber': function (x, y) {
      return x.div(y);
    },

    'Fraction, Fraction': function (x, y) {
      return x.div(y);
    },

    'Unit, number | Fraction | BigNumber': function (x, y) {
      var res = x.clone();
      // TODO: move the divide function to Unit.js, it uses internals of Unit
      res.value = divideScalar(((res.value === null) ? res._normalize(1) : res.value), y);
      return res;
    },

    'number | Fraction | BigNumber, Unit': function (x, y) {
      var res = y.pow(-1);
      // TODO: move the divide function to Unit.js, it uses internals of Unit
      res.value = multiplyScalar(((res.value === null) ? res._normalize(1) : res.value), x);
      return res;
    },

    'Unit, Unit': function (x, y) {
      return x.divide(y);
    }

  });

  return divideScalar;
}

exports.factory = factory;

},{"./multiplyScalar":276}],262:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {

  var matrix = load(require('../../type/matrix/function/matrix'));
  var divideScalar = load(require('./divideScalar'));
  var latex = require('../../utils/latex');
  
  var algorithm02 = load(require('../../type/matrix/utils/algorithm02'));
  var algorithm03 = load(require('../../type/matrix/utils/algorithm03'));
  var algorithm07 = load(require('../../type/matrix/utils/algorithm07'));
  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));
  var algorithm12 = load(require('../../type/matrix/utils/algorithm12'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

  /**
   * Divide two matrices element wise. The function accepts both matrices and
   * scalar values.
   *
   * Syntax:
   *
   *    math.dotDivide(x, y)
   *
   * Examples:
   *
   *    math.dotDivide(2, 4);   // returns 0.5
   *
   *    a = [[9, 5], [6, 1]];
   *    b = [[3, 2], [5, 2]];
   *
   *    math.dotDivide(a, b);   // returns [[3, 2.5], [1.2, 0.5]]
   *    math.divide(a, b);      // returns [[1.75, 0.75], [-1.75, 2.25]]
   *
   * See also:
   *
   *    divide, multiply, dotMultiply
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x Numerator
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Denominator
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}                    Quotient, `x ./ y`
   */
  var dotDivide = typed('dotDivide', {
    
    'any, any': divideScalar,
    
    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse ./ sparse
              c = algorithm07(x, y, divideScalar, false);
              break;
            default:
              // sparse ./ dense
              c = algorithm02(y, x, divideScalar, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense ./ sparse
              c = algorithm03(x, y, divideScalar, false);
              break;
            default:
              // dense ./ dense
              c = algorithm13(x, y, divideScalar);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return dotDivide(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return dotDivide(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return dotDivide(x, matrix(y));
    },

    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm11(x, y, divideScalar, false);
          break;
        default:
          c = algorithm14(x, y, divideScalar, false);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm12(y, x, divideScalar, true);
          break;
        default:
          c = algorithm14(y, x, divideScalar, true);
          break;
      }
      return c;
    },

    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, divideScalar, false).valueOf();
    },

    'any, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, divideScalar, true).valueOf();
    }
  });

  dotDivide.toTex = '\\left(${args[0]}' + latex.operators['dotDivide'] + '${args[1]}\\right)';
  
  return dotDivide;
}

exports.name = 'dotDivide';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../type/matrix/utils/algorithm02":439,"../../type/matrix/utils/algorithm03":440,"../../type/matrix/utils/algorithm07":444,"../../type/matrix/utils/algorithm11":448,"../../type/matrix/utils/algorithm12":449,"../../type/matrix/utils/algorithm13":450,"../../type/matrix/utils/algorithm14":451,"../../utils/latex":482,"./divideScalar":261}],263:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {

  var matrix = load(require('../../type/matrix/function/matrix'));
  var multiplyScalar = load(require('./multiplyScalar'));
  var latex = require('../../utils/latex');

  var algorithm02 = load(require('../../type/matrix/utils/algorithm02'));
  var algorithm09 = load(require('../../type/matrix/utils/algorithm09'));
  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

  /**
   * Multiply two matrices element wise. The function accepts both matrices and
   * scalar values.
   *
   * Syntax:
   *
   *    math.dotMultiply(x, y)
   *
   * Examples:
   *
   *    math.dotMultiply(2, 4); // returns 8
   *
   *    a = [[9, 5], [6, 1]];
   *    b = [[3, 2], [5, 2]];
   *
   *    math.dotMultiply(a, b); // returns [[27, 10], [30, 2]]
   *    math.multiply(a, b);    // returns [[52, 28], [23, 14]]
   *
   * See also:
   *
   *    multiply, divide, dotDivide
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x Left hand value
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Right hand value
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}                    Multiplication of `x` and `y`
   */
  var dotMultiply = typed('dotMultiply', {
    
    'any, any': multiplyScalar,
    
    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse .* sparse
              c = algorithm09(x, y, multiplyScalar, false);
              break;
            default:
              // sparse .* dense
              c = algorithm02(y, x, multiplyScalar, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense .* sparse
              c = algorithm02(x, y, multiplyScalar, false);
              break;
            default:
              // dense .* dense
              c = algorithm13(x, y, multiplyScalar);
              break;
          }
          break;
      }
      return c;
    },
    
    'Array, Array': function (x, y) {
      // use matrix implementation
      return dotMultiply(matrix(x), matrix(y)).valueOf();
    },
    
    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return dotMultiply(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return dotMultiply(x, matrix(y));
    },

    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm11(x, y, multiplyScalar, false);
          break;
        default:
          c = algorithm14(x, y, multiplyScalar, false);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm11(y, x, multiplyScalar, true);
          break;
        default:
          c = algorithm14(y, x, multiplyScalar, true);
          break;
      }
      return c;
    },

    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, multiplyScalar, false).valueOf();
    },

    'any, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, multiplyScalar, true).valueOf();
    }
  });

  dotMultiply.toTex = '\\left(${args[0]}' + latex.operators['dotMultiply'] + '${args[1]}\\right)';
  
  return dotMultiply;
}

exports.name = 'dotMultiply';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../type/matrix/utils/algorithm02":439,"../../type/matrix/utils/algorithm09":446,"../../type/matrix/utils/algorithm11":448,"../../type/matrix/utils/algorithm13":450,"../../type/matrix/utils/algorithm14":451,"../../utils/latex":482,"./multiplyScalar":276}],264:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {

  var matrix = load(require('../../type/matrix/function/matrix'));
  var pow = load(require('./pow'));
  var latex = require('../../utils/latex');

  var algorithm03 = load(require('../../type/matrix/utils/algorithm03'));
  var algorithm07 = load(require('../../type/matrix/utils/algorithm07'));
  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));
  var algorithm12 = load(require('../../type/matrix/utils/algorithm12'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

  /**
   * Calculates the power of x to y element wise.
   *
   * Syntax:
   *
   *    math.dotPow(x, y)
   *
   * Examples:
   *
   *    math.dotPow(2, 3);            // returns number 8
   *
   *    var a = [[1, 2], [4, 3]];
   *    math.dotPow(a, 2);            // returns Array [[1, 4], [16, 9]]
   *    math.pow(a, 2);               // returns Array [[9, 8], [16, 17]]
   *
   * See also:
   *
   *    pow, sqrt, multiply
   *
   * @param  {number | BigNumber | Complex | Unit | Array | Matrix} x  The base
   * @param  {number | BigNumber | Complex | Unit | Array | Matrix} y  The exponent
   * @return {number | BigNumber | Complex | Unit | Array | Matrix}                     The value of `x` to the power `y`
   */
  var dotPow = typed('dotPow', {
    
    'any, any': pow,
    
    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse .^ sparse
              c = algorithm07(x, y, pow, false);
              break;
            default:
              // sparse .^ dense
              c = algorithm03(y, x, pow, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense .^ sparse
              c = algorithm03(x, y, pow, false);
              break;
            default:
              // dense .^ dense
              c = algorithm13(x, y, pow);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return dotPow(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return dotPow(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return dotPow(x, matrix(y));
    },

    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm11(x, y, dotPow, false);
          break;
        default:
          c = algorithm14(x, y, dotPow, false);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm12(y, x, dotPow, true);
          break;
        default:
          c = algorithm14(y, x, dotPow, true);
          break;
      }
      return c;
    },

    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, dotPow, false).valueOf();
    },

    'any, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, dotPow, true).valueOf();
    }
  });

  dotPow.toTex = '\\left(${args[0]}' + latex.operators['dotPow'] + '${args[1]}\\right)';
  
  return dotPow;
}

exports.name = 'dotPow';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../type/matrix/utils/algorithm03":440,"../../type/matrix/utils/algorithm07":444,"../../type/matrix/utils/algorithm11":448,"../../type/matrix/utils/algorithm12":449,"../../type/matrix/utils/algorithm13":450,"../../type/matrix/utils/algorithm14":451,"../../utils/latex":482,"./pow":279}],265:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Calculate the exponent of a value.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.exp(x)
   *
   * Examples:
   *
   *    math.exp(2);                  // returns number 7.3890560989306495
   *    math.pow(math.e, 2);          // returns number 7.3890560989306495
   *    math.log(math.exp(2));        // returns number 2
   *
   *    math.exp([1, 2, 3]);
   *    // returns Array [
   *    //   2.718281828459045,
   *    //   7.3890560989306495,
   *    //   20.085536923187668
   *    // ]
   *
   * See also:
   *
   *    log, pow
   *
   * @param {number | BigNumber | Complex | Array | Matrix} x  A number or matrix to exponentiate
   * @return {number | BigNumber | Complex | Array | Matrix} Exponent of `x`
   */
  var exp = typed('exp', {
    'number': Math.exp,

    'Complex': function (x) {
      return x.exp();
    },

    'BigNumber': function (x) {
      return x.exp();
    },

    'Array | Matrix': function (x) {
      // TODO: exp(sparse) should return a dense matrix since exp(0)==1
      return deepMap(x, exp);
    }
  });

  exp.toTex = '\\exp\\left(${args[0]}\\right)';

  return exp;
}

exports.name = 'exp';
exports.factory = factory;

},{"../../utils/collection/deepMap":475}],266:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Round a value towards zero.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.fix(x)
   *
   * Examples:
   *
   *    math.fix(3.2);                // returns number 3
   *    math.fix(3.8);                // returns number 3
   *    math.fix(-4.2);               // returns number -4
   *    math.fix(-4.7);               // returns number -4
   *
   *    var c = math.complex(3.2, -2.7);
   *    math.fix(c);                  // returns Complex 3 - 2i
   *
   *    math.fix([3.2, 3.8, -4.7]);   // returns Array [3, 3, -4]
   *
   * See also:
   *
   *    ceil, floor, round
   *
   * @param {number | BigNumber | Fraction | Complex | Array | Matrix} x Number to be rounded
   * @return {number | BigNumber | Fraction | Complex | Array | Matrix}            Rounded value
   */
  var fix = typed('fix', {
    'number': function (x) {
      return (x > 0) ? Math.floor(x) : Math.ceil(x);
    },

    'Complex': function (x) {
      return new type.Complex(
          (x.re > 0) ? Math.floor(x.re) : Math.ceil(x.re),
          (x.im > 0) ? Math.floor(x.im) : Math.ceil(x.im)
      );
    },

    'BigNumber': function (x) {
      return x.isNegative() ? x.ceil() : x.floor();
    },

    'Fraction': function (x) {
      return x.s < 0 ? x.ceil() : x.floor();
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since fix(0) = 0
      return deepMap(x, fix, true);
    }
  });

  fix.toTex = '\\mathrm{${name}}\\left(${args}\\right)';

  return fix;
}

exports.name = 'fix';
exports.factory = factory;

},{"../../utils/collection/deepMap":475}],267:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Round a value towards minus infinity.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.floor(x)
   *
   * Examples:
   *
   *    math.floor(3.2);              // returns number 3
   *    math.floor(3.8);              // returns number 3
   *    math.floor(-4.2);             // returns number -5
   *    math.floor(-4.7);             // returns number -5
   *
   *    var c = math.complex(3.2, -2.7);
   *    math.floor(c);                // returns Complex 3 - 3i
   *
   *    math.floor([3.2, 3.8, -4.7]); // returns Array [3, 3, -5]
   *
   * See also:
   *
   *    ceil, fix, round
   *
   * @param  {number | BigNumber | Fraction | Complex | Array | Matrix} x  Number to be rounded
   * @return {number | BigNumber | Fraction | Complex | Array | Matrix} Rounded value
   */
  var floor = typed('floor', {
    'number': Math.floor,

    'Complex': function (x) {
      return x.floor();
    },

    'BigNumber': function (x) {
      return x.floor();
    },

    'Fraction': function (x) {
      return x.floor();
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since floor(0) = 0
      return deepMap(x, floor, true);
    }
  });

  floor.toTex = '\\left\\lfloor${args[0]}\\right\\rfloor';

  return floor;
}

exports.name = 'floor';
exports.factory = factory;

},{"../../utils/collection/deepMap":475}],268:[function(require,module,exports){
'use strict';

var isInteger = require('../../utils/number').isInteger;

function factory (type, config, load, typed) {

  var matrix = load(require('../../type/matrix/function/matrix'));

  var algorithm01 = load(require('../../type/matrix/utils/algorithm01'));
  var algorithm04 = load(require('../../type/matrix/utils/algorithm04'));
  var algorithm10 = load(require('../../type/matrix/utils/algorithm10'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

  /**
   * Calculate the greatest common divisor for two or more values or arrays.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.gcd(a, b)
   *    math.gcd(a, b, c, ...)
   *
   * Examples:
   *
   *    math.gcd(8, 12);              // returns 4
   *    math.gcd(-4, 6);              // returns 2
   *    math.gcd(25, 15, -10);        // returns 5
   *
   *    math.gcd([8, -4], [12, 6]);   // returns [4, 2]
   *
   * See also:
   *
   *    lcm, xgcd
   *
   * @param {... number | BigNumber | Fraction | Array | Matrix} args  Two or more integer numbers
   * @return {number | BigNumber | Fraction | Array | Matrix}                           The greatest common divisor
   */
  var gcd = typed('gcd', {

    'number, number': _gcd,

    'BigNumber, BigNumber': _gcdBigNumber,

    'Fraction, Fraction': function (x, y) {
      return x.gcd(y);
    },

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse + sparse
              c = algorithm04(x, y, gcd);
              break;
            default:
              // sparse + dense
              c = algorithm01(y, x, gcd, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense + sparse
              c = algorithm01(x, y, gcd, false);
              break;
            default:
              // dense + dense
              c = algorithm13(x, y, gcd);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return gcd(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return gcd(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return gcd(x, matrix(y));
    },
    
    'Matrix, number | BigNumber': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm10(x, y, gcd, false);
          break;
        default:
          c = algorithm14(x, y, gcd, false);
          break;
      }
      return c;
    },

    'number | BigNumber, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm10(y, x, gcd, true);
          break;
        default:
          c = algorithm14(y, x, gcd, true);
          break;
      }
      return c;
    },

    'Array, number | BigNumber': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, gcd, false).valueOf();
    },

    'number | BigNumber, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, gcd, true).valueOf();
    },

    // TODO: need a smarter notation here
    'Array | Matrix | number | BigNumber, Array | Matrix | number | BigNumber, ...Array | Matrix | number | BigNumber': function (a, b, args) {
      var res = gcd(a, b);
      for (var i = 0; i < args.length; i++) {
        res = gcd(res, args[i]);
      }
      return res;
    }
  });

  gcd.toTex = '\\gcd\\left(${args}\\right)';

  return gcd;

  /**
   * Calculate gcd for BigNumbers
   * @param {BigNumber} a
   * @param {BigNumber} b
   * @returns {BigNumber} Returns greatest common denominator of a and b
   * @private
   */
  function _gcdBigNumber(a, b) {
    if (!a.isInt() || !b.isInt()) {
      throw new Error('Parameters in function gcd must be integer numbers');
    }

    // http://en.wikipedia.org/wiki/Euclidean_algorithm
    var zero = new type.BigNumber(0);
    while (!b.isZero()) {
      var r = a.mod(b);
      a = b;
      b = r;
    }
    return a.lt(zero) ? a.neg() : a;
  }
}

/**
 * Calculate gcd for numbers
 * @param {number} a
 * @param {number} b
 * @returns {number} Returns the greatest common denominator of a and b
 * @private
 */
function _gcd(a, b) {
  if (!isInteger(a) || !isInteger(b)) {
    throw new Error('Parameters in function gcd must be integer numbers');
  }

  // http://en.wikipedia.org/wiki/Euclidean_algorithm
  var r;
  while (b != 0) {
    r = a % b;
    a = b;
    b = r;
  }
  return (a < 0) ? -a : a;
}

exports.name = 'gcd';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../type/matrix/utils/algorithm01":438,"../../type/matrix/utils/algorithm04":441,"../../type/matrix/utils/algorithm10":447,"../../type/matrix/utils/algorithm13":450,"../../type/matrix/utils/algorithm14":451,"../../utils/number":483}],269:[function(require,module,exports){
'use strict';

var flatten = require('../../utils/array').flatten;

function factory (type, config, load, typed) {
  var abs = load(require('./abs'));
  var add = load(require('./addScalar'));
  var divide = load(require('./divideScalar'));
  var multiply = load(require('./multiplyScalar'));
  var sqrt = load(require('./sqrt'));
  var smaller = load(require('../relational/smaller'));
  var isPositive = load(require('../utils/isPositive'));

  /**
   * Calculate the hypotenusa of a list with values. The hypotenusa is defined as:
   *
   *     hypot(a, b, c, ...) = sqrt(a^2 + b^2 + c^2 + ...)
   *
   * For matrix input, the hypotenusa is calculated for all values in the matrix.
   *
   * Syntax:
   *
   *     math.hypot(a, b, ...)
   *     math.hypot([a, b, c, ...])
   *
   * Examples:
   *
   *     math.hypot(3, 4);      // 5
   *     math.hypot(3, 4, 5);   // 7.0710678118654755
   *     math.hypot([3, 4, 5]); // 7.0710678118654755
   *     math.hypot(-2);        // 2
   *
   * See also:
   *
   *     abs, norm
   *
   * @param {... number | BigNumber} args
   * @return {number | BigNumber} Returns the hypothenusa of the input values.
   */
  var hypot = typed('hypot', {
    '... number | BigNumber': _hypot,

    'Array': function (x) {
      return hypot.apply(hypot, flatten(x));
    },

    'Matrix': function (x) {
      return hypot.apply(hypot, flatten(x.toArray()));
    }
  });

  /**
   * Calculate the hypotenusa for an Array with values
   * @param {Array.<number | BigNumber>} args
   * @return {number | BigNumber} Returns the result
   * @private
   */
  function _hypot (args) {
    // code based on `hypot` from es6-shim:
    // https://github.com/paulmillr/es6-shim/blob/master/es6-shim.js#L1619-L1633
    var result = 0;
    var largest = 0;

    for (var i = 0; i < args.length; i++) {
      var value = abs(args[i]);
      if (smaller(largest, value)) {
        result = multiply(result, multiply(divide(largest, value), divide(largest, value)));
        result = add(result, 1);
        largest = value;
      } else {
        result = add(result, isPositive(value) ? multiply(divide(value, largest), divide(value, largest)) : value);
      }
    }

    return multiply(largest, sqrt(result));
  }

  hypot.toTex = '\\hypot\\left(${args}\\right)';

  return hypot;
}

exports.name = 'hypot';
exports.factory = factory;

},{"../../utils/array":461,"../relational/smaller":356,"../utils/isPositive":406,"./abs":254,"./addScalar":256,"./divideScalar":261,"./multiplyScalar":276,"./sqrt":282}],270:[function(require,module,exports){
module.exports = [
  require('./abs'),
  require('./add'),
  require('./addScalar'),
  require('./cbrt'),
  require('./ceil'),
  require('./cube'),
  require('./divide'),
  require('./dotDivide'),
  require('./dotMultiply'),
  require('./dotPow'),
  require('./exp'),
  require('./fix'),
  require('./floor'),
  require('./gcd'),
  require('./hypot'),
  require('./lcm'),
  require('./log'),
  require('./log10'),
  require('./mod'),
  require('./multiply'),
  require('./norm'),
  require('./nthRoot'),
  require('./pow'),
  require('./round'),
  require('./sign'),
  require('./sqrt'),
  require('./square'),
  require('./subtract'),
  require('./unaryMinus'),
  require('./unaryPlus'),
  require('./xgcd')
];

},{"./abs":254,"./add":255,"./addScalar":256,"./cbrt":257,"./ceil":258,"./cube":259,"./divide":260,"./dotDivide":262,"./dotMultiply":263,"./dotPow":264,"./exp":265,"./fix":266,"./floor":267,"./gcd":268,"./hypot":269,"./lcm":271,"./log":272,"./log10":273,"./mod":274,"./multiply":275,"./norm":277,"./nthRoot":278,"./pow":279,"./round":280,"./sign":281,"./sqrt":282,"./square":283,"./subtract":284,"./unaryMinus":285,"./unaryPlus":286,"./xgcd":287}],271:[function(require,module,exports){
'use strict';

var isInteger = require('../../utils/number').isInteger;

function factory (type, config, load, typed) {
  
  var matrix = load(require('../../type/matrix/function/matrix'));

  var algorithm02 = load(require('../../type/matrix/utils/algorithm02'));
  var algorithm06 = load(require('../../type/matrix/utils/algorithm06'));
  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

  /**
   * Calculate the least common multiple for two or more values or arrays.
   *
   * lcm is defined as:
   *
   *     lcm(a, b) = abs(a * b) / gcd(a, b)
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.lcm(a, b)
   *    math.lcm(a, b, c, ...)
   *
   * Examples:
   *
   *    math.lcm(4, 6);               // returns 12
   *    math.lcm(6, 21);              // returns 42
   *    math.lcm(6, 21, 5);           // returns 210
   *
   *    math.lcm([4, 6], [6, 21]);    // returns [12, 42]
   *
   * See also:
   *
   *    gcd, xgcd
   *
   * @param {... number | BigNumber | Array | Matrix} args  Two or more integer numbers
   * @return {number | BigNumber | Array | Matrix}                           The least common multiple
   */
  var lcm = typed('lcm', {
    'number, number': _lcm,

    'BigNumber, BigNumber': _lcmBigNumber,

    'Fraction, Fraction': function (x, y) {

      return x.lcm(y);
    },

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse + sparse
              c = algorithm06(x, y, lcm);
              break;
            default:
              // sparse + dense
              c = algorithm02(y, x, lcm, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense + sparse
              c = algorithm02(x, y, lcm, false);
              break;
            default:
              // dense + dense
              c = algorithm13(x, y, lcm);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return lcm(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return lcm(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return lcm(x, matrix(y));
    },

    'Matrix, number | BigNumber': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm11(x, y, lcm, false);
          break;
        default:
          c = algorithm14(x, y, lcm, false);
          break;
      }
      return c;
    },

    'number | BigNumber, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm11(y, x, lcm, true);
          break;
        default:
          c = algorithm14(y, x, lcm, true);
          break;
      }
      return c;
    },

    'Array, number | BigNumber': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, lcm, false).valueOf();
    },

    'number | BigNumber, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, lcm, true).valueOf();
    },

    // TODO: need a smarter notation here
    'Array | Matrix | number | BigNumber, Array | Matrix | number | BigNumber, ...Array | Matrix | number | BigNumber': function (a, b, args) {
      var res = lcm(a, b);
      for (var i = 0; i < args.length; i++) {
        res = lcm(res, args[i]);
      }
      return res;
    }
  });

  lcm.toTex = '\\mathrm{${name}}\\left(${args}\\right)';

  return lcm;

  /**
   * Calculate lcm for two BigNumbers
   * @param {BigNumber} a
   * @param {BigNumber} b
   * @returns {BigNumber} Returns the least common multiple of a and b
   * @private
   */
  function _lcmBigNumber(a, b) {
    if (!a.isInt() || !b.isInt()) {
      throw new Error('Parameters in function lcm must be integer numbers');
    }

    if (a.isZero() || b.isZero()) {
      return new type.BigNumber(0);
    }

    // http://en.wikipedia.org/wiki/Euclidean_algorithm
    // evaluate lcm here inline to reduce overhead
    var prod = a.times(b);
    while (!b.isZero()) {
      var t = b;
      b = a.mod(t);
      a = t;
    }
    return prod.div(a).abs();
  }
}

/**
 * Calculate lcm for two numbers
 * @param {number} a
 * @param {number} b
 * @returns {number} Returns the least common multiple of a and b
 * @private
 */
function _lcm (a, b) {
  if (!isInteger(a) || !isInteger(b)) {
    throw new Error('Parameters in function lcm must be integer numbers');
  }

  if (a == 0 || b == 0) {
    return 0;
  }

  // http://en.wikipedia.org/wiki/Euclidean_algorithm
  // evaluate lcm here inline to reduce overhead
  var t;
  var prod = a * b;
  while (b != 0) {
    t = b;
    b = a % t;
    a = t;
  }
  return Math.abs(prod / a);
}

exports.name = 'lcm';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../type/matrix/utils/algorithm02":439,"../../type/matrix/utils/algorithm06":443,"../../type/matrix/utils/algorithm11":448,"../../type/matrix/utils/algorithm13":450,"../../type/matrix/utils/algorithm14":451,"../../utils/number":483}],272:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  var divideScalar = load(require('./divideScalar'));

  /**
   * Calculate the logarithm of a value.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.log(x)
   *    math.log(x, base)
   *
   * Examples:
   *
   *    math.log(3.5);                  // returns 1.252762968495368
   *    math.exp(math.log(2.4));        // returns 2.4
   *
   *    math.pow(10, 4);                // returns 10000
   *    math.log(10000, 10);            // returns 4
   *    math.log(10000) / math.log(10); // returns 4
   *
   *    math.log(1024, 2);              // returns 10
   *    math.pow(2, 10);                // returns 1024
   *
   * See also:
   *
   *    exp, log10
   *
   * @param {number | BigNumber | Complex | Array | Matrix} x
   *            Value for which to calculate the logarithm.
   * @param {number | BigNumber | Complex} [base=e]
   *            Optional base for the logarithm. If not provided, the natural
   *            logarithm of `x` is calculated.
   * @return {number | BigNumber | Complex | Array | Matrix}
   *            Returns the logarithm of `x`
   */
  var log = typed('log', {
    'number': function (x) {
      if (x >= 0 || config.predictable) {
        return Math.log(x);
      }
      else {
        // negative value -> complex value computation
        return new type.Complex(x, 0).log();
      }
    },

    'Complex': function (x) {
      return x.log();
    },

    'BigNumber': function (x) {
      if (!x.isNegative() || config.predictable) {
        return x.ln();
      }
      else {
        // downgrade to number, return Complex valued result
        return new type.Complex(x.toNumber(), 0).log();
      }
    },

    'Array | Matrix': function (x) {
      return deepMap(x, log);
    },

    'any, any': function (x, base) {
      // calculate logarithm for a specified base, log(x, base)
      return divideScalar(log(x), log(base));
    }
  });

  log.toTex = {
    1: '\\ln\\left(${args[0]}\\right)',
    2: '\\log_{${args[1]}}\\left(${args[0]}\\right)'
  };

  return log;
}

exports.name = 'log';
exports.factory = factory;

},{"../../utils/collection/deepMap":475,"./divideScalar":261}],273:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Calculate the 10-base of a value. This is the same as calculating `log(x, 10)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.log10(x)
   *
   * Examples:
   *
   *    math.log10(0.00001);            // returns -5
   *    math.log10(10000);              // returns 4
   *    math.log(10000) / math.log(10); // returns 4
   *    math.pow(10, 4);                // returns 10000
   *
   * See also:
   *
   *    exp, log
   *
   * @param {number | BigNumber | Complex | Array | Matrix} x
   *            Value for which to calculate the logarithm.
   * @return {number | BigNumber | Complex | Array | Matrix}
   *            Returns the 10-base logarithm of `x`
   */
  var log10 = typed('log10', {
    'number': function (x) {
      if (x >= 0 || config.predictable) {
        return Math.log(x) / Math.LN10;
      }
      else {
        // negative value -> complex value computation
        return new type.Complex(x, 0).log().div(Math.LN10);
      }
    },

    'Complex': function (x) {
      return new type.Complex(x).log().div(Math.LN10);
    },

    'BigNumber': function (x) {
      if (!x.isNegative() || config.predictable) {
        return x.log();
      }
      else {
        // downgrade to number, return Complex valued result
        return new type.Complex(x.toNumber(), 0).log().div(Math.LN10);
      }
    },

    'Array | Matrix': function (x) {
      return deepMap(x, log10);
    }
  });

  log10.toTex = '\\log_{10}\\left(${args[0]}\\right)';

  return log10;
}

exports.name = 'log10';
exports.factory = factory;


},{"../../utils/collection/deepMap":475}],274:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {

  var matrix = load(require('../../type/matrix/function/matrix'));
  var latex = require('../../utils/latex');

  var algorithm02 = load(require('../../type/matrix/utils/algorithm02'));
  var algorithm03 = load(require('../../type/matrix/utils/algorithm03'));
  var algorithm05 = load(require('../../type/matrix/utils/algorithm05'));
  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));
  var algorithm12 = load(require('../../type/matrix/utils/algorithm12'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));
  
  /**
   * Calculates the modulus, the remainder of an integer division.
   *
   * For matrices, the function is evaluated element wise.
   *
   * The modulus is defined as:
   *
   *     x - y * floor(x / y)
   *
   * See http://en.wikipedia.org/wiki/Modulo_operation.
   *
   * Syntax:
   *
   *    math.mod(x, y)
   *
   * Examples:
   *
   *    math.mod(8, 3);                // returns 2
   *    math.mod(11, 2);               // returns 1
   *
   *    function isOdd(x) {
   *      return math.mod(x, 2) != 0;
   *    }
   *
   *    isOdd(2);                      // returns false
   *    isOdd(3);                      // returns true
   *
   * See also:
   *
   *    divide
   *
   * @param  {number | BigNumber | Fraction | Array | Matrix} x Dividend
   * @param  {number | BigNumber | Fraction | Array | Matrix} y Divisor
   * @return {number | BigNumber | Fraction | Array | Matrix} Returns the remainder of `x` divided by `y`.
   */
  var mod = typed('mod', {

    'number, number': _mod,

    'BigNumber, BigNumber': function (x, y) {
      return y.isZero() ? x : x.mod(y);
    },

    'Fraction, Fraction': function (x, y) {
      return x.mod(y);
    },

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // mod(sparse, sparse)
              c = algorithm05(x, y, mod, false);
              break;
            default:
              // mod(sparse, dense)
              c = algorithm02(y, x, mod, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // mod(dense, sparse)
              c = algorithm03(x, y, mod, false);
              break;
            default:
              // mod(dense, dense)
              c = algorithm13(x, y, mod);
              break;
          }
          break;
      }
      return c;
    },
    
    'Array, Array': function (x, y) {
      // use matrix implementation
      return mod(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return mod(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return mod(x, matrix(y));
    },

    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm11(x, y, mod, false);
          break;
        default:
          c = algorithm14(x, y, mod, false);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm12(y, x, mod, true);
          break;
        default:
          c = algorithm14(y, x, mod, true);
          break;
      }
      return c;
    },

    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, mod, false).valueOf();
    },

    'any, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, mod, true).valueOf();
    }
  });

  mod.toTex = '\\left(${args[0]}' + latex.operators['mod'] + '${args[1]}\\right)';

  return mod;

  /**
   * Calculate the modulus of two numbers
   * @param {number} x
   * @param {number} y
   * @returns {number} res
   * @private
   */
  function _mod(x, y) {
    if (y > 0) {
      // We don't use JavaScript's % operator here as this doesn't work
      // correctly for x < 0 and x == 0
      // see http://en.wikipedia.org/wiki/Modulo_operation
      return x - y * Math.floor(x / y);
    }
    else if (y === 0) {
      return x;
    }
    else { // y < 0
      // TODO: implement mod for a negative divisor
      throw new Error('Cannot calculate mod for a negative divisor');
    }
  }
}

exports.name = 'mod';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../type/matrix/utils/algorithm02":439,"../../type/matrix/utils/algorithm03":440,"../../type/matrix/utils/algorithm05":442,"../../type/matrix/utils/algorithm11":448,"../../type/matrix/utils/algorithm12":449,"../../type/matrix/utils/algorithm13":450,"../../type/matrix/utils/algorithm14":451,"../../utils/latex":482}],275:[function(require,module,exports){
'use strict';

var extend = require('../../utils/object').extend;
var array = require('../../utils/array');

function factory (type, config, load, typed) {
  var latex = require('../../utils/latex');

  var matrix = load(require('../../type/matrix/function/matrix'));
  var addScalar = load(require('./addScalar'));
  var multiplyScalar = load(require('./multiplyScalar'));
  var equalScalar = load(require('../relational/equalScalar'));

  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));
  
  var DenseMatrix = type.DenseMatrix;
  var SparseMatrix = type.SparseMatrix;

  /**
   * Multiply two values, `x * y`.
   * For matrices, the matrix product is calculated.
   *
   * Syntax:
   *
   *    math.multiply(x, y)
   *
   * Examples:
   *
   *    math.multiply(4, 5.2);        // returns number 20.8
   *
   *    var a = math.complex(2, 3);
   *    var b = math.complex(4, 1);
   *    math.multiply(a, b);          // returns Complex 5 + 14i
   *
   *    var c = [[1, 2], [4, 3]];
   *    var d = [[1, 2, 3], [3, -4, 7]];
   *    math.multiply(c, d);          // returns Array [[7, -6, 17], [13, -4, 33]]
   *
   *    var e = math.unit('2.1 km');
   *    math.multiply(3, e);          // returns Unit 6.3 km
   *
   * See also:
   *
   *    divide
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x First value to multiply
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Second value to multiply
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} Multiplication of `x` and `y`
   */
  var multiply = typed('multiply', extend({
    // we extend the signatures of multiplyScalar with signatures dealing with matrices

    'Array, Array': function (x, y) {
      // check dimensions
      _validateMatrixDimensions(array.size(x), array.size(y));

      // use dense matrix implementation
      var m = multiply(matrix(x), matrix(y));
      // return array or scalar
      return (m && m.isMatrix === true) ? m.valueOf() : m;
    },

    'Matrix, Matrix': function (x, y) {
      // dimensions
      var xsize = x.size();
      var ysize = y.size();

      // check dimensions
      _validateMatrixDimensions(xsize, ysize);

      // process dimensions
      if (xsize.length === 1) {
        // process y dimensions
        if (ysize.length === 1) {
          // Vector * Vector
          return _multiplyVectorVector(x, y, xsize[0]);
        }
        // Vector * Matrix
        return _multiplyVectorMatrix(x, y);
      }
      // process y dimensions
      if (ysize.length === 1) {
        // Matrix * Vector
        return _multiplyMatrixVector(x, y);
      }
      // Matrix * Matrix
      return _multiplyMatrixMatrix(x, y);
    },

    'Matrix, Array': function (x, y) {
      // use Matrix * Matrix implementation
      return multiply(x, matrix(y));
    },

    'Array, Matrix': function (x, y) {
      // use Matrix * Matrix implementation
      return multiply(matrix(x, y.storage()), y);
    },

    'Matrix, any': function (x, y) {
      // result
      var c;
      
      // process storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm11(x, y, multiplyScalar, false);
          break;
        case 'dense':
          c = algorithm14(x, y, multiplyScalar, false);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm11(y, x, multiplyScalar, true);
          break;
        case 'dense':
          c = algorithm14(y, x, multiplyScalar, true);
          break;
      }
      return c;
    },

    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, multiplyScalar, false).valueOf();
    },

    'any, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, multiplyScalar, true).valueOf();
    }
  }, multiplyScalar.signatures));

  var _validateMatrixDimensions = function (size1, size2) {
    // check left operand dimensions
    switch (size1.length) {
      case 1:
        // check size2
        switch (size2.length) {
          case 1:
            // Vector x Vector
            if (size1[0] !== size2[0]) {
              // throw error
              throw new RangeError('Dimension mismatch in multiplication. Vectors must have the same length');
            }
            break;
          case 2:
            // Vector x Matrix
            if (size1[0] !== size2[0]) {
              // throw error
              throw new RangeError('Dimension mismatch in multiplication. Vector length (' + size1[0] + ') must match Matrix rows (' + size2[0] + ')');
            }
            break;
          default:
            throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix B has ' + size2.length + ' dimensions)');
        }
        break;
      case 2:
        // check size2
        switch (size2.length) {
          case 1:
            // Matrix x Vector
            if (size1[1] !== size2[0]) {
              // throw error
              throw new RangeError('Dimension mismatch in multiplication. Matrix columns (' + size1[1] + ') must match Vector length (' + size2[0] + ')');
            }
            break;
          case 2:
            // Matrix x Matrix
            if (size1[1] !== size2[0]) {
              // throw error
              throw new RangeError('Dimension mismatch in multiplication. Matrix A columns (' + size1[1] + ') must match Matrix B rows (' + size2[0] + ')');
            }
            break;
          default:
            throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix B has ' + size2.length + ' dimensions)');
        }
        break;
      default:
        throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix A has ' + size1.length + ' dimensions)');
    }
  };

  /**
   * C = A * B
   *
   * @param {Matrix} a            Dense Vector   (N)
   * @param {Matrix} b            Dense Vector   (N)
   *
   * @return {number}             Scalar value
   */
  var _multiplyVectorVector = function (a, b, n) {
    // check empty vector
    if (n === 0)
      throw new Error('Cannot multiply two empty vectors');

    // a dense
    var adata = a._data;
    var adt = a._datatype;
    // b dense
    var bdata = b._data;
    var bdt = b._datatype;

    // datatype
    var dt;
    // addScalar signature to use
    var af = addScalar;
    // multiplyScalar signature to use
    var mf = multiplyScalar;

    // process data types
    if (adt && bdt && adt === bdt && typeof adt === 'string') {
      // datatype
      dt = adt;
      // find signatures that matches (dt, dt)
      af = typed.find(addScalar, [dt, dt]);
      mf = typed.find(multiplyScalar, [dt, dt]);
    }
    
    // result (do not initialize it with zero)
    var c = mf(adata[0], bdata[0]);
    // loop data
    for (var i = 1; i < n; i++) {
      // multiply and accumulate
      c = af(c, mf(adata[i], bdata[i]));
    }
    return c;
  };

  /**
   * C = A * B
   *
   * @param {Matrix} a            Dense Vector   (M)
   * @param {Matrix} b            Matrix         (MxN)
   *
   * @return {Matrix}             Dense Vector   (N)
   */
  var _multiplyVectorMatrix = function (a, b) {
    // process storage
    switch (b.storage()) {
      case 'dense':
        return _multiplyVectorDenseMatrix(a, b);
    }
    throw new Error('Not implemented');
  };

  /**
   * C = A * B
   *
   * @param {Matrix} a            Dense Vector   (M)
   * @param {Matrix} b            Dense Matrix   (MxN)
   *
   * @return {Matrix}             Dense Vector   (N)
   */
  var _multiplyVectorDenseMatrix = function (a, b) {
    // a dense
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype;
    // b dense
    var bdata = b._data;
    var bsize = b._size;
    var bdt = b._datatype;
    // rows & columns
    var alength = asize[0];
    var bcolumns = bsize[1];

    // datatype
    var dt;
    // addScalar signature to use
    var af = addScalar;
    // multiplyScalar signature to use
    var mf = multiplyScalar;

    // process data types
    if (adt && bdt && adt === bdt && typeof adt === 'string') {
      // datatype
      dt = adt;
      // find signatures that matches (dt, dt)
      af = typed.find(addScalar, [dt, dt]);
      mf = typed.find(multiplyScalar, [dt, dt]);
    }

    // result
    var c = [];

    // loop matrix columns
    for (var j = 0; j < bcolumns; j++) {
      // sum (do not initialize it with zero)
      var sum = mf(adata[0], bdata[0][j]);      
      // loop vector
      for (var i = 1; i < alength; i++) {
        // multiply & accumulate
        sum = af(sum, mf(adata[i], bdata[i][j]));
      }
      c[j] = sum;
    }

    // return matrix
    return new DenseMatrix({
      data: c,
      size: [bcolumns],
      datatype: dt
    });
  };

  /**
   * C = A * B
   *
   * @param {Matrix} a            Matrix         (MxN)
   * @param {Matrix} b            Dense Vector   (N)
   *
   * @return {Matrix}             Dense Vector   (M)
   */
  var _multiplyMatrixVector = function (a, b) {
    // process storage
    switch (a.storage()) {
      case 'dense':
        return _multiplyDenseMatrixVector(a, b);
      case 'sparse':
        return _multiplySparseMatrixVector(a, b);
    }
  };

  /**
   * C = A * B
   *
   * @param {Matrix} a            Matrix         (MxN)
   * @param {Matrix} b            Matrix         (NxC)
   *
   * @return {Matrix}             Matrix         (MxC)
   */
  var _multiplyMatrixMatrix = function (a, b) {
    // process storage
    switch (a.storage()) {
      case 'dense':
        // process storage
        switch (b.storage()) {
          case 'dense':
            return _multiplyDenseMatrixDenseMatrix(a, b);
          case 'sparse':
            return _multiplyDenseMatrixSparseMatrix(a, b);
        }
        break;
      case 'sparse':
        // process storage
        switch (b.storage()) {
          case 'dense':
            return _multiplySparseMatrixDenseMatrix(a, b);
          case 'sparse':
            return _multiplySparseMatrixSparseMatrix(a, b);
        }
        break;
    }
  };

  /**
   * C = A * B
   *
   * @param {Matrix} a            DenseMatrix  (MxN)
   * @param {Matrix} b            Dense Vector (N)
   *
   * @return {Matrix}             Dense Vector (M) 
   */ 
  var _multiplyDenseMatrixVector = function (a, b) {
    // a dense
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype;
    // b dense
    var bdata = b._data;
    var bdt = b._datatype;
    // rows & columns
    var arows = asize[0];
    var acolumns = asize[1];

    // datatype
    var dt;
    // addScalar signature to use
    var af = addScalar;
    // multiplyScalar signature to use
    var mf = multiplyScalar;

    // process data types
    if (adt && bdt && adt === bdt && typeof adt === 'string') {
      // datatype
      dt = adt;
      // find signatures that matches (dt, dt)
      af = typed.find(addScalar, [dt, dt]);
      mf = typed.find(multiplyScalar, [dt, dt]);
    }

    // result
    var c = [];

    // loop matrix a rows
    for (var i = 0; i < arows; i++) {
      // current row
      var row = adata[i];
      // sum (do not initialize it with zero)
      var sum = mf(row[0], bdata[0]);
      // loop matrix a columns
      for (var j = 1; j < acolumns; j++) {
        // multiply & accumulate
        sum = af(sum, mf(row[j], bdata[j]));
      }
      c[i] = sum;
    }

    // return matrix
    return new DenseMatrix({
      data: c,
      size: [arows],
      datatype: dt
    });
  };

  /**
   * C = A * B
   *
   * @param {Matrix} a            DenseMatrix    (MxN)
   * @param {Matrix} b            DenseMatrix    (NxC)
   *
   * @return {Matrix}             DenseMatrix    (MxC)
   */
  var _multiplyDenseMatrixDenseMatrix = function (a, b) {
    // a dense
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype;
    // b dense
    var bdata = b._data;
    var bsize = b._size;
    var bdt = b._datatype;
    // rows & columns
    var arows = asize[0];
    var acolumns = asize[1];
    var bcolumns = bsize[1];

    // datatype
    var dt;
    // addScalar signature to use
    var af = addScalar;
    // multiplyScalar signature to use
    var mf = multiplyScalar;

    // process data types
    if (adt && bdt && adt === bdt && typeof adt === 'string') {
      // datatype
      dt = adt;
      // find signatures that matches (dt, dt)
      af = typed.find(addScalar, [dt, dt]);
      mf = typed.find(multiplyScalar, [dt, dt]);
    }
    
    // result
    var c = [];

    // loop matrix a rows
    for (var i = 0; i < arows; i++) {
      // current row
      var row = adata[i];
      // initialize row array
      c[i] = [];
      // loop matrix b columns
      for (var j = 0; j < bcolumns; j++) {
        // sum (avoid initializing sum to zero)
        var sum = mf(row[0], bdata[0][j]);
        // loop matrix a columns
        for (var x = 1; x < acolumns; x++) {
          // multiply & accumulate
          sum = af(sum, mf(row[x], bdata[x][j]));
        }
        c[i][j] = sum;
      }
    }

    // return matrix
    return new DenseMatrix({
      data: c,
      size: [arows, bcolumns],
      datatype: dt
    });
  };

  /**
   * C = A * B
   *
   * @param {Matrix} a            DenseMatrix    (MxN)
   * @param {Matrix} b            SparseMatrix   (NxC)
   *
   * @return {Matrix}             SparseMatrix   (MxC)
   */
  var _multiplyDenseMatrixSparseMatrix = function (a, b) {
    // a dense
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype;
    // b sparse
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype;
    // validate b matrix
    if (!bvalues)
      throw new Error('Cannot multiply Dense Matrix times Pattern only Matrix');
    // rows & columns
    var arows = asize[0];
    var bcolumns = bsize[1];
    
    // datatype
    var dt;
    // addScalar signature to use
    var af = addScalar;
    // multiplyScalar signature to use
    var mf = multiplyScalar;
    // equalScalar signature to use
    var eq = equalScalar;
    // zero value
    var zero = 0;

    // process data types
    if (adt && bdt && adt === bdt && typeof adt === 'string') {
      // datatype
      dt = adt;
      // find signatures that matches (dt, dt)
      af = typed.find(addScalar, [dt, dt]);
      mf = typed.find(multiplyScalar, [dt, dt]);
      eq = typed.find(equalScalar, [dt, dt]);
      // convert 0 to the same datatype
      zero = typed.convert(0, dt);
    }

    // result
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    // c matrix
    var c = new SparseMatrix({
      values : cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, bcolumns],
      datatype: dt
    });

    // loop b columns
    for (var jb = 0; jb < bcolumns; jb++) {
      // update ptr
      cptr[jb] = cindex.length;
      // indeces in column jb
      var kb0 = bptr[jb];
      var kb1 = bptr[jb + 1];
      // do not process column jb if no data exists
      if (kb1 > kb0) {
        // last row mark processed
        var last = 0;
        // loop a rows
        for (var i = 0; i < arows; i++) {
          // column mark
          var mark = i + 1;
          // C[i, jb]
          var cij;
          // values in b column j
          for (var kb = kb0; kb < kb1; kb++) {
            // row
            var ib = bindex[kb];
            // check value has been initialized
            if (last !== mark) {
              // first value in column jb
              cij = mf(adata[i][ib], bvalues[kb]);
              // update mark
              last = mark;
            }
            else {
              // accumulate value
              cij = af(cij, mf(adata[i][ib], bvalues[kb]));
            }
          }
          // check column has been processed and value != 0
          if (last === mark && !eq(cij, zero)) {
            // push row & value
            cindex.push(i);
            cvalues.push(cij);
          }
        }
      }
    }
    // update ptr
    cptr[bcolumns] = cindex.length;

    // return sparse matrix
    return c;
  };

  /**
   * C = A * B
   *
   * @param {Matrix} a            SparseMatrix    (MxN)
   * @param {Matrix} b            Dense Vector (N)
   *
   * @return {Matrix}             SparseMatrix    (M, 1) 
   */
  var _multiplySparseMatrixVector = function (a, b) {
    // a sparse
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var adt = a._datatype;
    // validate a matrix
    if (!avalues)
      throw new Error('Cannot multiply Pattern only Matrix times Dense Matrix');
    // b dense
    var bdata = b._data;
    var bdt = b._datatype;
    // rows & columns
    var arows = a._size[0];
    var brows = b._size[0];
    // result
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    
    // datatype
    var dt;
    // addScalar signature to use
    var af = addScalar;
    // multiplyScalar signature to use
    var mf = multiplyScalar;
    // equalScalar signature to use
    var eq = equalScalar;
    // zero value
    var zero = 0;

    // process data types
    if (adt && bdt && adt === bdt && typeof adt === 'string') {
      // datatype
      dt = adt;
      // find signatures that matches (dt, dt)
      af = typed.find(addScalar, [dt, dt]);
      mf = typed.find(multiplyScalar, [dt, dt]);
      eq = typed.find(equalScalar, [dt, dt]);
      // convert 0 to the same datatype
      zero = typed.convert(0, dt);
    }

    // workspace
    var x = [];
    // vector with marks indicating a value x[i] exists in a given column
    var w = [];

    // update ptr
    cptr[0] = 0;
    // rows in b
    for (var ib = 0; ib < brows; ib++) {
      // b[ib]
      var vbi = bdata[ib];
      // check b[ib] != 0, avoid loops
      if (!eq(vbi, zero)) {
        // A values & index in ib column
        for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
          // a row
          var ia = aindex[ka];
          // check value exists in current j
          if (!w[ia]) {
            // ia is new entry in j
            w[ia] = true;
            // add i to pattern of C
            cindex.push(ia);
            // x(ia) = A
            x[ia] = mf(vbi, avalues[ka]);
          }
          else {
            // i exists in C already
            x[ia] = af(x[ia], mf(vbi, avalues[ka]));
          }
        }
      }
    }
    // copy values from x to column jb of c
    for (var p1 = cindex.length, p = 0; p < p1; p++) {
      // row
      var ic = cindex[p];
      // copy value
      cvalues[p] = x[ic];
    }
    // update ptr
    cptr[1] = cindex.length;

    // return sparse matrix
    return new SparseMatrix({
      values : cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, 1],
      datatype: dt
    });
  };

  /**
   * C = A * B
   *
   * @param {Matrix} a            SparseMatrix      (MxN)
   * @param {Matrix} b            DenseMatrix       (NxC)
   *
   * @return {Matrix}             SparseMatrix      (MxC)
   */
  var _multiplySparseMatrixDenseMatrix = function (a, b) {
    // a sparse
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var adt = a._datatype;
    // validate a matrix
    if (!avalues)
      throw new Error('Cannot multiply Pattern only Matrix times Dense Matrix');
    // b dense
    var bdata = b._data;
    var bdt = b._datatype;
    // rows & columns
    var arows = a._size[0];
    var brows = b._size[0];
    var bcolumns = b._size[1];

    // datatype
    var dt;
    // addScalar signature to use
    var af = addScalar;
    // multiplyScalar signature to use
    var mf = multiplyScalar;
    // equalScalar signature to use
    var eq = equalScalar;
    // zero value
    var zero = 0;

    // process data types
    if (adt && bdt && adt === bdt && typeof adt === 'string') {
      // datatype
      dt = adt;
      // find signatures that matches (dt, dt)
      af = typed.find(addScalar, [dt, dt]);
      mf = typed.find(multiplyScalar, [dt, dt]);
      eq = typed.find(equalScalar, [dt, dt]);
      // convert 0 to the same datatype
      zero = typed.convert(0, dt);
    }

    // result
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    // c matrix
    var c = new SparseMatrix({
      values : cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, bcolumns],
      datatype: dt
    });

    // workspace
    var x = [];
    // vector with marks indicating a value x[i] exists in a given column
    var w = [];

    // loop b columns
    for (var jb = 0; jb < bcolumns; jb++) {
      // update ptr
      cptr[jb] = cindex.length;
      // mark in workspace for current column
      var mark = jb + 1;
      // rows in jb
      for (var ib = 0; ib < brows; ib++) {
        // b[ib, jb]
        var vbij = bdata[ib][jb];
        // check b[ib, jb] != 0, avoid loops
        if (!eq(vbij, zero)) {
          // A values & index in ib column
          for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
            // a row
            var ia = aindex[ka];
            // check value exists in current j
            if (w[ia] !== mark) {
              // ia is new entry in j
              w[ia] = mark;
              // add i to pattern of C
              cindex.push(ia);
              // x(ia) = A
              x[ia] = mf(vbij, avalues[ka]);
            }
            else {
              // i exists in C already
              x[ia] = af(x[ia], mf(vbij, avalues[ka]));
            }
          }
        }
      }
      // copy values from x to column jb of c
      for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {
        // row
        var ic = cindex[p];
        // copy value
        cvalues[p] = x[ic];
      }
    }
    // update ptr
    cptr[bcolumns] = cindex.length;

    // return sparse matrix
    return c;
  };

  /**
   * C = A * B
   *
   * @param {Matrix} a            SparseMatrix      (MxN)
   * @param {Matrix} b            SparseMatrix      (NxC)
   *
   * @return {Matrix}             SparseMatrix      (MxC)
   */
  var _multiplySparseMatrixSparseMatrix = function (a, b) {
    // a sparse
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var adt = a._datatype;
    // b sparse
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bdt = b._datatype;
    
    // rows & columns
    var arows = a._size[0];
    var bcolumns = b._size[1];
    // flag indicating both matrices (a & b) contain data
    var values = avalues && bvalues;

    // datatype
    var dt;
    // addScalar signature to use
    var af = addScalar;
    // multiplyScalar signature to use
    var mf = multiplyScalar;

    // process data types
    if (adt && bdt && adt === bdt && typeof adt === 'string') {
      // datatype
      dt = adt;
      // find signatures that matches (dt, dt)
      af = typed.find(addScalar, [dt, dt]);
      mf = typed.find(multiplyScalar, [dt, dt]);
    }
    
    // result
    var cvalues = values ? [] : undefined;
    var cindex = [];
    var cptr = [];
    // c matrix
    var c = new SparseMatrix({
      values : cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, bcolumns],
      datatype: dt
    });

    // workspace
    var x = values ? [] : undefined;
    // vector with marks indicating a value x[i] exists in a given column
    var w = [];
    // variables
    var ka, ka0, ka1, kb, kb0, kb1, ia, ib;
    // loop b columns
    for (var jb = 0; jb < bcolumns; jb++) {
      // update ptr
      cptr[jb] = cindex.length;
      // mark in workspace for current column
      var mark = jb + 1;
      // B values & index in j
      for (kb0 = bptr[jb], kb1 = bptr[jb + 1], kb = kb0; kb < kb1; kb++) {
        // b row
        ib = bindex[kb];
        // check we need to process values
        if (values) {
          // loop values in a[:,ib]
          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
            // row
            ia = aindex[ka];
            // check value exists in current j
            if (w[ia] !== mark) {
              // ia is new entry in j
              w[ia] = mark;
              // add i to pattern of C
              cindex.push(ia);
              // x(ia) = A
              x[ia] = mf(bvalues[kb], avalues[ka]);
            }
            else {
              // i exists in C already
              x[ia] = af(x[ia], mf(bvalues[kb], avalues[ka]));
            }
          }
        }
        else {
          // loop values in a[:,ib]
          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
            // row
            ia = aindex[ka];
            // check value exists in current j
            if (w[ia] !== mark) {
              // ia is new entry in j
              w[ia] = mark;
              // add i to pattern of C
              cindex.push(ia);
            }
          }
        }
      }
      // check we need to process matrix values (pattern matrix)
      if (values) {
        // copy values from x to column jb of c
        for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {
          // row
          var ic = cindex[p];
          // copy value
          cvalues[p] = x[ic];
        }
      }
    }
    // update ptr
    cptr[bcolumns] = cindex.length;

    // return sparse matrix
    return c;
  };

  multiply.toTex = '\\left(${args[0]}' + latex.operators['multiply'] + '${args[1]}\\right)';

  return multiply;
}

exports.name = 'multiply';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../type/matrix/utils/algorithm11":448,"../../type/matrix/utils/algorithm14":451,"../../utils/array":461,"../../utils/latex":482,"../../utils/object":484,"../relational/equalScalar":352,"./addScalar":256,"./multiplyScalar":276}],276:[function(require,module,exports){
'use strict';

function factory(type, config, load, typed) {
  
  /**
   * Multiply two scalar values, `x * y`.
   * This function is meant for internal use: it is used by the public function
   * `multiply`
   *
   * This function does not support collections (Array or Matrix), and does
   * not validate the number of of inputs.
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit} x   First value to multiply
   * @param  {number | BigNumber | Fraction | Complex} y          Second value to multiply
   * @return {number | BigNumber | Fraction | Complex | Unit}                      Multiplication of `x` and `y`
   * @private
   */
  var multiplyScalar = typed('multiplyScalar', {

    'number, number': function (x, y) {
      return x * y;
    },

    'Complex, Complex': function (x, y) {
      return x.mul(y);
    },

    'BigNumber, BigNumber': function (x, y) {
      return x.times(y);
    },

    'Fraction, Fraction': function (x, y) {
      return x.mul(y);
    },

    'number | Fraction | BigNumber | Complex, Unit': function (x, y) {
      var res = y.clone();
      res.value = (res.value === null) ? res._normalize(x) : multiplyScalar(res.value, x);
      return res;
    },

    'Unit, number | Fraction | BigNumber | Complex': function (x, y) {
      var res = x.clone();
      res.value = (res.value === null) ? res._normalize(y) : multiplyScalar(res.value, y);
      return res;
    },

    'Unit, Unit': function (x, y) {
      return x.multiply(y);
    }

  });

  return multiplyScalar;
}

exports.factory = factory;

},{}],277:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  
  var abs         = load(require('../arithmetic/abs'));
  var add         = load(require('../arithmetic/add'));
  var pow         = load(require('../arithmetic/pow'));
  var sqrt        = load(require('../arithmetic/sqrt'));
  var multiply    = load(require('../arithmetic/multiply'));
  var equalScalar = load(require('../relational/equalScalar'));
  var larger      = load(require('../relational/larger'));
  var smaller     = load(require('../relational/smaller'));
  var matrix      = load(require('../../type/matrix/function/matrix'));
  var trace       = load(require('../matrix/trace'));
  var transpose   = load(require('../matrix/transpose'));


  /**
   * Calculate the norm of a number, vector or matrix.
   *
   * The second parameter p is optional. If not provided, it defaults to 2.
   *
   * Syntax:
   *
   *    math.norm(x)
   *    math.norm(x, p)
   *
   * Examples:
   *
   *    math.abs(-3.5);                         // returns 3.5
   *    math.norm(-3.5);                        // returns 3.5
   *
   *    math.norm(math.complex(3, -4));         // returns 5
   *
   *    math.norm([1, 2, -3], Infinity);        // returns 3
   *    math.norm([1, 2, -3], -Infinity);       // returns 1
   *
   *    math.norm([3, 4], 2);                   // returns 5
   *
   *    math.norm([[1, 2], [3, 4]], 1)          // returns 6
   *    math.norm([[1, 2], [3, 4]], 'inf');     // returns 7
   *    math.norm([[1, 2], [3, 4]], 'fro');     // returns 5.477225575051661
   *
   * See also:
   *
   *    abs, hypot
   *
   * @param  {number | BigNumber | Complex | Array | Matrix} x
   *            Value for which to calculate the norm
   * @param  {number | BigNumber | string} [p=2]
   *            Vector space.
   *            Supported numbers include Infinity and -Infinity.
   *            Supported strings are: 'inf', '-inf', and 'fro' (The Frobenius norm)
   * @return {number | BigNumber} the p-norm
   */
  var norm = typed('norm', {
    'number': Math.abs,

    'Complex': function (x) {
      return x.abs();
    },

    'BigNumber': function (x) {
      // norm(x) = abs(x)
      return x.abs();
    },
    
    'boolean | null' : function (x) {
      // norm(x) = abs(x)
      return Math.abs(x);
    },

    'Array': function (x) {
      return _norm(matrix(x), 2);
    },
    
    'Matrix': function (x) {
      return _norm(x, 2);
    },

    'number | Complex | BigNumber | boolean | null, number | BigNumber | string': function (x) {
      // ignore second parameter, TODO: remove the option of second parameter for these types
      return norm(x);
    },

    'Array, number | BigNumber | string': function (x, p) {
      return _norm(matrix(x), p);
    },
    
    'Matrix, number | BigNumber | string': function (x, p) {
      return _norm(x, p);
    }
  });

  /**
   * Calculate the norm for an array
   * @param {Array} x
   * @param {number | string} p
   * @returns {number} Returns the norm
   * @private
   */
  function _norm (x, p) {
    // size
    var sizeX = x.size();
    
    // check if it is a vector
    if (sizeX.length == 1) {
      // check p
      if (p === Number.POSITIVE_INFINITY || p === 'inf') {
        // norm(x, Infinity) = max(abs(x))
        var pinf = 0;
        // skip zeros since abs(0) == 0
        x.forEach(
          function (value) {
            var v = abs(value);
            if (larger(v, pinf))
              pinf = v;
          },
          true);
        return pinf;
      }
      if (p === Number.NEGATIVE_INFINITY || p === '-inf') {
        // norm(x, -Infinity) = min(abs(x))
        var ninf;
        // skip zeros since abs(0) == 0
        x.forEach(
          function (value) {
            var v = abs(value);
            if (!ninf || smaller(v, ninf))
              ninf = v;
          },
          true);
        return ninf || 0;
      }
      if (p === 'fro') {
        return _norm(x, 2);
      }
      if (typeof p === 'number' && !isNaN(p)) {
        // check p != 0
        if (!equalScalar(p, 0)) {
          // norm(x, p) = sum(abs(xi) ^ p) ^ 1/p
          var n = 0;
          // skip zeros since abs(0) == 0
          x.forEach(
            function (value) {
              n = add(pow(abs(value), p), n);
            },
            true);
          return pow(n, 1 / p);
        }
        return Number.POSITIVE_INFINITY;
      }
      // invalid parameter value
      throw new Error('Unsupported parameter value');
    }
    // MxN matrix
    if (sizeX.length == 2) {
      // check p
      if (p === 1) {
        // norm(x) = the largest column sum
        var c = [];
        // result
        var maxc = 0;
        // skip zeros since abs(0) == 0
        x.forEach(
          function (value, index) {
            var j = index[1];
            var cj = add(c[j] || 0, abs(value));
            if (larger(cj, maxc))
              maxc = cj;
            c[j] = cj;
          },
          true);
        return maxc;
      }
      if (p === Number.POSITIVE_INFINITY || p === 'inf') {
        // norm(x) = the largest row sum
        var r = [];
        // result
        var maxr = 0;
        // skip zeros since abs(0) == 0
        x.forEach(
          function (value, index) {
            var i = index[0];
            var ri = add(r[i] || 0, abs(value));
            if (larger(ri, maxr))
              maxr = ri;
            r[i] = ri;
          },
          true);
        return maxr;
      }
      if (p === 'fro') {
        // norm(x) = sqrt(sum(diag(x'x)))
        return sqrt(trace(multiply(transpose(x), x)));
      }
      if (p === 2) {
        // not implemented
        throw new Error('Unsupported parameter value, missing implementation of matrix singular value decomposition');
      }
      // invalid parameter value
      throw new Error('Unsupported parameter value');
    }
  }

  norm.toTex = {
    1: '\\left\\|${args[0]}\\right\\|',
    2: '\\mathrm{${name}}\\left(${args}\\right)'
  };

  return norm;
}

exports.name = 'norm';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../arithmetic/abs":254,"../arithmetic/add":255,"../arithmetic/multiply":275,"../arithmetic/pow":279,"../arithmetic/sqrt":282,"../matrix/trace":335,"../matrix/transpose":336,"../relational/equalScalar":352,"../relational/larger":354,"../relational/smaller":356}],278:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {

  var matrix = load(require('../../type/matrix/function/matrix'));

  var algorithm01 = load(require('../../type/matrix/utils/algorithm01'));
  var algorithm02 = load(require('../../type/matrix/utils/algorithm02'));
  var algorithm06 = load(require('../../type/matrix/utils/algorithm06'));
  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

  /**
   * Calculate the nth root of a value.
   * The principal nth root of a positive real number A, is the positive real
   * solution of the equation
   *
   *     x^root = A
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *     math.nthRoot(a)
   *     math.nthRoot(a, root)
   *
   * Examples:
   *
   *     math.nthRoot(9, 2);    // returns 3, as 3^2 == 9
   *     math.sqrt(9);          // returns 3, as 3^2 == 9
   *     math.nthRoot(64, 3);   // returns 4, as 4^3 == 64
   *
   * See also:
   *
   *     sqrt, pow
   *
   * @param {number | BigNumber | Array | Matrix | Complex} a
   *              Value for which to calculate the nth root
   * @param {number | BigNumber} [root=2]    The root.
   * @return {number | Complex | Array | Matrix} Returns the nth root of `a`
   */
  var nthRoot = typed('nthRoot', {
    
    'number': function (x) {
      return _nthRoot(x, 2);
    },
    'number, number': _nthRoot,

    'BigNumber': function (x) {
      return _bigNthRoot(x, new type.BigNumber(2));
    },
    'Complex' : function(x) {
      return _nthComplexRoot(x, 2);
    }, 
    'Complex, number' : _nthComplexRoot,
    'BigNumber, BigNumber': _bigNthRoot,

    'Array | Matrix': function (x) {
      return nthRoot(x, 2);
    },
    
    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // density must be one (no zeros in matrix)
              if (y.density() === 1) {
                // sparse + sparse
                c = algorithm06(x, y, nthRoot);
              }
              else {
                // throw exception
                throw new Error('Root must be non-zero');
              }
              break;
            default:
              // sparse + dense
              c = algorithm02(y, x, nthRoot, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // density must be one (no zeros in matrix)
              if (y.density() === 1) {
                // dense + sparse
                c = algorithm01(x, y, nthRoot, false);
              }
              else {
                // throw exception
                throw new Error('Root must be non-zero');
              }
              break;
            default:
              // dense + dense
              c = algorithm13(x, y, nthRoot);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return nthRoot(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return nthRoot(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return nthRoot(x, matrix(y));
    },
    
    'Matrix, number | BigNumber': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm11(x, y, nthRoot, false);
          break;
        default:
          c = algorithm14(x, y, nthRoot, false);
          break;
      }
      return c;
    },

    'number | BigNumber, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          // density must be one (no zeros in matrix)
          if (y.density() === 1) {
            // sparse - scalar
            c = algorithm11(y, x, nthRoot, true);
          }
          else {
            // throw exception
            throw new Error('Root must be non-zero');
          }
          break;
        default:
          c = algorithm14(y, x, nthRoot, true);
          break;
      }
      return c;
    },

    'Array, number | BigNumber': function (x, y) {
      // use matrix implementation
      return nthRoot(matrix(x), y).valueOf();
    },

    'number | BigNumber, Array': function (x, y) {
      // use matrix implementation
      return nthRoot(x, matrix(y)).valueOf();
    }
  });

  nthRoot.toTex = '\\sqrt[${args[1]}]{${args[0]}}';

  return nthRoot;

  /**
   * Calculate the nth root of a for BigNumbers, solve x^root == a
   * http://rosettacode.org/wiki/Nth_root#JavaScript
   * @param {BigNumber} a
   * @param {BigNumber} root
   * @private
   */
  function _bigNthRoot(a, root) {
    var precision = type.BigNumber.precision;
    var Big = type.BigNumber.clone({precision: precision + 2});
    var zero = new type.BigNumber(0);

    var one = new Big(1);
    var inv = root.isNegative();
    if (inv) {
      root = root.neg();
    }

    if (root.isZero()) {
      throw new Error('Root must be non-zero');
    }
    if (a.isNegative() && !root.abs().mod(2).equals(1)) {
      throw new Error('Root must be odd when a is negative.');
    }

    // edge cases zero and infinity
    if (a.isZero()) {
      return inv ? new Big(Infinity) : 0;
    }
    if (!a.isFinite()) {
      return inv ? zero : a;
    }

    var x = a.abs().pow(one.div(root));
    // If a < 0, we require that root is an odd integer,
    // so (-1) ^ (1/root) = -1
    x = a.isNeg() ? x.neg() : x;
    return new type.BigNumber((inv ? one.div(x) : x).toPrecision(precision));
  }
}

/**
 * Calculate the nth root of a, solve x^root == a
 * http://rosettacode.org/wiki/Nth_root#JavaScript
 * @param {number} a
 * @param {number} root
 * @private
 */
function _nthRoot(a, root) {
  var inv = root < 0;
  if (inv) {
    root = -root;
  }

  if (root === 0) {
    throw new Error('Root must be non-zero');
  }
  if (a < 0 && (Math.abs(root) % 2 != 1)) {
    throw new Error('Root must be odd when a is negative.');
  }

  // edge cases zero and infinity
  if (a == 0) {
    return inv ? Infinity : 0;
  }
  if (!isFinite(a)) {
    return inv ? 0 : a;
  }

  var x = Math.pow(Math.abs(a), 1/root);
  // If a < 0, we require that root is an odd integer,
  // so (-1) ^ (1/root) = -1
  x = a < 0 ? -x : x;
  return inv ? 1 / x : x;

  // Very nice algorithm, but fails with nthRoot(-2, 3).
  // Newton's method has some well-known problems at times:
  // https://en.wikipedia.org/wiki/Newton%27s_method#Failure_analysis
  /*
  var x = 1; // Initial guess
  var xPrev = 1;
  var i = 0;
  var iMax = 10000;
  do {
    var delta = (a / Math.pow(x, root - 1) - x) / root;
    xPrev = x;
    x = x + delta;
    i++;
  }
  while (xPrev !== x && i < iMax);

  if (xPrev !== x) {
    throw new Error('Function nthRoot failed to converge');
  }

  return inv ? 1 / x : x;
  */
}

/**
 * Calculate the nth root of a Complex Number a using De Moviers Theorem.
 * @param  {Complex} a
 * @param  {number} root
 * @return {Array} array or n Complex Roots in Polar Form.
 */
function _nthComplexRoot(a, root) {
  if (root < 0) throw new Error('Root must be greater than zero');
  if (root === 0) throw new Error('Root must be non-zero');
  if (root % 1 !== 0) throw new Error('Root must be an integer');  
  var arg = a.arg();
  var abs = a.abs();
  var roots = [];
  var r = Math.pow(abs, 1/root);
  for(var k = 0; k < root; k++) {
    roots.push({r: r, phi: (arg + 2 * Math.PI * k)/root});
  }
  return roots;
}

exports.name = 'nthRoot';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../type/matrix/utils/algorithm01":438,"../../type/matrix/utils/algorithm02":439,"../../type/matrix/utils/algorithm06":443,"../../type/matrix/utils/algorithm11":448,"../../type/matrix/utils/algorithm13":450,"../../type/matrix/utils/algorithm14":451}],279:[function(require,module,exports){
'use strict';

var isInteger = require('../../utils/number').isInteger;
var size = require('../../utils/array').size;

function factory (type, config, load, typed) {
  var latex = require('../../utils/latex');
  var eye = load(require('../matrix/eye'));
  var multiply = load(require('./multiply'));
  var matrix = load(require('../../type/matrix/function/matrix'));
  var fraction = load(require('../../type/fraction/function/fraction'));
  var number = load(require('../../type/number'));

  /**
   * Calculates the power of x to y, `x ^ y`.
   * Matrix exponentiation is supported for square matrices `x`, and positive
   * integer exponents `y`.
   *
   * For cubic roots of negative numbers, the function returns the principal
   * root by default. In order to let the function return the real root,
   * math.js can be configured with `math.config({predictable: true})`.
   * To retrieve all cubic roots of a value, use `math.cbrt(x, true)`.
   *
   * Syntax:
   *
   *    math.pow(x, y)
   *
   * Examples:
   *
   *    math.pow(2, 3);               // returns number 8
   *
   *    var a = math.complex(2, 3);
   *    math.pow(a, 2)                // returns Complex -5 + 12i
   *
   *    var b = [[1, 2], [4, 3]];
   *    math.pow(b, 2);               // returns Array [[9, 8], [16, 17]]
   *
   * See also:
   *
   *    multiply, sqrt, cbrt, nthRoot
   *
   * @param  {number | BigNumber | Complex | Array | Matrix} x  The base
   * @param  {number | BigNumber | Complex} y                   The exponent
   * @return {number | BigNumber | Complex | Array | Matrix} The value of `x` to the power `y`
   */
  var pow = typed('pow', {
    'number, number': _pow,

    'Complex, Complex': function (x, y) {
      return x.pow(y);
    },

    'BigNumber, BigNumber': function (x, y) {
      if (y.isInteger() || x >= 0 || config.predictable) {
        return x.pow(y);
      }
      else {
        return new type.Complex(x.toNumber(), 0).pow(y.toNumber(), 0);
      }
    },

    'Fraction, Fraction': function (x, y) {
      if (y.d !== 1) {
        if (config.predictable) {
          throw new Error('Function pow does not support non-integer exponents for fractions.');
        }
        else {
          return _pow(x.valueOf(), y.valueOf());
        }
      }
      else {
        return x.pow(y);
     }
    },

    'Array, number': _powArray,

    'Array, BigNumber': function (x, y) {
      return _powArray(x, y.toNumber());
    },

    'Matrix, number': _powMatrix,

    'Matrix, BigNumber': function (x, y) {
      return _powMatrix(x, y.toNumber());
    },

    'Unit, number': function (x, y) {
      return x.pow(y);
    }

  });

  /**
   * Calculates the power of x to y, x^y, for two numbers.
   * @param {number} x
   * @param {number} y
   * @return {number | Complex} res
   * @private
   */
  function _pow(x, y) {

    // Alternatively could define a 'realmode' config option or something, but
    // 'predictable' will work for now
    if (config.predictable && !isInteger(y) && x < 0) {
      // Check to see if y can be represented as a fraction
      try {
        var yFrac = fraction(y);
        var yNum = number(yFrac);
        if(y === yNum || Math.abs((y - yNum) / y) < 1e-14) {
          if(yFrac.d % 2 === 1) {
            return (yFrac.n % 2 === 0 ? 1 : -1) * Math.pow(-x, y);
          }
        }
      }
      catch (ex) {
        // fraction() throws an error if y is Infinity, etc.
      }

      // Unable to express y as a fraction, so continue on
    }

    if (isInteger(y) || x >= 0 || config.predictable) {
      return Math.pow(x, y);
    }
    else {
      return new type.Complex(x, 0).pow(y, 0);
    }
  }

  /**
   * Calculate the power of a 2d array
   * @param {Array} x     must be a 2 dimensional, square matrix
   * @param {number} y    a positive, integer value
   * @returns {Array}
   * @private
   */
  function _powArray(x, y) {
    if (!isInteger(y) || y < 0) {
      throw new TypeError('For A^b, b must be a positive integer (value is ' + y + ')');
    }
    // verify that A is a 2 dimensional square matrix
    var s = size(x);
    if (s.length != 2) {
      throw new Error('For A^b, A must be 2 dimensional (A has ' + s.length + ' dimensions)');
    }
    if (s[0] != s[1]) {
      throw new Error('For A^b, A must be square (size is ' + s[0] + 'x' + s[1] + ')');
    }

    var res = eye(s[0]).valueOf();
    var px = x;
    while (y >= 1) {
      if ((y & 1) == 1) {
        res = multiply(px, res);
      }
      y >>= 1;
      px = multiply(px, px);
    }
    return res;
  }

  /**
   * Calculate the power of a 2d matrix
   * @param {Matrix} x     must be a 2 dimensional, square matrix
   * @param {number} y    a positive, integer value
   * @returns {Matrix}
   * @private
   */
  function _powMatrix (x, y) {
    return matrix(_powArray(x.valueOf(), y));
  }



  pow.toTex = '\\left(${args[0]}\\right)' + latex.operators['pow'] + '{${args[1]}}';

  return pow;
}

exports.name = 'pow';
exports.factory = factory;

},{"../../type/fraction/function/fraction":423,"../../type/matrix/function/matrix":435,"../../type/number":452,"../../utils/array":461,"../../utils/latex":482,"../../utils/number":483,"../matrix/eye":320,"./multiply":275}],280:[function(require,module,exports){
'use strict';

var isInteger = require('../../utils/number').isInteger;
var toFixed = require('../../utils/number').toFixed;
var deepMap = require('../../utils/collection/deepMap');

var NO_INT = 'Number of decimals in function round must be an integer';

function factory (type, config, load, typed) {
  var matrix = load(require('../../type/matrix/function/matrix'));
  var equalScalar = load(require('../relational/equalScalar'));
  var zeros = load(require('../matrix/zeros'));

  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));
  var algorithm12 = load(require('../../type/matrix/utils/algorithm12'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));
  
  /**
   * Round a value towards the nearest integer.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.round(x)
   *    math.round(x, n)
   *
   * Examples:
   *
   *    math.round(3.2);              // returns number 3
   *    math.round(3.8);              // returns number 4
   *    math.round(-4.2);             // returns number -4
   *    math.round(-4.7);             // returns number -5
   *    math.round(math.pi, 3);       // returns number 3.142
   *    math.round(123.45678, 2);     // returns number 123.46
   *
   *    var c = math.complex(3.2, -2.7);
   *    math.round(c);                // returns Complex 3 - 3i
   *
   *    math.round([3.2, 3.8, -4.7]); // returns Array [3, 4, -5]
   *
   * See also:
   *
   *    ceil, fix, floor
   *
   * @param  {number | BigNumber | Fraction | Complex | Array | Matrix} x  Number to be rounded
   * @param  {number | BigNumber | Array} [n=0]                            Number of decimals
   * @return {number | BigNumber | Fraction | Complex | Array | Matrix} Rounded value
   */
  var round = typed('round', {

    'number': Math.round,

    'number, number': function (x, n) {
      if (!isInteger(n))   {throw new TypeError(NO_INT);}
      if (n < 0 || n > 15) {throw new Error('Number of decimals in function round must be in te range of 0-15');}

      return _round(x, n);
    },

    'Complex': function (x) {
      return x.round();
    },

    'Complex, number': function (x, n) {
      if (n % 1) {throw new TypeError(NO_INT);}
      
      return x.round(n);
    },

    'Complex, BigNumber': function (x, n) {
      if (!n.isInteger()) {throw new TypeError(NO_INT);}

      var _n = n.toNumber();
      return x.round(_n);
    },

    'number, BigNumber': function (x, n) {
      if (!n.isInteger()) {throw new TypeError(NO_INT);}

      return new type.BigNumber(x).toDecimalPlaces(n.toNumber());
    },

    'BigNumber': function (x) {
      return x.toDecimalPlaces(0);
    },

    'BigNumber, BigNumber': function (x, n) {
      if (!n.isInteger()) {throw new TypeError(NO_INT);}

      return x.toDecimalPlaces(n.toNumber());
    },

    'Fraction': function (x) {
      return x.round();
    },

    'Fraction, number': function (x, n) {
      if (n % 1) {throw new TypeError(NO_INT);}
      return x.round(n);
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since round(0) = 0
      return deepMap(x, round, true);
    },

    'Matrix, number | BigNumber': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm11(x, y, round, false);
          break;
        default:
          c = algorithm14(x, y, round, false);
          break;
      }
      return c;
    },

    'number | Complex | BigNumber, Matrix': function (x, y) {
      // check scalar is zero
      if (!equalScalar(x, 0)) {
        // result
        var c;
        // check storage format
        switch (y.storage()) {
          case 'sparse':
            c = algorithm12(y, x, round, true);
            break;
          default:
            c = algorithm14(y, x, round, true);
            break;
        }
        return c;
      }
      // do not execute algorithm, result will be a zero matrix
      return zeros(y.size(), y.storage());
    },

    'Array, number | BigNumber': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, round, false).valueOf();
    },

    'number | Complex | BigNumber, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, round, true).valueOf();
    }
  });

  round.toTex = {
    1: '\\left\\lfloor${args[0]}\\right\\rceil',
    2: '\\mathrm{${name}}\\left(${args}\\right)'
  };

  return round;
}

/**
 * round a number to the given number of decimals, or to zero if decimals is
 * not provided
 * @param {number} value
 * @param {number} decimals       number of decimals, between 0 and 15 (0 by default)
 * @return {number} roundedValue
 * @private
 */
function _round (value, decimals) {
  return parseFloat(toFixed(value, decimals));
}

exports.name = 'round';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../type/matrix/utils/algorithm11":448,"../../type/matrix/utils/algorithm12":449,"../../type/matrix/utils/algorithm14":451,"../../utils/collection/deepMap":475,"../../utils/number":483,"../matrix/zeros":337,"../relational/equalScalar":352}],281:[function(require,module,exports){
'use strict';

var number = require('../../utils/number');
var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Compute the sign of a value. The sign of a value x is:
   *
   * -  1 when x > 1
   * - -1 when x < 0
   * -  0 when x == 0
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.sign(x)
   *
   * Examples:
   *
   *    math.sign(3.5);               // returns 1
   *    math.sign(-4.2);              // returns -1
   *    math.sign(0);                 // returns 0
   *
   *    math.sign([3, 5, -2, 0, 2]);  // returns [1, 1, -1, 0, 1]
   *
   * See also:
   *
   *    abs
   *
   * @param  {number | BigNumber | Fraction | Complex | Array | Matrix | Unit} x
   *            The number for which to determine the sign
   * @return {number | BigNumber | Fraction | Complex | Array | Matrix | Unit}e
   *            The sign of `x`
   */
  var sign = typed('sign', {
    'number': number.sign,

    'Complex': function (x) {
      return x.sign();
    },

    'BigNumber': function (x) {
      return new type.BigNumber(x.cmp(0));
    },

    'Fraction': function (x) {
      return new type.Fraction(x.s, 1);
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since sign(0) = 0
      return deepMap(x, sign, true);
    },

    'Unit': function(x) {
      return sign(x.value);
    }
  });

  sign.toTex = '\\mathrm{${name}}\\left(${args}\\right)';

  return sign;
}

exports.name = 'sign';
exports.factory = factory;


},{"../../utils/collection/deepMap":475,"../../utils/number":483}],282:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Calculate the square root of a value.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.sqrt(x)
   *
   * Examples:
   *
   *    math.sqrt(25);                // returns 5
   *    math.square(5);               // returns 25
   *    math.sqrt(-4);                // returns Complex 2i
   *
   * See also:
   *
   *    square, multiply, cube, cbrt
   *
   * @param {number | BigNumber | Complex | Array | Matrix | Unit} x
   *            Value for which to calculate the square root.
   * @return {number | BigNumber | Complex | Array | Matrix | Unit}
   *            Returns the square root of `x`
   */
  var sqrt = typed('sqrt', {
    'number': _sqrtNumber,

    'Complex': function (x) {
        return x.sqrt();
    },

    'BigNumber': function (x) {
      if (!x.isNegative() || config.predictable) {
        return x.sqrt();
      }
      else {
        // negative value -> downgrade to number to do complex value computation
        return _sqrtNumber(x.toNumber());
      }
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since sqrt(0) = 0
      return deepMap(x, sqrt, true);
    },

    'Unit': function (x) {
      // Someday will work for complex units when they are implemented
      return x.pow(0.5);
    }

  });

  /**
   * Calculate sqrt for a number
   * @param {number} x
   * @returns {number | Complex} Returns the square root of x
   * @private
   */
  function _sqrtNumber(x) {
    if (x >= 0 || config.predictable) {
      return Math.sqrt(x);
    }
    else {
      return new type.Complex(x, 0).sqrt();
    }
  }

  sqrt.toTex = '\\sqrt{${args[0]}}';

  return sqrt;
}

exports.name = 'sqrt';
exports.factory = factory;

},{"../../utils/collection/deepMap":475}],283:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Compute the square of a value, `x * x`.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.square(x)
   *
   * Examples:
   *
   *    math.square(2);           // returns number 4
   *    math.square(3);           // returns number 9
   *    math.pow(3, 2);           // returns number 9
   *    math.multiply(3, 3);      // returns number 9
   *
   *    math.square([1, 2, 3, 4]);  // returns Array [1, 4, 9, 16]
   *
   * See also:
   *
   *    multiply, cube, sqrt, pow
   *
   * @param  {number | BigNumber | Fraction | Complex | Array | Matrix | Unit} x
   *            Number for which to calculate the square
   * @return {number | BigNumber | Fraction | Complex | Array | Matrix | Unit}
   *            Squared value
   */
  var square = typed('square', {
    'number': function (x) {
      return x * x;
    },

    'Complex': function (x) {
      return x.mul(x);
    },

    'BigNumber': function (x) {
      return x.times(x);
    },

    'Fraction': function (x) {
      return x.mul(x);
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since square(0) = 0
      return deepMap(x, square, true);
    },

    'Unit': function(x) {
      return x.pow(2);
    }
  });

  square.toTex = '\\left(${args[0]}\\right)^2';

  return square;
}

exports.name = 'square';
exports.factory = factory;

},{"../../utils/collection/deepMap":475}],284:[function(require,module,exports){
'use strict';

var DimensionError = require('../../error/DimensionError');

function factory (type, config, load, typed) {
  var latex = require('../../utils/latex');

  var matrix = load(require('../../type/matrix/function/matrix'));
  var addScalar = load(require('./addScalar'));
  var unaryMinus = load(require('./unaryMinus'));

  var algorithm01 = load(require('../../type/matrix/utils/algorithm01'));
  var algorithm03 = load(require('../../type/matrix/utils/algorithm03'));
  var algorithm05 = load(require('../../type/matrix/utils/algorithm05'));
  var algorithm10 = load(require('../../type/matrix/utils/algorithm10'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

  // TODO: split function subtract in two: subtract and subtractScalar

  /**
   * Subtract two values, `x - y`.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.subtract(x, y)
   *
   * Examples:
   *
   *    math.subtract(5.3, 2);        // returns number 3.3
   *
   *    var a = math.complex(2, 3);
   *    var b = math.complex(4, 1);
   *    math.subtract(a, b);          // returns Complex -2 + 2i
   *
   *    math.subtract([5, 7, 4], 4);  // returns Array [1, 3, 0]
   *
   *    var c = math.unit('2.1 km');
   *    var d = math.unit('500m');
   *    math.subtract(c, d);          // returns Unit 1.6 km
   *
   * See also:
   *
   *    add
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x
   *            Initial value
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y
   *            Value to subtract from `x`
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}
   *            Subtraction of `x` and `y`
   */
  var subtract = typed('subtract', {

    'number, number': function (x, y) {
      return x - y;
    },

    'Complex, Complex': function (x, y) {
      return x.sub(y);
    },

    'BigNumber, BigNumber': function (x, y) {
      return x.minus(y);
    },

    'Fraction, Fraction': function (x, y) {
      return x.sub(y);
    },

    'Unit, Unit': function (x, y) {
      if (x.value == null) {
        throw new Error('Parameter x contains a unit with undefined value');
      }

      if (y.value == null) {
        throw new Error('Parameter y contains a unit with undefined value');
      }

      if (!x.equalBase(y)) {
        throw new Error('Units do not match');
      }

      var res = x.clone();
      res.value = subtract(res.value, y.value);
      res.fixPrefix = false;

      return res;
    },
    
    'Matrix, Matrix': function (x, y) {
      // matrix sizes
      var xsize = x.size();
      var ysize = y.size();

      // check dimensions
      if (xsize.length !== ysize.length)
        throw new DimensionError(xsize.length, ysize.length);

      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse - sparse
              c = algorithm05(x, y, subtract);
              break;
            default:
              // sparse - dense
              c = algorithm03(y, x, subtract, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense - sparse
              c = algorithm01(x, y, subtract, false);
              break;
            default:
              // dense - dense
              c = algorithm13(x, y, subtract);
              break;
          }
          break;
      }
      return c;
    },
    
    'Array, Array': function (x, y) {
      // use matrix implementation
      return subtract(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return subtract(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return subtract(x, matrix(y));
    },
    
    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          // algorithm 7 is faster than 9 since it calls f() for nonzero items only!
          c = algorithm10(x, unaryMinus(y), addScalar);
          break;
        default:
          c = algorithm14(x, y, subtract);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm10(y, x, subtract, true);
          break;
        default:
          c = algorithm14(y, x, subtract, true);
          break;
      }
      return c;
    },

    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, subtract, false).valueOf();
    },

    'any, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, subtract, true).valueOf();
    }
  });

  subtract.toTex = '\\left(${args[0]}' + latex.operators['subtract'] + '${args[1]}\\right)';

  return subtract;
}

exports.name = 'subtract';
exports.factory = factory;

},{"../../error/DimensionError":11,"../../type/matrix/function/matrix":435,"../../type/matrix/utils/algorithm01":438,"../../type/matrix/utils/algorithm03":440,"../../type/matrix/utils/algorithm05":442,"../../type/matrix/utils/algorithm10":447,"../../type/matrix/utils/algorithm13":450,"../../type/matrix/utils/algorithm14":451,"../../utils/latex":482,"./addScalar":256,"./unaryMinus":285}],285:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  var latex = require('../../utils/latex');

  /**
   * Inverse the sign of a value, apply a unary minus operation.
   *
   * For matrices, the function is evaluated element wise. Boolean values and
   * strings will be converted to a number. For complex numbers, both real and
   * complex value are inverted.
   *
   * Syntax:
   *
   *    math.unaryMinus(x)
   *
   * Examples:
   *
   *    math.unaryMinus(3.5);      // returns -3.5
   *    math.unaryMinus(-4.2);     // returns 4.2
   *
   * See also:
   *
   *    add, subtract, unaryPlus
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x Number to be inverted.
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} Returns the value with inverted sign.
   */
  var unaryMinus = typed('unaryMinus', {
    'number': function (x) {
      return -x;
    },

    'Complex': function (x) {
      return x.neg();
    },

    'BigNumber': function (x) {
      return x.neg();
    },

    'Fraction': function (x) {
      return x.neg();
    },

    'Unit': function (x) {
      var res = x.clone();
      res.value = unaryMinus(x.value);
      return res;
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since unaryMinus(0) = 0
      return deepMap(x, unaryMinus, true);
    }

    // TODO: add support for string
  });

  unaryMinus.toTex = latex.operators['unaryMinus'] + '\\left(${args[0]}\\right)';

  return unaryMinus;
}

exports.name = 'unaryMinus';
exports.factory = factory;

},{"../../utils/collection/deepMap":475,"../../utils/latex":482}],286:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  var latex = require('../../utils/latex');

  /**
   * Unary plus operation.
   * Boolean values and strings will be converted to a number, numeric values will be returned as is.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.unaryPlus(x)
   *
   * Examples:
   *
   *    math.unaryPlus(3.5);      // returns 3.5
   *    math.unaryPlus(1);     // returns 1
   *
   * See also:
   *
   *    unaryMinus, add, subtract
   *
   * @param  {number | BigNumber | Fraction | string | Complex | Unit | Array | Matrix} x
   *            Input value
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}
   *            Returns the input value when numeric, converts to a number when input is non-numeric.
   */
  var unaryPlus = typed('unaryPlus', {
    'number': function (x) {
      return x;
    },

    'Complex': function (x) {
      return x; // complex numbers are immutable
    },

    'BigNumber': function (x) {
      return x; // bignumbers are immutable
    },

    'Fraction': function (x) {
      return x; // fractions are immutable
    },

    'Unit': function (x) {
      return x.clone();
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since unaryPlus(0) = 0
      return deepMap(x, unaryPlus, true);
    },

    'boolean | string | null': function (x) {
      // convert to a number or bignumber
      return (config.number == 'BigNumber') ? new type.BigNumber(+x): +x;
    }
  });

  unaryPlus.toTex = latex.operators['unaryPlus'] + '\\left(${args[0]}\\right)'

  return unaryPlus;
}

exports.name = 'unaryPlus';
exports.factory = factory;

},{"../../utils/collection/deepMap":475,"../../utils/latex":482}],287:[function(require,module,exports){
'use strict';

var isInteger = require('../../utils/number').isInteger;

function factory (type, config, load, typed) {
  var matrix = load(require('../../type/matrix/function/matrix'));

  /**
   * Calculate the extended greatest common divisor for two values.
   * See http://en.wikipedia.org/wiki/Extended_Euclidean_algorithm.
   *
   * Syntax:
   *
   *    math.xgcd(a, b)
   *
   * Examples:
   *
   *    math.xgcd(8, 12);             // returns [4, -1, 1]
   *    math.gcd(8, 12);              // returns 4
   *    math.xgcd(36163, 21199);      // returns [1247, -7, 12]
   *
   * See also:
   *
   *    gcd, lcm
   *
   * @param {number | BigNumber} a  An integer number
   * @param {number | BigNumber} b  An integer number
   * @return {Array}              Returns an array containing 3 integers `[div, m, n]`
   *                              where `div = gcd(a, b)` and `a*m + b*n = div`
   */
  var xgcd = typed('xgcd', {
    'number, number': _xgcd,
    'BigNumber, BigNumber': _xgcdBigNumber
    // TODO: implement support for Fraction
  });

  xgcd.toTex = '\\mathrm{${name}}\\left(${args}\\right)';

  return xgcd;

  /**
   * Calculate xgcd for two numbers
   * @param {number} a
   * @param {number} b
   * @return {number} result
   * @private
   */
  function _xgcd (a, b) {
    // source: http://en.wikipedia.org/wiki/Extended_Euclidean_algorithm
    var t, // used to swap two variables
        q, // quotient
        r, // remainder
        x = 0, lastx = 1,
        y = 1, lasty = 0;

    if (!isInteger(a) || !isInteger(b)) {
      throw new Error('Parameters in function xgcd must be integer numbers');
    }

    while (b) {
      q = Math.floor(a / b);
      r = a % b;

      t = x;
      x = lastx - q * x;
      lastx = t;

      t = y;
      y = lasty - q * y;
      lasty = t;

      a = b;
      b = r;
    }

    var res;
    if (a < 0) {
      res = [-a, -lastx, -lasty];
    }
    else {
      res = [a, a ? lastx : 0, lasty];
    }
    return (config.matrix === 'Array') ? res : matrix(res);
  }

  /**
   * Calculate xgcd for two BigNumbers
   * @param {BigNumber} a
   * @param {BigNumber} b
   * @return {BigNumber[]} result
   * @private
   */
  function _xgcdBigNumber(a, b) {
    // source: http://en.wikipedia.org/wiki/Extended_Euclidean_algorithm
    var t, // used to swap two variables
        q, // quotient
        r, // remainder
        zero = new type.BigNumber(0),
        one = new type.BigNumber(1),
        x = zero,
        lastx = one,
        y = one,
        lasty = zero;

    if (!a.isInt() || !b.isInt()) {
      throw new Error('Parameters in function xgcd must be integer numbers');
    }

    //console.log('start', [a, b].toString())

    while (!b.isZero()) {
      //console.log('inner', [a, b, t, q, r, x, y, lastx, lasty].toString());
      q = a.div(b).floor();
      r = a.mod(b);
      //console.log('MOD', [a, b, a.mod(b), r].toString())

      t = x;
      x = lastx.minus(q.times(x));
      lastx = t;

      t = y;
      y = lasty.minus(q.times(y));
      lasty = t;

      a = b;
      b = r;

      //console.log('inner end', [a, b, t, q, r, x, y, lastx, lasty].toString());
    }

    //console.log('end', [a, lastx, lasty].toString())

    var res;
    if (a.lt(zero)) {
      res = [a.neg(), lastx.neg(), lasty.neg()];
    }
    else {
      res = [a, !a.isZero() ? lastx : 0, lasty];
    }
    return (config.matrix === 'Array') ? res : matrix(res);
  }
}

exports.name = 'xgcd';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../utils/number":483}],288:[function(require,module,exports){
'use strict';

var isInteger = require('../../utils/number').isInteger;
var bigBitAnd = require('../../utils/bignumber/bitAnd');

function factory (type, config, load, typed) {
  var latex = require('../../utils/latex');

  var matrix = load(require('../../type/matrix/function/matrix'));

  var algorithm02 = load(require('../../type/matrix/utils/algorithm02'));
  var algorithm06 = load(require('../../type/matrix/utils/algorithm06'));
  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));
  
  /**
   * Bitwise AND two values, `x & y`.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.bitAnd(x, y)
   *
   * Examples:
   *
   *    math.bitAnd(53, 131);               // returns number 1
   *
   *    math.bitAnd([1, 12, 31], 42);       // returns Array [0, 8, 10]
   *
   * See also:
   *
   *    bitNot, bitOr, bitXor, leftShift, rightArithShift, rightLogShift
   *
   * @param  {number | BigNumber | Array | Matrix} x First value to and
   * @param  {number | BigNumber | Array | Matrix} y Second value to and
   * @return {number | BigNumber | Array | Matrix} AND of `x` and `y`
   */
  var bitAnd = typed('bitAnd', {

    'number, number': function (x, y) {
      if (!isInteger(x) || !isInteger(y)) {
        throw new Error('Integers expected in function bitAnd');
      }

      return x & y;
    },

    'BigNumber, BigNumber': bigBitAnd,

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse & sparse
              c = algorithm06(x, y, bitAnd, false);
              break;
            default:
              // sparse & dense
              c = algorithm02(y, x, bitAnd, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense & sparse
              c = algorithm02(x, y, bitAnd, false);
              break;
            default:
              // dense & dense
              c = algorithm13(x, y, bitAnd);
              break;
          }
          break;
      }
      return c;
    },
    
    'Array, Array': function (x, y) {
      // use matrix implementation
      return bitAnd(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return bitAnd(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return bitAnd(x, matrix(y));
    },
    
    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm11(x, y, bitAnd, false);
          break;
        default:
          c = algorithm14(x, y, bitAnd, false);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm11(y, x, bitAnd, true);
          break;
        default:
          c = algorithm14(y, x, bitAnd, true);
          break;
      }
      return c;
    },

    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, bitAnd, false).valueOf();
    },

    'any, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, bitAnd, true).valueOf();
    }
  });

  bitAnd.toTex = '\\left(${args[0]}' + latex.operators['bitAnd'] + '${args[1]}\\right)';

  return bitAnd;
}

exports.name = 'bitAnd';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../type/matrix/utils/algorithm02":439,"../../type/matrix/utils/algorithm06":443,"../../type/matrix/utils/algorithm11":448,"../../type/matrix/utils/algorithm13":450,"../../type/matrix/utils/algorithm14":451,"../../utils/bignumber/bitAnd":462,"../../utils/latex":482,"../../utils/number":483}],289:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');
var bigBitNot = require('../../utils/bignumber/bitNot');
var isInteger = require('../../utils/number').isInteger;

function factory (type, config, load, typed) {
  var latex = require('../../utils/latex');

  /**
   * Bitwise NOT value, `~x`.
   * For matrices, the function is evaluated element wise.
   * For units, the function is evaluated on the best prefix base.
   *
   * Syntax:
   *
   *    math.bitNot(x)
   *
   * Examples:
   *
   *    math.bitNot(1);               // returns number -2
   *
   *    math.bitNot([2, -3, 4]);      // returns Array [-3, 2, 5]
   *
   * See also:
   *
   *    bitAnd, bitOr, bitXor, leftShift, rightArithShift, rightLogShift
   *
   * @param  {number | BigNumber | Array | Matrix} x Value to not
   * @return {number | BigNumber | Array | Matrix} NOT of `x`
   */
  var bitNot = typed('bitNot', {
    'number': function (x) {
      if (!isInteger(x)) {
        throw new Error('Integer expected in function bitNot');
      }

      return ~x;
    },

    'BigNumber': bigBitNot,

    'Array | Matrix': function (x) {
      return deepMap(x, bitNot);
    }
  });

  bitNot.toTex = latex.operators['bitNot'] + '\\left(${args[0]}\\right)';

  return bitNot;
}

exports.name = 'bitNot';
exports.factory = factory;

},{"../../utils/bignumber/bitNot":463,"../../utils/collection/deepMap":475,"../../utils/latex":482,"../../utils/number":483}],290:[function(require,module,exports){
'use strict';

var isInteger = require('../../utils/number').isInteger;
var bigBitOr = require('../../utils/bignumber/bitOr');

function factory (type, config, load, typed) {
  var latex = require('../../utils/latex');

  var matrix = load(require('../../type/matrix/function/matrix'));

  var algorithm01 = load(require('../../type/matrix/utils/algorithm01'));
  var algorithm04 = load(require('../../type/matrix/utils/algorithm04'));
  var algorithm10 = load(require('../../type/matrix/utils/algorithm10'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));
  
  /**
   * Bitwise OR two values, `x | y`.
   * For matrices, the function is evaluated element wise.
   * For units, the function is evaluated on the lowest print base.
   *
   * Syntax:
   *
   *    math.bitOr(x, y)
   *
   * Examples:
   *
   *    math.bitOr(1, 2);               // returns number 3
   *
   *    math.bitOr([1, 2, 3], 4);       // returns Array [5, 6, 7]
   *
   * See also:
   *
   *    bitAnd, bitNot, bitXor, leftShift, rightArithShift, rightLogShift
   *
   * @param  {number | BigNumber | Array | Matrix} x First value to or
   * @param  {number | BigNumber | Array | Matrix} y Second value to or
   * @return {number | BigNumber | Array | Matrix} OR of `x` and `y`
   */
  var bitOr = typed('bitOr', {

    'number, number': function (x, y) {
      if (!isInteger(x) || !isInteger(y)) {
        throw new Error('Integers expected in function bitOr');
      }

      return x | y;
    },

    'BigNumber, BigNumber': bigBitOr,

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse + sparse
              c = algorithm04(x, y, bitOr);
              break;
            default:
              // sparse + dense
              c = algorithm01(y, x, bitOr, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense + sparse
              c = algorithm01(x, y, bitOr, false);
              break;
            default:
              c = algorithm13(x, y, bitOr);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return bitOr(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return bitOr(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return bitOr(x, matrix(y));
    },

    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm10(x, y, bitOr, false);
          break;
        default:
          c = algorithm14(x, y, bitOr, false);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm10(y, x, bitOr, true);
          break;
        default:
          c = algorithm14(y, x, bitOr, true);
          break;
      }
      return c;
    },

    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, bitOr, false).valueOf();
    },

    'any, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, bitOr, true).valueOf();
    }
  });

  bitOr.toTex = '\\left(${args[0]}' + latex.operators['bitOr'] + '${args[1]}\\right)';

  return bitOr;
}

exports.name = 'bitOr';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../type/matrix/utils/algorithm01":438,"../../type/matrix/utils/algorithm04":441,"../../type/matrix/utils/algorithm10":447,"../../type/matrix/utils/algorithm13":450,"../../type/matrix/utils/algorithm14":451,"../../utils/bignumber/bitOr":464,"../../utils/latex":482,"../../utils/number":483}],291:[function(require,module,exports){
'use strict';

var isInteger = require('../../utils/number').isInteger;
var bigBitXor = require('../../utils/bignumber/bitXor');

function factory (type, config, load, typed) {
  var latex = require('../../utils/latex');

  var matrix = load(require('../../type/matrix/function/matrix'));

  var algorithm03 = load(require('../../type/matrix/utils/algorithm03'));
  var algorithm07 = load(require('../../type/matrix/utils/algorithm07'));
  var algorithm12 = load(require('../../type/matrix/utils/algorithm12'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

  /**
   * Bitwise XOR two values, `x ^ y`.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.bitXor(x, y)
   *
   * Examples:
   *
   *    math.bitXor(1, 2);               // returns number 3
   *
   *    math.bitXor([2, 3, 4], 4);       // returns Array [6, 7, 0]
   *
   * See also:
   *
   *    bitAnd, bitNot, bitOr, leftShift, rightArithShift, rightLogShift
   *
   * @param  {number | BigNumber | Array | Matrix} x First value to xor
   * @param  {number | BigNumber | Array | Matrix} y Second value to xor
   * @return {number | BigNumber | Array | Matrix} XOR of `x` and `y`
   */
  var bitXor = typed('bitXor', {

    'number, number': function (x, y) {
      if (!isInteger(x) || !isInteger(y)) {
        throw new Error('Integers expected in function bitXor');
      }

      return x ^ y;
    },

    'BigNumber, BigNumber': bigBitXor,

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse + sparse
              c = algorithm07(x, y, bitXor);
              break;
            default:
              // sparse + dense
              c = algorithm03(y, x, bitXor, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense + sparse
              c = algorithm03(x, y, bitXor, false);
              break;
            default:
              // dense + dense
              c = algorithm13(x, y, bitXor);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return bitXor(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return bitXor(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return bitXor(x, matrix(y));
    },

    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm12(x, y, bitXor, false);
          break;
        default:
          c = algorithm14(x, y, bitXor, false);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm12(y, x, bitXor, true);
          break;
        default:
          c = algorithm14(y, x, bitXor, true);
          break;
      }
      return c;
    },

    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, bitXor, false).valueOf();
    },

    'any, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, bitXor, true).valueOf();
    }
  });

  bitXor.toTex = '\\left(${args[0]}' + latex.operators['bitXor'] + '${args[1]}\\right)';

  return bitXor;
}

exports.name = 'bitXor';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../type/matrix/utils/algorithm03":440,"../../type/matrix/utils/algorithm07":444,"../../type/matrix/utils/algorithm12":449,"../../type/matrix/utils/algorithm13":450,"../../type/matrix/utils/algorithm14":451,"../../utils/bignumber/bitXor":465,"../../utils/latex":482,"../../utils/number":483}],292:[function(require,module,exports){
module.exports = [
  require('./bitAnd'),
  require('./bitNot'),
  require('./bitOr'),
  require('./bitXor'),
  require('./leftShift'),
  require('./rightArithShift'),
  require('./rightLogShift')
];

},{"./bitAnd":288,"./bitNot":289,"./bitOr":290,"./bitXor":291,"./leftShift":293,"./rightArithShift":294,"./rightLogShift":295}],293:[function(require,module,exports){
'use strict';

var isInteger = require('../../utils/number').isInteger;
var bigLeftShift = require('../../utils/bignumber/leftShift');

function factory (type, config, load, typed) {
  var latex = require('../../utils/latex');

  var matrix = load(require('../../type/matrix/function/matrix'));
  var equalScalar = load(require('../relational/equalScalar'));
  var zeros = load(require('../matrix/zeros'));

  var algorithm01 = load(require('../../type/matrix/utils/algorithm01'));
  var algorithm02 = load(require('../../type/matrix/utils/algorithm02'));
  var algorithm08 = load(require('../../type/matrix/utils/algorithm08'));
  var algorithm10 = load(require('../../type/matrix/utils/algorithm10'));
  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

  /**
   * Bitwise left logical shift of a value x by y number of bits, `x << y`.
   * For matrices, the function is evaluated element wise.
   * For units, the function is evaluated on the best prefix base.
   *
   * Syntax:
   *
   *    math.leftShift(x, y)
   *
   * Examples:
   *
   *    math.leftShift(1, 2);               // returns number 4
   *
   *    math.leftShift([1, 2, 3], 4);       // returns Array [16, 32, 64]
   *
   * See also:
   *
   *    leftShift, bitNot, bitOr, bitXor, rightArithShift, rightLogShift
   *
   * @param  {number | BigNumber | Array | Matrix} x Value to be shifted
   * @param  {number | BigNumber} y Amount of shifts
   * @return {number | BigNumber | Array | Matrix} `x` shifted left `y` times
   */
  var leftShift = typed('leftShift', {
    
    'number, number': function (x, y) {
      if (!isInteger(x) || !isInteger(y)) {
        throw new Error('Integers expected in function leftShift');
      }

      return x << y;
    },

    'BigNumber, BigNumber': bigLeftShift,

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse & sparse
              c = algorithm08(x, y, leftShift, false);
              break;
            default:
              // sparse & dense
              c = algorithm02(y, x, leftShift, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense & sparse
              c = algorithm01(x, y, leftShift, false);
              break;
            default:
              // dense & dense
              c = algorithm13(x, y, leftShift);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return leftShift(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return leftShift(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return leftShift(x, matrix(y));
    },

    'Matrix, number | BigNumber': function (x, y) {
      // check scalar
      if (!equalScalar(y, 0)) {
        // result
        var c;
        // check storage format
        switch (x.storage()) {
          case 'sparse':
            c = algorithm11(x, y, leftShift, false);
            break;
          default:
            c = algorithm14(x, y, leftShift, false);
            break;
        }
        return c;
      }
      return x.clone();
    },

    'number | BigNumber, Matrix': function (x, y) {
      // check scalar
      if (!equalScalar(x, 0)) {
        // result
        var c;
        // check storage format
        switch (y.storage()) {
          case 'sparse':
            c = algorithm10(y, x, leftShift, true);
            break;
          default:
            c = algorithm14(y, x, leftShift, true);
            break;
        }
        return c;
      }
      return zeros(y.size(), y.storage());
    },

    'Array, number | BigNumber': function (x, y) {
      // use matrix implementation
      return leftShift(matrix(x), y).valueOf();
    },

    'number | BigNumber, Array': function (x, y) {
      // use matrix implementation
      return leftShift(x, matrix(y)).valueOf();
    }
  });

  leftShift.toTex = '\\left(${args[0]}' + latex.operators['leftShift'] + '${args[1]}\\right)';

  return leftShift;
}

exports.name = 'leftShift';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../type/matrix/utils/algorithm01":438,"../../type/matrix/utils/algorithm02":439,"../../type/matrix/utils/algorithm08":445,"../../type/matrix/utils/algorithm10":447,"../../type/matrix/utils/algorithm11":448,"../../type/matrix/utils/algorithm13":450,"../../type/matrix/utils/algorithm14":451,"../../utils/bignumber/leftShift":469,"../../utils/latex":482,"../../utils/number":483,"../matrix/zeros":337,"../relational/equalScalar":352}],294:[function(require,module,exports){
'use strict';

var isInteger = require('../../utils/number').isInteger;
var bigRightArithShift = require('../../utils/bignumber/rightArithShift');

function factory (type, config, load, typed) {
  var latex = require('../../utils/latex');
  
  var matrix = load(require('../../type/matrix/function/matrix'));
  var equalScalar = load(require('../relational/equalScalar'));
  var zeros = load(require('../matrix/zeros'));

  var algorithm01 = load(require('../../type/matrix/utils/algorithm01'));
  var algorithm02 = load(require('../../type/matrix/utils/algorithm02'));
  var algorithm08 = load(require('../../type/matrix/utils/algorithm08'));
  var algorithm10 = load(require('../../type/matrix/utils/algorithm10'));
  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

  /**
   * Bitwise right arithmetic shift of a value x by y number of bits, `x >> y`.
   * For matrices, the function is evaluated element wise.
   * For units, the function is evaluated on the best prefix base.
   *
   * Syntax:
   *
   *    math.rightArithShift(x, y)
   *
   * Examples:
   *
   *    math.rightArithShift(4, 2);               // returns number 1
   *
   *    math.rightArithShift([16, -32, 64], 4);   // returns Array [1, -2, 3]
   *
   * See also:
   *
   *    bitAnd, bitNot, bitOr, bitXor, rightArithShift, rightLogShift
   *
   * @param  {number | BigNumber | Array | Matrix} x Value to be shifted
   * @param  {number | BigNumber} y Amount of shifts
   * @return {number | BigNumber | Array | Matrix} `x` sign-filled shifted right `y` times
   */
  var rightArithShift = typed('rightArithShift', {

    'number, number': function (x, y) {
      if (!isInteger(x) || !isInteger(y)) {
        throw new Error('Integers expected in function rightArithShift');
      }

      return x >> y;
    },

    'BigNumber, BigNumber': bigRightArithShift,

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse & sparse
              c = algorithm08(x, y, rightArithShift, false);
              break;
            default:
              // sparse & dense
              c = algorithm02(y, x, rightArithShift, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense & sparse
              c = algorithm01(x, y, rightArithShift, false);
              break;
            default:
              // dense & dense
              c = algorithm13(x, y, rightArithShift);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return rightArithShift(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return rightArithShift(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return rightArithShift(x, matrix(y));
    },

    'Matrix, number | BigNumber': function (x, y) {
      // check scalar
      if (!equalScalar(y, 0)) {
        // result
        var c;
        // check storage format
        switch (x.storage()) {
          case 'sparse':
            c = algorithm11(x, y, rightArithShift, false);
            break;
          default:
            c = algorithm14(x, y, rightArithShift, false);
            break;
        }
        return c;
      }
      return x.clone();
    },

    'number | BigNumber, Matrix': function (x, y) {
      // check scalar
      if (!equalScalar(x, 0)) {
        // result
        var c;
        // check storage format
        switch (y.storage()) {
          case 'sparse':
            c = algorithm10(y, x, rightArithShift, true);
            break;
          default:
            c = algorithm14(y, x, rightArithShift, true);
            break;
        }
        return c;
      }
      return zeros(y.size(), y.storage());
    },

    'Array, number | BigNumber': function (x, y) {
      // use matrix implementation
      return rightArithShift(matrix(x), y).valueOf();
    },

    'number | BigNumber, Array': function (x, y) {
      // use matrix implementation
      return rightArithShift(x, matrix(y)).valueOf();
    }
  });

  rightArithShift.toTex = '\\left(${args[0]}' + latex.operators['rightArithShift'] + '${args[1]}\\right)';

  return rightArithShift;
}

exports.name = 'rightArithShift';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../type/matrix/utils/algorithm01":438,"../../type/matrix/utils/algorithm02":439,"../../type/matrix/utils/algorithm08":445,"../../type/matrix/utils/algorithm10":447,"../../type/matrix/utils/algorithm11":448,"../../type/matrix/utils/algorithm13":450,"../../type/matrix/utils/algorithm14":451,"../../utils/bignumber/rightArithShift":471,"../../utils/latex":482,"../../utils/number":483,"../matrix/zeros":337,"../relational/equalScalar":352}],295:[function(require,module,exports){
'use strict';

var isInteger = require('../../utils/number').isInteger;

function factory (type, config, load, typed) {
  var latex = require('../../utils/latex');

  var matrix = load(require('../../type/matrix/function/matrix'));
  var equalScalar = load(require('../relational/equalScalar'));
  var zeros = load(require('../matrix/zeros'));

  var algorithm01 = load(require('../../type/matrix/utils/algorithm01'));
  var algorithm02 = load(require('../../type/matrix/utils/algorithm02'));
  var algorithm08 = load(require('../../type/matrix/utils/algorithm08'));
  var algorithm10 = load(require('../../type/matrix/utils/algorithm10'));
  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));
  
  /**
   * Bitwise right logical shift of value x by y number of bits, `x >>> y`.
   * For matrices, the function is evaluated element wise.
   * For units, the function is evaluated on the best prefix base.
   *
   * Syntax:
   *
   *    math.rightLogShift(x, y)
   *
   * Examples:
   *
   *    math.rightLogShift(4, 2);               // returns number 1
   *
   *    math.rightLogShift([16, -32, 64], 4);   // returns Array [1, 2, 3]
   *
   * See also:
   *
   *    bitAnd, bitNot, bitOr, bitXor, leftShift, rightLogShift
   *
   * @param  {number | Array | Matrix} x Value to be shifted
   * @param  {number} y Amount of shifts
   * @return {number | Array | Matrix} `x` zero-filled shifted right `y` times
   */

  var rightLogShift = typed('rightLogShift', {

    'number, number': function (x, y) {
      if (!isInteger(x) || !isInteger(y)) {
        throw new Error('Integers expected in function rightLogShift');
      }

      return x >>> y;
    },

    // 'BigNumber, BigNumber': ..., // TODO: implement BigNumber support for rightLogShift

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse & sparse
              c = algorithm08(x, y, rightLogShift, false);
              break;
            default:
              // sparse & dense
              c = algorithm02(y, x, rightLogShift, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense & sparse
              c = algorithm01(x, y, rightLogShift, false);
              break;
            default:
              // dense & dense
              c = algorithm13(x, y, rightLogShift);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return rightLogShift(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return rightLogShift(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return rightLogShift(x, matrix(y));
    },

    'Matrix, number | BigNumber': function (x, y) {
      // check scalar
      if (!equalScalar(y, 0)) {
        // result
        var c;
        // check storage format
        switch (x.storage()) {
          case 'sparse':
            c = algorithm11(x, y, rightLogShift, false);
            break;
          default:
            c = algorithm14(x, y, rightLogShift, false);
            break;
        }
        return c;
      }
      return x.clone();
    },

    'number | BigNumber, Matrix': function (x, y) {
      // check scalar
      if (!equalScalar(x, 0)) {
        // result
        var c;
        // check storage format
        switch (y.storage()) {
          case 'sparse':
            c = algorithm10(y, x, rightLogShift, true);
            break;
          default:
            c = algorithm14(y, x, rightLogShift, true);
            break;
        }
        return c;
      }
      return zeros(y.size(), y.storage());
    },

    'Array, number | BigNumber': function (x, y) {
      // use matrix implementation
      return rightLogShift(matrix(x), y).valueOf();
    },

    'number | BigNumber, Array': function (x, y) {
      // use matrix implementation
      return rightLogShift(x, matrix(y)).valueOf();
    }
  });

  rightLogShift.toTex = '\\left(${args[0]}' + latex.operators['rightLogShift'] + '${args[1]}\\right)';

  return rightLogShift;
}

exports.name = 'rightLogShift';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../type/matrix/utils/algorithm01":438,"../../type/matrix/utils/algorithm02":439,"../../type/matrix/utils/algorithm08":445,"../../type/matrix/utils/algorithm10":447,"../../type/matrix/utils/algorithm11":448,"../../type/matrix/utils/algorithm13":450,"../../type/matrix/utils/algorithm14":451,"../../utils/latex":482,"../../utils/number":483,"../matrix/zeros":337,"../relational/equalScalar":352}],296:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  var add = load(require('../arithmetic/add'));
  var stirlingS2 = load(require('./stirlingS2'));
  var isNegative = load(require('../utils/isNegative'));
  var isInteger = load(require('../utils/isInteger'));

  /**
   * The Bell Numbers count the number of partitions of a set. A partition is a pairwise disjoint subset of S whose union is S.
   * bellNumbers only takes integer arguments.
   * The following condition must be enforced: n >= 0
   *
   * Syntax:
   *
   *   math.bellNumbers(n)
   *
   * Examples:
   *
   *    math.bellNumbers(3); // returns 5;
   *    math.bellNumbers(8); // returns 4140;
   *
   * See also:
   *
   *    stirlingS2
   *
   * @param {Number | BigNumber} n    Total number of objects in the set
   * @return {Number | BigNumber}     B(n)
   */
  var bellNumbers = typed('bellNumbers', {
    'number | BigNumber': function (n) {

      if (!isInteger(n) || isNegative(n)) {
        throw new TypeError('Non-negative integer value expected in function bellNumbers');
      }

      // Sum (k=0, n) S(n,k).
      var result = 0;
      for(var i = 0; i <= n; i++) {
        result = add(result, stirlingS2(n, i));
      }

      return result;
    }
  });

  bellNumbers.toTex = '\\mathrm{B}_{${args[0]}}';

  return bellNumbers;
}

exports.name = 'bellNumbers';
exports.factory = factory;

},{"../arithmetic/add":255,"../utils/isInteger":403,"../utils/isNegative":404,"./stirlingS2":300}],297:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  var add = load(require('../arithmetic/add'));
  var divide = load(require('../arithmetic/divide'));
  var multiply = load(require('../arithmetic/multiply'));
  var combinations = load(require('../probability/combinations'));
  var isNegative = load(require('../utils/isNegative'));
  var isInteger = load(require('../utils/isInteger'));


  /**
   * The Catalan Numbers enumerate combinatorial structures of many different types.
   * catalan only takes integer arguments.
   * The following condition must be enforced: n >= 0
   *
   * Syntax:
   *
   *   math.catalan(n)
   *
   * Examples:
   *
   *    math.catalan(3); // returns 5;
   *    math.catalan(8); // returns 1430;
   *
   * See also:
   *
   *    bellNumbers
   *
   * @param {Number | BigNumber} n    nth Catalan number
   * @return {Number | BigNumber}     Cn(n)
   */
  var catalan = typed('catalan', {
    'number | BigNumber': function (n) {

      if (!isInteger(n) || isNegative(n)) {
        throw new TypeError('Non-negative integer value expected in function catalan');
      }
       
      return divide(combinations(multiply(n,2), n), add(n,1));

    }
  });

  catalan.toTex = '\\mathrm{C}_{${args[0]}}';

  return catalan;
}

exports.name = 'catalan';
exports.factory = factory;

},{"../arithmetic/add":255,"../arithmetic/divide":260,"../arithmetic/multiply":275,"../probability/combinations":338,"../utils/isInteger":403,"../utils/isNegative":404}],298:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  var combinations = load(require('../probability/combinations'));
  var add = load(require('../arithmetic/addScalar'));
  var isPositive = load(require('../utils/isPositive'));
  var isInteger = load(require('../utils/isInteger'));
  var larger = load(require('../relational/larger'));

  /**
   * The composition counts of n into k parts.
   *
   * composition only takes integer arguments.
   * The following condition must be enforced: k <= n.
   *
   * Syntax:
   *
   *   math.composition(n, k)
   *
   * Examples:
   *
   *    math.composition(5, 3); // returns 6
   *
   * See also:
   *
   *    combinations
   *
   * @param {Number | BigNumber} n    Total number of objects in the set
   * @param {Number | BigNumber} k    Number of objects in the subset
   * @return {Number | BigNumber}     Returns the composition counts of n into k parts.
   */
  var composition =  typed('composition', {
    'number | BigNumber, number | BigNumber': function (n, k) {
      if (!isInteger(n) || !isPositive(n) || !isInteger(k) || !isPositive(k)) {
        throw new TypeError('Positive integer value expected in function composition');
      }
      else if (larger(k, n)) {
        throw new TypeError('k must be less than or equal to n in function composition');
      }

      return combinations(add(n, -1), add(k, -1));
    }
  });

  composition.toTex = '\\mathrm{${name}}\\left(${args}\\right)';

  return composition;
}

exports.name = 'composition';
exports.factory = factory;

},{"../arithmetic/addScalar":256,"../probability/combinations":338,"../relational/larger":354,"../utils/isInteger":403,"../utils/isPositive":406}],299:[function(require,module,exports){
module.exports = [
  require('./bellNumbers'),
  require('./composition'),
  require('./stirlingS2'),
  require('./catalan')
];

},{"./bellNumbers":296,"./catalan":297,"./composition":298,"./stirlingS2":300}],300:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  var add = load(require('../arithmetic/add'));
  var subtract = load(require('../arithmetic/subtract'));
  var multiply = load(require('../arithmetic/multiply'));
  var divide = load(require('../arithmetic/divide'));
  var pow = load(require('../arithmetic/pow'));
  var factorial = load(require('../probability/factorial'));
  var combinations = load(require('../probability/combinations'));
  var isNegative = load(require('../utils/isNegative'));
  var isInteger = load(require('../utils/isInteger'));
  var larger = load(require('../relational/larger'));

  /**
   * The Stirling numbers of the second kind, counts the number of ways to partition
   * a set of n labelled objects into k nonempty unlabelled subsets.
   * stirlingS2 only takes integer arguments.
   * The following condition must be enforced: k <= n.
   *
   *  If n = k or k = 1, then s(n,k) = 1
   *
   * Syntax:
   *
   *   math.stirlingS2(n, k)
   *
   * Examples:
   *
   *    math.stirlingS2(5, 3); //returns 25
   *
   * See also:
   *
   *    Bell numbers
   *
   * @param {Number | BigNumber} n    Total number of objects in the set
   * @param {Number | BigNumber} k    Number of objects in the subset
   * @return {Number | BigNumber}     S(n,k)
   */
  var stirlingS2 = typed('stirlingS2', {
    'number | BigNumber, number | BigNumber': function (n, k) {
      if (!isInteger(n) || isNegative(n) || !isInteger(k) || isNegative(k)) {
        throw new TypeError('Non-negative integer value expected in function stirlingS2');
      }
      else if (larger(k, n)) {
        throw new TypeError('k must be less than or equal to n in function stirlingS2');
      }

      // 1/k! Sum(i=0 -> k) [(-1)^(k-i)*C(k,j)* i^n]
      var kFactorial = factorial(k);
      var result = 0;
      for(var i = 0; i <= k; i++) {
        var negativeOne = pow(-1, subtract(k,i));
        var kChooseI = combinations(k,i);
        var iPower = pow(i,n);

        result = add(result, multiply(multiply(kChooseI, iPower), negativeOne));
      }

      return divide(result, kFactorial);
    }
  });

  stirlingS2.toTex = '\\mathrm{S}\\left(${args[0]},${args[1]}\\right)';

  return stirlingS2;
}

exports.name = 'stirlingS2';
exports.factory = factory;

},{"../arithmetic/add":255,"../arithmetic/divide":260,"../arithmetic/multiply":275,"../arithmetic/pow":279,"../arithmetic/subtract":284,"../probability/combinations":338,"../probability/factorial":340,"../relational/larger":354,"../utils/isInteger":403,"../utils/isNegative":404}],301:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Compute the argument of a complex value.
   * For a complex number `a + bi`, the argument is computed as `atan2(b, a)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.arg(x)
   *
   * Examples:
   *
   *    var a = math.complex(2, 2);
   *    math.arg(a) / math.pi;          // returns number 0.25
   *
   *    var b = math.complex('2 + 3i');
   *    math.arg(b);                    // returns number 0.982793723247329
   *    math.atan2(3, 2);               // returns number 0.982793723247329
   *
   * See also:
   *
   *    re, im, conj, abs
   *
   * @param {number | Complex | Array | Matrix} x
   *            A complex number or array with complex numbers
   * @return {number | Array | Matrix} The argument of x
   */
  var arg = typed('arg', {
    'number': function (x) {
      return Math.atan2(0, x);
    },

    'Complex': function (x) {
      return x.arg();
    },

    // TODO: implement BigNumber support for function arg

    'Array | Matrix': function (x) {
      return deepMap(x, arg);
    }
  });

  arg.toTex = '\\arg\\left(${args[0]}\\right)';

  return arg;
}

exports.name = 'arg';
exports.factory = factory;

},{"../../utils/collection/deepMap":475}],302:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Compute the complex conjugate of a complex value.
   * If `x = a+bi`, the complex conjugate of `x` is `a - bi`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.conj(x)
   *
   * Examples:
   *
   *    math.conj(math.complex('2 + 3i'));  // returns Complex 2 - 3i
   *    math.conj(math.complex('2 - 3i'));  // returns Complex 2 + 3i
   *    math.conj(math.complex('-5.2i'));  // returns Complex 5.2i
   *
   * See also:
   *
   *    re, im, arg, abs
   *
   * @param {number | BigNumber | Complex | Array | Matrix} x
   *            A complex number or array with complex numbers
   * @return {number | BigNumber | Complex | Array | Matrix}
   *            The complex conjugate of x
   */
  var conj = typed('conj', {
    'number': function (x) {
      return x;
    },

    'BigNumber': function (x) {
      return x;
    },

    'Complex': function (x) {
      return x.conjugate();
    },

    'Array | Matrix': function (x) {
      return deepMap(x, conj);
    }
  });

  conj.toTex = '\\left(${args[0]}\\right)^*';

  return conj;
}

exports.name = 'conj';
exports.factory = factory;

},{"../../utils/collection/deepMap":475}],303:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Get the imaginary part of a complex number.
   * For a complex number `a + bi`, the function returns `b`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.im(x)
   *
   * Examples:
   *
   *    var a = math.complex(2, 3);
   *    math.re(a);                     // returns number 2
   *    math.im(a);                     // returns number 3
   *
   *    math.re(math.complex('-5.2i')); // returns number -5.2
   *    math.re(math.complex(2.4));     // returns number 0
   *
   * See also:
   *
   *    re, conj, abs, arg
   *
   * @param {number | BigNumber | Complex | Array | Matrix} x
   *            A complex number or array with complex numbers
   * @return {number | BigNumber | Array | Matrix} The imaginary part of x
   */
  var im = typed('im', {
    'number': function (x) {
      return 0;
    },

    'BigNumber': function (x) {
      return new type.BigNumber(0);
    },

    'Complex': function (x) {
      return x.im;
    },

    'Array | Matrix': function (x) {
      return deepMap(x, im);
    }
  });

  im.toTex = '\\Im\\left\\lbrace${args[0]}\\right\\rbrace';

  return im;
}

exports.name = 'im';
exports.factory = factory;

},{"../../utils/collection/deepMap":475}],304:[function(require,module,exports){
module.exports = [
  require('./arg'),
  require('./conj'),
  require('./im'),
  require('./re')
];

},{"./arg":301,"./conj":302,"./im":303,"./re":305}],305:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Get the real part of a complex number.
   * For a complex number `a + bi`, the function returns `a`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.re(x)
   *
   * Examples:
   *
   *    var a = math.complex(2, 3);
   *    math.re(a);                     // returns number 2
   *    math.im(a);                     // returns number 3
   *
   *    math.re(math.complex('-5.2i')); // returns number 0
   *    math.re(math.complex(2.4));     // returns number 2.4
   *
   * See also:
   *
   *    im, conj, abs, arg
   *
   * @param {number | BigNumber | Complex | Array | Matrix} x
   *            A complex number or array with complex numbers
   * @return {number | BigNumber | Array | Matrix} The real part of x
   */
  var re = typed('re', {
    'number': function (x) {
      return x;
    },

    'BigNumber': function (x) {
      return x;
    },

    'Complex': function (x) {
      return x.re;
    },

    'Array | Matrix': function (x) {
      return deepMap(x, re);
    }
  });

  re.toTex = '\\Re\\left\\lbrace${args[0]}\\right\\rbrace';

  return re;
}

exports.name = 're';
exports.factory = factory;

},{"../../utils/collection/deepMap":475}],306:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  var matrix = load(require('../../type/matrix/function/matrix'));

  /**
    * Calculates:
    *    The eucledian distance between two points in 2 and 3 dimensional spaces.
    *    Distance between point and a line in 2 and 3 dimensional spaces.
    *    Pairwise distance between a set of 2D or 3D points
    * NOTE:
    *    When substituting coefficients of a line(a, b and c), use ax + by + c = 0 instead of ax + by = c
    *    For parametric equation of a 3D line, x0, y0, z0, a, b, c are from: (x−x0, y−y0, z−z0) = t(a, b, c)
    *
    * Syntax:
    *    math.distance([x1, y1], [x2, y2])
    *-   math.distance({pointOneX: 4, pointOneY: 5}, {pointTwoX: 2, pointTwoY: 7})
    *    math.distance([x1, y1, z1], [x2, y2, z2])
    *    math.distance({pointOneX: 4, pointOneY: 5, pointOneZ: 8}, {pointTwoX: 2, pointTwoY: 7, pointTwoZ: 9})
    *    math.distance([[A], [B], [C]...])
    *    math.distance([x1, y1], [LinePtX1, LinePtY1], [LinePtX2, LinePtY2])
    *    math.distance({pointX: 1, pointY: 4}, {lineOnePtX: 6, lineOnePtY: 3}, {lineTwoPtX: 2, lineTwoPtY: 8})
    *    math.distance([x1, y1, z1], [LinePtX1, LinePtY1, LinePtZ1], [LinePtX2, LinePtY2, LinePtZ2])
    *    math.distance({pointX: 1, pointY: 4, pointZ: 7}, {lineOnePtX: 6, lineOnePtY: 3, lineOnePtZ: 4}, {lineTwoPtX: 2, lineTwoPtY: 8, lineTwoPtZ: 5})
    *    math.distance([x1, y1], [xCoeffLine, yCoeffLine, constant])
    *    math.distance({pointX: 10, pointY: 10}, {xCoeffLine: 8, yCoeffLine: 1, constant: 3})
    *    math.distance([x1, y1, z1], [x0, y0, z0, a-tCoeff, b-tCoeff, c-tCoeff]) point and parametric equation of 3D line
    *    math.distance([x, y, z], [x0, y0, z0, a, b, c])
    *    math.distance({pointX: 2, pointY: 5, pointZ: 9}, {x0: 4, y0: 6, z0: 3, a: 4, b: 2, c: 0})
    *
    * Examples:
    *    math.distance([0,0], [4,4])                     // Returns 5.6569
    *    math.distance(
    *     {pointOneX: 0, pointOneY: 0},
    *     {pointTwoX: 10, pointTwoY: 10})                // Returns 14.142135623730951
    *    math.distance([1, 0, 1], [4, -2, 2])            // Returns 3.74166
    *    math.distance(
    *     {pointOneX: 4, pointOneY: 5, pointOneZ: 8},
    *     {pointTwoX: 2, pointTwoY: 7, pointTwoZ: 9})    // Returns 3
    *    math.distance([[1, 2], [1, 2], [1, 3]])         // Returns [0, 1, 1]
    *    math.distance([[1,2,4], [1,2,6], [8,1,3]])      // Returns [2, 7.14142842854285, 7.681145747868608]
    *    math.distance([10, 10], [8, 1, 3])              // Returns 11.535230316796387
    *    math.distance([10, 10], [2, 3], [-8, 0])        // Returns 8.759953130362847
    *    math.distance(
    *     {pointX: 1, pointY: 4},
    *     {lineOnePtX: 6, lineOnePtY: 3},
    *     {lineTwoPtX: 2, lineTwoPtY: 8})                // Returns 2.720549372624744
    *    math.distance([2, 3, 1], [1, 1, 2, 5, 0, 1])    // Returns 2.3204774044612857
    *    math.distance(
    *     {pointX: 2, pointY: 3, pointZ: 1},
    *     {x0: 1, y0: 1, z0: 2, a: 5, b: 0, c: 1}        // Returns 2.3204774044612857
    *
    * @param {Array | Matrix | Object} x    Co-ordinates of first point
    * @param {Array | Matrix | Object} y    Co-ordinates of second point
    * @return {Number | BigNumber} Returns the distance from two/three points
  */

  var distance = typed('distance', {
    'Array, Array, Array': function(x, y, z){
      // Point to Line 2D; (x=Point, y=LinePoint1, z=LinePoint2)
      if (x.length == 2 && y.length == 2 && z.length == 2){
        if (!_2d(x)) { throw new TypeError('Array with 2 numbers expected for first argument'); }
        if (!_2d(y)) { throw new TypeError('Array with 2 numbers expected for second argument'); }
        if (!_2d(z)) { throw new TypeError('Array with 2 numbers expected for third argument'); }
        var m = (z[1]-z[0])/(y[1]-y[0]);
        var xCoeff = m*m*y[0];
        var yCoeff = -1*(m*y[0]);
        var constant = x[1];

        return _distancePointLine2D(x[0], x[1], xCoeff, yCoeff, constant);
      }
      else{
        throw new TypeError('Invalid Arguments: Try again');
      }
    },
    'Object, Object, Object': function(x, y, z){
      if (Object.keys(x).length == 2 && Object.keys(y).length == 2 && Object.keys(z).length == 2){
        if (!_2d(x)) { throw new TypeError('Values of pointX and pointY should be numbers'); }
        if (!_2d(y)) { throw new TypeError('Values of lineOnePtX and lineOnePtY should be numbers'); }
        if (!_2d(z)) { throw new TypeError('Values of lineTwoPtX and lineTwoPtY should be numbers'); }
        if (x.hasOwnProperty('pointX') && x.hasOwnProperty('pointY') && y.hasOwnProperty('lineOnePtX') &&
          y.hasOwnProperty('lineOnePtY') && z.hasOwnProperty('lineTwoPtX') && z.hasOwnProperty('lineTwoPtY')){
          var m = (z.lineTwoPtY-z.lineTwoPtX)/(y.lineOnePtY-y.lineOnePtX);
          var xCoeff = m*m*y.lineOnePtX;
          var yCoeff = -1*(m*y.lineOnePtX);
          var constant = x.pointX;

          return _distancePointLine2D(x.pointX, x.pointY, xCoeff, yCoeff, constant);
        }
        else{
          throw new TypeError('Key names do not match');
        }
      }
      else{
        throw new TypeError('Invalid Arguments: Try again');
      }
    },
    'Array, Array': function(x, y){
      // Point to Line 2D; (x=[pointX, pointY], y=[x-coeff, y-coeff, const])
      if (x.length == 2 && y.length == 3){
        if (!_2d(x)) { throw new TypeError('Array with 2 numbers expected for first argument'); }
        if (!_3d(y)) { throw new TypeError('Array with 3 numbers expected for second argument'); }

        return _distancePointLine2D(x[0], x[1], y[0], y[1], y[2]);
      }
      // Point to Line 3D
      else if (x.length == 3 && y.length == 6){
        if (!_3d(x)) { throw new TypeError('Array with 3 numbers expected for first argument'); }
        if (!_parametricLine(y)) { throw new TypeError('Array with 6 numbers expected for second argument'); }

        return _distancePointLine3D(x[0], x[1], x[2], y[0], y[1], y[2], y[3], y[4], y[5]);
      }
      // Point to Point 2D
      else if (x.length == 2 && y.length == 2){
        if (!_2d(x)) { throw new TypeError('Array with 2 numbers expected for first argument'); }
        if (!_2d(y)) { throw new TypeError('Array with 2 numbers expected for second argument'); }

        return _distance2d(x[0], x[1], y[0], y[1]);
      }
      // Point to Point 3D
      else if(x.length == 3 && y.length == 3){
        if (!_3d(x)) { throw new TypeError('Array with 3 numbers expected for first argument'); }
        if (!_3d(y)) { throw new TypeError('Array with 3 numbers expected for second argument'); }

        return _distance3d(x[0], x[1], x[2], y[0], y[1], y[2]);
      }
      else{
        throw new TypeError('Invalid Arguments: Try again');
      }
    },
    'Object, Object': function(x, y){
      if (Object.keys(x).length == 2 && Object.keys(y).length == 3){
        if (!_2d(x)) { throw new TypeError('Values of pointX and pointY should be numbers'); }
        if (!_3d(y)) { throw new TypeError('Values of xCoeffLine, yCoeffLine and constant should be numbers'); }
        if (x.hasOwnProperty('pointX') && x.hasOwnProperty('pointY') && y.hasOwnProperty('xCoeffLine') &&
          y.hasOwnProperty('yCoeffLine') && y.hasOwnProperty('yCoeffLine')){

          return _distancePointLine2D(x.pointX, x.pointY, y.xCoeffLine, y.yCoeffLine, y.constant);
        }
        else{
          throw new TypeError('Key names do not match');
        }
      }
      // Point to Line 3D
      else if (Object.keys(x).length == 3 && Object.keys(y).length == 6){
        if (!_3d(x)) { throw new TypeError('Values of pointX, pointY and pointZ should be numbers'); }
        if (!_parametricLine(y)) { throw new TypeError('Values of x0, y0, z0, a, b and c should be numbers'); }
        if (x.hasOwnProperty('pointX') && x.hasOwnProperty('pointY') && y.hasOwnProperty('x0') &&
          y.hasOwnProperty('y0') && y.hasOwnProperty('z0') && y.hasOwnProperty('a') &&
          y.hasOwnProperty('b') && y.hasOwnProperty('c')){

          return _distancePointLine3D(x.pointX, x.pointY, x.pointZ, y.x0, y.y0, y.z0, y.a, y.b, y.c);
        }
        else{
          throw new TypeError('Key names do not match');
        }
      }
      // Point to Point 2D
      else if (Object.keys(x).length == 2 && Object.keys(y).length == 2){
        if (!_2d(x)) { throw new TypeError('Values of pointOneX and pointOneY should be numbers'); }
        if (!_2d(y)) { throw new TypeError('Values of pointTwoX and pointTwoY should be numbers'); }
        if (x.hasOwnProperty('pointOneX') && x.hasOwnProperty('pointOneY') &&
          y.hasOwnProperty('pointTwoX') && y.hasOwnProperty('pointTwoY')){

          return _distance2d(x.pointOneX, x.pointOneY, y.pointTwoX, y.pointTwoY);
        }
        else{
          throw new TypeError('Key names do not match');
        }
      }
      // Point to Point 3D
      else if(Object.keys(x).length == 3 && Object.keys(y).length == 3){
        if (!_3d(x)) { throw new TypeError('Values of pointOneX, pointOneY and pointOneZ should be numbers'); }
        if (!_3d(y)) { throw new TypeError('Values of pointTwoX, pointTwoY and pointTwoZ should be numbers'); }
        if (x.hasOwnProperty('pointOneX') && x.hasOwnProperty('pointOneY') && x.hasOwnProperty('pointOneZ') &&
          y.hasOwnProperty('pointTwoX') && y.hasOwnProperty('pointTwoY') && y.hasOwnProperty('pointTwoZ')){

          return _distance3d(x.pointOneX, x.pointOneY, x.pointOneZ, y.pointTwoX, y.pointTwoY, y.pointTwoZ);
        }
        else {
          throw new TypeError('Key names do not match');
        }
      }
      else{
        throw new TypeError('Invalid Arguments: Try again');
      }
    },
    'Array': function(arr){
      if (!_pairwise(arr)) { throw new TypeError('Incorrect array format entered for pairwise distance calculation'); }

      return _distancePairwise(arr);
    }
  });
  return distance;
}

function _2d(a){
  // checks if the number of arguments are correct in count and are valid (should be numbers)
  if (a.constructor !== Array){
    a = _objectToArray(a);
  }
  return typeof a[0] === 'number' && typeof a[1] === 'number';
}

function _3d(a){
  // checks if the number of arguments are correct in count and are valid (should be numbers)
  if (a.constructor !== Array){
    a = _objectToArray(a);
  }
  return typeof a[0] === 'number' && typeof a[1] === 'number' && typeof a[2] === 'number';
}

function _parametricLine(a){
  if (a.constructor !== Array){
    a = _objectToArray(a);
  }
  return typeof a[0] === 'number' && typeof a[1] === 'number' && typeof a[2] === 'number' &&
    typeof a[3] === 'number' && typeof a[4] === 'number' && typeof a[5] === 'number';

}

function _objectToArray(o){
  var keys = Object.keys(o);
  var a = [];
  for (var i = 0; i < keys.length; i++) {
    a.push(o[keys[i]]);
  }
  return a;
}

function _pairwise(a){
  //checks for valid arguments passed to _distancePairwise(Array)
  if (a[0].length == 2 && typeof a[0][0] === 'number' && typeof a[0][1] === 'number'){
    for(var i in a){
      if (a[i].length != 2 || typeof a[i][0] !== 'number' || typeof a[i][1] !== 'number'){
        return false;
      }
    }
  }
  else if (a[0].length == 3 && typeof a[0][0] === 'number' && typeof a[0][1] === 'number' && typeof a[0][2] === 'number'){
    for(var i in a){
      if (a[i].length != 3 || typeof a[i][0] !== 'number' || typeof a[i][1] !== 'number' || typeof a[i][2] !== 'number'){
        return false;
      }
    }
  }
  else{
    return false;
  }
  return true;
}

function _distancePointLine2D(x, y, a, b, c){
  var num =  Math.abs(a*x + b*y + c);
  var den = Math.pow((a*a + b*b), 0.5);
  var result = (num/den);
  return result;
}

function _distancePointLine3D(x, y, z, x0, y0, z0, a, b, c){
  var num = [((y0-y)*(c))-((z0-z)*(b)), ((z0-z)*(a))-((x0-x)*(c)), ((x0-x)*(b))-((y0-y)*(a))]
  num = Math.pow(num[0]*num[0] + num[1]*num[1] + num[2]*num[2], 0.5);
  var den = Math.pow(a*a + b*b + c*c, 0.5);
  var result = num/den;
  return result;
}

function _distance2d(x1, y1, x2, y2){
  var yDiff = y2 - y1;
  var xDiff = x2 - x1;
  var radicant = yDiff * yDiff + xDiff * xDiff;
  var result = Math.pow(radicant, 0.5);
  return result;
}

function _distance3d(x1, y1, z1, x2, y2, z2){
  var zDiff = z2 - z1;
  var yDiff = y2 - y1;
  var xDiff = x2 - x1;
  var radicant = zDiff * zDiff + yDiff * yDiff + xDiff * xDiff;
  var result = Math.pow(radicant, 0.5);
  return result;
}

function _distancePairwise(a){
  var result = [];
  for(var i = 0; i < a.length-1; i++){
    for(var j = i+1; j < a.length; j++){
      if (a[0].length == 2){
        result.push(_distance2d(a[i][0], a[i][1], a[j][0], a[j][1]));
      }
      else if (a[0].length == 3){
        result.push(_distance3d(a[i][0], a[i][1], a[i][2], a[j][0], a[j][1], a[j][2]));
      }
    }
  }
  return result;
}

exports.name = 'distance';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435}],307:[function(require,module,exports){
module.exports = [
  require('./intersect'),
  require('./distance')
];

},{"./distance":306,"./intersect":308}],308:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {

  var abs = load(require('../arithmetic/abs'));
  var add = load(require('../arithmetic/add'));
  var matrix = load(require('../../type/matrix/function/matrix'));
  var multiply = load(require('../arithmetic/multiply'));
  var subtract = load(require('../arithmetic/subtract'));

  /**
   * Calculates the point of intersection of two lines in two or three dimensions
   * and of a line and a plane in three dimensions. The inputs are in the form of
   * arrays or 1 dimensional matrices. The line intersection functions return null
   * if the lines do not meet.
   *
   * Note: Fill the plane coefficients as `x + y + z = c` and not as `x + y + z + c = 0`.
   *
   * Syntax:
   *
   *    math.intersect(endPoint1Line1, endPoint2Line1, endPoint1Line2, endPoint2Line2)
   *    math.intersect(endPoint1, endPoint2, planeCoefficients)
   *
   * Examples:
   *
   *    math.intersect([0, 0], [10, 10], [10, 0], [0, 10]);              // Returns [5, 5]
   *    math.intersect([0, 0, 0], [10, 10, 0], [10, 0, 0], [0, 10, 0]);  // Returns [5, 5, 0]
   *    math.intersect([1, 0, 1],  [4, -2, 2], [1, 1, 1, 6]);            // Returns [7, -4, 3]
   *
   * @param  {Array | Matrix} w   Co-ordinates of first end-point of first line
   * @param  {Array | Matrix} x   Co-ordinates of second end-point of first line
   * @param  {Array | Matrix} y   Co-ordinates of first end-point of second line
   *                              OR Co-efficients of the plane's equation
   * @param  {Array | Matrix} z   Co-ordinates of second end-point of second line
   *                              OR null if the calculation is for line and plane
   * @return {Array}              Returns the point of intersection of lines/lines-planes
   */
  var intersect = typed('intersect', {
    'Array, Array, Array': function (x, y, plane) {
      if (!_3d(x)) { throw new TypeError('Array with 3 numbers expected for first argument'); }
      if (!_3d(y)) { throw new TypeError('Array with 3 numbers expected for second argument'); }
      if (!_4d(plane)) { throw new TypeError('Array with 4 numbers expected as third argument'); }

      return _intersectLinePlane(x[0], x[1], x[2], y[0], y[1], y[2], plane[0], plane[1], plane[2], plane[3]);
    },

    'Array, Array, Array, Array': function (w, x, y, z) {
      if (w.length === 2) {
        if (!_2d(w)) { throw new TypeError('Array with 2 numbers expected for first argument'); }
        if (!_2d(x)) { throw new TypeError('Array with 2 numbers expected for second argument'); }
        if (!_2d(y)) { throw new TypeError('Array with 2 numbers expected for third argument'); }
        if (!_2d(z)) { throw new TypeError('Array with 2 numbers expected for fourth argument'); }

        return _intersect2d(w, x, y, z);
      }
      else if (w.length === 3) {
        if (!_3d(w)) { throw new TypeError('Array with 3 numbers expected for first argument'); }
        if (!_3d(x)) { throw new TypeError('Array with 3 numbers expected for second argument'); }
        if (!_3d(y)) { throw new TypeError('Array with 3 numbers expected for third argument'); }
        if (!_3d(z)) { throw new TypeError('Array with 3 numbers expected for fourth argument'); }

        return _intersect3d(w[0], w[1], w[2], x[0], x[1], x[2], y[0], y[1], y[2], z[0], z[1], z[2]);
      }
      else {
        throw new TypeError('Arrays with two or thee dimensional points expected');
      }
    },

    'Matrix, Matrix, Matrix': function (x, y, plane) {
      return matrix(intersect(x.valueOf(), y.valueOf(), plane.valueOf()));
    },

    'Matrix, Matrix, Matrix, Matrix': function (w, x, y, z) {
      // TODO: output matrix type should match input matrix type
      return matrix(intersect(w.valueOf(), x.valueOf(), y.valueOf(), z.valueOf()));
    }
  });

  function _2d(x) {
    return x.length === 2 && typeof x[0] === 'number' && typeof x[1] === 'number';
  }

  function _3d(x) {
    return x.length === 3 && typeof x[0] === 'number' && typeof x[1] === 'number' && typeof x[2] === 'number';
  }

  function _4d(x) {
    return x.length === 4 && typeof x[0] === 'number' && typeof x[1] === 'number' && typeof x[2] === 'number' && typeof x[3] === 'number';
  }

  function _intersect2d(p1a, p1b, p2a, p2b){
    var o1 = p1a;
    var o2 = p2a;
    var d1 = subtract(o1, p1b);
    var d2 = subtract(o2, p2b);
    var det = d1[0]*d2[1] - d2[0]*d1[1];
    if (abs(det) < config.epsilon) {
      return null;
    }
    var t = (d2[0]*o1[1] - d2[1]*o1[0] - d2[0]*o2[1] + d2[1]*o2[0]) / det;
    return add(multiply(d1, t), o1); 
  }

  function _intersect3d(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4){
    var d1343 = (x1 - x3)*(x4 - x3) + (y1 - y3)*(y4 - y3) + (z1 - z3)*(z4 - z3);
    var d4321 = (x4 - x3)*(x2 - x1) + (y4 - y3)*(y2 - y1) + (z4 - z3)*(z2 - z1);
    var d1321 = (x1 - x3)*(x2 - x1) + (y1 - y3)*(y2 - y1) + (z1 - z3)*(z2 - z1);
    var d4343 = (x4 - x3)*(x4 - x3) + (y4 - y3)*(y4 - y3) + (z4 - z3)*(z4 - z3);
    var d2121 = (x2 - x1)*(x2 - x1) + (y2 - y1)*(y2 - y1) + (z2 - z1)*(z2 - z1);
    var ta = ( d1343*d4321 - d1321*d4343 ) / ( d2121*d4343 - d4321*d4321 );
    var tb = ( d1343 + ta * d4321 ) / (d4343);

    var pax = x1 + ta * (x2 - x1);
    var pay = y1 + ta * (y2 - y1);
    var paz = z1 + ta * (z2 - z1);
    var pbx = x3 + tb * (x4 - x3);
    var pby = y3 + tb * (y4 - y3);
    var pbz = z3 + tb * (z4 - z3);
    if (pax === pbx && pay === pby && paz === pbz){
      return [pax, pay, paz];
    }
    else{
      return null;
    }
  }

  function _intersectLinePlane(x1, y1, z1, x2, y2, z2, x, y, z, c){
    var t = (c - x1*x - y1*y - z1*z)/(x2*x + y2*y + z2*z - x1 - y1 - z1);
    var px = x1 + t * (x2 - x1);
    var py = y1 + t * (y2 - y1);
    var pz = z1 + t * (z2 - z1);
    return [px, py, pz];
    // TODO: Add cases when line is parallel to the plane:
    //       (a) no intersection,
    //       (b) line contained in plane
  }

  return intersect;
}

exports.name = 'intersect';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../arithmetic/abs":254,"../arithmetic/add":255,"../arithmetic/multiply":275,"../arithmetic/subtract":284}],309:[function(require,module,exports){
module.exports = [
  require('./algebra'),
  require('./arithmetic'),
  require('./bitwise'),
  require('./combinatorics'),
  require('./complex'),
  require('./geometry'),
  require('./logical'),
  require('./matrix'),
  require('./probability'),
  require('./relational'),
  require('./statistics'),
  require('./string'),
  require('./trigonometry'),
  require('./unit'),
  require('./utils')
];

},{"./algebra":231,"./arithmetic":270,"./bitwise":292,"./combinatorics":299,"./complex":304,"./geometry":307,"./logical":311,"./matrix":324,"./probability":342,"./relational":353,"./statistics":359,"./string":371,"./trigonometry":392,"./unit":399,"./utils":402}],310:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  var latex = require('../../utils/latex');

  var matrix = load(require('../../type/matrix/function/matrix'));
  var zeros = load(require('../matrix/zeros'));
  var not = load(require('./not'));
  var isZero = load(require('../utils/isZero'));

  var algorithm02 = load(require('../../type/matrix/utils/algorithm02'));
  var algorithm06 = load(require('../../type/matrix/utils/algorithm06'));
  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

  /**
   * Logical `and`. Test whether two values are both defined with a nonzero/nonempty value.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.and(x, y)
   *
   * Examples:
   *
   *    math.and(2, 4);   // returns true
   *
   *    a = [2, 0, 0];
   *    b = [3, 7, 0];
   *    c = 0;
   *
   *    math.and(a, b);   // returns [true, false, false]
   *    math.and(a, c);   // returns [false, false, false]
   *
   * See also:
   *
   *    not, or, xor
   *
   * @param  {number | BigNumber | Complex | Unit | Array | Matrix} x First value to check
   * @param  {number | BigNumber | Complex | Unit | Array | Matrix} y Second value to check
   * @return {boolean | Array | Matrix}
   *            Returns true when both inputs are defined with a nonzero/nonempty value.
   */
  var and = typed('and', {

    'number, number': function (x, y) {
      return !!(x && y);
    },

    'Complex, Complex': function (x, y) {
      return (x.re !== 0 || x.im !== 0) && (y.re !== 0 || y.im !== 0);
    },

    'BigNumber, BigNumber': function (x, y) {
      return !x.isZero() && !y.isZero() && !x.isNaN() && !y.isNaN();
    },

    'Unit, Unit': function (x, y) {
      return and(x.value, y.value);
    },
    
    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse & sparse
              c = algorithm06(x, y, and, false);
              break;
            default:
              // sparse & dense
              c = algorithm02(y, x, and, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense & sparse
              c = algorithm02(x, y, and, false);
              break;
            default:
              // dense & dense
              c = algorithm13(x, y, and);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return and(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return and(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return and(x, matrix(y));
    },

    'Matrix, any': function (x, y) {
      // check scalar
      if (not(y)) {
        // return zero matrix
        return zeros(x.size(), x.storage());
      }
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm11(x, y, and, false);
          break;
        default:
          c = algorithm14(x, y, and, false);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // check scalar
      if (not(x)) {
        // return zero matrix
        return zeros(x.size(), x.storage());
      }
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm11(y, x, and, true);
          break;
        default:
          c = algorithm14(y, x, and, true);
          break;
      }
      return c;
    },

    'Array, any': function (x, y) {
      // use matrix implementation
      return and(matrix(x), y).valueOf();
    },

    'any, Array': function (x, y) {
      // use matrix implementation
      return and(x, matrix(y)).valueOf();
    }
  });

  and.toTex = '\\left(${args[0]}' + latex.operators['and'] + '${args[1]}\\right)';

  return and;
}

exports.name = 'and';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../type/matrix/utils/algorithm02":439,"../../type/matrix/utils/algorithm06":443,"../../type/matrix/utils/algorithm11":448,"../../type/matrix/utils/algorithm13":450,"../../type/matrix/utils/algorithm14":451,"../../utils/latex":482,"../matrix/zeros":337,"../utils/isZero":407,"./not":312}],311:[function(require,module,exports){
module.exports = [
  require('./and'),
  require('./not'),
  require('./or'),
  require('./xor')
];

},{"./and":310,"./not":312,"./or":313,"./xor":314}],312:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  var latex = require('../../utils/latex');

  /**
   * Logical `not`. Flips boolean value of a given parameter.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.not(x)
   *
   * Examples:
   *
   *    math.not(2);      // returns false
   *    math.not(0);      // returns true
   *    math.not(true);   // returns false
   *
   *    a = [2, -7, 0];
   *    math.not(a);      // returns [false, false, true]
   *
   * See also:
   *
   *    and, or, xor
   *
   * @param  {number | BigNumber | Complex | Unit | Array | Matrix} x First value to check
   * @return {boolean | Array | Matrix}
   *            Returns true when input is a zero or empty value.
   */
  var not = typed('not', {
    'number': function (x) {
      return !x;
    },

    'Complex': function (x) {
      return x.re === 0 && x.im === 0;
    },

    'BigNumber': function (x) {
      return x.isZero() || x.isNaN();
    },

    'Unit': function (x) {
      return not(x.value);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, not);
    }
  });

  not.toTex = latex.operators['not'] + '\\left(${args[0]}\\right)';

  return not;
}

exports.name = 'not';
exports.factory = factory;

},{"../../utils/collection/deepMap":475,"../../utils/latex":482}],313:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  var latex = require('../../utils/latex');

  var matrix = load(require('../../type/matrix/function/matrix'));

  var algorithm03 = load(require('../../type/matrix/utils/algorithm03'));
  var algorithm05 = load(require('../../type/matrix/utils/algorithm05'));
  var algorithm12 = load(require('../../type/matrix/utils/algorithm12'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));
  
  /**
   * Logical `or`. Test if at least one value is defined with a nonzero/nonempty value.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.or(x, y)
   *
   * Examples:
   *
   *    math.or(2, 4);   // returns true
   *
   *    a = [2, 5, 0];
   *    b = [0, 22, 0];
   *    c = 0;
   *
   *    math.or(a, b);   // returns [true, true, false]
   *    math.or(b, c);   // returns [false, true, false]
   *
   * See also:
   *
   *    and, not, xor
   *
   * @param  {number | BigNumber | Complex | Unit | Array | Matrix} x First value to check
   * @param  {number | BigNumber | Complex | Unit | Array | Matrix} y Second value to check
   * @return {boolean | Array | Matrix}
   *            Returns true when one of the inputs is defined with a nonzero/nonempty value.
   */
  var or = typed('or', {

    'number, number': function (x, y) {
      return !!(x || y);
    },

    'Complex, Complex': function (x, y) {
      return (x.re !== 0 || x.im !== 0) || (y.re !== 0 || y.im !== 0);
    },

    'BigNumber, BigNumber': function (x, y) {
      return (!x.isZero() && !x.isNaN()) || (!y.isZero() && !y.isNaN());
    },

    'Unit, Unit': function (x, y) {
      return or(x.value, y.value);
    },

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse + sparse
              c = algorithm05(x, y, or);
              break;
            default:
              // sparse + dense
              c = algorithm03(y, x, or, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense + sparse
              c = algorithm03(x, y, or, false);
              break;
            default:
              // dense + dense
              c = algorithm13(x, y, or);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return or(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return or(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return or(x, matrix(y));
    },

    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm12(x, y, or, false);
          break;
        default:
          c = algorithm14(x, y, or, false);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm12(y, x, or, true);
          break;
        default:
          c = algorithm14(y, x, or, true);
          break;
      }
      return c;
    },

    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, or, false).valueOf();
    },

    'any, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, or, true).valueOf();
    }
  });

  or.toTex = '\\left(${args[0]}' + latex.operators['or'] + '${args[1]}\\right)';

  return or;
}

exports.name = 'or';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../type/matrix/utils/algorithm03":440,"../../type/matrix/utils/algorithm05":442,"../../type/matrix/utils/algorithm12":449,"../../type/matrix/utils/algorithm13":450,"../../type/matrix/utils/algorithm14":451,"../../utils/latex":482}],314:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  var latex = require('../../utils/latex');

  var matrix = load(require('../../type/matrix/function/matrix'));

  var algorithm03 = load(require('../../type/matrix/utils/algorithm03'));
  var algorithm07 = load(require('../../type/matrix/utils/algorithm07'));
  var algorithm12 = load(require('../../type/matrix/utils/algorithm12'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));
  
  /**
   * Logical `xor`. Test whether one and only one value is defined with a nonzero/nonempty value.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.xor(x, y)
   *
   * Examples:
   *
   *    math.xor(2, 4);   // returns false
   *
   *    a = [2, 0, 0];
   *    b = [2, 7, 0];
   *    c = 0;
   *
   *    math.xor(a, b);   // returns [false, true, false]
   *    math.xor(a, c);   // returns [true, false, false]
   *
   * See also:
   *
   *    and, not, or
   *
   * @param  {number | BigNumber | Complex | Unit | Array | Matrix} x First value to check
   * @param  {number | BigNumber | Complex | Unit | Array | Matrix} y Second value to check
   * @return {boolean | Array | Matrix}
   *            Returns true when one and only one input is defined with a nonzero/nonempty value.
   */
  var xor = typed('xor', {
 
    'number, number': function (x, y) {
      return !!(!!x ^ !!y);
    },

    'Complex, Complex': function (x, y) {
      return ((x.re !== 0 || x.im !== 0) !== (y.re !== 0 || y.im !== 0));
    },

    'BigNumber, BigNumber': function (x, y) {
      return ((!x.isZero() && !x.isNaN()) !== (!y.isZero() && !y.isNaN()));
    },

    'Unit, Unit': function (x, y) {
      return xor(x.value, y.value);
    },

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse + sparse
              c = algorithm07(x, y, xor);
              break;
            default:
              // sparse + dense
              c = algorithm03(y, x, xor, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense + sparse
              c = algorithm03(x, y, xor, false);
              break;
            default:
              // dense + dense
              c = algorithm13(x, y, xor);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return xor(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return xor(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return xor(x, matrix(y));
    },

    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm12(x, y, xor, false);
          break;
        default:
          c = algorithm14(x, y, xor, false);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm12(y, x, xor, true);
          break;
        default:
          c = algorithm14(y, x, xor, true);
          break;
      }
      return c;
    },

    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, xor, false).valueOf();
    },

    'any, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, xor, true).valueOf();
    }
  });

  xor.toTex = '\\left(${args[0]}' + latex.operators['xor'] + '${args[1]}\\right)';

  return xor;
}

exports.name = 'xor';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../type/matrix/utils/algorithm03":440,"../../type/matrix/utils/algorithm07":444,"../../type/matrix/utils/algorithm12":449,"../../type/matrix/utils/algorithm13":450,"../../type/matrix/utils/algorithm14":451,"../../utils/latex":482}],315:[function(require,module,exports){
'use strict';

var clone = require('../../utils/object').clone;
var isInteger = require('../../utils/number').isInteger;
var array = require('../../utils/array');
var IndexError = require('../../error/IndexError');
var DimensionError = require('../../error/DimensionError');

function factory (type, config, load, typed) {
  var matrix = load(require('../../type/matrix/function/matrix'));

  /**
   * Concatenate two or more matrices.
   *
   * Syntax:
   *
   *     math.concat(A, B, C, ...)
   *     math.concat(A, B, C, ..., dim)
   *
   * Where:
   *
   * - `dim: number` is a zero-based dimension over which to concatenate the matrices.
   *   By default the last dimension of the matrices.
   *
   * Examples:
   *
   *    var A = [[1, 2], [5, 6]];
   *    var B = [[3, 4], [7, 8]];
   *
   *    math.concat(A, B);                  // returns [[1, 2, 3, 4], [5, 6, 7, 8]]
   *    math.concat(A, B, 0);               // returns [[1, 2], [5, 6], [3, 4], [7, 8]]
   *    math.concat('hello', ' ', 'world'); // returns 'hello world'
   *
   * See also:
   *
   *    size, squeeze, subset, transpose
   *
   * @param {... Array | Matrix} args     Two or more matrices
   * @return {Array | Matrix} Concatenated matrix
   */
  var concat = typed('concat', {
    // TODO: change signature to '...Array | Matrix, dim?' when supported
    '...Array | Matrix | number | BigNumber': function (args) {
      var i;
      var len = args.length;
      var dim = -1;  // zero-based dimension
      var prevDim;
      var asMatrix = false;
      var matrices = [];  // contains multi dimensional arrays

      for (i = 0; i < len; i++) {
        var arg = args[i];

        // test whether we need to return a Matrix (if not we return an Array)
        if (arg && arg.isMatrix === true) {
          asMatrix = true;
        }

        if (typeof arg === 'number' || (arg && arg.isBigNumber === true)) {
          if (i !== len - 1) {
            throw new Error('Dimension must be specified as last argument');
          }

          // last argument contains the dimension on which to concatenate
          prevDim = dim;
          dim = arg.valueOf(); // change BigNumber to number

          if (!isInteger(dim)) {
            throw new TypeError('Integer number expected for dimension');
          }

          if (dim < 0 || (i > 0 && dim > prevDim)) {
            // TODO: would be more clear when throwing a DimensionError here
            throw new IndexError(dim, prevDim + 1);
          }
        }
        else {
          // this is a matrix or array
          var m = clone(arg).valueOf();
          var size = array.size(m);
          matrices[i] = m;
          prevDim = dim;
          dim = size.length - 1;

          // verify whether each of the matrices has the same number of dimensions
          if (i > 0 && dim != prevDim) {
            throw new DimensionError(prevDim + 1, dim + 1);
          }
        }
      }

      if (matrices.length == 0) {
        throw new SyntaxError('At least one matrix expected');
      }

      var res = matrices.shift();
      while (matrices.length) {
        res = _concat(res, matrices.shift(), dim, 0);
      }

      return asMatrix ? matrix(res) : res;
    },

    '...string': function (args) {
      return args.join('');
    }
  });

  concat.toTex = '\\mathrm{${name}}\\left(${args}\\right)';

  return concat;
}

/**
 * Recursively concatenate two matrices.
 * The contents of the matrices is not cloned.
 * @param {Array} a             Multi dimensional array
 * @param {Array} b             Multi dimensional array
 * @param {number} concatDim    The dimension on which to concatenate (zero-based)
 * @param {number} dim          The current dim (zero-based)
 * @return {Array} c            The concatenated matrix
 * @private
 */
function _concat(a, b, concatDim, dim) {
  if (dim < concatDim) {
    // recurse into next dimension
    if (a.length != b.length) {
      throw new DimensionError(a.length, b.length);
    }

    var c = [];
    for (var i = 0; i < a.length; i++) {
      c[i] = _concat(a[i], b[i], concatDim, dim + 1);
    }
    return c;
  }
  else {
    // concatenate this dimension
    return a.concat(b);
  }
}

exports.name = 'concat';
exports.factory = factory;

},{"../../error/DimensionError":11,"../../error/IndexError":12,"../../type/matrix/function/matrix":435,"../../utils/array":461,"../../utils/number":483,"../../utils/object":484}],316:[function(require,module,exports){
'use strict';

var size = require('../../utils/array').size;

function factory (type, config, load, typed) {
  var matrix   = load(require('../../type/matrix/function/matrix'));
  var subtract = load(require('../arithmetic/subtract'));
  var multiply = load(require('../arithmetic/multiply'));

  /**
   * Calculate the cross product for two vectors in three dimensional space.
   * The cross product of `A = [a1, a2, a3]` and `B =[b1, b2, b3]` is defined
   * as:
   *
   *    cross(A, B) = [
   *      a2 * b3 - a3 * b2,
   *      a3 * b1 - a1 * b3,
   *      a1 * b2 - a2 * b1
   *    ]
   *
   * Syntax:
   *
   *    math.cross(x, y)
   *
   * Examples:
   *
   *    math.cross([1, 1, 0],  [0, 1, 1]);  // Returns [1, -1, 1]
   *    math.cross([3, -3, 1], [4, 9, 2]);  // Returns [-15, -2, 39]
   *    math.cross([2, 3, 4],  [5, 6, 7]);  // Returns [-3, 6, -3]
   *
   * See also:
   *
   *    dot, multiply
   *
   * @param  {Array | Matrix} x   First vector
   * @param  {Array | Matrix} y   Second vector
   * @return {Array | Matrix}     Returns the cross product of `x` and `y`
   */
  var cross = typed('cross', {
    'Matrix, Matrix': function (x, y) {
      return matrix(_cross(x.toArray(), y.toArray()));
    },

    'Matrix, Array': function (x, y) {
      return matrix(_cross(x.toArray(), y));
    },

    'Array, Matrix': function (x, y) {
      return matrix(_cross(x, y.toArray()));
    },

    'Array, Array': _cross
  });

  cross.toTex = '\\left(${args[0]}\\right)\\times\\left(${args[1]}\\right)';

  return cross;

  /**
   * Calculate the cross product for two arrays
   * @param {Array} x  First vector
   * @param {Array} y  Second vector
   * @returns {Array} Returns the cross product of x and y
   * @private
   */
  function _cross(x, y) {
    var xSize= size(x);
    var ySize = size(y);

    if (xSize.length != 1 || ySize.length != 1 || xSize[0] != 3 || ySize[0] != 3) {
      throw new RangeError('Vectors with length 3 expected ' +
      '(Size A = [' + xSize.join(', ') + '], B = [' + ySize.join(', ') + '])');
    }

    return [
      subtract(multiply(x[1], y[2]), multiply(x[2], y[1])),
      subtract(multiply(x[2], y[0]), multiply(x[0], y[2])),
      subtract(multiply(x[0], y[1]), multiply(x[1], y[0]))
    ];
  }
}

exports.name = 'cross';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../utils/array":461,"../arithmetic/multiply":275,"../arithmetic/subtract":284}],317:[function(require,module,exports){
'use strict';

var util = require('../../utils/index');
var object = util.object;
var string = util.string;

function factory (type, config, load, typed) {
  var matrix = load(require('../../type/matrix/function/matrix'));
  var add = load(require('../arithmetic/add'));
  var subtract = load(require('../arithmetic/subtract'));
  var multiply = load(require('../arithmetic/multiply'));
  var unaryMinus = load(require('../arithmetic/unaryMinus'));

  /**
   * Calculate the determinant of a matrix.
   *
   * Syntax:
   *
   *    math.det(x)
   *
   * Examples:
   *
   *    math.det([[1, 2], [3, 4]]); // returns -2
   *
   *    var A = [
   *      [-2, 2, 3],
   *      [-1, 1, 3],
   *      [2, 0, -1]
   *    ]
   *    math.det(A); // returns 6
   *
   * See also:
   *
   *    inv
   *
   * @param {Array | Matrix} x  A matrix
   * @return {number} The determinant of `x`
   */
  var det = typed('det', {
    'any': function (x) {
      return object.clone(x);
    },

    'Array | Matrix': function det (x) {
      var size;
      if (x && x.isMatrix === true) {
        size = x.size();
      }
      else if (Array.isArray(x)) {
        x = matrix(x);
        size = x.size();
      }
      else {
        // a scalar
        size = [];
      }

      switch (size.length) {
        case 0:
          // scalar
          return object.clone(x);

        case 1:
          // vector
          if (size[0] == 1) {
            return object.clone(x.valueOf()[0]);
          }
          else {
            throw new RangeError('Matrix must be square ' +
            '(size: ' + string.format(size) + ')');
          }

        case 2:
          // two dimensional array
          var rows = size[0];
          var cols = size[1];
          if (rows == cols) {
            return _det(x.clone().valueOf(), rows, cols);
          }
          else {
            throw new RangeError('Matrix must be square ' +
            '(size: ' + string.format(size) + ')');
          }

        default:
          // multi dimensional array
          throw new RangeError('Matrix must be two dimensional ' +
          '(size: ' + string.format(size) + ')');
      }
    }
  });

  det.toTex = '\\det\\left(${args[0]}\\right)';

  return det;

  /**
   * Calculate the determinant of a matrix
   * @param {Array[]} matrix  A square, two dimensional matrix
   * @param {number} rows     Number of rows of the matrix (zero-based)
   * @param {number} cols     Number of columns of the matrix (zero-based)
   * @returns {number} det
   * @private
   */
  function _det (matrix, rows, cols) {
    if (rows == 1) {
      // this is a 1 x 1 matrix
      return object.clone(matrix[0][0]);
    }
    else if (rows == 2) {
      // this is a 2 x 2 matrix
      // the determinant of [a11,a12;a21,a22] is det = a11*a22-a21*a12
      return subtract(
          multiply(matrix[0][0], matrix[1][1]),
          multiply(matrix[1][0], matrix[0][1])
      );
    }
    else {
      // this is an n x n matrix
      var compute_mu = function (matrix) {
        var i, j;

        // Compute the matrix with zero lower triangle, same upper triangle,
        // and diagonals given by the negated sum of the below diagonal
        // elements.
        var mu = new Array(matrix.length);
        var sum = 0;
        for (i = 1; i < matrix.length; i++) {
          sum = add(sum, matrix[i][i]);
        }

        for (i = 0; i < matrix.length; i++) {
          mu[i] = new Array(matrix.length);
          mu[i][i] = unaryMinus(sum);

          for (j = 0; j < i; j++) {
            mu[i][j] = 0; // TODO: make bignumber 0 in case of bignumber computation
          }

          for (j = i + 1; j < matrix.length; j++) {
            mu[i][j] = matrix[i][j];
          }

          if (i+1 < matrix.length) {
            sum = subtract(sum, matrix[i + 1][i + 1]);
          }
        }

        return mu;
      };

      var fa = matrix;
      for (var i = 0; i < rows - 1; i++) {
        fa = multiply(compute_mu(fa), matrix);
      }

      if (rows % 2 == 0) {
        return unaryMinus(fa[0][0]);
      } else {
        return fa[0][0];
      }
    }
  }
}

exports.name = 'det';
exports.factory = factory;


},{"../../type/matrix/function/matrix":435,"../../utils/index":481,"../arithmetic/add":255,"../arithmetic/multiply":275,"../arithmetic/subtract":284,"../arithmetic/unaryMinus":285}],318:[function(require,module,exports){
'use strict';

var array     = require('../../utils/array');
var clone     = require('../../utils/object').clone;
var isInteger = require('../../utils/number').isInteger;

function factory (type, config, load, typed) {

  var matrix = load(require('../../type/matrix/function/matrix'));
  
  /**
   * Create a diagonal matrix or retrieve the diagonal of a matrix
   *
   * When `x` is a vector, a matrix with vector `x` on the diagonal will be returned.
   * When `x` is a two dimensional matrix, the matrixes `k`th diagonal will be returned as vector.
   * When k is positive, the values are placed on the super diagonal.
   * When k is negative, the values are placed on the sub diagonal.
   *
   * Syntax:
   *
   *     math.diag(X)
   *     math.diag(X, format)
   *     math.diag(X, k)
   *     math.diag(X, k, format)
   *
   * Examples:
   *
   *     // create a diagonal matrix
   *     math.diag([1, 2, 3]);      // returns [[1, 0, 0], [0, 2, 0], [0, 0, 3]]
   *     math.diag([1, 2, 3], 1);   // returns [[0, 1, 0, 0], [0, 0, 2, 0], [0, 0, 0, 3]]
   *     math.diag([1, 2, 3], -1);  // returns [[0, 0, 0], [1, 0, 0], [0, 2, 0], [0, 0, 3]]
   *
   *    // retrieve the diagonal from a matrix
   *    var a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];
   *    math.diag(a);   // returns [1, 5, 9]
   *
   * See also:
   *
   *     ones, zeros, eye
   *
   * @param {Matrix | Array} x          A two dimensional matrix or a vector
   * @param {number | BigNumber} [k=0]  The diagonal where the vector will be filled
   *                                    in or retrieved.
   * @param {string} [format='dense']   The matrix storage format.
   *
   * @returns {Matrix | Array} Diagonal matrix from input vector, or diagonal from input matrix.
   */
  var diag = typed('diag', {
    // FIXME: simplify this huge amount of signatures as soon as typed-function supports optional arguments

    'Array': function (x) {
      return _diag(x, 0, array.size(x), null);
    },

    'Array, number': function (x, k) {
      return _diag(x, k, array.size(x), null);
    },
    
    'Array, BigNumber': function (x, k) {
      return _diag(x, k.toNumber(), array.size(x), null);
    },

    'Array, string': function (x, format) {
      return _diag(x, 0, array.size(x), format);
    },

    'Array, number, string': function (x, k, format) {
      return _diag(x, k, array.size(x), format);
    },

    'Array, BigNumber, string': function (x, k, format) {
      return _diag(x, k.toNumber(), array.size(x), format);
    },

    'Matrix': function (x) {
      return _diag(x, 0, x.size(), x.storage());
    },

    'Matrix, number': function (x, k) {
      return _diag(x, k, x.size(), x.storage());
    },

    'Matrix, BigNumber': function (x, k) {
      return _diag(x, k.toNumber(), x.size(), x.storage());
    },

    'Matrix, string': function (x, format) {
      return _diag(x, 0, x.size(), format);
    },

    'Matrix, number, string': function (x, k, format) {
      return _diag(x, k, x.size(), format);
    },

    'Matrix, BigNumber, string': function (x, k, format) {
      return _diag(x, k.toNumber(), x.size(), format);
    }
  });

  diag.toTex = '\\mathrm{${name}}\\left(${args}\\right)';

  return diag;

  /**
   * Creeate diagonal matrix from a vector or vice versa
   * @param {Array | Matrix} x
   * @param {number} k
   * @param {string} format Storage format for matrix. If null,
   *                          an Array is returned
   * @returns {Array | Matrix}
   * @private
   */
  function _diag (x, k, size, format) {
    if (!isInteger(k)) {
      throw new TypeError ('Second parameter in function diag must be an integer');
    }
    
    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;

    // check dimensions
    switch (size.length) {
      case 1:
        return _createDiagonalMatrix(x, k, format, size[0], kSub, kSuper);
      case 2:
        return _getDiagonal(x, k, format, size, kSub, kSuper);
    }
    throw new RangeError('Matrix for function diag must be 2 dimensional');
  }
  
  function _createDiagonalMatrix(x, k, format, l, kSub, kSuper) {
    // matrix size
    var ms = [l + kSub, l + kSuper];
    // get matrix constructor
    var F = type.Matrix.storage(format || 'dense');
    // create diagonal matrix
    var m = F.diagonal(ms, x, k);
    // check we need to return a matrix
    return format !== null ? m : m.valueOf();
  }
  
  function _getDiagonal(x, k, format, s, kSub, kSuper) {
    // check x is a Matrix
    if (x && x.isMatrix === true) {
      // get diagonal matrix
      var dm = x.diagonal(k);
      // check we need to return a matrix
      if (format !== null) {
        // check we need to change matrix format
        if (format !== dm.storage())
          return matrix(dm, format);
        return dm;
      }
      return dm.valueOf();
    }
    // vector size
    var n = Math.min(s[0] - kSub, s[1] - kSuper);
    // diagonal values
    var vector = [];
    // loop diagonal
    for (var i = 0; i < n; i++) {
      vector[i] = x[i + kSub][i + kSuper];
    }
    // check we need to return a matrix
    return format !== null ? matrix(vector) : vector;
  }
}

exports.name = 'diag';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../utils/array":461,"../../utils/number":483,"../../utils/object":484}],319:[function(require,module,exports){
'use strict';

var size = require('../../utils/array').size;

function factory (type, config, load, typed) {
  var add      = load(require('../arithmetic/add'));
  var multiply = load(require('../arithmetic/multiply'));

  /**
   * Calculate the dot product of two vectors. The dot product of
   * `A = [a1, a2, a3, ..., an]` and `B = [b1, b2, b3, ..., bn]` is defined as:
   *
   *    dot(A, B) = a1 * b1 + a2 * b2 + a3 * b3 + ... + an * bn
   *
   * Syntax:
   *
   *    math.dot(x, y)
   *
   * Examples:
   *
   *    math.dot([2, 4, 1], [2, 2, 3]);       // returns number 15
   *    math.multiply([2, 4, 1], [2, 2, 3]);  // returns number 15
   *
   * See also:
   *
   *    multiply, cross
   *
   * @param  {Array | Matrix} x     First vector
   * @param  {Array | Matrix} y     Second vector
   * @return {number}               Returns the dot product of `x` and `y`
   */
  var dot = typed('dot', {
    'Matrix, Matrix': function (x, y) {
      return _dot(x.toArray(), y.toArray());
    },

    'Matrix, Array': function (x, y) {
      return _dot(x.toArray(), y);
    },

    'Array, Matrix': function (x, y) {
      return _dot(x, y.toArray());
    },

    'Array, Array': _dot
  });
  
  dot.toTex = '\\left(${args[0]}\\cdot${args[1]}\\right)';

  return dot;

  /**
   * Calculate the dot product for two arrays
   * @param {Array} x  First vector
   * @param {Array} y  Second vector
   * @returns {number} Returns the dot product of x and y
   * @private
   */
  // TODO: double code with math.multiply
  function _dot(x, y) {
    var xSize= size(x);
    var ySize = size(y);
    var len = xSize[0];

    if (xSize.length !== 1 || ySize.length !== 1) throw new RangeError('Vector expected'); // TODO: better error message
    if (xSize[0] != ySize[0]) throw new RangeError('Vectors must have equal length (' + xSize[0] + ' != ' + ySize[0] + ')');
    if (len == 0) throw new RangeError('Cannot calculate the dot product of empty vectors');

    var prod = 0;
    for (var i = 0; i < len; i++) {
      prod = add(prod, multiply(x[i], y[i]));
    }

    return prod;
  }
}

exports.name = 'dot';
exports.factory = factory;

},{"../../utils/array":461,"../arithmetic/add":255,"../arithmetic/multiply":275}],320:[function(require,module,exports){
'use strict';

var array = require('../../utils/array');
var isInteger = require('../../utils/number').isInteger;

function factory (type, config, load, typed) {
  
  var matrix = load(require('../../type/matrix/function/matrix'));
  
  /**
   * Create a 2-dimensional identity matrix with size m x n or n x n.
   * The matrix has ones on the diagonal and zeros elsewhere.
   *
   * Syntax:
   *
   *    math.eye(n)
   *    math.eye(n, format)
   *    math.eye(m, n)
   *    math.eye(m, n, format)
   *    math.eye([m, n])
   *    math.eye([m, n], format)
   *
   * Examples:
   *
   *    math.eye(3);                    // returns [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
   *    math.eye(3, 2);                 // returns [[1, 0], [0, 1], [0, 0]]
   *
   *    var A = [[1, 2, 3], [4, 5, 6]];
   *    math.eye(math.size(A));         // returns [[1, 0, 0], [0, 1, 0]]
   *
   * See also:
   *
   *    diag, ones, zeros, size, range
   *
   * @param {...number | Matrix | Array} size   The size for the matrix
   * @param {string} [format]                   The Matrix storage format
   *
   * @return {Matrix | Array | number} A matrix with ones on the diagonal.
   */
  var eye = typed('eye', {
    '': function () {
      return (config.matrix === 'Matrix') ? matrix([]) : [];
    },

    'string': function (format) {
      return matrix(format);
    },

    'number | BigNumber': function (rows) {
      return _eye(rows, rows, config.matrix === 'Matrix' ? 'default' : undefined);
    },
    
    'number | BigNumber, string': function (rows, format) {
      return _eye(rows, rows, format);
    },

    'number | BigNumber, number | BigNumber': function (rows, cols) {
      return _eye(rows, cols, config.matrix === 'Matrix' ? 'default' : undefined);
    },
    
    'number | BigNumber, number | BigNumber, string': function (rows, cols, format) {
      return _eye(rows, cols, format);
    },

    'Array':  function (size) {
      return _eyeVector(size);
    },
    
    'Array, string':  function (size, format) {
      return _eyeVector(size, format);
    },

    'Matrix': function (size) {
      return _eyeVector(size.valueOf(), size.storage());
    },
    
    'Matrix, string': function (size, format) {
      return _eyeVector(size.valueOf(), format);
    }
  });

  eye.toTex = '\\mathrm{${name}}\\left(${args}\\right)';

  return eye;

  function _eyeVector (size, format) {
    switch (size.length) {
      case 0: return format ? matrix(format) : [];
      case 1: return _eye(size[0], size[0], format);
      case 2: return _eye(size[0], size[1], format);
      default: throw new Error('Vector containing two values expected');
    }
  }

  /**
   * Create an identity matrix
   * @param {number | BigNumber} rows
   * @param {number | BigNumber} cols
   * @param {string} [format]
   * @returns {Matrix}
   * @private
   */
  function _eye (rows, cols, format) {
    // BigNumber constructor with the right precision
    var Big = (rows && rows.isBigNumber === true)
        ? type.BigNumber
        : (cols && cols.isBigNumber === true)
            ? type.BigNumber
            : null;

    if (rows && rows.isBigNumber === true) rows = rows.toNumber();
    if (cols && cols.isBigNumber === true) cols = cols.toNumber();

    if (!isInteger(rows) || rows < 1) {
      throw new Error('Parameters in function eye must be positive integers');
    }
    if (!isInteger(cols) || cols < 1) {
      throw new Error('Parameters in function eye must be positive integers');
    }
    
    var one = Big ? new type.BigNumber(1) : 1;
    var defaultValue = Big ? new Big(0) : 0;
    var size = [rows, cols];
    
    // check we need to return a matrix
    if (format) {
      // get matrix storage constructor
      var F = type.Matrix.storage(format);
      // create diagonal matrix (use optimized implementation for storage format)
      return F.diagonal(size, one, 0, defaultValue);
    }
    
    // create and resize array
    var res = array.resize([], size, defaultValue);
    // fill in ones on the diagonal
    var minimum = rows < cols ? rows : cols;
    // fill diagonal
    for (var d = 0; d < minimum; d++) {
      res[d][d] = one;
    }
    return res;
  }
}

exports.name = 'eye';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../utils/array":461,"../../utils/number":483}],321:[function(require,module,exports){
'use strict';

var size = require('../../utils/array').size;

function factory (type, config, load, typed) {
  var matrix = load(require('../../type/matrix/function/matrix'));
  
  /**
   * Filter the items in an array or one dimensional matrix.
   *
   * Syntax:
   *
   *    math.filter(x, test)
   *
   * Examples:
   *
   *    function isPositive (x) {
   *      return x > 0;
   *    }
   *    math.filter([6, -2, -1, 4, 3], isPositive); // returns [6, 4, 3]
   *
   *    math.filter(["23", "foo", "100", "55", "bar"], /[0-9]+/); // returns ["23", "100", "55"]
   *
   * See also:
   *
   *    forEach, map, sort
   *
   * @param {Matrix | Array} x    A one dimensional matrix or array to filter
   * @param {Function | RegExp} test
   *        A function or regular expression to test items.
   *        When `test` is a function, it must return a boolean.
   *        All entries for which `test` returns true are returned.
   * @return {Matrix | Array} Returns the filtered matrix.
   */
  var filter = typed('filter', {
    'Array, function': _filterCallback,

    'Array, RegExp': _filterRegExp,

    'Matrix, function': function (x, test) {
      return matrix(_filterCallback(x.toArray(), test));
    },

    'Matrix, RegExp': function (x, test) {
      return matrix(_filterRegExp(x.toArray(), test));
    }
  });

  filter.toTex = '\\mathrm{${name}}\\left(${args}\\right)';

  return filter;
}

/**
 * Filter values in a callback given a callback function
 * @param {Array} x
 * @param {Function} callback
 * @return {Array} Returns the filtered array
 * @private
 */
function _filterCallback (x, callback) {
  if (size(x).length !== 1) {
    throw new Error('Only one dimensional matrices supported');
  }

  return x.filter(function (entry) {
    return callback(entry);
  });
}

/**
 * Filter values in a callback given a regular expression
 * @param {Array} x
 * @param {Function} regexp
 * @return {Array} Returns the filtered array
 * @private
 */
function _filterRegExp (x, regexp) {
  if (size(x).length !== 1) {
    throw new Error('Only one dimensional matrices supported');
  }

  return x.filter(function (entry) {
    return regexp.test(entry);
  });
}

exports.name = 'filter';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../utils/array":461}],322:[function(require,module,exports){
'use strict';

var clone = require('../../utils/object').clone;
var _flatten = require('../../utils/array').flatten;

function factory (type, config, load, typed) {
  var matrix = load(require('../../type/matrix/function/matrix'));

  /**
   * Flatten a multi dimensional matrix into a single dimensional matrix.
   *
   * Syntax:
   *
   *    math.flatten(x)
   *
   * Examples:
   *
   *    math.flatten([[1,2], [3,4]]);   // returns [1, 2, 3, 4]
   *
   * See also:
   *
   *    concat, resize, size, squeeze
   *
   * @param {Matrix | Array} x   Matrix to be flattened
   * @return {Matrix | Array} Returns the flattened matrix
   */
  var flatten = typed('flatten', {
    'Array': function (x) {
      return _flatten(clone(x));
    },

    'Matrix': function (x) {
      var flat = _flatten(clone(x.toArray()));
      // TODO: return the same matrix type as x
      return matrix(flat);
    }
  });

  flatten.toTex = '\\mathrm{${name}}\\left(${args}\\right)';

  return flatten;
}

exports.name = 'flatten';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../utils/array":461,"../../utils/object":484}],323:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  /**
   * Iterate over all elements of a matrix/array, and executes the given callback function.
   *
   * Syntax:
   *
   *    math.forEach(x, callback)
   *
   * Examples:
   *
   *    math.forEach([1, 2, 3], function(value) {
   *      console.log(value);
   *    });
   *    // outputs 1, 2, 3
   *
   * See also:
   *
   *    filter, map, sort
   *
   * @param {Matrix | Array} x    The matrix to iterate on.
   * @param {Function} callback   The callback function is invoked with three
   *                              parameters: the value of the element, the index
   *                              of the element, and the Matrix/array being traversed.
   */
  var forEach = typed('forEach', {
    'Array, function': _forEach,

    'Matrix, function': function (x, callback) {
      return x.forEach(callback);
    }
  });

  forEach.toTex = '\\mathrm{${name}}\\left(${args}\\right)';

  return forEach;
}

/**
 * forEach for a multi dimensional array
 * @param {Array} array
 * @param {Function} callback
 * @private
 */
function _forEach (array, callback) {
  var recurse = function (value, index) {
    if (Array.isArray(value)) {
      value.forEach(function (child, i) {
        // we create a copy of the index array and append the new index value
        recurse(child, index.concat(i));
      });
    }
    else {
      callback(value, index, array);
    }
  };
  recurse(array, []);
}

exports.name = 'forEach';
exports.factory = factory;

},{}],324:[function(require,module,exports){
module.exports = [
  require('./concat'),
  require('./cross'),
  require('./det'),
  require('./diag'),
  require('./dot'),
  require('./eye'),
  require('./filter'),
  require('./flatten'),
  require('./forEach'),
  require('./inv'),
  require('./map'),
  require('./ones'),
  require('./partitionSelect'),
  require('./range'),
  require('./resize'),
  require('./size'),
  require('./sort'),
  require('./squeeze'),
  require('./subset'),
  require('./trace'),
  require('./transpose'),
  require('./zeros')
];

},{"./concat":315,"./cross":316,"./det":317,"./diag":318,"./dot":319,"./eye":320,"./filter":321,"./flatten":322,"./forEach":323,"./inv":325,"./map":326,"./ones":327,"./partitionSelect":328,"./range":329,"./resize":330,"./size":331,"./sort":332,"./squeeze":333,"./subset":334,"./trace":335,"./transpose":336,"./zeros":337}],325:[function(require,module,exports){
'use strict';

var util = require('../../utils/index');

function factory (type, config, load, typed) {
  var matrix       = load(require('../../type/matrix/function/matrix'));
  var divideScalar = load(require('../arithmetic/divideScalar'));
  var addScalar    = load(require('../arithmetic/addScalar'));
  var multiply     = load(require('../arithmetic/multiply'));
  var unaryMinus   = load(require('../arithmetic/unaryMinus'));
  var det          = load(require('../matrix/det'));
  var eye          = load(require('./eye'));

  /**
   * Calculate the inverse of a square matrix.
   *
   * Syntax:
   *
   *     math.inv(x)
   *
   * Examples:
   *
   *     math.inv([[1, 2], [3, 4]]);  // returns [[-2, 1], [1.5, -0.5]]
   *     math.inv(4);                 // returns 0.25
   *     1 / 4;                       // returns 0.25
   *
   * See also:
   *
   *     det, transpose
   *
   * @param {number | Complex | Array | Matrix} x     Matrix to be inversed
   * @return {number | Complex | Array | Matrix} The inverse of `x`.
   */
  var inv = typed('inv', {
    'Array | Matrix': function (x) {
      var size = (x.isMatrix === true) ? x.size() : util.array.size(x);
      switch (size.length) {
        case 1:
          // vector
          if (size[0] == 1) {
            if (x.isMatrix === true) {
              return matrix([
                divideScalar(1, x.valueOf()[0])
              ]);
            }
            else {
              return [
                divideScalar(1, x[0])
              ];
            }
          }
          else {
            throw new RangeError('Matrix must be square ' +
            '(size: ' + util.string.format(size) + ')');
          }

        case 2:
          // two dimensional array
          var rows = size[0];
          var cols = size[1];
          if (rows == cols) {
            if (x.isMatrix === true) {
              return matrix(
                  _inv(x.valueOf(), rows, cols),
                  x.storage()
              );
            }
            else {
              // return an Array
              return _inv(x, rows, cols);
            }
          }
          else {
            throw new RangeError('Matrix must be square ' +
            '(size: ' + util.string.format(size) + ')');
          }

        default:
          // multi dimensional array
          throw new RangeError('Matrix must be two dimensional ' +
          '(size: ' + util.string.format(size) + ')');
      }
    },

    'any': function (x) {
      // scalar
      return divideScalar(1, x); // FIXME: create a BigNumber one when configured for bignumbers
    }
  });

  /**
   * Calculate the inverse of a square matrix
   * @param {Array[]} mat     A square matrix
   * @param {number} rows     Number of rows
   * @param {number} cols     Number of columns, must equal rows
   * @return {Array[]} inv    Inverse matrix
   * @private
   */
  function _inv (mat, rows, cols){
    var r, s, f, value, temp;

    if (rows == 1) {
      // this is a 1 x 1 matrix
      value = mat[0][0];
      if (value == 0) {
        throw Error('Cannot calculate inverse, determinant is zero');
      }
      return [[
        divideScalar(1, value)
      ]];
    }
    else if (rows == 2) {
      // this is a 2 x 2 matrix
      var d = det(mat);
      if (d == 0) {
        throw Error('Cannot calculate inverse, determinant is zero');
      }
      return [
        [
          divideScalar(mat[1][1], d),
          divideScalar(unaryMinus(mat[0][1]), d)
        ],
        [
          divideScalar(unaryMinus(mat[1][0]), d),
          divideScalar(mat[0][0], d)
        ]
      ];
    }
    else {
      // this is a matrix of 3 x 3 or larger
      // calculate inverse using gauss-jordan elimination
      //      http://en.wikipedia.org/wiki/Gaussian_elimination
      //      http://mathworld.wolfram.com/MatrixInverse.html
      //      http://math.uww.edu/~mcfarlat/inverse.htm

      // make a copy of the matrix (only the arrays, not of the elements)
      var A = mat.concat();
      for (r = 0; r < rows; r++) {
        A[r] = A[r].concat();
      }

      // create an identity matrix which in the end will contain the
      // matrix inverse
      var B = eye(rows).valueOf();

      // loop over all columns, and perform row reductions
      for (var c = 0; c < cols; c++) {
        // element Acc should be non zero. if not, swap content
        // with one of the lower rows
        r = c;
        while (r < rows && A[r][c] == 0) {
          r++;
        }
        if (r == rows || A[r][c] == 0) {
          // TODO: in case of zero det, just return a matrix wih Infinity values? (like octave)
          throw Error('Cannot calculate inverse, determinant is zero');
        }
        if (r != c) {
          temp = A[c]; A[c] = A[r]; A[r] = temp;
          temp = B[c]; B[c] = B[r]; B[r] = temp;
        }

        // eliminate non-zero values on the other rows at column c
        var Ac = A[c],
            Bc = B[c];
        for (r = 0; r < rows; r++) {
          var Ar = A[r],
              Br = B[r];
          if(r != c) {
            // eliminate value at column c and row r
            if (Ar[c] != 0) {
              f = divideScalar(unaryMinus(Ar[c]), Ac[c]);

              // add (f * row c) to row r to eliminate the value
              // at column c
              for (s = c; s < cols; s++) {
                Ar[s] = addScalar(Ar[s], multiply(f, Ac[s]));
              }
              for (s = 0; s < cols; s++) {
                Br[s] = addScalar(Br[s],  multiply(f, Bc[s]));
              }
            }
          }
          else {
            // normalize value at Acc to 1,
            // divide each value on row r with the value at Acc
            f = Ac[c];
            for (s = c; s < cols; s++) {
              Ar[s] = divideScalar(Ar[s], f);
            }
            for (s = 0; s < cols; s++) {
              Br[s] = divideScalar(Br[s], f);
            }
          }
        }
      }
      return B;
    }
  }

  inv.toTex = '\\left(${args[0]}\\right)^{-1}';

  return inv;
}

exports.name = 'inv';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../utils/index":481,"../arithmetic/addScalar":256,"../arithmetic/divideScalar":261,"../arithmetic/multiply":275,"../arithmetic/unaryMinus":285,"../matrix/det":317,"./eye":320}],326:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  /**
   * Create a new matrix or array with the results of the callback function executed on
   * each entry of the matrix/array.
   *
   * Syntax:
   *
   *    math.map(x, callback)
   *
   * Examples:
   *
   *    math.map([1, 2, 3], function(value) {
   *      return value * value;
   *    });  // returns [1, 4, 9]
   *
   * See also:
   *
   *    filter, forEach, sort
   *
   * @param {Matrix | Array} x    The matrix to iterate on.
   * @param {Function} callback   The callback method is invoked with three
   *                              parameters: the value of the element, the index
   *                              of the element, and the matrix being traversed.
   * @return {Matrix | array}     Transformed map of x
   */
  var map = typed('map', {
    'Array, function': _map,

    'Matrix, function': function (x, callback) {
      return x.map(callback);
    }
  });

  map.toTex = '\\mathrm{${name}}\\left(${args}\\right)';

  return map;
}

/**
 * Map for a multi dimensional array
 * @param {Array} array
 * @param {Function} callback
 * @return {Array}
 * @private
 */
function _map (array, callback) {
  var recurse = function (value, index) {
    if (Array.isArray(value)) {
      return value.map(function (child, i) {
        // we create a copy of the index array and append the new index value
        return recurse(child, index.concat(i));
      });
    }
    else {
      return callback(value, index, array);
    }
  };

  return recurse(array, []);
}

exports.name = 'map';
exports.factory = factory;

},{}],327:[function(require,module,exports){
'use strict';

var isInteger = require('../../utils/number').isInteger;
var resize = require('../../utils/array').resize;

function factory (type, config, load, typed) {
  var matrix = load(require('../../type/matrix/function/matrix'));

  /**
   * Create a matrix filled with ones. The created matrix can have one or
   * multiple dimensions.
   *
   * Syntax:
   *
   *    math.ones(m)
   *    math.ones(m, format)
   *    math.ones(m, n)
   *    math.ones(m, n, format)
   *    math.ones([m, n])
   *    math.ones([m, n], format)
   *    math.ones([m, n, p, ...])
   *    math.ones([m, n, p, ...], format)
   *
   * Examples:
   *
   *    math.ones(3);                   // returns [1, 1, 1]
   *    math.ones(3, 2);                // returns [[1, 1], [1, 1], [1, 1]]
   *    math.ones(3, 2, 'dense');       // returns Dense Matrix [[1, 1], [1, 1], [1, 1]]
   *
   *    var A = [[1, 2, 3], [4, 5, 6]];
   *    math.ones(math.size(A));       // returns [[1, 1, 1], [1, 1, 1]]
   *
   * See also:
   *
   *    zeros, eye, size, range
   *
   * @param {...number | Array} size    The size of each dimension of the matrix
   * @param {string} [format]           The Matrix storage format
   *
   * @return {Array | Matrix | number}  A matrix filled with ones
   */
  var ones = typed('ones', {
    '': function () {
      return (config.matrix === 'Array')
          ? _ones([])
          : _ones([], 'default');
    },

    // math.ones(m, n, p, ..., format)
    // TODO: more accurate signature '...number | BigNumber, string' as soon as typed-function supports this
    '...number | BigNumber | string': function (size) {
      var last = size[size.length - 1];
      if (typeof last === 'string') {
        var format = size.pop();
        return _ones(size, format);
      }
      else if (config.matrix === 'Array') {
        return _ones(size);
      }
      else {
        return _ones(size, 'default');
      }
    },

    'Array': _ones,

    'Matrix': function (size) {
      var format = size.storage();
      return _ones(size.valueOf(), format);
    },

    'Array | Matrix, string': function (size, format) {
      return _ones (size.valueOf(), format);
    }
  });

  ones.toTex = '\\mathrm{${name}}\\left(${args}\\right)';

  return ones;

  /**
   * Create an Array or Matrix with ones
   * @param {Array} size
   * @param {string} [format='default']
   * @return {Array | Matrix}
   * @private
   */
  function _ones(size, format) {
    var hasBigNumbers = _normalize(size);
    var defaultValue = hasBigNumbers ? new type.BigNumber(1) : 1;
    _validate(size);

    if (format) {
      // return a matrix
      var m = matrix(format);
      if (size.length > 0) {
        return m.resize(size, defaultValue);
      }
      return m;
    }
    else {
      // return an Array
      var arr = [];
      if (size.length > 0) {
        return resize(arr, size, defaultValue);
      }
      return arr;
    }
  }

  // replace BigNumbers with numbers, returns true if size contained BigNumbers
  function _normalize(size) {
    var hasBigNumbers = false;
    size.forEach(function (value, index, arr) {
      if (value && value.isBigNumber === true) {
        hasBigNumbers = true;
        arr[index] = value.toNumber();
      }
    });
    return hasBigNumbers;
  }

  // validate arguments
  function _validate (size) {
    size.forEach(function (value) {
      if (typeof value !== 'number' || !isInteger(value) || value < 0) {
        throw new Error('Parameters in function ones must be positive integers');
      }
    });
  }
}

exports.name = 'ones';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../utils/array":461,"../../utils/number":483}],328:[function(require,module,exports){
'use strict';

var isInteger = require('../../utils/number').isInteger;

function factory (type, config, load, typed) {
  var asc = load(require('../relational/compare'));
  function desc(a, b) {
    return -asc(a, b);
  }

  /**
   * Partition-based selection of an array or 1D matrix.
   * Will find the kth smallest value, and mutates the input array.
   * Uses Quickselect.
   *
   * Syntax:
   *
   *    math.partitionSelect(x, k)
   *    math.partitionSelect(x, k, compare)
   *
   * Examples:
   *
   *    math.partitionSelect([5, 10, 1], 2);           // returns 10
   *    math.partitionSelect(['C', 'B', 'A', 'D'], 1); // returns 'B'
   *
   *    function sortByLength (a, b) {
   *      return a.length - b.length;
   *    }
   *    math.partitionSelect(['Langdon', 'Tom', 'Sara'], 2, sortByLength); // returns 'Langdon'
   *
   * See also:
   *
   *    sort
   *
   * @param {Matrix | Array} x    A one dimensional matrix or array to sort
   * @param {Number} k            The kth smallest value to be retrieved; zero-based index
   * @param {Function | 'asc' | 'desc'} [compare='asc']
   *        An optional comparator function. The function is called as
   *        `compare(a, b)`, and must return 1 when a > b, -1 when a < b,
   *        and 0 when a == b.
   * @return {*} Returns the kth lowest value.
   */
  return typed('partitionSelect', {
    'Array | Matrix, number': function (x, k) {
      return _partitionSelect(x, k, asc);
    },

    'Array | Matrix, number, string': function (x, k, compare) {
      if (compare === 'asc') {
        return _partitionSelect(x, k, asc);
      }
      else if (compare === 'desc') {
        return _partitionSelect(x, k, desc);
      }
      else {
        throw new Error('Compare string must be "asc" or "desc"');
      }
    },

    'Array | Matrix, number, function': _partitionSelect
  });

  function _partitionSelect(x, k, compare) {
    if (!isInteger(k) || k < 0) {
      throw new Error('k must be a non-negative integer');
    }

    if (x && x.isMatrix) {
      var size = x.size();
      if (size.length > 1) {
        throw new Error('Only one dimensional matrices supported');
      }
      return quickSelect(x.valueOf(), k, compare);
    }

    if (Array.isArray(x)) {
      return quickSelect(x, k, compare);
    }
  }

  /**
   * Quickselect algorithm.
   * Code adapted from:
   * http://blog.teamleadnet.com/2012/07/quick-select-algorithm-find-kth-element.html
   *
   * @param {Array} arr
   * @param {Number} k
   * @param {Function} compare
   * @private
   */
  function quickSelect(arr, k, compare) {
    if (k >= arr.length) {
      throw new Error('k out of bounds');
    }

    var from = 0;
    var to = arr.length - 1;

    // if from == to we reached the kth element
    while (from < to) {
      var r = from;
      var w = to;
      var pivot = arr[Math.floor(Math.random() * (to - from + 1)) + from];

      // stop if the reader and writer meets
      while (r < w) {
        // arr[r] >= pivot
        if (compare(arr[r], pivot) >= 0) { // put the large values at the end
          var tmp = arr[w];
          arr[w] = arr[r];
          arr[r] = tmp;
          --w;
        } else { // the value is smaller than the pivot, skip
          ++r;
        }
      }

      // if we stepped up (r++) we need to step one down (arr[r] > pivot)
      if (compare(arr[r], pivot) > 0) {
        --r;
      }

      // the r pointer is on the end of the first k elements
      if (k <= r) {
        to = r;
      } else {
        from = r + 1;
      }
    }

    return arr[k];
  }
}

exports.name = 'partitionSelect';
exports.factory = factory;

},{"../../utils/number":483,"../relational/compare":349}],329:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  var matrix = load(require('../../type/matrix/function/matrix'));

  var ZERO = new type.BigNumber(0);
  var ONE = new type.BigNumber(1);

  /**
   * Create an array from a range.
   * By default, the range end is excluded. This can be customized by providing
   * an extra parameter `includeEnd`.
   *
   * Syntax:
   *
   *     math.range(str [, includeEnd])               // Create a range from a string,
   *                                                  // where the string contains the
   *                                                  // start, optional step, and end,
   *                                                  // separated by a colon.
   *     math.range(start, end [, includeEnd])        // Create a range with start and
   *                                                  // end and a step size of 1.
   *     math.range(start, end, step [, includeEnd])  // Create a range with start, step,
   *                                                  // and end.
   *
   * Where:
   *
   * - `str: string`
   *   A string 'start:end' or 'start:step:end'
   * - `start: {number | BigNumber}`
   *   Start of the range
   * - `end: number | BigNumber`
   *   End of the range, excluded by default, included when parameter includeEnd=true
   * - `step: number | BigNumber`
   *   Step size. Default value is 1.
   * - `includeEnd: boolean`
   *   Option to specify whether to include the end or not. False by default.
   *
   * Examples:
   *
   *     math.range(2, 6);        // [2, 3, 4, 5]
   *     math.range(2, -3, -1);   // [2, 1, 0, -1, -2]
   *     math.range('2:1:6');     // [2, 3, 4, 5]
   *     math.range(2, 6, true);  // [2, 3, 4, 5, 6]
   *
   * See also:
   *
   *     ones, zeros, size, subset
   *
   * @param {*} args   Parameters describing the ranges `start`, `end`, and optional `step`.
   * @return {Array | Matrix} range
   */
  var range = typed('range', {
    // TODO: simplify signatures when typed-function supports default values and optional arguments

    // TODO: a number or boolean should not be converted to string here
    'string': _strRange,
    'string, boolean': _strRange,

    'number, number':  function (start, end) {
      return _out(_rangeEx(start, end, 1));
    },
    'number, number, number': function (start, end, step) {
      return _out(_rangeEx(start, end, step));
    },
    'number, number, boolean': function (start, end, includeEnd) {
      return includeEnd
          ? _out(_rangeInc(start, end, 1))
          : _out(_rangeEx(start, end, 1));
    },
    'number, number, number, boolean': function (start, end, step, includeEnd) {
      return includeEnd
          ? _out(_rangeInc(start, end, step))
          : _out(_rangeEx(start, end, step));
    },

    'BigNumber, BigNumber':  function (start, end) {
      return _out(_bigRangeEx(start, end, ONE));
    },
    'BigNumber, BigNumber, BigNumber': function (start, end, step) {
      return _out(_bigRangeEx(start, end, step));
    },
    'BigNumber, BigNumber, boolean': function (start, end, includeEnd) {
      return includeEnd
          ? _out(_bigRangeInc(start, end, ONE))
          : _out(_bigRangeEx(start, end, ONE));
    },
    'BigNumber, BigNumber, BigNumber, boolean': function (start, end, step, includeEnd) {
      return includeEnd
          ? _out(_bigRangeInc(start, end, step))
          : _out(_bigRangeEx(start, end, step));
    }

  });

  range.toTex = '\\mathrm{${name}}\\left(${args}\\right)';

  return range;

  function _out(arr) {
    return config.matrix === 'Array' ? arr : matrix(arr);
  }

  function _strRange (str, includeEnd) {
    var r = _parse(str);
    if (!r){
      throw new SyntaxError('String "' + str + '" is no valid range');
    }

    var fn;
    if (config.number === 'BigNumber') {
      fn = includeEnd ? _bigRangeInc : _bigRangeEx;
      return _out(fn(
          new type.BigNumber(r.start),
          new type.BigNumber(r.end),
          new type.BigNumber(r.step)));
    }
    else {
      fn = includeEnd ? _rangeInc : _rangeEx;
      return _out(fn(r.start, r.end, r.step));
    }
  }

  /**
   * Create a range with numbers. End is excluded
   * @param {number} start
   * @param {number} end
   * @param {number} step
   * @returns {Array} range
   * @private
   */
  function _rangeEx (start, end, step) {
    var array = [],
        x = start;
    if (step > 0) {
      while (x < end) {
        array.push(x);
        x += step;
      }
    }
    else if (step < 0) {
      while (x > end) {
        array.push(x);
        x += step;
      }
    }

    return array;
  }

  /**
   * Create a range with numbers. End is included
   * @param {number} start
   * @param {number} end
   * @param {number} step
   * @returns {Array} range
   * @private
   */
  function _rangeInc (start, end, step) {
    var array = [],
        x = start;
    if (step > 0) {
      while (x <= end) {
        array.push(x);
        x += step;
      }
    }
    else if (step < 0) {
      while (x >= end) {
        array.push(x);
        x += step;
      }
    }

    return array;
  }

  /**
   * Create a range with big numbers. End is excluded
   * @param {BigNumber} start
   * @param {BigNumber} end
   * @param {BigNumber} step
   * @returns {Array} range
   * @private
   */
  function _bigRangeEx (start, end, step) {
    var array = [],
        x = start;
    if (step.gt(ZERO)) {
      while (x.lt(end)) {
        array.push(x);
        x = x.plus(step);
      }
    }
    else if (step.lt(ZERO)) {
      while (x.gt(end)) {
        array.push(x);
        x = x.plus(step);
      }
    }

    return array;
  }

  /**
   * Create a range with big numbers. End is included
   * @param {BigNumber} start
   * @param {BigNumber} end
   * @param {BigNumber} step
   * @returns {Array} range
   * @private
   */
  function _bigRangeInc (start, end, step) {
    var array = [],
        x = start;
    if (step.gt(ZERO)) {
      while (x.lte(end)) {
        array.push(x);
        x = x.plus(step);
      }
    }
    else if (step.lt(ZERO)) {
      while (x.gte(end)) {
        array.push(x);
        x = x.plus(step);
      }
    }

    return array;
  }

  /**
   * Parse a string into a range,
   * The string contains the start, optional step, and end, separated by a colon.
   * If the string does not contain a valid range, null is returned.
   * For example str='0:2:11'.
   * @param {string} str
   * @return {{start: number, end: number, step: number} | null} range Object containing properties start, end, step
   * @private
   */
  function _parse (str) {
    var args = str.split(':');

    // number
    var nums = args.map(function (arg) {
      // use Number and not parseFloat as Number returns NaN on invalid garbage in the string
      return Number(arg);
    });

    var invalid = nums.some(function (num) {
      return isNaN(num);
    });
    if(invalid) {
      return null;
    }

    switch (nums.length) {
      case 2:
        return {
          start: nums[0],
          end: nums[1],
          step: 1
        };

      case 3:
        return {
          start: nums[0],
          end: nums[2],
          step: nums[1]
        };

      default:
        return null;
    }
  }

}

exports.name = 'range';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435}],330:[function(require,module,exports){
'use strict';

var DimensionError = require('../../error/DimensionError');
var ArgumentsError = require('../../error/ArgumentsError');

var isInteger = require('../../utils/number').isInteger;
var format = require('../../utils/string').format;
var clone = require('../../utils/object').clone;
var array = require('../../utils/array');

function factory (type, config, load, typed) {
  var matrix = load(require('../../type/matrix/function/matrix'));

  /**
   * Resize a matrix
   *
   * Syntax:
   *
   *     math.resize(x, size)
   *     math.resize(x, size, defaultValue)
   *
   * Examples:
   *
   *     math.resize([1, 2, 3, 4, 5], [3]); // returns Array  [1, 2, 3]
   *     math.resize([1, 2, 3], [5], 0);    // returns Array  [1, 2, 3, 0, 0]
   *     math.resize(2, [2, 3], 0);         // returns Matrix [[2, 0, 0], [0, 0, 0]]
   *     math.resize("hello", [8], "!");    // returns string 'hello!!!'
   *
   * See also:
   *
   *     size, squeeze, subset
   *
   * @param {Array | Matrix | *} x             Matrix to be resized
   * @param {Array | Matrix} size              One dimensional array with numbers
   * @param {number | string} [defaultValue=0] Zero by default, except in
   *                                           case of a string, in that case
   *                                           defaultValue = ' '
   * @return {* | Array | Matrix} A resized clone of matrix `x`
   */
  // TODO: rework resize to a typed-function
  var resize = function resize (x, size, defaultValue) {
    if (arguments.length != 2 && arguments.length != 3) {
      throw new ArgumentsError('resize', arguments.length, 2, 3);
    }

    if (size && size.isMatrix === true) {
      size = size.valueOf(); // get Array
    }

    if (size.length && size[0] && size[0].isBigNumber === true) {
      // convert bignumbers to numbers
      size = size.map(function (value) {
        return (value && value.isBigNumber === true) ? value.toNumber() : value;
      });
    }
    
    // check x is a Matrix
    if (x && x.isMatrix === true) {
      // use optimized matrix implementation, return copy
      return x.resize(size, defaultValue, true);
    }
    
    if (typeof x === 'string') {
      // resize string
      return _resizeString(x, size, defaultValue);
    }
    
    // check result should be a matrix
    var asMatrix = Array.isArray(x) ? false : (config.matrix !== 'Array');

    if (size.length == 0) {
      // output a scalar
      while (Array.isArray(x)) {
        x = x[0];
      }

      return clone(x);
    }
    else {
      // output an array/matrix
      if (!Array.isArray(x)) {
        x = [x];
      }
      x = clone(x);

      var res = array.resize(x, size, defaultValue);
      return asMatrix ? matrix(res) : res;
    }
  };

  resize.toTex = '\\mathrm{${name}}\\left(${args}\\right)';

  return resize;

  /**
   * Resize a string
   * @param {string} str
   * @param {number[]} size
   * @param {string} [defaultChar=' ']
   * @private
   */
  function _resizeString(str, size, defaultChar) {
    if (defaultChar !== undefined) {
      if (typeof defaultChar !== 'string' || defaultChar.length !== 1) {
        throw new TypeError('Single character expected as defaultValue');
      }
    }
    else {
      defaultChar = ' ';
    }

    if (size.length !== 1) {
      throw new DimensionError(size.length, 1);
    }
    var len = size[0];
    if (typeof len !== 'number' || !isInteger(len)) {
      throw new TypeError('Invalid size, must contain positive integers ' +
          '(size: ' + format(size) + ')');
    }

    if (str.length > len) {
      return str.substring(0, len);
    }
    else if (str.length < len) {
      var res = str;
      for (var i = 0, ii = len - str.length; i < ii; i++) {
        res += defaultChar;
      }
      return res;
    }
    else {
      return str;
    }
  }
}

exports.name = 'resize';
exports.factory = factory;

},{"../../error/ArgumentsError":10,"../../error/DimensionError":11,"../../type/matrix/function/matrix":435,"../../utils/array":461,"../../utils/number":483,"../../utils/object":484,"../../utils/string":485}],331:[function(require,module,exports){
'use strict';

var array = require('../../utils/array');

function factory (type, config, load, typed) {
  var matrix = load(require('../../type/matrix/function/matrix'));

  /**
   * Calculate the size of a matrix or scalar.
   *
   * Syntax:
   *
   *     math.size(x)
   *
   * Examples:
   *
   *     math.size(2.3);                  // returns []
   *     math.size('hello world');        // returns [11]
   *
   *     var A = [[1, 2, 3], [4, 5, 6]];
   *     math.size(A);                    // returns [2, 3]
   *     math.size(math.range(1,6));      // returns [5]
   *
   * See also:
   *
   *     resize, squeeze, subset
   *
   * @param {boolean | number | Complex | Unit | string | Array | Matrix} x  A matrix
   * @return {Array | Matrix} A vector with size of `x`.
   */
  var size = typed('size', {
    'Matrix': function (x) {
      // TODO: return the same matrix type as the input
      return matrix(x.size());
    },

    'Array': array.size,

    'string': function (x) {
      return (config.matrix === 'Array') ? [x.length] : matrix([x.length]);
    },

    'number | Complex | BigNumber | Unit | boolean | null': function (x) {
      // scalar
      return (config.matrix === 'Array') ? [] : matrix([]);
    }
  });

  size.toTex = '\\mathrm{${name}}\\left(${args}\\right)';

  return size;
}

exports.name = 'size';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../utils/array":461}],332:[function(require,module,exports){
'use strict';

var size = require('../../utils/array').size;

function factory (type, config, load, typed) {
  var matrix = load(require('../../type/matrix/function/matrix'));
  var asc = load(require('../relational/compare'));
  var desc = function (a, b) {
    return -asc(a, b);
  };

  /**
   * Sort the items in a matrix.
   *
   * Syntax:
   *
   *    math.sort(x)
   *    math.sort(x, compare)
   *
   * Examples:
   *
   *    math.sort([5, 10, 1]); // returns [1, 5, 10]
   *    math.sort(['C', 'B', 'A', 'D']); // returns ['A', 'B', 'C', 'D']
   *
   *    function sortByLength (a, b) {
   *      return a.length - b.length;
   *    }
   *    math.sort(['Langdon', 'Tom', 'Sara'], sortByLength); // returns ['Tom', 'Sara', 'Langdon']
   *
   * See also:
   *
   *    filter, forEach, map
   *
   * @param {Matrix | Array} x    A one dimensional matrix or array to sort
   * @param {Function | 'asc' | 'desc'} [compare='asc']
   *        An optional _comparator function. The function is called as
   *        `compare(a, b)`, and must return 1 when a > b, -1 when a < b,
   *        and 0 when a == b.
   * @return {Matrix | Array} Returns the sorted matrix.
   */
  var sort = typed('sort', {
    'Array': function (x) {
      _arrayIsVector(x);
      return x.sort(asc);
    },

    'Matrix': function (x) {
      _matrixIsVector(x);
      return matrix(x.toArray().sort(asc), x.storage());
    },

    'Array, function': function (x, _comparator) {
      _arrayIsVector(x);
      return x.sort(_comparator);
    },

    'Matrix, function': function (x, _comparator) {
      _matrixIsVector(x);
      return matrix(x.toArray().sort(_comparator), x.storage());
    },

    'Array, string': function (x, order) {
      _arrayIsVector(x);
      return x.sort(_comparator(order));
    },

    'Matrix, string': function (x, order) {
      _matrixIsVector(x);
      return matrix(x.toArray().sort(_comparator(order)), x.storage());
    }
  });

  sort.toTex = '\\mathrm{${name}}\\left(${args}\\right)';

  /**
   * Get the comparator for given order ('asc' or 'desc')
   * @param {'asc' | 'desc'} order
   * @return {Function} Returns a _comparator function
   */
  function _comparator (order) {
    if (order === 'asc') {
      return asc;
    }
    else if (order === 'desc') {
      return desc;
    }
    else {
      throw new Error('String "asc" or "desc" expected');
    }
  }

  /**
   * Validate whether an array is one dimensional
   * Throws an error when this is not the case
   * @param {Array} array
   * @private
   */
  function _arrayIsVector (array) {
    if (size(array).length !== 1) {
      throw new Error('One dimensional array expected');
    }
  }

  /**
   * Validate whether a matrix is one dimensional
   * Throws an error when this is not the case
   * @param {Matrix} matrix
   * @private
   */
  function _matrixIsVector (matrix) {
    if (matrix.size().length !== 1) {
      throw new Error('One dimensional matrix expected');
    }
  }

  return sort;
}

exports.name = 'sort';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../utils/array":461,"../relational/compare":349}],333:[function(require,module,exports){
'use strict';

var object = require('../../utils/object');
var array = require('../../utils/array');

function factory (type, config, load, typed) {
  var matrix = load(require('../../type/matrix/function/matrix'));

  /**
   * Squeeze a matrix, remove inner and outer singleton dimensions from a matrix.
   *
   * Syntax:
   *
   *     math.squeeze(x)
   *
   * Examples:
   *
   *     math.squeeze([3]);           // returns 3
   *     math.squeeze([[3]]);         // returns 3
   *
   *     var A = math.zeros(3, 1);    // returns [[0], [0], [0]] (size 3x1)
   *     math.squeeze(A);             // returns [0, 0, 0] (size 3)
   *
   *     var B = math.zeros(1, 3);    // returns [[0, 0, 0]] (size 1x3)
   *     math.squeeze(B);             // returns [0, 0, 0] (size 3)
   *
   *     // only inner and outer dimensions are removed
   *     var C = math.zeros(2, 1, 3); // returns [[[0, 0, 0]], [[0, 0, 0]]] (size 2x1x3)
   *     math.squeeze(C);             // returns [[[0, 0, 0]], [[0, 0, 0]]] (size 2x1x3)
   *
   * See also:
   *
   *     subset
   *
   * @param {Matrix | Array} x      Matrix to be squeezed
   * @return {Matrix | Array} Squeezed matrix
   */
  var squeeze = typed('squeeze', {
    'Array': function (x) {
      return array.squeeze(object.clone(x));
    },

    'Matrix': function (x) {
      var res = array.squeeze(x.toArray());
      // FIXME: return the same type of matrix as the input
      return Array.isArray(res) ? matrix(res) : res;
    },

    'any': function (x) {
      // scalar
      return object.clone(x);
    }
  });

  squeeze.toTex = '\\mathrm{${name}}\\left(${args}\\right)';

  return squeeze;
}

exports.name = 'squeeze';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../utils/array":461,"../../utils/object":484}],334:[function(require,module,exports){
'use strict';

var clone = require('../../utils/object').clone;
var validateIndex = require('../../utils/array').validateIndex;
var DimensionError = require('../../error/DimensionError');

function factory (type, config, load, typed) {
  var matrix = load(require('../../type/matrix/function/matrix'));

  /**
   * Get or set a subset of a matrix or string.
   *
   * Syntax:
   *     math.subset(value, index)                                // retrieve a subset
   *     math.subset(value, index, replacement [, defaultValue])  // replace a subset
   *
   * Examples:
   *
   *     // get a subset
   *     var d = [[1, 2], [3, 4]];
   *     math.subset(d, math.index(1, 0));        // returns 3
   *     math.subset(d, math.index([0, 2], 1));   // returns [[2], [4]]
   *
   *     // replace a subset
   *     var e = [];
   *     var f = math.subset(e, math.index(0, [0, 2]), [5, 6]);  // f = [[5, 6]]
   *     var g = math.subset(f, math.index(1, 1), 7, 0);         // g = [[5, 6], [0, 7]]
   *
   * See also:
   *
   *     size, resize, squeeze, index
   *
   * @param {Array | Matrix | string} matrix  An array, matrix, or string
   * @param {Index} index                     An index containing ranges for each
   *                                          dimension
   * @param {*} [replacement]                 An array, matrix, or scalar.
   *                                          If provided, the subset is replaced with replacement.
   *                                          If not provided, the subset is returned
   * @param {*} [defaultValue=undefined]      Default value, filled in on new entries when
   *                                          the matrix is resized. If not provided,
   *                                          math.matrix elements will be left undefined.
   * @return {Array | Matrix | string} Either the retrieved subset or the updated matrix.
   */
  var subset = typed('subset', {
    // get subset
    'Array, Index': function (value, index) {
      var m = matrix(value);
      var subset = m.subset(index);       // returns a Matrix
      return subset && subset.valueOf();  // return an Array (like the input)
    },

    'Matrix, Index': function (value, index) {
      return value.subset(index);
    },

    'Object, Index': _getObjectProperty,

    'string, Index': _getSubstring,

    // set subset
    'Array, Index, any': function (value, index, replacement) {
      return matrix(clone(value))
          .subset(index, replacement, undefined)
          .valueOf();
    },

    'Array, Index, any, any': function (value, index, replacement, defaultValue) {
      return matrix(clone(value))
          .subset(index, replacement, defaultValue)
          .valueOf();
    },

    'Matrix, Index, any': function (value, index, replacement) {
      return value.clone().subset(index, replacement);
    },

    'Matrix, Index, any, any': function (value, index, replacement, defaultValue) {
      return value.clone().subset(index, replacement, defaultValue);
    },

    'string, Index, string': _setSubstring,
    'string, Index, string, string': _setSubstring,
    'Object, Index, any': _setObjectProperty
  });

  subset.toTex = '\\mathrm{${name}}\\left(${args}\\right)';

  return subset;

  /**
   * Retrieve a subset of a string
   * @param {string} str            string from which to get a substring
   * @param {Index} index           An index containing ranges for each dimension
   * @returns {string} substring
   * @private
   */
  function _getSubstring(str, index) {
    if (!index || index.isIndex !== true) {
      // TODO: better error message
      throw new TypeError('Index expected');
    }
    if (index.size().length != 1) {
      throw new DimensionError(index.size().length, 1);
    }

    // validate whether the range is out of range
    var strLen = str.length;
    validateIndex(index.min()[0], strLen);
    validateIndex(index.max()[0], strLen);

    var range = index.dimension(0);

    var substr = '';
    range.forEach(function (v) {
      substr += str.charAt(v);
    });

    return substr;
  }

  /**
   * Replace a substring in a string
   * @param {string} str            string to be replaced
   * @param {Index} index           An index containing ranges for each dimension
   * @param {string} replacement    Replacement string
   * @param {string} [defaultValue] Default value to be uses when resizing
   *                                the string. is ' ' by default
   * @returns {string} result
   * @private
   */
  function _setSubstring(str, index, replacement, defaultValue) {
    if (!index || index.isIndex !== true) {
      // TODO: better error message
      throw new TypeError('Index expected');
    }
    if (index.size().length != 1) {
      throw new DimensionError(index.size().length, 1);
    }
    if (defaultValue !== undefined) {
      if (typeof defaultValue !== 'string' || defaultValue.length !== 1) {
        throw new TypeError('Single character expected as defaultValue');
      }
    }
    else {
      defaultValue = ' ';
    }

    var range = index.dimension(0);
    var len = range.size()[0];

    if (len != replacement.length) {
      throw new DimensionError(range.size()[0], replacement.length);
    }

    // validate whether the range is out of range
    var strLen = str.length;
    validateIndex(index.min()[0]);
    validateIndex(index.max()[0]);

    // copy the string into an array with characters
    var chars = [];
    for (var i = 0; i < strLen; i++) {
      chars[i] = str.charAt(i);
    }

    range.forEach(function (v, i) {
      chars[v] = replacement.charAt(i[0]);
    });

    // initialize undefined characters with a space
    if (chars.length > strLen) {
      for (i = strLen - 1, len = chars.length; i < len; i++) {
        if (!chars[i]) {
          chars[i] = defaultValue;
        }
      }
    }

    return chars.join('');
  }
}

/**
 * Retrieve a property from an object
 * @param {Object} object
 * @param {Index} index
 * @return {*} Returns the value of the property
 * @private
 */
function _getObjectProperty (object, index) {
  if (index.size().length !== 1) {
    throw new DimensionError(index.size(), 1);
  }

  var key = index.dimension(0);
  if (typeof key !== 'string') {
    throw new TypeError('String expected as index to retrieve an object property');
  }

  return object[key];
}

/**
 * Set a property on an object
 * @param {Object} object
 * @param {Index} index
 * @param {*} replacement
 * @return {*} Returns the updated object
 * @private
 */
function _setObjectProperty (object, index, replacement) {
  if (index.size().length !== 1) {
    throw new DimensionError(index.size(), 1);
  }

  var key = index.dimension(0);
  if (typeof key !== 'string') {
    throw new TypeError('String expected as index to retrieve an object property');
  }

  // clone the object, and apply the property to the clone
  var updated = clone(object);
  updated[key] = replacement;

  return updated;
}

exports.name = 'subset';
exports.factory = factory;

},{"../../error/DimensionError":11,"../../type/matrix/function/matrix":435,"../../utils/array":461,"../../utils/object":484}],335:[function(require,module,exports){
'use strict';

var clone = require('../../utils/object').clone;
var format = require('../../utils/string').format;

function factory (type, config, load, typed) {
  
  var matrix = load(require('../../type/matrix/function/matrix'));
  var add = load(require('../arithmetic/add'));

  /**
   * Calculate the trace of a matrix: the sum of the elements on the main
   * diagonal of a square matrix.
   *
   * Syntax:
   *
   *    math.trace(x)
   *
   * Examples:
   *
   *    math.trace([[1, 2], [3, 4]]); // returns 5
   *
   *    var A = [
   *      [1, 2, 3],
   *      [-1, 2, 3],
   *      [2, 0, 3]
   *    ]
   *    math.trace(A); // returns 6
   *
   * See also:
   *
   *    diag
   *
   * @param {Array | Matrix} x  A matrix
   *
   * @return {number} The trace of `x`
   */
  var trace = typed('trace', {
    
    'Array': function (x) {
      // use dense matrix implementation
      return trace(matrix(x));
    },

    'Matrix': function (x) {
      // result
      var c;
      // process storage format
      switch (x.storage()) {
        case 'dense':
          c = _denseTrace(x);
          break;
        case 'sparse':
          c = _sparseTrace(x);
          break;
      }
      return c;
    },
    
    'any': clone
  });
  
  var _denseTrace = function (m) {
    // matrix size & data
    var size = m._size;
    var data = m._data;
    
    // process dimensions
    switch (size.length) {
      case 1:
        // vector
        if (size[0] == 1) {
          // return data[0]
          return clone(data[0]);
        }
        throw new RangeError('Matrix must be square (size: ' + format(size) + ')');
      case 2:
        // two dimensional
        var rows = size[0];
        var cols = size[1];
        if (rows === cols) {
          // calulate sum
          var sum = 0;
          // loop diagonal
          for (var i = 0; i < rows; i++)
            sum = add(sum, data[i][i]);
          // return trace
          return sum;
        }
        throw new RangeError('Matrix must be square (size: ' + format(size) + ')');        
      default:
        // multi dimensional
        throw new RangeError('Matrix must be two dimensional (size: ' + format(size) + ')');
    }
  };
  
  var _sparseTrace = function (m) {
    // matrix arrays
    var values = m._values;
    var index = m._index;
    var ptr = m._ptr;
    var size = m._size;
    // check dimensions
    var rows = size[0];
    var columns = size[1];
    // matrix must be square
    if (rows === columns) {
      // calulate sum
      var sum = 0;
      // check we have data (avoid looping columns)
      if (values.length > 0) {
        // loop columns
        for (var j = 0; j < columns; j++) {
          // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
          var k0 = ptr[j];
          var k1 = ptr[j + 1];
          // loop k within [k0, k1[
          for (var k = k0; k < k1; k++) {
            // row index
            var i = index[k];
            // check row
            if (i === j) {
              // accumulate value
              sum = add(sum, values[k]);
              // exit loop
              break;
            }
            if (i > j) {
              // exit loop, no value on the diagonal for column j
              break;
            }
          }
        }
      }
      // return trace
      return sum;
    }
    throw new RangeError('Matrix must be square (size: ' + format(size) + ')');   
  };

  trace.toTex = '\\mathrm{tr}\\left(${args[0]}\\right)';
  
  return trace;
}

exports.name = 'trace';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../utils/object":484,"../../utils/string":485,"../arithmetic/add":255}],336:[function(require,module,exports){
'use strict';

var clone = require('../../utils/object').clone;
var format = require('../../utils/string').format;

function factory (type, config, load, typed) {
  var latex = require('../../utils/latex');

  var matrix = load(require('../../type/matrix/function/matrix'));

  var DenseMatrix = type.DenseMatrix,
      SparseMatrix = type.SparseMatrix;

  /**
   * Transpose a matrix. All values of the matrix are reflected over its
   * main diagonal. Only two dimensional matrices are supported.
   *
   * Syntax:
   *
   *     math.transpose(x)
   *
   * Examples:
   *
   *     var A = [[1, 2, 3], [4, 5, 6]];
   *     math.transpose(A);               // returns [[1, 4], [2, 5], [3, 6]]
   *
   * See also:
   *
   *     diag, inv, subset, squeeze
   *
   * @param {Array | Matrix} x  Matrix to be transposed
   * @return {Array | Matrix}   The transposed matrix
   */
  var transpose = typed('transpose', {

    'Array': function (x) {
      // use dense matrix implementation
      return transpose(matrix(x)).valueOf();
    },

    'Matrix': function (x) {
      // matrix size
      var size = x.size();

      // result
      var c;
      
      // process dimensions
      switch (size.length) {
        case 1:
          // vector
          c = x.clone();
          break;

        case 2:
          // rows and columns
          var rows = size[0];
          var columns = size[1];

          // check columns
          if (columns === 0) {
            // throw exception
            throw new RangeError('Cannot transpose a 2D matrix with no columns (size: ' + format(size) + ')');
          }

          // process storage format
          switch (x.storage()) {
            case 'dense':
              c = _denseTranspose(x, rows, columns);
              break;
            case 'sparse':
              c = _sparseTranspose(x, rows, columns);
              break;
          }
          break;
          
        default:
          // multi dimensional
          throw new RangeError('Matrix must be a vector or two dimensional (size: ' + format(this._size) + ')');
      }
      return c;
    },

    // scalars
    'any': function (x) {
      return clone(x);
    }
  });

  var _denseTranspose = function (m, rows, columns) {
    // matrix array
    var data = m._data;
    // transposed matrix data
    var transposed = [];
    var transposedRow;
    // loop columns
    for (var j = 0; j < columns; j++) {
      // initialize row
      transposedRow = transposed[j] = [];
      // loop rows
      for (var i = 0; i < rows; i++) {
        // set data
        transposedRow[i] = clone(data[i][j]);
      }
    }
    // return matrix
    return new DenseMatrix({
      data: transposed,
      size: [columns, rows],
      datatype: m._datatype
    });
  };

  var _sparseTranspose = function (m, rows, columns) {
    // matrix arrays
    var values = m._values;
    var index = m._index;
    var ptr = m._ptr;
    // result matrices
    var cvalues = values ? [] : undefined;
    var cindex = [];
    var cptr = [];
    // row counts
    var w = [];
    for (var x = 0; x < rows; x++)
      w[x] = 0;
    // vars
    var p, l, j;
    // loop values in matrix
    for (p = 0, l = index.length; p < l; p++) {
      // number of values in row
      w[index[p]]++;
    }
    // cumulative sum
    var sum = 0;
    // initialize cptr with the cummulative sum of row counts
    for (var i = 0; i < rows; i++) {
      // update cptr
      cptr.push(sum);
      // update sum
      sum += w[i];
      // update w
      w[i] = cptr[i];
    }
    // update cptr
    cptr.push(sum);
    // loop columns
    for (j = 0; j < columns; j++) {
      // values & index in column
      for (var k0 = ptr[j], k1 = ptr[j + 1], k = k0; k < k1; k++) {
        // C values & index
        var q = w[index[k]]++;
        // C[j, i] = A[i, j]
        cindex[q] = j;
        // check we need to process values (pattern matrix)
        if (values)
          cvalues[q] = clone(values[k]);
      }
    }
    // return matrix
    return new SparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [columns, rows],
      datatype: m._datatype
    });
  };

  transpose.toTex = '\\left(${args[0]}\\right)' + latex.operators['transpose'];

  return transpose;
}

exports.name = 'transpose';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../utils/latex":482,"../../utils/object":484,"../../utils/string":485}],337:[function(require,module,exports){
'use strict';

var isInteger = require('../../utils/number').isInteger;
var resize = require('../../utils/array').resize;

function factory (type, config, load, typed) {
  var matrix = load(require('../../type/matrix/function/matrix'));

  /**
   * Create a matrix filled with zeros. The created matrix can have one or
   * multiple dimensions.
   *
   * Syntax:
   *
   *    math.zeros(m)
   *    math.zeros(m, format)
   *    math.zeros(m, n)
   *    math.zeros(m, n, format)
   *    math.zeros([m, n])
   *    math.zeros([m, n], format)
   *
   * Examples:
   *
   *    math.zeros(3);                  // returns [0, 0, 0]
   *    math.zeros(3, 2);               // returns [[0, 0], [0, 0], [0, 0]]
   *    math.zeros(3, 'dense');         // returns [0, 0, 0]
   *
   *    var A = [[1, 2, 3], [4, 5, 6]];
   *    math.zeros(math.size(A));       // returns [[0, 0, 0], [0, 0, 0]]
   *
   * See also:
   *
   *    ones, eye, size, range
   *
   * @param {...number | Array} size    The size of each dimension of the matrix
   * @param {string} [format]           The Matrix storage format
   *
   * @return {Array | Matrix}           A matrix filled with zeros
   */
  var zeros = typed('zeros', {
    '': function () {
      return (config.matrix === 'Array')
          ? _zeros([])
          : _zeros([], 'default');
    },

    // math.zeros(m, n, p, ..., format)
    // TODO: more accurate signature '...number | BigNumber, string' as soon as typed-function supports this
    '...number | BigNumber | string': function (size) {
      var last = size[size.length - 1];
      if (typeof last === 'string') {
        var format = size.pop();
        return _zeros(size, format);
      }
      else if (config.matrix === 'Array') {
        return _zeros(size);
      }
      else {
        return _zeros(size, 'default');
      }
    },

    'Array': _zeros,

    'Matrix': function (size) {
      var format = size.storage();
      return _zeros(size.valueOf(), format);
    },

    'Array | Matrix, string': function (size, format) {
      return _zeros (size.valueOf(), format);
    }
  });

  zeros.toTex = '\\mathrm{${name}}\\left(${args}\\right)';

  return zeros;

  /**
   * Create an Array or Matrix with zeros
   * @param {Array} size
   * @param {string} [format='default']
   * @return {Array | Matrix}
   * @private
   */
  function _zeros(size, format) {
    var hasBigNumbers = _normalize(size);
    var defaultValue = hasBigNumbers ? new type.BigNumber(0) : 0;
    _validate(size);

    if (format) {
      // return a matrix
      var m = matrix(format);
      if (size.length > 0) {
        return m.resize(size, defaultValue);
      }
      return m;
    }
    else {
      // return an Array
      var arr = [];
      if (size.length > 0) {
        return resize(arr, size, defaultValue);
      }
      return arr;
    }
  }

  // replace BigNumbers with numbers, returns true if size contained BigNumbers
  function _normalize(size) {
    var hasBigNumbers = false;
    size.forEach(function (value, index, arr) {
      if (value && value.isBigNumber === true) {
        hasBigNumbers = true;
        arr[index] = value.toNumber();
      }
    });
    return hasBigNumbers;
  }

  // validate arguments
  function _validate (size) {
    size.forEach(function (value) {
      if (typeof value !== 'number' || !isInteger(value) || value < 0) {
        throw new Error('Parameters in function zeros must be positive integers');
      }
    });
  }
}

// TODO: zeros contains almost the same code as ones. Reuse this?

exports.name = 'zeros';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../utils/array":461,"../../utils/number":483}],338:[function(require,module,exports){
'use strict';

var isInteger = require('../../utils/number').isInteger;

function factory (type, config, load, typed) {
  /**
   * Compute the number of ways of picking `k` unordered outcomes from `n`
   * possibilities.
   *
   * Combinations only takes integer arguments.
   * The following condition must be enforced: k <= n.
   *
   * Syntax:
   *
   *     math.combinations(n, k)
   *
   * Examples:
   *
   *    math.combinations(7, 5); // returns 21
   *
   * See also:
   *
   *    permutations, factorial
   *
   * @param {number | BigNumber} n    Total number of objects in the set
   * @param {number | BigNumber} k    Number of objects in the subset
   * @return {number | BigNumber}     Number of possible combinations.
   */
  var combinations = typed('combinations', {
    'number, number': function (n, k) {
      var max, result, i;

      if (!isInteger(n) || n < 0) {
        throw new TypeError('Positive integer value expected in function combinations');
      }
      if (!isInteger(k) || k < 0) {
        throw new TypeError('Positive integer value expected in function combinations');
      }
      if (k > n) {
        throw new TypeError('k must be less than or equal to n');
      }

      max = Math.max(k, n - k);
      result = 1;
      for (i = 1; i <= n - max; i++) {
        result = result * (max + i) / i;
      }

      return result;
    },

    'BigNumber, BigNumber': function (n, k) {
      var max, result, i, ii;
      var one = new type.BigNumber(1);

      if (!isPositiveInteger(n) || !isPositiveInteger(k)) {
        throw new TypeError('Positive integer value expected in function combinations');
      }
      if (k.gt(n)) {
        throw new TypeError('k must be less than n in function combinations');
      }

      max = n.minus(k);
      if (k.lt(max)) max = k;
      result = one;
      for (i = one, ii = n.minus(max); i.lte(ii); i = i.plus(1)) {
        result = result.times(max.plus(i)).dividedBy(i);
      }

      return result;
    }

    // TODO: implement support for collection in combinations
  });

  combinations.toTex = '\\binom{${args[0]}}{${args[1]}}';

  return combinations;
}

/**
 * Test whether BigNumber n is a positive integer
 * @param {BigNumber} n
 * @returns {boolean} isPositiveInteger
 */
function isPositiveInteger(n) {
  return n.isInteger() && n.gte(0);
}

exports.name = 'combinations';
exports.factory = factory;

},{"../../utils/number":483}],339:[function(require,module,exports){
'use strict';

var ArgumentsError = require('../../error/ArgumentsError');
var isCollection = require('../../utils/collection/isCollection');

// TODO: rethink math.distribution
// TODO: rework to a typed function
function factory (type, config, load, typed) {
  var matrix = load(require('../../type/matrix/function/matrix'));
  var array = require('../../utils/array');

  /**
   * Create a distribution object with a set of random functions for given
   * random distribution.
   *
   * Syntax:
   *
   *     math.distribution(name)
   *
   * Examples:
   *
   *     var normalDist = math.distribution('normal'); // create a normal distribution
   *     normalDist.random(0, 10);                     // get a random value between 0 and 10
   *
   * See also:
   *
   *     random, randomInt, pickRandom
   *
   * @param {string} name   Name of a distribution. Choose from 'uniform', 'normal'.
   * @return {Object}       Returns a distribution object containing functions:
   *                        `random([size] [, min] [, max])`,
   *                        `randomInt([min] [, max])`,
   *                        `pickRandom(array)`
   */
  function distribution(name) {
    if (!distributions.hasOwnProperty(name))
      throw new Error('Unknown distribution ' + name);

    var args = Array.prototype.slice.call(arguments, 1),
        distribution = distributions[name].apply(this, args);

    return (function(distribution) {

      // This is the public API for all distributions
      var randFunctions = {

        random: function(arg1, arg2, arg3) {
          var size, min, max;
          if (arguments.length > 3) {
            throw new ArgumentsError('random', arguments.length, 0, 3);

          // `random(max)` or `random(size)`
          } else if (arguments.length === 1) {
            if (isCollection(arg1)) {
              size = arg1;
            }
            else {
              max = arg1;
            }
          // `random(min, max)` or `random(size, max)`
          } else if (arguments.length === 2) {
            if (isCollection(arg1)) {
              size = arg1;
              max = arg2;
            }
            else {
              min = arg1;
              max = arg2;
            }
          // `random(size, min, max)`
          } else {
            size = arg1;
            min = arg2;
            max = arg3;
          }

          // TODO: validate type of min, max, and size

          if (max === undefined) max = 1;
          if (min === undefined) min = 0;
          if (size !== undefined) {
            var res = _randomDataForMatrix(size.valueOf(), min, max, _random);
            return (size && size.isMatrix === true) ? matrix(res) : res;
          }
          else return _random(min, max);
        },

        randomInt: function(arg1, arg2, arg3) {
          var size, min, max;
          if (arguments.length > 3 || arguments.length < 1)
            throw new ArgumentsError('randomInt', arguments.length, 1, 3);

          // `random(max)` or `random(size)`
          else if (arguments.length === 1)
            if (isCollection(arg1)) {
              size = arg1;
            }
            else {
              max = arg1;
            }
          // `randomInt(min, max)` or `randomInt(size, max)`
          else if (arguments.length === 2) {
            if (isCollection(arg1)) {
              size = arg1;
              max = arg2;
            }
            else {
              min = arg1;
              max = arg2;
            }
          // `randomInt(size, min, max)`
          } else {
            size = arg1;
            min = arg2;
            max = arg3;
          }

          // TODO: validate type of min, max, and size

          if (min === undefined) min = 0;
          if (size !== undefined) {
            var res = _randomDataForMatrix(size.valueOf(), min, max, _randomInt);
            return (size && size.isMatrix === true) ? matrix(res) : res;
          }
          else return _randomInt(min, max);
        },

        pickRandom: function(possibles) {
          if (arguments.length !== 1) {
            throw new ArgumentsError('pickRandom', arguments.length, 1);
          }
          if (possibles && possibles.isMatrix === true) {
            possibles = possibles.valueOf(); // get Array
          }
          else if (!Array.isArray(possibles)) {
            throw new TypeError('Unsupported type of value in function pickRandom');
          }

          if (array.size(possibles).length > 1) {
            throw new Error('Only one dimensional vectors supported');
          }

          // TODO: add support for multi dimensional matrices
          return possibles[Math.floor(Math.random() * possibles.length)];
        }

      };

      var _random = function(min, max) {
        return min + distribution() * (max - min);
      };

      var _randomInt = function(min, max) {
        return Math.floor(min + distribution() * (max - min));
      };

      // This is a function for generating a random matrix recursively.
      var _randomDataForMatrix = function(size, min, max, randFunc) {
        var data = [], length, i;
        size = size.slice(0);

        if (size.length > 1) {
          for (i = 0, length = size.shift(); i < length; i++)
            data.push(_randomDataForMatrix(size, min, max, randFunc));
        } else {
          for (i = 0, length = size.shift(); i < length; i++)
            data.push(randFunc(min, max));
        }

        return data;
      };

      return randFunctions;

    })(distribution);
  }

  // Each distribution is a function that takes no argument and when called returns
  // a number between 0 and 1.
  var distributions = {

    uniform: function() {
      return Math.random;
    },

    // Implementation of normal distribution using Box-Muller transform
    // ref : http://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform
    // We take : mean = 0.5, standard deviation = 1/6
    // so that 99.7% values are in [0, 1].
    normal: function() {
      return function() {
        var u1, u2,
            picked = -1;
        // We reject values outside of the interval [0, 1]
        // TODO: check if it is ok to do that?
        while (picked < 0 || picked > 1) {
          u1 = Math.random();
          u2 = Math.random();
          picked = 1/6 * Math.pow(-2 * Math.log(u1), 0.5) * Math.cos(2 * Math.PI * u2) + 0.5;
        }
        return picked;
      }
    }
  };

  distribution.toTex = '\\mathrm{${name}}\\left(${args}\\right)';

  return distribution;
}

exports.name = 'distribution';
exports.factory = factory;

},{"../../error/ArgumentsError":10,"../../type/matrix/function/matrix":435,"../../utils/array":461,"../../utils/collection/isCollection":476}],340:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  var gamma = load(require('./gamma'));
  var latex = require('../../utils/latex');

  /**
   * Compute the factorial of a value
   *
   * Factorial only supports an integer value as argument.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.factorial(n)
   *
   * Examples:
   *
   *    math.factorial(5);    // returns 120
   *    math.factorial(3);    // returns 6
   *
   * See also:
   *
   *    combinations, gamma, permutations
   *
   * @param {number | BigNumber | Array | Matrix} n   An integer number
   * @return {number | BigNumber | Array | Matrix}    The factorial of `n`
   */
  var factorial = typed('factorial', {
    'number': function (n) {
      if (n < 0) {
        throw new Error('Value must be non-negative');
      }

      return gamma(n + 1);
    },

    'BigNumber': function (n) {
      if (n.isNegative()) {
        throw new Error('Value must be non-negative');
      }

      return gamma(n.plus(1));
    },

    'Array | Matrix': function (n) {
      return deepMap(n, factorial);
    }
  });

  factorial.toTex = '\\left(${args[0]}\\right)' + latex.operators['factorial'];

  return factorial;
}

exports.name = 'factorial';
exports.factory = factory;

},{"../../utils/collection/deepMap":475,"../../utils/latex":482,"./gamma":341}],341:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');
var isInteger = require('../../utils/number').isInteger;

function factory (type, config, load, typed) {
  var multiply = load(require('../arithmetic/multiply'));
  var pow = load(require('../arithmetic/pow'));

  /**
   * Compute the gamma function of a value using Lanczos approximation for
   * small values, and an extended Stirling approximation for large values.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.gamma(n)
   *
   * Examples:
   *
   *    math.gamma(5);       // returns 24
   *    math.gamma(-0.5);    // returns -3.5449077018110335
   *    math.gamma(math.i);  // returns -0.15494982830180973 - 0.49801566811835596i
   *
   * See also:
   *
   *    combinations, factorial, permutations
   *
   * @param {number | Array | Matrix} n   A real or complex number
   * @return {number | Array | Matrix}    The gamma of `n`
   */
  var gamma = typed('gamma', {
    'number': function (n) {
      var t, x;

      if (isInteger(n)) {
        if (n <= 0) {
          return isFinite(n) ? Infinity : NaN;
        }

        if (n > 171) {
          return Infinity;                  // Will overflow
        }

        var value = n - 2;
        var res = n - 1;
        while (value > 1) {
          res *= value;
          value--;
        }

        if (res == 0) {
          res = 1;                          // 0! is per definition 1
        }

        return res;
      }

      if (n < 0.5) {
        return Math.PI / (Math.sin(Math.PI * n) * gamma(1-n));
      }

      if (n >= 171.35) {
        return Infinity;                    // will overflow
      }

      if (n > 85.0) {                       // Extended Stirling Approx
        var twoN = n*n;
        var threeN = twoN*n;
        var fourN = threeN*n;
        var fiveN = fourN*n;
        return Math.sqrt(2*Math.PI/n) * Math.pow((n/Math.E), n) *
            (1 + 1/(12*n) + 1/(288*twoN) - 139/(51840*threeN) -
            571/(2488320*fourN) + 163879/(209018880*fiveN) +
            5246819/(75246796800*fiveN*n));
      }

      --n;
      x = p[0];
      for (var i = 1; i < p.length; ++i) {
        x += p[i] / (n+i);
      }

      t = n + g + 0.5;
      return Math.sqrt(2*Math.PI) * Math.pow(t, n+0.5) * Math.exp(-t) * x;
    },

    'Complex': function (n) {
      var t, x;

      if (n.im == 0) {
        return gamma(n.re);
      }

      n = new type.Complex(n.re - 1, n.im);
      x = new type.Complex(p[0], 0);
      for (var i = 1; i < p.length; ++i) {
        var real = n.re + i;                // x += p[i]/(n+i)
        var den = real*real + n.im*n.im;
        if (den != 0) {
          x.re += p[i] * real / den;
          x.im += -(p[i] * n.im) / den;
        } else {
          x.re = p[i] < 0
              ? -Infinity
              :  Infinity;
        }
      }

      t = new type.Complex(n.re + g + 0.5, n.im);
      var twoPiSqrt = Math.sqrt(2*Math.PI);

      n.re += 0.5;
      var result = pow(t, n);
      if (result.im == 0) {                 // sqrt(2*PI)*result
        result.re *= twoPiSqrt;
      } else if (result.re == 0) {
        result.im *= twoPiSqrt;
      } else {
        result.re *= twoPiSqrt;
        result.im *= twoPiSqrt;
      }

      var r = Math.exp(-t.re);              // exp(-t)
      t.re = r * Math.cos(-t.im);
      t.im = r * Math.sin(-t.im);

      return multiply(multiply(result, t), x);
    },

    'BigNumber': function (n) {
      if (n.isInteger()) {
        return (n.isNegative() || n.isZero())
            ? new type.BigNumber(Infinity)
            : bigFactorial(n.minus(1));
      }

      if (!n.isFinite()) {
        return new type.BigNumber(n.isNegative() ? NaN : Infinity);
      }

      throw new Error('Integer BigNumber expected');
    },

    'Array | Matrix': function (n) {
      return deepMap(n, gamma);
    }
  });

  /**
   * Calculate factorial for a BigNumber
   * @param {BigNumber} n
   * @returns {BigNumber} Returns the factorial of n
   */
  function bigFactorial(n) {
    if (n.isZero()) {
      return new type.BigNumber(1); // 0! is per definition 1
    }

    var precision = config.precision + (Math.log(n.toNumber()) | 0);
    var Big = type.BigNumber.clone({precision: precision});

    var res = new Big(n);
    var value = n.toNumber() - 1; // number
    while (value > 1) {
      res = res.times(value);
      value--;
    }

    return new type.BigNumber(res.toPrecision(type.BigNumber.precision));
  }

  gamma.toTex = '\\Gamma\\left(${args[0]}\\right)';

  return gamma;
}

// TODO: comment on the variables g and p

var g = 4.7421875;

var p = [
  0.99999999999999709182,
  57.156235665862923517,
  -59.597960355475491248,
  14.136097974741747174,
  -0.49191381609762019978,
  0.33994649984811888699e-4,
  0.46523628927048575665e-4,
  -0.98374475304879564677e-4,
  0.15808870322491248884e-3,
  -0.21026444172410488319e-3,
  0.21743961811521264320e-3,
  -0.16431810653676389022e-3,
  0.84418223983852743293e-4,
  -0.26190838401581408670e-4,
  0.36899182659531622704e-5
];

exports.name = 'gamma';
exports.factory = factory;

},{"../../utils/collection/deepMap":475,"../../utils/number":483,"../arithmetic/multiply":275,"../arithmetic/pow":279}],342:[function(require,module,exports){
module.exports = [
  //require('./distribution'), // TODO: rethink math.distribution
  require('./combinations'),
  require('./factorial'),
  require('./gamma'),
  require('./kldivergence'),
  require('./multinomial'),
  require('./permutations'),
  require('./pickRandom'),
  require('./random'),
  require('./randomInt')
];

},{"./combinations":338,"./factorial":340,"./gamma":341,"./kldivergence":343,"./multinomial":344,"./permutations":345,"./pickRandom":346,"./random":347,"./randomInt":348}],343:[function(require,module,exports){
'use strict';


function factory(type, config, load, typed) {
    var matrix = load(require('../../type/matrix/function/matrix'));
    var divide = load(require('../arithmetic/divide'));
    var sum = load(require('../statistics/sum'));
    var multiply = load(require('../arithmetic/multiply'));
    var dotDivide = load(require('../arithmetic/dotDivide'));
    var log = load(require('../arithmetic/log'));
    var isNumeric = load(require('../utils/isNumeric'));

    /**
     * Calculate the Kullback-Leibler (KL) divergence  between two distributions
     *
     * Syntax:
     *
     *     math.kldivergence(x, y)
     *
     * Examples:
     *
     *     math.kldivergence([0.7,0.5,0.4], [0.2,0.9,0.5]);   //returns 0.24376698773121153
     *
     *
     * @param  {Array | Matrix} q    First vector
     * @param  {Array | Matrix} p    Second vector
     * @return {number}              Returns distance between q and p
     */
    var kldivergence = typed('kldivergence', {
        'Array, Array': function(q, p) {
            return _kldiv(matrix(q), matrix(p));
        },

        'Matrix, Array': function(q, p) {
            return _kldiv(q, matrix(p));
        },

        'Array, Matrix': function(q, p){
            return _kldiv(matrix(q), p);
        },

        'Matrix, Matrix': function(q, p){
            return _kldiv(q, p);
        }

    });

    function _kldiv(q, p) {
        var plength = p.size().length;
        var qlength = q.size().length;
        if (plength > 1) {
            throw new Error('first object must be one dimensional');
        }
        
        if (qlength > 1) {
            throw new Error('second object must be one dimensional');
        }
        
        if(plength !== qlength){
            throw new Error("Length of two vectors must be equal");
        }
        
        //Before calculation, apply normalization
        var sumq = sum(q);
        if (sumq === 0) {
            throw new Error("Sum of elements in first object must be non zero");
        }

        var sump = sum(p);
        if (sump === 0) {
            throw new Error("Sum of elements in second object must be non zero");
        }
        var qnorm = divide(q, sum(q));
        var pnorm = divide(p, sum(p));

        var result = sum(multiply(qnorm, log(dotDivide(qnorm, pnorm))));
        if (isNumeric(result)) {
            return result;
        }
        else {
            return Number.NaN;
        }
    }

    return kldivergence;
}


exports.name = 'kldivergence';
exports.factory = factory;
 

},{"../../type/matrix/function/matrix":435,"../arithmetic/divide":260,"../arithmetic/dotDivide":262,"../arithmetic/log":272,"../arithmetic/multiply":275,"../statistics/sum":368,"../utils/isNumeric":405}],344:[function(require,module,exports){
'use strict';

var deepForEach = require('../../utils/collection/deepForEach');

function factory (type, config, load, typed) {
  var add = load(require('../arithmetic/add'));
  var multiply = load(require('../arithmetic/multiply'));
  var divide = load(require('../arithmetic/divide'));
  var factorial = load(require('../probability/factorial'));
  var isInteger = load(require('../utils/isInteger'));
  var isPositive = load(require('../utils/isPositive'));

  /**
   * Multinomial Coefficients compute the number of ways of picking a1, a2, ..., ai unordered outcomes from `n` possibilities.
   *
   * multinomial takes one array of integers as an argument.
   * The following condition must be enforced: every ai <= 0
   *
   * Syntax:
   *
   *     math.multinomial(a) // a is an array type
   *
   * Examples:
   *
   *    math.multinomial([1,2,1]); // returns 12
   *
   * See also:
   *
   *    combinations, factorial
   *
   * @param {number[] | BigNumber[]} a    Integer numbers of objects in the subset
   * @return {Number | BigNumber}         Multinomial coefficient.
   */
  return typed('multinomial', {
    'Array | Matrix': function (a) {
      var sum = 0;
      var denom = 1;

      deepForEach(a, function(ai) {
        if(!isInteger(ai) || !isPositive(ai)) {
          throw new TypeError('Positive integer value expected in function multinomial');
        }
        sum = add(sum, ai);
        denom = multiply(denom, factorial(ai));
      });

      return divide(factorial(sum), denom);
    }
  });
}

exports.name = 'multinomial';
exports.factory = factory;

},{"../../utils/collection/deepForEach":474,"../arithmetic/add":255,"../arithmetic/divide":260,"../arithmetic/multiply":275,"../probability/factorial":340,"../utils/isInteger":403,"../utils/isPositive":406}],345:[function(require,module,exports){
'use strict';

var isInteger = require('../../utils/number').isInteger;

function factory (type, config, load, typed) {
  var factorial = load(require('./factorial'));

  /**
   * Compute the number of ways of obtaining an ordered subset of `k` elements
   * from a set of `n` elements.
   *
   * Permutations only takes integer arguments.
   * The following condition must be enforced: k <= n.
   *
   * Syntax:
   *
   *     math.permutations(n)
   *     math.permutations(n, k)
   *
   * Examples:
   *
   *    math.permutations(5);     // 120
   *    math.permutations(5, 3);  // 60
   *
   * See also:
   *
   *    combinations, factorial
   *
   * @param {number | BigNumber} n   The number of objects in total
   * @param {number | BigNumber} [k] The number of objects in the subset
   * @return {number | BigNumber}    The number of permutations
   */
  var permutations = typed('permutations', {
    'number | BigNumber': factorial,

    'number, number': function (n, k) {
      var result, i;

      if (!isInteger(n) || n < 0) {
        throw new TypeError('Positive integer value expected in function permutations');
      }
      if (!isInteger(k) || k < 0) {
        throw new TypeError('Positive integer value expected in function permutations');
      }
      if (k > n) {
        throw new TypeError('second argument k must be less than or equal to first argument n');
      }

      // Permute n objects, k at a time
      result = 1;
      for (i = n - k + 1; i <= n; i++) {
        result = result * i;
      }

      return result;
    },

    'BigNumber, BigNumber': function (n, k) {
      var result, i;

      if (!isPositiveInteger(n) || !isPositiveInteger(k)) {
        throw new TypeError('Positive integer value expected in function permutations');
      }
      if (k.gt(n)) {
        throw new TypeError('second argument k must be less than or equal to first argument n');
      }

      result = new type.BigNumber(1);
      for (i = n.minus(k).plus(1); i.lte(n); i = i.plus(1)) {
        result = result.times(i);
      }

      return result;
    }

    // TODO: implement support for collection in permutations
  });

  permutations.toTex = '\\mathrm{${name}}\\left(${args}\\right)';

  return permutations;
}

/**
 * Test whether BigNumber n is a positive integer
 * @param {BigNumber} n
 * @returns {boolean} isPositiveInteger
 */
function isPositiveInteger(n) {
  return n.isInteger() && n.gte(0);
}

exports.name = 'permutations';
exports.factory = factory;

},{"../../utils/number":483,"./factorial":340}],346:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  var distribution = load(require('./distribution'));

  /**
   * Random pick a value from a one dimensional array.
   * Array element is picked using a random function with uniform distribution.
   *
   * Syntax:
   *
   *     math.pickRandom(array)
   *
   * Examples:
   *
   *     math.pickRandom([3, 6, 12, 2]);       // returns one of the values in the array
   *
   * See also:
   *
   *     random, randomInt
   *
   * @param {Array} array     A one dimensional array
   * @return {number} One of the elements of the provided input array
   */
  // TODO: rework pickRandom to a typed-function
  var pickRandom =  distribution('uniform').pickRandom;

  pickRandom.toTex = '\\mathrm{${name}}\\left(${args}\\right)';

  return pickRandom;
}

exports.name = 'pickRandom';
exports.factory = factory;

},{"./distribution":339}],347:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  var distribution = load(require('./distribution'));

  /**
   * Return a random number larger or equal to `min` and smaller than `max`
   * using a uniform distribution.
   *
   * Syntax:
   *
   *     math.random()                // generate a random number between 0 and 1
   *     math.random(max)             // generate a random number between 0 and max
   *     math.random(min, max)        // generate a random number between min and max
   *     math.random(size)            // generate a matrix with random numbers between 0 and 1
   *     math.random(size, max)       // generate a matrix with random numbers between 0 and max
   *     math.random(size, min, max)  // generate a matrix with random numbers between min and max
   *
   * Examples:
   *
   *     math.random();       // returns a random number between 0 and 1
   *     math.random(100);    // returns a random number between 0 and 100
   *     math.random(30, 40); // returns a random number between 30 and 40
   *     math.random([2, 3]); // returns a 2x3 matrix with random numbers between 0 and 1
   *
   * See also:
   *
   *     randomInt, pickRandom
   *
   * @param {Array | Matrix} [size] If provided, an array or matrix with given
   *                                size and filled with random values is returned
   * @param {number} [min]  Minimum boundary for the random value, included
   * @param {number} [max]  Maximum boundary for the random value, excluded
   * @return {number | Array | Matrix} A random number
   */
  // TODO: rework random to a typed-function
  var random = distribution('uniform').random;

  random.toTex = '\\mathrm{${name}}\\left(${args}\\right)';

  return random;
}

exports.name = 'random';
exports.factory = factory;

},{"./distribution":339}],348:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  var distribution = load(require('./distribution'));

  /**
   * Return a random integer number larger or equal to `min` and smaller than `max`
   * using a uniform distribution.
   *
   * Syntax:
   *
   *     math.randomInt(max)             // generate a random integer between 0 and max
   *     math.randomInt(min, max)        // generate a random integer between min and max
   *     math.randomInt(size)            // generate a matrix with random integer between 0 and 1
   *     math.randomInt(size, max)       // generate a matrix with random integer between 0 and max
   *     math.randomInt(size, min, max)  // generate a matrix with random integer between min and max
   *
   * Examples:
   *
   *     math.randomInt(100);    // returns a random integer between 0 and 100
   *     math.randomInt(30, 40); // returns a random integer between 30 and 40
   *     math.randomInt([2, 3]); // returns a 2x3 matrix with random integers between 0 and 1
   *
   * See also:
   *
   *     random, pickRandom
   *
   * @param {Array | Matrix} [size] If provided, an array or matrix with given
   *                                size and filled with random values is returned
   * @param {number} [min]  Minimum boundary for the random value, included
   * @param {number} [max]  Maximum boundary for the random value, excluded
   * @return {number | Array | Matrix} A random integer value
   */
  // TODO: rework randomInt to a typed-function
  var randomInt = distribution('uniform').randomInt;

  randomInt.toTex = '\\mathrm{${name}}\\left(${args}\\right)';

  return randomInt;
}

exports.name = 'randomInt';
exports.factory = factory;

},{"./distribution":339}],349:[function(require,module,exports){
'use strict';

var nearlyEqual = require('../../utils/number').nearlyEqual;
var bigNearlyEqual = require('../../utils/bignumber/nearlyEqual');

function factory (type, config, load, typed) {

  var matrix = load(require('../../type/matrix/function/matrix'));

  var algorithm03 = load(require('../../type/matrix/utils/algorithm03'));
  var algorithm05 = load(require('../../type/matrix/utils/algorithm05'));
  var algorithm12 = load(require('../../type/matrix/utils/algorithm12'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));
  
  /**
   * Compare two values. Returns 1 when x > y, -1 when x < y, and 0 when x == y.
   *
   * x and y are considered equal when the relative difference between x and y
   * is smaller than the configured epsilon. The function cannot be used to
   * compare values smaller than approximately 2.22e-16.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.compare(x, y)
   *
   * Examples:
   *
   *    math.compare(6, 1);           // returns 1
   *    math.compare(2, 3);           // returns -1
   *    math.compare(7, 7);           // returns 0
   *
   *    var a = math.unit('5 cm');
   *    var b = math.unit('40 mm');
   *    math.compare(a, b);           // returns 1
   *
   *    math.compare(2, [1, 2, 3]);   // returns [1, 0, -1]
   *
   * See also:
   *
   *    equal, unequal, smaller, smallerEq, larger, largerEq
   *
   * @param  {number | BigNumber | Fraction | Unit | string | Array | Matrix} x First value to compare
   * @param  {number | BigNumber | Fraction | Unit | string | Array | Matrix} y Second value to compare
   * @return {number | BigNumber | Fraction | Array | Matrix} Returns the result of the comparison: 1, 0 or -1.
   */
  var compare = typed('compare', {

    'boolean, boolean': function (x, y) {
      return x === y ? 0 : (x > y ? 1 : -1);
    },

    'number, number': function (x, y) {
      return (x === y || nearlyEqual(x, y, config.epsilon))
          ? 0
          : (x > y ? 1 : -1);
    },

    'BigNumber, BigNumber': function (x, y) {
      return (x.eq(y) || bigNearlyEqual(x, y, config.epsilon))
          ? new type.BigNumber(0)
          : new type.BigNumber(x.cmp(y));
    },

    'Fraction, Fraction': function (x, y) {
      return new type.Fraction(x.compare(y));
    },

    'Complex, Complex': function () {
      throw new TypeError('No ordering relation is defined for complex numbers');
    },

    'Unit, Unit': function (x, y) {
      if (!x.equalBase(y)) {
        throw new Error('Cannot compare units with different base');
      }
      return compare(x.value, y.value);
    },

    'string, string': function (x, y) {
      return x === y ? 0 : (x > y ? 1 : -1);
    },

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse + sparse
              c = algorithm05(x, y, compare);
              break;
            default:
              // sparse + dense
              c = algorithm03(y, x, compare, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense + sparse
              c = algorithm03(x, y, compare, false);
              break;
            default:
              // dense + dense
              c = algorithm13(x, y, compare);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return compare(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return compare(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return compare(x, matrix(y));
    },

    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm12(x, y, compare, false);
          break;
        default:
          c = algorithm14(x, y, compare, false);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm12(y, x, compare, true);
          break;
        default:
          c = algorithm14(y, x, compare, true);
          break;
      }
      return c;
    },

    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, compare, false).valueOf();
    },

    'any, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, compare, true).valueOf();
    }
  });

  compare.toTex = '\\mathrm{${name}}\\left(${args}\\right)';

  return compare;
}

exports.name = 'compare';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../type/matrix/utils/algorithm03":440,"../../type/matrix/utils/algorithm05":442,"../../type/matrix/utils/algorithm12":449,"../../type/matrix/utils/algorithm13":450,"../../type/matrix/utils/algorithm14":451,"../../utils/bignumber/nearlyEqual":470,"../../utils/number":483}],350:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  var equal = load(require('./equal'));

  /**
   * Test element wise whether two matrices are equal.
   * The function accepts both matrices and scalar values.
   *
   * Syntax:
   *
   *    math.deepEqual(x, y)
   *
   * Examples:
   *
   *    math.deepEqual(2, 4);   // returns false
   *
   *    a = [2, 5, 1];
   *    b = [2, 7, 1];
   *
   *    math.deepEqual(a, b);   // returns false
   *    math.equal(a, b);       // returns [true, false, true]
   *
   * See also:
   *
   *    equal, unequal
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x First matrix to compare
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Second matrix to compare
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}
   *            Returns true when the input matrices have the same size and each of their elements is equal.
   */
  var deepEqual = typed('deepEqual', {
    'any, any': function (x, y) {
      return _deepEqual(x.valueOf(), y.valueOf());
    }
  });

  deepEqual.toTex = '\\mathrm{${name}}\\left(${args}\\right)';

  return deepEqual;

  /**
   * Test whether two arrays have the same size and all elements are equal
   * @param {Array | *} x
   * @param {Array | *} y
   * @return {boolean} Returns true if both arrays are deep equal
   */
  function _deepEqual(x, y) {
    if (Array.isArray(x)) {
      if (Array.isArray(y)) {
        var len = x.length;
        if (len !== y.length) {
          return false;
        }

        for (var i = 0; i < len; i++) {
          if (!_deepEqual(x[i], y[i])) {
            return false;
          }
        }

        return true;
      }
      else {
        return false;
      }
    }
    else {
      if (Array.isArray(y)) {
        return false;
      }
      else {
        return equal(x, y);
      }
    }
  }
}

exports.name = 'deepEqual';
exports.factory = factory;

},{"./equal":351}],351:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  
  var matrix = load(require('../../type/matrix/function/matrix'));
  var equalScalar = load(require('./equalScalar'));

  var algorithm03 = load(require('../../type/matrix/utils/algorithm03'));
  var algorithm07 = load(require('../../type/matrix/utils/algorithm07'));
  var algorithm12 = load(require('../../type/matrix/utils/algorithm12'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

  var latex = require('../../utils/latex');

  /**
   * Test whether two values are equal.
   *
   * The function tests whether the relative difference between x and y is
   * smaller than the configured epsilon. The function cannot be used to
   * compare values smaller than approximately 2.22e-16.
   *
   * For matrices, the function is evaluated element wise.
   * In case of complex numbers, x.re must equal y.re, and x.im must equal y.im.
   *
   * Values `null` and `undefined` are compared strictly, thus `null` is only
   * equal to `null` and nothing else, and `undefined` is only equal to
   * `undefined` and nothing else.
   *
   * Syntax:
   *
   *    math.equal(x, y)
   *
   * Examples:
   *
   *    math.equal(2 + 2, 3);         // returns false
   *    math.equal(2 + 2, 4);         // returns true
   *
   *    var a = math.unit('50 cm');
   *    var b = math.unit('5 m');
   *    math.equal(a, b);             // returns true
   *
   *    var c = [2, 5, 1];
   *    var d = [2, 7, 1];
   *
   *    math.equal(c, d);             // returns [true, false, true]
   *    math.deepEqual(c, d);         // returns false
   *
   *    math.equal(0, null);          // returns false
   *
   * See also:
   *
   *    unequal, smaller, smallerEq, larger, largerEq, compare, deepEqual
   *
   * @param  {number | BigNumber | boolean | Complex | Unit | string | Array | Matrix} x First value to compare
   * @param  {number | BigNumber | boolean | Complex | Unit | string | Array | Matrix} y Second value to compare
   * @return {boolean | Array | Matrix} Returns true when the compared values are equal, else returns false
   */
  var equal = typed('equal', {
    
    'any, any': function (x, y) {
      // strict equality for null and undefined?
      if (x === null) { return y === null; }
      if (y === null) { return x === null; }
      if (x === undefined) { return y === undefined; }
      if (y === undefined) { return x === undefined; }

      return equalScalar(x, y);
    },

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse + sparse
              c = algorithm07(x, y, equalScalar);
              break;
            default:
              // sparse + dense
              c = algorithm03(y, x, equalScalar, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense + sparse
              c = algorithm03(x, y, equalScalar, false);
              break;
            default:
              // dense + dense
              c = algorithm13(x, y, equalScalar);
              break;
          }
          break;
      }
      return c;
    },
    
    'Array, Array': function (x, y) {
      // use matrix implementation
      return equal(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return equal(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return equal(x, matrix(y));
    },
    
    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm12(x, y, equalScalar, false);
          break;
        default:
          c = algorithm14(x, y, equalScalar, false);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm12(y, x, equalScalar, true);
          break;
        default:
          c = algorithm14(y, x, equalScalar, true);
          break;
      }
      return c;
    },

    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, equalScalar, false).valueOf();
    },

    'any, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, equalScalar, true).valueOf();
    }
  });

  equal.toTex = '\\left(${args[0]}' + latex.operators['equal'] + '${args[1]}\\right)';

  return equal;
}

exports.name = 'equal';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../type/matrix/utils/algorithm03":440,"../../type/matrix/utils/algorithm07":444,"../../type/matrix/utils/algorithm12":449,"../../type/matrix/utils/algorithm13":450,"../../type/matrix/utils/algorithm14":451,"../../utils/latex":482,"./equalScalar":352}],352:[function(require,module,exports){
'use strict';

var nearlyEqual = require('../../utils/number').nearlyEqual;
var bigNearlyEqual = require('../../utils/bignumber/nearlyEqual');

function factory (type, config, load, typed) {
  
  /**
   * Test whether two values are equal.
   *
   * @param  {number | BigNumber | Fraction | boolean | Complex | Unit} x   First value to compare
   * @param  {number | BigNumber | Fraction | boolean | Complex} y          Second value to compare
   * @return {boolean}                                                  Returns true when the compared values are equal, else returns false
   * @private
   */
  var equalScalar = typed('equalScalar', {

    'boolean, boolean': function (x, y) {
      return x === y;
    },

    'number, number': function (x, y) {
      return x === y || nearlyEqual(x, y, config.epsilon);
    },

    'BigNumber, BigNumber': function (x, y) {
      return x.eq(y) || bigNearlyEqual(x, y, config.epsilon);
    },

    'Fraction, Fraction': function (x, y) {
      return x.equals(y);
    },

    'Complex, Complex': function (x, y) {
      return x.equals(y);
    },

    'Unit, Unit': function (x, y) {
      if (!x.equalBase(y)) {
        throw new Error('Cannot compare units with different base');
      }
      return equalScalar(x.value, y.value);
    },

    'string, string': function (x, y) {
      return x === y;
    }
  });
  
  return equalScalar;
}

exports.factory = factory;

},{"../../utils/bignumber/nearlyEqual":470,"../../utils/number":483}],353:[function(require,module,exports){
module.exports = [
  require('./compare'),
  require('./deepEqual'),
  require('./equal'),
  require('./larger'),
  require('./largerEq'),
  require('./smaller'),
  require('./smallerEq'),
  require('./unequal')
];

},{"./compare":349,"./deepEqual":350,"./equal":351,"./larger":354,"./largerEq":355,"./smaller":356,"./smallerEq":357,"./unequal":358}],354:[function(require,module,exports){
'use strict';

var nearlyEqual = require('../../utils/number').nearlyEqual;
var bigNearlyEqual = require('../../utils/bignumber/nearlyEqual');

function factory (type, config, load, typed) {
  
  var matrix = load(require('../../type/matrix/function/matrix'));

  var algorithm03 = load(require('../../type/matrix/utils/algorithm03'));
  var algorithm07 = load(require('../../type/matrix/utils/algorithm07'));
  var algorithm12 = load(require('../../type/matrix/utils/algorithm12'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

  var latex = require('../../utils/latex');

  /**
   * Test whether value x is larger than y.
   *
   * The function returns true when x is larger than y and the relative
   * difference between x and y is larger than the configured epsilon. The
   * function cannot be used to compare values smaller than approximately 2.22e-16.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.larger(x, y)
   *
   * Examples:
   *
   *    math.larger(2, 3);             // returns false
   *    math.larger(5, 2 + 2);         // returns true
   *
   *    var a = math.unit('5 cm');
   *    var b = math.unit('2 inch');
   *    math.larger(a, b);             // returns false
   *
   * See also:
   *
   *    equal, unequal, smaller, smallerEq, largerEq, compare
   *
   * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
   * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} y Second value to compare
   * @return {boolean | Array | Matrix} Returns true when the x is larger than y, else returns false
   */
  var larger = typed('larger', {

    'boolean, boolean': function (x, y) {
      return x > y;
    },

    'number, number': function (x, y) {
      return x > y && !nearlyEqual(x, y, config.epsilon);
    },

    'BigNumber, BigNumber': function (x, y) {
      return x.gt(y) && !bigNearlyEqual(x, y, config.epsilon);
    },

    'Fraction, Fraction': function (x, y) {
      return x.compare(y) === 1;
    },

    'Complex, Complex': function () {
      throw new TypeError('No ordering relation is defined for complex numbers');
    },

    'Unit, Unit': function (x, y) {
      if (!x.equalBase(y)) {
        throw new Error('Cannot compare units with different base');
      }
      return larger(x.value, y.value);
    },

    'string, string': function (x, y) {
      return x > y;
    },

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse + sparse
              c = algorithm07(x, y, larger);
              break;
            default:
              // sparse + dense
              c = algorithm03(y, x, larger, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense + sparse
              c = algorithm03(x, y, larger, false);
              break;
            default:
              // dense + dense
              c = algorithm13(x, y, larger);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return larger(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return larger(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return larger(x, matrix(y));
    },

    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm12(x, y, larger, false);
          break;
        default:
          c = algorithm14(x, y, larger, false);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm12(y, x, larger, true);
          break;
        default:
          c = algorithm14(y, x, larger, true);
          break;
      }
      return c;
    },

    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, larger, false).valueOf();
    },

    'any, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, larger, true).valueOf();
    }
  });

  larger.toTex = '\\left(${args[0]}' + latex.operators['larger'] + '${args[1]}\\right)';

  return larger;
}

exports.name = 'larger';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../type/matrix/utils/algorithm03":440,"../../type/matrix/utils/algorithm07":444,"../../type/matrix/utils/algorithm12":449,"../../type/matrix/utils/algorithm13":450,"../../type/matrix/utils/algorithm14":451,"../../utils/bignumber/nearlyEqual":470,"../../utils/latex":482,"../../utils/number":483}],355:[function(require,module,exports){
'use strict';

var nearlyEqual = require('../../utils/number').nearlyEqual;
var bigNearlyEqual = require('../../utils/bignumber/nearlyEqual');

function factory (type, config, load, typed) {
  
  var matrix = load(require('../../type/matrix/function/matrix'));

  var algorithm03 = load(require('../../type/matrix/utils/algorithm03'));
  var algorithm07 = load(require('../../type/matrix/utils/algorithm07'));
  var algorithm12 = load(require('../../type/matrix/utils/algorithm12'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

  var latex = require('../../utils/latex');

  /**
   * Test whether value x is larger or equal to y.
   *
   * The function returns true when x is larger than y or the relative
   * difference between x and y is smaller than the configured epsilon. The
   * function cannot be used to compare values smaller than approximately 2.22e-16.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.largerEq(x, y)
   *
   * Examples:
   *
   *    math.larger(2, 1 + 1);         // returns false
   *    math.largerEq(2, 1 + 1);       // returns true
   *
   * See also:
   *
   *    equal, unequal, smaller, smallerEq, larger, compare
   *
   * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
   * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} y Second value to compare
   * @return {boolean | Array | Matrix} Returns true when the x is larger or equal to y, else returns false
   */
  var largerEq = typed('largerEq', {

    'boolean, boolean': function (x, y) {
      return x >= y;
    },

    'number, number': function (x, y) {
      return x >= y || nearlyEqual(x, y, config.epsilon);
    },

    'BigNumber, BigNumber': function (x, y) {
      return x.gte(y) || bigNearlyEqual(x, y, config.epsilon);
    },

    'Fraction, Fraction': function (x, y) {
      return x.compare(y) !== -1;
    },

    'Complex, Complex': function () {
      throw new TypeError('No ordering relation is defined for complex numbers');
    },

    'Unit, Unit': function (x, y) {
      if (!x.equalBase(y)) {
        throw new Error('Cannot compare units with different base');
      }
      return largerEq(x.value, y.value);
    },

    'string, string': function (x, y) {
      return x >= y;
    },

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse + sparse
              c = algorithm07(x, y, largerEq);
              break;
            default:
              // sparse + dense
              c = algorithm03(y, x, largerEq, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense + sparse
              c = algorithm03(x, y, largerEq, false);
              break;
            default:
              // dense + dense
              c = algorithm13(x, y, largerEq);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return largerEq(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return largerEq(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return largerEq(x, matrix(y));
    },

    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm12(x, y, largerEq, false);
          break;
        default:
          c = algorithm14(x, y, largerEq, false);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm12(y, x, largerEq, true);
          break;
        default:
          c = algorithm14(y, x, largerEq, true);
          break;
      }
      return c;
    },

    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, largerEq, false).valueOf();
    },

    'any, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, largerEq, true).valueOf();
    }
  });

  largerEq.toTex = '\\left(${args[0]}' + latex.operators['largerEq'] + '${args[1]}\\right)';

  return largerEq;
}

exports.name = 'largerEq';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../type/matrix/utils/algorithm03":440,"../../type/matrix/utils/algorithm07":444,"../../type/matrix/utils/algorithm12":449,"../../type/matrix/utils/algorithm13":450,"../../type/matrix/utils/algorithm14":451,"../../utils/bignumber/nearlyEqual":470,"../../utils/latex":482,"../../utils/number":483}],356:[function(require,module,exports){
'use strict';

var nearlyEqual = require('../../utils/number').nearlyEqual;
var bigNearlyEqual = require('../../utils/bignumber/nearlyEqual');

function factory (type, config, load, typed) {

  var matrix = load(require('../../type/matrix/function/matrix'));

  var algorithm03 = load(require('../../type/matrix/utils/algorithm03'));
  var algorithm07 = load(require('../../type/matrix/utils/algorithm07'));
  var algorithm12 = load(require('../../type/matrix/utils/algorithm12'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

  var latex = require('../../utils/latex');

  /**
   * Test whether value x is smaller than y.
   *
   * The function returns true when x is smaller than y and the relative
   * difference between x and y is smaller than the configured epsilon. The
   * function cannot be used to compare values smaller than approximately 2.22e-16.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.smaller(x, y)
   *
   * Examples:
   *
   *    math.smaller(2, 3);            // returns true
   *    math.smaller(5, 2 * 2);        // returns false
   *
   *    var a = math.unit('5 cm');
   *    var b = math.unit('2 inch');
   *    math.smaller(a, b);            // returns true
   *
   * See also:
   *
   *    equal, unequal, smallerEq, smaller, smallerEq, compare
   *
   * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
   * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} y Second value to compare
   * @return {boolean | Array | Matrix} Returns true when the x is smaller than y, else returns false
   */
  var smaller = typed('smaller', {

    'boolean, boolean': function (x, y) {
      return x < y;
    },

    'number, number': function (x, y) {
      return x < y && !nearlyEqual(x, y, config.epsilon);
    },

    'BigNumber, BigNumber': function (x, y) {
      return x.lt(y) && !bigNearlyEqual(x, y, config.epsilon);
    },

    'Fraction, Fraction': function (x, y) {
      return x.compare(y) === -1;
    },

    'Complex, Complex': function (x, y) {
      throw new TypeError('No ordering relation is defined for complex numbers');
    },

    'Unit, Unit': function (x, y) {
      if (!x.equalBase(y)) {
        throw new Error('Cannot compare units with different base');
      }
      return smaller(x.value, y.value);
    },

    'string, string': function (x, y) {
      return x < y;
    },

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse + sparse
              c = algorithm07(x, y, smaller);
              break;
            default:
              // sparse + dense
              c = algorithm03(y, x, smaller, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense + sparse
              c = algorithm03(x, y, smaller, false);
              break;
            default:
              // dense + dense
              c = algorithm13(x, y, smaller);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return smaller(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return smaller(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return smaller(x, matrix(y));
    },

    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm12(x, y, smaller, false);
          break;
        default:
          c = algorithm14(x, y, smaller, false);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm12(y, x, smaller, true);
          break;
        default:
          c = algorithm14(y, x, smaller, true);
          break;
      }
      return c;
    },

    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, smaller, false).valueOf();
    },

    'any, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, smaller, true).valueOf();
    }
  });

  smaller.toTex = '\\left(${args[0]}' + latex.operators['smaller'] + '${args[1]}\\right)';

  return smaller;
}

exports.name = 'smaller';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../type/matrix/utils/algorithm03":440,"../../type/matrix/utils/algorithm07":444,"../../type/matrix/utils/algorithm12":449,"../../type/matrix/utils/algorithm13":450,"../../type/matrix/utils/algorithm14":451,"../../utils/bignumber/nearlyEqual":470,"../../utils/latex":482,"../../utils/number":483}],357:[function(require,module,exports){
'use strict';

var nearlyEqual = require('../../utils/number').nearlyEqual;
var bigNearlyEqual = require('../../utils/bignumber/nearlyEqual');

function factory (type, config, load, typed) {

  var matrix = load(require('../../type/matrix/function/matrix'));

  var algorithm03 = load(require('../../type/matrix/utils/algorithm03'));
  var algorithm07 = load(require('../../type/matrix/utils/algorithm07'));
  var algorithm12 = load(require('../../type/matrix/utils/algorithm12'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

  var latex = require('../../utils/latex');

  /**
   * Test whether value x is smaller or equal to y.
   *
   * The function returns true when x is smaller than y or the relative
   * difference between x and y is smaller than the configured epsilon. The
   * function cannot be used to compare values smaller than approximately 2.22e-16.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.smallerEq(x, y)
   *
   * Examples:
   *
   *    math.smaller(1 + 2, 3);        // returns false
   *    math.smallerEq(1 + 2, 3);      // returns true
   *
   * See also:
   *
   *    equal, unequal, smaller, larger, largerEq, compare
   *
   * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
   * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} y Second value to compare
   * @return {boolean | Array | Matrix} Returns true when the x is smaller than y, else returns false
   */
  var smallerEq = typed('smallerEq', {

    'boolean, boolean': function (x, y) {
      return x <= y;
    },

    'number, number': function (x, y) {
      return x <= y || nearlyEqual(x, y, config.epsilon);
    },

    'BigNumber, BigNumber': function (x, y) {
      return x.lte(y) || bigNearlyEqual(x, y, config.epsilon);
    },

    'Fraction, Fraction': function (x, y) {
      return x.compare(y) !== 1;
    },

    'Complex, Complex': function () {
      throw new TypeError('No ordering relation is defined for complex numbers');
    },

    'Unit, Unit': function (x, y) {
      if (!x.equalBase(y)) {
        throw new Error('Cannot compare units with different base');
      }
      return smallerEq(x.value, y.value);
    },

    'string, string': function (x, y) {
      return x <= y;
    },

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse + sparse
              c = algorithm07(x, y, smallerEq);
              break;
            default:
              // sparse + dense
              c = algorithm03(y, x, smallerEq, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense + sparse
              c = algorithm03(x, y, smallerEq, false);
              break;
            default:
              // dense + dense
              c = algorithm13(x, y, smallerEq);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return smallerEq(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return smallerEq(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return smallerEq(x, matrix(y));
    },

    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm12(x, y, smallerEq, false);
          break;
        default:
          c = algorithm14(x, y, smallerEq, false);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm12(y, x, smallerEq, true);
          break;
        default:
          c = algorithm14(y, x, smallerEq, true);
          break;
      }
      return c;
    },

    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, smallerEq, false).valueOf();
    },

    'any, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, smallerEq, true).valueOf();
    }
  });

  smallerEq.toTex = '\\left(${args[0]}' + latex.operators['smallerEq'] + '${args[1]}\\right)';

  return smallerEq;
}

exports.name = 'smallerEq';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../type/matrix/utils/algorithm03":440,"../../type/matrix/utils/algorithm07":444,"../../type/matrix/utils/algorithm12":449,"../../type/matrix/utils/algorithm13":450,"../../type/matrix/utils/algorithm14":451,"../../utils/bignumber/nearlyEqual":470,"../../utils/latex":482,"../../utils/number":483}],358:[function(require,module,exports){
'use strict';

var nearlyEqual = require('../../utils/number').nearlyEqual;
var bigNearlyEqual = require('../../utils/bignumber/nearlyEqual');

function factory (type, config, load, typed) {

  var matrix = load(require('../../type/matrix/function/matrix'));

  var algorithm03 = load(require('../../type/matrix/utils/algorithm03'));
  var algorithm07 = load(require('../../type/matrix/utils/algorithm07'));
  var algorithm12 = load(require('../../type/matrix/utils/algorithm12'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

  var latex = require('../../utils/latex');

  /**
   * Test whether two values are unequal.
   *
   * The function tests whether the relative difference between x and y is
   * larger than the configured epsilon. The function cannot be used to compare
   * values smaller than approximately 2.22e-16.
   *
   * For matrices, the function is evaluated element wise.
   * In case of complex numbers, x.re must unequal y.re, or x.im must unequal y.im.
   *
   * Values `null` and `undefined` are compared strictly, thus `null` is unequal
   * with everything except `null`, and `undefined` is unequal with everying
   * except. `undefined`.
   *
   * Syntax:
   *
   *    math.unequal(x, y)
   *
   * Examples:
   *
   *    math.unequal(2 + 2, 3);       // returns true
   *    math.unequal(2 + 2, 4);       // returns false
   *
   *    var a = math.unit('50 cm');
   *    var b = math.unit('5 m');
   *    math.unequal(a, b);           // returns false
   *
   *    var c = [2, 5, 1];
   *    var d = [2, 7, 1];
   *
   *    math.unequal(c, d);           // returns [false, true, false]
   *    math.deepEqual(c, d);         // returns false
   *
   *    math.unequal(0, null);        // returns true
   * See also:
   *
   *    equal, deepEqual, smaller, smallerEq, larger, largerEq, compare
   *
   * @param  {number | BigNumber | Fraction | boolean | Complex | Unit | string | Array | Matrix | undefined} x First value to compare
   * @param  {number | BigNumber | Fraction | boolean | Complex | Unit | string | Array | Matrix | undefined} y Second value to compare
   * @return {boolean | Array | Matrix} Returns true when the compared values are unequal, else returns false
   */
  var unequal = typed('unequal', {
    
    'any, any': function (x, y) {
      // strict equality for null and undefined?
      if (x === null) { return y !== null; }
      if (y === null) { return x !== null; }
      if (x === undefined) { return y !== undefined; }
      if (y === undefined) { return x !== undefined; }

      return _unequal(x, y);
    },

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse + sparse
              c = algorithm07(x, y, _unequal);
              break;
            default:
              // sparse + dense
              c = algorithm03(y, x, _unequal, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense + sparse
              c = algorithm03(x, y, _unequal, false);
              break;
            default:
              // dense + dense
              c = algorithm13(x, y, _unequal);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return unequal(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return unequal(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return unequal(x, matrix(y));
    },

    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm12(x, y, _unequal, false);
          break;
        default:
          c = algorithm14(x, y, _unequal, false);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm12(y, x, _unequal, true);
          break;
        default:
          c = algorithm14(y, x, _unequal, true);
          break;
      }
      return c;
    },

    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, _unequal, false).valueOf();
    },

    'any, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, _unequal, true).valueOf();
    }
  });

  var _unequal = typed('_unequal', {

    'boolean, boolean': function (x, y) {
      return x !== y;
    },

    'number, number': function (x, y) {
      return !nearlyEqual(x, y, config.epsilon);
    },

    'BigNumber, BigNumber': function (x, y) {
      return !bigNearlyEqual(x, y, config.epsilon);
    },

    'Fraction, Fraction': function (x, y) {
      return !x.equals(y);
    },

    'Complex, Complex': function (x, y) {
      return !x.equals(y);
    },

    'Unit, Unit': function (x, y) {
      if (!x.equalBase(y)) {
        throw new Error('Cannot compare units with different base');
      }
      return unequal(x.value, y.value);
    },

    'string, string': function (x, y) {
      return x !== y;
    }
  });

  unequal.toTex = '\\left(${args[0]}' + latex.operators['unequal'] + '${args[1]}\\right)';

  return unequal;
}

exports.name = 'unequal';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../type/matrix/utils/algorithm03":440,"../../type/matrix/utils/algorithm07":444,"../../type/matrix/utils/algorithm12":449,"../../type/matrix/utils/algorithm13":450,"../../type/matrix/utils/algorithm14":451,"../../utils/bignumber/nearlyEqual":470,"../../utils/latex":482,"../../utils/number":483}],359:[function(require,module,exports){
module.exports = [
  require('./max'),
  require('./mean'),
  require('./median'),
  require('./min'),
  require('./mode'),
  require('./prod'),
  require('./quantileSeq'),
  require('./std'),
  require('./sum'),
  require('./var')
];
},{"./max":360,"./mean":361,"./median":362,"./min":363,"./mode":364,"./prod":365,"./quantileSeq":366,"./std":367,"./sum":368,"./var":369}],360:[function(require,module,exports){
'use strict';

var deepForEach = require('../../utils/collection/deepForEach');
var reduce = require('../../utils/collection/reduce');
var containsCollections = require('../../utils/collection/containsCollections');

function factory (type, config, load, typed) {
  var larger = load(require('../relational/larger'));

  /**
   * Compute the maximum value of a matrix or a  list with values.
   * In case of a multi dimensional array, the maximum of the flattened array
   * will be calculated. When `dim` is provided, the maximum over the selected
   * dimension will be calculated. Parameter `dim` is zero-based.
   *
   * Syntax:
   *
   *     math.max(a, b, c, ...)
   *     math.max(A)
   *     math.max(A, dim)
   *
   * Examples:
   *
   *     math.max(2, 1, 4, 3);                  // returns 4
   *     math.max([2, 1, 4, 3]);                // returns 4
   *
   *     // maximum over a specified dimension (zero-based)
   *     math.max([[2, 5], [4, 3], [1, 7]], 0); // returns [4, 7]
   *     math.max([[2, 5], [4, 3]], [1, 7], 1); // returns [5, 4, 7]
   *
   *     math.max(2.7, 7.1, -4.5, 2.0, 4.1);    // returns 7.1
   *     math.min(2.7, 7.1, -4.5, 2.0, 4.1);    // returns -4.5
   *
   * See also:
   *
   *    mean, median, min, prod, std, sum, var
   *
   * @param {... *} args  A single matrix or or multiple scalar values
   * @return {*} The maximum value
   */
  var max = typed('max', {
    // max([a, b, c, d, ...])
    'Array | Matrix': _max,

    // max([a, b, c, d, ...], dim)
    'Array | Matrix, number | BigNumber': function (array, dim) {
      return reduce(array, dim.valueOf(), _largest);
    },

    // max(a, b, c, d, ...)
    '...': function (args) {
      if (containsCollections(args)) {
        throw new TypeError('Scalar values expected in function max');
      }

      return _max(args);
    }
  });

  max.toTex = '\\max\\left(${args}\\right)';

  return max;

  /**
   * Return the largest of two values
   * @param {*} x
   * @param {*} y
   * @returns {*} Returns x when x is largest, or y when y is largest
   * @private
   */
  function _largest(x, y){
    return larger(x, y) ? x : y;
  }

  /**
   * Recursively calculate the maximum value in an n-dimensional array
   * @param {Array} array
   * @return {number} max
   * @private
   */
  function _max(array) {
    var max = undefined;

    deepForEach(array, function (value) {
      if (max === undefined || larger(value, max)) {
        max = value;
      }
    });

    if (max === undefined) {
      throw new Error('Cannot calculate max of an empty array');
    }

    return max;
  }
}

exports.name = 'max';
exports.factory = factory;

},{"../../utils/collection/containsCollections":473,"../../utils/collection/deepForEach":474,"../../utils/collection/reduce":477,"../relational/larger":354}],361:[function(require,module,exports){
'use strict';

var size = require('../../utils/array').size;
var deepForEach = require('../../utils/collection/deepForEach');
var reduce = require('../../utils/collection/reduce');
var containsCollections = require('../../utils/collection/containsCollections');

function factory (type, config, load, typed) {
  var add = load(require('../arithmetic/add'));
  var divide = load(require('../arithmetic/divide'));

  /**
   * Compute the mean value of matrix or a list with values.
   * In case of a multi dimensional array, the mean of the flattened array
   * will be calculated. When `dim` is provided, the maximum over the selected
   * dimension will be calculated. Parameter `dim` is zero-based.
   *
   * Syntax:
   *
   *     math.mean(a, b, c, ...)
   *     math.mean(A)
   *     math.mean(A, dim)
   *
   * Examples:
   *
   *     math.mean(2, 1, 4, 3);                     // returns 2.5
   *     math.mean([1, 2.7, 3.2, 4]);               // returns 2.725
   *
   *     math.mean([[2, 5], [6, 3], [1, 7]], 0);    // returns [3, 5]
   *     math.mean([[2, 5], [6, 3], [1, 7]], 1);    // returns [3.5, 4.5, 4]
   *
   * See also:
   *
   *     median, min, max, sum, prod, std, var
   *
   * @param {... *} args  A single matrix or or multiple scalar values
   * @return {*} The mean of all values
   */
  var mean = typed('mean', {
      // mean([a, b, c, d, ...])
    'Array | Matrix': _mean,

      // mean([a, b, c, d, ...], dim)
    'Array | Matrix, number | BigNumber': _nmean,

    // mean(a, b, c, d, ...)
    '...': function (args) {
      if (containsCollections(args)) {
        throw new TypeError('Scalar values expected in function mean');
      }

      return _mean(args);
    }
  });

  mean.toTex = '\\mathrm{${name}}\\left(${args}\\right)';

  return mean;

  /**
   * Calculate the mean value in an n-dimensional array, returning a
   * n-1 dimensional array
   * @param {Array} array
   * @param {number} dim
   * @return {number} mean
   * @private
   */
  function _nmean(array, dim){
    var sum = reduce(array, dim, add);
    var s = Array.isArray(array) ? size(array) : array.size();
    return divide(sum, s[dim]);
  }

  /**
   * Recursively calculate the mean value in an n-dimensional array
   * @param {Array} array
   * @return {number} mean
   * @private
   */
  function _mean(array) {
    var sum = 0;
    var num = 0;

    deepForEach(array, function (value) {
      sum = add(sum, value);
      num++;
    });

    if (num === 0) {
      throw new Error('Cannot calculate mean of an empty array');
    }

    return divide(sum, num);
  }
}

exports.name = 'mean';
exports.factory = factory;

},{"../../utils/array":461,"../../utils/collection/containsCollections":473,"../../utils/collection/deepForEach":474,"../../utils/collection/reduce":477,"../arithmetic/add":255,"../arithmetic/divide":260}],362:[function(require,module,exports){
'use strict';

var flatten = require('../../utils/array').flatten;
var reduce = require('../../utils/collection/reduce');
var containsCollections = require('../../utils/collection/containsCollections');

function factory (type, config, load, typed) {
  var add = load(require('../arithmetic/addScalar'));
  var divide = load(require('../arithmetic/divideScalar'));
  var compare = load(require('../relational/compare'));
  var partitionSelect = load(require('../matrix/partitionSelect'));

  /**
   * Compute the median of a matrix or a list with values. The values are
   * sorted and the middle value is returned. In case of an even number of
   * values, the average of the two middle values is returned.
   * Supported types of values are: Number, BigNumber, Unit
   *
   * In case of a (multi dimensional) array or matrix, the median of all
   * elements will be calculated.
   *
   * Syntax:
   *
   *     math.median(a, b, c, ...)
   *     math.median(A)
   *
   * Examples:
   *
   *     math.median(5, 2, 7);        // returns 5
   *     math.median([3, -1, 5, 7]);  // returns 4
   *
   * See also:
   *
   *     mean, min, max, sum, prod, std, var
   *
   * @param {... *} args  A single matrix or or multiple scalar values
   * @return {*} The median
   */
  var median = typed('median', {
    // median([a, b, c, d, ...])
    'Array | Matrix': _median,

    // median([a, b, c, d, ...], dim)
    'Array | Matrix, number | BigNumber': function (array, dim) {
      // TODO: implement median(A, dim)
      throw new Error('median(A, dim) is not yet supported');
      //return reduce(arguments[0], arguments[1], ...);
    },

    // median(a, b, c, d, ...)
    '...': function (args) {
      if (containsCollections(args)) {
          throw new TypeError('Scalar values expected in function median');
      }

      return _median(args);
    }
  });


  /**
   * Recursively calculate the median of an n-dimensional array
   * @param {Array} array
   * @return {Number} median
   * @private
   */
  function _median(array) {
    array = flatten(array.valueOf());

    var num = array.length;
    if (num == 0) {
      throw new Error('Cannot calculate median of an empty array');
    }

    if (num % 2 == 0) {
      // even: return the average of the two middle values
      var mid = num / 2 - 1;
      var right = partitionSelect(array, mid + 1);

      // array now partitioned at mid + 1, take max of left part
      var left = array[mid];
      for (var i = 0; i < mid; ++i) {
        if (compare(array[i], left) > 0) {
          left = array[i];
        }
      }

      return middle2(left, right);
    }
    else {
      // odd: return the middle value
      var m = partitionSelect(array, (num - 1) / 2);

      return middle(m);
    }
  }

  // helper function to type check the middle value of the array
  var middle = typed({
    'number | BigNumber | Unit': function (value) {
      return value;
    }
  });

  // helper function to type check the two middle value of the array
  var middle2 = typed({
    'number | BigNumber | Unit, number | BigNumber | Unit': function (left, right) {
      return divide(add(left, right), 2);
    }
  });

  median.toTex = '\\mathrm{${name}}\\left(${args}\\right)';

  return median;
}

exports.name = 'median';
exports.factory = factory;

},{"../../utils/array":461,"../../utils/collection/containsCollections":473,"../../utils/collection/reduce":477,"../arithmetic/addScalar":256,"../arithmetic/divideScalar":261,"../matrix/partitionSelect":328,"../relational/compare":349}],363:[function(require,module,exports){
'use strict';

var deepForEach = require('../../utils/collection/deepForEach');
var reduce = require('../../utils/collection/reduce');
var containsCollections = require('../../utils/collection/containsCollections');

function factory (type, config, load, typed) {
  var smaller = load(require('../relational/smaller'));
  
  /**
   * Compute the maximum value of a matrix or a  list of values.
   * In case of a multi dimensional array, the maximum of the flattened array
   * will be calculated. When `dim` is provided, the maximum over the selected
   * dimension will be calculated. Parameter `dim` is zero-based.
   *
   * Syntax:
   *
   *     math.min(a, b, c, ...)
   *     math.min(A)
   *     math.min(A, dim)
   *
   * Examples:
   *
   *     math.min(2, 1, 4, 3);                  // returns 1
   *     math.min([2, 1, 4, 3]);                // returns 1
   *
   *     // maximum over a specified dimension (zero-based)
   *     math.min([[2, 5], [4, 3], [1, 7]], 0); // returns [1, 3]
   *     math.min([[2, 5], [4, 3], [1, 7]], 1); // returns [2, 3, 1]
   *
   *     math.max(2.7, 7.1, -4.5, 2.0, 4.1);    // returns 7.1
   *     math.min(2.7, 7.1, -4.5, 2.0, 4.1);    // returns -4.5
   *
   * See also:
   *
   *    mean, median, max, prod, std, sum, var
   *
   * @param {... *} args  A single matrix or or multiple scalar values
   * @return {*} The minimum value
   */
  var min = typed('min', {
    // min([a, b, c, d, ...])
    'Array | Matrix': _min,

    // min([a, b, c, d, ...], dim)
    'Array | Matrix, number | BigNumber': function (array, dim) {
      return reduce(array, dim.valueOf(), _smallest);
    },

    // min(a, b, c, d, ...)
    '...': function (args) {
      if (containsCollections(args)) {
        throw new TypeError('Scalar values expected in function min');
      }

      return _min(args);
    }
  });

  min.toTex = '\\min\\left(${args}\\right)';

  return min;

  /**
   * Return the smallest of two values
   * @param {*} x
   * @param {*} y
   * @returns {*} Returns x when x is smallest, or y when y is smallest
   * @private
   */
  function _smallest(x, y) {
    return smaller(x, y) ? x : y;
  }

  /**
   * Recursively calculate the minimum value in an n-dimensional array
   * @param {Array} array
   * @return {number} min
   * @private
   */
  function _min(array) {
    var min = undefined;

    deepForEach(array, function (value) {
      if (min === undefined || smaller(value, min)) {
        min = value;
      }
    });

    if (min === undefined) {
      throw new Error('Cannot calculate min of an empty array');
    }

    return min;
  }
}

exports.name = 'min';
exports.factory = factory;

},{"../../utils/collection/containsCollections":473,"../../utils/collection/deepForEach":474,"../../utils/collection/reduce":477,"../relational/smaller":356}],364:[function(require,module,exports){
'use strict';

var flatten = require('../../utils/array').flatten;

function factory (type, config, load, typed) {

  /**
  * Computes the mode of a set of numbers or a list with values(numbers or characters).
  * If there are more than one modes, it returns a list of those values.
  *
  * Syntax:
  *
  *     math.mode(a, b, c, ...)
  *     math.mode(A)
  *
  * Examples:
  *
  *     math.mode(2, 1, 4, 3, 1);                            // returns [1]
  *     math.mode([1, 2.7, 3.2, 4, 2.7]);                    // returns [2.7]
  *     math.mode(1, 4, 6, 1, 6)                             // returns [1, 6]
  *     math.mode('a','a','b','c')                           // returns ["a"]
  *     math.mode(1, 1.5, 'abc')                             // returns [1, 1.5, "abc"]
  *
  * See also:
  *
  *     median,
  *     mean
  *
  * @param {... *} args  A single matrix
  * @return {*} The mode of all values
  */

  var mode = typed('mode', {
    'Array | Matrix' : _mode,
    
    '...': function (args) {
      return _mode(args);
    }
  });
  
  return mode;

  /**
   * Calculates the mode in an 1-dimensional array
   * @param {Array} values
   * @return {number} mode
   * @private
   */
  function _mode(values) {
    values = flatten(values.valueOf());
    var num = values.length;
    if (num == 0) {
      throw new Error('Cannot calculate mode of an empty array');
    }
    
    var count = {},
        mode = [],
        max = 0;
    for (var i in values) {
      if (!(values[i] in count)){
        count[values[i]] = 0;
      }
      count[values[i]]++;
      if (count[values[i]] == max){
        mode.push(values[i]);
      }
      else if (count[values[i]] > max) {
        max = count[values[i]];
        mode = [values[i]];
      }
    }
    return mode; 
  };
}

exports.name = 'mode';
exports.factory = factory;
},{"../../utils/array":461}],365:[function(require,module,exports){
'use strict';

var deepForEach = require('../../utils/collection/deepForEach');

function factory (type, config, load, typed) {
  var multiply = load(require('../arithmetic/multiplyScalar'));

  /**
   * Compute the product of a matrix or a list with values.
   * In case of a (multi dimensional) array or matrix, the sum of all
   * elements will be calculated.
   *
   * Syntax:
   *
   *     math.prod(a, b, c, ...)
   *     math.prod(A)
   *
   * Examples:
   *
   *     math.multiply(2, 3);           // returns 6
   *     math.prod(2, 3);               // returns 6
   *     math.prod(2, 3, 4);            // returns 24
   *     math.prod([2, 3, 4]);          // returns 24
   *     math.prod([[2, 5], [4, 3]]);   // returns 120
   *
   * See also:
   *
   *    mean, median, min, max, sum, std, var
   *
   * @param {... *} args  A single matrix or or multiple scalar values
   * @return {*} The product of all values
   */
  var prod = typed('prod', {
    // prod([a, b, c, d, ...])
    'Array | Matrix': _prod,

    // prod([a, b, c, d, ...], dim)
    'Array | Matrix, number | BigNumber': function (array, dim) {
      // TODO: implement prod(A, dim)
      throw new Error('prod(A, dim) is not yet supported');
      //return reduce(arguments[0], arguments[1], math.prod);
    },

    // prod(a, b, c, d, ...)
    '...': function (args) {
      return _prod(args);
    }
  });

  prod.toTex = '\\mathrm{${name}}\\left(${args}\\right)';

  return prod;

  /**
   * Recursively calculate the product of an n-dimensional array
   * @param {Array} array
   * @return {number} prod
   * @private
   */
  function _prod(array) {
    var prod = undefined;

    deepForEach(array, function (value) {
      prod = (prod === undefined) ? value : multiply(prod, value);
    });

    if (prod === undefined) {
      throw new Error('Cannot calculate prod of an empty array');
    }

    return prod;
  }
}

exports.name = 'prod';
exports.factory = factory;

},{"../../utils/collection/deepForEach":474,"../arithmetic/multiplyScalar":276}],366:[function(require,module,exports){
'use strict';

var isInteger = require('../../utils/number').isInteger;
var isNumber = require('../../utils/number').isNumber;
var flatten = require('../../utils/array').flatten;
var isCollection = require('../../utils/collection/isCollection');

function factory (type, config, load, typed) {
  var add = load(require('../arithmetic/add'));
  var multiply = load(require('../arithmetic/multiply'));
  var partitionSelect = load(require('../matrix/partitionSelect'));
  var compare = load(require('../relational/compare'));

  /**
   * Compute the prob order quantile of a matrix or a list with values.
   * The sequence is sorted and the middle value is returned.
   * Supported types of sequence values are: Number, BigNumber, Unit
   * Supported types of probability are: Number, BigNumber
   *
   * In case of a (multi dimensional) array or matrix, the prob order quantile
   * of all elements will be calculated.
   *
   * Syntax:
   *
   *     math.quantileSeq(A, prob[, sorted])
   *     math.quantileSeq(A, [prob1, prob2, ...][, sorted])
   *     math.quantileSeq(A, N[, sorted])
   *
   * Examples:
   *
   *     math.quantileSeq([3, -1, 5, 7], 0.5);         // returns 4
   *     math.quantileSeq([3, -1, 5, 7], [1/3, 2/3]);  // returns [3, 5]
   *     math.quantileSeq([3, -1, 5, 7], 2);           // returns [3, 5]
   *     math.quantileSeq([-1, 3, 5, 7], 0.5, true);   // returns 4
   *
   * See also:
   *
   *     median, mean, min, max, sum, prod, std, var
   *
   * @param {Array, Matrix} data                A single matrix or Array
   * @param {Number, BigNumber, Array} probOrN  prob is the order of the quantile, while N is
   *                                            the amount of evenly distributed steps of
   *                                            probabilities; only one of these options can
   *                                            be provided
   * @param {Boolean} sorted=false              is data sorted in ascending order
   * @return {Number, BigNumber, Unit, Array}   Quantile(s)
   */
  function quantileSeq(data, probOrN, sorted) {
    var probArr, dataArr, one;

    if (arguments.length < 2 || arguments.length > 3) {
      throw new SyntaxError('Function quantileSeq requires two or three parameters');
    }

    if (isCollection(data)) {
      sorted = sorted || false;
      if (typeof sorted === 'boolean') {
        dataArr = data.valueOf();
        if (isNumber(probOrN)) {
          if (probOrN < 0) {
            throw new Error('N/prob must be non-negative');
          }

          if (probOrN <= 1) {
            // quantileSeq([a, b, c, d, ...], prob[,sorted])
            return _quantileSeq(dataArr, probOrN, sorted);
          }

          if (probOrN > 1) {
            // quantileSeq([a, b, c, d, ...], N[,sorted])
            if (!isInteger(probOrN)) {
              throw new Error('N must be a positive integer');
            }

            var nPlusOne = probOrN + 1;
            probArr = new Array(probOrN);
            for (var i = 0; i < probOrN;) {
              probArr[i] = _quantileSeq(dataArr, (++i) / nPlusOne, sorted);
            }
            return probArr;
          }
        }

        if (probOrN && probOrN.isBigNumber) {
          if (probOrN.isNegative()) {
            throw new Error('N/prob must be non-negative');
          }

          one = new probOrN.constructor(1);

          if (probOrN.lte(one)) {
            // quantileSeq([a, b, c, d, ...], prob[,sorted])
            return _quantileSeq(dataArr, probOrN, sorted);
          }

          if (probOrN.gt(one)) {
            // quantileSeq([a, b, c, d, ...], N[,sorted])
            if (!probOrN.isInteger()) {
              throw new Error('N must be a positive integer');
            }

            // largest possible Array length is 2^32-1;
            // 2^32 < 10^15, thus safe conversion guaranteed
            var intN = probOrN.toNumber();
            if (intN > 4294967295) {
              throw new Error('N must be less than or equal to 2^32-1, as that is the maximum length of an Array');
            }

            var nPlusOne = new type.BigNumber(intN + 1);
            probArr = new Array(intN);
            for (var i = 0; i < intN;) {
              probArr[i] = _quantileSeq(dataArr, new type.BigNumber(++i).div(nPlusOne), sorted);
            }
            return probArr;
          }
        }

        if (Array.isArray(probOrN)) {
          // quantileSeq([a, b, c, d, ...], [prob1, prob2, ...][,sorted])
          probArr = new Array(probOrN.length);
          for (var i = 0; i < probArr.length; ++i) {
            var currProb = probOrN[i];
            if (isNumber(currProb)) {
              if (currProb < 0 || currProb > 1) {
                throw new Error('Probability must be between 0 and 1, inclusive');
              }
            } else if (currProb && currProb.isBigNumber) {
              one = new currProb.constructor(1);
              if (currProb.isNegative() || currProb.gt(one)) {
                throw new Error('Probability must be between 0 and 1, inclusive');
              }
            } else {
              throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function
            }

            probArr[i] = _quantileSeq(dataArr, currProb, sorted);
          }
          return probArr;
        }

        throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function
      }

      throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function
    }

    throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function
  }

  /**
   * Calculate the prob order quantile of an n-dimensional array.
   * 
   * @param {Array} array
   * @param {Number, BigNumber} prob
   * @param {Boolean} sorted
   * @return {Number, BigNumber, Unit} prob order quantile
   * @private
   */
  function _quantileSeq(array, prob, sorted) {
    var flat = flatten(array);
    var len = flat.length;
    if (len === 0) {
      throw new Error('Cannot calculate quantile of an empty sequence');
    }

    if (isNumber(prob)) {
      var index = prob * (len-1);
      var fracPart = index % 1;
      if (fracPart === 0) {
        var value = sorted ? flat[index] : partitionSelect(flat, index);

        validate(value);

        return value;
      }

      var integerPart = Math.floor(index);

      var left, right;
      if (sorted) {
        left = flat[integerPart];
        right = flat[integerPart+1];
      } else {
        right = partitionSelect(flat, integerPart+1);

        // max of partition is kth largest
        left = flat[integerPart];
        for (var i = 0; i < integerPart; ++i) {
          if (compare(flat[i], left) > 0) {
            left = flat[i];
          }
        }
      }

      validate(left);
      validate(right);

      // Q(prob) = (1-f)*A[floor(index)] + f*A[floor(index)+1]
      return add(multiply(left, 1 - fracPart), multiply(right, fracPart));
    }

    // If prob is a BigNumber
    var index = prob.times(len-1);
    if (index.isInteger()) {
      index = index.toNumber();
      var value = sorted ? flat[index] : partitionSelect(flat, index);

      validate(value);

      return value;
    }

    var integerPart = index.floor();
    var fracPart = index.minus(integerPart);
    var integerPartNumber = integerPart.toNumber();

    var left, right;
    if (sorted) {
      left = flat[integerPartNumber];
      right = flat[integerPartNumber+1];
    } else {
      right = partitionSelect(flat, integerPartNumber+1);

      // max of partition is kth largest
      left = flat[integerPartNumber];
      for (var i = 0; i < integerPartNumber; ++i) {
        if (compare(flat[i], left) > 0) {
          left = flat[i];
        }
      }
    }

    validate(left);
    validate(right);

    // Q(prob) = (1-f)*A[floor(index)] + f*A[floor(index)+1]
    var one = new fracPart.constructor(1);
    return add(multiply(left, one.minus(fracPart)), multiply(right, fracPart));
  }

  /**
   * Check if array value types are valid, throw error otherwise.
   * @param {number | BigNumber | Unit} x
   * @param {number | BigNumber | Unit} x
   * @private
   */
  var validate = typed({
    'number | BigNumber | Unit': function (x) {
      return x;
    }
  });

  return quantileSeq;
}

exports.name = 'quantileSeq';
exports.factory = factory;

},{"../../utils/array":461,"../../utils/collection/isCollection":476,"../../utils/number":483,"../arithmetic/add":255,"../arithmetic/multiply":275,"../matrix/partitionSelect":328,"../relational/compare":349}],367:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  var sqrt       = load(require('../arithmetic/sqrt'));
  var variance   = load(require('../statistics/var'));

  /**
   * Compute the standard deviation of a matrix or a  list with values.
   * The standard deviations is defined as the square root of the variance:
   * `std(A) = sqrt(var(A))`.
   * In case of a (multi dimensional) array or matrix, the standard deviation
   * over all elements will be calculated.
   *
   * Optionally, the type of normalization can be specified as second
   * parameter. The parameter `normalization` can be one of the following values:
   *
   * - 'unbiased' (default) The sum of squared errors is divided by (n - 1)
   * - 'uncorrected'        The sum of squared errors is divided by n
   * - 'biased'             The sum of squared errors is divided by (n + 1)
   *
   * Syntax:
   *
   *     math.std(a, b, c, ...)
   *     math.std(A)
   *     math.std(A, normalization)
   *
   * Examples:
   *
   *     math.std(2, 4, 6);                     // returns 2
   *     math.std([2, 4, 6, 8]);                // returns 2.581988897471611
   *     math.std([2, 4, 6, 8], 'uncorrected'); // returns 2.23606797749979
   *     math.std([2, 4, 6, 8], 'biased');      // returns 2
   *
   *     math.std([[1, 2, 3], [4, 5, 6]]);      // returns 1.8708286933869707
   *
   * See also:
   *
   *    mean, median, max, min, prod, sum, var
   *
   * @param {Array | Matrix} array
   *                        A single matrix or or multiple scalar values
   * @param {string} [normalization='unbiased']
   *                        Determines how to normalize the variance.
   *                        Choose 'unbiased' (default), 'uncorrected', or 'biased'.
   * @return {*} The standard deviation
   */
  var std = typed('std', {
    // std([a, b, c, d, ...])
    'Array | Matrix': _std,

    // std([a, b, c, d, ...], normalization)
    'Array | Matrix, string': _std,

    // std(a, b, c, d, ...)
    '...': function (args) {
      return _std(args);
    }
  });
  
  std.toTex = '\\mathrm{${name}}\\left(${args}\\right)';

  return std;

  function _std(array, normalization) {
    if (array.length == 0) {
      throw new SyntaxError('Function std requires one or more parameters (0 provided)');
    }

    return sqrt(variance.apply(null, arguments));
  }
}

exports.name = 'std';
exports.factory = factory;

},{"../arithmetic/sqrt":282,"../statistics/var":369}],368:[function(require,module,exports){
'use strict';

var deepForEach = require('../../utils/collection/deepForEach');

function factory (type, config, load, typed) {
  var add = load(require('../arithmetic/addScalar'));

  /**
   * Compute the sum of a matrix or a list with values.
   * In case of a (multi dimensional) array or matrix, the sum of all
   * elements will be calculated.
   *
   * Syntax:
   *
   *     math.sum(a, b, c, ...)
   *     math.sum(A)
   *
   * Examples:
   *
   *     math.sum(2, 1, 4, 3);               // returns 10
   *     math.sum([2, 1, 4, 3]);             // returns 10
   *     math.sum([[2, 5], [4, 3], [1, 7]]); // returns 22
   *
   * See also:
   *
   *    mean, median, min, max, prod, std, var
   *
   * @param {... *} args  A single matrix or or multiple scalar values
   * @return {*} The sum of all values
   */
  var sum = typed('sum', {
    'Array | Matrix': function (args) {
      // sum([a, b, c, d, ...])
      return _sum(args);
    },

    'Array | Matrix, number | BigNumber': function () {
      // sum([a, b, c, d, ...], dim)
      // TODO: implement sum(A, dim)
      throw new Error('sum(A, dim) is not yet supported');
    },

    '...': function (args) {
      // sum(a, b, c, d, ...)
      return _sum(args);
    }
  });

  sum.toTex = '\\mathrm{${name}}\\left(${args}\\right)';

  return sum;

  /**
   * Recursively calculate the sum of an n-dimensional array
   * @param {Array} array
   * @return {number} sum
   * @private
   */
  function _sum(array) {
    var sum = undefined;

    deepForEach(array, function (value) {
      sum = (sum === undefined) ? value : add(sum, value);
    });

    if (sum === undefined) {
      switch (config.number) {
        case 'number':
          return 0;
        case 'BigNumber':
          return new type.BigNumber(0);
        case 'Fraction':
          return new type.Fraction(0);
        default:
          return 0;
      }
    }

    return sum;
  }
}

exports.name = 'sum';
exports.factory = factory;

},{"../../utils/collection/deepForEach":474,"../arithmetic/addScalar":256}],369:[function(require,module,exports){
'use strict';

var DEFAULT_NORMALIZATION = 'unbiased';

var deepForEach = require('../../utils/collection/deepForEach');

function factory (type, config, load, typed) {
  var add = load(require('../arithmetic/addScalar'));
  var subtract = load(require('../arithmetic/subtract'));
  var multiply = load(require('../arithmetic/multiplyScalar'));
  var divide = load(require('../arithmetic/divideScalar'));

  /**
   * Compute the variance of a matrix or a  list with values.
   * In case of a (multi dimensional) array or matrix, the variance over all
   * elements will be calculated.
   *
   * Optionally, the type of normalization can be specified as second
   * parameter. The parameter `normalization` can be one of the following values:
   *
   * - 'unbiased' (default) The sum of squared errors is divided by (n - 1)
   * - 'uncorrected'        The sum of squared errors is divided by n
   * - 'biased'             The sum of squared errors is divided by (n + 1)
   *
   * Note that older browser may not like the variable name `var`. In that
   * case, the function can be called as `math['var'](...)` instead of
   * `math.var(...)`.
   *
   * Syntax:
   *
   *     math.var(a, b, c, ...)
   *     math.var(A)
   *     math.var(A, normalization)
   *
   * Examples:
   *
   *     math.var(2, 4, 6);                     // returns 4
   *     math.var([2, 4, 6, 8]);                // returns 6.666666666666667
   *     math.var([2, 4, 6, 8], 'uncorrected'); // returns 5
   *     math.var([2, 4, 6, 8], 'biased');      // returns 4
   *
   *     math.var([[1, 2, 3], [4, 5, 6]]);      // returns 3.5
   *
   * See also:
   *
   *    mean, median, max, min, prod, std, sum
   *
   * @param {Array | Matrix} array
   *                        A single matrix or or multiple scalar values
   * @param {string} [normalization='unbiased']
   *                        Determines how to normalize the variance.
   *                        Choose 'unbiased' (default), 'uncorrected', or 'biased'.
   * @return {*} The variance
   */
  var variance = typed('variance', {
    // var([a, b, c, d, ...])
    'Array | Matrix': function (array) {
      return _var(array, DEFAULT_NORMALIZATION);
    },

    // var([a, b, c, d, ...], normalization)
    'Array | Matrix, string': _var,

    // var(a, b, c, d, ...)
    '...': function (args) {
      return _var(args, DEFAULT_NORMALIZATION);
    }
  });

  variance.toTex = '\\mathrm{Var}\\left(${args}\\right)';

  return variance;

  /**
   * Recursively calculate the variance of an n-dimensional array
   * @param {Array} array
   * @param {string} normalization
   *                        Determines how to normalize the variance:
   *                        - 'unbiased'    The sum of squared errors is divided by (n - 1)
   *                        - 'uncorrected' The sum of squared errors is divided by n
   *                        - 'biased'      The sum of squared errors is divided by (n + 1)
   * @return {number | BigNumber} variance
   * @private
   */
  function _var(array, normalization) {
    var sum = 0;
    var num = 0;

    if (array.length == 0) {
      throw new SyntaxError('Function var requires one or more parameters (0 provided)');
    }

    // calculate the mean and number of elements
    deepForEach(array, function (value) {
      sum = add(sum, value);
      num++;
    });
    if (num === 0) throw new Error('Cannot calculate var of an empty array');

    var mean = divide(sum, num);

    // calculate the variance
    sum = 0;
    deepForEach(array, function (value) {
      var diff = subtract(value, mean);
      sum = add(sum, multiply(diff, diff));
    });

    switch (normalization) {
      case 'uncorrected':
        return divide(sum, num);

      case 'biased':
        return divide(sum, num + 1);

      case 'unbiased':
        var zero = (sum && sum.isBigNumber === true) ? new type.BigNumber(0) : 0;
        return (num == 1) ? zero : divide(sum, num - 1);

      default:
        throw new Error('Unknown normalization "' + normalization + '". ' +
        'Choose "unbiased" (default), "uncorrected", or "biased".');
    }
  }
}

exports.name = 'var';
exports.factory = factory;

},{"../../utils/collection/deepForEach":474,"../arithmetic/addScalar":256,"../arithmetic/divideScalar":261,"../arithmetic/multiplyScalar":276,"../arithmetic/subtract":284}],370:[function(require,module,exports){
'use strict';

var string = require('../../utils/string');

function factory (type, config, load, typed) {
  /**
   * Format a value of any type into a string.
   *
   * Syntax:
   *
   *    math.format(value)
   *    math.format(value, options)
   *    math.format(value, precision)
   *    math.format(value, fn)
   *
   * Where:
   *
   *  - `value: *`
   *    The value to be formatted
   *  - `options: Object`
   *    An object with formatting options. Available options:
   *    - `notation: string`
   *      Number notation. Choose from:
   *      - 'fixed'
   *        Always use regular number notation.
   *        For example '123.40' and '14000000'
   *      - 'exponential'
   *        Always use exponential notation.
   *        For example '1.234e+2' and '1.4e+7'
   *      - 'auto' (default)
   *        Regular number notation for numbers having an absolute value between
   *        `lower` and `upper` bounds, and uses exponential notation elsewhere.
   *        Lower bound is included, upper bound is excluded.
   *        For example '123.4' and '1.4e7'.
   *    - `precision: number`
   *      A number between 0 and 16 to round the digits of the number. In case
   *      of notations 'exponential' and 'auto', `precision` defines the total
   *      number of significant digits returned and is undefined by default.
   *      In case of notation 'fixed', `precision` defines the number of
   *      significant digits after the decimal point, and is 0 by default.
   *    - `exponential: Object`
   *      An object containing two parameters, {number} lower and {number} upper,
   *      used by notation 'auto' to determine when to return exponential
   *      notation. Default values are `lower=1e-3` and `upper=1e5`. Only
   *      applicable for notation `auto`.
   *    - `fraction: string`. Available values: 'ratio' (default) or 'decimal'.
   *      For example `format(fraction(1, 3))` will output '1/3' when 'ratio' is
   *      configured, and will output `0.(3)` when 'decimal' is configured.
   * - `fn: Function`
   *   A custom formatting function. Can be used to override the built-in notations.
   *   Function `fn` is called with `value` as parameter and must return a string.
   *   Is useful for example to format all values inside a matrix in a particular way.
   *
   * When `value` is an Object:
   *
   * - When the object contains a property `format` being a function, this function
   *   is invoked as `value.format(options)` and the result is returned.
   * - When the object has its own `toString` method, this method is invoked
   *   and the result is returned.
   * - In other cases the function will loop over all object properties and
   *   return JSON object notation like '{"a": 2, "b": 3}'.
   *
   * When value is a function:
   *
   * - When the function has a property `syntax`, it returns this
   *   syntax description.
   * - In other cases, a string `'function'` is returned.
   *
   * Examples:
   *
   *    math.format(6.4);                                        // returns '6.4'
   *    math.format(1240000);                                    // returns '1.24e6'
   *    math.format(1/3);                                        // returns '0.3333333333333333'
   *    math.format(1/3, 3);                                     // returns '0.333'
   *    math.format(21385, 2);                                   // returns '21000'
   *    math.format(12.071, {notation: 'fixed'});                // returns '12'
   *    math.format(2.3,    {notation: 'fixed', precision: 2});  // returns '2.30'
   *    math.format(52.8,   {notation: 'exponential'});          // returns '5.28e+1'
   *
   * See also:
   *
   *    print
   *
   * @param {*} value                               Value to be stringified
   * @param {Object | Function | number} [options]  Formatting options
   * @return {string} The formatted value
   */
  var format = typed('format', {
    'any': string.format,
    'any, Object | function | number': string.format
  });

  format.toTex = '\\mathrm{${name}}\\left(${args}\\right)';

  return format;
}

exports.name = 'format';
exports.factory = factory;

},{"../../utils/string":485}],371:[function(require,module,exports){
module.exports = [
  require('./format'),
  require('./print')
];

},{"./format":370,"./print":372}],372:[function(require,module,exports){
'use strict';

var isString = require('../../utils/string').isString;
var format = require('../../utils/string').format;

function factory (type, config, load, typed) {
  /**
   * Interpolate values into a string template.
   *
   * Syntax:
   *
   *     math.print(template, values)
   *     math.print(template, values, precision)
   *     math.print(template, values, options)
   *
   * Example usage:
   *
   *     // the following outputs: 'Lucy is 5 years old'
   *     math.print('Lucy is $age years old', {age: 5});
   *
   *     // the following outputs: 'The value of pi is 3.141592654'
   *     math.print('The value of pi is $pi', {pi: math.pi}, 10);
   *
   *     // the following outputs: 'hello Mary! The date is 2013-03-23'
   *     math.print('Hello $user.name! The date is $date', {
   *       user: {
   *         name: 'Mary',
   *       },
   *       date: new Date(2013, 2, 23).toISOString().substring(0, 10)
   *     });
   *
   * See also:
   *
   *     format
   *
   * @param {string} template     A string containing variable placeholders.
   * @param {Object} values       An object containing variables which will
   *                              be filled in in the template.
   * @param {number | Object} [options]  Formatting options,
   *                              or the number of digits to format numbers.
   *                              See function math.format for a description
   *                              of all options.
   * @return {string} Interpolated string
   */
  var print = typed ('print', {
    'string, Object': _print,
    'string, Object, number': _print
  });

  print.toTex = '\\mathrm{${name}}\\left(${args}\\right)';

  return print;
}

/**
 * Interpolate values into a string template.
 * @param {string} template
 * @param {Object} values
 * @param {number | Object} [options]
 * @returns {string} Interpolated string
 * @private
 */
function _print(template, values, options) {
  return template.replace(/\$([\w\.]+)/g, function (original, key) {
        var keys = key.split('.');
        var value = values[keys.shift()];
        while (keys.length && value !== undefined) {
          var k = keys.shift();
          value = k ? value[k] : value + '.';
        }

        if (value !== undefined) {
          if (!isString(value)) {
            return format(value, options);
          }
          else {
            return value;
          }
        }

        return original;
      }
  );
}

exports.name = 'print';
exports.factory = factory;

},{"../../utils/string":485}],373:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {

  /**
   * Calculate the inverse cosine of a value.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.acos(x)
   *
   * Examples:
   *
   *    math.acos(0.5);           // returns number 1.0471975511965979
   *    math.acos(math.cos(1.5)); // returns number 1.5
   *
   *    math.acos(2);             // returns Complex 0 + 1.3169578969248166 i
   *
   * See also:
   *
   *    cos, atan, asin
   *
   * @param {number | BigNumber | Complex | Array | Matrix} x  Function input
   * @return {number | BigNumber | Complex | Array | Matrix} The arc cosine of x
   */
  var acos = typed('acos', {
    'number': function (x) {
      if ((x >= -1 && x <= 1) || config.predictable) {
        return Math.acos(x);
      }
      else {
        return new type.Complex(x, 0).acos();
      }
    },

    'Complex': function (x) {
      return x.acos();
    },

    'BigNumber': function (x) {
      return x.acos();
    },

    'Array | Matrix': function (x) {
      return deepMap(x, acos);
    }
  });

  acos.toTex = '\\cos^{-1}\\left(${args[0]}\\right)';

  return acos;
}

exports.name = 'acos';
exports.factory = factory;

},{"../../utils/collection/deepMap":475}],374:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {

  /**
   * Calculate the hyperbolic arccos of a value,
   * defined as `acosh(x) = ln(sqrt(x^2 - 1) + x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.acosh(x)
   *
   * Examples:
   *
   *    math.acosh(1.5);       // returns 0.9624236501192069
   *
   * See also:
   *
   *    cosh, asinh, atanh
   *
   * @param {number | Complex | Unit | Array | Matrix} x  Function input
   * @return {number | Complex | Array | Matrix} Hyperbolic arccosine of x
   */
  var acosh = typed('acosh', {
    'number': function (x) {
      if (x >= 1 || config.predictable) {
        return Math.log(Math.sqrt(x*x - 1) + x);
      }
      if (x <= -1) {
        return new type.Complex(Math.log(Math.sqrt(x*x - 1) - x), Math.PI);
      }
      return new type.Complex(x, 0).acosh();
    },

    'Complex': function (x) {
      return x.acosh();
    },

    'BigNumber': function (x) {
      return x.acosh();
    },

    'Array | Matrix': function (x) {
      return deepMap(x, acosh);
    }
  });

  acosh.toTex = '\\cosh^{-1}\\left(${args[0]}\\right)';

  return acosh;
}

exports.name = 'acosh';
exports.factory = factory;

},{"../../utils/collection/deepMap":475}],375:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {

  /**
   * Calculate the inverse cotangent of a value, defined as `acot(x) = atan(1/x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.acot(x)
   *
   * Examples:
   *
   *    math.acot(0.5);           // returns number 0.4636476090008061
   *    math.acot(math.cot(1.5)); // returns number 1.5
   *
   *    math.acot(2);             // returns Complex 1.5707963267948966 -1.3169578969248166 i
   *
   * See also:
   *
   *    cot, atan
   *
   * @param {number | Complex | Array | Matrix} x   Function input
   * @return {number | Complex | Array | Matrix} The arc cotangent of x
   */
  var acot = typed('acot', {
    'number': function (x) {
      return Math.atan(1 / x);
    },

    'Complex': function (x) {
      return x.acot();
    },

    'BigNumber': function (x) {
      return new type.BigNumber(1).div(x).atan();
    },

    'Array | Matrix': function (x) {
      return deepMap(x, acot);
    }
  });

  acot.toTex = '\\cot^{-1}\\left(${args[0]}\\right)';

  return acot;
}

exports.name = 'acot';
exports.factory = factory;

},{"../../utils/collection/deepMap":475}],376:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {

  /**
   * Calculate the hyperbolic arccotangent of a value,
   * defined as `acoth(x) = atanh(1/x) = (ln((x+1)/x) + ln(x/(x-1))) / 2`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.acoth(x)
   *
   * Examples:
   *
   *    math.acoth(0.5);       // returns 0.8047189562170503
   *
   * See also:
   *
   *    acsch, asech
   *
   * @param {number | Complex | Array | Matrix} x  Function input
   * @return {number | Complex | Array | Matrix} Hyperbolic arccotangent of x
   */
  var acoth = typed('acoth', {
    'number': function (x) {
      if (x >= 1 || x <= -1 || config.predictable) {
        return isFinite(x) ? (Math.log((x+1)/x) + Math.log(x/(x-1))) / 2 : 0;
      }
      return new type.Complex(x, 0).acoth();
    },

    'Complex': function (x) {
      return x.acoth();
    },

    'BigNumber': function (x) {
      return new type.BigNumber(1).div(x).atanh();
    },

    'Array | Matrix': function (x) {
      return deepMap(x, acoth);
    }
  });

  acoth.toTex = '\\coth^{-1}\\left(${args[0]}\\right)';

  return acoth;
}

exports.name = 'acoth';
exports.factory = factory;

},{"../../utils/collection/deepMap":475}],377:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');


function factory (type, config, load, typed) {

  /**
   * Calculate the inverse cosecant of a value, defined as `acsc(x) = asin(1/x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.acsc(x)
   *
   * Examples:
   *
   *    math.acsc(0.5);           // returns number 0.5235987755982989
   *    math.acsc(math.csc(1.5)); // returns number ~1.5
   *
   *    math.acsc(2);             // returns Complex 1.5707963267948966 -1.3169578969248166 i
   *
   * See also:
   *
   *    csc, asin, asec
   *
   * @param {number | Complex | Array | Matrix} x   Function input
   * @return {number | Complex | Array | Matrix} The arc cosecant of x
   */
  var acsc = typed('acsc', {
    'number': function (x) {
      if (x <= -1 || x >= 1 || config.predictable) {
        return Math.asin(1 / x);
      }
      return new type.Complex(x, 0).acsc();
    },

    'Complex': function (x) {
      return x.acsc();
    },

    'BigNumber': function (x) {
      return new type.BigNumber(1).div(x).asin();
    },

    'Array | Matrix': function (x) {
      return deepMap(x, acsc);
    }
  });

  acsc.toTex = '\\csc^{-1}\\left(${args[0]}\\right)';

  return acsc;
}

exports.name = 'acsc';
exports.factory = factory;

},{"../../utils/collection/deepMap":475}],378:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {

  /**
   * Calculate the hyperbolic arccosecant of a value,
   * defined as `acsch(x) = asinh(1/x) = ln(1/x + sqrt(1/x^2 + 1))`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.acsch(x)
   *
   * Examples:
   *
   *    math.acsch(0.5);       // returns 1.4436354751788103
   *
   * See also:
   *
   *    asech, acoth
   *
   * @param {number | Complex | Array | Matrix} x  Function input
   * @return {number | Complex | Array | Matrix} Hyperbolic arccosecant of x
   */
  var acsch = typed('acsch', {
    'number': function (x) {
      x = 1 / x;
      return Math.log(x + Math.sqrt(x*x + 1));
    },

    'Complex': function (x) {
      return x.acsch();
    },

    'BigNumber': function (x) {
      return new type.BigNumber(1).div(x).asinh();
    },

    'Array | Matrix': function (x) {
      return deepMap(x, acsch);
    }
  });

  acsch.toTex = '\\mathrm{csch}^{-1}\\left(${args[0]}\\right)';

  return acsch;
}

exports.name = 'acsch';
exports.factory = factory;

},{"../../utils/collection/deepMap":475}],379:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {

  /**
   * Calculate the inverse secant of a value. Defined as `asec(x) = acos(1/x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.asec(x)
   *
   * Examples:
   *
   *    math.asec(0.5);           // returns 1.0471975511965979
   *    math.asec(math.sec(1.5)); // returns 1.5
   *
   *    math.asec(2);             // returns 0 + 1.3169578969248166 i
   *
   * See also:
   *
   *    acos, acot, acsc
   *
   * @param {number | Complex | Array | Matrix} x  Function input
   * @return {number | Complex | Array | Matrix} The arc secant of x
   */
  var asec = typed('asec', {
    'number': function (x) {
      if (x <= -1 || x >= 1 || config.predictable) {
        return Math.acos(1 / x);
      }
      return new type.Complex(x, 0).asec();
    },

    'Complex': function (x) {
      return x.asec();
    },

    'BigNumber': function (x) {
      return new type.BigNumber(1).div(x).acos();
    },

    'Array | Matrix': function (x) {
      return deepMap(x, asec);
    }
  });

  asec.toTex = '\\sec^{-1}\\left(${args[0]}\\right)';

  return asec;
}

exports.name = 'asec';
exports.factory = factory;

},{"../../utils/collection/deepMap":475}],380:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  var acosh = typed.find(load(require('./acosh')), ['Complex']);

  /**
   * Calculate the hyperbolic arcsecant of a value,
   * defined as `asech(x) = acosh(1/x) = ln(sqrt(1/x^2 - 1) + 1/x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.asech(x)
   *
   * Examples:
   *
   *    math.asech(0.5);       // returns 1.3169578969248166
   *
   * See also:
   *
   *    acsch, acoth
   *
   * @param {number | Complex | Array | Matrix} x  Function input
   * @return {number | Complex | Array | Matrix} Hyperbolic arcsecant of x
   */
  var asech = typed('asech', {
    'number': function (x) {
      if ((x <= 1 && x >= -1) || config.predictable) {
        x = 1 / x;

        var ret = Math.sqrt(x*x - 1);
        if (x > 0 || config.predictable) {
          return Math.log(ret + x);
        }

        return new type.Complex(Math.log(ret - x), Math.PI);
      }

      return new type.Complex(x, 0).asech();
    },

    'Complex': function (x) {
      return x.asech()
    },

    'BigNumber': function (x) {
      return new type.BigNumber(1).div(x).acosh();
    },

    'Array | Matrix': function (x) {
      return deepMap(x, asech);
    }
  });

  asech.toTex = '\\mathrm{sech}^{-1}\\left(${args[0]}\\right)';

  return asech;
}

exports.name = 'asech';
exports.factory = factory;

},{"../../utils/collection/deepMap":475,"./acosh":374}],381:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {

  /**
   * Calculate the inverse sine of a value.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.asin(x)
   *
   * Examples:
   *
   *    math.asin(0.5);           // returns number 0.5235987755982989
   *    math.asin(math.sin(1.5)); // returns number ~1.5
   *
   *    math.asin(2);             // returns Complex 1.5707963267948966 -1.3169578969248166 i
   *
   * See also:
   *
   *    sin, atan, acos
   *
   * @param {number | BigNumber | Complex | Array | Matrix} x   Function input
   * @return {number | BigNumber | Complex | Array | Matrix} The arc sine of x
   */
  var asin = typed('asin', {
    'number': function (x) {
      if ((x >= -1 && x <= 1) || config.predictable) {
        return Math.asin(x);
      }
      else {
        return new type.Complex(x, 0).asin();
      }
    },

    'Complex': function (x) {
      return x.asin();
    },

    'BigNumber': function (x) {
      return x.asin();
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since asin(0) = 0
      return deepMap(x, asin, true);
    }
  });

  asin.toTex = '\\sin^{-1}\\left(${args[0]}\\right)';

  return asin;
}

exports.name = 'asin';
exports.factory = factory;

},{"../../utils/collection/deepMap":475}],382:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {

  /**
   * Calculate the hyperbolic arcsine of a value,
   * defined as `asinh(x) = ln(x + sqrt(x^2 + 1))`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.asinh(x)
   *
   * Examples:
   *
   *    math.asinh(0.5);       // returns 0.48121182505960347
   *
   * See also:
   *
   *    acosh, atanh
   *
   * @param {number | Complex | Array | Matrix} x  Function input
   * @return {number | Complex | Array | Matrix} Hyperbolic arcsine of x
   */
  var asinh = typed('asinh', {
    'number': function (x) {
      return Math.log(Math.sqrt(x*x + 1) + x);
    },

    'Complex': function (x) {
        return x.asinh();
    },

    'BigNumber': function (x) {
      return x.asinh();
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since asinh(0) = 0
      return deepMap(x, asinh, true);
    }
  });

  asinh.toTex = '\\sinh^{-1}\\left(${args[0]}\\right)';

  return asinh;
}

exports.name = 'asinh';
exports.factory = factory;

},{"../../utils/collection/deepMap":475}],383:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {

  /**
   * Calculate the inverse tangent of a value.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.atan(x)
   *
   * Examples:
   *
   *    math.atan(0.5);           // returns number 0.4636476090008061
   *    math.atan(math.tan(1.5)); // returns number 1.5
   *
   *    math.atan(2);             // returns Complex 1.5707963267948966 -1.3169578969248166 i
   *
   * See also:
   *
   *    tan, asin, acos
   *
   * @param {number | BigNumber | Complex | Array | Matrix} x   Function input
   * @return {number | BigNumber | Complex | Array | Matrix} The arc tangent of x
   */
  var atan = typed('atan', {
    'number': function (x) {
      return Math.atan(x);
    },

    'Complex': function (x) {
      return x.atan();
    },

    'BigNumber': function (x) {
      return x.atan();
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since atan(0) = 0
      return deepMap(x, atan, true);
    }
  });

  atan.toTex = '\\tan^{-1}\\left(${args[0]}\\right)';

  return atan;
}

exports.name = 'atan';
exports.factory = factory;

},{"../../utils/collection/deepMap":475}],384:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {

  var matrix = load(require('../../type/matrix/function/matrix'));

  var algorithm02 = load(require('../../type/matrix/utils/algorithm02'));
  var algorithm03 = load(require('../../type/matrix/utils/algorithm03'));
  var algorithm09 = load(require('../../type/matrix/utils/algorithm09'));
  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));
  var algorithm12 = load(require('../../type/matrix/utils/algorithm12'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

  /**
   * Calculate the inverse tangent function with two arguments, y/x.
   * By providing two arguments, the right quadrant of the computed angle can be
   * determined.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.atan2(y, x)
   *
   * Examples:
   *
   *    math.atan2(2, 2) / math.pi;       // returns number 0.25
   *
   *    var angle = math.unit(60, 'deg'); // returns Unit 60 deg
   *    var x = math.cos(angle);
   *    var y = math.sin(angle);
   *
   *    math.atan(2);             // returns Complex 1.5707963267948966 -1.3169578969248166 i
   *
   * See also:
   *
   *    tan, atan, sin, cos
   *
   * @param {number | Array | Matrix} y  Second dimension
   * @param {number | Array | Matrix} x  First dimension
   * @return {number | Array | Matrix} Four-quadrant inverse tangent
   */
  var atan2 = typed('atan2', {

    'number, number': Math.atan2,

    // Complex numbers doesn't seem to have a reasonable implementation of
    // atan2(). Even Matlab removed the support, after they only calculated
    // the atan only on base of the real part of the numbers and ignored the imaginary.

    'BigNumber, BigNumber': function (y, x) {
      return type.BigNumber.atan2(y, x);
    },

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse .* sparse
              c = algorithm09(x, y, atan2, false);
              break;
            default:
              // sparse .* dense
              c = algorithm02(y, x, atan2, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense .* sparse
              c = algorithm03(x, y, atan2, false);
              break;
            default:
              // dense .* dense
              c = algorithm13(x, y, atan2);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return atan2(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return atan2(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return atan2(x, matrix(y));
    },

    'Matrix, number | BigNumber': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm11(x, y, atan2, false);
          break;
        default:
          c = algorithm14(x, y, atan2, false);
          break;
      }
      return c;
    },

    'number | BigNumber, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm12(y, x, atan2, true);
          break;
        default:
          c = algorithm14(y, x, atan2, true);
          break;
      }
      return c;
    },

    'Array, number | BigNumber': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, atan2, false).valueOf();
    },

    'number | BigNumber, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, atan2, true).valueOf();
    }
  });

  atan2.toTex = '\\mathrm{atan2}\\left(${args}\\right)';

  return atan2;
}

exports.name = 'atan2';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../type/matrix/utils/algorithm02":439,"../../type/matrix/utils/algorithm03":440,"../../type/matrix/utils/algorithm09":446,"../../type/matrix/utils/algorithm11":448,"../../type/matrix/utils/algorithm12":449,"../../type/matrix/utils/algorithm13":450,"../../type/matrix/utils/algorithm14":451}],385:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Calculate the hyperbolic arctangent of a value,
   * defined as `atanh(x) = ln((1 + x)/(1 - x)) / 2`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.atanh(x)
   *
   * Examples:
   *
   *    math.atanh(0.5);       // returns 0.5493061443340549
   *
   * See also:
   *
   *    acosh, asinh
   *
   * @param {number | Complex | Array | Matrix} x  Function input
   * @return {number | Complex | Array | Matrix} Hyperbolic arctangent of x
   */
  var atanh = typed('atanh', {
    'number': function (x) {
      if ((x <= 1 && x >= -1) || config.predictable) {
        return Math.log((1 + x)/(1 - x)) / 2;
      }
      return new type.Complex(x, 0).atanh();
    },

    'Complex': function (x) {
      return x.atanh();
    },

    'BigNumber': function (x) {
      return x.atanh();
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since atanh(0) = 0
      return deepMap(x, atanh, true);
    }
  });

  atanh.toTex = '\\tanh^{-1}\\left(${args[0]}\\right)';

  return atanh;
}

exports.name = 'atanh';
exports.factory = factory;

},{"../../utils/collection/deepMap":475}],386:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {

  /**
   * Calculate the cosine of a value.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.cos(x)
   *
   * Examples:
   *
   *    math.cos(2);                      // returns number -0.4161468365471422
   *    math.cos(math.pi / 4);            // returns number  0.7071067811865475
   *    math.cos(math.unit(180, 'deg'));  // returns number -1
   *    math.cos(math.unit(60, 'deg'));   // returns number  0.5
   *
   *    var angle = 0.2;
   *    math.pow(math.sin(angle), 2) + math.pow(math.cos(angle), 2); // returns number ~1
   *
   * See also:
   *
   *    cos, tan
   *
   * @param {number | BigNumber | Complex | Unit | Array | Matrix} x  Function input
   * @return {number | BigNumber | Complex | Array | Matrix} Cosine of x
   */
  var cos = typed('cos', {
    'number': Math.cos,

    'Complex': function (x) {
      return x.cos();
    },

    'BigNumber': function (x) {
      return x.cos();
    },

    'Unit': function (x) {
      if (!x.hasBase(type.Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function cos is no angle');
      }
      return cos(x.value);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, cos);
    }
  });

  cos.toTex = '\\cos\\left(${args[0]}\\right)';

  return cos;
}

exports.name = 'cos';
exports.factory = factory;

},{"../../utils/collection/deepMap":475}],387:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Calculate the hyperbolic cosine of a value,
   * defined as `cosh(x) = 1/2 * (exp(x) + exp(-x))`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.cosh(x)
   *
   * Examples:
   *
   *    math.cosh(0.5);       // returns number 1.1276259652063807
   *
   * See also:
   *
   *    sinh, tanh
   *
   * @param {number | BigNumber | Complex | Unit | Array | Matrix} x  Function input
   * @return {number | BigNumber | Complex | Array | Matrix} Hyperbolic cosine of x
   */
  var cosh = typed('cosh', {
    'number': _cosh,

    'Complex': function (x) {
      return x.cosh();
    },

    'BigNumber': function (x) {
      return x.cosh();
    },

    'Unit': function (x) {
      if (!x.hasBase(type.Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function cosh is no angle');
      }
      return cosh(x.value);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, cosh);
    }
  });

  cosh.toTex = '\\cosh\\left(${args[0]}\\right)';

  return cosh;
}

/**
 * Calculate the hyperbolic cosine of a number
 * @param {number} x
 * @returns {number}
 * @private
 */
function _cosh(x) {
  return (Math.exp(x) + Math.exp(-x)) / 2;
}

exports.name = 'cosh';
exports.factory = factory;

},{"../../utils/collection/deepMap":475}],388:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Calculate the cotangent of a value. Defined as `cot(x) = 1 / tan(x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.cot(x)
   *
   * Examples:
   *
   *    math.cot(2);      // returns number -0.45765755436028577
   *    1 / math.tan(2);  // returns number -0.45765755436028577
   *
   * See also:
   *
   *    tan, sec, csc
   *
   * @param {number | Complex | Unit | Array | Matrix} x  Function input
   * @return {number | Complex | Array | Matrix} Cotangent of x
   */
  var cot = typed('cot', {
    'number': function (x) {
      return 1 / Math.tan(x);
    },

    'Complex': function (x) {
      return x.cot();
    },

    'BigNumber': function (x) {
      return new type.BigNumber(1).div(x.tan());
    },

    'Unit': function (x) {
      if (!x.hasBase(type.Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function cot is no angle');
      }
      return cot(x.value);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, cot);
    }
  });

  cot.toTex = '\\cot\\left(${args[0]}\\right)';

  return cot;
}

exports.name = 'cot';
exports.factory = factory;

},{"../../utils/collection/deepMap":475}],389:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Calculate the hyperbolic cotangent of a value,
   * defined as `coth(x) = 1 / tanh(x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.coth(x)
   *
   * Examples:
   *
   *    // coth(x) = 1 / tanh(x)
   *    math.coth(2);         // returns 1.0373147207275482
   *    1 / math.tanh(2);     // returns 1.0373147207275482
   *
   * See also:
   *
   *    sinh, tanh, cosh
   *
   * @param {number | Complex | Unit | Array | Matrix} x  Function input
   * @return {number | Complex | Array | Matrix} Hyperbolic cotangent of x
   */
  var coth = typed('coth', {
    'number': _coth,

    'Complex': function (x) {
      return x.coth();
    },

    'BigNumber': function (x) {
      return new type.BigNumber(1).div(x.tanh());
    },

    'Unit': function (x) {
      if (!x.hasBase(type.Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function coth is no angle');
      }
      return coth(x.value);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, coth);
    }
  });

  coth.toTex = '\\coth\\left(${args[0]}\\right)';

  return coth;
}

/**
 * Calculate the hyperbolic cosine of a number
 * @param {number} x
 * @returns {number}
 * @private
 */
function _coth(x) {
  var e = Math.exp(2 * x);
  return (e + 1) / (e - 1);
}

exports.name = 'coth';
exports.factory = factory;

},{"../../utils/collection/deepMap":475}],390:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Calculate the cosecant of a value, defined as `csc(x) = 1/sin(x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.csc(x)
   *
   * Examples:
   *
   *    math.csc(2);      // returns number 1.099750170294617
   *    1 / math.sin(2);  // returns number 1.099750170294617
   *
   * See also:
   *
   *    sin, sec, cot
   *
   * @param {number | Complex | Unit | Array | Matrix} x  Function input
   * @return {number | Complex | Array | Matrix} Cosecant of x
   */
  var csc = typed('csc', {
    'number': function (x) {
      return 1 / Math.sin(x);
    },

    'Complex': function (x) {
      return x.csc();
    },

    'BigNumber': function (x) {
      return new type.BigNumber(1).div(x.sin());
    },

    'Unit': function (x) {
      if (!x.hasBase(type.Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function csc is no angle');
      }
      return csc(x.value);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, csc);
    }
  });

  csc.toTex = '\\csc\\left(${args[0]}\\right)';

  return csc;
}

exports.name = 'csc';
exports.factory = factory;

},{"../../utils/collection/deepMap":475}],391:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');
var sign = require('../../utils/number').sign;

function factory (type, config, load, typed) {
  /**
   * Calculate the hyperbolic cosecant of a value,
   * defined as `csch(x) = 1 / sinh(x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.csch(x)
   *
   * Examples:
   *
   *    // csch(x) = 1/ sinh(x)
   *    math.csch(0.5);       // returns 1.9190347513349437
   *    1 / math.sinh(0.5);   // returns 1.9190347513349437
   *
   * See also:
   *
   *    sinh, sech, coth
   *
   * @param {number | Complex | Unit | Array | Matrix} x  Function input
   * @return {number | Complex | Array | Matrix} Hyperbolic cosecant of x
   */
  var csch = typed('csch', {
    'number': _csch,

    'Complex': function (x) {
      return x.csch();
    },

    'BigNumber': function (x) {
      return new type.BigNumber(1).div(x.sinh());
    },

    'Unit': function (x) {
      if (!x.hasBase(type.Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function csch is no angle');
      }
      return csch(x.value);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, csch);
    }
  });

  csch.toTex = '\\mathrm{csch}\\left(${args[0]}\\right)';

  return csch;
}

/**
 * Calculate the hyperbolic cosecant of a number
 * @param {number} x
 * @returns {number}
 * @private
 */
function _csch(x) {
  // consider values close to zero (+/-)
  if (x == 0) {
    return Number.POSITIVE_INFINITY;
  }
  else {
    return Math.abs(2 / (Math.exp(x) - Math.exp(-x))) * sign(x);
  }
}

exports.name = 'csch';
exports.factory = factory;

},{"../../utils/collection/deepMap":475,"../../utils/number":483}],392:[function(require,module,exports){
module.exports = [
  require('./acos'),
  require('./acosh'),
  require('./acot'),
  require('./acoth'),
  require('./acsc'),
  require('./acsch'),
  require('./asec'),
  require('./asech'),
  require('./asin'),
  require('./asinh'),
  require('./atan'),
  require('./atan2'),
  require('./atanh'),
  require('./cos'),
  require('./cosh'),
  require('./cot'),
  require('./coth'),
  require('./csc'),
  require('./csch'),
  require('./sec'),
  require('./sech'),
  require('./sin'),
  require('./sinh'),
  require('./tan'),
  require('./tanh')
];

},{"./acos":373,"./acosh":374,"./acot":375,"./acoth":376,"./acsc":377,"./acsch":378,"./asec":379,"./asech":380,"./asin":381,"./asinh":382,"./atan":383,"./atan2":384,"./atanh":385,"./cos":386,"./cosh":387,"./cot":388,"./coth":389,"./csc":390,"./csch":391,"./sec":393,"./sech":394,"./sin":395,"./sinh":396,"./tan":397,"./tanh":398}],393:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Calculate the secant of a value, defined as `sec(x) = 1/cos(x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.sec(x)
   *
   * Examples:
   *
   *    math.sec(2);      // returns number -2.4029979617223822
   *    1 / math.cos(2);  // returns number -2.4029979617223822
   *
   * See also:
   *
   *    cos, csc, cot
   *
   * @param {number | Complex | Unit | Array | Matrix} x  Function input
   * @return {number | Complex | Array | Matrix} Secant of x
   */
  var sec = typed('sec', {
    'number': function (x) {
      return 1 / Math.cos(x);
    },

    'Complex': function (x) {
      return x.sec();
    },

    'BigNumber': function (x) {
      return new type.BigNumber(1).div(x.cos());
    },

    'Unit': function (x) {
      if (!x.hasBase(type.Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function sec is no angle');
      }
      return sec(x.value);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, sec);
    }
  });

  sec.toTex = '\\sec\\left(${args[0]}\\right)';

  return sec;
}

exports.name = 'sec';
exports.factory = factory;

},{"../../utils/collection/deepMap":475}],394:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Calculate the hyperbolic secant of a value,
   * defined as `sech(x) = 1 / cosh(x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.sech(x)
   *
   * Examples:
   *
   *    // sech(x) = 1/ cosh(x)
   *    math.sech(0.5);       // returns 0.886818883970074
   *    1 / math.cosh(0.5);   // returns 0.886818883970074
   *
   * See also:
   *
   *    cosh, csch, coth
   *
   * @param {number | Complex | Unit | Array | Matrix} x  Function input
   * @return {number | Complex | Array | Matrix} Hyperbolic secant of x
   */
  var sech = typed('sech', {
    'number': _sech,

    'Complex': function (x) {
      return x.sech();
    },

    'BigNumber': function (x) {
      return new type.BigNumber(1).div(x.cosh());
    },

    'Unit': function (x) {
      if (!x.hasBase(type.Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function sech is no angle');
      }
      return sech(x.value);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, sech);
    }
  });

  sech.toTex = '\\mathrm{sech}\\left(${args[0]}\\right)';

  return sech;
}

/**
 * Calculate the hyperbolic secant of a number
 * @param {number} x
 * @returns {number}
 * @private
 */
function _sech(x) {
  return 2 / (Math.exp(x) + Math.exp(-x));
}

exports.name = 'sech';
exports.factory = factory;

},{"../../utils/collection/deepMap":475}],395:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {

  /**
   * Calculate the sine of a value.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.sin(x)
   *
   * Examples:
   *
   *    math.sin(2);                      // returns number 0.9092974268256813
   *    math.sin(math.pi / 4);            // returns number 0.7071067811865475
   *    math.sin(math.unit(90, 'deg'));   // returns number 1
   *    math.sin(math.unit(30, 'deg'));   // returns number 0.5
   *
   *    var angle = 0.2;
   *    math.pow(math.sin(angle), 2) + math.pow(math.cos(angle), 2); // returns number ~1
   *
   * See also:
   *
   *    cos, tan
   *
   * @param {number | BigNumber | Complex | Unit | Array | Matrix} x  Function input
   * @return {number | BigNumber | Complex | Array | Matrix} Sine of x
   */
  var sin = typed('sin', {
    'number': Math.sin,

    'Complex': function (x) {
      return x.sin();
    },

    'BigNumber': function (x) {
      return x.sin();
    },

    'Unit': function (x) {
      if (!x.hasBase(type.Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function sin is no angle');
      }
      return sin(x.value);
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since sin(0) = 0
      return deepMap(x, sin, true);
    }
  });

  sin.toTex = '\\sin\\left(${args[0]}\\right)';

  return sin;
}

exports.name = 'sin';
exports.factory = factory;

},{"../../utils/collection/deepMap":475}],396:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Calculate the hyperbolic sine of a value,
   * defined as `sinh(x) = 1/2 * (exp(x) - exp(-x))`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.sinh(x)
   *
   * Examples:
   *
   *    math.sinh(0.5);       // returns number 0.5210953054937474
   *
   * See also:
   *
   *    cosh, tanh
   *
   * @param {number | BigNumber | Complex | Unit | Array | Matrix} x  Function input
   * @return {number | BigNumber | Complex | Array | Matrix} Hyperbolic sine of x
   */
  var sinh = typed('sinh', {
    'number': _sinh,

    'Complex': function (x) {
      return x.sinh();
    },

    'BigNumber': function (x) {
      return x.sinh();
    },

    'Unit': function (x) {
      if (!x.hasBase(type.Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function sinh is no angle');
      }
      return sinh(x.value);
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since sinh(0) = 0
      return deepMap(x, sinh, true);
    }
  });

  sinh.toTex = '\\sinh\\left(${args[0]}\\right)';

  return sinh;
}

/**
 * Calculate the hyperbolic sine of a number
 * @param {number} x
 * @returns {number}
 * @private
 */
function _sinh (x) {
  if (Math.abs(x) < 1) {
    return x + (x * x * x) / 6 + (x * x * x * x * x) / 120;
  } else {
    return (Math.exp(x) - Math.exp(-x)) / 2;
  }
}

exports.name = 'sinh';
exports.factory = factory;

},{"../../utils/collection/deepMap":475}],397:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Calculate the tangent of a value. `tan(x)` is equal to `sin(x) / cos(x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.tan(x)
   *
   * Examples:
   *
   *    math.tan(0.5);                    // returns number 0.5463024898437905
   *    math.sin(0.5) / math.cos(0.5);    // returns number 0.5463024898437905
   *    math.tan(math.pi / 4);            // returns number 1
   *    math.tan(math.unit(45, 'deg'));   // returns number 1
   *
   * See also:
   *
   *    atan, sin, cos
   *
   * @param {number | BigNumber | Complex | Unit | Array | Matrix} x  Function input
   * @return {number | BigNumber | Complex | Array | Matrix} Tangent of x
   */
  var tan = typed('tan', {
    'number': Math.tan,

    'Complex': function (x) {
        return x.tan();
    },

    'BigNumber': function (x) {
      return x.tan();
    },

    'Unit': function (x) {
      if (!x.hasBase(type.Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function tan is no angle');
      }
      return tan(x.value);
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since tan(0) = 0
      return deepMap(x, tan, true);
    }
  });

  tan.toTex = '\\tan\\left(${args[0]}\\right)';

  return tan;
}

exports.name = 'tan';
exports.factory = factory;

},{"../../utils/collection/deepMap":475}],398:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Calculate the hyperbolic tangent of a value,
   * defined as `tanh(x) = (exp(2 * x) - 1) / (exp(2 * x) + 1)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.tanh(x)
   *
   * Examples:
   *
   *    // tanh(x) = sinh(x) / cosh(x) = 1 / coth(x)
   *    math.tanh(0.5);                   // returns 0.46211715726000974
   *    math.sinh(0.5) / math.cosh(0.5);  // returns 0.46211715726000974
   *    1 / math.coth(0.5);               // returns 0.46211715726000974
   *
   * See also:
   *
   *    sinh, cosh, coth
   *
   * @param {number | BigNumber | Complex | Unit | Array | Matrix} x  Function input
   * @return {number | BigNumber | Complex | Array | Matrix} Hyperbolic tangent of x
   */
  var tanh = typed('tanh', {
    'number': _tanh,

    'Complex': function (x) {
        return x.tanh();
    },

    'BigNumber': function (x) {
      return x.tanh();
    },

    'Unit': function (x) {
      if (!x.hasBase(type.Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function tanh is no angle');
      }
      return tanh(x.value);
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since tanh(0) = 0
      return deepMap(x, tanh, true);
    }
  });

  tanh.toTex = '\\tanh\\left(${args[0]}\\right)';

  return tanh;
}

/**
 * Calculate the hyperbolic tangent of a number
 * @param {number} x
 * @returns {number}
 * @private
 */
function _tanh (x) {
  var e = Math.exp(2 * x);
  return (e - 1) / (e + 1);
}

exports.name = 'tanh';
exports.factory = factory;

},{"../../utils/collection/deepMap":475}],399:[function(require,module,exports){
module.exports = [
  require('./to')
];
},{"./to":400}],400:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  var latex = require('../../utils/latex');

  var matrix = load(require('../../type/matrix/function/matrix'));

  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

  /**
   * Change the unit of a value.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.to(x, unit)
   *
   * Examples:
   *
   *    math.to(math.unit('2 inch'), 'cm');                   // returns Unit 5.08 cm
   *    math.to(math.unit('2 inch'), math.unit(null, 'cm'));  // returns Unit 5.08 cm
   *    math.to(math.unit(16, 'bytes'), 'bits');              // returns Unit 128 bits
   *
   * See also:
   *
   *    unit
   *
   * @param {Unit | Array | Matrix} x     The unit to be converted.
   * @param {Unit | Array | Matrix} unit  New unit. Can be a string like "cm"
   *                                      or a unit without value.
   * @return {Unit | Array | Matrix} value with changed, fixed unit.
   */
  var to = typed('to', {

    'Unit, Unit | string': function (x, unit) {
      return x.to(unit);
    },

    'Matrix, Matrix': function (x, y) {
      // SparseMatrix does not support Units
      return algorithm13(x, y, to);
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return to(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return to(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return to(x, matrix(y));
    },

    'Matrix, any': function (x, y) {
      // SparseMatrix does not support Units
      return algorithm14(x, y, to, false);
    },

    'any, Matrix': function (x, y) {
      // SparseMatrix does not support Units
      return algorithm14(y, x, to, true);
    },

    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, to, false).valueOf();
    },

    'any, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, to, true).valueOf();
    }
  });

  to.toTex = '\\left(${args[0]}' + latex.operators['to'] + '${args[1]}\\right)';

  return to;
}

exports.name = 'to';
exports.factory = factory;

},{"../../type/matrix/function/matrix":435,"../../type/matrix/utils/algorithm13":450,"../../type/matrix/utils/algorithm14":451,"../../utils/latex":482}],401:[function(require,module,exports){
'use strict';

var object= require('../../utils/object');

function factory (type, config, load, typed) {
  /**
   * Clone an object.
   *
   * Syntax:
   *
   *     math.clone(x)
   *
   * Examples:
   *
   *    math.clone(3.5);                   // returns number 3.5
   *    math.clone(math.complex('2-4i'); // returns Complex 2 - 4i
   *    math.clone(math.unit(45, 'deg'));  // returns Unit 45 deg
   *    math.clone([[1, 2], [3, 4]]);      // returns Array [[1, 2], [3, 4]]
   *    math.clone("hello world");         // returns string "hello world"
   *
   * @param {*} x   Object to be cloned
   * @return {*} A clone of object x
   */
  var clone = typed('clone', {
    'any': object.clone
  });

  clone.toTex = '\\mathrm{${name}}\\left(${args}\\right)';

  return clone;
}

exports.name = 'clone';
exports.factory = factory;

},{"../../utils/object":484}],402:[function(require,module,exports){
module.exports = [
  require('./clone'),
  require('./isInteger'),
  require('./isNegative'),
  require('./isNumeric'),
  require('./isPositive'),
  require('./isZero'),
  require('./typeof')
];

},{"./clone":401,"./isInteger":403,"./isNegative":404,"./isNumeric":405,"./isPositive":406,"./isZero":407,"./typeof":408}],403:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');
var number = require('../../utils/number');

function factory (type, config, load, typed) {
  /**
   * Test whether a value is an integer number.
   * The function supports `number`, `BigNumber`, and `Fraction`.
   *
   * The function is evaluated element-wise in case of Array or Matrix input.
   *
   * Syntax:
   *
   *     math.isInteger(x)
   *
   * Examples:
   *
   *    math.isInteger(2);                     // returns true
   *    math.isInteger(0);                     // returns true
   *    math.isInteger(0.5);                   // returns false
   *    math.isInteger(math.bignumber(500));   // returns true
   *    math.isInteger(math.fraction(4));      // returns true
   *    math.isInteger('3');                   // returns true
   *    math.isInteger([3, 0.5, -2]);          // returns [true, false, true]
   *    math.isInteger(math.complex('2-4i');   // throws an error
   *
   * See also:
   *
   *    isNumeric, isPositive, isNegative, isZero
   *
   * @param {number | BigNumber | Fraction | Array | Matrix} x   Value to be tested
   * @return {boolean}  Returns true when `x` contains a numeric, integer value.
   *                    Throws an error in case of an unknown data type.
   */
  var isInteger = typed('isInteger', {
    'number': number.isInteger, // TODO: what to do with isInteger(add(0.1, 0.2))  ?

    'BigNumber': function (x) {
      return x.isInt();
    },

    'Fraction': function (x) {
      return x.d === 1 && isFinite(x.n);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, isInteger);
    }
  });

  return isInteger;
}

exports.name = 'isInteger';
exports.factory = factory;

},{"../../utils/collection/deepMap":475,"../../utils/number":483}],404:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');
var number = require('../../utils/number');

function factory (type, config, load, typed) {
  /**
   * Test whether a value is negative: smaller than zero.
   * The function supports types `number`, `BigNumber`, `Fraction`, and `Unit`.
   *
   * The function is evaluated element-wise in case of Array or Matrix input.
   *
   * Syntax:
   *
   *     math.isNegative(x)
   *
   * Examples:
   *
   *    math.isNegative(3);                     // returns false
   *    math.isNegative(-2);                    // returns true
   *    math.isNegative(0);                     // returns false
   *    math.isNegative(-0);                    // returns false
   *    math.isNegative(math.bignumber(2));     // returns false
   *    math.isNegative(math.fraction(-2, 5));  // returns true
   *    math.isNegative('-2');                  // returns true
   *    math.isNegative([2, 0, -3]');           // returns [false, false, true]
   *
   * See also:
   *
   *    isNumeric, isPositive, isZero, isInteger
   *
   * @param {number | BigNumber | Fraction | Unit | Array | Matrix} x  Value to be tested
   * @return {boolean}  Returns true when `x` is larger than zero.
   *                    Throws an error in case of an unknown data type.
   */
  var isNegative = typed('isNegative', {
    'number': function (x) {
      return x < 0;
    },

    'BigNumber': function (x) {
      return x.isNeg() && !x.isZero() && !x.isNaN();
    },

    'Fraction': function (x) {
      return x.s < 0; // It's enough to decide on the sign
    },

    'Unit': function (x) {
      return isNegative(x.value);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, isNegative);
    }
  });

  return isNegative;
}

exports.name = 'isNegative';
exports.factory = factory;

},{"../../utils/collection/deepMap":475,"../../utils/number":483}],405:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');
var number = require('../../utils/number');

function factory (type, config, load, typed) {
  /**
   * Test whether a value is an numeric value.
   *
   * The function is evaluated element-wise in case of Array or Matrix input.
   *
   * Syntax:
   *
   *     math.isNumeric(x)
   *
   * Examples:
   *
   *    math.isNumeric(2);                     // returns true
   *    math.isNumeric(0);                     // returns true
   *    math.isNumeric(math.bignumber(500));   // returns true
   *    math.isNumeric(math.fraction(4));      // returns true
   *    math.isNumeric(math.complex('2-4i');   // returns false
   *    math.isNumeric('3');                   // returns false
   *    math.isNumeric([2.3, 'foo', false]);   // returns [true, false, true]
   *
   * See also:
   *
   *    isZero, isPositive, isNegative, isInteger
   *
   * @param {*} x       Value to be tested
   * @return {boolean}  Returns true when `x` is a `number`, `BigNumber`,
   *                    `Fraction`, or `boolean`. Returns false for other types.
   *                    Throws an error in case of unknown types.
   */
  var isNumeric = typed('isNumeric', {
    'number | BigNumber | Fraction | boolean': function () {
      return true;
    },

    'Complex | Unit | string': function () {
      return false;
    },

    'Array | Matrix': function (x) {
      return deepMap(x, isNumeric);
    }
  });

  return isNumeric;
}

exports.name = 'isNumeric';
exports.factory = factory;

},{"../../utils/collection/deepMap":475,"../../utils/number":483}],406:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');
var number = require('../../utils/number');

function factory (type, config, load, typed) {
  /**
   * Test whether a value is positive: larger than zero.
   * The function supports types `number`, `BigNumber`, `Fraction`, and `Unit`.
   *
   * The function is evaluated element-wise in case of Array or Matrix input.
   *
   * Syntax:
   *
   *     math.isPositive(x)
   *
   * Examples:
   *
   *    math.isPositive(3);                     // returns true
   *    math.isPositive(-2);                    // returns false
   *    math.isPositive(0);                     // returns false
   *    math.isPositive(-0);                    // returns false
   *    math.isPositive(0.5);                   // returns true
   *    math.isPositive(math.bignumber(2));     // returns true
   *    math.isPositive(math.fraction(-2, 5));  // returns false
   *    math.isPositive(math.fraction(1,3));    // returns false
   *    math.isPositive('2');                   // returns true
   *    math.isPositive([2, 0, -3]');           // returns [true, false, false]
   *
   * See also:
   *
   *    isNumeric, isZero, isNegative, isInteger
   *
   * @param {number | BigNumber | Fraction | Unit | Array | Matrix} x  Value to be tested
   * @return {boolean}  Returns true when `x` is larger than zero.
   *                    Throws an error in case of an unknown data type.
   */
  var isPositive = typed('isPositive', {
    'number': function (x) {
      return x > 0;
    },

    'BigNumber': function (x) {
      return !x.isNeg() && !x.isZero() && !x.isNaN();
    },

    'Fraction': function (x) {
      return x.s > 0 && x.n > 0;
    },

    'Unit': function (x) {
      return isPositive(x.value);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, isPositive);
    }
  });

  return isPositive;
}

exports.name = 'isPositive';
exports.factory = factory;

},{"../../utils/collection/deepMap":475,"../../utils/number":483}],407:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');
var number = require('../../utils/number');

function factory (type, config, load, typed) {
  /**
   * Test whether a value is zero.
   * The function can check for zero for types `number`, `BigNumber`, `Fraction`,
   * `Complex`, and `Unit`.
   *
   * The function is evaluated element-wise in case of Array or Matrix input.
   *
   * Syntax:
   *
   *     math.isZero(x)
   *
   * Examples:
   *
   *    math.isZero(0);                     // returns true
   *    math.isZero(2);                     // returns false
   *    math.isZero(0.5);                   // returns false
   *    math.isZero(math.bignumber(0));     // returns true
   *    math.isZero(math.fraction(0));      // returns true
   *    math.isZero(math.fraction(1,3));    // returns false
   *    math.isZero(math.complex('2 - 4i'); // returns false
   *    math.isZero(math.complex('0i');     // returns true
   *    math.isZero('0');                   // returns true
   *    math.isZero('2');                   // returns false
   *    math.isZero([2, 0, -3]');           // returns [false, true, false]
   *
   * See also:
   *
   *    isNumeric, isPositive, isNegative, isInteger
   *
   * @param {number | BigNumber | Complex | Fraction | Unit | Array | Matrix} x       Value to be tested
   * @return {boolean}  Returns true when `x` is zero.
   *                    Throws an error in case of an unknown data type.
   */
  var isZero = typed('isZero', {
    'number': function (x) {
      return x === 0;
    },

    'BigNumber': function (x) {
      return x.isZero();
    },

    'Complex': function (x) {
      return x.re === 0 && x.im === 0;
    },

    'Fraction': function (x) {
      return x.d === 1 && x.n === 0;
    },

    'Unit': function (x) {
      return isZero(x.value);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, isZero);
    }
  });

  return isZero;
}

exports.name = 'isZero';
exports.factory = factory;

},{"../../utils/collection/deepMap":475,"../../utils/number":483}],408:[function(require,module,exports){
'use strict';

var types = require('../../utils/types');

function factory (type, config, load, typed) {
  /**
   * Determine the type of a variable.
   *
   * Function `typeof` recognizes the following types of objects:
   *
   * Object                 | Returns       | Example
   * ---------------------- | ------------- | ------------------------------------------
   * null                   | `'null'`      | `math.typeof(null)`
   * number                 | `'number'`    | `math.typeof(3.5)`
   * boolean                | `'boolean'`   | `math.typeof (true)`
   * string                 | `'string'`    | `math.typeof ('hello world')`
   * Array                  | `'Array'`     | `math.typeof ([1, 2, 3])`
   * Date                   | `'Date'`      | `math.typeof (new Date())`
   * Function               | `'Function'`  | `math.typeof (function () {})`
   * Object                 | `'Object'`    | `math.typeof ({a: 2, b: 3})`
   * RegExp                 | `'RegExp'`    | `math.typeof (/a regexp/)`
   * undefined              | `'undefined'` | `math.typeof(undefined)`
   * math.type.BigNumber    | `'BigNumber'` | `math.typeof (math.bignumber('2.3e500'))`
   * math.type.Chain        | `'Chain'`     | `math.typeof (math.chain(2))`
   * math.type.Complex      | `'Complex'`   | `math.typeof (math.complex(2, 3))`
   * math.type.Fraction     | `'Fraction'`  | `math.typeof (math.fraction(1, 3))`
   * math.type.Help         | `'Help'`      | `math.typeof (math.help('sqrt'))`
   * math.type.Index        | `'Index'`     | `math.typeof (math.index(1, 3))`
   * math.type.Matrix       | `'Matrix'`    | `math.typeof (math.matrix([[1,2], [3, 4]]))`
   * math.type.Range        | `'Range'`     | `math.typeof (math.range(0, 10))`
   * math.type.Unit         | `'Unit'`      | `math.typeof (math.unit('45 deg'))`
   *
   * Syntax:
   *
   *    math.typeof(x)
   *
   * Examples:
   *
   *    math.typeof(3.5);                     // returns 'number'
   *    math.typeof(math.complex('2-4i'));    // returns 'Complex'
   *    math.typeof(math.unit('45 deg'));     // returns 'Unit'
   *    math.typeof('hello world');           // returns 'string'
   *
   * @param {*} x     The variable for which to test the type.
   * @return {string} Returns the name of the type. Primitive types are lower case,
   *                  non-primitive types are upper-camel-case.
   *                  For example 'number', 'string', 'Array', 'Date'.
   */
  var _typeof = typed('_typeof', {
    'any': function (x) {
      // JavaScript types
      var t = types.type(x);

      // math.js types
      if (t === 'Object') {
        if (x.isBigNumber === true) return 'BigNumber';
        if (x.isComplex === true)   return 'Complex';
        if (x.isFraction === true)  return 'Fraction';
        if (x.isMatrix === true)    return 'Matrix';
        if (x.isUnit === true)      return 'Unit';
        if (x.isIndex === true)     return 'Index';
        if (x.isRange === true)     return 'Range';
        if (x.isChain === true)     return 'Chain';
        if (x.isHelp === true)      return 'Help';
      }

      return t;
    }
  });

  _typeof.toTex = '\\mathrm{${name}}\\left(${args}\\right)';

  return _typeof;
}

exports.name = 'typeof';
exports.factory = factory;

},{"../../utils/types":486}],409:[function(require,module,exports){
module.exports = [
  require('./type'),        // data types (Matrix, Complex, Unit, ...)
  require('./constants'),   // constants
  require('./expression'),  // expression parsing
  require('./function'),    // functions
  require('./json'),        // serialization utility (math.json.reviver)
  require('./error')        // errors
];

},{"./constants":5,"./error":13,"./expression":194,"./function":309,"./json":410,"./type":425}],410:[function(require,module,exports){
module.exports = [
  require('./reviver')
];

},{"./reviver":411}],411:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  /**
   * Instantiate mathjs data types from their JSON representation
   * @param {string} key
   * @param {*} value
   * @returns {*} Returns the revived object
   */
  return function reviver(key, value) {
    var constructor = type[value && value.mathjs];
    if (constructor && typeof constructor.fromJSON === 'function') {
      return constructor.fromJSON(value);
    }

    return value;
  }
}

exports.name = 'reviver';
exports.path = 'json';
exports.factory = factory;

},{}],412:[function(require,module,exports){
var Decimal = require('decimal.js');

function factory (type, config, load, typed, math) {
  var BigNumber = Decimal.clone({precision: config.precision});

  /**
   * Attach type information
   */
  BigNumber.prototype.type = 'BigNumber';
  BigNumber.prototype.isBigNumber = true;

  /**
   * Get a JSON representation of a BigNumber containing
   * type information
   * @returns {Object} Returns a JSON object structured as:
   *                   `{"mathjs": "BigNumber", "value": "0.2"}`
   */
  BigNumber.prototype.toJSON = function () {
    return {
      mathjs: 'BigNumber',
      value: this.toString()
    };
  };

  /**
   * Instantiate a BigNumber from a JSON object
   * @param {Object} json  a JSON object structured as:
   *                       `{"mathjs": "BigNumber", "value": "0.2"}`
   * @return {BigNumber}
   */
  BigNumber.fromJSON = function (json) {
    return new BigNumber(json.value);
  };

  // listen for changed in the configuration, automatically apply changed precision
  math.on('config', function (curr, prev) {
    if (curr.precision !== prev.precision) {
      BigNumber.config({ precision: curr.precision });
    }
  });

  return BigNumber;
}

exports.name = 'BigNumber';
exports.path = 'type';
exports.factory = factory;
exports.math = true; // request access to the math namespace
},{"decimal.js":489}],413:[function(require,module,exports){
'use strict';

var deepMap = require('../../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Create a BigNumber, which can store numbers with arbitrary precision.
   * When a matrix is provided, all elements will be converted to BigNumber.
   *
   * Syntax:
   *
   *    math.bignumber(x)
   *
   * Examples:
   *
   *    0.1 + 0.2;                                  // returns number 0.30000000000000004
   *    math.bignumber(0.1) + math.bignumber(0.2);  // returns BigNumber 0.3
   *
   *
   *    7.2e500;                                    // returns number Infinity
   *    math.bignumber('7.2e500');                  // returns BigNumber 7.2e500
   *
   * See also:
   *
   *    boolean, complex, index, matrix, string, unit
   *
   * @param {number | string | Fraction | BigNumber | Array | Matrix | boolean | null} [value]  Value for the big number,
   *                                                    0 by default.
   * @returns {BigNumber} The created bignumber
   */
  var bignumber = typed('bignumber', {
    '': function () {
      return new type.BigNumber(0);
    },

    'number': function (x) {
      // convert to string to prevent errors in case of >15 digits
      return new type.BigNumber(x + '');
    },

    'string': function (x) {
      return new type.BigNumber(x);
    },

    'BigNumber': function (x) {
      // we assume a BigNumber is immutable
      return x;
    },

    'Fraction': function (x) {
      return new type.BigNumber(x.n).div(x.d);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, bignumber);
    }
  });

  bignumber.toTex = {
    0: '0',
    1: '\\left(${args[0]}\\right)'
  };

  return bignumber;
}

exports.name = 'bignumber';
exports.factory = factory;

},{"../../../utils/collection/deepMap":475}],414:[function(require,module,exports){
module.exports = [
  // type
  require('./BigNumber'),

  // construction function
  require('./function/bignumber')
];

},{"./BigNumber":412,"./function/bignumber":413}],415:[function(require,module,exports){
'use strict';

var deepMap = require('./../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Create a boolean or convert a string or number to a boolean.
   * In case of a number, `true` is returned for non-zero numbers, and `false` in
   * case of zero.
   * Strings can be `'true'` or `'false'`, or can contain a number.
   * When value is a matrix, all elements will be converted to boolean.
   *
   * Syntax:
   *
   *    math.boolean(x)
   *
   * Examples:
   *
   *    math.boolean(0);     // returns false
   *    math.boolean(1);     // returns true
   *    math.boolean(-3);     // returns true
   *    math.boolean('true');     // returns true
   *    math.boolean('false');     // returns false
   *    math.boolean([1, 0, 1, 1]);     // returns [true, false, true, true]
   *
   * See also:
   *
   *    bignumber, complex, index, matrix, string, unit
   *
   * @param {string | number | boolean | Array | Matrix | null} value  A value of any type
   * @return {boolean | Array | Matrix} The boolean value
   */
  var bool = typed('bool', {
    '': function () {
      return false;
    },

    'boolean': function (x) {
      return x;
    },

    'number': function (x) {
      return !!x;
    },

    'BigNumber': function (x) {
      return !x.isZero();
    },

    'string': function (x) {
      // try case insensitive
      var lcase = x.toLowerCase();
      if (lcase === 'true') {
        return true;
      }
      else if (lcase === 'false') {
        return false;
      }

      // test whether value is a valid number
      var num = Number(x);
      if (x != '' && !isNaN(num)) {
        return !!num;
      }

      throw new Error('Cannot convert "' + x + '" to a boolean');
    },

    'Array | Matrix': function (x) {
      return deepMap(x, bool);
    }
  });

  return bool;
}

exports.name = 'boolean';
exports.factory = factory;

},{"./../utils/collection/deepMap":475}],416:[function(require,module,exports){
'use strict';

var format = require('../../utils/string').format;
var lazy = require('../../utils/object').lazy;

function factory (type, config, load, typed, math) {
  /**
   * @constructor Chain
   * Wrap any value in a chain, allowing to perform chained operations on
   * the value.
   *
   * All methods available in the math.js library can be called upon the chain,
   * and then will be evaluated with the value itself as first argument.
   * The chain can be closed by executing chain.done(), which will return
   * the final value.
   *
   * The Chain has a number of special functions:
   * - done()             Finalize the chained operation and return the
   *                      chain's value.
   * - valueOf()          The same as done()
   * - toString()         Returns a string representation of the chain's value.
   *
   * @param {*} [value]
   */
  function Chain (value) {
    if (!(this instanceof Chain)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    if (value && value.isChain) {
      this.value = value.value;
    }
    else {
      this.value = value;
    }
  }

  /**
   * Attach type information
   */
  Chain.prototype.type = 'Chain';
  Chain.prototype.isChain = true;

  /**
   * Close the chain. Returns the final value.
   * Does the same as method valueOf()
   * @returns {*} value
   */
  Chain.prototype.done = function () {
    return this.value;
  };

  /**
   * Close the chain. Returns the final value.
   * Does the same as method done()
   * @returns {*} value
   */
  Chain.prototype.valueOf = function () {
    return this.value;
  };

  /**
   * Get a string representation of the value in the chain
   * @returns {string}
   */
  Chain.prototype.toString = function () {
    return format(this.value);
  };

  /**
   * Create a proxy method for the chain
   * @param {string} name
   * @param {Function} fn      The function to be proxied
   *                           If fn is no function, it is silently ignored.
   * @private
   */
  function createProxy(name, fn) {
    if (typeof fn === 'function') {
      Chain.prototype[name] = chainify(fn);
    }
  }

  /**
   * Create a proxy method for the chain
   * @param {string} name
   * @param {function} resolver   The function resolving with the
   *                              function to be proxied
   * @private
   */
  function createLazyProxy(name, resolver) {
    lazy(Chain.prototype, name, function outerResolver() {
      var fn = resolver();
      if (typeof fn === 'function') {
        return chainify(fn);
      }

      return undefined; // if not a function, ignore
    });
  }

  /**
   * Make a function chainable
   * @param {function} fn
   * @return {Function} chain function
   * @private
   */
  function chainify (fn) {
    return function () {
      var args = [this.value];  // `this` will be the context of a Chain instance
      for (var i = 0; i < arguments.length; i++) {
        args[i + 1] = arguments[i];
      }

      return new Chain(fn.apply(fn, args));
    }
  }

  /**
   * Create a proxy for a single method, or an object with multiple methods.
   * Example usage:
   *
   *   Chain.createProxy('add', function add (x, y) {...});
   *   Chain.createProxy({
   *     add:      function add (x, y) {...},
   *     subtract: function subtract (x, y) {...}
   *   }
   *
   * @param {string | Object} arg0   A name (string), or an object with
   *                                 functions
   * @param {*} [arg1]               A function, when arg0 is a name
   */
  Chain.createProxy = function (arg0, arg1) {
    if (typeof arg0 === 'string') {
      // createProxy(name, value)
      createProxy(arg0, arg1);
    }
    else {
      // createProxy(values)
      for (var prop in arg0) {
        if (arg0.hasOwnProperty(prop)) {
          createProxy(prop, arg0[prop]);
        }
      }
    }
  };

  // create proxy for everything that is in math.js
  Chain.createProxy(math);

  // register on the import event, automatically add a proxy for every imported function.
  math.on('import', function (name, resolver, path) {
    if (path === undefined) {
      // an imported function (not a data type or something special)
      createLazyProxy(name, resolver);
    }
  });

  return Chain;
}

exports.name = 'Chain';
exports.path = 'type';
exports.factory = factory;
exports.math = true;  // require providing the math namespace as 5th argument
exports.lazy = false; // we need to register a listener on the import events, so no lazy loading

},{"../../utils/object":484,"../../utils/string":485}],417:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  /**
   * Wrap any value in a chain, allowing to perform chained operations on
   * the value.
   *
   * All methods available in the math.js library can be called upon the chain,
   * and then will be evaluated with the value itself as first argument.
   * The chain can be closed by executing `chain.done()`, which returns
   * the final value.
   *
   * The chain has a number of special functions:
   *
   * - `done()`     Finalize the chain and return the chain's value.
   * - `valueOf()`  The same as `done()`
   * - `toString()` Executes `math.format()` onto the chain's value, returning
   *                a string representation of the value.
   *
   * Syntax:
   *
   *    math.chain(value)
   *
   * Examples:
   *
   *     math.chain(3)
   *         .add(4)
   *         .subtract(2)
   *         .done();     // 5
   *
   *     math.chain( [[1, 2], [3, 4]] )
   *         .subset(math.index(0, 0), 8)
   *         .multiply(3)
   *         .done();     // [[24, 6], [9, 12]]
   *
   * @param {*} [value]   A value of any type on which to start a chained operation.
   * @return {math.type.Chain} The created chain
   */
  return typed('chain', {
    '': function() {
      return new type.Chain();
    },

    'any': function(value) {
      return new type.Chain(value);
    }
  });
}

exports.name = 'chain';
exports.factory = factory;

},{}],418:[function(require,module,exports){
module.exports = [
  // type
  require('./Chain'),

  // construction function
  require('./function/chain')
];

},{"./Chain":416,"./function/chain":417}],419:[function(require,module,exports){
var Complex = require('complex.js');
var format = require('../../utils/number').format;
var isNumber = require('../../utils/number').isNumber;

function factory (type, config, load, typed, math) {

  /**
   * Attach type information
   */
  Complex.prototype.type = 'Complex';
  Complex.prototype.isComplex = true;


  /**
   * Get a JSON representation of the complex number
   * @returns {Object} Returns a JSON object structured as:
   *                   `{"mathjs": "Complex", "re": 2, "im": 3}`
   */
  Complex.prototype.toJSON = function () {
    return {
      mathjs: 'Complex',
      re: this.re,
      im: this.im
    };
  };

  /*
   * Return the value of the complex number in polar notation
   * The angle phi will be set in the interval of [-pi, pi].
   * @return {{r: number, phi: number}} Returns and object with properties r and phi.
   */
  Complex.prototype.toPolar = function () {
    return {
      r: this.abs(),
      phi: this.arg()
    };
  };

  /**
   * Get a string representation of the complex number,
   * with optional formatting options.
   * @param {Object | number | Function} [options]  Formatting options. See
   *                                                lib/utils/number:format for a
   *                                                description of the available
   *                                                options.
   * @return {string} str
   */
  Complex.prototype.format = function (options) {
    var str = '';
    var im = this.im;
    var re = this.re;
    var strRe = format(this.re, options);
    var strIm = format(this.im, options);

    // round either re or im when smaller than the configured precision
    var precision = isNumber(options) ? options : options ? options.precision : null;
    if (precision !== null) {
      var epsilon = Math.pow(10, -precision);
      if (Math.abs(re / im) < epsilon) {
        re = 0;
      }
      if (Math.abs(im / re) < epsilon) {
        im = 0;
      }
    }

    if (im == 0) {
      // real value
      str = strRe;
    } else if (re == 0) {
      // purely complex value
      if (im == 1) {
        str = 'i';
      } else if (im == -1) {
        str = '-i';
      } else {
        str = strIm + 'i';
      }
    } else {
      // complex value
      if (im > 0) {
        if (im == 1) {
          str = strRe + ' + i';
        } else {
          str = strRe + ' + ' + strIm + 'i';
        }
      } else {
        if (im == -1) {
          str = strRe + ' - i';
        } else {
          str = strRe + ' - ' + strIm.substring(1) + 'i';
        }
      }
    }
    return str;
  };

  /**
   * Create a complex number from polar coordinates
   *
   * Usage:
   *
   *     Complex.fromPolar(r: number, phi: number) : Complex
   *     Complex.fromPolar({r: number, phi: number}) : Complex
   *
   * @param {*} args...
   * @return {Complex}
   */
  Complex.fromPolar = function (args) {
    switch (arguments.length) {
      case 1:
        var arg = arguments[0];
        if (typeof arg === 'object') {
          return Complex(arg);
        }
        throw new TypeError('Input has to be an object with r and phi keys.');

      case 2:
        var r = arguments[0],
            phi = arguments[1];
        if (isNumber(r)) {
          if (phi && phi.isUnit && phi.hasBase('ANGLE')) {
            // convert unit to a number in radians
            phi = phi.toNumber('rad');
          }

          if (isNumber(phi)) {
            return new Complex({r: r, phi: phi});
          }

          throw new TypeError('Phi is not a number nor an angle unit.');
        } else {
          throw new TypeError('Radius r is not a number.');
        }

      default:
        throw new SyntaxError('Wrong number of arguments in function fromPolar');
    }
  };


  Complex.prototype.valueOf = Complex.prototype.toString;

  /**
   * Create a Complex number from a JSON object
   * @param {Object} json  A JSON Object structured as
   *                       {"mathjs": "Complex", "re": 2, "im": 3}
   *                       All properties are optional, default values
   *                       for `re` and `im` are 0.
   * @return {Complex} Returns a new Complex number
   */
  Complex.fromJSON = function (json) {
    return new Complex(json);
  };

  // apply the current epsilon
  Complex.EPSILON = config.epsilon;

  // listen for changed in the configuration, automatically apply changed epsilon
  math.on('config', function (curr, prev) {
    if (curr.epsilon !== prev.epsilon) {
      Complex.EPSILON = curr.epsilon;
    }
  });

  return Complex;
}

exports.name = 'Complex';
exports.path = 'type';
exports.factory = factory;
exports.math = true; // request access to the math namespace

},{"../../utils/number":483,"complex.js":488}],420:[function(require,module,exports){
'use strict';

var deepMap = require('../../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  var latex = require('../../../utils/latex');

  /**
   * Create a complex value or convert a value to a complex value.
   *
   * Syntax:
   *
   *     math.complex()                           // creates a complex value with zero
   *                                              // as real and imaginary part.
   *     math.complex(re : number, im : string)   // creates a complex value with provided
   *                                              // values for real and imaginary part.
   *     math.complex(re : number)                // creates a complex value with provided
   *                                              // real value and zero imaginary part.
   *     math.complex(complex : Complex)          // clones the provided complex value.
   *     math.complex(arg : string)               // parses a string into a complex value.
   *     math.complex(array : Array)              // converts the elements of the array
   *                                              // or matrix element wise into a
   *                                              // complex value.
   *     math.complex({re: number, im: number})   // creates a complex value with provided
   *                                              // values for real an imaginary part.
   *     math.complex({r: number, phi: number})   // creates a complex value with provided
   *                                              // polar coordinates
   *
   * Examples:
   *
   *    var a = math.complex(3, -4);     // a = Complex 3 - 4i
   *    a.re = 5;                        // a = Complex 5 - 4i
   *    var i = a.im;                    // Number -4;
   *    var b = math.complex('2 + 6i');  // Complex 2 + 6i
   *    var c = math.complex();          // Complex 0 + 0i
   *    var d = math.add(a, b);          // Complex 5 + 2i
   *
   * See also:
   *
   *    bignumber, boolean, index, matrix, number, string, unit
   *
   * @param {* | Array | Matrix} [args]
   *            Arguments specifying the real and imaginary part of the complex number
   * @return {Complex | Array | Matrix} Returns a complex value
   */
  var complex = typed('complex', {
    '': function () {
      return type.Complex.ZERO;
    },

    'number': function (x) {
      return new type.Complex(x, 0);
    },

    'number, number': function (re, im) {
      return new type.Complex(re, im);
    },

    // TODO: this signature should be redundant
    'BigNumber, BigNumber': function (re, im) {
      return new type.Complex(re.toNumber(), im.toNumber());
    },

    'Complex': function (x) {
      return x.clone();
    },

    'string': function (x) {
      return type.Complex(x); // for example '2 + 3i'
    },

    'Object': function (x) {
      if('re' in x && 'im' in x) {
        return new type.Complex(x.re, x.im);
      }

      if ('r' in x && 'phi' in x) {
        return new type.Complex(x);
      }

      throw new Error('Expected object with either properties re and im, or properties r and phi.');
    },

    'Array | Matrix': function (x) {
      return deepMap(x, complex);
    }
  });

  complex.toTex = {
    0: '0',
    1: '\\left(${args[0]}\\right)',
    2: '\\left(\\left(${args[0]}\\right)+'
      + latex.symbols['i'] + '\\cdot\\left(${args[1]}\\right)\\right)'
  };

  return complex;
}

exports.name = 'complex';
exports.factory = factory;

},{"../../../utils/collection/deepMap":475,"../../../utils/latex":482}],421:[function(require,module,exports){
module.exports = [
  // type
  require('./Complex'),

  // construction function
  require('./function/complex')
];

},{"./Complex":419,"./function/complex":420}],422:[function(require,module,exports){
var Fraction = require('fraction.js');

/**
 * Attach type information
 */
Fraction.prototype.type = 'Fraction';
Fraction.prototype.isFraction = true;

/**
 * Get a JSON representation of a Fraction containing type information
 * @returns {Object} Returns a JSON object structured as:
 *                   `{"mathjs": "Fraction", "n": 3, "d": 8}`
 */
Fraction.prototype.toJSON = function () {
  return {
    mathjs: 'Fraction',
    n: this.s * this.n,
    d: this.d
  };
};

/**
 * Instantiate a Fraction from a JSON object
 * @param {Object} json  a JSON object structured as:
 *                       `{"mathjs": "Fraction", "n": 3, "d": 8}`
 * @return {BigNumber}
 */
Fraction.fromJSON = function (json) {
  return new Fraction(json);
};


function factory (type, config, load, typed) {
  return Fraction;
}

exports.name = 'Fraction';
exports.path = 'type';
exports.factory = factory;

},{"fraction.js":490}],423:[function(require,module,exports){
'use strict';

var deepMap = require('../../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Create a fraction convert a value to a fraction.
   *
   * Syntax:
   *     math.fraction(numerator, denominator)
   *     math.fraction({n: numerator, d: denominator})
   *     math.fraction(matrix: Array | Matrix)         Turn all matrix entries
   *                                                   into fractions
   *
   * Examples:
   *
   *     math.fraction(1, 3);
   *     math.fraction('2/3');
   *     math.fraction({n: 2, d: 3});
   *     math.fraction([0.2, 0.25, 1.25]);
   *
   * See also:
   *
   *    bignumber, number, string, unit
   *
   * @param {number | string | Fraction | BigNumber | Array | Matrix} [args]
   *            Arguments specifying the numerator and denominator of
   *            the fraction
   * @return {Fraction | Array | Matrix} Returns a fraction
   */
  var fraction = typed('fraction', {
    'number': function (x) {
      if (!isFinite(x) || isNaN(x)) {
        throw new Error(x + ' cannot be represented as a fraction');
      }

      return new type.Fraction(x);
    },

    'string': function (x) {
      return new type.Fraction(x);
    },

    'number, number': function (numerator, denominator) {
      return new type.Fraction(numerator, denominator);
    },

    'BigNumber': function (x) {
      return new type.Fraction(x.toString());
    },

    'Fraction': function (x) {
      return x; // fractions are immutable
    },

    'Object': function (x) {
      return new type.Fraction(x);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, fraction);
    }
  });

  return fraction;
}

exports.name = 'fraction';
exports.factory = factory;

},{"../../../utils/collection/deepMap":475}],424:[function(require,module,exports){
module.exports = [
  // type
  require('./Fraction'),

  // construction function
  require('./function/fraction')
];

},{"./Fraction":422,"./function/fraction":423}],425:[function(require,module,exports){
module.exports = [
  require('./bignumber'),
  require('./boolean'),
  require('./chain'),
  require('./complex'),
  require('./fraction'),
  require('./matrix'),
  require('./number'),
  require('./resultset'),
  require('./string'),
  require('./unit')
];

},{"./bignumber":414,"./boolean":415,"./chain":418,"./complex":421,"./fraction":424,"./matrix":437,"./number":452,"./resultset":454,"./string":455,"./unit":458}],426:[function(require,module,exports){
'use strict';

var util = require('../../utils/index');
var DimensionError = require('../../error/DimensionError');

var string = util.string;
var array = util.array;
var object = util.object;
var number = util.number;

var isArray = Array.isArray;
var isNumber = number.isNumber;
var isInteger = number.isInteger;
var isString = string.isString;

var validateIndex = array.validateIndex;

function factory (type, config, load, typed) {
  var Matrix = load(require('./Matrix')); // force loading Matrix (do not use via type.Matrix)

  /**
   * Dense Matrix implementation. A regular, dense matrix, supporting multi-dimensional matrices. This is the default matrix type.
   * @class DenseMatrix
   */
  function DenseMatrix(data, datatype) {
    if (!(this instanceof DenseMatrix))
      throw new SyntaxError('Constructor must be called with the new operator');
    if (datatype && !isString(datatype))
      throw new Error('Invalid datatype: ' + datatype);

    if (data && data.isMatrix === true) {
      // check data is a DenseMatrix
      if (data.type === 'DenseMatrix') {
        // clone data & size
        this._data = object.clone(data._data);
        this._size = object.clone(data._size);
        this._datatype = datatype || data._datatype;
      }
      else {
        // build data from existing matrix
        this._data = data.toArray();
        this._size = data.size();
        this._datatype = datatype || data._datatype;
      }
    }
    else if (data && isArray(data.data) && isArray(data.size)) {
      // initialize fields from JSON representation
      this._data = data.data;
      this._size = data.size;
      this._datatype = datatype || data.datatype;
    }
    else if (isArray(data)) {
      // replace nested Matrices with Arrays
      this._data = preprocess(data);
      // get the dimensions of the array
      this._size = array.size(this._data);
      // verify the dimensions of the array, TODO: compute size while processing array
      array.validate(this._data, this._size);
      // data type unknown
      this._datatype = datatype;
    }
    else if (data) {
      // unsupported type
      throw new TypeError('Unsupported type of data (' + util.types.type(data) + ')');
    }
    else {
      // nothing provided
      this._data = [];
      this._size = [0];
      this._datatype = datatype;
    }
  }
  
  DenseMatrix.prototype = new Matrix();

  /**
   * Attach type information
   */
  DenseMatrix.prototype.type = 'DenseMatrix';
  DenseMatrix.prototype.isDenseMatrix = true;

  /**
   * Get the storage format used by the matrix.
   *
   * Usage:
   *     var format = matrix.storage()                   // retrieve storage format
   *
   * @memberof DenseMatrix
   * @return {string}           The storage format.
   */
  DenseMatrix.prototype.storage = function () {
    return 'dense';
  };

  /**
   * Get the datatype of the data stored in the matrix.
   *
   * Usage:
   *     var format = matrix.datatype()                   // retrieve matrix datatype
   *
   * @memberof DenseMatrix
   * @return {string}           The datatype.
   */
  DenseMatrix.prototype.datatype = function () {
    return this._datatype;
  };

  /**
   * Create a new DenseMatrix
   * @memberof DenseMatrix
   * @param {Array} data
   * @param {string} [datatype]
   */
  DenseMatrix.prototype.create = function (data, datatype) {
    return new DenseMatrix(data, datatype);
  };

  /**
   * Get a subset of the matrix, or replace a subset of the matrix.
   *
   * Usage:
   *     var subset = matrix.subset(index)               // retrieve subset
   *     var value = matrix.subset(index, replacement)   // replace subset
   *
   * @memberof DenseMatrix
   * @param {Index} index
   * @param {Array | DenseMatrix | *} [replacement]
   * @param {*} [defaultValue=0]      Default value, filled in on new entries when
   *                                  the matrix is resized. If not provided,
   *                                  new matrix elements will be filled with zeros.
   */
  DenseMatrix.prototype.subset = function (index, replacement, defaultValue) {
    switch (arguments.length) {
      case 1:
        return _get(this, index);

        // intentional fall through
      case 2:
      case 3:
        return _set(this, index, replacement, defaultValue);

      default:
        throw new SyntaxError('Wrong number of arguments');
    }
  };
  
  /**
   * Get a single element from the matrix.
   * @memberof DenseMatrix
   * @param {number[]} index   Zero-based index
   * @return {*} value
   */
  DenseMatrix.prototype.get = function (index) {
    if (!isArray(index))
      throw new TypeError('Array expected');
    if (index.length != this._size.length)
      throw new DimensionError(index.length, this._size.length);

    // check index
    for (var x = 0; x < index.length; x++)
      validateIndex(index[x], this._size[x]);

    var data = this._data;
    for (var i = 0, ii = index.length; i < ii; i++) {
      var index_i = index[i];
      validateIndex(index_i, data.length);
      data = data[index_i];
    }

    return data;
  };
  
  /**
   * Replace a single element in the matrix.
   * @memberof DenseMatrix
   * @param {number[]} index   Zero-based index
   * @param {*} value
   * @param {*} [defaultValue]        Default value, filled in on new entries when
   *                                  the matrix is resized. If not provided,
   *                                  new matrix elements will be left undefined.
   * @return {DenseMatrix} self
   */
  DenseMatrix.prototype.set = function (index, value, defaultValue) {
    if (!isArray(index))
      throw new TypeError('Array expected');
    if (index.length < this._size.length)
      throw new DimensionError(index.length, this._size.length, '<');

    var i, ii, index_i;

    // enlarge matrix when needed
    var size = index.map(function (i) {
      return i + 1;
    });
    _fit(this, size, defaultValue);

    // traverse over the dimensions
    var data = this._data;
    for (i = 0, ii = index.length - 1; i < ii; i++) {
      index_i = index[i];
      validateIndex(index_i, data.length);
      data = data[index_i];
    }

    // set new value
    index_i = index[index.length - 1];
    validateIndex(index_i, data.length);
    data[index_i] = value;

    return this;
  };
  
  /**
   * Get a submatrix of this matrix
   * @memberof DenseMatrix
   * @param {DenseMatrix} matrix
   * @param {Index} index   Zero-based index
   * @private
   */
  function _get (matrix, index) {
    if (!index || index.isIndex !== true) {
      throw new TypeError('Invalid index');
    }

    var isScalar = index.isScalar();
    if (isScalar) {
      // return a scalar
      return matrix.get(index.min());
    }
    else {
      // validate dimensions
      var size = index.size();
      if (size.length != matrix._size.length) {
        throw new DimensionError(size.length, matrix._size.length);
      }

      // validate if any of the ranges in the index is out of range
      var min = index.min();
      var max = index.max();
      for (var i = 0, ii = matrix._size.length; i < ii; i++) {
        validateIndex(min[i], matrix._size[i]);
        validateIndex(max[i], matrix._size[i]);
      }

      // retrieve submatrix
      // TODO: more efficient when creating an empty matrix and setting _data and _size manually
      return new DenseMatrix(_getSubmatrix(matrix._data, index, size.length, 0), matrix._datatype);
    }
  }
  
  /**
   * Recursively get a submatrix of a multi dimensional matrix.
   * Index is not checked for correct number or length of dimensions.
   * @memberof DenseMatrix
   * @param {Array} data
   * @param {Index} index
   * @param {number} dims   Total number of dimensions
   * @param {number} dim    Current dimension
   * @return {Array} submatrix
   * @private
   */
  function _getSubmatrix (data, index, dims, dim) {
    var last = (dim == dims - 1);
    var range = index.dimension(dim);

    if (last) {
      return range.map(function (i) {
        return data[i];
      }).valueOf();
    }
    else {
      return range.map(function (i) {
        var child = data[i];
        return _getSubmatrix(child, index, dims, dim + 1);
      }).valueOf();
    }
  }
  
  /**
   * Replace a submatrix in this matrix
   * Indexes are zero-based.
   * @memberof DenseMatrix
   * @param {DenseMatrix} matrix
   * @param {Index} index
   * @param {DenseMatrix | Array | *} submatrix
   * @param {*} defaultValue          Default value, filled in on new entries when
   *                                  the matrix is resized.
   * @return {DenseMatrix} matrix
   * @private
   */
  function _set (matrix, index, submatrix, defaultValue) {
    if (!index || index.isIndex !== true) {
      throw new TypeError('Invalid index');
    }

    // get index size and check whether the index contains a single value
    var iSize = index.size(),
        isScalar = index.isScalar();

    // calculate the size of the submatrix, and convert it into an Array if needed
    var sSize;
    if (submatrix && submatrix.isMatrix === true) {
      sSize = submatrix.size();
      submatrix = submatrix.valueOf();
    }
    else {
      sSize = array.size(submatrix);
    }

    if (isScalar) {
      // set a scalar

      // check whether submatrix is a scalar
      if (sSize.length !== 0) {
        throw new TypeError('Scalar expected');
      }

      matrix.set(index.min(), submatrix, defaultValue);
    }
    else {
      // set a submatrix

      // validate dimensions
      if (iSize.length < matrix._size.length) {
        throw new DimensionError(iSize.length, matrix._size.length, '<');
      }

      if (sSize.length < iSize.length) {
        // calculate number of missing outer dimensions
        var i = 0;
        var outer = 0;
        while (iSize[i] === 1 && sSize[i] === 1) {
          i++;
        }
        while (iSize[i] === 1) {
          outer++;
          i++;
        }

        // unsqueeze both outer and inner dimensions
        submatrix = array.unsqueeze(submatrix, iSize.length, outer, sSize);
      }

      // check whether the size of the submatrix matches the index size
      if (!object.deepEqual(iSize, sSize)) {
        throw new DimensionError(iSize, sSize, '>');
      }

      // enlarge matrix when needed
      var size = index.max().map(function (i) {
        return i + 1;
      });
      _fit(matrix, size, defaultValue);

      // insert the sub matrix
      var dims = iSize.length,
          dim = 0;
      _setSubmatrix (matrix._data, index, submatrix, dims, dim);
    }

    return matrix;
  }
  
  /**
   * Replace a submatrix of a multi dimensional matrix.
   * @memberof DenseMatrix
   * @param {Array} data
   * @param {Index} index
   * @param {Array} submatrix
   * @param {number} dims   Total number of dimensions
   * @param {number} dim
   * @private
   */
  function _setSubmatrix (data, index, submatrix, dims, dim) {
    var last = (dim == dims - 1),
        range = index.dimension(dim);

    if (last) {
      range.forEach(function (dataIndex, subIndex) {
        validateIndex(dataIndex);
        data[dataIndex] = submatrix[subIndex[0]];
      });
    }
    else {
      range.forEach(function (dataIndex, subIndex) {
        validateIndex(dataIndex);
        _setSubmatrix(data[dataIndex], index, submatrix[subIndex[0]], dims, dim + 1);
      });
    }
  }
  
  /**
   * Resize the matrix to the given size. Returns a copy of the matrix when
   * `copy=true`, otherwise return the matrix itself (resize in place).
   *
   * @memberof DenseMatrix
   * @param {number[]} size           The new size the matrix should have.
   * @param {*} [defaultValue=0]      Default value, filled in on new entries.
   *                                  If not provided, the matrix elements will
   *                                  be filled with zeros.
   * @param {boolean} [copy]          Return a resized copy of the matrix
   *
   * @return {Matrix}                 The resized matrix
   */
  DenseMatrix.prototype.resize = function (size, defaultValue, copy) {
    // validate arguments
    if (!isArray(size))
      throw new TypeError('Array expected');

    // matrix to resize
    var m = copy ? this.clone() : this;
    // resize matrix
    return _resize(m, size, defaultValue);
  };
  
  var _resize = function (matrix, size, defaultValue) {
    // check size
    if (size.length === 0) {
      // first value in matrix
      var v = matrix._data;
      // go deep
      while (isArray(v)) {
        v = v[0];
      }
      return v;
    }
    // resize matrix
    matrix._size = size.slice(0); // copy the array
    matrix._data = array.resize(matrix._data, matrix._size, defaultValue);
    // return matrix
    return matrix;
  };
  
  /**
   * Enlarge the matrix when it is smaller than given size.
   * If the matrix is larger or equal sized, nothing is done.
   * @memberof DenseMatrix
   * @param {DenseMatrix} matrix           The matrix to be resized
   * @param {number[]} size
   * @param {*} defaultValue          Default value, filled in on new entries.
   * @private
   */
  function _fit(matrix, size, defaultValue) {
    var newSize = matrix._size.slice(0), // copy the array
        changed = false;

    // add dimensions when needed
    while (newSize.length < size.length) {
      newSize.push(0);
      changed = true;
    }

    // enlarge size when needed
    for (var i = 0, ii = size.length; i < ii; i++) {
      if (size[i] > newSize[i]) {
        newSize[i] = size[i];
        changed = true;
      }
    }

    if (changed) {
      // resize only when size is changed
      _resize(matrix, newSize, defaultValue);
    }
  }
  
  /**
   * Create a clone of the matrix
   * @memberof DenseMatrix
   * @return {DenseMatrix} clone
   */
  DenseMatrix.prototype.clone = function () {
    var m = new DenseMatrix({
      data: object.clone(this._data),
      size: object.clone(this._size),
      datatype: this._datatype
    });
    return m;
  };
  
  /**
   * Retrieve the size of the matrix.
   * @memberof DenseMatrix
   * @returns {number[]} size
   */
  DenseMatrix.prototype.size = function() {
    return this._size;
  };
  
  /**
   * Create a new matrix with the results of the callback function executed on
   * each entry of the matrix.
   * @memberof DenseMatrix
   * @param {Function} callback   The callback function is invoked with three
   *                              parameters: the value of the element, the index
   *                              of the element, and the Matrix being traversed.
   *
   * @return {DenseMatrix} matrix
   */
  DenseMatrix.prototype.map = function (callback) {
    // matrix instance
    var me = this;
    var recurse = function (value, index) {
      if (isArray(value)) {
        return value.map(function (child, i) {
          return recurse(child, index.concat(i));
        });
      }
      else {
        return callback(value, index, me);
      }
    };
    // return dense format
    return new DenseMatrix({
      data: recurse(this._data, []),
      size: object.clone(this._size),
      datatype: this._datatype
    });
  };
  
  /**
   * Execute a callback function on each entry of the matrix.
   * @memberof DenseMatrix
   * @param {Function} callback   The callback function is invoked with three
   *                              parameters: the value of the element, the index
   *                              of the element, and the Matrix being traversed.
   */
  DenseMatrix.prototype.forEach = function (callback) {
    // matrix instance
    var me = this;
    var recurse = function (value, index) {
      if (isArray(value)) {
        value.forEach(function (child, i) {
          recurse(child, index.concat(i));
        });
      }
      else {
        callback(value, index, me);
      }
    };
    recurse(this._data, []);
  };
  
  /**
   * Create an Array with a copy of the data of the DenseMatrix
   * @memberof DenseMatrix
   * @returns {Array} array
   */
  DenseMatrix.prototype.toArray = function () {
    return object.clone(this._data);
  };
  
  /**
   * Get the primitive value of the DenseMatrix: a multidimensional array
   * @memberof DenseMatrix
   * @returns {Array} array
   */
  DenseMatrix.prototype.valueOf = function () {
    return this._data;
  };
  
  /**
   * Get a string representation of the matrix, with optional formatting options.
   * @memberof DenseMatrix
   * @param {Object | number | Function} [options]  Formatting options. See
   *                                                lib/utils/number:format for a
   *                                                description of the available
   *                                                options.
   * @returns {string} str
   */
  DenseMatrix.prototype.format = function (options) {
    return string.format(this._data, options);
  };
  
  /**
   * Get a string representation of the matrix
   * @memberof DenseMatrix
   * @returns {string} str
   */
  DenseMatrix.prototype.toString = function () {
    return string.format(this._data);
  };
  
  /**
   * Get a JSON representation of the matrix
   * @memberof DenseMatrix
   * @returns {Object}
   */
  DenseMatrix.prototype.toJSON = function () {
    return {
      mathjs: 'DenseMatrix',
      data: this._data,
      size: this._size,
      datatype: this._datatype
    };
  };
  
  /**
   * Get the kth Matrix diagonal.
   *
   * @memberof DenseMatrix
   * @param {number | BigNumber} [k=0]     The kth diagonal where the vector will retrieved.
   *
   * @returns {Array}                      The array vector with the diagonal values.
   */
  DenseMatrix.prototype.diagonal = function(k) {
    // validate k if any
    if (k) {
      // convert BigNumber to a number
      if (k.isBigNumber === true)
        k = k.toNumber();
      // is must be an integer
      if (!isNumber(k) || !isInteger(k)) {
        throw new TypeError ('The parameter k must be an integer number');
      }
    }
    else {
      // default value
      k = 0;
    }

    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;

    // rows & columns
    var rows = this._size[0];
    var columns = this._size[1];

    // number diagonal values
    var n = Math.min(rows - kSub, columns -  kSuper);
    
    // x is a matrix get diagonal from matrix
    var data = [];
    
    // loop rows
    for (var i = 0; i < n; i++) {
      data[i] = this._data[i + kSub][i + kSuper];
    }

    // create DenseMatrix
    return new DenseMatrix({
      data: data,
      size: [n],
      datatype: this._datatype
    });
  };
  
  /**
   * Create a diagonal matrix.
   *
   * @memberof DenseMatrix
   * @param {Array} size                   The matrix size.
   * @param {number | Array} value          The values for the diagonal.
   * @param {number | BigNumber} [k=0]     The kth diagonal where the vector will be filled in.
   * @param {number} [defaultValue]        The default value for non-diagonal
   *
   * @returns {DenseMatrix}
   */
  DenseMatrix.diagonal = function (size, value, k, defaultValue, datatype) {
    if (!isArray(size))
      throw new TypeError('Array expected, size parameter');
    if (size.length !== 2)
      throw new Error('Only two dimensions matrix are supported');

    // map size & validate
    size = size.map(function (s) {
      // check it is a big number
      if (s && s.isBigNumber === true) {
        // convert it
        s = s.toNumber();
      }
      // validate arguments
      if (!isNumber(s) || !isInteger(s) || s < 1) {
        throw new Error('Size values must be positive integers');
      } 
      return s;
    });

    // validate k if any
    if (k) {
      // convert BigNumber to a number
      if (k && k.isBigNumber === true)
        k = k.toNumber();
      // is must be an integer
      if (!isNumber(k) || !isInteger(k)) {
        throw new TypeError ('The parameter k must be an integer number');
      }
    }
    else {
      // default value
      k = 0;
    }
    
    if (defaultValue && isString(datatype)) {
      // convert defaultValue to the same datatype
      defaultValue = typed.convert(defaultValue, datatype);
    }

    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;
    
    // rows and columns
    var rows = size[0];
    var columns = size[1];

    // number of non-zero items
    var n = Math.min(rows - kSub, columns -  kSuper);

    // value extraction function
    var _value;

    // check value
    if (isArray(value)) {
      // validate array
      if (value.length !== n) {
        // number of values in array must be n
        throw new Error('Invalid value array length');
      }
      // define function
      _value = function (i) {
        // return value @ i
        return value[i];
      };      
    }
    else if (value && value.isMatrix === true) {
      // matrix size
      var ms = value.size();
      // validate matrix
      if (ms.length !== 1 || ms[0] !== n) {
        // number of values in array must be n
        throw new Error('Invalid matrix length');
      }
      // define function
      _value = function (i) {
        // return value @ i
        return value.get([i]);
      };
    }
    else {
      // define function
      _value = function () {
        // return value
        return value;
      };
    }
    
    // discover default value if needed
    if (!defaultValue) {
      // check first value in array
      defaultValue = (_value(0) && _value(0).isBigNumber === true) ? new type.BigNumber(0) : 0;
    }

    // empty array
    var data = [];

    // check we need to resize array
    if (size.length > 0) {
      // resize array
      data = array.resize(data, size, defaultValue);
      // fill diagonal
      for (var d = 0; d < n; d++) {
        data[d + kSub][d + kSuper] = _value(d);
      }
    }
    
    // create DenseMatrix
    return new DenseMatrix({
      data: data,
      size: [rows, columns]
    });
  };

  /**
   * Generate a matrix from a JSON object
   * @memberof DenseMatrix
   * @param {Object} json  An object structured like
   *                       `{"mathjs": "DenseMatrix", data: [], size: []}`,
   *                       where mathjs is optional
   * @returns {DenseMatrix}
   */
  DenseMatrix.fromJSON = function (json) {
    return new DenseMatrix(json);
  };
  
  /**
   * Swap rows i and j in Matrix.
   *
   * @memberof DenseMatrix
   * @param {number} i       Matrix row index 1
   * @param {number} j       Matrix row index 2
   *
   * @return {Matrix}        The matrix reference
   */
  DenseMatrix.prototype.swapRows = function (i, j) {
    // check index
    if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {
      throw new Error('Row index must be positive integers');
    }
    // check dimensions
    if (this._size.length !== 2) {
      throw new Error('Only two dimensional matrix is supported');
    }
    // validate index
    validateIndex(i, this._size[0]);
    validateIndex(j, this._size[0]);

    // swap rows
    DenseMatrix._swapRows(i, j, this._data);
    // return current instance
    return this;
  };

  /**
   * Swap rows i and j in Dense Matrix data structure.
   *
   * @param {number} i       Matrix row index 1
   * @param {number} j       Matrix row index 2
   */
  DenseMatrix._swapRows = function (i, j, data) {
    // swap values i <-> j
    var vi = data[i];
    data[i] = data[j];
    data[j] = vi;
  };
   
  /**
   * Preprocess data, which can be an Array or DenseMatrix with nested Arrays and
   * Matrices. Replaces all nested Matrices with Arrays
   * @memberof DenseMatrix
   * @param {Array} data
   * @return {Array} data
   */
  function preprocess(data) {
    for (var i = 0, ii = data.length; i < ii; i++) {
      var elem = data[i];
      if (isArray(elem)) {
        data[i] = preprocess(elem);
      }
      else if (elem && elem.isMatrix === true) {
        data[i] = preprocess(elem.valueOf());
      }
    }

    return data;
  }

  // register this type in the base class Matrix
  type.Matrix._storage.dense = DenseMatrix;
  type.Matrix._storage['default'] = DenseMatrix;

  // exports
  return DenseMatrix;
}

exports.name = 'DenseMatrix';
exports.path = 'type';
exports.factory = factory;
exports.lazy = false;  // no lazy loading, as we alter type.Matrix._storage
},{"../../error/DimensionError":11,"../../utils/index":481,"./Matrix":429}],427:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  
  var smaller = load(require('../../function/relational/smaller'));
  var larger = load(require('../../function/relational/larger'));
  
  var oneOverLogPhi = 1.0 / Math.log((1.0 + Math.sqrt(5.0)) / 2.0);
  
  /**
   * Fibonacci Heap implementation, used interally for Matrix math.
   * @class FibonacciHeap
   * @constructor FibonacciHeap
   */
  function FibonacciHeap() {
    if (!(this instanceof FibonacciHeap))
      throw new SyntaxError('Constructor must be called with the new operator');

    // initialize fields
    this._minimum = null;
    this._size = 0;
  }

  /**
   * Attach type information
   */
  FibonacciHeap.prototype.type = 'FibonacciHeap';
  FibonacciHeap.prototype.isFibonacciHeap = true;

  /**
   * Inserts a new data element into the heap. No heap consolidation is
   * performed at this time, the new node is simply inserted into the root
   * list of this heap. Running time: O(1) actual.
   * @memberof FibonacciHeap
   */
  FibonacciHeap.prototype.insert = function (key, value) {
    // create node
    var node = {
      key: key,
      value: value,
      degree: 0
    };
    // check we have a node in the minimum
    if (this._minimum) {
      // minimum node
      var minimum = this._minimum;
      // update left & right of node
      node.left = minimum;
      node.right = minimum.right;
      minimum.right = node;
      node.right.left = node;
      // update minimum node in heap if needed
      if (smaller(key, minimum.key)) {
        // node has a smaller key, use it as minimum
        this._minimum = node;
      }
    }
    else {
      // set left & right
      node.left = node;
      node.right = node;
      // this is the first node
      this._minimum = node;
    }
    // increment number of nodes in heap
    this._size++;
    // return node
    return node;
  };

  /**
   * Returns the number of nodes in heap. Running time: O(1) actual.
   * @memberof FibonacciHeap
   */
  FibonacciHeap.prototype.size = function () {
    return this._size;
  };

  /**
   * Removes all elements from this heap.
   * @memberof FibonacciHeap
   */
  FibonacciHeap.prototype.clear = function () {
    this._minimum = null;
    this._size = 0;
  };

  /**
   * Returns true if the heap is empty, otherwise false.
   * @memberof FibonacciHeap
   */
  FibonacciHeap.prototype.isEmpty = function () {
    return !!this._minimum;
  };
  
  /**
   * Extracts the node with minimum key from heap. Amortized running 
   * time: O(log n).
   * @memberof FibonacciHeap
   */
  FibonacciHeap.prototype.extractMinimum = function () {
    // node to remove
    var node = this._minimum;
    // check we have a minimum
    if (node === null)
      return node;
    // current minimum
    var minimum = this._minimum;
    // get number of children
    var numberOfChildren = node.degree;
    // pointer to the first child
    var x = node.child;
    // for each child of node do...
    while (numberOfChildren > 0) {
      // store node in right side
      var tempRight = x.right;
      // remove x from child list
      x.left.right = x.right;
      x.right.left = x.left;
      // add x to root list of heap
      x.left = minimum;
      x.right = minimum.right;
      minimum.right = x;
      x.right.left = x;
      // set Parent[x] to null
      x.parent = null;
      x = tempRight;
      numberOfChildren--;
    }
    // remove node from root list of heap
    node.left.right = node.right;
    node.right.left = node.left;
    // update minimum
    if (node == node.right) {
      // empty
      minimum = null;
    }
    else {
      // update minimum
      minimum = node.right;
      // we need to update the pointer to the root with minimum key
      minimum = _findMinimumNode(minimum, this._size);
    }
    // decrement size of heap
    this._size--;
    // update minimum
    this._minimum = minimum;
    // return node
    return node;
  };
  
  /**
   * Removes a node from the heap given the reference to the node. The trees
   * in the heap will be consolidated, if necessary. This operation may fail
   * to remove the correct element if there are nodes with key value -Infinity.
   * Running time: O(log n) amortized.
   * @memberof FibonacciHeap
   */
  FibonacciHeap.prototype.remove = function (node) {
    // decrease key value
    this._minimum = _decreaseKey(this._minimum, node, -1);
    // remove the smallest
    this.extractMinimum();
  };
  
  /**
   * Decreases the key value for a heap node, given the new value to take on.
   * The structure of the heap may be changed and will not be consolidated. 
   * Running time: O(1) amortized.
   * @memberof FibonacciHeap
   */
  var _decreaseKey = function (minimum, node, key) {
    // set node key
    node.key = key;
    // get parent node
    var parent = node.parent;
    if (parent && smaller(node.key, parent.key)) {
      // remove node from parent
      _cut(minimum, node, parent);
      // remove all nodes from parent to the root parent
      _cascadingCut(minimum, parent);
    }
    // update minimum node if needed
    if (smaller(node.key, minimum.key))
      minimum = node;
    // return minimum
    return minimum;
  };
  
  /**
   * The reverse of the link operation: removes node from the child list of parent.
   * This method assumes that min is non-null. Running time: O(1).
   * @memberof FibonacciHeap
   */
  var _cut = function (minimum, node, parent) {
    // remove node from parent children and decrement Degree[parent]
    node.left.right = node.right;
    node.right.left = node.left;
    parent.degree--;
    // reset y.child if necessary
    if (parent.child == node)
      parent.child = node.right;
    // remove child if degree is 0
    if (parent.degree === 0)
      parent.child = null;
    // add node to root list of heap
    node.left = minimum;
    node.right = minimum.right;
    minimum.right = node;
    node.right.left = node;
    // set parent[node] to null
    node.parent = null;
    // set mark[node] to false
    node.mark = false;
  };
  
  /**
   * Performs a cascading cut operation. This cuts node from its parent and then
   * does the same for its parent, and so on up the tree.
   * Running time: O(log n); O(1) excluding the recursion.
   * @memberof FibonacciHeap
   */
  var _cascadingCut= function (minimum, node) {
    // store parent node
    var parent = node.parent;
    // if there's a parent...
    if (!parent)
      return;
    // if node is unmarked, set it marked
    if (!node.mark) {
      node.mark = true;
    }
    else {
      // it's marked, cut it from parent
      _cut(minimum, node, parent);
      // cut its parent as well
      _cascadingCut(parent);
    }
  };
  
  /**
   * Make the first node a child of the second one. Running time: O(1) actual.
   * @memberof FibonacciHeap
   */
  var _linkNodes = function (node, parent) {
    // remove node from root list of heap
    node.left.right = node.right;
    node.right.left = node.left;
    // make node a Child of parent
    node.parent = parent;
    if (!parent.child) {
      parent.child = node;
      node.right = node;
      node.left = node;
    }
    else {
      node.left = parent.child;
      node.right = parent.child.right;
      parent.child.right = node;
      node.right.left = node;
    }
    // increase degree[parent]
    parent.degree++;
    // set mark[node] false
    node.mark = false;
  };
  
  var _findMinimumNode = function (minimum, size) {
    // to find trees of the same degree efficiently we use an array of length O(log n) in which we keep a pointer to one root of each degree
    var arraySize = Math.floor(Math.log(size) * oneOverLogPhi) + 1;
    // create list with initial capacity
    var array = new Array(arraySize);
    // find the number of root nodes.
    var numRoots = 0;
    var x = minimum;
    if (x) {
      numRoots++;
      x = x.right;
      while (x !== minimum) {
        numRoots++;
        x = x.right;
      }
    }
    // vars
    var y;
    // For each node in root list do...
    while (numRoots > 0) {
      // access this node's degree..
      var d = x.degree;
      // get next node
      var next = x.right;
      // check if there is a node already in array with the same degree
      while (true) {
        // get node with the same degree is any
        y = array[d];
        if (!y)
          break;
        // make one node with the same degree a child of the other, do this based on the key value.
        if (larger(x.key, y.key)) {
          var temp = y;
          y = x;
          x = temp;
        }
        // make y a child of x
        _linkNodes(y, x);
        // we have handled this degree, go to next one.
        array[d] = null;
        d++;
      }
      // save this node for later when we might encounter another of the same degree.
      array[d] = x;
      // move forward through list.
      x = next;
      numRoots--;
    }
    // Set min to null (effectively losing the root list) and reconstruct the root list from the array entries in array[].
    minimum = null;
    // loop nodes in array
    for (var i = 0; i < arraySize; i++) {
      // get current node
      y = array[i];
      if (!y)
        continue;
      // check if we have a linked list
      if (minimum) {
        // First remove node from root list.
        y.left.right = y.right;
        y.right.left = y.left;
        // now add to root list, again.
        y.left = minimum;
        y.right = minimum.right;
        minimum.right = y;
        y.right.left = y;
        // check if this is a new min.
        if (smaller(y.key, minimum.key))
          minimum = y;
      }
      else
        minimum = y;
    }
    return minimum;
  };
  
  return FibonacciHeap;
}

exports.name = 'FibonacciHeap';
exports.path = 'type';
exports.factory = factory;

},{"../../function/relational/larger":354,"../../function/relational/smaller":356}],428:[function(require,module,exports){
'use strict';

var util = require('../../utils/index');

var string = util.string;
var object = util.object;

var isArray = Array.isArray;
var isString = string.isString;

function factory (type, config, load) {

  var DenseMatrix = load(require('./DenseMatrix'));

  var smaller = load(require('../../function/relational/smaller'));

  function ImmutableDenseMatrix(data, datatype) {
    if (!(this instanceof ImmutableDenseMatrix))
      throw new SyntaxError('Constructor must be called with the new operator');
    if (datatype && !isString(datatype))
      throw new Error('Invalid datatype: ' + datatype);

    if ((data && data.isMatrix === true) || isArray(data)) {
      // use DenseMatrix implementation
      var matrix = new DenseMatrix(data, datatype);
      // internal structures
      this._data = matrix._data;
      this._size = matrix._size;
      this._datatype = matrix._datatype;
      this._min = null;
      this._max = null;
    }
    else if (data && isArray(data.data) && isArray(data.size)) {
      // initialize fields from JSON representation
      this._data = data.data;
      this._size = data.size;
      this._datatype = data.datatype;
      this._min = typeof data.min !== 'undefined' ? data.min : null;
      this._max = typeof data.max !== 'undefined' ? data.max : null;
    }
    else if (data) {
      // unsupported type
      throw new TypeError('Unsupported type of data (' + util.types.type(data) + ')');
    }
    else {
      // nothing provided
      this._data = [];
      this._size = [0];
      this._datatype = datatype;
      this._min = null;
      this._max = null;
    }
  }

  ImmutableDenseMatrix.prototype = new DenseMatrix();

  /**
   * Attach type information
   */
  ImmutableDenseMatrix.prototype.type = 'ImmutableDenseMatrix';
  ImmutableDenseMatrix.prototype.isImmutableDenseMatrix = true;

  /**
   * Get a subset of the matrix, or replace a subset of the matrix.
   *
   * Usage:
   *     var subset = matrix.subset(index)               // retrieve subset
   *     var value = matrix.subset(index, replacement)   // replace subset
   *
   * @param {Index} index
   * @param {Array | ImmutableDenseMatrix | *} [replacement]
   * @param {*} [defaultValue=0]      Default value, filled in on new entries when
   *                                  the matrix is resized. If not provided,
   *                                  new matrix elements will be filled with zeros.
   */
  ImmutableDenseMatrix.prototype.subset = function (index) {
    switch (arguments.length) {
      case 1:
        // use base implementation
        var m = DenseMatrix.prototype.subset.call(this, index);
        // check result is a matrix
        if (m.isMatrix) {
          // return immutable matrix
          return new ImmutableDenseMatrix({
            data: m._data,
            size: m._size,
            datatype: m._datatype
          });
        }
        return m;
        
        // intentional fall through
      case 2:
      case 3:
        throw new Error('Cannot invoke set subset on an Immutable Matrix instance');

      default:
        throw new SyntaxError('Wrong number of arguments');
    }
  };

  /**
   * Replace a single element in the matrix.
   * @param {Number[]} index   Zero-based index
   * @param {*} value
   * @param {*} [defaultValue]        Default value, filled in on new entries when
   *                                  the matrix is resized. If not provided,
   *                                  new matrix elements will be left undefined.
   * @return {ImmutableDenseMatrix} self
   */
  ImmutableDenseMatrix.prototype.set = function () {
    throw new Error('Cannot invoke set on an Immutable Matrix instance');
  };

  /**
   * Resize the matrix to the given size. Returns a copy of the matrix when
   * `copy=true`, otherwise return the matrix itself (resize in place).
   *
   * @param {Number[]} size           The new size the matrix should have.
   * @param {*} [defaultValue=0]      Default value, filled in on new entries.
   *                                  If not provided, the matrix elements will
   *                                  be filled with zeros.
   * @param {boolean} [copy]          Return a resized copy of the matrix
   *
   * @return {Matrix}                 The resized matrix
   */
  ImmutableDenseMatrix.prototype.resize = function () {
    throw new Error('Cannot invoke resize on an Immutable Matrix instance');
  };

  /**
   * Create a clone of the matrix
   * @return {ImmutableDenseMatrix} clone
   */
  ImmutableDenseMatrix.prototype.clone = function () {
    var m = new ImmutableDenseMatrix({
      data: object.clone(this._data),
      size: object.clone(this._size),
      datatype: this._datatype
    });
    return m;
  };

  /**
   * Get a JSON representation of the matrix
   * @returns {Object}
   */
  ImmutableDenseMatrix.prototype.toJSON = function () {
    return {
      mathjs: 'ImmutableDenseMatrix',
      data: this._data,
      size: this._size,
      datatype: this._datatype
    };
  };

  /**
   * Generate a matrix from a JSON object
   * @param {Object} json  An object structured like
   *                       `{"mathjs": "ImmutableDenseMatrix", data: [], size: []}`,
   *                       where mathjs is optional
   * @returns {ImmutableDenseMatrix}
   */
  ImmutableDenseMatrix.fromJSON = function (json) {
    return new ImmutableDenseMatrix(json);
  };

  /**
   * Swap rows i and j in Matrix.
   *
   * @param {Number} i       Matrix row index 1
   * @param {Number} j       Matrix row index 2
   *
   * @return {Matrix}        The matrix reference
   */
  ImmutableDenseMatrix.prototype.swapRows = function () {
    throw new Error('Cannot invoke swapRows on an Immutable Matrix instance');
  };

  /**
   * Calculate the minimum value in the set
   * @return {Number | undefined} min
   */
  ImmutableDenseMatrix.prototype.min = function () {
    // check min has been calculated before
    if (this._min === null) {
      // minimum
      var m = null;
      // compute min
      this.forEach(function (v) {
        if (m === null || smaller(v, m))
          m = v;
      });
      this._min = m !== null ? m : undefined;
    }
    return this._min;
  };

  /**
   * Calculate the maximum value in the set
   * @return {Number | undefined} max
   */
  ImmutableDenseMatrix.prototype.max = function () {
    // check max has been calculated before
    if (this._max === null) {
      // maximum
      var m = null;
      // compute max
      this.forEach(function (v) {
        if (m === null || smaller(m, v))
          m = v;
      });
      this._max = m !== null ? m : undefined;
    }
    return this._max;
  };

  // exports
  return ImmutableDenseMatrix;
}

exports.name = 'ImmutableDenseMatrix';
exports.path = 'type';
exports.factory = factory;

},{"../../function/relational/smaller":356,"../../utils/index":481,"./DenseMatrix":426}],429:[function(require,module,exports){
'use strict';

var util = require('../../utils/index');

var string = util.string;

var isString = string.isString;

function factory (type, config, load, typed) {
  /**
   * @constructor Matrix
   *
   * A Matrix is a wrapper around an Array. A matrix can hold a multi dimensional
   * array. A matrix can be constructed as:
   *     var matrix = math.matrix(data)
   *
   * Matrix contains the functions to resize, get and set values, get the size,
   * clone the matrix and to convert the matrix to a vector, array, or scalar.
   * Furthermore, one can iterate over the matrix using map and forEach.
   * The internal Array of the Matrix can be accessed using the function valueOf.
   *
   * Example usage:
   *     var matrix = math.matrix([[1, 2], [3, 4]]);
   *     matix.size();              // [2, 2]
   *     matrix.resize([3, 2], 5);
   *     matrix.valueOf();          // [[1, 2], [3, 4], [5, 5]]
   *     matrix.subset([1,2])       // 3 (indexes are zero-based)
   *
   */
  function Matrix() {
    if (!(this instanceof Matrix)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }
  }

  /**
   * Attach type information
   */
  Matrix.prototype.type = 'Matrix';
  Matrix.prototype.isMatrix = true;

  /**
   * Get the Matrix storage constructor for the given format.
   *
   * @param {string} format       The Matrix storage format.
   *
   * @return {Function}           The Matrix storage constructor.
   */
  Matrix.storage = function (format) {
    // check storage format is a string
    if (!isString(format)) {
      throw new TypeError('format must be a string value');
    }

    // get storage format constructor
    var constructor = Matrix._storage[format];
    if (!constructor) {
      throw new SyntaxError('Unsupported matrix storage format: ' + format);
    }

    // return storage constructor
    return constructor;
  };

  // a map with all constructors for all storage types
  Matrix._storage = {};

  /**
   * Get the storage format used by the matrix.
   *
   * Usage:
   *     var format = matrix.storage()                   // retrieve storage format
   *
   * @return {string}           The storage format.
   */
  Matrix.prototype.storage = function () {
    // must be implemented by each of the Matrix implementations
    throw new Error('Cannot invoke storage on a Matrix interface');
  };
  
  /**
   * Get the datatype of the data stored in the matrix.
   *
   * Usage:
   *     var format = matrix.datatype()                   // retrieve matrix datatype
   *
   * @return {string}           The datatype.
   */
  Matrix.prototype.datatype = function () {
    // must be implemented by each of the Matrix implementations
    throw new Error('Cannot invoke datatype on a Matrix interface');
  };

  /**
   * Create a new Matrix With the type of the current matrix instance
   * @param {Array | Object} data
   * @param {string} [datatype]
   */
  Matrix.prototype.create = function (data, datatype) {
    throw new Error('Cannot invoke create on a Matrix interface');
  };

  /**
   * Get a subset of the matrix, or replace a subset of the matrix.
   *
   * Usage:
   *     var subset = matrix.subset(index)               // retrieve subset
   *     var value = matrix.subset(index, replacement)   // replace subset
   *
   * @param {Index} index
   * @param {Array | Matrix | *} [replacement]
   * @param {*} [defaultValue=0]      Default value, filled in on new entries when
   *                                  the matrix is resized. If not provided,
   *                                  new matrix elements will be filled with zeros.
   */
  Matrix.prototype.subset = function (index, replacement, defaultValue) {
    // must be implemented by each of the Matrix implementations
    throw new Error('Cannot invoke subset on a Matrix interface');
  };

  /**
   * Get a single element from the matrix.
   * @param {number[]} index   Zero-based index
   * @return {*} value
   */
  Matrix.prototype.get = function (index) {
    // must be implemented by each of the Matrix implementations
    throw new Error('Cannot invoke get on a Matrix interface');
  };

  /**
   * Replace a single element in the matrix.
   * @param {number[]} index   Zero-based index
   * @param {*} value
   * @param {*} [defaultValue]        Default value, filled in on new entries when
   *                                  the matrix is resized. If not provided,
   *                                  new matrix elements will be left undefined.
   * @return {Matrix} self
   */
  Matrix.prototype.set = function (index, value, defaultValue) {
    // must be implemented by each of the Matrix implementations
    throw new Error('Cannot invoke set on a Matrix interface');
  };

  /**
   * Resize the matrix to the given size. Returns a copy of the matrix when 
   * `copy=true`, otherwise return the matrix itself (resize in place).
   *
   * @param {number[]} size           The new size the matrix should have.
   * @param {*} [defaultValue=0]      Default value, filled in on new entries.
   *                                  If not provided, the matrix elements will
   *                                  be filled with zeros.
   * @param {boolean} [copy]          Return a resized copy of the matrix
   *
   * @return {Matrix}                 The resized matrix
   */
  Matrix.prototype.resize = function (size, defaultValue) {
    // must be implemented by each of the Matrix implementations
    throw new Error('Cannot invoke resize on a Matrix interface');
  };

  /**
   * Create a clone of the matrix
   * @return {Matrix} clone
   */
  Matrix.prototype.clone = function () {
    // must be implemented by each of the Matrix implementations
    throw new Error('Cannot invoke clone on a Matrix interface');
  };

  /**
   * Retrieve the size of the matrix.
   * @returns {number[]} size
   */
  Matrix.prototype.size = function() {
    // must be implemented by each of the Matrix implementations
    throw new Error('Cannot invoke size on a Matrix interface');
  };

  /**
   * Create a new matrix with the results of the callback function executed on
   * each entry of the matrix.
   * @param {Function} callback   The callback function is invoked with three
   *                              parameters: the value of the element, the index
   *                              of the element, and the Matrix being traversed.
   * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.
   *
   * @return {Matrix} matrix
   */
  Matrix.prototype.map = function (callback, skipZeros) {
    // must be implemented by each of the Matrix implementations
    throw new Error('Cannot invoke map on a Matrix interface');
  };

  /**
   * Execute a callback function on each entry of the matrix.
   * @param {Function} callback   The callback function is invoked with three
   *                              parameters: the value of the element, the index
   *                              of the element, and the Matrix being traversed.
   */
  Matrix.prototype.forEach = function (callback) {
    // must be implemented by each of the Matrix implementations
    throw new Error('Cannot invoke forEach on a Matrix interface');
  };

  /**
   * Create an Array with a copy of the data of the Matrix
   * @returns {Array} array
   */
  Matrix.prototype.toArray = function () {
    // must be implemented by each of the Matrix implementations
    throw new Error('Cannot invoke toArray on a Matrix interface');
  };

  /**
   * Get the primitive value of the Matrix: a multidimensional array
   * @returns {Array} array
   */
  Matrix.prototype.valueOf = function () {
    // must be implemented by each of the Matrix implementations
    throw new Error('Cannot invoke valueOf on a Matrix interface');
  };

  /**
   * Get a string representation of the matrix, with optional formatting options.
   * @param {Object | number | Function} [options]  Formatting options. See
   *                                                lib/utils/number:format for a
   *                                                description of the available
   *                                                options.
   * @returns {string} str
   */
  Matrix.prototype.format = function (options) {
    // must be implemented by each of the Matrix implementations
    throw new Error('Cannot invoke format on a Matrix interface');
  };

  /**
   * Get a string representation of the matrix
   * @returns {string} str
   */
  Matrix.prototype.toString = function () {
    // must be implemented by each of the Matrix implementations
    throw new Error('Cannot invoke toString on a Matrix interface');
  };
   
  // exports
  return Matrix;
}

exports.name = 'Matrix';
exports.path = 'type';
exports.factory = factory;

},{"../../utils/index":481}],430:[function(require,module,exports){
'use strict';

var clone = require('../../utils/object').clone;
var isInteger = require('../../utils/number').isInteger;

function factory (type) {
  
  /**
   * Create an index. An Index can store ranges and sets for multiple dimensions.
   * Matrix.get, Matrix.set, and math.subset accept an Index as input.
   *
   * Usage:
   *     var index = new Index(range1, range2, matrix1, array1, ...);
   *
   * Where each parameter can be any of:
   *     A number
   *     A string (containing a name of an object property)
   *     An instance of Range
   *     An Array with the Set values
   *     A Matrix with the Set values
   *
   * The parameters start, end, and step must be integer numbers.
   *
   * @class Index
   * @Constructor Index
   * @param {...*} ranges
   */
  function Index(ranges) {
    if (!(this instanceof Index)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    this._dimensions = [];
    this._isScalar = true;

    for (var i = 0, ii = arguments.length; i < ii; i++) {
      var arg = arguments[i];

      if (arg && (arg.isRange === true)) {
        this._dimensions.push(arg);
        this._isScalar = false;
      }
      else if (arg && (Array.isArray(arg) || arg.isMatrix === true)) {
        // create matrix
        var m = _createImmutableMatrix(arg.valueOf());
        this._dimensions.push(m);
        // size
        var size = m.size();
        // scalar
        if (size.length !== 1 || size[0] !== 1) {
          this._isScalar = false;
        }
      }
      else if (typeof arg === 'number') {
        this._dimensions.push(_createImmutableMatrix([arg]));
      }
      else if (typeof arg === 'string') {
        // object property (arguments.count should be 1)
        this._dimensions.push(arg);
      }
      // TODO: implement support for wildcard '*'
      else {
        throw new TypeError('Dimension must be an Array, Matrix, number, string, or Range');
      }
    }
  }

  /**
   * Attach type information
   */
  Index.prototype.type = 'Index';
  Index.prototype.isIndex = true;

  function _createImmutableMatrix(arg) {
    // loop array elements
    for (var i = 0, l = arg.length; i < l; i++) {
      if (typeof arg[i] !== 'number' || !isInteger(arg[i])) {
        throw new TypeError('Index parameters must be positive integer numbers');
      }
    }
    // create matrix
    return new type.ImmutableDenseMatrix(arg);
  }

  /**
   * Create a clone of the index
   * @memberof Index
   * @return {Index} clone
   */
  Index.prototype.clone = function () {
    var index = new Index();
    index._dimensions = clone(this._dimensions);
    index._isScalar = this._isScalar;
    return index;
  };

  /**
   * Create an index from an array with ranges/numbers
   * @memberof Index
   * @param {Array.<Array | number>} ranges
   * @return {Index} index
   * @private
   */
  Index.create = function (ranges) {
    var index = new Index();
    Index.apply(index, ranges);
    return index;
  };

  /**
   * Retrieve the size of the index, the number of elements for each dimension.
   * @memberof Index
   * @returns {number[]} size
   */
  Index.prototype.size = function () {
    var size = [];

    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
      var d = this._dimensions[i];
      size[i] = (typeof d === 'string') ? 1 : d.size()[0];
    }

    return size;
  };

  /**
   * Get the maximum value for each of the indexes ranges.
   * @memberof Index
   * @returns {number[]} max
   */
  Index.prototype.max = function () {
    var values = [];

    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
      var range = this._dimensions[i];
      values[i] = (typeof range === 'string') ? range : range.max();
    }

    return values;
  };

  /**
   * Get the minimum value for each of the indexes ranges.
   * @memberof Index
   * @returns {number[]} min
   */
  Index.prototype.min = function () {
    var values = [];

    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
      var range = this._dimensions[i];
      values[i] = (typeof range === 'string') ? range : range.min();
    }

    return values;
  };

  /**
   * Loop over each of the ranges of the index
   * @memberof Index
   * @param {Function} callback   Called for each range with a Range as first
   *                              argument, the dimension as second, and the
   *                              index object as third.
   */
  Index.prototype.forEach = function (callback) {
    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
      callback(this._dimensions[i], i, this);
    }
  };

  /**
   * Retrieve the dimension for the given index
   * @memberof Index
   * @param {Number} dim                  Number of the dimension
   * @returns {Range | null} range
   */
  Index.prototype.dimension = function (dim) {
    return this._dimensions[dim] || null;
  };

  /**
   * Test whether this index contains an object property
   * @returns {boolean} Returns true if the index is an object property
   */
  Index.prototype.isObjectProperty = function () {
    return this._dimensions.length === 1 && typeof this._dimensions[0] === 'string';
  };

  /**
   * Returns the object property name when the Index holds a single object property,
   * else returns null
   * @returns {string | null}
   */
  Index.prototype.getObjectProperty = function () {
    return this.isObjectProperty() ? this._dimensions[0] : null;
  };

  /**
   * Test whether this index contains only a single value.
   *
   * This is the case when the index is created with only scalar values as ranges,
   * not for ranges resolving into a single value.
   * @memberof Index
   * @return {boolean} isScalar
   */
  Index.prototype.isScalar = function () {
    return this._isScalar;
  };

  /**
   * Expand the Index into an array.
   * For example new Index([0,3], [2,7]) returns [[0,1,2], [2,3,4,5,6]]
   * @memberof Index
   * @returns {Array} array
   */
  Index.prototype.toArray = function () {
    var array = [];
    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
      var dimension = this._dimensions[i];
      array.push((typeof dimension === 'string') ? dimension : dimension.toArray());
    }
    return array;
  };

  /**
   * Get the primitive value of the Index, a two dimensional array.
   * Equivalent to Index.toArray().
   * @memberof Index
   * @returns {Array} array
   */
  Index.prototype.valueOf = Index.prototype.toArray;

  /**
   * Get the string representation of the index, for example '[2:6]' or '[0:2:10, 4:7, [1,2,3]]'
   * @memberof Index
   * @returns {String} str
   */
  Index.prototype.toString = function () {
    var strings = [];

    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
      var dimension = this._dimensions[i];
      if (typeof dimension === 'string') {
        strings.push(JSON.stringify(dimension));
      }
      else {
        strings.push(dimension.toString());
      }
    }

    return '[' + strings.join(', ') + ']';
  };

  /**
   * Get a JSON representation of the Index
   * @memberof Index
   * @returns {Object} Returns a JSON object structured as:
   *                   `{"mathjs": "Index", "ranges": [{"mathjs": "Range", start: 0, end: 10, step:1}, ...]}`
   */
  Index.prototype.toJSON = function () {
    return {
      mathjs: 'Index',
      dimensions: this._dimensions
    };
  };

  /**
   * Instantiate an Index from a JSON object
   * @memberof Index
   * @param {Object} json A JSON object structured as:
   *                     `{"mathjs": "Index", "dimensions": [{"mathjs": "Range", start: 0, end: 10, step:1}, ...]}`
   * @return {Index}
   */
  Index.fromJSON = function (json) {
    return Index.create(json.dimensions);
  };

  return Index;
}

exports.name = 'Index';
exports.path = 'type';
exports.factory = factory;

},{"../../utils/number":483,"../../utils/object":484}],431:[function(require,module,exports){
'use strict';

var number = require('../../utils/number');

function factory (type, config, load, typed) {
  /**
   * Create a range. A range has a start, step, and end, and contains functions
   * to iterate over the range.
   *
   * A range can be constructed as:
   *     var range = new Range(start, end);
   *     var range = new Range(start, end, step);
   *
   * To get the result of the range:
   *     range.forEach(function (x) {
   *         console.log(x);
   *     });
   *     range.map(function (x) {
   *         return math.sin(x);
   *     });
   *     range.toArray();
   *
   * Example usage:
   *     var c = new Range(2, 6);         // 2:1:5
   *     c.toArray();                     // [2, 3, 4, 5]
   *     var d = new Range(2, -3, -1);    // 2:-1:-2
   *     d.toArray();                     // [2, 1, 0, -1, -2]
   *
   * @class Range
   * @constructor Range
   * @param {number} start  included lower bound
   * @param {number} end    excluded upper bound
   * @param {number} [step] step size, default value is 1
   */
  function Range(start, end, step) {
    if (!(this instanceof Range)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    if (start != null) {
      if (start.isBigNumber === true)
        start = start.toNumber();
      else if (typeof start !== 'number')
        throw new TypeError('Parameter start must be a number');
    }
    if (end != null) {
      if (end.isBigNumber === true)
        end = end.toNumber();
      else if (typeof end !== 'number')
        throw new TypeError('Parameter end must be a number');
    }
    if (step != null) {
      if (step.isBigNumber === true)
        step = step.toNumber();
      else if (typeof step !== 'number')
        throw new TypeError('Parameter step must be a number');
    }

    this.start = (start != null) ? parseFloat(start) : 0;
    this.end   = (end != null)   ? parseFloat(end)   : 0;
    this.step  = (step != null)  ? parseFloat(step)  : 1;
  }

  /**
   * Attach type information
   */
  Range.prototype.type = 'Range';
  Range.prototype.isRange = true;

  /**
   * Parse a string into a range,
   * The string contains the start, optional step, and end, separated by a colon.
   * If the string does not contain a valid range, null is returned.
   * For example str='0:2:11'.
   * @memberof Range
   * @param {string} str
   * @return {Range | null} range
   */
  Range.parse = function (str) {
    if (typeof str !== 'string') {
      return null;
    }

    var args = str.split(':');
    var nums = args.map(function (arg) {
      return parseFloat(arg);
    });

    var invalid = nums.some(function (num) {
      return isNaN(num);
    });
    if (invalid) {
      return null;
    }

    switch (nums.length) {
      case 2:
        return new Range(nums[0], nums[1]);
      case 3:
        return new Range(nums[0], nums[2], nums[1]);
      default:
        return null;
    }
  };

  /**
   * Create a clone of the range
   * @return {Range} clone
   */
  Range.prototype.clone = function () {
    return new Range(this.start, this.end, this.step);
  };

  /**
   * Retrieve the size of the range.
   * Returns an array containing one number, the number of elements in the range.
   * @memberof Range
   * @returns {number[]} size
   */
  Range.prototype.size = function () {
    var len = 0,
        start = this.start,
        step = this.step,
        end = this.end,
        diff = end - start;

    if (number.sign(step) == number.sign(diff)) {
      len = Math.ceil((diff) / step);
    }
    else if (diff == 0) {
      len = 0;
    }

    if (isNaN(len)) {
      len = 0;
    }
    return [len];
  };

  /**
   * Calculate the minimum value in the range
   * @memberof Range
   * @return {number | undefined} min
   */
  Range.prototype.min = function () {
    var size = this.size()[0];

    if (size > 0) {
      if (this.step > 0) {
        // positive step
        return this.start;
      }
      else {
        // negative step
        return this.start + (size - 1) * this.step;
      }
    }
    else {
      return undefined;
    }
  };

  /**
   * Calculate the maximum value in the range
   * @memberof Range
   * @return {number | undefined} max
   */
  Range.prototype.max = function () {
    var size = this.size()[0];

    if (size > 0) {
      if (this.step > 0) {
        // positive step
        return this.start + (size - 1) * this.step;
      }
      else {
        // negative step
        return this.start;
      }
    }
    else {
      return undefined;
    }
  };


  /**
   * Execute a callback function for each value in the range.
   * @memberof Range
   * @param {function} callback   The callback method is invoked with three
   *                              parameters: the value of the element, the index
   *                              of the element, and the Range being traversed.
   */
  Range.prototype.forEach = function (callback) {
    var x = this.start;
    var step = this.step;
    var end = this.end;
    var i = 0;

    if (step > 0) {
      while (x < end) {
        callback(x, [i], this);
        x += step;
        i++;
      }
    }
    else if (step < 0) {
      while (x > end) {
        callback(x, [i], this);
        x += step;
        i++;
      }
    }
  };

  /**
   * Execute a callback function for each value in the Range, and return the
   * results as an array
   * @memberof Range
   * @param {function} callback   The callback method is invoked with three
   *                              parameters: the value of the element, the index
   *                              of the element, and the Matrix being traversed.
   * @returns {Array} array
   */
  Range.prototype.map = function (callback) {
    var array = [];
    this.forEach(function (value, index, obj) {
      array[index[0]] = callback(value, index, obj);
    });
    return array;
  };

  /**
   * Create an Array with a copy of the Ranges data
   * @memberof Range
   * @returns {Array} array
   */
  Range.prototype.toArray = function () {
    var array = [];
    this.forEach(function (value, index) {
      array[index[0]] = value;
    });
    return array;
  };

  /**
   * Get the primitive value of the Range, a one dimensional array
   * @memberof Range
   * @returns {Array} array
   */
  Range.prototype.valueOf = function () {
    // TODO: implement a caching mechanism for range.valueOf()
    return this.toArray();
  };

  /**
   * Get a string representation of the range, with optional formatting options.
   * Output is formatted as 'start:step:end', for example '2:6' or '0:0.2:11'
   * @memberof Range
   * @param {Object | number | function} [options]  Formatting options. See
   *                                                lib/utils/number:format for a
   *                                                description of the available
   *                                                options.
   * @returns {string} str
   */
  Range.prototype.format = function (options) {
    var str = number.format(this.start, options);

    if (this.step != 1) {
      str += ':' + number.format(this.step, options);
    }
    str += ':' + number.format(this.end, options);
    return str;
  };

  /**
   * Get a string representation of the range.
   * @memberof Range
   * @returns {string}
   */
  Range.prototype.toString = function () {
    return this.format();
  };

  /**
   * Get a JSON representation of the range
   * @memberof Range
   * @returns {Object} Returns a JSON object structured as:
   *                   `{"mathjs": "Range", "start": 2, "end": 4, "step": 1}`
   */
  Range.prototype.toJSON = function () {
    return {
      mathjs: 'Range',
      start: this.start,
      end: this.end,
      step: this.step
    };
  };

  /**
   * Instantiate a Range from a JSON object
   * @memberof Range
   * @param {Object} json A JSON object structured as:
   *                      `{"mathjs": "Range", "start": 2, "end": 4, "step": 1}`
   * @return {Range}
   */
  Range.fromJSON = function (json) {
    return new Range(json.start, json.end, json.step);
  };

  return Range;
}

exports.name = 'Range';
exports.path = 'type';
exports.factory = factory;

},{"../../utils/number":483}],432:[function(require,module,exports){
'use strict';

function factory (type, config, load) {
  
  var add = load(require('../../function/arithmetic/add'));
  var equalScalar = load(require('../../function/relational/equalScalar'));
  
  /**
   * An ordered Sparse Accumulator is a representation for a sparse vector that includes a dense array 
   * of the vector elements and an ordered list of non-zero elements.
   */
  function Spa() {
    if (!(this instanceof Spa))
      throw new SyntaxError('Constructor must be called with the new operator');
    
    // allocate vector, TODO use typed arrays
    this._values = [];
    this._heap = new type.FibonacciHeap();
  }

  /**
   * Attach type information
   */
  Spa.prototype.type = 'Spa';
  Spa.prototype.isSpa = true;

  /**
   * Set the value for index i.
   *
   * @param {number} i                       The index
   * @param {number | BigNumber | Complex}   The value at index i
   */
  Spa.prototype.set = function (i, v) {
    // check we have a value @ i
    if (!this._values[i]) {
      // insert in heap
      var node = this._heap.insert(i, v);
      // set the value @ i
      this._values[i] = node;
    }
    else {
      // update the value @ i
      this._values[i].value = v;
    }
  };
  
  Spa.prototype.get = function (i) {
    var node = this._values[i];
    if (node)
      return node.value;
    return 0;
  };
  
  Spa.prototype.accumulate = function (i, v) {
    // node @ i
    var node = this._values[i];
    if (!node) {
      // insert in heap
      node = this._heap.insert(i, v);
      // initialize value
      this._values[i] = node;
    }
    else {
      // accumulate value
      node.value = add(node.value, v);
    }
  };
  
  Spa.prototype.forEach = function (from, to, callback) {
    // references
    var heap = this._heap;
    var values = this._values;
    // nodes
    var nodes = [];
    // node with minimum key, save it
    var node = heap.extractMinimum();
    if (node)
      nodes.push(node);
    // extract nodes from heap (ordered)
    while (node && node.key <= to) {
      // check it is in range
      if (node.key >= from) {
        // check value is not zero
        if (!equalScalar(node.value, 0)) {
          // invoke callback
          callback(node.key, node.value, this);
        }
      }
      // extract next node, save it
      node = heap.extractMinimum();
      if (node)
        nodes.push(node);
    }
    // reinsert all nodes in heap
    for (var i = 0; i < nodes.length; i++) {
      // current node
      var n = nodes[i];
      // insert node in heap
      node = heap.insert(n.key, n.value);
      // update values
      values[node.key] = node;
    }
  };
  
  Spa.prototype.swap = function (i, j) {
    // node @ i and j
    var nodei = this._values[i];
    var nodej = this._values[j];
    // check we need to insert indeces
    if (!nodei && nodej) {
      // insert in heap
      nodei = this._heap.insert(i, nodej.value);
      // remove from heap
      this._heap.remove(nodej);
      // set values
      this._values[i] = nodei;
      this._values[j] = undefined;
    }
    else if (nodei && !nodej) {
      // insert in heap
      nodej = this._heap.insert(j, nodei.value);
      // remove from heap
      this._heap.remove(nodei);
      // set values
      this._values[j] = nodej;
      this._values[i] = undefined;
    }
    else if (nodei && nodej) {
      // swap values
      var v = nodei.value;
      nodei.value = nodej.value;
      nodej.value = v;
    }
  };
  
  return Spa;
}

exports.name = 'Spa';
exports.path = 'type';
exports.factory = factory;

},{"../../function/arithmetic/add":255,"../../function/relational/equalScalar":352}],433:[function(require,module,exports){
'use strict';

var util = require('../../utils/index');
var DimensionError = require('../../error/DimensionError');

var array = util.array;
var object = util.object;
var string = util.string;
var number = util.number;

var isArray = Array.isArray;
var isNumber = number.isNumber;
var isInteger = number.isInteger;
var isString = string.isString;

var validateIndex = array.validateIndex;

function factory (type, config, load, typed) {
  var Matrix = load(require('./Matrix')); // force loading Matrix (do not use via type.Matrix)
  var equalScalar = load(require('../../function/relational/equalScalar'));

  /**
   * Sparse Matrix implementation. This type implements a Compressed Column Storage format
   * for sparse matrices.
   * @class SparseMatrix
   */
  function SparseMatrix(data, datatype) {
    if (!(this instanceof SparseMatrix))
      throw new SyntaxError('Constructor must be called with the new operator');
    if (datatype && !isString(datatype))
      throw new Error('Invalid datatype: ' + datatype);
    
    if (data && data.isMatrix === true) {
      // create from matrix
      _createFromMatrix(this, data, datatype);
    }
    else if (data && isArray(data.index) && isArray(data.ptr) && isArray(data.size)) {
      // initialize fields
      this._values = data.values;
      this._index = data.index;
      this._ptr = data.ptr;
      this._size = data.size;
      this._datatype = datatype || data.datatype;
    }
    else if (isArray(data)) {
      // create from array
      _createFromArray(this, data, datatype);
    }
    else if (data) {
      // unsupported type
      throw new TypeError('Unsupported type of data (' + util.types.type(data) + ')');
    }
    else {
      // nothing provided
      this._values = [];
      this._index = [];
      this._ptr = [0];
      this._size = [0, 0];
      this._datatype = datatype;
    }
  }
  
  var _createFromMatrix = function (matrix, source, datatype) {
    // check matrix type
    if (source.type === 'SparseMatrix') {
      // clone arrays
      matrix._values = source._values ? object.clone(source._values) : undefined;
      matrix._index = object.clone(source._index);
      matrix._ptr = object.clone(source._ptr);
      matrix._size = object.clone(source._size);
      matrix._datatype = datatype || source._datatype;
    }
    else {
      // build from matrix data
      _createFromArray(matrix, source.valueOf(), datatype || source._datatype);
    }
  };
  
  var _createFromArray = function (matrix, data, datatype) {
    // initialize fields
    matrix._values = [];
    matrix._index = [];
    matrix._ptr = [];
    matrix._datatype = datatype;
    // discover rows & columns, do not use math.size() to avoid looping array twice
    var rows = data.length;
    var columns = 0;
    
    // equal signature to use
    var eq = equalScalar;
    // zero value
    var zero = 0;
    
    if (isString(datatype)) {
      // find signature that matches (datatype, datatype)
      eq = typed.find(equalScalar, [datatype, datatype]) || equalScalar;
      // convert 0 to the same datatype
      zero = typed.convert(0, datatype);
    }

    // check we have rows (empty array)
    if (rows > 0) {
      // column index
      var j = 0;
      do {
        // store pointer to values index
        matrix._ptr.push(matrix._index.length);
        // loop rows
        for (var i = 0; i < rows; i++) {
          // current row
          var row = data[i];
          // check row is an array
          if (isArray(row)) {
            // update columns if needed (only on first column)
            if (j === 0 && columns < row.length)
              columns = row.length;
            // check row has column
            if (j < row.length) {
              // value
              var v = row[j];
              // check value != 0
              if (!eq(v, zero)) {
                // store value
                matrix._values.push(v);
                // index
                matrix._index.push(i);
              }
            }
          }
          else {
            // update columns if needed (only on first column)
            if (j === 0 && columns < 1)
              columns = 1;
            // check value != 0 (row is a scalar)
            if (!eq(row, zero)) {
              // store value
              matrix._values.push(row);
              // index
              matrix._index.push(i);
            }
          }
        }
        // increment index
        j++;      
      }
      while (j < columns);
    }
    // store number of values in ptr
    matrix._ptr.push(matrix._index.length);
    // size
    matrix._size = [rows, columns];
  };
  
  SparseMatrix.prototype = new Matrix();

  /**
   * Attach type information
   */
  SparseMatrix.prototype.type = 'SparseMatrix';
  SparseMatrix.prototype.isSparseMatrix = true;

  /**
   * Get the storage format used by the matrix.
   *
   * Usage:
   *     var format = matrix.storage()                   // retrieve storage format
   *
   * @memberof SparseMatrix
   * @return {string}           The storage format.
   */
  SparseMatrix.prototype.storage = function () {
    return 'sparse';
  };

  /**
   * Get the datatype of the data stored in the matrix.
   *
   * Usage:
   *     var format = matrix.datatype()                   // retrieve matrix datatype
   *
   * @memberof SparseMatrix
   * @return {string}           The datatype.
   */
  SparseMatrix.prototype.datatype = function () {
    return this._datatype;
  };

  /**
   * Create a new SparseMatrix
   * @memberof SparseMatrix
   * @param {Array} data
   * @param {string} [datatype]
   */
  SparseMatrix.prototype.create = function (data, datatype) {
    return new SparseMatrix(data, datatype);
  };

  /**
   * Get the matrix density.
   *
   * Usage:
   *     var density = matrix.density()                   // retrieve matrix density
   *
   * @memberof SparseMatrix
   * @return {number}           The matrix density.
   */
  SparseMatrix.prototype.density = function () {
    // rows & columns
    var rows = this._size[0];
    var columns = this._size[1];
    // calculate density
    return rows !== 0 && columns !== 0 ? (this._index.length / (rows * columns)) : 0;
  };
  
  /**
   * Get a subset of the matrix, or replace a subset of the matrix.
   *
   * Usage:
   *     var subset = matrix.subset(index)               // retrieve subset
   *     var value = matrix.subset(index, replacement)   // replace subset
   *
   * @memberof SparseMatrix
   * @param {Index} index
   * @param {Array | Maytrix | *} [replacement]
   * @param {*} [defaultValue=0]      Default value, filled in on new entries when
   *                                  the matrix is resized. If not provided,
   *                                  new matrix elements will be filled with zeros.
   */
  SparseMatrix.prototype.subset = function (index, replacement, defaultValue) { // check it is a pattern matrix
    if (!this._values)
      throw new Error('Cannot invoke subset on a Pattern only matrix');

    // check arguments
    switch (arguments.length) {
      case 1:
        return _getsubset(this, index);

        // intentional fall through
      case 2:
      case 3:
        return _setsubset(this, index, replacement, defaultValue);

      default:
        throw new SyntaxError('Wrong number of arguments');
    }
  };
  
  var _getsubset = function (matrix, idx) {
    // check idx
    if (!idx || idx.isIndex !== true) {
      throw new TypeError('Invalid index');
    }

    var isScalar = idx.isScalar();
    if (isScalar) {
      // return a scalar
      return matrix.get(idx.min());
    }
    // validate dimensions
    var size = idx.size();
    if (size.length != matrix._size.length) {
      throw new DimensionError(size.length, matrix._size.length);
    }

    // vars
    var i, ii, k, kk;
    
    // validate if any of the ranges in the index is out of range
    var min = idx.min();
    var max = idx.max();
    for (i = 0, ii = matrix._size.length; i < ii; i++) {
      validateIndex(min[i], matrix._size[i]);
      validateIndex(max[i], matrix._size[i]);
    }
    
    // matrix arrays
    var mvalues = matrix._values;
    var mindex = matrix._index;
    var mptr = matrix._ptr;
        
    // rows & columns dimensions for result matrix
    var rows = idx.dimension(0);
    var columns = idx.dimension(1);
    
    // workspace & permutation vector
    var w = [];
    var pv = [];
    
    // loop rows in resulting matrix
    rows.forEach(function (i, r) {
      // update permutation vector
      pv[i] = r[0];  
      // mark i in workspace
      w[i] = true;
    });

    // result matrix arrays
    var values = mvalues ? [] : undefined;
    var index = [];
    var ptr = [];
        
    // loop columns in result matrix
    columns.forEach(function (j) {
      // update ptr
      ptr.push(index.length);
      // loop values in column j
      for (k = mptr[j], kk = mptr[j + 1]; k < kk; k++) {
        // row
        i = mindex[k];
        // check row is in result matrix
        if (w[i] === true) {
          // push index
          index.push(pv[i]);
          // check we need to process values
          if (values)
            values.push(mvalues[k]);
        }
      }
    });
    // update ptr
    ptr.push(index.length);
    
    // return matrix
    return new SparseMatrix({
      values: values,
      index: index,
      ptr: ptr,
      size: size,
      datatype: matrix._datatype
    });
  };
  
  var _setsubset = function (matrix, index, submatrix, defaultValue) {
    // check index
    if (!index || index.isIndex !== true) {
      throw new TypeError('Invalid index');
    }
    
    // get index size and check whether the index contains a single value
    var iSize = index.size(),
        isScalar = index.isScalar();
    
    // calculate the size of the submatrix, and convert it into an Array if needed
    var sSize;
    if (submatrix && submatrix.isMatrix === true) {
      // submatrix size
      sSize = submatrix.size();
      // use array representation
      submatrix = submatrix.toArray();
    }
    else {
      // get submatrix size (array, scalar)
      sSize = array.size(submatrix);
    }
    
    // check index is a scalar
    if (isScalar) {
      // verify submatrix is a scalar
      if (sSize.length !== 0) {
        throw new TypeError('Scalar expected');
      }
      // set value
      matrix.set(index.min(), submatrix, defaultValue);
    }
    else {
      // validate dimensions, index size must be one or two dimensions
      if (iSize.length !== 1 && iSize.length !== 2) {
        throw new DimensionError(iSize.length, matrix._size.length, '<');
      }
      
      // check submatrix and index have the same dimensions
      if (sSize.length < iSize.length) {
        // calculate number of missing outer dimensions
        var i = 0;
        var outer = 0;
        while (iSize[i] === 1 && sSize[i] === 1) {
          i++;
        }
        while (iSize[i] === 1) {
          outer++;
          i++;
        }
        // unsqueeze both outer and inner dimensions
        submatrix = array.unsqueeze(submatrix, iSize.length, outer, sSize);
      }
      
      // check whether the size of the submatrix matches the index size
      if (!object.deepEqual(iSize, sSize)) {
        throw new DimensionError(iSize, sSize, '>');
      }
      
      // offsets
      var x0 = index.min()[0];
      var y0 = index.min()[1];      
      
      // submatrix rows and columns
      var m = sSize[0];
      var n = sSize[1];

      // loop submatrix
      for (var x = 0; x < m; x++) {
        // loop columns
        for (var y = 0; y < n; y++) {
          // value at i, j
          var v = submatrix[x][y];
          // invoke set (zero value will remove entry from matrix)
          matrix.set([x + x0, y + y0], v, defaultValue);
        }
      }
    }
    return matrix;
  };

  /**
   * Get a single element from the matrix.
   * @memberof SparseMatrix
   * @param {number[]} index   Zero-based index
   * @return {*} value
   */
  SparseMatrix.prototype.get = function (index) {
    if (!isArray(index))
      throw new TypeError('Array expected');
    if (index.length != this._size.length)
      throw new DimensionError(index.length, this._size.length);

    // check it is a pattern matrix
    if (!this._values)
      throw new Error('Cannot invoke get on a Pattern only matrix');

    // row and column
    var i = index[0];
    var j = index[1];

    // check i, j are valid
    validateIndex(i, this._size[0]);
    validateIndex(j, this._size[1]);

    // find value index
    var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index);
    // check k is prior to next column k and it is in the correct row
    if (k < this._ptr[j + 1] && this._index[k] === i)
      return this._values[k];

    return 0;
  };
  
  /**
   * Replace a single element in the matrix.
   * @memberof SparseMatrix
   * @param {number[]} index   Zero-based index
   * @param {*} value
   * @param {*} [defaultValue]        Default value, filled in on new entries when
   *                                  the matrix is resized. If not provided,
   *                                  new matrix elements will be set to zero.
   * @return {SparseMatrix} self
   */
  SparseMatrix.prototype.set = function (index, v, defaultValue) {
    if (!isArray(index))
      throw new TypeError('Array expected');
    if (index.length != this._size.length)
      throw new DimensionError(index.length, this._size.length);

    // check it is a pattern matrix
    if (!this._values)
      throw new Error('Cannot invoke set on a Pattern only matrix');
      
    // row and column
    var i = index[0];
    var j = index[1];

    // rows & columns
    var rows = this._size[0];
    var columns = this._size[1];
    
    // equal signature to use
    var eq = equalScalar;
    // zero value
    var zero = 0;

    if (isString(this._datatype)) {
      // find signature that matches (datatype, datatype)
      eq = typed.find(equalScalar, [this._datatype, this._datatype]) || equalScalar;
      // convert 0 to the same datatype
      zero = typed.convert(0, this._datatype);
    }

    // check we need to resize matrix
    if (i > rows - 1 || j > columns - 1) {
      // resize matrix
      _resize(this, Math.max(i + 1, rows), Math.max(j + 1, columns), defaultValue);
      // update rows & columns
      rows = this._size[0];
      columns = this._size[1];
    }

    // check i, j are valid
    validateIndex(i, rows);
    validateIndex(j, columns);

    // find value index
    var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index);
    // check k is prior to next column k and it is in the correct row
    if (k < this._ptr[j + 1] && this._index[k] === i) {
      // check value != 0
      if (!eq(v, zero)) {
        // update value
        this._values[k] = v;
      }
      else {
        // remove value from matrix
        _remove(k, j, this._values, this._index, this._ptr);
      }
    }
    else {
      // insert value @ (i, j)
      _insert(k, i, j, v, this._values, this._index, this._ptr);
    }

    return this;
  };
  
  var _getValueIndex = function(i, top, bottom, index) {
    // check row is on the bottom side
    if (bottom - top === 0)
      return bottom;
    // loop rows [top, bottom[
    for (var r = top; r < bottom; r++) {
      // check we found value index
      if (index[r] === i)
        return r;
    }
    // we did not find row
    return top;
  };

  var _remove = function (k, j, values, index, ptr) {
    // remove value @ k
    values.splice(k, 1);
    index.splice(k, 1);
    // update pointers
    for (var x = j + 1; x < ptr.length; x++)
      ptr[x]--;
  };

  var _insert = function (k, i, j, v, values, index, ptr) {
    // insert value
    values.splice(k, 0, v);
    // update row for k
    index.splice(k, 0, i);
    // update column pointers
    for (var x = j + 1; x < ptr.length; x++)
      ptr[x]++;
  };
  
  /**
   * Resize the matrix to the given size. Returns a copy of the matrix when 
   * `copy=true`, otherwise return the matrix itself (resize in place).
   *
   * @memberof SparseMatrix
   * @param {number[]} size           The new size the matrix should have.
   * @param {*} [defaultValue=0]      Default value, filled in on new entries.
   *                                  If not provided, the matrix elements will
   *                                  be filled with zeros.
   * @param {boolean} [copy]          Return a resized copy of the matrix
   *
   * @return {Matrix}                 The resized matrix
   */
  SparseMatrix.prototype.resize = function (size, defaultValue, copy) {    
    // validate arguments
    if (!isArray(size))
      throw new TypeError('Array expected');
    if (size.length !== 2)
      throw new Error('Only two dimensions matrix are supported');

    // check sizes
    size.forEach(function (value) {
      if (!number.isNumber(value) || !number.isInteger(value) || value < 0) {
        throw new TypeError('Invalid size, must contain positive integers ' +
                            '(size: ' + string.format(size) + ')');
      }
    });
    
    // matrix to resize
    var m = copy ? this.clone() : this;
    // resize matrix
    return _resize(m, size[0], size[1], defaultValue);
  };
  
  var _resize = function (matrix, rows, columns, defaultValue) {
    // value to insert at the time of growing matrix
    var value = defaultValue || 0;
    
    // equal signature to use
    var eq = equalScalar;
    // zero value
    var zero = 0;

    if (isString(matrix._datatype)) {
      // find signature that matches (datatype, datatype)
      eq = typed.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar;
      // convert 0 to the same datatype
      zero = typed.convert(0, matrix._datatype);
      // convert value to the same datatype
      value = typed.convert(value, matrix._datatype);
    }
    
    // should we insert the value?
    var ins = !eq(value, zero);

    // old columns and rows
    var r = matrix._size[0];
    var c = matrix._size[1];

    var i, j, k;

    // check we need to increase columns
    if (columns > c) {
      // loop new columns
      for (j = c; j < columns; j++) {
        // update matrix._ptr for current column
        matrix._ptr[j] = matrix._values.length;
        // check we need to insert matrix._values
        if (ins) {
          // loop rows
          for (i = 0; i < r; i++) {
            // add new matrix._values
            matrix._values.push(value);
            // update matrix._index
            matrix._index.push(i);
          }
        }        
      }
      // store number of matrix._values in matrix._ptr
      matrix._ptr[columns] = matrix._values.length;
    }
    else if (columns < c) {
      // truncate matrix._ptr
      matrix._ptr.splice(columns + 1, c - columns);
      // truncate matrix._values and matrix._index
      matrix._values.splice(matrix._ptr[columns], matrix._values.length);
      matrix._index.splice(matrix._ptr[columns], matrix._index.length);
    }
    // update columns
    c = columns;

    // check we need to increase rows
    if (rows > r) {
      // check we have to insert values
      if (ins) {
        // inserts
        var n = 0;
        // loop columns
        for (j = 0; j < c; j++) {
          // update matrix._ptr for current column
          matrix._ptr[j] = matrix._ptr[j] + n;
          // where to insert matrix._values
          k = matrix._ptr[j + 1] + n;
          // pointer
          var p = 0;
          // loop new rows, initialize pointer
          for (i = r; i < rows; i++, p++) {
            // add value
            matrix._values.splice(k + p, 0, value);
            // update matrix._index
            matrix._index.splice(k + p, 0, i);
            // increment inserts
            n++;
          }
        }
        // store number of matrix._values in matrix._ptr
        matrix._ptr[c] = matrix._values.length;
      }
    }
    else if (rows < r) {
      // deletes
      var d = 0;
      // loop columns
      for (j = 0; j < c; j++) {
        // update matrix._ptr for current column
        matrix._ptr[j] = matrix._ptr[j] - d;
        // where matrix._values start for next column
        var k0 = matrix._ptr[j];
        var k1 = matrix._ptr[j + 1] - d;
        // loop matrix._index
        for (k = k0; k < k1; k++) {
          // row
          i = matrix._index[k];
          // check we need to delete value and matrix._index
          if (i > rows - 1) {
            // remove value
            matrix._values.splice(k, 1);
            // remove item from matrix._index
            matrix._index.splice(k, 1);
            // increase deletes
            d++;
          }
        }
      }
      // update matrix._ptr for current column
      matrix._ptr[j] = matrix._values.length;
    }
    // update matrix._size
    matrix._size[0] = rows;
    matrix._size[1] = columns;
    // return matrix
    return matrix;
  };
  
  /**
   * Create a clone of the matrix
   * @memberof SparseMatrix
   * @return {SparseMatrix} clone
   */
  SparseMatrix.prototype.clone = function () {
    var m = new SparseMatrix({
      values: this._values ? object.clone(this._values) : undefined,
      index: object.clone(this._index),
      ptr: object.clone(this._ptr),
      size: object.clone(this._size),
      datatype: this._datatype
    });
    return m;
  };
  
  /**
   * Retrieve the size of the matrix.
   * @memberof SparseMatrix
   * @returns {number[]} size
   */
  SparseMatrix.prototype.size = function() {
    return this._size.slice(0); // copy the Array
  };
  
  /**
   * Create a new matrix with the results of the callback function executed on
   * each entry of the matrix.
   * @memberof SparseMatrix
   * @param {Function} callback   The callback function is invoked with three
   *                              parameters: the value of the element, the index
   *                              of the element, and the Matrix being traversed.
   * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.
   *
   * @return {SparseMatrix} matrix
   */
  SparseMatrix.prototype.map = function (callback, skipZeros) {
    // check it is a pattern matrix
    if (!this._values)
      throw new Error('Cannot invoke map on a Pattern only matrix');
    // matrix instance
    var me = this;
    // rows and columns
    var rows = this._size[0];
    var columns = this._size[1];
    // invoke callback
    var invoke = function (v, i, j) {
      // invoke callback
      return callback(v, [i, j], me);
    };
    // invoke _map
    return _map(this, 0, rows - 1, 0, columns - 1, invoke, skipZeros);
  };

  /**
   * Create a new matrix with the results of the callback function executed on the interval
   * [minRow..maxRow, minColumn..maxColumn].
   */
  var _map = function (matrix, minRow, maxRow, minColumn, maxColumn, callback, skipZeros) {
    // result arrays
    var values = [];
    var index = [];
    var ptr = [];
    
    // equal signature to use
    var eq = equalScalar;
    // zero value
    var zero = 0;

    if (isString(matrix._datatype)) {
      // find signature that matches (datatype, datatype)
      eq = typed.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar;
      // convert 0 to the same datatype
      zero = typed.convert(0, matrix._datatype);
    }
    
    // invoke callback
    var invoke = function (v, x, y) {
      // invoke callback
      v = callback(v, x, y);
      // check value != 0
      if (!eq(v, zero)) {
        // store value
        values.push(v);
        // index
        index.push(x);
      }
    };
    // loop columns
    for (var j = minColumn; j <= maxColumn; j++) {
      // store pointer to values index
      ptr.push(values.length);
      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
      var k0 = matrix._ptr[j];
      var k1 = matrix._ptr[j + 1];
      // row pointer
      var p = minRow;
      // loop k within [k0, k1[
      for (var k = k0; k < k1; k++) {
        // row index
        var i = matrix._index[k];
        // check i is in range
        if (i >= minRow && i <= maxRow) {
          // zero values
          if (!skipZeros) {
           for (var x = p; x < i; x++)
             invoke(0, x - minRow, j - minColumn);
          }
          // value @ k
          invoke(matrix._values[k], i - minRow, j - minColumn);
        }
        // update pointer
        p = i + 1;
      }
      // zero values
      if (!skipZeros) {
        for (var y = p; y <= maxRow; y++)
          invoke(0, y - minRow, j - minColumn);
      }
    }
    // store number of values in ptr
    ptr.push(values.length);
    // return sparse matrix
    return new SparseMatrix({
      values: values,
      index: index,
      ptr: ptr,
      size: [maxRow - minRow + 1, maxColumn - minColumn + 1]
    });
  };
  
  /**
   * Execute a callback function on each entry of the matrix.
   * @memberof SparseMatrix
   * @param {Function} callback   The callback function is invoked with three
   *                              parameters: the value of the element, the index
   *                              of the element, and the Matrix being traversed.
   * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.
   */
  SparseMatrix.prototype.forEach = function (callback, skipZeros) {
    // check it is a pattern matrix
    if (!this._values)
      throw new Error('Cannot invoke forEach on a Pattern only matrix');
    // matrix instance
    var me = this;
    // rows and columns
    var rows = this._size[0];
    var columns = this._size[1];
    // loop columns
    for (var j = 0; j < columns; j++) {
      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
      var k0 = this._ptr[j];
      var k1 = this._ptr[j + 1];
      // column pointer
      var p = 0;
      // loop k within [k0, k1[
      for (var k = k0; k < k1; k++) {
        // row index
        var i = this._index[k];
        // check we need to process zeros
        if (!skipZeros) {
          // zero values
          for (var x = p; x < i; x++)
            callback(0, [x, j], me);
        }
        // value @ k
        callback(this._values[k], [i, j], me);
        // update pointer
        p = i + 1;
      }
      // check we need to process zeros
      if (!skipZeros) {
        // zero values
        for (var y = p; y < rows; y++)
          callback(0, [y, j], me);
      }
    }
  };
  
  /**
   * Create an Array with a copy of the data of the SparseMatrix
   * @memberof SparseMatrix
   * @returns {Array} array
   */
  SparseMatrix.prototype.toArray = function () {
    return _toArray(this._values, this._index, this._ptr, this._size, true);
  };

  /**
   * Get the primitive value of the SparseMatrix: a two dimensions array
   * @memberof SparseMatrix
   * @returns {Array} array
   */
  SparseMatrix.prototype.valueOf = function () {
    return _toArray(this._values, this._index, this._ptr, this._size, false);
  };
  
  var _toArray = function (values, index, ptr, size, copy) {    
    // rows and columns
    var rows = size[0];
    var columns = size[1];
    // result
    var a = [];
    // vars
    var i, j;
    // initialize array
    for (i = 0; i < rows; i++) {
      a[i] = [];
      for (j = 0; j < columns; j++)
        a[i][j] = 0;
    }

    // loop columns
    for (j = 0; j < columns; j++) {
      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
      var k0 = ptr[j];
      var k1 = ptr[j + 1];
      // loop k within [k0, k1[
      for (var k = k0; k < k1; k++) {
        // row index
        i = index[k];
        // set value (use one for pattern matrix)
        a[i][j] = values ? (copy ? object.clone(values[k]) : values[k]) : 1;
      }
    }
    return a;
  };
  
  /**
   * Get a string representation of the matrix, with optional formatting options.
   * @memberof SparseMatrix
   * @param {Object | number | Function} [options]  Formatting options. See
   *                                                lib/utils/number:format for a
   *                                                description of the available
   *                                                options.
   * @returns {string} str
   */
  SparseMatrix.prototype.format = function (options) {
    // rows and columns
    var rows = this._size[0];
    var columns = this._size[1];
    // density
    var density = this.density();
    // rows & columns
    var str = 'Sparse Matrix [' + string.format(rows, options) + ' x ' + string.format(columns, options) + '] density: ' + string.format(density, options) + '\n';
    // loop columns
    for (var j = 0; j < columns; j++) {
      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
      var k0 = this._ptr[j];
      var k1 = this._ptr[j + 1];
      // loop k within [k0, k1[
      for (var k = k0; k < k1; k++) {
        // row index
        var i = this._index[k];
        // append value
        str += '\n    (' + string.format(i, options) + ', ' + string.format(j, options) + ') ==> ' + (this._values ? string.format(this._values[k], options) : 'X');
      }
    }
    return str;
  };
  
  /**
   * Get a string representation of the matrix
   * @memberof SparseMatrix
   * @returns {string} str
   */
  SparseMatrix.prototype.toString = function () {
    return string.format(this.toArray());
  };
  
  /**
   * Get a JSON representation of the matrix
   * @memberof SparseMatrix
   * @returns {Object}
   */
  SparseMatrix.prototype.toJSON = function () {
    return {
      mathjs: 'SparseMatrix',
      values: this._values,
      index: this._index,
      ptr: this._ptr,
      size: this._size,
      datatype: this._datatype
    };
  };

  /**
   * Get the kth Matrix diagonal.
   *
   * @memberof SparseMatrix
   * @param {number | BigNumber} [k=0]     The kth diagonal where the vector will retrieved.
   *
   * @returns {Matrix}                     The matrix vector with the diagonal values.
   */
  SparseMatrix.prototype.diagonal = function(k) {
    // validate k if any
    if (k) {
      // convert BigNumber to a number
      if (k.isBigNumber === true)
        k = k.toNumber();
      // is must be an integer
      if (!isNumber(k) || !isInteger(k)) {
        throw new TypeError ('The parameter k must be an integer number');
      }
    }
    else {
      // default value
      k = 0;
    }

    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;
    
    // rows & columns
    var rows = this._size[0];
    var columns = this._size[1];
    
    // number diagonal values
    var n = Math.min(rows - kSub, columns -  kSuper);
    
    // diagonal arrays
    var values = [];
    var index = [];
    var ptr = [];
    // initial ptr value
    ptr[0] = 0;
    // loop columns
    for (var j = kSuper; j < columns && values.length < n; j++) {
      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
      var k0 = this._ptr[j];
      var k1 = this._ptr[j + 1];
      // loop x within [k0, k1[
      for (var x = k0; x < k1; x++) {
        // row index
        var i = this._index[x];
        // check row
        if (i === j - kSuper + kSub) {
          // value on this column
          values.push(this._values[x]);
          // store row
          index[values.length - 1] = i - kSub;
          // exit loop
          break;
        }
      }
    }
    // close ptr
    ptr.push(values.length);
    // return matrix
    return new SparseMatrix({
      values: values,
      index: index,
      ptr: ptr,
      size: [n, 1]
    });
  };
  
  /**
   * Generate a matrix from a JSON object
   * @memberof SparseMatrix
   * @param {Object} json  An object structured like
   *                       `{"mathjs": "SparseMatrix", "values": [], "index": [], "ptr": [], "size": []}`,
   *                       where mathjs is optional
   * @returns {SparseMatrix}
   */
  SparseMatrix.fromJSON = function (json) {
    return new SparseMatrix(json);
  };

  /**
   * Create a diagonal matrix.
   *
   * @memberof SparseMatrix
   * @param {Array} size                       The matrix size.
   * @param {number | Array | Matrix } value   The values for the diagonal.
   * @param {number | BigNumber} [k=0]         The kth diagonal where the vector will be filled in.
   * @param {string} [datatype]                The Matrix datatype, values must be of this datatype.
   *
   * @returns {SparseMatrix}
   */
  SparseMatrix.diagonal = function (size, value, k, defaultValue, datatype) {
    if (!isArray(size))
      throw new TypeError('Array expected, size parameter');
    if (size.length !== 2)
      throw new Error('Only two dimensions matrix are supported');
    
    // map size & validate
    size = size.map(function (s) {
      // check it is a big number
      if (s && s.isBigNumber === true) {
        // convert it
        s = s.toNumber();
      }
      // validate arguments
      if (!isNumber(s) || !isInteger(s) || s < 1) {
        throw new Error('Size values must be positive integers');
      } 
      return s;
    });
    
    // validate k if any
    if (k) {
      // convert BigNumber to a number
      if (k.isBigNumber === true)
        k = k.toNumber();
      // is must be an integer
      if (!isNumber(k) || !isInteger(k)) {
        throw new TypeError ('The parameter k must be an integer number');
      }
    }
    else {
      // default value
      k = 0;
    }

    // equal signature to use
    var eq = equalScalar;
    // zero value
    var zero = 0;

    if (isString(datatype)) {
      // find signature that matches (datatype, datatype)
      eq = typed.find(equalScalar, [datatype, datatype]) || equalScalar;
      // convert 0 to the same datatype
      zero = typed.convert(0, datatype);
    }
    
    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;
    
    // rows and columns
    var rows = size[0];
    var columns = size[1];
    
    // number of non-zero items
    var n = Math.min(rows - kSub, columns -  kSuper);
    
    // value extraction function
    var _value;
      
    // check value
    if (isArray(value)) {
      // validate array
      if (value.length !== n) {
        // number of values in array must be n
        throw new Error('Invalid value array length');
      }
      // define function
      _value = function (i) {
        // return value @ i
        return value[i];
      };
    }
    else if (value && value.isMatrix === true) {
      // matrix size
      var ms = value.size();
      // validate matrix
      if (ms.length !== 1 || ms[0] !== n) {
        // number of values in array must be n
        throw new Error('Invalid matrix length');
      }
      // define function
      _value = function (i) {
        // return value @ i
        return value.get([i]);
      };
    }
    else {
      // define function
      _value = function () {
        // return value
        return value;
      };
    }
    
    // create arrays
    var values = [];
    var index = [];
    var ptr = [];
    
    // loop items
    for (var j = 0; j < columns; j++) {
      // number of rows with value
      ptr.push(values.length);
      // diagonal index
      var i = j - kSuper;      
      // check we need to set diagonal value
      if (i >= 0 && i < n) {
        // get value @ i
        var v = _value(i);
        // check for zero
        if (!eq(v, zero)) {
          // column
          index.push(i + kSub);
          // add value
          values.push(v);
        }
      }
    }
    // last value should be number of values
    ptr.push(values.length);
    // create SparseMatrix
    return new SparseMatrix({
      values: values,
      index: index,
      ptr: ptr,
      size: [rows, columns]
    });
  };
  
  /**
   * Swap rows i and j in Matrix.
   *
   * @memberof SparseMatrix
   * @param {number} i       Matrix row index 1
   * @param {number} j       Matrix row index 2
   *
   * @return {Matrix}        The matrix reference
   */
  SparseMatrix.prototype.swapRows = function (i, j) {
    // check index
    if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {
      throw new Error('Row index must be positive integers');
    }
    // check dimensions
    if (this._size.length !== 2) {
      throw new Error('Only two dimensional matrix is supported');
    }
    // validate index
    validateIndex(i, this._size[0]);
    validateIndex(j, this._size[0]);
    
    // swap rows
    SparseMatrix._swapRows(i, j, this._size[1], this._values, this._index, this._ptr);
    // return current instance
    return this;
  };
  
  /**
   * Loop rows with data in column j.
   *
   * @param {number} j            Column
   * @param {Array} values        Matrix values
   * @param {Array} index         Matrix row indeces
   * @param {Array} ptr           Matrix column pointers
   * @param {Function} callback   Callback function invoked for every row in column j
   */
  SparseMatrix._forEachRow = function (j, values, index, ptr, callback) {
    // indeces for column j
    var k0 = ptr[j];
    var k1 = ptr[j + 1];
    // loop
    for (var k = k0; k < k1; k++) {
      // invoke callback
      callback(index[k], values[k]);
    }
  };
  
  /**
   * Swap rows x and y in Sparse Matrix data structures.
   *
   * @param {number} x         Matrix row index 1
   * @param {number} y         Matrix row index 2
   * @param {number} columns   Number of columns in matrix
   * @param {Array} values     Matrix values
   * @param {Array} index      Matrix row indeces
   * @param {Array} ptr        Matrix column pointers
   */
  SparseMatrix._swapRows = function (x, y, columns, values, index, ptr) {
    // loop columns
    for (var j = 0; j < columns; j++) {
      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
      var k0 = ptr[j];
      var k1 = ptr[j + 1];
      // find value index @ x
      var kx = _getValueIndex(x, k0, k1, index);
      // find value index @ x
      var ky = _getValueIndex(y, k0, k1, index);
      // check both rows exist in matrix
      if (kx < k1 && ky < k1 && index[kx] === x && index[ky] === y) {
        // swap values (check for pattern matrix)
        if (values) {
          var v = values[kx];
          values[kx] = values[ky];
          values[ky] = v;
        }
        // next column
        continue;
      }
      // check x row exist & no y row
      if (kx < k1 && index[kx] === x && (ky >= k1 || index[ky] !== y)) {
        // value @ x (check for pattern matrix)
        var vx = values ? values[kx] : undefined;
        // insert value @ y
        index.splice(ky, 0, y);
        if (values)
          values.splice(ky, 0, vx);        
        // remove value @ x (adjust array index if needed)
        index.splice(ky <= kx ? kx + 1 : kx, 1);
        if (values)
          values.splice(ky <= kx ? kx + 1 : kx, 1);
        // next column
        continue;
      }
      // check y row exist & no x row
      if (ky < k1 && index[ky] === y && (kx >= k1 || index[kx] !== x)) {
        // value @ y (check for pattern matrix)
        var vy = values ? values[ky] : undefined;
        // insert value @ x
        index.splice(kx, 0, x);
        if (values)
          values.splice(kx, 0, vy);
        // remove value @ y (adjust array index if needed)
        index.splice(kx <= ky ? ky + 1 : ky, 1);
        if (values)
          values.splice(kx <= ky ? ky + 1 : ky, 1);
      }
    }
  };

  // register this type in the base class Matrix
  type.Matrix._storage.sparse = SparseMatrix;

  return SparseMatrix;
}

exports.name = 'SparseMatrix';
exports.path = 'type';
exports.factory = factory;
exports.lazy = false;  // no lazy loading, as we alter type.Matrix._storage

},{"../../error/DimensionError":11,"../../function/relational/equalScalar":352,"../../utils/index":481,"./Matrix":429}],434:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  /**
   * Create an index. An Index can store ranges having start, step, and end
   * for multiple dimensions.
   * Matrix.get, Matrix.set, and math.subset accept an Index as input.
   *
   * Syntax:
   *
   *     math.index(range1, range2, ...)
   *
   * Where each range can be any of:
   *
   * - A number
   * - A string for getting/setting an object property
   * - An instance of `Range`
   * - A one-dimensional Array or a Matrix with numbers
   *
   * Indexes must be zero-based, integer numbers.
   *
   * Examples:
   *
   *    var math = math.js
   *
   *    var b = [1, 2, 3, 4, 5];
   *    math.subset(b, math.index([1, 2, 3]));     // returns [2, 3, 4]
   *
   *    var a = math.matrix([[1, 2], [3, 4]]);
   *    a.subset(math.index(0, 1));             // returns 2
   *
   * See also:
   *
   *    bignumber, boolean, complex, matrix, number, string, unit
   *
   * @param {...*} ranges   Zero or more ranges or numbers.
   * @return {Index}        Returns the created index
   */
  return typed('index', {
    '...number | string | BigNumber | Range | Array | Matrix': function (args) {
      var ranges = args.map(function (arg) {
        if (arg && arg.isBigNumber === true) {
          return arg.toNumber(); // convert BigNumber to Number
        }
        else if (arg && (Array.isArray(arg) || arg.isMatrix === true)) {
          return arg.map(function (elem) {
            // convert BigNumber to Number
            return (elem && elem.isBigNumber === true) ? elem.toNumber() : elem;
          });
        }
        else {
          return arg;
        }
      });

      var res = new type.Index();
      type.Index.apply(res, ranges);
      return res;
    }
  });
}

exports.name = 'index';
exports.factory = factory;

},{}],435:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  /**
   * Create a Matrix. The function creates a new `math.type.Matrix` object from
   * an `Array`. A Matrix has utility functions to manipulate the data in the
   * matrix, like getting the size and getting or setting values in the matrix.
   * Supported storage formats are 'dense' and 'sparse'.
   *
   * Syntax:
   *
   *    math.matrix()                         // creates an empty matrix using default storage format (dense).
   *    math.matrix(data)                     // creates a matrix with initial data using default storage format (dense).
   *    math.matrix('dense')                  // creates an empty matrix using the given storage format.
   *    math.matrix(data, 'dense')            // creates a matrix with initial data using the given storage format.
   *    math.matrix(data, 'sparse')           // creates a sparse matrix with initial data.
   *    math.matrix(data, 'sparse', 'number') // creates a sparse matrix with initial data, number data type.
   *
   * Examples:
   *
   *    var m = math.matrix([[1, 2], [3, 4]]);
   *    m.size();                        // Array [2, 2]
   *    m.resize([3, 2], 5);
   *    m.valueOf();                     // Array [[1, 2], [3, 4], [5, 5]]
   *    m.get([1, 0])                    // number 3
   *
   * See also:
   *
   *    bignumber, boolean, complex, index, number, string, unit, sparse
   *
   * @param {Array | Matrix} [data]    A multi dimensional array
   * @param {string} [format]          The Matrix storage format
   *
   * @return {Matrix} The created matrix
   */
  var matrix = typed('matrix', {
    '': function () {
      return _create([]);
    },

    'string': function (format) {
      return _create([], format);
    },
    
    'string, string': function (format, datatype) {
      return _create([], format, datatype);
    },

    'Array': function (data) {
      return _create(data);
    },
      
    'Matrix': function (data) {
      return _create(data, data.storage());
    },
    
    'Array | Matrix, string': _create,
    
    'Array | Matrix, string, string': _create
  });

  matrix.toTex = {
    0: '\\begin{bmatrix}\\end{bmatrix}',
    1: '\\left(${args[0]}\\right)',
    2: '\\left(${args[0]}\\right)'
  };

  return matrix;

  /**
   * Create a new Matrix with given storage format
   * @param {Array} data
   * @param {string} [format]
   * @param {string} [datatype]
   * @returns {Matrix} Returns a new Matrix
   * @private
   */
  function _create(data, format, datatype) {
    // get storage format constructor
    var M = type.Matrix.storage(format || 'default');

    // create instance
    return new M(data, datatype);
  }
}

exports.name = 'matrix';
exports.factory = factory;

},{}],436:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {

  var SparseMatrix = type.SparseMatrix;

  /**
   * Create a Sparse Matrix. The function creates a new `math.type.Matrix` object from
   * an `Array`. A Matrix has utility functions to manipulate the data in the
   * matrix, like getting the size and getting or setting values in the matrix.
   *
   * Syntax:
   *
   *    math.sparse()               // creates an empty sparse matrix.
   *    math.sparse(data)           // creates a sparse matrix with initial data.
   *    math.sparse(data, 'number') // creates a sparse matrix with initial data, number datatype.
   *
   * Examples:
   *
   *    var m = math.sparse([[1, 2], [3, 4]]);
   *    m.size();                        // Array [2, 2]
   *    m.resize([3, 2], 5);
   *    m.valueOf();                     // Array [[1, 2], [3, 4], [5, 5]]
   *    m.get([1, 0])                    // number 3
   *
   * See also:
   *
   *    bignumber, boolean, complex, index, number, string, unit, matrix
   *
   * @param {Array | Matrix} [data]    A two dimensional array
   *
   * @return {Matrix} The created matrix
   */
  var sparse = typed('sparse', {
    '': function () {
      return new SparseMatrix([]);
    },
    
    'string': function (datatype) {
      return new SparseMatrix([], datatype);
    },

    'Array | Matrix': function (data) {
      return new SparseMatrix(data);
    },
    
    'Array | Matrix, string': function (data, datatype) {
      return new SparseMatrix(data, datatype);
    }
  });

  sparse.toTex = {
    0: '\\begin{bsparse}\\end{bsparse}',
    1: '\\left(${args[0]}\\right)'
  };

  return sparse;
}

exports.name = 'sparse';
exports.factory = factory;

},{}],437:[function(require,module,exports){
module.exports = [
  // types
  require('./Matrix'),
  require('./DenseMatrix'),
  require('./SparseMatrix'),
  require('./Spa'),
  require('./FibonacciHeap'),
  require('./ImmutableDenseMatrix'),
  require('./MatrixIndex'),
  require('./Range'),

  // construction functions
  require('./function/index'),
  require('./function/matrix'),
  require('./function/sparse')
];

},{"./DenseMatrix":426,"./FibonacciHeap":427,"./ImmutableDenseMatrix":428,"./Matrix":429,"./MatrixIndex":430,"./Range":431,"./Spa":432,"./SparseMatrix":433,"./function/index":434,"./function/matrix":435,"./function/sparse":436}],438:[function(require,module,exports){
'use strict';

var DimensionError = require('../../../error/DimensionError');

function factory (type, config, load, typed) {

  var DenseMatrix = type.DenseMatrix;

  /**
   * Iterates over SparseMatrix nonzero items and invokes the callback function f(Dij, Sij). 
   * Callback function invoked NNZ times (number of nonzero items in SparseMatrix).
   *
   *
   *          ┌  f(Dij, Sij)  ; S(i,j) !== 0
   * C(i,j) = ┤
   *          └  Dij          ; otherwise
   *
   *
   * @param {Matrix}   denseMatrix       The DenseMatrix instance (D)
   * @param {Matrix}   sparseMatrix      The SparseMatrix instance (S)
   * @param {Function} callback          The f(Dij,Sij) operation to invoke, where Dij = DenseMatrix(i,j) and Sij = SparseMatrix(i,j)
   * @param {boolean}  inverse           A true value indicates callback should be invoked f(Sij,Dij)
   *
   * @return {Matrix}                    DenseMatrix (C)
   *
   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97477571
   */
  var algorithm01 = function (denseMatrix, sparseMatrix, callback, inverse) {
    // dense matrix arrays
    var adata = denseMatrix._data;
    var asize = denseMatrix._size;
    var adt = denseMatrix._datatype;
    // sparse matrix arrays
    var bvalues = sparseMatrix._values;
    var bindex = sparseMatrix._index;
    var bptr = sparseMatrix._ptr;
    var bsize = sparseMatrix._size;
    var bdt = sparseMatrix._datatype;

    // validate dimensions
    if (asize.length !== bsize.length)
      throw new DimensionError(asize.length, bsize.length);

    // check rows & columns
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1])
      throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');

    // sparse matrix cannot be a Pattern matrix
    if (!bvalues)
      throw new Error('Cannot perform operation on Dense Matrix and Pattern Sparse Matrix');

    // rows & columns
    var rows = asize[0];
    var columns = asize[1];

    // process data types
    var dt = typeof adt === 'string' && adt === bdt ? adt : undefined;
    // callback function
    var cf = dt ? typed.find(callback, [dt, dt]) : callback;

    // vars
    var i, j;
    
    // result (DenseMatrix)
    var cdata = [];
    // initialize c
    for (i = 0; i < rows; i++)
      cdata[i] = [];      
    
    // workspace
    var x = [];
    // marks indicating we have a value in x for a given column
    var w = [];

    // loop columns in b
    for (j = 0; j < columns; j++) {
      // column mark
      var mark = j + 1;
      // values in column j
      for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
        // row
        i = bindex[k];
        // update workspace
        x[i] = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]);
        // mark i as updated
        w[i] = mark;
      }
      // loop rows
      for (i = 0; i < rows; i++) {
        // check row is in workspace
        if (w[i] === mark) {
          // c[i][j] was already calculated
          cdata[i][j] = x[i];
        }
        else {
          // item does not exist in S
          cdata[i][j] = adata[i][j];
        }
      }
    }

    // return dense matrix
    return new DenseMatrix({
      data: cdata,
      size: [rows, columns],
      datatype: dt
    });
  };
  
  return algorithm01;
}

exports.name = 'algorithm01';
exports.factory = factory;

},{"../../../error/DimensionError":11}],439:[function(require,module,exports){
'use strict';

var DimensionError = require('../../../error/DimensionError');

function factory (type, config, load, typed) {

  var equalScalar = load(require('../../../function/relational/equalScalar'));

  var SparseMatrix = type.SparseMatrix;

  /**
   * Iterates over SparseMatrix nonzero items and invokes the callback function f(Dij, Sij). 
   * Callback function invoked NNZ times (number of nonzero items in SparseMatrix).
   *
   *
   *          ┌  f(Dij, Sij)  ; S(i,j) !== 0
   * C(i,j) = ┤
   *          └  0            ; otherwise
   *
   *
   * @param {Matrix}   denseMatrix       The DenseMatrix instance (D)
   * @param {Matrix}   sparseMatrix      The SparseMatrix instance (S)
   * @param {Function} callback          The f(Dij,Sij) operation to invoke, where Dij = DenseMatrix(i,j) and Sij = SparseMatrix(i,j)
   * @param {boolean}  inverse           A true value indicates callback should be invoked f(Sij,Dij)
   *
   * @return {Matrix}                    SparseMatrix (C)
   *
   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97477571
   */
  var algorithm02 = function (denseMatrix, sparseMatrix, callback, inverse) {
    // dense matrix arrays
    var adata = denseMatrix._data;
    var asize = denseMatrix._size;
    var adt = denseMatrix._datatype;
    // sparse matrix arrays
    var bvalues = sparseMatrix._values;
    var bindex = sparseMatrix._index;
    var bptr = sparseMatrix._ptr;
    var bsize = sparseMatrix._size;
    var bdt = sparseMatrix._datatype;

    // validate dimensions
    if (asize.length !== bsize.length)
      throw new DimensionError(asize.length, bsize.length);

    // check rows & columns
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1])
      throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');

    // sparse matrix cannot be a Pattern matrix
    if (!bvalues)
      throw new Error('Cannot perform operation on Dense Matrix and Pattern Sparse Matrix');

    // rows & columns
    var rows = asize[0];
    var columns = asize[1];
    
    // datatype
    var dt;
    // equal signature to use
    var eq = equalScalar;
    // zero value
    var zero = 0;
    // callback signature to use
    var cf = callback;

    // process data types
    if (typeof adt === 'string' && adt === bdt) {
      // datatype
      dt = adt;
      // find signature that matches (dt, dt)
      eq = typed.find(equalScalar, [dt, dt]);
      // convert 0 to the same datatype
      zero = typed.convert(0, dt);
      // callback
      cf = typed.find(callback, [dt, dt]);
    }

    // result (SparseMatrix)
    var cvalues = [];
    var cindex = [];
    var cptr = [];

    // loop columns in b
    for (var j = 0; j < columns; j++) {
      // update cptr
      cptr[j] = cindex.length;
      // values in column j
      for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
        // row
        var i = bindex[k];
        // update C(i,j)
        var cij = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]);
        // check for nonzero
        if (!eq(cij, zero)) {
          // push i & v
          cindex.push(i);
          cvalues.push(cij);
        }
      }
    }
    // update cptr
    cptr[columns] = cindex.length;

    // return sparse matrix
    return new SparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });
  };
  
  return algorithm02;
}

exports.name = 'algorithm02';
exports.factory = factory;

},{"../../../error/DimensionError":11,"../../../function/relational/equalScalar":352}],440:[function(require,module,exports){
'use strict';

var DimensionError = require('../../../error/DimensionError');

function factory (type, config, load, typed) {

  var DenseMatrix = type.DenseMatrix;

  /**
   * Iterates over SparseMatrix items and invokes the callback function f(Dij, Sij).
   * Callback function invoked M*N times.
   *
   *
   *          ┌  f(Dij, Sij)  ; S(i,j) !== 0
   * C(i,j) = ┤
   *          └  f(Dij, 0)    ; otherwise
   *
   *
   * @param {Matrix}   denseMatrix       The DenseMatrix instance (D)
   * @param {Matrix}   sparseMatrix      The SparseMatrix instance (C)
   * @param {Function} callback          The f(Dij,Sij) operation to invoke, where Dij = DenseMatrix(i,j) and Sij = SparseMatrix(i,j)
   * @param {boolean}  inverse           A true value indicates callback should be invoked f(Sij,Dij)
   *
   * @return {Matrix}                    DenseMatrix (C)
   *
   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97477571
   */
  var algorithm03 = function (denseMatrix, sparseMatrix, callback, inverse) {
    // dense matrix arrays
    var adata = denseMatrix._data;
    var asize = denseMatrix._size;
    var adt = denseMatrix._datatype;
    // sparse matrix arrays
    var bvalues = sparseMatrix._values;
    var bindex = sparseMatrix._index;
    var bptr = sparseMatrix._ptr;
    var bsize = sparseMatrix._size;
    var bdt = sparseMatrix._datatype;

    // validate dimensions
    if (asize.length !== bsize.length)
      throw new DimensionError(asize.length, bsize.length);

    // check rows & columns
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1])
      throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');

    // sparse matrix cannot be a Pattern matrix
    if (!bvalues)
      throw new Error('Cannot perform operation on Dense Matrix and Pattern Sparse Matrix');

    // rows & columns
    var rows = asize[0];
    var columns = asize[1];

    // datatype
    var dt;
    // zero value
    var zero = 0;
    // callback signature to use
    var cf = callback;

    // process data types
    if (typeof adt === 'string' && adt === bdt) {
      // datatype
      dt = adt;
      // convert 0 to the same datatype
      zero = typed.convert(0, dt);
      // callback
      cf = typed.find(callback, [dt, dt]);
    }

    // result (DenseMatrix)
    var cdata = [];

    // initialize dense matrix
    for (var z = 0; z < rows; z++) {
      // initialize row
      cdata[z] = [];
    }

    // workspace
    var x = [];
    // marks indicating we have a value in x for a given column
    var w = [];

    // loop columns in b
    for (var j = 0; j < columns; j++) {
      // column mark
      var mark = j + 1;
      // values in column j
      for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
        // row
        var i = bindex[k];
        // update workspace
        x[i] = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]);
        w[i] = mark;
      }
      // process workspace
      for (var y = 0; y < rows; y++) {
        // check we have a calculated value for current row
        if (w[y] === mark) {
          // use calculated value
          cdata[y][j] = x[y];
        }
        else {
          // calculate value
          cdata[y][j] = inverse ? cf(zero, adata[y][j]) : cf(adata[y][j], zero);
        }
      }
    }

    // return dense matrix
    return new DenseMatrix({
      data: cdata,
      size: [rows, columns],
      datatype: dt
    });
  };
  
  return algorithm03;
}

exports.name = 'algorithm03';
exports.factory = factory;

},{"../../../error/DimensionError":11}],441:[function(require,module,exports){
'use strict';

var DimensionError = require('../../../error/DimensionError');

function factory (type, config, load, typed) {

  var equalScalar = load(require('../../../function/relational/equalScalar'));

  var SparseMatrix = type.SparseMatrix;

  /**
   * Iterates over SparseMatrix A and SparseMatrix B nonzero items and invokes the callback function f(Aij, Bij). 
   * Callback function invoked MAX(NNZA, NNZB) times
   *
   *
   *          ┌  f(Aij, Bij)  ; A(i,j) !== 0 && B(i,j) !== 0
   * C(i,j) = ┤  A(i,j)       ; A(i,j) !== 0
   *          └  B(i,j)       ; B(i,j) !== 0
   *
   *
   * @param {Matrix}   a                 The SparseMatrix instance (A)
   * @param {Matrix}   b                 The SparseMatrix instance (B)
   * @param {Function} callback          The f(Aij,Bij) operation to invoke
   *
   * @return {Matrix}                    SparseMatrix (C)
   *
   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
   */
  var algorithm04 = function (a, b, callback) {
    // sparse matrix arrays
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var adt = a._datatype;
    // sparse matrix arrays
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype;

    // validate dimensions
    if (asize.length !== bsize.length)
      throw new DimensionError(asize.length, bsize.length);

    // check rows & columns
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1])
      throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');

    // rows & columns
    var rows = asize[0];
    var columns = asize[1];

    // datatype
    var dt;
    // equal signature to use
    var eq = equalScalar;
    // zero value
    var zero = 0;
    // callback signature to use
    var cf = callback;

    // process data types
    if (typeof adt === 'string' && adt === bdt) {
      // datatype
      dt = adt;
      // find signature that matches (dt, dt)
      eq = typed.find(equalScalar, [dt, dt]);
      // convert 0 to the same datatype
      zero = typed.convert(0, dt);
      // callback
      cf = typed.find(callback, [dt, dt]);
    }

    // result arrays
    var cvalues = avalues && bvalues ? [] : undefined;
    var cindex = [];
    var cptr = [];
    // matrix
    var c = new SparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });

    // workspace
    var xa = avalues && bvalues ? [] : undefined;
    var xb = avalues && bvalues ? [] : undefined;
    // marks indicating we have a value in x for a given column
    var wa = [];
    var wb = [];

    // vars 
    var i, j, k, k0, k1;
    
    // loop columns
    for (j = 0; j < columns; j++) {
      // update cptr
      cptr[j] = cindex.length;
      // columns mark
      var mark = j + 1;
      // loop A(:,j)
      for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        // row
        i = aindex[k];
        // update c
        cindex.push(i);
        // update workspace
        wa[i] = mark;
        // check we need to process values
        if (xa)
          xa[i] = avalues[k];
      }
      // loop B(:,j)
      for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
        // row
        i = bindex[k];
        // check row exists in A
        if (wa[i] === mark) {
          // update record in xa @ i
          if (xa) {
            // invoke callback
            var v = cf(xa[i], bvalues[k]);
            // check for zero
            if (!eq(v, zero)) {
              // update workspace
              xa[i] = v;              
            }
            else {
              // remove mark (index will be removed later)
              wa[i] = null;
            }
          }
        }
        else {
          // update c
          cindex.push(i);
          // update workspace
          wb[i] = mark;
          // check we need to process values
          if (xb)
            xb[i] = bvalues[k];
        }
      }
      // check we need to process values (non pattern matrix)
      if (xa && xb) {
        // initialize first index in j
        k = cptr[j];
        // loop index in j
        while (k < cindex.length) {
          // row
          i = cindex[k];
          // check workspace has value @ i
          if (wa[i] === mark) {
            // push value (Aij != 0 || (Aij != 0 && Bij != 0))
            cvalues[k] = xa[i];
            // increment pointer
            k++;
          }
          else if (wb[i] === mark) {
            // push value (bij != 0)
            cvalues[k] = xb[i];
            // increment pointer
            k++;
          }
          else {
            // remove index @ k
            cindex.splice(k, 1);
          }
        }
      }
    }
    // update cptr
    cptr[columns] = cindex.length;

    // return sparse matrix
    return c;
  };
  
  return algorithm04;
}

exports.name = 'algorithm04';
exports.factory = factory;

},{"../../../error/DimensionError":11,"../../../function/relational/equalScalar":352}],442:[function(require,module,exports){
'use strict';

var DimensionError = require('../../../error/DimensionError');

function factory (type, config, load, typed) {

  var equalScalar = load(require('../../../function/relational/equalScalar'));
  
  var SparseMatrix = type.SparseMatrix;

  /**
   * Iterates over SparseMatrix A and SparseMatrix B nonzero items and invokes the callback function f(Aij, Bij). 
   * Callback function invoked MAX(NNZA, NNZB) times
   *
   *
   *          ┌  f(Aij, Bij)  ; A(i,j) !== 0 || B(i,j) !== 0
   * C(i,j) = ┤  
   *          └  0            ; otherwise
   *
   *
   * @param {Matrix}   a                 The SparseMatrix instance (A)
   * @param {Matrix}   b                 The SparseMatrix instance (B)
   * @param {Function} callback          The f(Aij,Bij) operation to invoke
   *
   * @return {Matrix}                    SparseMatrix (C)
   *
   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
   */
  var algorithm05 = function (a, b, callback) {
    // sparse matrix arrays
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var adt = a._datatype;
    // sparse matrix arrays
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype;

    // validate dimensions
    if (asize.length !== bsize.length)
      throw new DimensionError(asize.length, bsize.length);

    // check rows & columns
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1])
      throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');

    // rows & columns
    var rows = asize[0];
    var columns = asize[1];

    // datatype
    var dt;
    // equal signature to use
    var eq = equalScalar;
    // zero value
    var zero = 0;
    // callback signature to use
    var cf = callback;

    // process data types
    if (typeof adt === 'string' && adt === bdt) {
      // datatype
      dt = adt;
      // find signature that matches (dt, dt)
      eq = typed.find(equalScalar, [dt, dt]);
      // convert 0 to the same datatype
      zero = typed.convert(0, dt);
      // callback
      cf = typed.find(callback, [dt, dt]);
    }

    // result arrays
    var cvalues = avalues && bvalues ? [] : undefined;
    var cindex = [];
    var cptr = [];
    // matrix
    var c = new SparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });

    // workspaces
    var xa = cvalues ? [] : undefined;
    var xb = cvalues ? [] : undefined;
    // marks indicating we have a value in x for a given column
    var wa = [];
    var wb = [];

    // vars
    var i, j, k, k1;
    
    // loop columns
    for (j = 0; j < columns; j++) {
      // update cptr
      cptr[j] = cindex.length;
      // columns mark
      var mark = j + 1;
      // loop values A(:,j)
      for (k = aptr[j], k1 = aptr[j + 1]; k < k1; k++) {
        // row
        i = aindex[k];
        // push index
        cindex.push(i);
        // update workspace
        wa[i] = mark;
        // check we need to process values
        if (xa)
          xa[i] = avalues[k];
      }
      // loop values B(:,j)
      for (k = bptr[j], k1 = bptr[j + 1]; k < k1; k++) {
        // row
        i = bindex[k];
        // check row existed in A
        if (wa[i] !== mark) {
          // push index
          cindex.push(i);
        }
        // update workspace
        wb[i] = mark;
        // check we need to process values
        if (xb)
          xb[i] = bvalues[k];
      }
      // check we need to process values (non pattern matrix)
      if (cvalues) {
        // initialize first index in j
        k = cptr[j];
        // loop index in j
        while (k < cindex.length) {
          // row
          i = cindex[k];
          // marks
          var wai = wa[i];
          var wbi = wb[i];
          // check Aij or Bij are nonzero
          if (wai === mark || wbi === mark) {
            // matrix values @ i,j
            var va = wai === mark ? xa[i] : zero;
            var vb = wbi === mark ? xb[i] : zero;
            // Cij
            var vc = cf(va, vb);
            // check for zero
            if (!eq(vc, zero)) {
              // push value
              cvalues.push(vc);
              // increment pointer
              k++;
            }
            else {
              // remove value @ i, do not increment pointer
              cindex.splice(k, 1);
            }
          }
        }
      }
    }
    // update cptr
    cptr[columns] = cindex.length;

    // return sparse matrix
    return c;
  };

  return algorithm05;
}

exports.name = 'algorithm05';
exports.factory = factory;

},{"../../../error/DimensionError":11,"../../../function/relational/equalScalar":352}],443:[function(require,module,exports){
'use strict';

var scatter = require('./../../../utils/collection/scatter');
var DimensionError = require('../../../error/DimensionError');

function factory (type, config, load, typed) {

  var equalScalar = load(require('../../../function/relational/equalScalar'));

  var SparseMatrix = type.SparseMatrix;

  /**
   * Iterates over SparseMatrix A and SparseMatrix B nonzero items and invokes the callback function f(Aij, Bij). 
   * Callback function invoked (Anz U Bnz) times, where Anz and Bnz are the nonzero elements in both matrices.
   *
   *
   *          ┌  f(Aij, Bij)  ; A(i,j) !== 0 && B(i,j) !== 0
   * C(i,j) = ┤  
   *          └  0            ; otherwise
   *
   *
   * @param {Matrix}   a                 The SparseMatrix instance (A)
   * @param {Matrix}   b                 The SparseMatrix instance (B)
   * @param {Function} callback          The f(Aij,Bij) operation to invoke
   *
   * @return {Matrix}                    SparseMatrix (C)
   *
   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
   */
  var algorithm06 = function (a, b, callback) {
    // sparse matrix arrays
    var avalues = a._values;
    var asize = a._size;
    var adt = a._datatype;
    // sparse matrix arrays
    var bvalues = b._values;
    var bsize = b._size;
    var bdt = b._datatype;

    // validate dimensions
    if (asize.length !== bsize.length)
      throw new DimensionError(asize.length, bsize.length);

    // check rows & columns
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1])
      throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');

    // rows & columns
    var rows = asize[0];
    var columns = asize[1];

    // datatype
    var dt;
    // equal signature to use
    var eq = equalScalar;
    // zero value
    var zero = 0;
    // callback signature to use
    var cf = callback;

    // process data types
    if (typeof adt === 'string' && adt === bdt) {
      // datatype
      dt = adt;
      // find signature that matches (dt, dt)
      eq = typed.find(equalScalar, [dt, dt]);
      // convert 0 to the same datatype
      zero = typed.convert(0, dt);
      // callback
      cf = typed.find(callback, [dt, dt]);
    }

    // result arrays
    var cvalues = avalues && bvalues ? [] : undefined;
    var cindex = [];
    var cptr = [];
    // matrix
    var c = new SparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });

    // workspaces
    var x = cvalues ? [] : undefined;
    // marks indicating we have a value in x for a given column
    var w = [];
    // marks indicating value in a given row has been updated
    var u = [];

    // loop columns
    for (var j = 0; j < columns; j++) {
      // update cptr
      cptr[j] = cindex.length;
      // columns mark
      var mark = j + 1;
      // scatter the values of A(:,j) into workspace
      scatter(a, j, w, x, u, mark, c, cf);
      // scatter the values of B(:,j) into workspace
      scatter(b, j, w, x, u, mark, c, cf);
      // check we need to process values (non pattern matrix)
      if (x) {
        // initialize first index in j
        var k = cptr[j];
        // loop index in j
        while (k < cindex.length) {
          // row
          var i = cindex[k];
          // check function was invoked on current row (Aij !=0 && Bij != 0)
          if (u[i] === mark) {
            // value @ i
            var v = x[i];
            // check for zero value
            if (!eq(v, zero)) {
              // push value
              cvalues.push(v);
              // increment pointer
              k++;
            }
            else {
              // remove value @ i, do not increment pointer
              cindex.splice(k, 1);
            }
          }
          else {
            // remove value @ i, do not increment pointer
            cindex.splice(k, 1);
          }
        }
      }
      else {
        // initialize first index in j
        var p = cptr[j];
        // loop index in j
        while (p < cindex.length) {
          // row
          var r = cindex[p];
          // check function was invoked on current row (Aij !=0 && Bij != 0)
          if (u[r] !== mark) {
            // remove value @ i, do not increment pointer
            cindex.splice(p, 1);
          }
          else {
            // increment pointer
            p++;
          }
        }
      }
    }
    // update cptr
    cptr[columns] = cindex.length;

    // return sparse matrix
    return c;
  };
  
  return algorithm06;
}

exports.name = 'algorithm06';
exports.factory = factory;

},{"../../../error/DimensionError":11,"../../../function/relational/equalScalar":352,"./../../../utils/collection/scatter":478}],444:[function(require,module,exports){
'use strict';

var DimensionError = require('../../../error/DimensionError');

function factory (type, config, load, typed) {

  var DenseMatrix = type.DenseMatrix;

  /**
   * Iterates over SparseMatrix A and SparseMatrix B items (zero and nonzero) and invokes the callback function f(Aij, Bij). 
   * Callback function invoked MxN times.
   *
   * C(i,j) = f(Aij, Bij)
   *
   * @param {Matrix}   a                 The SparseMatrix instance (A)
   * @param {Matrix}   b                 The SparseMatrix instance (B)
   * @param {Function} callback          The f(Aij,Bij) operation to invoke
   *
   * @return {Matrix}                    DenseMatrix (C)
   *
   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
   */
  var algorithm07 = function (a, b, callback) {
    // sparse matrix arrays
    var asize = a._size;
    var adt = a._datatype;
    // sparse matrix arrays
    var bsize = b._size;
    var bdt = b._datatype;

    // validate dimensions
    if (asize.length !== bsize.length)
      throw new DimensionError(asize.length, bsize.length);

    // check rows & columns
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1])
      throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');

    // rows & columns
    var rows = asize[0];
    var columns = asize[1];

    // datatype
    var dt;
    // zero value
    var zero = 0;
    // callback signature to use
    var cf = callback;

    // process data types
    if (typeof adt === 'string' && adt === bdt) {
      // datatype
      dt = adt;
      // convert 0 to the same datatype
      zero = typed.convert(0, dt);
      // callback
      cf = typed.find(callback, [dt, dt]);
    }

    // vars
    var i, j;
    
    // result arrays
    var cdata = [];
    // initialize c
    for (i = 0; i < rows; i++)
      cdata[i] = [];

    // matrix
    var c = new DenseMatrix({
      data: cdata,
      size: [rows, columns],
      datatype: dt
    });

    // workspaces
    var xa = [];
    var xb = [];
    // marks indicating we have a value in x for a given column
    var wa = [];
    var wb = [];

    // loop columns
    for (j = 0; j < columns; j++) {
      // columns mark
      var mark = j + 1;
      // scatter the values of A(:,j) into workspace
      _scatter(a, j, wa, xa, mark);
      // scatter the values of B(:,j) into workspace
      _scatter(b, j, wb, xb, mark);
      // loop rows
      for (i = 0; i < rows; i++) {
        // matrix values @ i,j
        var va = wa[i] === mark ? xa[i] : zero;
        var vb = wb[i] === mark ? xb[i] : zero;
        // invoke callback
        cdata[i][j] = cf(va, vb);
      }          
    }

    // return sparse matrix
    return c;
  };
  
  var _scatter = function (m, j, w, x, mark) {
    // a arrays
    var values = m._values;
    var index = m._index;
    var ptr = m._ptr;
    // loop values in column j
    for (var k = ptr[j], k1 = ptr[j + 1]; k < k1; k++) {
      // row
      var i = index[k];
      // update workspace
      w[i] = mark;
      x[i] = values[k];
    }
  };
  
  return algorithm07;
}

exports.name = 'algorithm07';
exports.factory = factory;

},{"../../../error/DimensionError":11}],445:[function(require,module,exports){
'use strict';

var DimensionError = require('../../../error/DimensionError');

function factory (type, config, load, typed) {

  var equalScalar = load(require('../../../function/relational/equalScalar'));

  var SparseMatrix = type.SparseMatrix;

  /**
   * Iterates over SparseMatrix A and SparseMatrix B nonzero items and invokes the callback function f(Aij, Bij). 
   * Callback function invoked MAX(NNZA, NNZB) times
   *
   *
   *          ┌  f(Aij, Bij)  ; A(i,j) !== 0 && B(i,j) !== 0
   * C(i,j) = ┤  A(i,j)       ; A(i,j) !== 0
   *          └  0            ; otherwise
   *
   *
   * @param {Matrix}   a                 The SparseMatrix instance (A)
   * @param {Matrix}   b                 The SparseMatrix instance (B)
   * @param {Function} callback          The f(Aij,Bij) operation to invoke
   *
   * @return {Matrix}                    SparseMatrix (C)
   *
   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
   */
  var algorithm08 = function (a, b, callback) {
    // sparse matrix arrays
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var adt = a._datatype;
    // sparse matrix arrays
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype;

    // validate dimensions
    if (asize.length !== bsize.length)
      throw new DimensionError(asize.length, bsize.length);

    // check rows & columns
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1])
      throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');

    // sparse matrix cannot be a Pattern matrix
    if (!avalues || !bvalues)
      throw new Error('Cannot perform operation on Pattern Sparse Matrices');

    // rows & columns
    var rows = asize[0];
    var columns = asize[1];

    // datatype
    var dt;
    // equal signature to use
    var eq = equalScalar;
    // zero value
    var zero = 0;
    // callback signature to use
    var cf = callback;

    // process data types
    if (typeof adt === 'string' && adt === bdt) {
      // datatype
      dt = adt;
      // find signature that matches (dt, dt)
      eq = typed.find(equalScalar, [dt, dt]);
      // convert 0 to the same datatype
      zero = typed.convert(0, dt);
      // callback
      cf = typed.find(callback, [dt, dt]);
    }

    // result arrays
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    // matrix
    var c = new SparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });

    // workspace
    var x = [];
    // marks indicating we have a value in x for a given column
    var w = [];

    // vars
    var k, k0, k1, i;

    // loop columns
    for (var j = 0; j < columns; j++) {
      // update cptr
      cptr[j] = cindex.length;
      // columns mark
      var mark = j + 1;
      // loop values in a
      for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        // row
        i = aindex[k];
        // mark workspace
        w[i] = mark;
        // set value
        x[i] = avalues[k];
        // add index
        cindex.push(i);
      }
      // loop values in b
      for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
        // row
        i = bindex[k];
        // check value exists in workspace
        if (w[i] === mark) {
          // evaluate callback
          x[i] = cf(x[i], bvalues[k]);
        }
      }
      // initialize first index in j
      k = cptr[j];
      // loop index in j
      while (k < cindex.length) {
        // row
        i = cindex[k];
        // value @ i
        var v = x[i];
        // check for zero value
        if (!eq(v, zero)) {
          // push value
          cvalues.push(v);
          // increment pointer
          k++;
        }
        else {
          // remove value @ i, do not increment pointer
          cindex.splice(k, 1);
        }
      }      
    }
    // update cptr
    cptr[columns] = cindex.length;

    // return sparse matrix
    return c;
  };

  return algorithm08;
}

exports.name = 'algorithm08';
exports.factory = factory;

},{"../../../error/DimensionError":11,"../../../function/relational/equalScalar":352}],446:[function(require,module,exports){
'use strict';

var DimensionError = require('../../../error/DimensionError');

function factory (type, config, load, typed) {

  var equalScalar = load(require('../../../function/relational/equalScalar'));

  var SparseMatrix = type.SparseMatrix;

  /**
   * Iterates over SparseMatrix A and invokes the callback function f(Aij, Bij). 
   * Callback function invoked NZA times, number of nonzero elements in A.
   *
   *
   *          ┌  f(Aij, Bij)  ; A(i,j) !== 0
   * C(i,j) = ┤  
   *          └  0            ; otherwise
   *
   *
   * @param {Matrix}   a                 The SparseMatrix instance (A)
   * @param {Matrix}   b                 The SparseMatrix instance (B)
   * @param {Function} callback          The f(Aij,Bij) operation to invoke
   *
   * @return {Matrix}                    SparseMatrix (C)
   *
   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
   */
  var algorithm09 = function (a, b, callback) {
    // sparse matrix arrays
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var adt = a._datatype;
    // sparse matrix arrays
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype;

    // validate dimensions
    if (asize.length !== bsize.length)
      throw new DimensionError(asize.length, bsize.length);

    // check rows & columns
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1])
      throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');

    // rows & columns
    var rows = asize[0];
    var columns = asize[1];

    // datatype
    var dt;
    // equal signature to use
    var eq = equalScalar;
    // zero value
    var zero = 0;
    // callback signature to use
    var cf = callback;

    // process data types
    if (typeof adt === 'string' && adt === bdt) {
      // datatype
      dt = adt;
      // find signature that matches (dt, dt)
      eq = typed.find(equalScalar, [dt, dt]);
      // convert 0 to the same datatype
      zero = typed.convert(0, dt);
      // callback
      cf = typed.find(callback, [dt, dt]);
    }

    // result arrays
    var cvalues = avalues && bvalues ? [] : undefined;
    var cindex = [];
    var cptr = [];
    // matrix
    var c = new SparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });

    // workspaces
    var x = cvalues ? [] : undefined;
    // marks indicating we have a value in x for a given column
    var w = [];

    // vars
    var i, j, k, k0, k1;
    
    // loop columns
    for (j = 0; j < columns; j++) {
      // update cptr
      cptr[j] = cindex.length;
      // column mark
      var mark = j + 1;
      // check we need to process values
      if (x) {
        // loop B(:,j)
        for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
          // row
          i = bindex[k];
          // update workspace
          w[i] = mark;
          x[i] = bvalues[k];
        }
      }
      // loop A(:,j)
      for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        // row
        i = aindex[k];
        // check we need to process values
        if (x) {
          // b value @ i,j
          var vb = w[i] === mark ? x[i] : zero;
          // invoke f
          var vc = cf(avalues[k], vb);
          // check zero value
          if (!eq(vc, zero)) {
            // push index
            cindex.push(i);
            // push value
            cvalues.push(vc);
          }
        }
        else {
          // push index
          cindex.push(i);
        }
      }
    }
    // update cptr
    cptr[columns] = cindex.length;

    // return sparse matrix
    return c;
  };

  return algorithm09;
}

exports.name = 'algorithm09';
exports.factory = factory;

},{"../../../error/DimensionError":11,"../../../function/relational/equalScalar":352}],447:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {

  var DenseMatrix = type.DenseMatrix;

  /**
   * Iterates over SparseMatrix S nonzero items and invokes the callback function f(Sij, b). 
   * Callback function invoked NZ times (number of nonzero items in S).
   *
   *
   *          ┌  f(Sij, b)  ; S(i,j) !== 0
   * C(i,j) = ┤  
   *          └  b          ; otherwise
   *
   *
   * @param {Matrix}   s                 The SparseMatrix instance (S)
   * @param {Scalar}   b                 The Scalar value
   * @param {Function} callback          The f(Aij,b) operation to invoke
   * @param {boolean}  inverse           A true value indicates callback should be invoked f(b,Sij)
   *
   * @return {Matrix}                    DenseMatrix (C)
   *
   * https://github.com/josdejong/mathjs/pull/346#issuecomment-97626813
   */
  var algorithm10 = function (s, b, callback, inverse) {
    // sparse matrix arrays
    var avalues = s._values;
    var aindex = s._index;
    var aptr = s._ptr;
    var asize = s._size;
    var adt = s._datatype;

    // sparse matrix cannot be a Pattern matrix
    if (!avalues)
      throw new Error('Cannot perform operation on Pattern Sparse Matrix and Scalar value');

    // rows & columns
    var rows = asize[0];
    var columns = asize[1];

    // datatype
    var dt;
    // callback signature to use
    var cf = callback;

    // process data types
    if (typeof adt === 'string') {
      // datatype
      dt = adt;
      // convert b to the same datatype
      b = typed.convert(b, dt);
      // callback
      cf = typed.find(callback, [dt, dt]);
    }

    // result arrays
    var cdata = [];
    // matrix
    var c = new DenseMatrix({
      data: cdata,
      size: [rows, columns],
      datatype: dt
    });

    // workspaces
    var x = [];
    // marks indicating we have a value in x for a given column
    var w = [];

    // loop columns
    for (var j = 0; j < columns; j++) {
      // columns mark
      var mark = j + 1;
      // values in j
      for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        // row
        var r = aindex[k];
        // update workspace
        x[r] = avalues[k];
        w[r] = mark;
      }
      // loop rows
      for (var i = 0; i < rows; i++) {
        // initialize C on first column
        if (j === 0) {
          // create row array
          cdata[i] = [];
        }
        // check sparse matrix has a value @ i,j
        if (w[i] === mark) {
          // invoke callback, update C
          cdata[i][j] = inverse ? cf(b, x[i]) : cf(x[i], b);
        }
        else {
          // dense matrix value @ i, j
          cdata[i][j] = b;
        }
      }
    }

    // return sparse matrix
    return c;
  };

  return algorithm10;
}

exports.name = 'algorithm10';
exports.factory = factory;

},{}],448:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {

  var equalScalar = load(require('../../../function/relational/equalScalar'));

  var SparseMatrix = type.SparseMatrix;

  /**
   * Iterates over SparseMatrix S nonzero items and invokes the callback function f(Sij, b). 
   * Callback function invoked NZ times (number of nonzero items in S).
   *
   *
   *          ┌  f(Sij, b)  ; S(i,j) !== 0
   * C(i,j) = ┤  
   *          └  0          ; otherwise
   *
   *
   * @param {Matrix}   s                 The SparseMatrix instance (S)
   * @param {Scalar}   b                 The Scalar value
   * @param {Function} callback          The f(Aij,b) operation to invoke
   * @param {boolean}  inverse           A true value indicates callback should be invoked f(b,Sij)
   *
   * @return {Matrix}                    SparseMatrix (C)
   *
   * https://github.com/josdejong/mathjs/pull/346#issuecomment-97626813
   */
  var algorithm11 = function (s, b, callback, inverse) {
    // sparse matrix arrays
    var avalues = s._values;
    var aindex = s._index;
    var aptr = s._ptr;
    var asize = s._size;
    var adt = s._datatype;

    // sparse matrix cannot be a Pattern matrix
    if (!avalues)
      throw new Error('Cannot perform operation on Pattern Sparse Matrix and Scalar value');

    // rows & columns
    var rows = asize[0];
    var columns = asize[1];

    // datatype
    var dt;
    // equal signature to use
    var eq = equalScalar;
    // zero value
    var zero = 0;
    // callback signature to use
    var cf = callback;

    // process data types
    if (typeof adt === 'string') {
      // datatype
      dt = adt;
      // find signature that matches (dt, dt)
      eq = typed.find(equalScalar, [dt, dt]);
      // convert 0 to the same datatype
      zero = typed.convert(0, dt);
      // convert b to the same datatype
      b = typed.convert(b, dt);
      // callback
      cf = typed.find(callback, [dt, dt]);
    }

    // result arrays
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    // matrix
    var c = new SparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });

    // loop columns
    for (var j = 0; j < columns; j++) {
      // initialize ptr
      cptr[j] = cindex.length;
      // values in j
      for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        // row
        var i = aindex[k];
        // invoke callback
        var v = inverse ? cf(b, avalues[k]) : cf(avalues[k], b);
        // check value is zero
        if (!eq(v, zero)) {
          // push index & value
          cindex.push(i);
          cvalues.push(v);
        }
      }
    }
    // update ptr
    cptr[columns] = cindex.length;

    // return sparse matrix
    return c;
  };

  return algorithm11;
}

exports.name = 'algorithm11';
exports.factory = factory;

},{"../../../function/relational/equalScalar":352}],449:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {

  var DenseMatrix = type.DenseMatrix;

  /**
   * Iterates over SparseMatrix S nonzero items and invokes the callback function f(Sij, b). 
   * Callback function invoked MxN times.
   *
   *
   *          ┌  f(Sij, b)  ; S(i,j) !== 0
   * C(i,j) = ┤  
   *          └  f(0, b)    ; otherwise
   *
   *
   * @param {Matrix}   s                 The SparseMatrix instance (S)
   * @param {Scalar}   b                 The Scalar value
   * @param {Function} callback          The f(Aij,b) operation to invoke
   * @param {boolean}  inverse           A true value indicates callback should be invoked f(b,Sij)
   *
   * @return {Matrix}                    DenseMatrix (C)
   *
   * https://github.com/josdejong/mathjs/pull/346#issuecomment-97626813
   */
  var algorithm12 = function (s, b, callback, inverse) {
    // sparse matrix arrays
    var avalues = s._values;
    var aindex = s._index;
    var aptr = s._ptr;
    var asize = s._size;
    var adt = s._datatype;

    // sparse matrix cannot be a Pattern matrix
    if (!avalues)
      throw new Error('Cannot perform operation on Pattern Sparse Matrix and Scalar value');

    // rows & columns
    var rows = asize[0];
    var columns = asize[1];

    // datatype
    var dt;
    // callback signature to use
    var cf = callback;

    // process data types
    if (typeof adt === 'string') {
      // datatype
      dt = adt;
      // convert b to the same datatype
      b = typed.convert(b, dt);
      // callback
      cf = typed.find(callback, [dt, dt]);
    }
    
    // result arrays
    var cdata = [];
    // matrix
    var c = new DenseMatrix({
      data: cdata,
      size: [rows, columns],
      datatype: dt
    });

    // workspaces
    var x = [];
    // marks indicating we have a value in x for a given column
    var w = [];

    // loop columns
    for (var j = 0; j < columns; j++) {
      // columns mark
      var mark = j + 1;
      // values in j
      for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        // row
        var r = aindex[k];
        // update workspace
        x[r] = avalues[k];
        w[r] = mark;
      }
      // loop rows
      for (var i = 0; i < rows; i++) {
        // initialize C on first column
        if (j === 0) {
          // create row array
          cdata[i] = [];
        }
        // check sparse matrix has a value @ i,j
        if (w[i] === mark) {
          // invoke callback, update C
          cdata[i][j] = inverse ? cf(b, x[i]) : cf(x[i], b);
        }
        else {
          // dense matrix value @ i, j
          cdata[i][j] = inverse ? cf(b, 0) : cf(0, b);
        }
      }
    }

    // return sparse matrix
    return c;
  };
  
  return algorithm12;
}

exports.name = 'algorithm12';
exports.factory = factory;

},{}],450:[function(require,module,exports){
'use strict';

var util = require('../../../utils/index');
var DimensionError = require('../../../error/DimensionError');

var string = util.string,
    isString = string.isString;

function factory (type, config, load, typed) {

  var DenseMatrix = type.DenseMatrix;

  /**
   * Iterates over DenseMatrix items and invokes the callback function f(Aij..z, Bij..z). 
   * Callback function invoked MxN times.
   *
   * C(i,j,...z) = f(Aij..z, Bij..z)
   *
   * @param {Matrix}   a                 The DenseMatrix instance (A)
   * @param {Matrix}   b                 The DenseMatrix instance (B)
   * @param {Function} callback          The f(Aij..z,Bij..z) operation to invoke
   *
   * @return {Matrix}                    DenseMatrix (C)
   *
   * https://github.com/josdejong/mathjs/pull/346#issuecomment-97658658
   */
  var algorithm13 = function (a, b, callback) {
    // a arrays
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype;
    // b arrays
    var bdata = b._data;
    var bsize = b._size;
    var bdt = b._datatype;
    // c arrays
    var csize = [];

    // validate dimensions
    if (asize.length !== bsize.length)
      throw new DimensionError(asize.length, bsize.length);

    // validate each one of the dimension sizes
    for (var s = 0; s < asize.length; s++) {
      // must match
      if (asize[s] !== bsize[s])
        throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
      // update dimension in c
      csize[s] = asize[s];
    }

    // datatype
    var dt;
    // callback signature to use
    var cf = callback;

    // process data types
    if (typeof adt === 'string' && adt === bdt) {
      // datatype
      dt = adt;
      // convert b to the same datatype
      b = typed.convert(b, dt);
      // callback
      cf = typed.find(callback, [dt, dt]);
    }

    // populate cdata, iterate through dimensions
    var cdata = csize.length > 0 ? _iterate(cf, 0, csize, csize[0], adata, bdata) : [];
    
    // c matrix
    return new DenseMatrix({
      data: cdata,
      size: csize,
      datatype: dt
    });
  };
  
  // recursive function
  var _iterate = function (f, level, s, n, av, bv) {
    // initialize array for this level
    var cv = [];
    // check we reach the last level
    if (level === s.length - 1) {
      // loop arrays in last level
      for (var i = 0; i < n; i++) {
        // invoke callback and store value
        cv[i] = f(av[i], bv[i]);
      }
    }
    else {
      // iterate current level
      for (var j = 0; j < n; j++) {
        // iterate next level
        cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv[j]);
      }
    }
    return cv;
  };
  
  return algorithm13;
}

exports.name = 'algorithm13';
exports.factory = factory;

},{"../../../error/DimensionError":11,"../../../utils/index":481}],451:[function(require,module,exports){
'use strict';

var clone = require('../../../utils/object').clone;

function factory (type, config, load, typed) {

  var DenseMatrix = type.DenseMatrix;

  /**
   * Iterates over DenseMatrix items and invokes the callback function f(Aij..z, b). 
   * Callback function invoked MxN times.
   *
   * C(i,j,...z) = f(Aij..z, b)
   *
   * @param {Matrix}   a                 The DenseMatrix instance (A)
   * @param {Scalar}   b                 The Scalar value
   * @param {Function} callback          The f(Aij..z,b) operation to invoke
   * @param {boolean}  inverse           A true value indicates callback should be invoked f(b,Aij..z)
   *
   * @return {Matrix}                    DenseMatrix (C)
   *
   * https://github.com/josdejong/mathjs/pull/346#issuecomment-97659042
   */
  var algorithm14 = function (a, b, callback, inverse) {
    // a arrays
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype;
    
    // datatype
    var dt;
    // callback signature to use
    var cf = callback;

    // process data types
    if (typeof adt === 'string') {
      // datatype
      dt = adt;
      // convert b to the same datatype
      b = typed.convert(b, dt);
      // callback
      cf = typed.find(callback, [dt, dt]);
    }
    
    // populate cdata, iterate through dimensions
    var cdata = asize.length > 0 ? _iterate(cf, 0, asize, asize[0], adata, b, inverse) : [];

    // c matrix
    return new DenseMatrix({
      data: cdata,
      size: clone(asize),
      datatype: dt
    });
  };
  
  // recursive function
  var _iterate = function (f, level, s, n, av, bv, inverse) {
    // initialize array for this level
    var cv = [];
    // check we reach the last level
    if (level === s.length - 1) {
      // loop arrays in last level
      for (var i = 0; i < n; i++) {
        // invoke callback and store value
        cv[i] = inverse ? f(bv, av[i]) : f(av[i], bv);
      }
    }
    else {
      // iterate current level
      for (var j = 0; j < n; j++) {
        // iterate next level
        cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv, inverse);
      }
    }
    return cv;
  };

  return algorithm14;
}

exports.name = 'algorithm14';
exports.factory = factory;

},{"../../../utils/object":484}],452:[function(require,module,exports){
'use strict';

var deepMap = require('./../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Create a number or convert a string, boolean, or unit to a number.
   * When value is a matrix, all elements will be converted to number.
   *
   * Syntax:
   *
   *    math.number(value)
   *    math.number(unit, valuelessUnit)
   *
   * Examples:
   *
   *    math.number(2);                         // returns number 2
   *    math.number('7.2');                     // returns number 7.2
   *    math.number(true);                      // returns number 1
   *    math.number([true, false, true, true]); // returns [1, 0, 1, 1]
   *    math.number(math.unit('52cm'), 'm');    // returns 0.52
   *
   * See also:
   *
   *    bignumber, boolean, complex, index, matrix, string, unit
   *
   * @param {string | number | BigNumber | Fraction | boolean | Array | Matrix | Unit | null} [value]  Value to be converted
   * @param {Unit | string} [valuelessUnit] A valueless unit, used to convert a unit to a number
   * @return {number | Array | Matrix} The created number
   */
  var number = typed('number', {
    '': function () {
      return 0;
    },

    'number': function (x) {
      return x;
    },

    'string': function (x) {
      var num = Number(x);
      if (isNaN(num)) {
        throw new SyntaxError('String "' + x + '" is no valid number');
      }
      return num;
    },

    'BigNumber': function (x) {
      return x.toNumber();
    },

    'Fraction': function (x) {
      return x.valueOf();
    },

    'Unit': function (x) {
      throw new Error('Second argument with valueless unit expected');
    },

    'Unit, string | Unit': function (unit, valuelessUnit) {
      return unit.toNumber(valuelessUnit);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, number);
    }
  });

  number.toTex = {
    0: '0',
    1: '\\left(${args[0]}\\right)',
    2: '\\left(\\left(${args[0]}\\right)${args[1]}\\right)'
  };

  return number;
}

exports.name = 'number';
exports.factory = factory;

},{"./../utils/collection/deepMap":475}],453:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  /**
   * A ResultSet contains a list or results
   * @class ResultSet
   * @param {Array} entries
   * @constructor ResultSet
   */
  function ResultSet(entries) {
    if (!(this instanceof ResultSet)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    this.entries = entries || [];
  }

  /**
   * Attach type information
   */
  ResultSet.prototype.type = 'ResultSet';
  ResultSet.prototype.isResultSet = true;

  /**
   * Returns the array with results hold by this ResultSet
   * @memberof ResultSet
   * @returns {Array} entries
   */
  ResultSet.prototype.valueOf = function () {
    return this.entries;
  };

  /**
   * Returns the stringified results of the ResultSet
   * @memberof ResultSet
   * @returns {string} string
   */
  ResultSet.prototype.toString = function () {
    return '[' + this.entries.join(', ') + ']';
  };

  /**
   * Get a JSON representation of the ResultSet
   * @memberof ResultSet
   * @returns {Object} Returns a JSON object structured as:
   *                   `{"mathjs": "ResultSet", "entries": [...]}`
   */
  ResultSet.prototype.toJSON = function () {
    return {
      mathjs: 'ResultSet',
      entries: this.entries
    };
  };

  /**
   * Instantiate a ResultSet from a JSON object
   * @memberof ResultSet
   * @param {Object} json  A JSON object structured as:
   *                       `{"mathjs": "ResultSet", "entries": [...]}`
   * @return {ResultSet}
   */
  ResultSet.fromJSON = function (json) {
    return new ResultSet(json.entries);
  };

  return ResultSet;
}

exports.name = 'ResultSet';
exports.path = 'type';
exports.factory = factory;

},{}],454:[function(require,module,exports){
module.exports = [
  // type
  require('./ResultSet')
];

},{"./ResultSet":453}],455:[function(require,module,exports){
'use strict';

var deepMap = require('./../utils/collection/deepMap');
var number = require('../utils/number');

function factory (type, config, load, typed) {
  /**
   * Create a string or convert any object into a string.
   * Elements of Arrays and Matrices are processed element wise.
   *
   * Syntax:
   *
   *    math.string(value)
   *
   * Examples:
   *
   *    math.string(4.2);               // returns string '4.2'
   *    math.string(math.complex(3, 2); // returns string '3 + 2i'
   *
   *    var u = math.unit(5, 'km');
   *    math.string(u.to('m'));         // returns string '5000 m'
   *
   *    math.string([true, false]);     // returns ['true', 'false']
   *
   * See also:
   *
   *    bignumber, boolean, complex, index, matrix, number, unit
   *
   * @param {* | Array | Matrix | null} [value]  A value to convert to a string
   * @return {string | Array | Matrix} The created string
   */
  var string = typed('string', {
    '': function () {
      return '';
    },

    'number': number.format,

    'null': function (x) {
      return 'null';
    },

    'boolean': function (x) {
      return x + '';
    },

    'string': function (x) {
      return x;
    },

    'Array | Matrix': function (x) {
      return deepMap(x, string);
    },

    'any': function (x) {
      return String(x);
    }
  });

  string.toTex = {
    0: '\\mathtt{""}',
    1: '\\mathrm{string}\\left(${args[0]}\\right)'
  };

  return string;
}

exports.name = 'string';
exports.factory = factory;

},{"../utils/number":483,"./../utils/collection/deepMap":475}],456:[function(require,module,exports){
'use strict';

var endsWith = require('../../utils/string').endsWith;
var clone = require('../../utils/object').clone;
var constants = require('../../utils/bignumber/constants');

function factory (type, config, load, typed, math) {
  var add       = load(require('../../function/arithmetic/addScalar'));
  var subtract  = load(require('../../function/arithmetic/subtract'));
  var multiply  = load(require('../../function/arithmetic/multiplyScalar'));
  var divide    = load(require('../../function/arithmetic/divideScalar'));
  var pow       = load(require('../../function/arithmetic/pow'));
  var abs       = load(require('../../function/arithmetic/abs'));
  var equal     = load(require('../../function/relational/equal'));
  var isNumeric = load(require('../../function/utils/isNumeric'));
  var format    = load(require('../../function/string/format'));
  var getTypeOf = load(require('../../function/utils/typeof'));
  var toNumber  = load(require('../../type/number'));
  var Complex   = load(require('../../type/complex/Complex'));

  /**
   * A unit can be constructed in the following ways:
   *     var a = new Unit(value, name);
   *     var b = new Unit(null, name);
   *     var c = Unit.parse(str);
   *
   * Example usage:
   *     var a = new Unit(5, 'cm');               // 50 mm
   *     var b = Unit.parse('23 kg');             // 23 kg
   *     var c = math.in(a, new Unit(null, 'm');  // 0.05 m
   *     var d = new Unit(9.81, "m/s^2");         // 9.81 m/s^2
   *
   * @class Unit
   * @constructor Unit
   * @param {number | BigNumber | Fraction | Complex | boolean} [value]  A value like 5.2
   * @param {string} [name]   A unit name like "cm" or "inch", or a derived unit of the form: "u1[^ex1] [u2[^ex2] ...] [/ u3[^ex3] [u4[^ex4]]]", such as "kg m^2/s^2", where each unit appearing after the forward slash is taken to be in the denominator. "kg m^2 s^-2" is a synonym and is also acceptable. Any of the units can include a prefix.
   */
  function Unit(value, name) {
    if (!(this instanceof Unit)) {
      throw new Error('Constructor must be called with the new operator');
    }

    if (!(value === undefined || isNumeric(value) || value.isComplex)) {
      throw new TypeError('First parameter in Unit constructor must be number, BigNumber, Fraction, Complex, or undefined');
    }
    if (name != undefined && (typeof name !== 'string' || name == '')) {
      throw new TypeError('Second parameter in Unit constructor must be a string');
    }

    if (name != undefined) {
      var u = Unit.parse(name);
      this.units = u.units;
      this.dimensions = u.dimensions;
    }
    else {
      this.units = [
        {
          unit: UNIT_NONE,
          prefix: PREFIXES.NONE,  // link to a list with supported prefixes
          power: 0
        }
      ];
      this.dimensions = [0, 0, 0, 0, 0, 0, 0, 0, 0];
    }

    this.value = (value != undefined) ? this._normalize(value) : null;

    this.fixPrefix = false; // if true, function format will not search for the
                            // best prefix but leave it as initially provided.
                            // fixPrefix is set true by the method Unit.to

    // The justification behind this is that if the constructor is explicitly called,
    // the caller wishes the units to be returned exactly as he supplied.
    this.isUnitListSimplified = true;

  }

  /**
   * Attach type information
   */
  Unit.prototype.type = 'Unit';
  Unit.prototype.isUnit = true;

  // private variables and functions for the Unit parser
  var text, index, c;

  function skipWhitespace() {
    while (c == ' ' || c == '\t') {
      next();
    }
  }

  function isDigitDot(c) {
    return ((c >= '0' && c <= '9') || c == '.');
  }

  function isDigit(c) {
    return ((c >= '0' && c <= '9'));
  }

  function next() {
    index++;
    c = text.charAt(index);
  }

  function revert(oldIndex) {
    index = oldIndex;
    c = text.charAt(index);
  }

  function parseNumber() {
    var number = '';
    var oldIndex;
    oldIndex = index;

    if (c == '+') {
      next();
    }
    else if (c == '-') {
      number += c;
      next();
    }

    if (!isDigitDot(c)) {
      // a + or - must be followed by a digit
      revert(oldIndex);
      return null;
    }

    // get number, can have a single dot
    if (c == '.') {
      number += c;
      next();
      if (!isDigit(c)) {
        // this is no legal number, it is just a dot
        revert(oldIndex);
        return null;
      }
    }
    else {
      while (isDigit(c)) {
        number += c;
        next();
      }
      if (c == '.') {
        number += c;
        next();
      }
    }
    while (isDigit(c)) {
      number += c;
      next();
    }

    // check for exponential notation like "2.3e-4" or "1.23e50"
    if (c == 'E' || c == 'e') {
      // The grammar branches here. This could either be part of an exponent or the start of a unit that begins with the letter e, such as "4exabytes"

      var tentativeNumber = '';
      var tentativeIndex = index;

      tentativeNumber += c;
      next();

      if (c == '+' || c == '-') {
        tentativeNumber += c;
        next();
      }

      // Scientific notation MUST be followed by an exponent (otherwise we assume it is not scientific notation)
      if (!isDigit(c)) {
        // The e or E must belong to something else, so return the number without the e or E.
        revert(tentativeIndex);
        return number;
      }
      
      // We can now safely say that this is scientific notation.
      number = number + tentativeNumber;
      while (isDigit(c)) {
        number += c;
        next();
      }
    }

    return number;
  }

  function parseUnit() {
    var unitName = '';

    // Alphanumeric characters only; matches [a-zA-Z0-9]
    var code = text.charCodeAt(index);
    while ( (code >= 48 && code <= 57) ||
            (code >= 65 && code <= 90) ||
            (code >= 97 && code <= 122)) {
      unitName += c;
      next();
      code = text.charCodeAt(index);
    }

    // Must begin with [a-zA-Z]
    code = unitName.charCodeAt(0);
    if ((code >= 65 && code <= 90) ||
        (code >= 97 && code <= 122)) {
        return unitName || null;
    } 
    else {
      return null;
    }
  }

  function parseCharacter(toFind) {
    if (c === toFind) {
      next();
      return toFind;
    }
    else {
      return null;
    }
  }

  /**
   * Parse a string into a unit. The value of the unit is parsed as number,
   * BigNumber, or Fraction depending on the math.js config setting `number`.
   *
   * Throws an exception if the provided string does not contain a valid unit or
   * cannot be parsed.
   * @memberof Unit
   * @param {string} str        A string like "5.2 inch", "4e2 cm/s^2"
   * @return {Unit} unit
   */
  Unit.parse = function (str) {
    text = str;
    index = -1;
    c = '';

    if (typeof text !== 'string') {
      throw new TypeError('Invalid argument in Unit.parse, string expected');
    }

    var unit = new Unit();
    unit.units = [];

    // A unit should follow this pattern:
    // [number]unit[^number] [unit[^number]]...[/unit[^number] [unit[^number]]]

    // Rules:
    // number is any floating point number.
    // unit is any alphanumeric string beginning with an alpha. Units with names like e3 should be avoided because they look like the exponent of a floating point number!
    // The string may optionally begin with a number.
    // Each unit may optionally be followed by ^number.
    // Whitespace or a forward slash is recommended between consecutive units, although the following technically is parseable:
    //   2m^2kg/s^2
    // it is not good form. If a unit starts with e, then it could be confused as a floating point number:
    //   4erg

    next();
    skipWhitespace();
    // Optional number at the start of the string
    var valueStr = parseNumber();
    var value = null;
    if(valueStr) {
      if (config.number === 'BigNumber') {
        value = new type.BigNumber(valueStr);
      }
      else if (config.number === 'Fraction') {
        value = new type.Fraction(valueStr);
      }
      else { // number
        value = parseFloat(valueStr);
      }
    }
    skipWhitespace();    // Whitespace is not required here

    // Next, we read any number of unit[^number]
    var powerMultiplierCurrent = 1;
    var expectingUnit = false;

    // Stack to keep track of powerMultipliers applied to each parentheses group
    var powerMultiplierStack = [];

    // Running product of all elements in powerMultiplierStack
    var powerMultiplierStackProduct = 1;

    while (true) {
      skipWhitespace();

      // Check for and consume opening parentheses, pushing powerMultiplierCurrent to the stack
      // A '(' will always appear directly before a unit.
      while (c === '(') {
        powerMultiplierStack.push(powerMultiplierCurrent);
        powerMultiplierStackProduct *= powerMultiplierCurrent;
        powerMultiplierCurrent = 1;
        next();
        skipWhitespace();
      }

      // Is there something here?
      if(c) {
        var oldC = c;
        var uStr = parseUnit();
        if(uStr == null) {
          throw new SyntaxError('Unexpected "' + oldC + '" in "' + text + '" at index ' + index.toString());
        }
      }
      else {
        // End of input.
        break;
      }

      // Verify the unit exists and get the prefix (if any)
      var res = _findUnit(uStr);
      if(res == null) {
        // Unit not found.
        throw new SyntaxError('Unit "' + uStr + '" not found.');
      }

      var power = powerMultiplierCurrent * powerMultiplierStackProduct;
      // Is there a "^ number"?
      skipWhitespace();
      if (parseCharacter('^')) {
        skipWhitespace();
        var p = parseNumber();
        if(p == null) {
          // No valid number found for the power!
          throw new SyntaxError('In "' + str + '", "^" must be followed by a floating-point number');
        }
        power *= p;
      }

      // Add the unit to the list
      unit.units.push( {
        unit: res.unit,
        prefix: res.prefix,
        power: power
      });
      for(var i=0; i<BASE_DIMENSIONS.length; i++) {
        unit.dimensions[i] += res.unit.dimensions[i] * power;
      }

      // Check for and consume closing parentheses, popping from the stack.
      // A ')' will always follow a unit.
      skipWhitespace();
      while (c === ')') {
        if(powerMultiplierStack.length === 0) {
          throw new SyntaxError('Unmatched ")" in "' + text + '" at index ' + index.toString());
        }
        powerMultiplierStackProduct /= powerMultiplierStack.pop();
        next();
        skipWhitespace();
      }

      // "*" and "/" should mean we are expecting something to come next.
      // Is there a forward slash? If so, negate powerMultiplierCurrent. The next unit or paren group is in the denominator.
      expectingUnit = false;

      if (parseCharacter('*')) {
        // explicit multiplication
        powerMultiplierCurrent = 1;
        expectingUnit = true;
      }
      else if (parseCharacter('/')) {
        // division
        powerMultiplierCurrent = -1;
        expectingUnit = true;
      }
      else {
        // implicit multiplication
        powerMultiplierCurrent = 1;
      }

      // Replace the unit into the auto unit system
      var baseDim = res.unit.base.key;
      UNIT_SYSTEMS.auto[baseDim] = {
        unit: res.unit,
        prefix: res.prefix
      };
    }
    
    // Has the string been entirely consumed?
    skipWhitespace();
    if(c) {
      throw new SyntaxError('Could not parse: "' + str + '"');
    }

    // Is there a trailing slash?
    if(expectingUnit) {
      throw new SyntaxError('Trailing characters: "' + str + '"');
    }

    // Is the parentheses stack empty?
    if(powerMultiplierStack.length !== 0) {
      throw new SyntaxError('Unmatched "(" in "' + text + '"');
    }

    // Are there any units at all?
    if(unit.units.length == 0) {
      throw new SyntaxError('"' + str + '" contains no units');
    }

    unit.value = (value != undefined) ? unit._normalize(value) : null;
    return unit;
  };

  /**
   * create a copy of this unit
   * @memberof Unit
   * @return {Unit} Returns a cloned version of the unit
   */
  Unit.prototype.clone = function () {
    var unit = new Unit();

    unit.fixPrefix = this.fixPrefix;
    unit.isUnitListSimplified = this.isUnitListSimplified;

    unit.value = clone(this.value);
    unit.dimensions = this.dimensions.slice(0);
    unit.units = [];
    for(var i = 0; i < this.units.length; i++) {
      unit.units[i] = { };
      for (var p in this.units[i]) {
        if (this.units[i].hasOwnProperty(p)) {
          unit.units[i][p] = this.units[i][p];
        }
      }
    }

    return unit;
  };

  /**
   * Return whether the unit is derived (such as m/s, or cm^2, but not N)
   * @memberof Unit
   * @return {boolean} True if the unit is derived
   */
  Unit.prototype._isDerived = function() {
    if(this.units.length === 0) {
      return false;
    }
    return this.units.length > 1 || Math.abs(this.units[0].power - 1.0) > 1e-15;
  };

  /**
   * Normalize a value, based on its currently set unit(s)
   * @memberof Unit
   * @param {number | BigNumber | Fraction | boolean} value
   * @return {number | BigNumber | Fraction | boolean} normalized value
   * @private
   */
  Unit.prototype._normalize = function (value) {
    var unitValue, unitOffset, unitPower, unitPrefixValue;
    var convert;

    if (value == null || this.units.length === 0) {
      return value;
    }
    else if (this._isDerived()) {
      // This is a derived unit, so do not apply offsets.
      // For example, with J kg^-1 degC^-1 you would NOT want to apply the offset.
      var res = value;
      convert = Unit._getNumberConverter(getTypeOf(value)); // convert to Fraction or BigNumber if needed

      for(var i=0; i < this.units.length; i++) {
        unitValue       = convert(this.units[i].unit.value);
        unitPrefixValue = convert(this.units[i].prefix.value);
        unitPower       = convert(this.units[i].power);
        res = multiply(res, pow(multiply(unitValue, unitPrefixValue), unitPower));
      }

      return res;
    }
    else {
      // This is a single unit of power 1, like kg or degC
      convert = Unit._getNumberConverter(getTypeOf(value)); // convert to Fraction or BigNumber if needed

      unitValue       = convert(this.units[0].unit.value);
      unitOffset      = convert(this.units[0].unit.offset);
      unitPrefixValue = convert(this.units[0].prefix.value);

      return multiply(add(value, unitOffset), multiply(unitValue, unitPrefixValue));
    }
  };

  /**
   * Denormalize a value, based on its currently set unit(s)
   * @memberof Unit
   * @param {number} value
   * @param {number} [prefixValue]    Optional prefix value to be used (ignored if this is a derived unit)
   * @return {number} denormalized value
   * @private
   */
  Unit.prototype._denormalize = function (value, prefixValue) {
    var unitValue, unitOffset, unitPower, unitPrefixValue;
    var convert;

    if (value == null || this.units.length === 0) {
      return value;
    }
    else if (this._isDerived()) {
      // This is a derived unit, so do not apply offsets.
      // For example, with J kg^-1 degC^-1 you would NOT want to apply the offset.
      // Also, prefixValue is ignored--but we will still use the prefix value stored in each unit, since kg is usually preferable to g unless the user decides otherwise.
      var res = value;
      convert = Unit._getNumberConverter(getTypeOf(value)); // convert to Fraction or BigNumber if needed

      for (var i = 0; i < this.units.length; i++) {
        unitValue       = convert(this.units[i].unit.value);
        unitPrefixValue = convert(this.units[i].prefix.value);
        unitPower       = convert(this.units[i].power);
        res = divide(res, pow(multiply(unitValue, unitPrefixValue), unitPower));
      }

      return res;
    }
    else {
      // This is a single unit of power 1, like kg or degC
      convert = Unit._getNumberConverter(getTypeOf(value)); // convert to Fraction or BigNumber if needed

      unitValue       = convert(this.units[0].unit.value);
      unitPrefixValue = convert(this.units[0].prefix.value);
      unitOffset      = convert(this.units[0].unit.offset);

      if (prefixValue == undefined) {
        return subtract(divide(divide(value, unitValue), unitPrefixValue), unitOffset);
      }
      else {
        return subtract(divide(divide(value, unitValue), prefixValue), unitOffset);
      }
    }
  };

  /**
   * Find a unit from a string
   * @memberof Unit
   * @param {string} str              A string like 'cm' or 'inch'
   * @returns {Object | null} result  When found, an object with fields unit and
   *                                  prefix is returned. Else, null is returned.
   * @private
   */
  function _findUnit(str) {
    for (var name in UNITS) {
      if (UNITS.hasOwnProperty(name)) {
        if (endsWith(str, name)) {
          var unit = UNITS[name];
          var prefixLen = (str.length - name.length);
          var prefixName = str.substring(0, prefixLen);
          var prefix = unit.prefixes[prefixName];
          if (prefix !== undefined) {
            // store unit, prefix, and value
            return {
              unit: unit,
              prefix: prefix
            };
          }
        }
      }
    }

    return null;
  }

  /**
   * Test if the given expression is a unit.
   * The unit can have a prefix but cannot have a value.
   * @memberof Unit
   * @param {string} name   A string to be tested whether it is a value less unit.
   *                        The unit can have prefix, like "cm"
   * @return {boolean}      true if the given string is a unit
   */
  Unit.isValuelessUnit = function (name) {
    return (_findUnit(name) != null);
  };

  /**
   * check if this unit has given base unit
   * If this unit is a derived unit, this will ALWAYS return false, since by definition base units are not derived.
   * @memberof Unit
   * @param {BASE_UNITS | string | undefined} base
   */
  Unit.prototype.hasBase = function (base) {

    if(typeof(base) === "string") {
      base = BASE_UNITS[base];
    }

    if(!base)
      return false;


    // All dimensions must be the same
    for(var i=0; i<BASE_DIMENSIONS.length; i++) {
      if (Math.abs(this.dimensions[i] - base.dimensions[i]) > 1e-12) {
        return false;
      }
    }
    return true;

  };

  /**
   * Check if this unit has a base or bases equal to another base or bases
   * For derived units, the exponent on each base also must match
   * @memberof Unit
   * @param {Unit} other
   * @return {boolean} true if equal base
   */
  Unit.prototype.equalBase = function (other) {
    // All dimensions must be the same
    for(var i=0; i<BASE_DIMENSIONS.length; i++) {
      if (Math.abs(this.dimensions[i] - other.dimensions[i]) > 1e-12) {
        return false;
      }
    }
    return true;
  };

  /**
   * Check if this unit equals another unit
   * @memberof Unit
   * @param {Unit} other
   * @return {boolean} true if both units are equal
   */
  Unit.prototype.equals = function (other) {
    return (this.equalBase(other) && equal(this.value, other.value));
  };

  /**
   * Multiply this unit with another one
   * @memberof Unit
   * @param {Unit} other
   * @return {Unit} product of this unit and the other unit
   */
  Unit.prototype.multiply = function (other) {
    var res = this.clone();
    
    for(var i = 0; i<BASE_DIMENSIONS.length; i++) {
      res.dimensions[i] = this.dimensions[i] + other.dimensions[i];
    }

    // Append other's units list onto res (simplify later in Unit.prototype.format)
    for(var i=0; i<other.units.length; i++) {
      var inverted = JSON.parse(JSON.stringify(other.units[i])); 
      res.units.push(inverted);
    }

    // If at least one operand has a value, then the result should also have a value
    if(this.value != null || other.value != null) {
      var valThis = this.value == null ? this._normalize(1) : this.value;
      var valOther = other.value == null ? other._normalize(1) : other.value;
      res.value = multiply(valThis, valOther);
    }
    else {
      res.value = null;
    }

    // Trigger simplification of the unit list at some future time
    res.isUnitListSimplified = false;
    return res;
  };

  /**
   * Divide this unit by another one
   * @memberof Unit
   * @param {Unit} other
   * @return {Unit} result of dividing this unit by the other unit
   */
  Unit.prototype.divide = function (other) {
    var res = this.clone();
    
    for(var i=0; i<BASE_DIMENSIONS.length; i++) {
      res.dimensions[i] = this.dimensions[i] - other.dimensions[i];
    }

    // Invert and append other's units list onto res (simplify later in Unit.prototype.format)
    for(var i=0; i<other.units.length; i++) {
      // Clone other's unit
      var inverted = JSON.parse(JSON.stringify(other.units[i])); 
      inverted.power = -inverted.power;
      res.units.push(inverted);
    }

    // If at least one operand has a value, the result should have a value
    if (this.value != null || other.value != null) {
      var valThis = this.value == null ? this._normalize(1) : this.value;
      var valOther = other.value == null ? other._normalize(1) : other.value;
      res.value = divide(valThis, valOther);
    }
    else {
      res.value = null;
    }

    // Trigger simplification of the unit list at some future time
    res.isUnitListSimplified = false;
    return res;
  };

  /**
   * Calculate the power of a unit
   * @memberof Unit
   * @param {number | Fraction | BigNumber} p
   * @returns {Unit}      The result: this^p
   */
  Unit.prototype.pow = function (p) {
    var res = this.clone();
    
    for(var i=0; i<BASE_DIMENSIONS.length; i++) {
      res.dimensions[i] = this.dimensions[i] * p;
    }

    // Adjust the power of each unit in the list
    for(var i=0; i<res.units.length; i++) {
      res.units[i].power *= p;
    }

    if(res.value != null) {
      res.value = pow(res.value, p);

      // only allow numeric output, we don't want to return a Complex number
      //if (!isNumeric(res.value)) {
      //  res.value = NaN;
      //}
      // Update: Complex supported now
    }
    else {
      res.value = null;
    }

    // Trigger lazy evaluation of the unit list
    res.isUnitListSimplified = false;
    return res;
  };

  /**
   * Calculate the absolute value of a unit
   * @memberof Unit
   * @param {number | Fraction | BigNumber} x
   * @returns {Unit}      The result: |x|, absolute value of x
   */
  Unit.prototype.abs = function () {
    // This gives correct, but unexpected, results for units with an offset.
    // For example, abs(-283.15 degC) = -263.15 degC !!!
    var ret = this.clone();
    ret.value = abs(ret.value);

    for(var i in ret.units) {
      if(ret.units[i].unit.name === 'VA' || ret.units[i].unit.name === 'VAR') {
        ret.units[i].unit = UNITS["W"];
      }
    }

    return ret;
  };

  /**
   * Convert the unit to a specific unit name.
   * @memberof Unit
   * @param {string | Unit} valuelessUnit   A unit without value. Can have prefix, like "cm"
   * @returns {Unit} Returns a clone of the unit with a fixed prefix and unit.
   */
  Unit.prototype.to = function (valuelessUnit) {
    var other;
    var value = this.value == null ? this._normalize(1) : this.value;
    if (typeof valuelessUnit === 'string') {
      //other = new Unit(null, valuelessUnit);
      other = Unit.parse(valuelessUnit);
      if (!this.equalBase(other)) {
        throw new Error('Units do not match');
      }
      if (other.value !== null) {
        throw new Error('Cannot convert to a unit with a value');
      }

      other.value = clone(value);
      other.fixPrefix = true;
      other.isUnitListSimplified = true;
      return other;
    }
    else if (valuelessUnit && valuelessUnit.isUnit) {
      if (!this.equalBase(valuelessUnit)) {
        throw new Error('Units do not match');
      }
      if (valuelessUnit.value !== null) {
        throw new Error('Cannot convert to a unit with a value');
      }
      other = valuelessUnit.clone();
      other.value = clone(value);
      other.fixPrefix = true;
      other.isUnitListSimplified = true;
      return other;
    }
    else {
      throw new Error('String or Unit expected as parameter');
    }
  };

  /**
   * Return the value of the unit when represented with given valueless unit
   * @memberof Unit
   * @param {string | Unit} valuelessUnit    For example 'cm' or 'inch'
   * @return {number} Returns the unit value as number.
   */
  // TODO: deprecate Unit.toNumber? It's always better to use toNumeric
  Unit.prototype.toNumber = function (valuelessUnit) {
    return toNumber(this.toNumeric(valuelessUnit));
  };

  /**
   * Return the value of the unit in the original numeric type
   * @memberof Unit
   * @param {string | Unit} valuelessUnit    For example 'cm' or 'inch'
   * @return {number | BigNumber | Fraction} Returns the unit value
   */
  Unit.prototype.toNumeric = function (valuelessUnit) {
    var other = this.to(valuelessUnit);
    if(other._isDerived()) {
      return other._denormalize(other.value);
    }
    else {
      return other._denormalize(other.value, other.units[0].prefix.value);
    }
  };

  /**
   * Get a string representation of the unit.
   * @memberof Unit
   * @return {string}
   */
  Unit.prototype.toString = function () {
    return this.format();
  };

  /**
   * Get a JSON representation of the unit
   * @memberof Unit
   * @returns {Object} Returns a JSON object structured as:
   *                   `{"mathjs": "Unit", "value": 2, "unit": "cm", "fixPrefix": false}`
   */
  Unit.prototype.toJSON = function () {
    return {
      mathjs: 'Unit',
      value: this._denormalize(this.value),
      unit: this.formatUnits(),
      fixPrefix: this.fixPrefix
    };
  };

  /**
   * Instantiate a Unit from a JSON object
   * @memberof Unit
   * @param {Object} json  A JSON object structured as:
   *                       `{"mathjs": "Unit", "value": 2, "unit": "cm", "fixPrefix": false}`
   * @return {Unit}
   */
  Unit.fromJSON = function (json) {
    var unit = new Unit(json.value, json.unit);
    unit.fixPrefix = json.fixPrefix || false;
    return unit;
  };

  /**
   * Returns the string representation of the unit.
   * @memberof Unit
   * @return {string}
   */
  Unit.prototype.valueOf = Unit.prototype.toString;

  /**
   * Attempt to simplify the list of units for this unit according to the dimensions array and the current unit system. After the call, this Unit will contain a list of the "best" units for formatting.
   * Intended to be evaluated lazily. You must set isUnitListSimplified = false before the call! After the call, isUnitListSimplified will be set to true.
   */
  Unit.prototype.simplifyUnitListLazy = function() {

    if (this.isUnitListSimplified || this.value == null) {
      return;
    }

    var proposedUnitList = [];

    // Search for a matching base
    var matchingBase;
    for(var key in currentUnitSystem) {
      if(this.hasBase(BASE_UNITS[key])) {
        matchingBase = key;
        break;
      }
    }

    if(matchingBase === 'NONE')
    {
      this.units = [];
    }
    else {
      var matchingUnit;
      if(matchingBase) {
        // Does the unit system have a matching unit?
        if(currentUnitSystem.hasOwnProperty(matchingBase)) {
          matchingUnit = currentUnitSystem[matchingBase]
        }
      }

      var value;
      var str;
      if(matchingUnit) {
        this.units = [{
          unit: matchingUnit.unit,
          prefix: matchingUnit.prefix,
          power: 1.0
        }];
      }
      else {
        // Multiple units or units with powers are formatted like this:
        // 5 (kg m^2) / (s^3 mol)
        // Build an representation from the base units of the current unit system
        for(var i=0; i<BASE_DIMENSIONS.length; i++) {
          var baseDim = BASE_DIMENSIONS[i];
          if(Math.abs(this.dimensions[i]) > 1e-12) {
            proposedUnitList.push({
              unit: currentUnitSystem[baseDim].unit,
              prefix: currentUnitSystem[baseDim].prefix,
              power: this.dimensions[i]
            });
          }
        }

        // Is the proposed unit list "simpler" than the existing one?
        if(proposedUnitList.length < this.units.length) {
          // Replace this unit list with the proposed list
          this.units = proposedUnitList;
        }
      }
    }

    this.isUnitListSimplified = true;
  };

  /**
   * Get a string representation of the units of this Unit, without the value.
   * @memberof Unit
   * @return {string}
   */
  Unit.prototype.formatUnits = function () {

    // Lazy evaluation of the unit list
    this.simplifyUnitListLazy();

    var strNum = "";
    var strDen = "";
    var nNum = 0;
    var nDen = 0;

    for(var i=0; i<this.units.length; i++) {
      if(this.units[i].power > 0) {
        nNum++;
        strNum += " " + this.units[i].prefix.name + this.units[i].unit.name;
        if(Math.abs(this.units[i].power - 1.0) > 1e-15) {
          strNum += "^" + this.units[i].power;
        }
      }
      else if(this.units[i].power < 0) {
        nDen++;
      }
    }

    if(nDen > 0) {
      for(var i=0; i<this.units.length; i++) {
        if(this.units[i].power < 0) {
          if(nNum > 0) {
            strDen += " " + this.units[i].prefix.name + this.units[i].unit.name;
            if(Math.abs(this.units[i].power + 1.0) > 1e-15) {
              strDen += "^" + (-this.units[i].power);
            }
          }
          else {
            strDen += " " + this.units[i].prefix.name + this.units[i].unit.name;
            strDen += "^" + (this.units[i].power);
          }
        }
      }
    }
    // Remove leading " "
    strNum = strNum.substr(1);
    strDen = strDen.substr(1);

    // Add parans for better copy/paste back into the eval, for example, or for better pretty print formatting
    if(nNum > 1 && nDen > 0) {
      strNum = "(" + strNum + ")";
    }
    if(nDen > 1 && nNum > 0) {
      strDen = "(" + strDen + ")";
    }

    var str = strNum;
    if(nNum > 0 && nDen > 0) {
      str += " / ";
    }
    str += strDen;

    return str;
  };

  /**
   * Get a string representation of the Unit, with optional formatting options.
   * @memberof Unit
   * @param {Object | number | Function} [options]  Formatting options. See
   *                                                lib/utils/number:format for a
   *                                                description of the available
   *                                                options.
   * @return {string}
   */
  Unit.prototype.format = function (options) {

    // Simplfy the unit list, if necessary
    this.simplifyUnitListLazy();

    // Apply some custom logic for handling VA and VAR. The goal is to express the value of the unit as a real value, if possible. Otherwise, use a real-valued unit instead of a complex-valued one.
    var isImaginary = false;
    var isReal = true;
    if(typeof(this.value) !== 'undefined' && this.value !== null && this.value.isComplex) {
      // TODO: Make this better, for example, use relative magnitude of re and im rather than absolute
      isImaginary = Math.abs(this.value.re) < 1e-14;
      isReal = Math.abs(this.value.im) < 1e-14;
    }
    
    for(var i in this.units) {
      if(this.units[i].unit) {
        if(this.units[i].unit.name === 'VA' && isImaginary) {
          this.units[i].unit = UNITS["VAR"];
        }
        else if(this.units[i].unit.name === 'VAR' && !isImaginary) {
          this.units[i].unit = UNITS["VA"];
        }
      }
    }


    // Now apply the best prefix
    // Units must have only one unit and not have the fixPrefix flag set
    if (this.units.length === 1 && !this.fixPrefix) {
      // Units must have integer powers, otherwise the prefix will change the
      // outputted value by not-an-integer-power-of-ten
      if (Math.abs(this.units[0].power - Math.round(this.units[0].power)) < 1e-14) {
        // Apply the best prefix
        this.units[0].prefix = this._bestPrefix();
      }
    }

    var value = this._denormalize(this.value);
    var str = (this.value !== null) ? format(value, options || {}) : '';
    var unitStr = this.formatUnits();
    if(this.value && this.value.isComplex) {
      str = "(" + str + ")";    // Surround complex values with ( ) to enable better parsing 
    }
    if(unitStr.length > 0 && str.length > 0) {
      str += " ";
    }
    str += unitStr;

    return str;
  };

  /**
   * Calculate the best prefix using current value.
   * @memberof Unit
   * @returns {Object} prefix
   * @private
   */
  Unit.prototype._bestPrefix = function () {
    if (this.units.length !== 1) {
      throw new Error("Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!");
    }
    if (Math.abs(this.units[0].power - Math.round(this.units[0].power)) >= 1e-14) {
      throw new Error("Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!");
    }

    // find the best prefix value (resulting in the value of which
    // the absolute value of the log10 is closest to zero,
    // though with a little offset of 1.2 for nicer values: you get a
    // sequence 1mm 100mm 500mm 0.6m 1m 10m 100m 500m 0.6km 1km ...

    // Note: the units value can be any numeric type, but to find the best
    // prefix it's enough to work with limited precision of a regular number
    // Update: using mathjs abs since we also allow complex numbers
    var absValue = abs(this.value);
    var absUnitValue = abs(this.units[0].unit.value);
    var bestPrefix = this.units[0].prefix;
    if (absValue === 0) {
      return bestPrefix;
    }
    var power = this.units[0].power;
    var bestDiff = Math.abs(
        Math.log(absValue / Math.pow(bestPrefix.value * absUnitValue, power)) / Math.LN10 - 1.2);

    var prefixes = this.units[0].unit.prefixes;
    for (var p in prefixes) {
      if (prefixes.hasOwnProperty(p)) {
        var prefix = prefixes[p];
        if (prefix.scientific) {

          var diff = Math.abs(
              Math.log(absValue / Math.pow(prefix.value * absUnitValue, power)) / Math.LN10 - 1.2);

          if (diff < bestDiff
              || (diff === bestDiff && prefix.name.length < bestPrefix.name.length)) {
                // choose the prefix with the smallest diff, or if equal, choose the one
                // with the shortest name (can happen with SHORTLONG for example)
                bestPrefix = prefix;
                bestDiff = diff;
          }
        }
      }
    }

    return bestPrefix;
  };

  var PREFIXES = {
    NONE: {
      '': {name: '', value: 1, scientific: true}
    },
    SHORT: {
      '': {name: '', value: 1, scientific: true},

      'da': {name: 'da', value: 1e1, scientific: false},
      'h': {name: 'h', value: 1e2, scientific: false},
      'k': {name: 'k', value: 1e3, scientific: true},
      'M': {name: 'M', value: 1e6, scientific: true},
      'G': {name: 'G', value: 1e9, scientific: true},
      'T': {name: 'T', value: 1e12, scientific: true},
      'P': {name: 'P', value: 1e15, scientific: true},
      'E': {name: 'E', value: 1e18, scientific: true},
      'Z': {name: 'Z', value: 1e21, scientific: true},
      'Y': {name: 'Y', value: 1e24, scientific: true},

      'd': {name: 'd', value: 1e-1, scientific: false},
      'c': {name: 'c', value: 1e-2, scientific: false},
      'm': {name: 'm', value: 1e-3, scientific: true},
      'u': {name: 'u', value: 1e-6, scientific: true},
      'n': {name: 'n', value: 1e-9, scientific: true},
      'p': {name: 'p', value: 1e-12, scientific: true},
      'f': {name: 'f', value: 1e-15, scientific: true},
      'a': {name: 'a', value: 1e-18, scientific: true},
      'z': {name: 'z', value: 1e-21, scientific: true},
      'y': {name: 'y', value: 1e-24, scientific: true}
    },
    LONG: {
      '': {name: '', value: 1, scientific: true},

      'deca': {name: 'deca', value: 1e1, scientific: false},
      'hecto': {name: 'hecto', value: 1e2, scientific: false},
      'kilo': {name: 'kilo', value: 1e3, scientific: true},
      'mega': {name: 'mega', value: 1e6, scientific: true},
      'giga': {name: 'giga', value: 1e9, scientific: true},
      'tera': {name: 'tera', value: 1e12, scientific: true},
      'peta': {name: 'peta', value: 1e15, scientific: true},
      'exa': {name: 'exa', value: 1e18, scientific: true},
      'zetta': {name: 'zetta', value: 1e21, scientific: true},
      'yotta': {name: 'yotta', value: 1e24, scientific: true},

      'deci': {name: 'deci', value: 1e-1, scientific: false},
      'centi': {name: 'centi', value: 1e-2, scientific: false},
      'milli': {name: 'milli', value: 1e-3, scientific: true},
      'micro': {name: 'micro', value: 1e-6, scientific: true},
      'nano': {name: 'nano', value: 1e-9, scientific: true},
      'pico': {name: 'pico', value: 1e-12, scientific: true},
      'femto': {name: 'femto', value: 1e-15, scientific: true},
      'atto': {name: 'atto', value: 1e-18, scientific: true},
      'zepto': {name: 'zepto', value: 1e-21, scientific: true},
      'yocto': {name: 'yocto', value: 1e-24, scientific: true}
    },
    SQUARED: {
      '': {name: '', value: 1, scientific: true},

      'da': {name: 'da', value: 1e2, scientific: false},
      'h': {name: 'h', value: 1e4, scientific: false},
      'k': {name: 'k', value: 1e6, scientific: true},
      'M': {name: 'M', value: 1e12, scientific: true},
      'G': {name: 'G', value: 1e18, scientific: true},
      'T': {name: 'T', value: 1e24, scientific: true},
      'P': {name: 'P', value: 1e30, scientific: true},
      'E': {name: 'E', value: 1e36, scientific: true},
      'Z': {name: 'Z', value: 1e42, scientific: true},
      'Y': {name: 'Y', value: 1e48, scientific: true},

      'd': {name: 'd', value: 1e-2, scientific: false},
      'c': {name: 'c', value: 1e-4, scientific: false},
      'm': {name: 'm', value: 1e-6, scientific: true},
      'u': {name: 'u', value: 1e-12, scientific: true},
      'n': {name: 'n', value: 1e-18, scientific: true},
      'p': {name: 'p', value: 1e-24, scientific: true},
      'f': {name: 'f', value: 1e-30, scientific: true},
      'a': {name: 'a', value: 1e-36, scientific: true},
      'z': {name: 'z', value: 1e-42, scientific: true},
      'y': {name: 'y', value: 1e-48, scientific: true}
    },
    CUBIC: {
      '': {name: '', value: 1, scientific: true},

      'da': {name: 'da', value: 1e3, scientific: false},
      'h': {name: 'h', value: 1e6, scientific: false},
      'k': {name: 'k', value: 1e9, scientific: true},
      'M': {name: 'M', value: 1e18, scientific: true},
      'G': {name: 'G', value: 1e27, scientific: true},
      'T': {name: 'T', value: 1e36, scientific: true},
      'P': {name: 'P', value: 1e45, scientific: true},
      'E': {name: 'E', value: 1e54, scientific: true},
      'Z': {name: 'Z', value: 1e63, scientific: true},
      'Y': {name: 'Y', value: 1e72, scientific: true},

      'd': {name: 'd', value: 1e-3, scientific: false},
      'c': {name: 'c', value: 1e-6, scientific: false},
      'm': {name: 'm', value: 1e-9, scientific: true},
      'u': {name: 'u', value: 1e-18, scientific: true},
      'n': {name: 'n', value: 1e-27, scientific: true},
      'p': {name: 'p', value: 1e-36, scientific: true},
      'f': {name: 'f', value: 1e-45, scientific: true},
      'a': {name: 'a', value: 1e-54, scientific: true},
      'z': {name: 'z', value: 1e-63, scientific: true},
      'y': {name: 'y', value: 1e-72, scientific: true}
    },
    BINARY_SHORT: {
      '': {name: '', value: 1, scientific: true},
      'k': {name: 'k', value: 1e3, scientific: true},
      'M': {name: 'M', value: 1e6, scientific: true},
      'G': {name: 'G', value: 1e9, scientific: true},
      'T': {name: 'T', value: 1e12, scientific: true},
      'P': {name: 'P', value: 1e15, scientific: true},
      'E': {name: 'E', value: 1e18, scientific: true},
      'Z': {name: 'Z', value: 1e21, scientific: true},
      'Y': {name: 'Y', value: 1e24, scientific: true},

      'Ki': {name: 'Ki', value: 1024, scientific: true},
      'Mi': {name: 'Mi', value: Math.pow(1024, 2), scientific: true},
      'Gi': {name: 'Gi', value: Math.pow(1024, 3), scientific: true},
      'Ti': {name: 'Ti', value: Math.pow(1024, 4), scientific: true},
      'Pi': {name: 'Pi', value: Math.pow(1024, 5), scientific: true},
      'Ei': {name: 'Ei', value: Math.pow(1024, 6), scientific: true},
      'Zi': {name: 'Zi', value: Math.pow(1024, 7), scientific: true},
      'Yi': {name: 'Yi', value: Math.pow(1024, 8), scientific: true}
    },
    BINARY_LONG: {
      '': {name: '', value: 1, scientific: true},
      'kilo': {name: 'kilo', value: 1e3, scientific: true},
      'mega': {name: 'mega', value: 1e6, scientific: true},
      'giga': {name: 'giga', value: 1e9, scientific: true},
      'tera': {name: 'tera', value: 1e12, scientific: true},
      'peta': {name: 'peta', value: 1e15, scientific: true},
      'exa': {name: 'exa', value: 1e18, scientific: true},
      'zetta': {name: 'zetta', value: 1e21, scientific: true},
      'yotta': {name: 'yotta', value: 1e24, scientific: true},

      'kibi': {name: 'kibi', value: 1024, scientific: true},
      'mebi': {name: 'mebi', value: Math.pow(1024, 2), scientific: true},
      'gibi': {name: 'gibi', value: Math.pow(1024, 3), scientific: true},
      'tebi': {name: 'tebi', value: Math.pow(1024, 4), scientific: true},
      'pebi': {name: 'pebi', value: Math.pow(1024, 5), scientific: true},
      'exi': {name: 'exi', value: Math.pow(1024, 6), scientific: true},
      'zebi': {name: 'zebi', value: Math.pow(1024, 7), scientific: true},
      'yobi': {name: 'yobi', value: Math.pow(1024, 8), scientific: true}
    },
    BTU: {
      '':   {name: '',   value: 1,   scientific: true},
      'MM': {name: 'MM', value: 1e6, scientific: true}
    }
  };

  // Add a prefix list for both short and long prefixes (for ohm in particular, since Mohm and megaohm are both acceptable):
  PREFIXES.SHORTLONG = {};
  for (var key in PREFIXES.SHORT) {
    if(PREFIXES.SHORT.hasOwnProperty(key)) {
      PREFIXES.SHORTLONG[key] = PREFIXES.SHORT[key];
    }
  }
  for (var key in PREFIXES.LONG) {
    if(PREFIXES.LONG.hasOwnProperty(key)) {
      PREFIXES.SHORTLONG[key] = PREFIXES.LONG[key];
    }
  }

  /* Internally, each unit is represented by a value and a dimension array. The elements of the dimensions array have the following meaning:
   * Index  Dimension
   * -----  ---------
   *   0    Length
   *   1    Mass
   *   2    Time
   *   3    Current
   *   4    Temperature
   *   5    Luminous intensity
   *   6    Amount of substance
   *   7    Angle
   *   8    Bit (digital)
   * For example, the unit "298.15 K" is a pure temperature and would have a value of 298.15 and a dimension array of [0, 0, 0, 0, 1, 0, 0, 0, 0]. The unit "1 cal / (gm °C)" can be written in terms of the 9 fundamental dimensions as [length^2] / ([time^2] * [temperature]), and would a value of (after conversion to SI) 4184.0 and a dimensions array of [2, 0, -2, 0, -1, 0, 0, 0, 0].
   *
   */

  var BASE_DIMENSIONS = ["MASS", "LENGTH", "TIME", "CURRENT", "TEMPERATURE", "LUMINOUS_INTENSITY", "AMOUNT_OF_SUBSTANCE", "ANGLE", "BIT"];

  var BASE_UNITS = {
    NONE: {
      dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 0]
    },
    MASS: {
      dimensions: [1, 0, 0, 0, 0, 0, 0, 0, 0]
    },
    LENGTH: {
      dimensions: [0, 1, 0, 0, 0, 0, 0, 0, 0]
    },
    TIME: {
      dimensions: [0, 0, 1, 0, 0, 0, 0, 0, 0]
    },
    CURRENT: {
      dimensions: [0, 0, 0, 1, 0, 0, 0, 0, 0]
    },
    TEMPERATURE: {
      dimensions: [0, 0, 0, 0, 1, 0, 0, 0, 0]
    },
    LUMINOUS_INTENSITY: {
      dimensions: [0, 0, 0, 0, 0, 1, 0, 0, 0]
    },
    AMOUNT_OF_SUBSTANCE: {
      dimensions: [0, 0, 0, 0, 0, 0, 1, 0, 0]
    },

    FORCE: {
      dimensions: [1, 1, -2, 0, 0, 0, 0, 0, 0]
    },
    SURFACE: {
      dimensions: [0, 2, 0, 0, 0, 0, 0, 0, 0]
    },
    VOLUME: {
      dimensions: [0, 3, 0, 0, 0, 0, 0, 0, 0]
    },
    ENERGY: {
      dimensions: [1, 2, -2, 0, 0, 0, 0, 0, 0]
    },
    POWER: {
      dimensions: [1, 2, -3, 0, 0, 0, 0, 0, 0]
    },
    PRESSURE: {
      dimensions: [1, -1, -2, 0, 0, 0, 0, 0, 0]
    },

    ELECTRIC_CHARGE: {
      dimensions: [0, 0, 1, 1, 0, 0, 0, 0, 0]
    },
    ELECTRIC_CAPACITANCE: {
      dimensions: [-1, -2, 4, 2, 0, 0, 0, 0, 0]
    },
    ELECTRIC_POTENTIAL: {
      dimensions: [1, 2, -3, -1, 0, 0, 0, 0, 0]
    },
    ELECTRIC_RESISTANCE: {
      dimensions: [1, 2, -3, -2, 0, 0, 0, 0, 0]
    },
    ELECTRIC_INDUCTANCE: {
      dimensions: [1, 2, -2, -2, 0, 0, 0, 0, 0]
    },
    ELECTRIC_CONDUCTANCE: {
      dimensions: [-1, -2, 3, 2, 0, 0, 0, 0, 0]
    },
    MAGNETIC_FLUX: {
      dimensions: [1, 2, -2, -1, 0, 0, 0, 0, 0]
    },
    MAGNETIC_FLUX_DENSITY: {
      dimensions: [1, 0, -2, -1, 0, 0, 0, 0, 0]
    },

    FREQUENCY: {
      dimensions: [0, 0, -1, 0, 0, 0, 0, 0, 0]
    },
    ANGLE: {
      dimensions: [0, 0, 0, 0, 0, 0, 0, 1, 0]
    },
    BIT: {
      dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 1]
    }
  };

  for(var key in BASE_UNITS) {
    BASE_UNITS[key].key = key;
  }

  var BASE_UNIT_NONE = {};

  var UNIT_NONE = {name: '', base: BASE_UNIT_NONE, value: 1, offset: 0, dimensions: [0,0,0,0,0,0,0,0,0]};

  var UNITS = {
    // length
    meter: {
      name: 'meter',
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    inch: {
      name: 'inch',
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.0254,
      offset: 0
    },
    foot: {
      name: 'foot',
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.3048,
      offset: 0
    },
    yard: {
      name: 'yard',
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.9144,
      offset: 0
    },
    mile: {
      name: 'mile',
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 1609.344,
      offset: 0
    },
    link: {
      name: 'link',
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.201168,
      offset: 0
    },
    rod: {
      name: 'rod',
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 5.029210,
      offset: 0
    },
    chain: {
      name: 'chain',
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 20.1168,
      offset: 0
    },
    angstrom: {
      name: 'angstrom',
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 1e-10,
      offset: 0
    },

    m: {
      name: 'm',
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    'in': {
      name: 'in',
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.0254,
      offset: 0
    },
    ft: {
      name: 'ft',
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.3048,
      offset: 0
    },
    yd: {
      name: 'yd',
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.9144,
      offset: 0
    },
    mi: {
      name: 'mi',
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 1609.344,
      offset: 0
    },
    li: {
      name: 'li',
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.201168,
      offset: 0
    },
    rd: {
      name: 'rd',
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 5.029210,
      offset: 0
    },
    ch: {
      name: 'ch',
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 20.1168,
      offset: 0
    },
    mil: {
      name: 'mil',
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.0000254,
      offset: 0
    }, // 1/1000 inch

    // Surface
    m2: {
      name: 'm2',
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.SQUARED,
      value: 1,
      offset: 0
    },
    sqin: {
      name: 'sqin',
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 0.00064516,
      offset: 0
    }, // 645.16 mm2
    sqft: {
      name: 'sqft',
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 0.09290304,
      offset: 0
    }, // 0.09290304 m2
    sqyd: {
      name: 'sqyd',
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 0.83612736,
      offset: 0
    }, // 0.83612736 m2
    sqmi: {
      name: 'sqmi',
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 2589988.110336,
      offset: 0
    }, // 2.589988110336 km2
    sqrd: {
      name: 'sqrd',
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 25.29295,
      offset: 0
    }, // 25.29295 m2
    sqch: {
      name: 'sqch',
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 404.6873,
      offset: 0
    }, // 404.6873 m2
    sqmil: {
      name: 'sqmil',
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 6.4516e-10,
      offset: 0
    }, // 6.4516 * 10^-10 m2
    acre: {
      name: 'acre',
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 4046.86,
      offset: 0
    }, // 4046.86 m2
    hectare: {
      name: 'hectare',
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 10000,
      offset: 0
    }, // 10000 m2

    // Volume
    m3: {
      name: 'm3',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.CUBIC,
      value: 1,
      offset: 0
    },
    L: {
      name: 'L',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.SHORT,
      value: 0.001,
      offset: 0
    }, // litre
    l: {
      name: 'l',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.SHORT,
      value: 0.001,
      offset: 0
    }, // litre
    litre: {
      name: 'litre',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.LONG,
      value: 0.001,
      offset: 0
    },
    cuin: {
      name: 'cuin',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 1.6387064e-5,
      offset: 0
    }, // 1.6387064e-5 m3
    cuft: {
      name: 'cuft',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.028316846592,
      offset: 0
    }, // 28.316 846 592 L
    cuyd: {
      name: 'cuyd',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.764554857984,
      offset: 0
    }, // 764.554 857 984 L
    teaspoon: {
      name: 'teaspoon',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.000005,
      offset: 0
    }, // 5 mL
    tablespoon: {
      name: 'tablespoon',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.000015,
      offset: 0
    }, // 15 mL
    //{name: 'cup', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.000240, offset: 0}, // 240 mL  // not possible, we have already another cup
    drop: {
      name: 'drop',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 5e-8,
      offset: 0
    },  // 0.05 mL = 5e-8 m3
    gtt: {
      name: 'gtt',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 5e-8,
      offset: 0
    },  // 0.05 mL = 5e-8 m3

    // Liquid volume
    minim: {
      name: 'minim',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.00000006161152,
      offset: 0
    }, // 0.06161152 mL
    fluiddram: {
      name: 'fluiddram',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.0000036966911,
      offset: 0
    },  // 3.696691 mL
    fluidounce: {
      name: 'fluidounce',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.00002957353,
      offset: 0
    }, // 29.57353 mL
    gill: {
      name: 'gill',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.0001182941,
      offset: 0
    }, // 118.2941 mL
    cc: {
      name: 'cc',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 1e-6,
      offset: 0
    }, // 1e-6 L
    cup: {
      name: 'cup',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.0002365882,
      offset: 0
    }, // 236.5882 mL
    pint: {
      name: 'pint',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.0004731765,
      offset: 0
    }, // 473.1765 mL
    quart: {
      name: 'quart',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.0009463529,
      offset: 0
    }, // 946.3529 mL
    gallon: {
      name: 'gallon',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.003785412,
      offset: 0
    }, // 3.785412 L
    beerbarrel: {
      name: 'beerbarrel',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.1173478,
      offset: 0
    }, // 117.3478 L
    oilbarrel: {
      name: 'oilbarrel',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.1589873,
      offset: 0
    }, // 158.9873 L
    hogshead: {
      name: 'hogshead',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.2384810,
      offset: 0
    }, // 238.4810 L

    //{name: 'min', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.00000006161152, offset: 0}, // 0.06161152 mL // min is already in use as minute
    fldr: {
      name: 'fldr',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.0000036966911,
      offset: 0
    },  // 3.696691 mL
    floz: {
      name: 'floz',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.00002957353,
      offset: 0
    }, // 29.57353 mL
    gi: {
      name: 'gi',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.0001182941,
      offset: 0
    }, // 118.2941 mL
    cp: {
      name: 'cp',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.0002365882,
      offset: 0
    }, // 236.5882 mL
    pt: {
      name: 'pt',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.0004731765,
      offset: 0
    }, // 473.1765 mL
    qt: {
      name: 'qt',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.0009463529,
      offset: 0
    }, // 946.3529 mL
    gal: {
      name: 'gal',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.003785412,
      offset: 0
    }, // 3.785412 L
    bbl: {
      name: 'bbl',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.1173478,
      offset: 0
    }, // 117.3478 L
    obl: {
      name: 'obl',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.1589873,
      offset: 0
    }, // 158.9873 L
    //{name: 'hogshead', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.2384810, offset: 0}, // 238.4810 L // TODO: hh?

    // Mass
    g: {
      name: 'g',
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.SHORT,
      value: 0.001,
      offset: 0
    },
    gram: {
      name: 'gram',
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.LONG,
      value: 0.001,
      offset: 0
    },

    ton: {
      name: 'ton',
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.SHORT,
      value: 907.18474,
      offset: 0
    },
    tonne: {
      name: 'tonne',
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.SHORT,
      value: 1000,
      offset: 0
    },

    grain: {
      name: 'grain',
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 64.79891e-6,
      offset: 0
    },
    dram: {
      name: 'dram',
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 1.7718451953125e-3,
      offset: 0
    },
    ounce: {
      name: 'ounce',
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 28.349523125e-3,
      offset: 0
    },
    poundmass: {
      name: 'poundmass',
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 453.59237e-3,
      offset: 0
    },
    hundredweight: {
      name: 'hundredweight',
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 45.359237,
      offset: 0
    },
    stick: {
      name: 'stick',
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 115e-3,
      offset: 0
    },
    stone: {
      name: 'stone',
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 6.35029318,
      offset: 0
    },

    gr: {
      name: 'gr',
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 64.79891e-6,
      offset: 0
    },
    dr: {
      name: 'dr',
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 1.7718451953125e-3,
      offset: 0
    },
    oz: {
      name: 'oz',
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 28.349523125e-3,
      offset: 0
    },
    lbm: {
      name: 'lbm',
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 453.59237e-3,
      offset: 0
    },
    cwt: {
      name: 'cwt',
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 45.359237,
      offset: 0
    },

    // Time
    s: {
      name: 's',
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    min: {
      name: 'min',
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 60,
      offset: 0
    },
    h: {
      name: 'h',
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 3600,
      offset: 0
    },
    second: {
      name: 'second',
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    sec: {
      name: 'sec',
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    minute: {
      name: 'minute',
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 60,
      offset: 0
    },
    hour: {
      name: 'hour',
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 3600,
      offset: 0
    },
    day: {
      name: 'day',
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 86400,
      offset: 0
    },
    week: {
      name: 'week',
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 7*86400,
      offset: 0
    },
    month: {
      name: 'month',
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 2629800, //1/12th of Julian year
      offset: 0
    },
    year: {
      name: 'year',
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 31557600, //Julian year
      offset: 0
    },
    decade: {
      name: 'year',
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 315576000, //Julian decade
      offset: 0
    },
    century: {
      name: 'century',
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 3155760000, //Julian century
      offset: 0
    },
    millennium: {
      name: 'millennium',
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 31557600000, //Julian millennium
      offset: 0
    },

    // Frequency
    hertz: {
      name: 'Hertz',
      base: BASE_UNITS.FREQUENCY,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0,
      reciprocal: true
    },
    Hz: {
      name: 'Hz',
      base: BASE_UNITS.FREQUENCY,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0,
      reciprocal: true
    },

    // Angle
    rad: {
      name: 'rad',
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.NONE,
      value: 1,
      offset: 0
    },
    // deg = rad / (2*pi) * 360 = rad / 0.017453292519943295769236907684888
    deg: {
      name: 'deg',
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.NONE,
      value: null, // will be filled in by calculateAngleValues()
      offset: 0
    },
    // grad = rad / (2*pi) * 400  = rad / 0.015707963267948966192313216916399
    grad: {
      name: 'grad',
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.NONE,
      value: null, // will be filled in by calculateAngleValues()
      offset: 0
    },
    // cycle = rad / (2*pi) = rad / 6.2831853071795864769252867665793
    cycle: {
      name: 'cycle',
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.NONE,
      value: null, // will be filled in by calculateAngleValues()
      offset: 0
    },
    // arcsec = rad / (3600 * (360 / 2 * pi)) = rad / 0.0000048481368110953599358991410235795
    arcsec: {
      name: 'arcsec',
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.NONE,
      value: null, // will be filled in by calculateAngleValues()
      offset: 0
    },
    // arcmin = rad / (60 * (360 / 2 * pi)) = rad / 0.00029088820866572159615394846141477
    arcmin: {
      name: 'arcmin',
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.NONE,
      value: null, // will be filled in by calculateAngleValues()
      offset: 0
    },
    
    // Electric current
    A: {
      name: 'A',
      base: BASE_UNITS.CURRENT,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    ampere: {
      name: 'ampere',
      base: BASE_UNITS.CURRENT,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },

    // Temperature
    // K(C) = °C + 273.15
    // K(F) = (°F + 459.67) / 1.8
    // K(R) = °R / 1.8
    K: {
      name: 'K',
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.NONE,
      value: 1,
      offset: 0
    },
    degC: {
      name: 'degC',
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.NONE,
      value: 1,
      offset: 273.15
    },
    degF: {
      name: 'degF',
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.NONE,
      value: 1 / 1.8,
      offset: 459.67
    },
    degR: {
      name: 'degR',
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.NONE,
      value: 1 / 1.8,
      offset: 0
    },
    kelvin: {
      name: 'kelvin',
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.NONE,
      value: 1,
      offset: 0
    },
    celsius: {
      name: 'celsius',
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.NONE,
      value: 1,
      offset: 273.15
    },
    fahrenheit: {
      name: 'fahrenheit',
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.NONE,
      value: 1 / 1.8,
      offset: 459.67
    },
    rankine: {
      name: 'rankine',
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.NONE,
      value: 1 / 1.8,
      offset: 0
    },

    // amount of substance
    mol: {
      name: 'mol',
      base: BASE_UNITS.AMOUNT_OF_SUBSTANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    mole: {
      name: 'mole',
      base: BASE_UNITS.AMOUNT_OF_SUBSTANCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },

    // luminous intensity
    cd: {
      name: 'cd',
      base: BASE_UNITS.LUMINOUS_INTENSITY,
      prefixes: PREFIXES.NONE,
      value: 1,
      offset: 0
    },
    candela: {
      name: 'candela',
      base: BASE_UNITS.LUMINOUS_INTENSITY,
      prefixes: PREFIXES.NONE,
      value: 1,
      offset: 0
    },
    // TODO: units STERADIAN
    //{name: 'sr', base: BASE_UNITS.STERADIAN, prefixes: PREFIXES.NONE, value: 1, offset: 0},
    //{name: 'steradian', base: BASE_UNITS.STERADIAN, prefixes: PREFIXES.NONE, value: 1, offset: 0},

    // Force
    N: {
      name: 'N',
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    newton: {
      name: 'newton',
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    dyn: {
      name: 'dyn',
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.SHORT,
      value: 0.00001,
      offset: 0
    },
    dyne: {
      name: 'dyne',
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.LONG,
      value: 0.00001,
      offset: 0
    },
    lbf: {
      name: 'lbf',
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.NONE,
      value: 4.4482216152605,
      offset: 0
    },
    poundforce: {
      name: 'poundforce',
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.NONE,
      value: 4.4482216152605,
      offset: 0
    },
    kip: {
      name: 'kip',
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.LONG,
      value: 4448.2216,
      offset: 0
    },
	
    // Energy
    J: {
      name: 'J',
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    joule: {
      name: 'joule',
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    erg: {
      name: 'erg',
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.NONE,
      value: 1e-5,
      offset: 0
    },
    Wh: {
      name: 'Wh',
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.SHORT,
      value: 3600,
      offset: 0
    },
    BTU: {
      name: 'BTU',
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.BTU,
      value: 1055.05585262,
      offset: 0
    },
    eV: {
      name: 'eV',
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.SHORT,
      value: 1.602176565e-19,
      offset: 0
    },
    electronvolt: {
      name: 'electronvolt',
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.LONG,
      value: 1.602176565e-19,
      offset: 0
    },


    // Power
    W: {
      name: 'W',
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    watt: {
      name: 'W',
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    hp: {
      name: 'hp',
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.NONE,
      value: 745.6998715386,
      offset: 0
    },

    // Electrical power units
    VAR: {
      name: 'VAR',
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.SHORT,
      value: Complex.I,
      offset: 0
    },
    
    VA: {
      name: 'VA',
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },

    // Pressure
    Pa: {
      name: 'Pa',
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    psi: {
      name: 'psi',
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 6894.75729276459,
      offset: 0
    },
    atm: {
      name: 'atm',
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 101325,
      offset: 0
    },
    bar: {
      name: 'bar',
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 100000,
      offset: 0
    },
    torr: {
      name: 'torr',
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 133.322,
      offset: 0
    },
    mmHg: {
      name: 'mmHg',
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 133.322,
      offset: 0
    },
    mmH2O: {
      name: 'mmH2O',
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 9.80665,
      offset: 0
    },
    cmH2O: {
      name: 'cmH2O',
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 98.0665,
      offset: 0
    },

    // Electric charge
    coulomb: {
      name: 'coulomb',
      base: BASE_UNITS.ELECTRIC_CHARGE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    C: {
      name: 'C',
      base: BASE_UNITS.ELECTRIC_CHARGE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Electric capacitance
    farad: {
      name: 'farad',
      base: BASE_UNITS.ELECTRIC_CAPACITANCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    F: {
      name: 'F',
      base: BASE_UNITS.ELECTRIC_CAPACITANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Electric potential
    volt: {
      name: 'volt',
      base: BASE_UNITS.ELECTRIC_POTENTIAL,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    V: {
      name: 'V',
      base: BASE_UNITS.ELECTRIC_POTENTIAL,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Electric resistance
    ohm: {
      name: 'ohm',
      base: BASE_UNITS.ELECTRIC_RESISTANCE,
      prefixes: PREFIXES.SHORTLONG,    // Both Mohm and megaohm are acceptable
      value: 1,
      offset: 0
    },
    /*
     * Unicode breaks in browsers if charset is not specified
    Ω: {
      name: 'Ω',
      base: BASE_UNITS.ELECTRIC_RESISTANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    */
    // Electric inductance
    henry: {
      name: 'henry',
      base: BASE_UNITS.ELECTRIC_INDUCTANCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    H: {
      name: 'H',
      base: BASE_UNITS.ELECTRIC_INDUCTANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Electric conductance
    siemens: {
      name: 'siemens',
      base: BASE_UNITS.ELECTRIC_CONDUCTANCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    S: {
      name: 'S',
      base: BASE_UNITS.ELECTRIC_CONDUCTANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Magnetic flux
    weber: {
      name: 'weber',
      base: BASE_UNITS.MAGNETIC_FLUX,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    Wb: {
      name: 'Wb',
      base: BASE_UNITS.MAGNETIC_FLUX,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Magnetic flux density
    tesla: {
      name: 'tesla',
      base: BASE_UNITS.MAGNETIC_FLUX_DENSITY,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    T: {
      name: 'T',
      base: BASE_UNITS.MAGNETIC_FLUX_DENSITY,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },

    // Binary
    b: {
      name: 'b',
      base: BASE_UNITS.BIT,
      prefixes: PREFIXES.BINARY_SHORT,
      value: 1,
      offset: 0
    },
    bits: {
      name: 'bits',
      base: BASE_UNITS.BIT,
      prefixes: PREFIXES.BINARY_LONG,
      value: 1,
      offset: 0
    },
    B: {
      name: 'B',
      base: BASE_UNITS.BIT,
      prefixes: PREFIXES.BINARY_SHORT,
      value: 8,
      offset: 0
    },
    bytes: {
      name: 'bytes',
      base: BASE_UNITS.BIT,
      prefixes: PREFIXES.BINARY_LONG,
      value: 8,
      offset: 0
    }
  };

  // aliases (formerly plurals)
  var ALIASES = {
    meters: 'meter',
    inches: 'inch',
    feet: 'foot',
    yards: 'yard',
    miles: 'mile',
    links: 'link',
    rods: 'rod',
    chains: 'chain',
    angstroms: 'angstrom',

    lt: 'l',
    litres: 'litre',
    liter: 'litre',
    liters: 'litre',
    teaspoons: 'teaspoon',
    tablespoons: 'tablespoon',
    minims: 'minim',
    fluiddrams: 'fluiddram',
    fluidounces: 'fluidounce',
    gills: 'gill',
    cups: 'cup',
    pints: 'pint',
    quarts: 'quart',
    gallons: 'gallon',
    beerbarrels: 'beerbarrel',
    oilbarrels: 'oilbarrel',
    hogsheads: 'hogshead',
    gtts: 'gtt',

    grams: 'gram',
    tons: 'ton',
    tonnes: 'tonne',
    grains: 'grain',
    drams: 'dram',
    ounces: 'ounce',
    poundmasses: 'poundmass',
    hundredweights: 'hundredweight',
    sticks: 'stick',
    lb: 'lbm',
    lbs: 'lbm',
	
    kips: 'kip',

    acres: 'acre',
    hectares: 'hectare',
    sqfeet: 'sqft',
    sqyard: 'sqyd',
    sqmile: 'sqmi',
    sqmiles: 'sqmi',

    mmhg: 'mmHg',
    mmh2o: 'mmH2O',
    cmh2o: 'cmH2O',

    seconds: 'second',
    secs: 'second',
    minutes: 'minute',
    mins: 'minute',
    hours: 'hour',
    hr: 'hour',
    hrs: 'hour',
    days: 'day',

    hertz: 'hertz',

    radians: 'rad',
    degree: 'deg',
    degrees: 'deg',
    gradian: 'grad',
    gradians: 'grad',
    cycles: 'cycle',
    arcsecond: 'arcsec',
    arcseconds: 'arcsec',
    arcminute: 'arcmin',
    arcminutes: 'arcmin',

    BTUs: 'BTU',
    watts: 'watt',
    joules: 'joule',

    amperes: 'ampere',
    coulombs: 'coulomb',
    volts: 'volt',
    ohms: 'ohm',
    farads: 'farad',
    webers: 'weber',
    teslas: 'tesla',
    electronvolts: 'electronvolt',
    moles: 'mole'

  };

  /**
   * Calculate the values for the angle units.
   * Value is calculated as number or BigNumber depending on the configuration
   * @param {{number: 'number' | 'BigNumber'}} config
   */
  function calculateAngleValues (config) {
    if (config.number === 'BigNumber') {
      var pi = constants.pi(type.BigNumber);
      UNITS.rad.value = new type.BigNumber(1);
      UNITS.deg.value = pi.div(180);        // 2 * pi / 360;
      UNITS.grad.value = pi.div(200);       // 2 * pi / 400;
      UNITS.cycle.value = pi.times(2);      // 2 * pi
      UNITS.arcsec.value = pi.div(648000);  // 2 * pi / 360 / 3600
      UNITS.arcmin.value = pi.div(10800);   // 2 * pi / 360 / 60
    }
    else { // number
      UNITS.rad.value = 1;
      UNITS.deg.value = Math.PI / 180;        // 2 * pi / 360;
      UNITS.grad.value = Math.PI / 200;       // 2 * pi / 400;
      UNITS.cycle.value = Math.PI * 2;        // 2 * pi
      UNITS.arcsec.value = Math.PI / 648000;  // 2 * pi / 360 / 3600;
      UNITS.arcmin.value = Math.PI / 10800;   // 2 * pi / 360 / 60;
    }
  }

  // apply the angle values now
  calculateAngleValues(config);

  // recalculate the values on change of configuration
  math.on('config', function (curr, prev) {
    if (curr.number !== prev.number) {
      calculateAngleValues(curr);
    }
  });

  /**
   * A unit system is a set of dimensionally independent base units plus a set of derived units, formed by multiplication and division of the base units, that are by convention used with the unit system.
   * A user perhaps could issue a command to select a preferred unit system, or use the default (see below).
   * Auto unit system: The default unit system is updated on the fly anytime a unit is parsed. The corresponding unit in the default unit system is updated, so that answers are given in the same units the user supplies.
   */
  var UNIT_SYSTEMS = {
    si: {
      // Base units
      NONE:                  {unit: UNIT_NONE, prefix: PREFIXES.NONE['']},
      LENGTH:                {unit: UNITS.m,   prefix: PREFIXES.SHORT['']},
      MASS:                  {unit: UNITS.g,   prefix: PREFIXES.SHORT['k']}, 
      TIME:                  {unit: UNITS.s,   prefix: PREFIXES.SHORT['']}, 
      CURRENT:               {unit: UNITS.A,   prefix: PREFIXES.SHORT['']}, 
      TEMPERATURE:           {unit: UNITS.K,   prefix: PREFIXES.SHORT['']}, 
      LUMINOUS_INTENSITY:    {unit: UNITS.cd,  prefix: PREFIXES.SHORT['']}, 
      AMOUNT_OF_SUBSTANCE:   {unit: UNITS.mol, prefix: PREFIXES.SHORT['']}, 
      ANGLE:                 {unit: UNITS.rad, prefix: PREFIXES.SHORT['']}, 
      BIT:                   {unit: UNITS.bit, prefix: PREFIXES.SHORT['']}, 

      // Derived units
      FORCE:                 {unit: UNITS.N,   prefix: PREFIXES.SHORT['']}, 
      ENERGY:                {unit: UNITS.J,   prefix: PREFIXES.SHORT['']},
      POWER:                 {unit: UNITS.W,   prefix: PREFIXES.SHORT['']},
      PRESSURE:              {unit: UNITS.Pa,  prefix: PREFIXES.SHORT['']},
      ELECTRIC_CHARGE:       {unit: UNITS.C,   prefix: PREFIXES.SHORT['']},
      ELECTRIC_CAPACITANCE:  {unit: UNITS.F,   prefix: PREFIXES.SHORT['']},
      ELECTRIC_POTENTIAL:    {unit: UNITS.V,   prefix: PREFIXES.SHORT['']},
      ELECTRIC_RESISTANCE:   {unit: UNITS.ohm, prefix: PREFIXES.SHORT['']},
      ELECTRIC_INDUCTANCE:   {unit: UNITS.H,   prefix: PREFIXES.SHORT['']},
      ELECTRIC_CONDUCTANCE:  {unit: UNITS.S,   prefix: PREFIXES.SHORT['']},
      MAGNETIC_FLUX:         {unit: UNITS.Wb,  prefix: PREFIXES.SHORT['']},
      MAGNETIC_FLUX_DENSITY: {unit: UNITS.T,   prefix: PREFIXES.SHORT['']},
      FREQUENCY:             {unit: UNITS.Hz,  prefix: PREFIXES.SHORT['']}
    }
  };

  // Clone to create the other unit systems
  UNIT_SYSTEMS.cgs = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
  UNIT_SYSTEMS.cgs.LENGTH = {unit: UNITS.m,   prefix: PREFIXES.SHORT['c']};
  UNIT_SYSTEMS.cgs.MASS =   {unit: UNITS.g,   prefix: PREFIXES.SHORT['']};
  UNIT_SYSTEMS.cgs.FORCE =  {unit: UNITS.dyn, prefix: PREFIXES.SHORT['']};
  UNIT_SYSTEMS.cgs.ENERGY = {unit: UNITS.erg, prefix: PREFIXES.NONE['']};
  // there are wholly 4 unique cgs systems for electricity and magnetism,
  // so let's not worry about it unless somebody complains
  
  UNIT_SYSTEMS.us = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
  UNIT_SYSTEMS.us.LENGTH =      {unit: UNITS.ft,   prefix: PREFIXES.NONE['']};
  UNIT_SYSTEMS.us.MASS =        {unit: UNITS.lbm,  prefix: PREFIXES.NONE['']};
  UNIT_SYSTEMS.us.TEMPERATURE = {unit: UNITS.degF, prefix: PREFIXES.NONE['']};
  UNIT_SYSTEMS.us.FORCE =       {unit: UNITS.lbf,  prefix: PREFIXES.NONE['']};
  UNIT_SYSTEMS.us.ENERGY =      {unit: UNITS.BTU,  prefix: PREFIXES.BTU['']};
  UNIT_SYSTEMS.us.POWER =       {unit: UNITS.hp,   prefix: PREFIXES.NONE['']};
  UNIT_SYSTEMS.us.PRESSURE =    {unit: UNITS.psi,  prefix: PREFIXES.NONE['']};

  // Add additional unit systems here.



  // Choose a unit system to seed the auto unit system.
  UNIT_SYSTEMS.auto = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));

  // Set the current unit system
  var currentUnitSystem = UNIT_SYSTEMS.auto;

  /**
   * Set a unit system for formatting derived units.
   * @param {string} [name] The name of the unit system.
   */
  Unit.setUnitSystem = function(name) {
    if(UNIT_SYSTEMS.hasOwnProperty(name)) {
      currentUnitSystem = UNIT_SYSTEMS[name];
    }
    else {
      throw new Error('Unit system ' + name + ' does not exist. Choices are: ' + Object.keys(UNIT_SYSTEMS).join(', '));
    }
  };

  /**
   * Return the current unit system.
   * @return {string} The current unit system.
   */
  Unit.getUnitSystem = function() {
    for(var key in UNIT_SYSTEMS) {
      if(UNIT_SYSTEMS[key] === currentUnitSystem) {
        return key;
      }
    }
  };

  /**
   * Converters to convert from number to an other numeric type like BigNumber
   * or Fraction
   */
  Unit.typeConverters = {
    BigNumber: function (x) {
      return new type.BigNumber(x + ''); // stringify to prevent constructor error
    },

    Fraction: function (x) {
      return new type.Fraction(x);
    },

    Complex: function (x) {
      return x;
    },

    number: function (x) {
      return x;
    }
  };

  /**
   * Retrieve the right convertor function corresponding with the type
   * of provided exampleValue.
   *
   * @param {string} type   A string 'number', 'BigNumber', or 'Fraction'
   *                        In case of an unknown type,
   * @return {Function}
   */
  Unit._getNumberConverter = function (type) {
    if (!Unit.typeConverters[type]) {
      throw new TypeError('Unsupported type "' + type + '"');
    }

    return Unit.typeConverters[type];
  };

  // Add dimensions to each built-in unit
  for (var key in UNITS) {
    var unit = UNITS[key];
    unit.dimensions = unit.base.dimensions;
  }    

  // Create aliases
  for (var name in ALIASES) {
    /* istanbul ignore next (we cannot really test next statement) */
    if (ALIASES.hasOwnProperty(name)) {
      var unit = UNITS[ALIASES[name]];
      var alias = Object.create(unit);
      alias.name = name;
      UNITS[name] = alias;
    }
  }

  Unit.PREFIXES = PREFIXES;
  Unit.BASE_UNITS = BASE_UNITS;
  Unit.UNITS = UNITS;
  Unit.UNIT_SYSTEMS = UNIT_SYSTEMS;

  return Unit;
}

exports.name = 'Unit';
exports.path = 'type';
exports.factory = factory;
exports.math = true; // request access to the math namespace

},{"../../function/arithmetic/abs":254,"../../function/arithmetic/addScalar":256,"../../function/arithmetic/divideScalar":261,"../../function/arithmetic/multiplyScalar":276,"../../function/arithmetic/pow":279,"../../function/arithmetic/subtract":284,"../../function/relational/equal":351,"../../function/string/format":370,"../../function/utils/isNumeric":405,"../../function/utils/typeof":408,"../../type/complex/Complex":419,"../../type/number":452,"../../utils/bignumber/constants":467,"../../utils/object":484,"../../utils/string":485}],457:[function(require,module,exports){
'use strict';

var deepMap = require('../../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Create a unit. Depending on the passed arguments, the function
   * will create and return a new math.type.Unit object.
   * When a matrix is provided, all elements will be converted to units.
   *
   * Syntax:
   *
   *     math.unit(unit : string)
   *     math.unit(value : number, unit : string)
   *
   * Examples:
   *
   *    var a = math.unit(5, 'cm');    // returns Unit 50 mm
   *    var b = math.unit('23 kg');    // returns Unit 23 kg
   *    a.to('m');                     // returns Unit 0.05 m
   *
   * See also:
   *
   *    bignumber, boolean, complex, index, matrix, number, string
   *
   * @param {* | Array | Matrix} args   A number and unit.
   * @return {Unit | Array | Matrix}    The created unit
   */

  var unit = typed('unit', {
    'Unit': function (x) {
      return x.clone();
    },

    'string': function (x) {
      if (type.Unit.isValuelessUnit(x)) {
        return new type.Unit(null, x); // a pure unit
      }

      return type.Unit.parse(x); // a unit with value, like '5cm'
    },

    'number | BigNumber | Fraction | Complex, string': function (value, unit) {
      return new type.Unit(value, unit);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, unit);
    }
  });

  unit.toTex = {
    1: '\\left(${args[0]}\\right)',
    2: '\\left(\\left(${args[0]}\\right)${args[1]}\\right)'
  };

  return unit;
}

exports.name = 'unit';
exports.factory = factory;

},{"../../../utils/collection/deepMap":475}],458:[function(require,module,exports){
module.exports = [
  // type
  require('./Unit'),

  // construction function
  require('./function/unit'),

  // physical constants
  require('./physicalConstants')
];

},{"./Unit":456,"./function/unit":457,"./physicalConstants":459}],459:[function(require,module,exports){
var lazy = require('../../utils/object').lazy;


function factory (type, config, load, typed, math) {

  // helper function to create a unit with a fixed prefix
  function fixedUnit(str) {
    var unit = type.Unit.parse(str);
    unit.fixPrefix = true;
    return unit;
  }

  // Source: http://www.wikiwand.com/en/Physical_constant

  // Universal constants
  lazy(math, 'speedOfLight',         function () {return fixedUnit('299792458 m s^-1')});
  lazy(math, 'gravitationConstant',  function () {return fixedUnit('6.6738480e-11 m^3 kg^-1 s^-2')});
  lazy(math, 'planckConstant',       function () {return fixedUnit('6.626069311e-34 J s')});
  lazy(math, 'reducedPlanckConstant',function () {return fixedUnit('1.05457172647e-34 J s')});

  // Electromagnetic constants
  lazy(math, 'magneticConstant',          function () {return fixedUnit('1.2566370614e-6 N A^-2')});
  lazy(math, 'electricConstant',          function () {return fixedUnit('8.854187817e-12 F m^-1')});
  lazy(math, 'vacuumImpedance',           function () {return fixedUnit('376.730313461 ohm')});
  lazy(math, 'coulomb',                   function () {return fixedUnit('8.9875517873681764e9 N m^2 C^-2')});
  lazy(math, 'elementaryCharge',          function () {return fixedUnit('1.60217656535e-19 C')});
  lazy(math, 'bohrMagneton',              function () {return fixedUnit('9.2740096820e-24 J T^-1')});
  lazy(math, 'conductanceQuantum',        function () {return fixedUnit('7.748091734625e-5 S')});
  lazy(math, 'inverseConductanceQuantum', function () {return fixedUnit('12906.403721742 ohm')});
  lazy(math, 'magneticFluxQuantum',       function () {return fixedUnit('2.06783375846e-15 Wb')});
  lazy(math, 'nuclearMagneton',           function () {return fixedUnit('5.0507835311e-27 J T^-1')});
  lazy(math, 'klitzing',                  function () {return fixedUnit('25812.807443484 ohm')});
  //lazy(math, 'josephson',                 function () {return fixedUnit('4.8359787011e-14 Hz V^-1')});  // TODO: support for Hz needed

  // Atomic and nuclear constants
  lazy(math, 'bohrRadius',              function () {return fixedUnit('5.291772109217e-11 m')});
  lazy(math, 'classicalElectronRadius', function () {return fixedUnit('2.817940326727e-15 m')});
  lazy(math, 'electronMass',            function () {return fixedUnit('9.1093829140e-31 kg')});
  lazy(math, 'fermiCoupling',           function () {return fixedUnit('1.1663645e-5 GeV^-2')});
  lazy(math, 'fineStructure',           function () {return 7.297352569824e-3});
  lazy(math, 'hartreeEnergy',           function () {return fixedUnit('4.3597443419e-18 J')});
  lazy(math, 'protonMass',              function () {return fixedUnit('1.67262177774e-27 kg')});
  lazy(math, 'deuteronMass',            function () {return fixedUnit('3.3435830926e-27 kg')});
  lazy(math, 'neutronMass',             function () {return fixedUnit('1.6749271613e-27 kg')});
  lazy(math, 'quantumOfCirculation',    function () {return fixedUnit('3.636947552024e-4 m^2 s^-1')});
  lazy(math, 'rydberg',                 function () {return fixedUnit('10973731.56853955 m^-1')});
  lazy(math, 'thomsonCrossSection',     function () {return fixedUnit('6.65245873413e-29 m^2')});
  lazy(math, 'weakMixingAngle',         function () {return 0.222321});
  lazy(math, 'efimovFactor',            function () {return 22.7});

  // Physico-chemical constants
  lazy(math, 'atomicMass',          function () {return fixedUnit('1.66053892173e-27 kg')});
  lazy(math, 'avogadro',            function () {return fixedUnit('6.0221412927e23 mol^-1')});
  lazy(math, 'boltzmann',           function () {return fixedUnit('1.380648813e-23 J K^-1')});
  lazy(math, 'faraday',             function () {return fixedUnit('96485.336521 C mol^-1')});
  lazy(math, 'firstRadiation',      function () {return fixedUnit('3.7417715317e-16 W m^2')});
  // lazy(math, 'spectralRadiance',   function () {return fixedUnit('1.19104286953e-16 W m^2 sr^-1')}); // TODO spectralRadiance
  lazy(math, 'loschmidt',           function () {return fixedUnit('2.686780524e25 m^-3')});
  lazy(math, 'gasConstant',         function () {return fixedUnit('8.314462175 J K^-1 mol^-1')});
  lazy(math, 'molarPlanckConstant', function () {return fixedUnit('3.990312717628e-10 J s mol^-1')});
  lazy(math, 'molarVolume',         function () {return fixedUnit('2.241396820e-10 m^3 mol^-1')});
  lazy(math, 'sackurTetrode',       function () {return -1.164870823});
  lazy(math, 'secondRadiation',     function () {return fixedUnit('1.438777013e-2 m K')});
  lazy(math, 'stefanBoltzmann',     function () {return fixedUnit('5.67037321e-8 W m^-2 K^-4')});
  lazy(math, 'wienDisplacement',    function () {return fixedUnit('2.897772126e-3 m K')});

  // Adopted values
  lazy(math, 'molarMass',         function () {return fixedUnit('1e-3 kg mol^-1')});
  lazy(math, 'molarMassC12',      function () {return fixedUnit('1.2e-2 kg mol^-1')});
  lazy(math, 'gravity',           function () {return fixedUnit('9.80665 m s^-2')});
  // atm is defined in Unit.js

  // Natural units
  lazy(math, 'planckLength',      function () {return fixedUnit('1.61619997e-35 m')});
  lazy(math, 'planckMass',        function () {return fixedUnit('2.1765113e-8 kg')});
  lazy(math, 'planckTime',        function () {return fixedUnit('5.3910632e-44 s')});
  lazy(math, 'planckCharge',      function () {return fixedUnit('1.87554595641e-18 C')});
  lazy(math, 'planckTemperature', function () {return fixedUnit('1.41683385e+32 K')});

}

exports.factory = factory;
exports.lazy = false;  // no lazy loading of constants, the constants themselves are lazy when needed
exports.math = true;   // request access to the math namespace

},{"../../utils/object":484}],460:[function(require,module,exports){
'use strict';

/**
 * Format a number using methods toPrecision, toFixed, toExponential.
 * @param {number | string} value
 * @constructor
 */
function NumberFormatter (value) {
  // parse the input value
  var match = String(value).toLowerCase().match(/^0*?(-?)(\d+\.?\d*)(e([+-]?\d+))?$/);
  if (!match) {
    throw new SyntaxError('Invalid number');
  }

  var sign         = match[1];
  var coefficients = match[2];
  var exponent     = parseFloat(match[4] || '0');

  var dot = coefficients.indexOf('.');
  exponent += (dot !== -1) ? (dot - 1) : (coefficients.length - 1);

  this.sign = sign;
  this.coefficients = coefficients
      .replace('.', '')  // remove the dot (must be removed before removing leading zeros)
      .replace(/^0*/, function (zeros) {
        // remove leading zeros, add their count to the exponent
        exponent -= zeros.length;
        return '';
      })
      .replace(/0*$/, '') // remove trailing zeros
      .split('')
      .map(function (d) {
        return parseInt(d);
      });

  if (this.coefficients.length === 0) {
    this.coefficients.push(0);
    exponent++;
  }

  this.exponent = exponent;
}


/**
 * Format a number with engineering notation.
 * @param {number} [precision=0]        Optional number of decimals after the
 *                                      decimal point. Zero by default.
 */
NumberFormatter.prototype.toEngineering = function(precision) {
  var rounded = this.roundDigits(precision);

  var e = rounded.exponent;
  var c = rounded.coefficients;

  // find nearest lower multiple of 3 for exponent
  var newExp = e % 3 === 0 ? e : (e < 0 ? (e - 3) - (e % 3) : e - (e % 3));

  // concatenate coefficients with necessary zeros
  var significandsDiff = e >= 0 ? e : Math.abs(newExp);

  // add zeros if necessary (for ex: 1e+8)
  if (c.length - 1 < significandsDiff) c = c.concat(zeros(significandsDiff - (c.length - 1)));

  // find difference in exponents
  var expDiff = Math.abs(e - newExp);

  var decimalIdx = 1;
  var str = '';

  // push decimal index over by expDiff times
  while (--expDiff >= 0) decimalIdx++;

  // if all coefficient values are zero after the decimal point, don't add a decimal value. 
  // otherwise concat with the rest of the coefficients
  var decimals = c.slice(decimalIdx).join('');
  var decimalVal = decimals.match(/[1-9]/) ? ('.' + decimals) : '';

  str = c.slice(0, decimalIdx).join('') + decimalVal;

  str += 'e' + (e >= 0 ? '+' : '') + newExp.toString();
  return rounded.sign + str;
}

/**
 * Format a number with fixed notation.
 * @param {number} [precision=0]        Optional number of decimals after the
 *                                      decimal point. Zero by default.
 */
NumberFormatter.prototype.toFixed = function (precision) {
  var rounded = this.roundDigits(this.exponent + 1 + (precision || 0));
  var c = rounded.coefficients;
  var p = rounded.exponent + 1; // exponent may have changed

  // append zeros if needed
  var pp = p + (precision || 0);
  if (c.length < pp) {
    c = c.concat(zeros(pp - c.length));
  }

  // prepend zeros if needed
  if (p < 0) {
    c = zeros(-p + 1).concat(c);
    p = 1;
  }

  // insert a dot if needed
  if (precision) {
    c.splice(p, 0, (p === 0) ? '0.' : '.');
  }

  return this.sign + c.join('');
};

/**
 * Format a number in exponential notation. Like '1.23e+5', '2.3e+0', '3.500e-3'
 * @param {number} [precision]  Number of digits in formatted output.
 *                              If not provided, the maximum available digits
 *                              is used.
 */
NumberFormatter.prototype.toExponential = function (precision) {
  // round if needed, else create a clone
  var rounded = precision ? this.roundDigits(precision) : this.clone();
  var c = rounded.coefficients;
  var e = rounded.exponent;

  // append zeros if needed
  if (c.length < precision) {
    c = c.concat(zeros(precision - c.length));
  }

  // format as `C.CCCe+EEE` or `C.CCCe-EEE`
  var first = c.shift();
  return this.sign + first + (c.length > 0 ? ('.' + c.join('')) : '') +
      'e' + (e >= 0 ? '+' : '') + e;
};

/**
 * Format a number with a certain precision
 * @param {number} [precision=undefined] Optional number of digits.
 * @param {{lower: number | undefined, upper: number | undefined}} [options]
 *                                       By default:
 *                                         lower = 1e-3 (excl)
 *                                         upper = 1e+5 (incl)
 * @return {string}
 */
NumberFormatter.prototype.toPrecision = function(precision, options) {
  // determine lower and upper bound for exponential notation.
  var lower = (options && options.lower !== undefined) ? options.lower : 1e-3;
  var upper = (options && options.upper !== undefined) ? options.upper : 1e+5;

  var abs = Math.abs(Math.pow(10, this.exponent));
  if (abs < lower || abs >= upper) {
    // exponential notation
    return this.toExponential(precision);
  }
  else {
    var rounded = precision ? this.roundDigits(precision) : this.clone();
    var c = rounded.coefficients;
    var e = rounded.exponent;

    // append trailing zeros
    if (c.length < precision) {
      c = c.concat(zeros(precision - c.length));
    }

    // append trailing zeros
    // TODO: simplify the next statement
    c = c.concat(zeros(e - c.length + 1 +
        (c.length < precision ? precision - c.length : 0)));

    // prepend zeros
    c = zeros(-e).concat(c);

    var dot = e > 0 ? e : 0;
    if (dot < c.length - 1) {
      c.splice(dot + 1, 0, '.');
    }

    return this.sign + c.join('');
  }
};

/**
 * Crete a clone of the NumberFormatter
 * @return {NumberFormatter} Returns a clone of the NumberFormatter
 */
NumberFormatter.prototype.clone = function () {
  var clone = new NumberFormatter('0');
  clone.sign = this.sign;
  clone.coefficients = this.coefficients.slice(0);
  clone.exponent = this.exponent;
  return clone;
};

/**
 * Round the number of digits of a number *
 * @param {number} precision  A positive integer
 * @return {NumberFormatter}  Returns a new NumberFormatter with the rounded
 *                            digits
 */
NumberFormatter.prototype.roundDigits = function (precision) {
  var rounded = this.clone();
  var c = rounded.coefficients;

  // prepend zeros if needed
  while (precision <= 0) {
    c.unshift(0);
    rounded.exponent++;
    precision++;
  }

  if (c.length > precision) {
    var removed = c.splice(precision, c.length - precision);

    if (removed[0] >= 5) {
      var i = precision - 1;
      c[i]++;
      while (c[i] === 10) {
        c.pop();
        if (i === 0) {
          c.unshift(0);
          rounded.exponent++;
          i++;
        }
        i--;
        c[i]++;
      }
    }
  }

  return rounded;
};

/**
 * Create an array filled with zeros.
 * @param {number} length
 * @return {Array}
 */
function zeros(length) {
  var arr = [];
  for (var i = 0; i < length; i++) {
    arr.push(0);
  }
  return arr;
}

module.exports = NumberFormatter;

},{}],461:[function(require,module,exports){
'use strict';

var number = require('./number');
var string = require('./string');
var object = require('./object');
var types = require('./types');

var DimensionError = require('../error/DimensionError');
var IndexError = require('../error/IndexError');

/**
 * Calculate the size of a multi dimensional array.
 * This function checks the size of the first entry, it does not validate
 * whether all dimensions match. (use function `validate` for that)
 * @param {Array} x
 * @Return {Number[]} size
 */
exports.size = function (x) {
  var s = [];

  while (Array.isArray(x)) {
    s.push(x.length);
    x = x[0];
  }

  return s;
};

/**
 * Recursively validate whether each element in a multi dimensional array
 * has a size corresponding to the provided size array.
 * @param {Array} array    Array to be validated
 * @param {number[]} size  Array with the size of each dimension
 * @param {number} dim   Current dimension
 * @throws DimensionError
 * @private
 */
function _validate(array, size, dim) {
  var i;
  var len = array.length;

  if (len != size[dim]) {
    throw new DimensionError(len, size[dim]);
  }

  if (dim < size.length - 1) {
    // recursively validate each child array
    var dimNext = dim + 1;
    for (i = 0; i < len; i++) {
      var child = array[i];
      if (!Array.isArray(child)) {
        throw new DimensionError(size.length - 1, size.length, '<');
      }
      _validate(array[i], size, dimNext);
    }
  }
  else {
    // last dimension. none of the childs may be an array
    for (i = 0; i < len; i++) {
      if (Array.isArray(array[i])) {
        throw new DimensionError(size.length + 1, size.length, '>');
      }
    }
  }
}

/**
 * Validate whether each element in a multi dimensional array has
 * a size corresponding to the provided size array.
 * @param {Array} array    Array to be validated
 * @param {number[]} size  Array with the size of each dimension
 * @throws DimensionError
 */
exports.validate = function(array, size) {
  var isScalar = (size.length == 0);
  if (isScalar) {
    // scalar
    if (Array.isArray(array)) {
      throw new DimensionError(array.length, 0);
    }
  }
  else {
    // array
    _validate(array, size, 0);
  }
};

/**
 * Test whether index is an integer number with index >= 0 and index < length
 * when length is provided
 * @param {number} index    Zero-based index
 * @param {number} [length] Length of the array
 */
exports.validateIndex = function(index, length) {
  if (!number.isNumber(index) || !number.isInteger(index)) {
    throw new TypeError('Index must be an integer (value: ' + index + ')');
  }
  if (index < 0 || (typeof length === 'number' && index >= length)) {
    throw new IndexError(index, length);
  }
};

// a constant used to specify an undefined defaultValue
exports.UNINITIALIZED = {};

/**
 * Resize a multi dimensional array. The resized array is returned.
 * @param {Array} array         Array to be resized
 * @param {Array.<number>} size Array with the size of each dimension
 * @param {*} [defaultValue=0]  Value to be filled in in new entries,
 *                              zero by default. To leave new entries undefined,
 *                              specify array.UNINITIALIZED as defaultValue
 * @return {Array} array         The resized array
 */
exports.resize = function(array, size, defaultValue) {
  // TODO: add support for scalars, having size=[] ?

  // check the type of the arguments
  if (!Array.isArray(array) || !Array.isArray(size)) {
    throw new TypeError('Array expected');
  }
  if (size.length === 0) {
    throw new Error('Resizing to scalar is not supported');
  }

  // check whether size contains positive integers
  size.forEach(function (value) {
    if (!number.isNumber(value) || !number.isInteger(value) || value < 0) {
      throw new TypeError('Invalid size, must contain positive integers ' +
          '(size: ' + string.format(size) + ')');
    }
  });

  // recursively resize the array
  var _defaultValue = (defaultValue !== undefined) ? defaultValue : 0;
  _resize(array, size, 0, _defaultValue);

  return array;
};

/**
 * Recursively resize a multi dimensional array
 * @param {Array} array         Array to be resized
 * @param {number[]} size       Array with the size of each dimension
 * @param {number} dim          Current dimension
 * @param {*} [defaultValue]    Value to be filled in in new entries,
 *                              undefined by default.
 * @private
 */
function _resize (array, size, dim, defaultValue) {
  var i;
  var elem;
  var oldLen = array.length;
  var newLen = size[dim];
  var minLen = Math.min(oldLen, newLen);

  // apply new length
  array.length = newLen;

  if (dim < size.length - 1) {
    // non-last dimension
    var dimNext = dim + 1;

    // resize existing child arrays
    for (i = 0; i < minLen; i++) {
      // resize child array
      elem = array[i];
      if (!Array.isArray(elem)) {
        elem = [elem]; // add a dimension
        array[i] = elem;
      }
      _resize(elem, size, dimNext, defaultValue);
    }

    // create new child arrays
    for (i = minLen; i < newLen; i++) {
      // get child array
      elem = [];
      array[i] = elem;

      // resize new child array
      _resize(elem, size, dimNext, defaultValue);
    }
  }
  else {
    // last dimension

    // remove dimensions of existing values
    for (i = 0; i < minLen; i++) {
      while (Array.isArray(array[i])) {
        array[i] = array[i][0];
      }
    }

    if(defaultValue !== exports.UNINITIALIZED) {
      // fill new elements with the default value
      for (i = minLen; i < newLen; i++) {
        array[i] = defaultValue;
      }
    }
  }
}

/**
 * Squeeze a multi dimensional array
 * @param {Array} array
 * @param {Array} [size]
 * @returns {Array} returns the array itself
 */
exports.squeeze = function(array, size) {
  var s = size || exports.size(array);

  // squeeze outer dimensions
  while (Array.isArray(array) && array.length === 1) {
    array = array[0];
    s.shift();
  }

  // find the first dimension to be squeezed
  var dims = s.length;
  while (s[dims - 1] === 1) {
    dims--;
  }

  // squeeze inner dimensions
  if (dims < s.length) {
    array = _squeeze(array, dims, 0);
    s.length = dims;
  }

  return array;
};

/**
 * Recursively squeeze a multi dimensional array
 * @param {Array} array
 * @param {number} dims Required number of dimensions
 * @param {number} dim  Current dimension
 * @returns {Array | *} Returns the squeezed array
 * @private
 */
function _squeeze (array, dims, dim) {
  var i, ii;

  if (dim < dims) {
    var next = dim + 1;
    for (i = 0, ii = array.length; i < ii; i++) {
      array[i] = _squeeze(array[i], dims, next);
    }
  }
  else {
    while (Array.isArray(array)) {
      array = array[0];
    }
  }

  return array;
}

/**
 * Unsqueeze a multi dimensional array: add dimensions when missing
 * @param {Array} array
 * @param {number} dims     Desired number of dimensions of the array
 * @param {number} [outer]  Number of outer dimensions to be added
 * @param {Array} [size]    Current size of array
 * @returns {Array} returns the array itself
 * @private
 */
exports.unsqueeze = function(array, dims, outer, size) {
  var s = size || exports.size(array);

  // unsqueeze outer dimensions
  if (outer) {
    for (var i = 0; i < outer; i++) {
      array = [array];
      s.unshift(1);
    }
  }

  // unsqueeze inner dimensions
  array = _unsqueeze(array, dims, 0);
  while (s.length < dims) {
    s.push(1);
  }

  return array;
};

/**
 * Recursively unsqueeze a multi dimensional array
 * @param {Array} array
 * @param {number} dims Required number of dimensions
 * @param {number} dim  Current dimension
 * @returns {Array | *} Returns the squeezed array
 * @private
 */
function _unsqueeze (array, dims, dim) {
  var i, ii;

  if (Array.isArray(array)) {
    var next = dim + 1;
    for (i = 0, ii = array.length; i < ii; i++) {
      array[i] = _unsqueeze(array[i], dims, next);
    }
  }
  else {
    for (var d = dim; d < dims; d++) {
      array = [array];
    }
  }

  return array;
}
/**
 * Flatten a multi dimensional array, put all elements in a one dimensional
 * array
 * @param {Array} array   A multi dimensional array
 * @return {Array}        The flattened array (1 dimensional)
 */
exports.flatten = function(array) {
  if (!Array.isArray(array)) {
    //if not an array, return as is
    return array;
  }
  var flat = [];

  array.forEach(function callback(value) {
    if (Array.isArray(value)) {
      value.forEach(callback);  //traverse through sub-arrays recursively
    }
    else {
      flat.push(value);
    }
  });

  return flat;
};

/**
 * Test whether an object is an array
 * @param {*} value
 * @return {boolean} isArray
 */
exports.isArray = Array.isArray;

},{"../error/DimensionError":11,"../error/IndexError":12,"./number":483,"./object":484,"./string":485,"./types":486}],462:[function(require,module,exports){
var bitwise = require('./bitwise');

/**
 * Bitwise and for Bignumbers
 *
 * Special Cases:
 *   N &  n =  N
 *   n &  0 =  0
 *   n & -1 =  n
 *   n &  n =  n
 *   I &  I =  I
 *  -I & -I = -I
 *   I & -I =  0
 *   I &  n =  n
 *   I & -n =  I
 *  -I &  n =  0
 *  -I & -n = -I
 *
 * @param {BigNumber} x
 * @param {BigNumber} y
 * @return {BigNumber} Result of `x` & `y`, is fully precise
 * @private
 */
module.exports = function bitAnd(x, y) {
  if ((x.isFinite() && !x.isInteger()) || (y.isFinite() && !y.isInteger())) {
    throw new Error('Integers expected in function bitAnd');
  }

  var BigNumber = x.constructor;
  if (x.isNaN() || y.isNaN()) {
    return new BigNumber(NaN);
  }

  if (x.isZero() || y.eq(-1) || x.eq(y)) {
    return x;
  }
  if (y.isZero() || x.eq(-1)) {
    return y;
  }

  if (!x.isFinite() || !y.isFinite()) {
    if (!x.isFinite() && !y.isFinite()) {
      if (x.isNegative() == y.isNegative()) {
        return x;
      }
      return new BigNumber(0);
    }
    if (!x.isFinite()) {
      if (y.isNegative()) {
        return x;
      }
      if (x.isNegative()) {
        return new BigNumber(0);
      }
      return y;
    }
    if (!y.isFinite()) {
      if (x.isNegative()) {
        return y;
      }
      if (y.isNegative()) {
        return new BigNumber(0);
      }
      return x;
    }
  }
  return bitwise(x, y, function (a, b) { return a & b });
};

},{"./bitwise":466}],463:[function(require,module,exports){
/**
 * Bitwise not
 * @param {BigNumber} value
 * @return {BigNumber} Result of ~`x`, fully precise
 *
 */
module.exports = function bitNot (x) {
  if (x.isFinite() && !x.isInteger()) {
    throw new Error('Integer expected in function bitNot');
  }

  var BigNumber = x.constructor;
  var prevPrec = BigNumber.precision;
  BigNumber.config({precision: 1E9});

  var x = x.plus(new BigNumber(1));
  x.s = -x.s || null;

  BigNumber.config({precision: prevPrec});
  return x;
};

},{}],464:[function(require,module,exports){
var bitwise = require('./bitwise');

/**
 * Bitwise OR for BigNumbers
 *
 * Special Cases:
 *   N |  n =  N
 *   n |  0 =  n
 *   n | -1 = -1
 *   n |  n =  n
 *   I |  I =  I
 *  -I | -I = -I
 *   I | -n = -1
 *   I | -I = -1
 *   I |  n =  I
 *  -I |  n = -I
 *  -I | -n = -n
 *
 * @param {BigNumber} x
 * @param {BigNumber} y
 * @return {BigNumber} Result of `x` | `y`, fully precise
 */
module.exports = function bitOr (x, y) {
  if ((x.isFinite() && !x.isInteger()) || (y.isFinite() && !y.isInteger())) {
    throw new Error('Integers expected in function bitOr');
  }

  var BigNumber = x.constructor;
  if (x.isNaN() || y.isNaN()) {
    return new BigNumber(NaN);
  }

  var negOne = new BigNumber(-1);
  if (x.isZero() || y.eq(negOne) || x.eq(y)) {
    return y;
  }
  if (y.isZero() || x.eq(negOne)) {
    return x;
  }

  if (!x.isFinite() || !y.isFinite()) {
    if ((!x.isFinite() && !x.isNegative() && y.isNegative()) ||
        (x.isNegative() && !y.isNegative() && !y.isFinite())) {
      return negOne;
    }
    if (x.isNegative() && y.isNegative()) {
      return x.isFinite() ? x : y;
    }
    return x.isFinite() ? y : x;
  }

  return bitwise(x, y, function (a, b) { return a | b });
};

},{"./bitwise":466}],465:[function(require,module,exports){
var bitwise = require('./bitwise');
var bitNot = require('./bitNot');

/**
 * Bitwise XOR for BigNumbers
 *
 * Special Cases:
 *   N ^  n =  N
 *   n ^  0 =  n
 *   n ^  n =  0
 *   n ^ -1 = ~n
 *   I ^  n =  I
 *   I ^ -n = -I
 *   I ^ -I = -1
 *  -I ^  n = -I
 *  -I ^ -n =  I
 *
 * @param {BigNumber} x
 * @param {BigNumber} y
 * @return {BigNumber} Result of `x` ^ `y`, fully precise
 *
 */
module.exports = function bitXor(x, y) {
  if ((x.isFinite() && !x.isInteger()) || (y.isFinite() && !y.isInteger())) {
    throw new Error('Integers expected in function bitXor');
  }

  var BigNumber = x.constructor;
  if (x.isNaN() || y.isNaN()) {
    return new BigNumber(NaN);
  }
  if (x.isZero()) {
    return y;
  }
  if (y.isZero()) {
    return x;
  }

  if (x.eq(y)) {
    return new BigNumber(0);
  }

  var negOne = new BigNumber(-1);
  if (x.eq(negOne)) {
    return bitNot(y);
  }
  if (y.eq(negOne)) {
    return bitNot(x);
  }

  if (!x.isFinite() || !y.isFinite()) {
    if (!x.isFinite() && !y.isFinite()) {
      return negOne;
    }
    return new BigNumber(x.isNegative() == y.isNegative()
        ?  Infinity
        : -Infinity);
  }
  return bitwise(x, y, function (a, b) { return a ^ b });
};

},{"./bitNot":463,"./bitwise":466}],466:[function(require,module,exports){
var bitNot = require('./bitNot');

/**
 * Applies bitwise function to numbers
 * @param {BigNumber} x
 * @param {BigNumber} y
 * @param {function (a, b)} func
 * @return {BigNumber}
 */
module.exports = function bitwise(x, y, func) {
  var BigNumber = x.constructor;

  var xBits, yBits;
  var xSign = +(x.s < 0);
  var ySign = +(y.s < 0);
  if (xSign) {
    xBits = decCoefficientToBinaryString(bitNot(x));
    for (var i = 0; i < xBits.length; ++i) {
      xBits[i] ^= 1;
    }
  } else {
    xBits = decCoefficientToBinaryString(x);
  }
  if (ySign) {
    yBits = decCoefficientToBinaryString(bitNot(y));
    for (var i = 0; i < yBits.length; ++i) {
      yBits[i] ^= 1;
    }
  } else {
    yBits = decCoefficientToBinaryString(y);
  }

  var minBits, maxBits, minSign;
  if (xBits.length <= yBits.length) {
    minBits = xBits;
    maxBits = yBits;
    minSign = xSign;
  } else {
    minBits = yBits;
    maxBits = xBits;
    minSign = ySign;
  }

  var shortLen = minBits.length;
  var longLen = maxBits.length;
  var expFuncVal = func(xSign, ySign) ^ 1;
  var outVal = new BigNumber(expFuncVal ^ 1);
  var twoPower = new BigNumber(1);
  var two = new BigNumber(2);

  var prevPrec = BigNumber.precision;
  BigNumber.config({precision: 1E9});

  while (shortLen > 0) {
    if (func(minBits[--shortLen], maxBits[--longLen]) == expFuncVal) {
      outVal = outVal.plus(twoPower);
    }
    twoPower = twoPower.times(two);
  }
  while (longLen > 0) {
    if (func(minSign, maxBits[--longLen]) == expFuncVal) {
      outVal = outVal.plus(twoPower);
    }
    twoPower = twoPower.times(two);
  }

  BigNumber.config({precision: prevPrec});

  if (expFuncVal == 0) {
    outVal.s = -outVal.s;
  }
  return outVal;
};

/* Extracted from decimal.js, and edited to specialize. */
function decCoefficientToBinaryString (x) {
  // Convert to string
  var a = x.d; // array with digits
  var r = a[0] + '';

  for (var i = 1; i < a.length; ++i) {
    var s = a[i] + '';
    for (var z = 7 - s.length; z--; ) {
      s = '0' + s;
    }

    r += s;
  }

  var j;
  for (j = r.length - 1; r.charAt(j) == '0'; --j);

  var xe = x.e;
  var str = r.slice(0, j + 1 || 1);
  var strL = str.length;
  if (xe > 0) {
    if (++xe > strL) {
      // Append zeros.
      for (xe -= strL; xe--; str += '0');
    } else if (xe < strL) {
      str = str.slice(0, xe) + '.' + str.slice(xe);
    }
  }

  // Convert from base 10 (decimal) to base 2
  var arr = [0];
  for (var i = 0; i < str.length; ) {
    for (var arrL = arr.length; arrL--; arr[arrL] *= 10);

    arr[0] += str.charAt(i++) << 0;  // convert to int
    for (var j = 0; j < arr.length; ++j) {
      if (arr[j] > 1) {
        if (arr[j + 1] == null) {
          arr[j + 1] = 0;
        }

        arr[j + 1] += arr[j] >> 1;
        arr[j] &= 1;
      }
    }
  }

  return arr.reverse();
}

},{"./bitNot":463}],467:[function(require,module,exports){
var memoize = require('../function').memoize;

/**
 * Calculate BigNumber e
 * @param {function} BigNumber   BigNumber constructor
 * @returns {BigNumber} Returns e
 */
exports.e = memoize(function (BigNumber) {
  return new BigNumber(1).exp();
}, hasher);

/**
 * Calculate BigNumber golden ratio, phi = (1+sqrt(5))/2
 * @param {function} BigNumber   BigNumber constructor
 * @returns {BigNumber} Returns phi
 */
exports.phi = memoize(function (BigNumber) {
  return new BigNumber(1).plus(new BigNumber(5).sqrt()).div(2);
}, hasher);

/**
 * Calculate BigNumber pi.
 * @param {function} BigNumber   BigNumber constructor
 * @returns {BigNumber} Returns pi
 */
exports.pi = memoize(function (BigNumber) {
  return pi = BigNumber.acos(-1);
}, hasher);

/**
 * Calculate BigNumber tau, tau = 2 * pi
 * @param {function} BigNumber   BigNumber constructor
 * @returns {BigNumber} Returns tau
 */
exports.tau = memoize(function (BigNumber) {
  return exports.pi(BigNumber).times(2);
}, hasher);

/**
 * Create a hash for a BigNumber constructor function. The created has is
 * the configured precision
 * @param {Array} args         Supposed to contain a single entry with
 *                             a BigNumber constructor
 * @return {number} precision
 * @private
 */
function hasher (args) {
  return args[0].precision;
}

},{"../function":480}],468:[function(require,module,exports){
/**
 * Convert a BigNumber to a formatted string representation.
 *
 * Syntax:
 *
 *    format(value)
 *    format(value, options)
 *    format(value, precision)
 *    format(value, fn)
 *
 * Where:
 *
 *    {number} value   The value to be formatted
 *    {Object} options An object with formatting options. Available options:
 *                     {string} notation
 *                         Number notation. Choose from:
 *                         'fixed'          Always use regular number notation.
 *                                          For example '123.40' and '14000000'
 *                         'exponential'    Always use exponential notation.
 *                                          For example '1.234e+2' and '1.4e+7'
 *                         'auto' (default) Regular number notation for numbers
 *                                          having an absolute value between
 *                                          `lower` and `upper` bounds, and uses
 *                                          exponential notation elsewhere.
 *                                          Lower bound is included, upper bound
 *                                          is excluded.
 *                                          For example '123.4' and '1.4e7'.
 *                     {number} precision   A number between 0 and 16 to round
 *                                          the digits of the number.
 *                                          In case of notations 'exponential' and
 *                                          'auto', `precision` defines the total
 *                                          number of significant digits returned
 *                                          and is undefined by default.
 *                                          In case of notation 'fixed',
 *                                          `precision` defines the number of
 *                                          significant digits after the decimal
 *                                          point, and is 0 by default.
 *                     {Object} exponential An object containing two parameters,
 *                                          {number} lower and {number} upper,
 *                                          used by notation 'auto' to determine
 *                                          when to return exponential notation.
 *                                          Default values are `lower=1e-3` and
 *                                          `upper=1e5`.
 *                                          Only applicable for notation `auto`.
 *    {Function} fn    A custom formatting function. Can be used to override the
 *                     built-in notations. Function `fn` is called with `value` as
 *                     parameter and must return a string. Is useful for example to
 *                     format all values inside a matrix in a particular way.
 *
 * Examples:
 *
 *    format(6.4);                                        // '6.4'
 *    format(1240000);                                    // '1.24e6'
 *    format(1/3);                                        // '0.3333333333333333'
 *    format(1/3, 3);                                     // '0.333'
 *    format(21385, 2);                                   // '21000'
 *    format(12.071, {notation: 'fixed'});                // '12'
 *    format(2.3,    {notation: 'fixed', precision: 2});  // '2.30'
 *    format(52.8,   {notation: 'exponential'});          // '5.28e+1'
 *
 * @param {BigNumber} value
 * @param {Object | Function | number} [options]
 * @return {string} str The formatted value
 */
exports.format = function (value, options) {
  if (typeof options === 'function') {
    // handle format(value, fn)
    return options(value);
  }

  // handle special cases
  if (!value.isFinite()) {
    return value.isNaN() ? 'NaN' : (value.gt(0) ? 'Infinity' : '-Infinity');
  }

  // default values for options
  var notation = 'auto';
  var precision = undefined;

  if (options !== undefined) {
    // determine notation from options
    if (options.notation) {
      notation = options.notation;
    }

    // determine precision from options
    if (typeof options === 'number') {
      precision = options;
    }
    else if (options.precision) {
      precision = options.precision;
    }
  }

  // handle the various notations
  switch (notation) {
    case 'fixed':
      return exports.toFixed(value, precision);

    case 'exponential':
      return exports.toExponential(value, precision);

    case 'auto':
      // determine lower and upper bound for exponential notation.
      // TODO: implement support for upper and lower to be BigNumbers themselves
      var lower = 1e-3;
      var upper = 1e5;
      if (options && options.exponential) {
        if (options.exponential.lower !== undefined) {
          lower = options.exponential.lower;
        }
        if (options.exponential.upper !== undefined) {
          upper = options.exponential.upper;
        }
      }

      // adjust the configuration of the BigNumber constructor (yeah, this is quite tricky...)
      var oldConfig = {
        toExpNeg: value.constructor.toExpNeg,
        toExpPos: value.constructor.toExpPos
      };

      value.constructor.config({
        toExpNeg: Math.round(Math.log(lower) / Math.LN10),
        toExpPos: Math.round(Math.log(upper) / Math.LN10)
      });

      // handle special case zero
      if (value.isZero()) return '0';

      // determine whether or not to output exponential notation
      var str;
      var abs = value.abs();
      if (abs.gte(lower) && abs.lt(upper)) {
        // normal number notation
        str = value.toSignificantDigits(precision).toFixed();
      }
      else {
        // exponential notation
        str = exports.toExponential(value, precision);
      }

      // remove trailing zeros after the decimal point
      return str.replace(/((\.\d*?)(0+))($|e)/, function () {
        var digits = arguments[2];
        var e = arguments[4];
        return (digits !== '.') ? digits + e : e;
      });

    default:
      throw new Error('Unknown notation "' + notation + '". ' +
          'Choose "auto", "exponential", or "fixed".');
  }
};

/**
 * Format a number in exponential notation. Like '1.23e+5', '2.3e+0', '3.500e-3'
 * @param {BigNumber} value
 * @param {number} [precision]  Number of digits in formatted output.
 *                              If not provided, the maximum available digits
 *                              is used.
 * @returns {string} str
 */
exports.toExponential = function (value, precision) {
  if (precision !== undefined) {
    return value.toExponential(precision - 1); // Note the offset of one
  }
  else {
    return value.toExponential();
  }
};

/**
 * Format a number with fixed notation.
 * @param {BigNumber} value
 * @param {number} [precision=0]        Optional number of decimals after the
 *                                      decimal point. Zero by default.
 */
exports.toFixed = function (value, precision) {
  return value.toFixed(precision || 0);
  // Note: the (precision || 0) is needed as the toFixed of BigNumber has an
  // undefined default precision instead of 0.
};

},{}],469:[function(require,module,exports){

/**
 * Bitwise left shift
 *
 * Special Cases:
 *  n << -n = N
 *  n <<  N = N
 *  N <<  n = N
 *  n <<  0 = n
 *  0 <<  n = 0
 *  I <<  I = N
 *  I <<  n = I
 *  n <<  I = I
 *
 * @param {BigNumber} x
 * @param {BigNumber} y
 * @return {BigNumber} Result of `x` << `y`
 *
 */
module.exports = function leftShift (x, y) {
  if ((x.isFinite() && !x.isInteger()) || (y.isFinite() && !y.isInteger())) {
    throw new Error('Integers expected in function leftShift');
  }

  var BigNumber = x.constructor;
  if (x.isNaN() || y.isNaN() || (y.isNegative() && !y.isZero())) {
    return new BigNumber(NaN);
  }
  if (x.isZero() || y.isZero()) {
    return x;
  }
  if (!x.isFinite() && !y.isFinite()) {
    return new BigNumber(NaN);
  }

  // Math.pow(2, y) is fully precise for y < 55, and fast
  if (y.lt(55)) {
    return x.times(Math.pow(2, y.toNumber()) + '');
  }
  return x.times(new BigNumber(2).pow(y));
};

},{}],470:[function(require,module,exports){
'use strict';

/**
 * Compares two BigNumbers.
 * @param {BigNumber} x       First value to compare
 * @param {BigNumber} y       Second value to compare
 * @param {number} [epsilon]  The maximum relative difference between x and y
 *                            If epsilon is undefined or null, the function will
 *                            test whether x and y are exactly equal.
 * @return {boolean} whether the two numbers are nearly equal
 */
module.exports = function nearlyEqual(x, y, epsilon) {
  // if epsilon is null or undefined, test whether x and y are exactly equal
  if (epsilon == null) {
    return x.eq(y);
  }


  // use "==" operator, handles infinities
  if (x.eq(y)) {
    return true;
  }

  // NaN
  if (x.isNaN() || y.isNaN()) {
    return false;
  }

  // at this point x and y should be finite
  if(x.isFinite() && y.isFinite()) {
    // check numbers are very close, needed when comparing numbers near zero
    var diff = x.minus(y).abs();
    if (diff.isZero()) {
      return true;
    }
    else {
      // use relative error
      var max = x.constructor.max(x.abs(), y.abs());
      return diff.lte(max.times(epsilon));
    }
  }

  // Infinite and Number or negative Infinite and positive Infinite cases
  return false;
};

},{}],471:[function(require,module,exports){
/*
 * Special Cases:
 *   n >> -n =  N
 *   n >>  N =  N
 *   N >>  n =  N
 *   I >>  I =  N
 *   n >>  0 =  n
 *   I >>  n =  I
 *  -I >>  n = -I
 *  -I >>  I = -I
 *   n >>  I =  I
 *  -n >>  I = -1
 *   0 >>  n =  0
 *
 * @param {BigNumber} value
 * @param {BigNumber} value
 * @return {BigNumber} Result of `x` >> `y`
 *
 */
module.exports = function rightArithShift (x, y) {
  if ((x.isFinite() && !x.isInteger()) || (y.isFinite() && !y.isInteger())) {
    throw new Error('Integers expected in function rightArithShift');
  }

  var BigNumber = x.constructor;
  if (x.isNaN() || y.isNaN() || (y.isNegative() && !y.isZero())) {
    return new BigNumber(NaN);
  }
  if (x.isZero() || y.isZero()) {
    return x;
  }
  if (!y.isFinite()) {
    if (x.isNegative()) {
      return new BigNumber(-1);
    }
    if (!x.isFinite()) {
      return new BigNumber(NaN);
    }
    return new BigNumber(0);
  }

  // Math.pow(2, y) is fully precise for y < 55, and fast
  if (y.lt(55)) {
    return x.div(Math.pow(2, y.toNumber()) + '').floor();
  }
  return x.div(new BigNumber(2).pow(y)).floor();
};

},{}],472:[function(require,module,exports){
'use strict';

/**
 * Test whether value is a boolean
 * @param {*} value
 * @return {boolean} isBoolean
 */
exports.isBoolean = function(value) {
  return typeof value == 'boolean';
};

},{}],473:[function(require,module,exports){
'use strict';

var isCollection = require('./isCollection');

/**
 * Test whether an array contains collections
 * @param {Array} array
 * @returns {boolean} Returns true when the array contains one or multiple
 *                    collections (Arrays or Matrices). Returns false otherwise.
 */
module.exports = function containsCollections (array) {
  for (var i = 0; i < array.length; i++) {
    if (isCollection(array[i])) {
      return true;
    }
  }
  return false;
};

},{"./isCollection":476}],474:[function(require,module,exports){
'use strict';

/**
 * Recursively loop over all elements in a given multi dimensional array
 * and invoke the callback on each of the elements.
 * @param {Array | Matrix} array
 * @param {Function} callback     The callback method is invoked with one
 *                                parameter: the current element in the array
 */
module.exports = function deepForEach (array, callback) {
  if (array && array.isMatrix === true) {
    array = array.valueOf();
  }

  for (var i = 0, ii = array.length; i < ii; i++) {
    var value = array[i];

    if (Array.isArray(value)) {
      deepForEach(value, callback);
    }
    else {
      callback(value);
    }
  }
};

},{}],475:[function(require,module,exports){
'use strict';

/**
 * Execute the callback function element wise for each element in array and any
 * nested array
 * Returns an array with the results
 * @param {Array | Matrix} array
 * @param {Function} callback   The callback is called with two parameters:
 *                              value1 and value2, which contain the current
 *                              element of both arrays.
 * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.
 *
 * @return {Array | Matrix} res
 */
module.exports = function deepMap(array, callback, skipZeros) {
  if (array && (typeof array.map === 'function')) {
    // TODO: replace array.map with a for loop to improve performance
    return array.map(function (x) {
      return deepMap(x, callback, skipZeros);
    });
  }
  else {
    return callback(array);
  }
};

},{}],476:[function(require,module,exports){
'use strict';

/**
 * Test whether a value is a collection: an Array or Matrix
 * @param {*} x
 * @returns {boolean} isCollection
 */
module.exports = function isCollection (x) {
  return (Array.isArray(x) || (x && x.isMatrix === true));
};

},{}],477:[function(require,module,exports){
'use strict';

var arraySize = require('../array').size;
var IndexError = require('../../error/IndexError');

/**
 * Reduce a given matrix or array to a new matrix or
 * array with one less dimension, applying the given
 * callback in the selected dimension.
 * @param {Array | Matrix} mat
 * @param {number} dim
 * @param {Function} callback
 * @return {Array | Matrix} res
 */
module.exports = function(mat, dim, callback) {
  var size = Array.isArray(mat) ? arraySize(mat) : mat.size();
  if (dim < 0 || (dim >= size.length)) {
    // TODO: would be more clear when throwing a DimensionError here
    throw new IndexError(dim, size.length);
  }

  if (mat && mat.isMatrix === true) {
    return mat.create(_reduce(mat.valueOf(), dim, callback));
  }else {
    return _reduce(mat, dim, callback);
  }
};

/**
 * Recursively reduce a matrix
 * @param {Array} mat
 * @param {number} dim
 * @param {Function} callback
 * @returns {Array} ret
 * @private
 */
function _reduce(mat, dim, callback){
  var i, ret, val, tran;

  if(dim<=0){
    if( !Array.isArray(mat[0]) ){
      val = mat[0];
      for(i=1; i<mat.length; i++){
        val = callback(val, mat[i]);
      }
      return val;
    }else{
      tran = _switch(mat);
      ret = [];
      for(i=0; i<tran.length; i++){
        ret[i] = _reduce(tran[i], dim-1, callback);
      }
      return ret;
    }
  }else{
    ret = [];
    for(i=0; i<mat.length; i++){
      ret[i] = _reduce(mat[i], dim-1, callback);
    }
    return ret;
  }
}

/**
 * Transpose a matrix
 * @param {Array} mat
 * @returns {Array} ret
 * @private
 */
function _switch(mat){
  var I = mat.length;
  var J = mat[0].length;
  var i, j;
  var ret = [];
  for( j=0; j<J; j++) {
    var tmp = [];
    for( i=0; i<I; i++) {
      tmp.push(mat[i][j]);
    }
    ret.push(tmp);
  }
  return ret;
}

},{"../../error/IndexError":12,"../array":461}],478:[function(require,module,exports){
'use strict';

module.exports = function scatter(a, j, w, x, u, mark, c, f, inverse, update, value) {
  // a arrays
  var avalues = a._values;
  var aindex = a._index;
  var aptr = a._ptr;
  // c arrays
  var cindex = c._index;

  // vars
  var k, k0, k1, i;

  // check we need to process values (pattern matrix)
  if (x) {
    // values in j
    for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
      // row
      i = aindex[k];
      // check value exists in current j
      if (w[i] !== mark) {
        // i is new entry in j
        w[i] = mark;
        // add i to pattern of C
        cindex.push(i);
        // x(i) = A, check we need to call function this time
        if (update) {
          // copy value to workspace calling callback function
          x[i] = inverse ? f(avalues[k], value) : f(value, avalues[k]);
          // function was called on current row
          u[i] = mark;
        }
        else {
          // copy value to workspace
          x[i] = avalues[k];
        }
      }
      else {
        // i exists in C already
        x[i] = inverse ? f(avalues[k], x[i]) : f(x[i], avalues[k]);
        // function was called on current row
        u[i] = mark;
      }
    }
  }
  else {
    // values in j
    for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
      // row
      i = aindex[k];
      // check value exists in current j
      if (w[i] !== mark) {
        // i is new entry in j
        w[i] = mark;
        // add i to pattern of C
        cindex.push(i);
      }
      else {
        // indicate function was called on current row
        u[i] = mark;
      }
    }
  }
};

},{}],479:[function(require,module,exports){
var Emitter = require('tiny-emitter');

/**
 * Extend given object with emitter functions `on`, `off`, `once`, `emit`
 * @param {Object} obj
 * @return {Object} obj
 */
exports.mixin = function (obj) {
  // create event emitter
  var emitter = new Emitter();

  // bind methods to obj (we don't want to expose the emitter.e Array...)
  obj.on   = emitter.on.bind(emitter);
  obj.off  = emitter.off.bind(emitter);
  obj.once = emitter.once.bind(emitter);
  obj.emit = emitter.emit.bind(emitter);

  return obj;
};

},{"tiny-emitter":491}],480:[function(require,module,exports){
// function utils

/*
 * Memoize a given function by caching the computed result.
 * The cache of a memoized function can be cleared by deleting the `cache`
 * property of the function.
 *
 * @param {function} fn                     The function to be memoized.
 *                                          Must be a pure function.
 * @param {function(args: Array)} [hasher]  A custom hash builder.
 *                                          Is JSON.stringify by default.
 * @return {function}                       Returns the memoized function
 */
exports.memoize = function(fn, hasher) {
  return function memoize() {
    if (typeof memoize.cache !== 'object') {
      memoize.cache = {};
    }

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args[i] = arguments[i];
    }

    var hash = hasher ? hasher(args) : JSON.stringify(args);
    if (!(hash in memoize.cache)) {
      return memoize.cache[hash] = fn.apply(fn, args);
    }
    return memoize.cache[hash];
  };
};

},{}],481:[function(require,module,exports){
'use strict';

exports.array = require('./array');
exports['boolean'] = require('./boolean');
exports['function'] = require('./function');
exports.number = require('./number');
exports.object = require('./object');
exports.string = require('./string');
exports.types = require('./types');
exports.emitter = require('./emitter');

},{"./array":461,"./boolean":472,"./emitter":479,"./function":480,"./number":483,"./object":484,"./string":485,"./types":486}],482:[function(require,module,exports){
'use strict';

exports.symbols = {
  // GREEK LETTERS
  Alpha: 'A',     alpha: '\\alpha',
  Beta: 'B',      beta: '\\beta',
  Gamma: '\\Gamma',    gamma: '\\gamma',
  Delta: '\\Delta',    delta: '\\delta',
  Epsilon: 'E',   epsilon: '\\epsilon',  varepsilon: '\\varepsilon',
  Zeta: 'Z',      zeta: '\\zeta',
  Eta: 'H',       eta: '\\eta',
  Theta: '\\Theta',    theta: '\\theta',    vartheta: '\\vartheta',
  Iota: 'I',      iota: '\\iota',
  Kappa: 'K',     kappa: '\\kappa',    varkappa: '\\varkappa',
  Lambda: '\\Lambda',   lambda: '\\lambda',
  Mu: 'M',        mu: '\\mu',
  Nu: 'N',        nu: '\\nu',
  Xi: '\\Xi',       xi: '\\xi',
  Omicron: 'O',   omicron: 'o',
  Pi: '\\Pi',       pi: '\\pi',       varpi: '\\varpi',
  Rho: 'P',       rho: '\\rho',      varrho: '\\varrho',
  Sigma: '\\Sigma',    sigma: '\\sigma',    varsigma: '\\varsigma',
  Tau: 'T',       tau: '\\tau',
  Upsilon: '\\Upsilon',  upsilon: '\\upsilon',
  Phi: '\\Phi',      phi: '\\phi',      varphi: '\\varphi',
  Chi: 'X',       chi: '\\chi',
  Psi: '\\Psi',      psi: '\\psi',
  Omega: '\\Omega',    omega: '\\omega',
  //logic
  'true': '\\mathrm{True}',
  'false': '\\mathrm{False}',
  //other
  i: 'i', //TODO use \i ??
  inf: '\\infty',
  Inf: '\\infty',
  infinity: '\\infty',
  Infinity: '\\infty',
  oo: '\\infty',
  lim: '\\lim',
  'undefined': '\\mathbf{?}'
};

exports.operators = {
  'transpose': '^\\top',
  'factorial': '!',
  'pow': '^',
  'dotPow': '.^\\wedge', //TODO find ideal solution
  'unaryPlus': '+',
  'unaryMinus': '-',
  'bitNot': '~', //TODO find ideal solution
  'not': '\\neg',
  'multiply': '\\cdot',
  'divide': '\\frac', //TODO how to handle that properly?
  'dotMultiply': '.\\cdot', //TODO find ideal solution
  'dotDivide': '.:', //TODO find ideal solution
  'mod': '\\mod',
  'add': '+',
  'subtract': '-',
  'to': '\\rightarrow',
  'leftShift': '<<',
  'rightArithShift': '>>',
  'rightLogShift': '>>>',
  'equal': '=',
  'unequal': '\\neq',
  'smaller': '<',
  'larger': '>',
  'smallerEq': '\\leq',
  'largerEq': '\\geq',
  'bitAnd': '\\&',
  'bitXor': '\\underline{|}',
  'bitOr': '|',
  'and': '\\wedge',
  'xor': '\\veebar',
  'or': '\\vee'
};

exports.defaultTemplate = '\\mathrm{${name}}\\left(${args}\\right)';

var units = {
  deg: '^\\circ'
};

//@param {string} name
//@param {boolean} isUnit
exports.toSymbol = function (name, isUnit) {
  isUnit = typeof isUnit === 'undefined' ? false : isUnit;
  if (isUnit) {
    if (units.hasOwnProperty(name)) {
      return units[name];
    }
    return '\\mathrm{' + name + '}';
  }

  if (exports.symbols.hasOwnProperty(name)) {
    return exports.symbols[name];
  }
  else if (name.indexOf('_') !== -1) {
    //symbol with index (eg. alpha_1)
    var index = name.indexOf('_');
    return exports.toSymbol(name.substring(0, index)) + '_{'
      + exports.toSymbol(name.substring(index + 1)) + '}';
  }
  return name;
};

},{}],483:[function(require,module,exports){
'use strict';

var NumberFormatter = require('./NumberFormatter');

/**
 * Test whether value is a number
 * @param {*} value
 * @return {boolean} isNumber
 */
exports.isNumber = function(value) {
  return typeof value === 'number';
};

/**
 * Check if a number is integer
 * @param {number | boolean} value
 * @return {boolean} isInteger
 */
exports.isInteger = function(value) {
  return isFinite(value)
      ? (value == Math.round(value))
      : false;
  // Note: we use ==, not ===, as we can have Booleans as well
};

/**
 * Calculate the sign of a number
 * @param {number} x
 * @returns {*}
 */
exports.sign = function(x) {
  if (x > 0) {
    return 1;
  }
  else if (x < 0) {
    return -1;
  }
  else {
    return 0;
  }
};

/**
 * Convert a number to a formatted string representation.
 *
 * Syntax:
 *
 *    format(value)
 *    format(value, options)
 *    format(value, precision)
 *    format(value, fn)
 *
 * Where:
 *
 *    {number} value   The value to be formatted
 *    {Object} options An object with formatting options. Available options:
 *                     {string} notation
 *                         Number notation. Choose from:
 *                         'fixed'          Always use regular number notation.
 *                                          For example '123.40' and '14000000'
 *                         'exponential'    Always use exponential notation.
 *                                          For example '1.234e+2' and '1.4e+7'
 *                         'engineering'    Always use engineering notation.
 *                                          For example '123.4e+0 and 14.0e+6'
 *                         'auto' (default) Regular number notation for numbers
 *                                          having an absolute value between
 *                                          `lower` and `upper` bounds, and uses
 *                                          exponential notation elsewhere.
 *                                          Lower bound is included, upper bound
 *                                          is excluded.
 *                                          For example '123.4' and '1.4e7'.
 *                     {number} precision   A number between 0 and 16 to round
 *                                          the digits of the number.
 *                                          In case of notations 'exponential' and
 *                                          'auto', `precision` defines the total
 *                                          number of significant digits returned
 *                                          and is undefined by default.
 *                                          In case of notation 'fixed',
 *                                          `precision` defines the number of
 *                                          significant digits after the decimal
 *                                          point, and is 0 by default.
 *                     {Object} exponential An object containing two parameters,
 *                                          {number} lower and {number} upper,
 *                                          used by notation 'auto' to determine
 *                                          when to return exponential notation.
 *                                          Default values are `lower=1e-3` and
 *                                          `upper=1e5`.
 *                                          Only applicable for notation `auto`.
 *    {Function} fn    A custom formatting function. Can be used to override the
 *                     built-in notations. Function `fn` is called with `value` as
 *                     parameter and must return a string. Is useful for example to
 *                     format all values inside a matrix in a particular way.
 *
 * Examples:
 *
 *    format(6.4);                                        // '6.4'
 *    format(1240000);                                    // '1.24e6'
 *    format(1/3);                                        // '0.3333333333333333'
 *    format(1/3, 3);                                     // '0.333'
 *    format(21385, 2);                                   // '21000'
 *    format(12.071, {notation: 'fixed'});                // '12'
 *    format(2.3,    {notation: 'fixed', precision: 2});  // '2.30'
 *    format(52.8,   {notation: 'exponential'});          // '5.28e+1'
 *    format(12345678, {notation: 'engineering'});        // '12.345678e+6'
 *
 * @param {number} value
 * @param {Object | Function | number} [options]
 * @return {string} str The formatted value
 */
exports.format = function(value, options) {
  if (typeof options === 'function') {
    // handle format(value, fn)
    return options(value);
  }

  // handle special cases
  if (value === Infinity) {
    return 'Infinity';
  }
  else if (value === -Infinity) {
    return '-Infinity';
  }
  else if (isNaN(value)) {
    return 'NaN';
  }

  // default values for options
  var notation = 'auto';
  var precision = undefined;

  if (options) {
    // determine notation from options
    if (options.notation) {
      notation = options.notation;
    }

    // determine precision from options
    if (exports.isNumber(options)) {
      precision = options;
    }
    else if (options.precision) {
      precision = options.precision;
    }
  }

  // handle the various notations
  switch (notation) {
    case 'fixed':
      return exports.toFixed(value, precision);

    case 'exponential':
      return exports.toExponential(value, precision);

    case 'engineering':
      return exports.toEngineering(value, precision);

    case 'auto':
      return exports
          .toPrecision(value, precision, options && options.exponential)

          // remove trailing zeros after the decimal point
          .replace(/((\.\d*?)(0+))($|e)/, function () {
            var digits = arguments[2];
            var e = arguments[4];
            return (digits !== '.') ? digits + e : e;
          });

    default:
      throw new Error('Unknown notation "' + notation + '". ' +
          'Choose "auto", "exponential", or "fixed".');
  }
};

/**
 * Format a number in exponential notation. Like '1.23e+5', '2.3e+0', '3.500e-3'
 * @param {number} value
 * @param {number} [precision]  Number of digits in formatted output.
 *                              If not provided, the maximum available digits
 *                              is used.
 * @returns {string} str
 */
exports.toExponential = function(value, precision) {
  return new NumberFormatter(value).toExponential(precision);
};

/**
 * Format a number in engineering notation. Like '1.23e+6', '2.3e+0', '3.500e-3'
 * @param {number} value
 * @param {number} [precision]  Number of digits in formatted output.
 *                              If not provided, the maximum available digits
 *                              is used.
 * @returns {string} str
 */
exports.toEngineering = function(value, precision) {
  return new NumberFormatter(value).toEngineering(precision);
};

/**
 * Format a number with fixed notation.
 * @param {number} value
 * @param {number} [precision=0]        Optional number of decimals after the
 *                                      decimal point. Zero by default.
 */
exports.toFixed = function(value, precision) {
  return new NumberFormatter(value).toFixed(precision);
};

/**
 * Format a number with a certain precision
 * @param {number} value
 * @param {number} [precision=undefined] Optional number of digits.
 * @param {{lower: number, upper: number}} [options]  By default:
 *                                                    lower = 1e-3 (excl)
 *                                                    upper = 1e+5 (incl)
 * @return {string}
 */
exports.toPrecision = function(value, precision, options) {
  return new NumberFormatter(value).toPrecision(precision, options);
};

/**
 * Count the number of significant digits of a number.
 *
 * For example:
 *   2.34 returns 3
 *   0.0034 returns 2
 *   120.5e+30 returns 4
 *
 * @param {number} value
 * @return {number} digits   Number of significant digits
 */
exports.digits = function(value) {
  return value
      .toExponential()
      .replace(/e.*$/, '')          // remove exponential notation
      .replace( /^0\.?0*|\./, '')   // remove decimal point and leading zeros
      .length
};

/**
 * Minimum number added to one that makes the result different than one
 */
exports.DBL_EPSILON = Number.EPSILON || 2.2204460492503130808472633361816E-16;

/**
 * Compares two floating point numbers.
 * @param {number} x          First value to compare
 * @param {number} y          Second value to compare
 * @param {number} [epsilon]  The maximum relative difference between x and y
 *                            If epsilon is undefined or null, the function will
 *                            test whether x and y are exactly equal.
 * @return {boolean} whether the two numbers are nearly equal
*/
exports.nearlyEqual = function(x, y, epsilon) {
  // if epsilon is null or undefined, test whether x and y are exactly equal
  if (epsilon == null) {
    return x == y;
  }

  // use "==" operator, handles infinities
  if (x == y) {
    return true;
  }

  // NaN
  if (isNaN(x) || isNaN(y)) {
    return false;
  }

  // at this point x and y should be finite
  if(isFinite(x) && isFinite(y)) {
    // check numbers are very close, needed when comparing numbers near zero
    var diff = Math.abs(x - y);
    if (diff < exports.DBL_EPSILON) {
      return true;
    }
    else {
      // use relative error
      return diff <= Math.max(Math.abs(x), Math.abs(y)) * epsilon;
    }
  }

  // Infinite and Number or negative Infinite and positive Infinite cases
  return false;
};

},{"./NumberFormatter":460}],484:[function(require,module,exports){
'use strict';

/**
 * Clone an object
 *
 *     clone(x)
 *
 * Can clone any primitive type, array, and object.
 * If x has a function clone, this function will be invoked to clone the object.
 *
 * @param {*} x
 * @return {*} clone
 */
exports.clone = function clone(x) {
  var type = typeof x;

  // immutable primitive types
  if (type === 'number' || type === 'string' || type === 'boolean' ||
      x === null || x === undefined) {
    return x;
  }

  // use clone function of the object when available
  if (typeof x.clone === 'function') {
    return x.clone();
  }

  // array
  if (Array.isArray(x)) {
    return x.map(function (value) {
      return clone(value);
    });
  }

  if (x instanceof Number)    return new Number(x.valueOf());
  if (x instanceof String)    return new String(x.valueOf());
  if (x instanceof Boolean)   return new Boolean(x.valueOf());
  if (x instanceof Date)      return new Date(x.valueOf());
  if (x && x.isBigNumber === true) return x; // bignumbers are immutable
  if (x instanceof RegExp)  throw new TypeError('Cannot clone ' + x);  // TODO: clone a RegExp

  // object
  var m = {};
  for (var key in x) {
    if (x.hasOwnProperty(key)) {
      m[key] = clone(x[key]);
    }
  }
  return m;
};

/**
 * Extend object a with the properties of object b
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 */
exports.extend = function(a, b) {
  for (var prop in b) {
    if (b.hasOwnProperty(prop)) {
      a[prop] = b[prop];
    }
  }
  return a;
};

/**
 * Deep extend an object a with the properties of object b
 * @param {Object} a
 * @param {Object} b
 * @returns {Object}
 */
exports.deepExtend = function deepExtend (a, b) {
  // TODO: add support for Arrays to deepExtend
  if (Array.isArray(b)) {
    throw new TypeError('Arrays are not supported by deepExtend');
  }

  for (var prop in b) {
    if (b.hasOwnProperty(prop)) {
      if (b[prop] && b[prop].constructor === Object) {
        if (a[prop] === undefined) {
          a[prop] = {};
        }
        if (a[prop].constructor === Object) {
          deepExtend(a[prop], b[prop]);
        }
        else {
          a[prop] = b[prop];
        }
      } else if (Array.isArray(b[prop])) {
        throw new TypeError('Arrays are not supported by deepExtend');
      } else {
        a[prop] = b[prop];
      }
    }
  }
  return a;
};

/**
 * Deep test equality of all fields in two pairs of arrays or objects.
 * @param {Array | Object} a
 * @param {Array | Object} b
 * @returns {boolean}
 */
exports.deepEqual = function deepEqual (a, b) {
  var prop, i, len;
  if (Array.isArray(a)) {
    if (!Array.isArray(b)) {
      return false;
    }

    if (a.length != b.length) {
      return false;
    }

    for (i = 0, len = a.length; i < len; i++) {
      if (!exports.deepEqual(a[i], b[i])) {
        return false;
      }
    }
    return true;
  }
  else if (a instanceof Object) {
    if (Array.isArray(b) || !(b instanceof Object)) {
      return false;
    }

    for (prop in a) {
      //noinspection JSUnfilteredForInLoop
      if (!exports.deepEqual(a[prop], b[prop])) {
        return false;
      }
    }
    for (prop in b) {
      //noinspection JSUnfilteredForInLoop
      if (!exports.deepEqual(a[prop], b[prop])) {
        return false;
      }
    }
    return true;
  }
  else {
    return (typeof a === typeof b) && (a == b);
  }
};

/**
 * Test whether the current JavaScript engine supports Object.defineProperty
 * @returns {boolean} returns true if supported
 */
exports.canDefineProperty = function () {
  // test needed for broken IE8 implementation
  try {
    if (Object.defineProperty) {
      Object.defineProperty({}, 'x', { get: function () {} });
      return true;
    }
  } catch (e) {}

  return false;
};

/**
 * Attach a lazy loading property to a constant.
 * The given function `fn` is called once when the property is first requested.
 * On older browsers (<IE8), the function will fall back to direct evaluation
 * of the properties value.
 * @param {Object} object   Object where to add the property
 * @param {string} prop     Property name
 * @param {Function} fn     Function returning the property value. Called
 *                          without arguments.
 */
exports.lazy = function (object, prop, fn) {
  if (exports.canDefineProperty()) {
    var _uninitialized = true;
    var _value;
    Object.defineProperty(object, prop, {
      get: function () {
        if (_uninitialized) {
          _value = fn();
          _uninitialized = false;
        }
        return _value;
      },

      set: function (value) {
        _value = value;
        _uninitialized = false;
      },

      configurable: true,
      enumerable: true
    });
  }
  else {
    // fall back to immediate evaluation
    object[prop] = fn();
  }
};

/**
 * Traverse a path into an object.
 * When a namespace is missing, it will be created
 * @param {Object} object
 * @param {string} path   A dot separated string like 'name.space'
 * @return {Object} Returns the object at the end of the path
 */
exports.traverse = function(object, path) {
  var obj = object;

  if (path) {
    var names = path.split('.');
    for (var i = 0; i < names.length; i++) {
      var name = names[i];
      if (!(name in obj)) {
        obj[name] = {};
      }
      obj = obj[name];
    }
  }

  return obj;
};

/**
 * Test whether an object is a factory. a factory has fields:
 *
 * - factory: function (type: Object, config: Object, load: function, typed: function [, math: Object])   (required)
 * - name: string (optional)
 * - path: string    A dot separated path (optional)
 * - math: boolean   If true (false by default), the math namespace is passed
 *                   as fifth argument of the factory function
 *
 * @param {*} object
 * @returns {boolean}
 */
exports.isFactory = function (object) {
  return object && typeof object.factory === 'function';
};

},{}],485:[function(require,module,exports){
'use strict';

var formatNumber = require('./number').format;
var formatBigNumber = require('./bignumber/formatter').format;

/**
 * Test whether value is a string
 * @param {*} value
 * @return {boolean} isString
 */
exports.isString = function(value) {
  return typeof value === 'string';
};

/**
 * Check if a text ends with a certain string.
 * @param {string} text
 * @param {string} search
 */
exports.endsWith = function(text, search) {
  var start = text.length - search.length;
  var end = text.length;
  return (text.substring(start, end) === search);
};

/**
 * Format a value of any type into a string.
 *
 * Usage:
 *     math.format(value)
 *     math.format(value, precision)
 *
 * When value is a function:
 *
 * - When the function has a property `syntax`, it returns this
 *   syntax description.
 * - In other cases, a string `'function'` is returned.
 *
 * When `value` is an Object:
 *
 * - When the object contains a property `format` being a function, this
 *   function is invoked as `value.format(options)` and the result is returned.
 * - When the object has its own `toString` method, this method is invoked
 *   and the result is returned.
 * - In other cases the function will loop over all object properties and
 *   return JSON object notation like '{"a": 2, "b": 3}'.
 *
 * Example usage:
 *     math.format(2/7);                // '0.2857142857142857'
 *     math.format(math.pi, 3);         // '3.14'
 *     math.format(new Complex(2, 3));  // '2 + 3i'
 *     math.format('hello');            // '"hello"'
 *
 * @param {*} value             Value to be stringified
 * @param {Object | number | Function} [options]  Formatting options. See
 *                                                lib/utils/number:format for a
 *                                                description of the available
 *                                                options.
 * @return {string} str
 */
exports.format = function(value, options) {
  if (typeof value === 'number') {
    return formatNumber(value, options);
  }

  if (value && value.isBigNumber === true) {
    return formatBigNumber(value, options);
  }

  if (value && value.isFraction === true) {
    if (!options || options.fraction !== 'decimal') {
      // output as ratio, like '1/3'
      return (value.s * value.n) + '/' + value.d;
    }
    else {
      // output as decimal, like '0.(3)'
      return value.toString();
    }
  }

  if (Array.isArray(value)) {
    return formatArray(value, options);
  }

  if (exports.isString(value)) {
    return '"' + value + '"';
  }

  if (typeof value === 'function') {
    return value.syntax ? String(value.syntax) : 'function';
  }

  if (value && typeof value === 'object') {
    if (typeof value.format === 'function') {
      return value.format(options);
    }
    else if (value && value.toString() !== {}.toString()) {
      // this object has a non-native toString method, use that one
      return value.toString();
    }
    else {
      var entries = [];

      for (var key in value) {
        if (value.hasOwnProperty(key)) {
          entries.push('"' + key + '": ' + exports.format(value[key], options));
        }
      }

      return '{' + entries.join(', ') + '}';
    }
  }

  return String(value);
};

/**
 * Recursively format an n-dimensional matrix
 * Example output: "[[1, 2], [3, 4]]"
 * @param {Array} array
 * @param {Object | number | Function} [options]  Formatting options. See
 *                                                lib/utils/number:format for a
 *                                                description of the available
 *                                                options.
 * @returns {string} str
 */
function formatArray (array, options) {
  if (Array.isArray(array)) {
    var str = '[';
    var len = array.length;
    for (var i = 0; i < len; i++) {
      if (i != 0) {
        str += ', ';
      }
      str += formatArray(array[i], options);
    }
    str += ']';
    return str;
  }
  else {
    return exports.format(array, options);
  }
}

},{"./bignumber/formatter":468,"./number":483}],486:[function(require,module,exports){
'use strict';

/**
 * Determine the type of a variable
 *
 *     type(x)
 *
 * The following types are recognized:
 *
 *     'undefined'
 *     'null'
 *     'boolean'
 *     'number'
 *     'string'
 *     'Array'
 *     'Function'
 *     'Date'
 *     'RegExp'
 *     'Object'
 *
 * @param {*} x
 * @return {string} Returns the name of the type. Primitive types are lower case,
 *                  non-primitive types are upper-camel-case.
 *                  For example 'number', 'string', 'Array', 'Date'.
 */
exports.type = function(x) {
  var type = typeof x;

  if (type === 'object') {
    if (x === null)           return 'null';
    if (x instanceof Boolean) return 'boolean';
    if (x instanceof Number)  return 'number';
    if (x instanceof String)  return 'string';
    if (Array.isArray(x))     return 'Array';
    if (x instanceof Date)    return 'Date';
    if (x instanceof RegExp)  return 'RegExp';

    return 'Object';
  }

  if (type === 'function')    return 'Function';

  return type;
};

/**
 * Test whether a value is a scalar
 * @param x
 * @return {boolean} Returns true when x is a scalar, returns false when
 *                   x is a Matrix or Array.
 */
exports.isScalar = function (x) {
  return !((x && x.isMatrix) || Array.isArray(x));
};

},{}],487:[function(require,module,exports){
module.exports = '3.1.3';
// Note: This file is automatically generated when building math.js.
// Changes made in this file will be overwritten.

},{}],488:[function(require,module,exports){
/**
 * @license Complex.js v2.0.1 11/02/2016
 *
 * Copyright (c) 2016, Robert Eisele (robert@xarg.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/

/**
 *
 * This class allows the manipilation of complex numbers.
 * You can pass a complex number in different formats. Either as object, double, string or two integer parameters.
 *
 * Object form
 * { re: <real>, im: <imaginary> }
 * { arg: <angle>, abs: <radius> }
 * { phi: <angle>, r: <radius> }
 *
 * Double form
 * 99.3 - Single double value
 *
 * String form
 * "23.1337" - Simple real number
 * "15+3i" - a simple complex number
 * "3-i" - a simple complex number
 *
 * Example:
 *
 * var c = new Complex("99.3+8i");
 * c.mul({r: 3, i: 9}).div(4.9).sub(3, 2);
 *
 */

(function(root) {

  "use strict";

  var P = {'re': 0, 'im': 0};

  Math.cosh = Math.cosh || function(x) {
    return (Math.exp(x) + Math.exp(-x)) * 0.5;
  };

  Math.sinh = Math.sinh || function(x) {
    return (Math.exp(x) - Math.exp(-x)) * 0.5;
  };

  var parser_exit = function() {
    throw SyntaxError("Invalid Param");
  };

  /**
   * Calculates log(sqrt(a^2+b^2)) in a way to avoid overflows
   *
   * @param {number} a
   * @param {number} b
   * @returns {number}
   */
  function logHypot(a, b) {

    var _a = Math.abs(a);
    var _b = Math.abs(b);

    if (a === 0) {
      return Math.log(_b);
    }

    if (b === 0) {
      return Math.log(_a);
    }

    if (_a < 3000 && _b < 3000) {
      return Math.log(a * a + b * b) * 0.5;
    }

    /* I got 4 ideas to compute this property without overflow:
     *
     * Testing 1000000 times with random samples for a,b ∈ [1, 1000000000] against a big decimal library to get an error estimate
     *
     * 1. Only eliminate the square root: (OVERALL ERROR: 3.9122483030951116e-11)

     Math.log(a * a + b * b) / 2

     *
     *
     * 2. Try to use the non-overflowing pythagoras: (OVERALL ERROR: 8.889760039210159e-10)

     var fn = function(a, b) {
     a = Math.abs(a);
     b = Math.abs(b);
     var t = Math.min(a, b);
     a = Math.max(a, b);
     t = t / a;

     return Math.log(a) + Math.log(1 + t * t) / 2;
     };

     * 3. Abuse the identity cos(atan(y/x) = x / sqrt(x^2+y^2): (OVERALL ERROR: 3.4780178737037204e-10)

     Math.log(a / Math.cos(Math.atan2(b, a)))

     * 4. Use 3. and apply log rules: (OVERALL ERROR: 1.2014087502620896e-9)

     Math.log(a) - Math.log(Math.cos(Math.atan2(b, a)))

     */

    return Math.log(a / Math.cos(Math.atan2(b, a)));
  }

  var parse = function(a, b) {

    if (a === undefined || a === null) {
      P["re"] =
      P["im"] = 0;
    } else if (b !== undefined) {
      P["re"] = a;
      P["im"] = b;
    } else switch (typeof a) {

      case "object":

        if ("im" in a && "re" in a) {
          P["re"] = a["re"];
          P["im"] = a["im"];
        } else if ("abs" in a && "arg" in a) {
          P["re"] = a["abs"] * Math.cos(a["arg"]);
          P["im"] = a["abs"] * Math.sin(a["arg"]);
        } else if ("r" in a && "phi" in a) {
          P["re"] = a["r"] * Math.cos(a["phi"]);
          P["im"] = a["r"] * Math.sin(a["phi"]);
        } else {
          parser_exit();
        }
        break;

      case "string":

        P["im"] = /* void */
        P["re"] = 0;

        var tokens = a.match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g);
        var plus = 1;
        var minus = 0;

        if (tokens === null) {
          parser_exit();
        }

        for (var i = 0; i < tokens.length; i++) {

          var c = tokens[i];

          if (c === ' ' || c === '\t' || c === '\n') {
            /* void */
          } else if (c === '+') {
            plus++;
          } else if (c === '-') {
            minus++;
          } else if (c === 'i' || c === 'I') {

            if (plus + minus === 0) {
              parser_exit();
            }

            if (tokens[i + 1] !== ' ' && !isNaN(tokens[i + 1])) {
              P["im"]+= parseFloat((minus % 2 ? "-" : "") + tokens[i + 1]);
              i++;
            } else {
              P["im"]+= parseFloat((minus % 2 ? "-" : "") + "1");
            }
            plus = minus = 0;

          } else {

            if (plus + minus === 0 || isNaN(c)) {
              parser_exit();
            }

            if (tokens[i + 1] === 'i' || tokens[i + 1] === 'I') {
              P["im"]+= parseFloat((minus % 2 ? "-" : "") + c);
              i++;
            } else {
              P["re"]+= parseFloat((minus % 2 ? "-" : "") + c);
            }
            plus = minus = 0;
          }
        }

        // Still something on the stack
        if (plus + minus > 0) {
          parser_exit();
        }
        break;

      case "number":
        P["im"] = 0;
        P["re"] = a;
        break;

      default:
        parser_exit();
    }

    if (isNaN(P["re"]) || isNaN(P["im"])) {
      // If a calculation is NaN, we treat it as NaN and don't throw
      //parser_exit();
    }
  };

  /**
   * @constructor
   * @returns {Complex}
   */
  function Complex(a, b) {

    if (!(this instanceof Complex)) {
      return new Complex(a, b);
    }

    parse(a, b); // mutates P

    this["re"] = P["re"];
    this["im"] = P["im"];
  }

  Complex.prototype = {

    "re": 0,
    "im": 0,

    /**
     * Calculates the sign of a complex number
     *
     * @returns {Complex}
     */
    "sign": function() {

      var abs = this["abs"]();

      return new Complex(
              this["re"] / abs,
              this["im"] / abs);
    },

    /**
     * Adds two complex numbers
     *
     * @returns {Complex}
     */
    "add": function(a, b) {

      parse(a, b); // mutates P

      return new Complex(
              this["re"] + P["re"],
              this["im"] + P["im"]);
    },

    /**
     * Subtracts two complex numbers
     *
     * @returns {Complex}
     */
    "sub": function(a, b) {

      parse(a, b); // mutates P

      return new Complex(
              this["re"] - P["re"],
              this["im"] - P["im"]);
    },

    /**
     * Multiplies two complex numbers
     *
     * @returns {Complex}
     */
    "mul": function(a, b) {

      parse(a, b); // mutates P

      // Besides the addition/subtraction, this helps having a solution for rational Infinity
      if (P['im'] === 0 && this['im'] === 0) {
        return new Complex(this['re'] * P['re'], 0);
      }

      return new Complex(
              this["re"] * P["re"] - this["im"] * P["im"],
              this["re"] * P["im"] + this["im"] * P["re"]);
    },

    /**
     * Divides two complex numbers
     *
     * @returns {Complex}
     */
    "div": function(a, b) {

      parse(a, b); // mutates P

      a = this["re"];
      b = this["im"];

      var c = P["re"];
      var d = P["im"];
      var t, x;

      // Divisor is zero
      if (0 === c && 0 === d) {
        return new Complex(
                (a !== 0) ? (a / 0) : 0,
                (b !== 0) ? (b / 0) : 0);
      }

      // Divisor is rational
      if (0 === d) {
        return new Complex(a / c, b / c);
      }

      if (Math.abs(c) < Math.abs(d)) {

        x = c / d;
        t = c * x + d;

        return new Complex(
                (a * x + b) / t,
                (b * x - a) / t);

      } else {

        x = d / c;
        t = d * x + c;

        return new Complex(
                (a + b * x) / t,
                (b - a * x) / t);
      }
    },

    /**
     * Calculate the power of two complex numbers
     *
     * @returns {Complex}
     */
    "pow": function(a, b) {

      parse(a, b); // mutates P

      a = this["re"];
      b = this["im"];

      if (a === 0 && b === 0) {
        return new Complex(0, 0);
      }

      var arg = Math.atan2(b, a);
      var loh = logHypot(a, b);

      if (P["im"] === 0) {

        if (b === 0 && a >= 0) {

          return new Complex(Math.pow(a, P["re"]), 0);

        } else if (a === 0) {

          switch (P["re"] % 4) {
            case 0:
              return new Complex(Math.pow(b, P["re"]), 0);
            case 1:
              return new Complex(0, Math.pow(b, P["re"]));
            case 2:
              return new Complex(-Math.pow(b, P["re"]), 0);
            case 3:
              return new Complex(0, -Math.pow(b, P["re"]));
          }
        }
      }

      /* I couldn"t find a good formula, so here is a derivation and optimization
       *
       * z_1^z_2 = (a + bi)^(c + di)
       *         = exp((c + di) * log(a + bi)
       *         = pow(a^2 + b^2, (c + di) / 2) * exp(i(c + di)atan2(b, a))
       * =>...
       * Re = (pow(a^2 + b^2, c / 2) * exp(-d * atan2(b, a))) * cos(d * log(a^2 + b^2) / 2 + c * atan2(b, a))
       * Im = (pow(a^2 + b^2, c / 2) * exp(-d * atan2(b, a))) * sin(d * log(a^2 + b^2) / 2 + c * atan2(b, a))
       *
       * =>...
       * Re = exp(c * log(sqrt(a^2 + b^2)) - d * atan2(b, a)) * cos(d * log(sqrt(a^2 + b^2)) + c * atan2(b, a))
       * Im = exp(c * log(sqrt(a^2 + b^2)) - d * atan2(b, a)) * sin(d * log(sqrt(a^2 + b^2)) + c * atan2(b, a))
       *
       * =>
       * Re = exp(c * logsq2 - d * arg(z_1)) * cos(d * logsq2 + c * arg(z_1))
       * Im = exp(c * logsq2 - d * arg(z_1)) * sin(d * logsq2 + c * arg(z_1))
       *
       */

      a = Math.exp(P["re"] * loh - P["im"] * arg);
      b = P["im"] * loh + P["re"] * arg;
      return new Complex(
              a * Math.cos(b),
              a * Math.sin(b));
    },

    /**
     * Calculate the complex square root
     *
     * @returns {Complex}
     */
    "sqrt": function() {

      var a = this["re"];
      var b = this["im"];
      var r = this["abs"]();

      var re, im;

      if (a >= 0 && b === 0) {
        return new Complex(Math.sqrt(a), 0);
      }

      if (a >= 0) {
        re = 0.5 * Math.sqrt(2.0 * (r + a));
      } else {
        re = Math.abs(b) / Math.sqrt(2 * (r - a));
      }

      if (a <= 0) {
        im = 0.5 * Math.sqrt(2.0 * (r - a));
      } else {
        im = Math.abs(b) / Math.sqrt(2 * (r + a));
      }

      return new Complex(re, b >= 0 ? im : -im);
    },

    /**
     * Calculate the complex exponent
     *
     * @returns {Complex}
     */
    "exp": function() {

      var tmp = Math.exp(this["re"]);

      if (this["im"] === 0) {
        //return new Complex(tmp, 0);
      }
      return new Complex(
              tmp * Math.cos(this["im"]),
              tmp * Math.sin(this["im"]));
    },

    /**
     * Calculate the natural log
     *
     * @returns {Complex}
     */
    "log": function() {

      var a = this["re"];
      var b = this["im"];
      
      if (b === 0 && a > 0) {
        //return new Complex(Math.log(a), 0);
      }

      return new Complex(
              logHypot(a, b),
              Math.atan2(b, a));
    },

    /**
     * Calculate the magniture of the complex number
     *
     * @returns {number}
     */
    "abs": function() {

      var a = Math.abs(this["re"]);
      var b = Math.abs(this["im"]);

      if (a < 3000 && b < 3000) {
        return Math.sqrt(a * a + b * b);
      }

      if (a < b) {
        a = b;
        b = this["re"] / this["im"];
      } else {
        b = this["im"] / this["re"];
      }
      return a * Math.sqrt(1 + b * b);
    },

    /**
     * Calculate the angle of the complex number
     *
     * @returns {number}
     */
    "arg": function() {

      return Math.atan2(this["im"], this["re"]);
    },

    /**
     * Calculate the sine of the complex number
     *
     * @returns {Complex}
     */
    "sin": function() {

      var a = this["re"];
      var b = this["im"];

      return new Complex(
              Math.sin(a) * Math.cosh(b),
              Math.cos(a) * Math.sinh(b));
    },

    /**
     * Calculate the cosine
     *
     * @returns {Complex}
     */
    "cos": function() {

      var a = this["re"];
      var b = this["im"];

      return new Complex(
              Math.cos(a) * Math.cosh(b),
             -Math.sin(a) * Math.sinh(b));
    },

    /**
     * Calculate the tangent
     *
     * @returns {Complex}
     */
    "tan": function() {

      var a = 2 * this["re"];
      var b = 2 * this["im"];
      var d = Math.cos(a) + Math.cosh(b);

      return new Complex(
              Math.sin(a) / d,
              Math.sinh(b) / d);
    },

    /**
     * Calculate the cotangent
     *
     * @returns {Complex}
     */
    "cot": function() {

      var a = 2 * this["re"];
      var b = 2 * this["im"];
      var d = Math.cos(a) - Math.cosh(b);

      return new Complex(
             -Math.sin(a) / d,
              Math.sinh(b) / d);
    },

    /**
     * Calculate the secant
     *
     * @returns {Complex}
     */
    "sec": function() {

      var a = this["re"];
      var b = this["im"];
      var d = 0.5 * Math.cosh(2 * b) + 0.5 * Math.cos(2 * a);

      return new Complex(
              Math.cos(a) * Math.cosh(b) / d,
              Math.sin(a) * Math.sinh(b) / d);
    },

    /**
     * Calculate the cosecans
     *
     * @returns {Complex}
     */
    "csc": function() {

      var a = this["re"];
      var b = this["im"];
      var d = 0.5 * Math.cosh(2 * b) - 0.5 * Math.cos(2 * a);

      return new Complex(
              Math.sin(a) * Math.cosh(b) / d,
             -Math.cos(a) * Math.sinh(b) / d);
    },

    /**
     * Calculate the complex arcus sinus
     *
     * @returns {Complex}
     */
    "asin": function() {

      var a = this["re"];
      var b = this["im"];

      var t1 = new Complex(
               b * b - a * a + 1,
              -2 * a * b)['sqrt']();

      var t2 = new Complex(
              t1['re'] - b,
              t1['im'] + a)['log']();

      return new Complex(t2['im'], -t2['re']);
    },

    /**
     * Calculate the complex arcus cosinus
     *
     * @returns {Complex}
     */
    "acos": function() {

      var a = this["re"];
      var b = this["im"];

      var t1 = new Complex(
               b * b - a * a + 1,
              -2 * a * b)['sqrt']();

      var t2 = new Complex(
              t1["re"] - b,
              t1["im"] + a)['log']();

      return new Complex(Math.PI / 2 - t2["im"], t2["re"]);
    },

    /**
     * Calculate the complex arcus tangent
     *
     * @returns {Complex}
     */
    "atan": function() {

      var a = this["re"];
      var b = this["im"];

      if (a === 0) {

        if (b === 1) {
          return new Complex(0, Infinity);
        }

        if (b === -1) {
          return new Complex(0, -Infinity);
        }
      }

      var d = a * a + (1.0 - b) * (1.0 - b);

      var t1 = new Complex(
              (1 - b * b - a * a) / d,
              -2 * a / d).log();

      return new Complex(-0.5 * t1["im"], 0.5 * t1["re"]);
    },

    /**
     * Calculate the complex arcus cotangent
     *
     * @returns {Complex}
     */
    "acot": function() {

      var a = this["re"];
      var b = this["im"];

      if (b === 0) {
        return new Complex(Math.atan2(1, a), 0);
      }

      var d = a * a + b * b;
      return (d !== 0)
              ? new Complex(
                      a / d,
                     -b / d).atan()
              : new Complex(
                      (a !== 0) ? a / 0 : 0,
                      (b !== 0) ?-b / 0 : 0).atan();
    },

    /**
     * Calculate the complex arcus secant
     *
     * @returns {Complex}
     */
    "asec": function() {

      var a = this["re"];
      var b = this["im"];

      if (a === 0 && b === 0) {
        return new Complex(0, Infinity);
      }

      var d = a * a + b * b;
      return (d !== 0)
              ? new Complex(
                      a / d,
                      -b / d).acos()
              : new Complex(
                      (a !== 0) ? a / 0 : 0,
                      (b !== 0) ?-b / 0 : 0).acos();
    },

    /**
     * Calculate the complex arcus cosecans
     *
     * @returns {Complex}
     */
    "acsc": function() {

      var a = this["re"];
      var b = this["im"];

      if (a === 0 && b === 0) {
        return new Complex(Math.PI / 2, Infinity);
      }

      var d = a * a + b * b;
      return (d !== 0)
              ? new Complex(
                      a / d,
                     -b / d).asin()
              : new Complex(
                      (a !== 0) ? a / 0 : 0,
                      (b !== 0) ?-b / 0 : 0).asin();
    },

    /**
     * Calculate the complex sinh
     *
     * @returns {Complex}
     */
    "sinh": function() {

      var a = this["re"];
      var b = this["im"];

      return new Complex(
              Math.sinh(a) * Math.cos(b),
              Math.cosh(a) * Math.sin(b));
    },

    /**
     * Calculate the complex cosh
     *
     * @returns {Complex}
     */
    "cosh": function() {

      var a = this["re"];
      var b = this["im"];

      return new Complex(
              Math.cosh(a) * Math.cos(b),
              Math.sinh(a) * Math.sin(b));
    },

    /**
     * Calculate the complex tanh
     *
     * @returns {Complex}
     */
    "tanh": function() {

      var a = 2 * this["re"];
      var b = 2 * this["im"];
      var d = Math.cosh(a) + Math.cos(b);

      return new Complex(
              Math.sinh(a) / d,
              Math.sin(b) / d);
    },

    /**
     * Calculate the complex coth
     *
     * @returns {Complex}
     */
    "coth": function() {

      var a = 2 * this["re"];
      var b = 2 * this["im"];
      var d = Math.cosh(a) - Math.cos(b);

      return new Complex(
              Math.sinh(a) / d,
             -Math.sin(b) / d);
    },

    /**
     * Calculate the complex coth
     *
     * @returns {Complex}
     */
    "csch": function() {

      var a = this["re"];
      var b = this["im"];
      var d = Math.cos(2 * b) - Math.cosh(2 * a);

      return new Complex(
           -2 * Math.sinh(a) * Math.cos(b) / d, 
            2 * Math.cosh(a) * Math.sin(b) / d);
    },

    /**
     * Calculate the complex sech
     *
     * @returns {Complex}
     */
    "sech": function() {

      var a = this["re"];
      var b = this["im"];
      var d = Math.cos(2 * b) + Math.cosh(2 * a);

      return new Complex(
              2 * Math.cosh(a) * Math.cos(b) / d, 
             -2 * Math.sinh(a) * Math.sin(b) / d);
    },

    /**
     * Calculate the complex asinh
     *
     * @returns {Complex}
     */
    "asinh": function() {

      var tmp = this["im"];
      this["im"] = -this["re"];
      this["re"] = tmp;
      var res = this["asin"]();

      this["re"] = -this["im"];
      this["im"] = tmp;
      tmp = res["re"];

      res["re"] = -res["im"];
      res["im"] = tmp;
      return res;
    },

    /**
     * Calculate the complex asinh
     *
     * @returns {Complex}
     */
    "acosh": function() {

      var tmp;
      var res = this["acos"]();
      if (res["im"] <= 0) {
        tmp = res["re"];
        res["re"] = -res["im"];
        res["im"] = tmp;
      } else {
        tmp = res["im"];
        res["im"] = -res["re"];
        res["re"] = tmp;
      }
      return res;
    },

    /**
     * Calculate the complex atanh
     *
     * @returns {Complex}
     */
    "atanh": function() {

      var a = this["re"];
      var b = this["im"];

      var noIM = a > 1 && b === 0;
      var oneMinus = 1 - a;
      var onePlus = 1 + a;
      var d = oneMinus * oneMinus + b * b;

      var x = (d !== 0)
              ? new Complex(
                      (onePlus * oneMinus - b * b) / d,
                      (b * oneMinus + onePlus * b) / d)
              : new Complex(
                      (a !== -1) ? (a / 0) : 0,
                      (b !== 0) ? (b / 0) : 0);

      var temp = x["re"];
      x["re"] = logHypot(x["re"], x["im"]) / 2;
      x["im"] = Math.atan2(x["im"], temp) / 2;
      if (noIM) {
        x["im"] = -x["im"];
      }
      return x;
    },

    /**
     * Calculate the complex acoth
     *
     * @returns {Complex}
     */
    "acoth": function() {

      var a = this["re"];
      var b = this["im"];

      if (a === 0 && b === 0) {

        return new Complex(0, Math.PI / 2);
      }

      var d = a * a + b * b;
      return (d !== 0)
              ? new Complex(
                      a / d,
                     -b / d).atanh()
              : new Complex(
                      (a !== 0) ? a / 0 : 0,
                      (b !== 0) ?-b / 0 : 0).atanh();
    },

    /**
     * Calculate the complex acsch
     *
     * @returns {Complex}
     */
    "acsch": function() {

      var a = this["re"];
      var b = this["im"];

      if (b === 0) {

        return new Complex(
                (a !== 0)
                ? Math.log(a + Math.sqrt(a * a + 1))
                : Infinity, 0);
      }

      var d = a * a + b * b;
      return (d !== 0)
              ? new Complex(
                      a / d,
                      -b / d).asinh()
              : new Complex(
                      (a !== 0) ? a / 0 : 0,
                      (b !== 0) ?-b / 0 : 0).asinh();
    },

    /**
     * Calculate the complex asech
     *
     * @returns {Complex}
     */
    "asech": function() {

      var a = this["re"];
      var b = this["im"];

      if (a === 0 && b === 0) {
        return new Complex(Infinity, 0);
      }

      var d = a * a + b * b;
      return (d !== 0)
              ? new Complex(
                      a / d,
                     -b / d).acosh()
              : new Complex(
                      (a !== 0) ? a / 0 : 0,
                      (b !== 0) ?-b / 0 : 0).acosh();
    },

    /**
     * Calculate the complex inverse 1/z
     *
     * @returns {Complex}
     */
    "inverse": function() {

      var a = this["re"];
      var b = this["im"];

      var d = a * a + b * b;

      return new Complex(
              a !== 0 ? a / d : 0,
              b !== 0 ?-b / d : 0);
    },

    /**
     * Returns the complex conjugate
     *
     * @returns {Complex}
     */
    "conjugate": function() {

      return new Complex(this["re"], -this["im"]);
    },

    /**
     * Gets the negated complex number
     *
     * @returns {Complex}
     */
    "neg": function() {

      return new Complex(-this["re"], -this["im"]);
    },

    /**
     * Ceils the actual complex number
     *
     * @returns {Complex}
     */
    "ceil": function(places) {

      places = Math.pow(10, places || 0);

      return new Complex(
              Math.ceil(this["re"] * places) / places,
              Math.ceil(this["im"] * places) / places);
    },

    /**
     * Floors the actual complex number
     *
     * @returns {Complex}
     */
    "floor": function(places) {

      places = Math.pow(10, places || 0);

      return new Complex(
              Math.floor(this["re"] * places) / places,
              Math.floor(this["im"] * places) / places);
    },

    /**
     * Ceils the actual complex number
     *
     * @returns {Complex}
     */
    "round": function(places) {

      places = Math.pow(10, places || 0);

      return new Complex(
              Math.round(this["re"] * places) / places,
              Math.round(this["im"] * places) / places);
    },

    /**
     * Compares two complex numbers
     *
     * @returns {boolean}
     */
    "equals": function(a, b) {

      parse(a, b); // mutates P

      return Math.abs(P["re"] - this["re"]) <= Complex["EPSILON"] &&
             Math.abs(P["im"] - this["im"]) <= Complex["EPSILON"];
    },

    /**
     * Clones the actual object
     *
     * @returns {Complex}
     */
    "clone": function() {

      return new Complex(this["re"], this["im"]);
    },

    /**
     * Gets a string of the actual complex number
     *
     * @returns {string}
     */
    "toString": function() {

      var a = this["re"];
      var b = this["im"];
      var ret = "";

      if (isNaN(a) || isNaN(b)) {
        return "NaN";
      }

      if (a !== 0) {
        ret+= a;
      }

      if (b !== 0) {

        if (a !== 0) {
          ret+= b < 0 ? " - " : " + ";
        } else if (b < 0) {
          ret+= "-";
        }

        b = Math.abs(b);

        if (1 !== b) {
          ret+= b;
        }
        ret+= "i";
      }

      if (!ret)
        return "0";

      return ret;
    },

    /**
     * Returns the actual number as a vector
     *
     * @returns {Array}
     */
    "toVector": function() {

      return [this["re"], this["im"]];
    },

    /**
     * Returns the actual real value of the current object
     *
     * @returns {number|null}
     */
    "valueOf": function() {

      if (this["im"] === 0) {
        return this["re"];
      }
      return null;
    },

    /**
     * Checks if the given complex number is not a number
     *
     * @returns {boolean}
     */
    isNaN: function() {
      return isNaN(this['re']) || isNaN(this['im']);
    }
  };

  Complex["ZERO"] = new Complex(0, 0);
  Complex["ONE"] = new Complex(1, 0);
  Complex["I"] = new Complex(0, 1);
  Complex["PI"] = new Complex(Math.PI, 0);
  Complex["E"] = new Complex(Math.E, 0);
  Complex['EPSILON'] = 1e-16;

  if (typeof define === "function" && define["amd"]) {
    define([], function() {
      return Complex;
    });
  } else if (typeof exports === "object") {
    module["exports"] = Complex;
  } else {
    root["Complex"] = Complex;
  }
  
})(this);

},{}],489:[function(require,module,exports){
/*! decimal.js v5.0.6 https://github.com/MikeMcl/decimal.js/LICENCE */
;(function (globalScope) {
  'use strict';


  /*
   *  decimal.js v5.0.6
   *  An arbitrary-precision Decimal type for JavaScript.
   *  https://github.com/MikeMcl/decimal.js
   *  Copyright (c) 2016 Michael Mclaughlin <M8ch88l@gmail.com>
   *  MIT Expat Licence
   */


  // -----------------------------------  EDITABLE DEFAULTS  ------------------------------------ //


    // The maximum exponent magnitude.
    // The limit on the value of `toExpNeg`, `toExpPos`, `minE` and `maxE`.
  var EXP_LIMIT = 9e15,                      // 0 to 9e15

    // The limit on the value of `precision`, and on the value of the first argument to
    // `toDecimalPlaces`, `toExponential`, `toFixed`, `toPrecision` and `toSignificantDigits`.
    MAX_DIGITS = 1e9,                        // 0 to 1e9

    // The base 88 alphabet used by `toJSON` and `fromJSON`.
    // 7 printable ASCII characters omitted (space) \ " & ' < >
    NUMERALS = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!#$%()*+,-./:;=?@[]^_`{|}~',

    // The natural logarithm of 10 (1025 digits).
    LN10 = '2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058',

    // Pi (1025 digits).
    PI = '3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789',


    // The initial configuration properties of the Decimal constructor.
    Decimal = {

      // These values must be integers within the stated ranges (inclusive).
      // Most of these values can be changed during run-time using `Decimal.config`.

      // The maximum number of significant digits of the result of a calculation or base conversion.
      // E.g. `Decimal.config({ precision: 20 });`
      precision: 20,                         // 1 to MAX_DIGITS

      // The rounding mode used when rounding to `precision`.
      //
      // ROUND_UP         0 Away from zero.
      // ROUND_DOWN       1 Towards zero.
      // ROUND_CEIL       2 Towards +Infinity.
      // ROUND_FLOOR      3 Towards -Infinity.
      // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
      // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
      // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
      // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
      // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
      //
      // E.g.
      // `Decimal.rounding = 4;`
      // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
      rounding: 4,                           // 0 to 8

      // The modulo mode used when calculating the modulus: a mod n.
      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
      // The remainder (r) is calculated as: r = a - n * q.
      //
      // UP         0 The remainder is positive if the dividend is negative, else is negative.
      // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
      // FLOOR      3 The remainder has the same sign as the divisor (Python %).
      // HALF_EVEN  6 The IEEE 754 remainder function.
      // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
      //
      // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
      // division (9) are commonly used for the modulus operation. The other rounding modes can also
      // be used, but they may not give useful results.
      modulo: 1,                             // 0 to 9

      // The exponent value at and beneath which `toString` returns exponential notation.
      // JavaScript numbers: -7
      toExpNeg: -7,                          // 0 to -EXP_LIMIT

      // The exponent value at and above which `toString` returns exponential notation.
      // JavaScript numbers: 21
      toExpPos:  21,                         // 0 to EXP_LIMIT

      // The minimum exponent value, beneath which underflow to zero occurs.
      // JavaScript numbers: -324  (5e-324)
      minE: -EXP_LIMIT,                      // -1 to -EXP_LIMIT

      // The maximum exponent value, above which overflow to Infinity occurs.
      // JavaScript numbers: 308  (1.7976931348623157e+308)
      maxE: EXP_LIMIT,                       // 1 to EXP_LIMIT

      // Whether to use cryptographically-secure random number generation, if available.
      crypto: void 0                         // true/false/undefined
    },


  // ----------------------------------- END OF EDITABLE DEFAULTS ------------------------------- //


    inexact, noConflict, quadrant,
    cryptoObject = typeof crypto != 'undefined' ? crypto : null,
    external = true,

    decimalError = '[DecimalError] ',
    invalidArgument = decimalError + 'Invalid argument: ',
    precisionLimitExceeded = decimalError + 'Precision limit exceeded',

    mathfloor = Math.floor,
    mathpow = Math.pow,

    isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,
    isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,
    isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,
    isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,

    BASE = 1e7,
    LOG_BASE = 7,
    MAX_SAFE_INTEGER = 9007199254740991,

    LN10_PRECISION = LN10.length - 1,
    PI_PRECISION = PI.length - 1,

    // Decimal.prototype object
    P = {};


  // Decimal prototype methods


  /*
   *  absoluteValue             abs
   *  ceil
   *  comparedTo                cmp
   *  cosine                    cos
   *  cubeRoot                  cbrt
   *  decimalPlaces             dp
   *  dividedBy                 div
   *  dividedToIntegerBy        divToInt
   *  equals                    eq
   *  floor
   *  greaterThan               gt
   *  greaterThanOrEqualTo      gte
   *  hyperbolicCosine          cosh
   *  hyperbolicSine            sinh
   *  hyperbolicTangent         tanh
   *  inverseCosine             acos
   *  inverseHyperbolicCosine   acosh
   *  inverseHyperbolicSine     asinh
   *  inverseHyperbolicTangent  atanh
   *  inverseSine               asin
   *  inverseTangent            atan
   *  isFinite
   *  isInteger                 isInt
   *  isNaN
   *  isNegative                isNeg
   *  isPositive                isPos
   *  isZero
   *  lessThan                  lt
   *  lessThanOrEqualTo         lte
   *  logarithm                 log
   *  [maximum]                 [max]
   *  [minimum]                 [min]
   *  minus                     sub
   *  modulo                    mod
   *  naturalExponential        exp
   *  naturalLogarithm          ln
   *  negated                   neg
   *  plus                      add
   *  precision                 sd
   *  round
   *  sine                      sin
   *  squareRoot                sqrt
   *  tangent                   tan
   *  times                     mul
   *  toBinary
   *  toDecimalPlaces           toDP
   *  toExponential
   *  toFixed
   *  toFraction
   *  toHexadecimal             toHex
   *  toJSON
   *  toNearest
   *  toNumber
   *  toOctal
   *  toPower                   pow
   *  toPrecision
   *  toSignificantDigits       toSD
   *  toString
   *  truncated                 trunc
   *  valueOf
   */


  /*
   * Return a new Decimal whose value is the absolute value of this Decimal.
   *
   */
  P.absoluteValue = P.abs = function () {
    var x = new this.constructor(this);
    if (x.s < 0) x.s = 1;
    return finalise(x);
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the
   * direction of positive Infinity.
   *
   */
  P.ceil = function () {
    return finalise(new this.constructor(this), this.e + 1, 2);
  };


  /*
   * Return
   *   1    if the value of this Decimal is greater than the value of `y`,
   *  -1    if the value of this Decimal is less than the value of `y`,
   *   0    if they have the same value,
   *   NaN  if the value of either Decimal is NaN.
   *
   */
  P.comparedTo = P.cmp = function (y) {
    var i, j, xdL, ydL,
      x = this,
      xd = x.d,
      yd = (y = new x.constructor(y)).d,
      xs = x.s,
      ys = y.s;

    // Either NaN or ±Infinity?
    if (!xd || !yd) {
      return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
    }

    // Either zero?
    if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;

    // Signs differ?
    if (xs !== ys) return xs;

    // Compare exponents.
    if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;

    xdL = xd.length;
    ydL = yd.length;

    // Compare digit by digit.
    for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
      if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
    }

    // Compare lengths.
    return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
  };


  /*
   * Return a new Decimal whose value is the cosine of the value in radians of this Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-1, 1]
   *
   * cos(0)         = 1
   * cos(-0)        = 1
   * cos(Infinity)  = NaN
   * cos(-Infinity) = NaN
   * cos(NaN)       = NaN
   *
   */
  P.cosine = P.cos = function () {
    var pr, rm,
      x = this,
      Ctor = x.constructor;

    if (!x.d) return new Ctor(NaN);

    // cos(0) = cos(-0) = 1
    if (!x.d[0]) return new Ctor(1);

    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
    Ctor.rounding = 1;

    x = cosine(Ctor, toLessThanHalfPi(Ctor, x));

    Ctor.precision = pr;
    Ctor.rounding = rm;

    return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
  };


  /*
   *
   * Return a new Decimal whose value is the cube root of the value of this Decimal, rounded to
   * `precision` significant digits using rounding mode `rounding`.
   *
   *  cbrt(0)  =  0
   *  cbrt(-0) = -0
   *  cbrt(1)  =  1
   *  cbrt(-1) = -1
   *  cbrt(N)  =  N
   *  cbrt(-I) = -I
   *  cbrt(I)  =  I
   *
   * Math.cbrt(x) = (x < 0 ? -Math.pow(-x, 1/3) : Math.pow(x, 1/3))
   *
   */
  P.cubeRoot = P.cbrt = function () {
    var e, m, n, r, rep, s, sd, t, t3, t3plusx,
      x = this,
      Ctor = x.constructor;

    if (!x.isFinite() || x.isZero()) return new Ctor(x);
    external = false;

    // Initial estimate.
    s = x.s * Math.pow(x.s * x, 1 / 3);

     // Math.cbrt underflow/overflow?
     // Pass x to Math.pow as integer, then adjust the exponent of the result.
    if (!s || Math.abs(s) == 1 / 0) {
      n = digitsToString(x.d);
      e = x.e;

      // Adjust n exponent so it is a multiple of 3 away from x exponent.
      if (s = (e - n.length + 1) % 3) n += (s == 1 || s == -2 ? '0' : '00');
      s = Math.pow(n, 1 / 3);

      // Rarely, e may be one less than the result exponent value.
      e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));

      if (s == 1 / 0) {
        n = '5e' + e;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf('e') + 1) + e;
      }

      r = new Ctor(n);
      r.s = x.s;
    } else {
      r = new Ctor(s.toString());
    }

    sd = (e = Ctor.precision) + 3;

    // Halley's method.
    // TODO? Compare Newton's method.
    for (;;) {
      t = r;
      t3 = t.times(t).times(t);
      t3plusx = t3.plus(x);
      r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);

      // TODO? Replace with for-loop and checkRoundingDigits.
      if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
        n = n.slice(sd - 3, sd + 1);

        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or 4999
        // , i.e. approaching a rounding boundary, continue the iteration.
        if (n == '9999' || !rep && n == '4999') {

          // On the first iteration only, check to see if rounding up gives the exact result as the
          // nines may infinitely repeat.
          if (!rep) {
            finalise(t, e + 1, 0);

            if (t.times(t).times(t).eq(x)) {
              r = t;
              break;
            }
          }

          sd += 4;
          rep = 1;
        } else {

          // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.
          // If not, then there are further digits and m will be truthy.
          if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

            // Truncate to the first rounding digit.
            finalise(r, e + 1, 1);
            m = !r.times(r).times(r).eq(x);
          }

          break;
        }
      }
    }

    external = true;

    return finalise(r, e, Ctor.rounding, m);
  };


  /*
   * Return the number of decimal places of the value of this Decimal.
   *
   */
  P.decimalPlaces = P.dp = function () {
    var w,
      d = this.d,
      n = NaN;

    if (d) {
      w = d.length - 1;
      n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;

      // Subtract the number of trailing zeros of the last word.
      w = d[w];
      if (w) for (; w % 10 == 0; w /= 10) n--;
      if (n < 0) n = 0;
    }

    return n;
  };


  /*
   *  n / 0 = I
   *  n / N = N
   *  n / I = 0
   *  0 / n = 0
   *  0 / 0 = N
   *  0 / N = N
   *  0 / I = 0
   *  N / n = N
   *  N / 0 = N
   *  N / N = N
   *  N / I = N
   *  I / n = I
   *  I / 0 = I
   *  I / N = N
   *  I / I = N
   *
   * Return a new Decimal whose value is the value of this Decimal divided by `y`, rounded to
   * `precision` significant digits using rounding mode `rounding`.
   *
   */
  P.dividedBy = P.div = function (y) {
    return divide(this, new this.constructor(y));
  };


  /*
   * Return a new Decimal whose value is the integer part of dividing the value of this Decimal
   * by the value of `y`, rounded to `precision` significant digits using rounding mode `rounding`.
   *
   */
  P.dividedToIntegerBy = P.divToInt = function (y) {
    var x = this,
      Ctor = x.constructor;
    return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
  };


  /*
   * Return true if the value of this Decimal is equal to the value of `y`, otherwise return false.
   *
   */
  P.equals = P.eq = function (y) {
    return this.cmp(y) === 0;
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the
   * direction of negative Infinity.
   *
   */
  P.floor = function () {
    return finalise(new this.constructor(this), this.e + 1, 3);
  };


  /*
   * Return true if the value of this Decimal is greater than the value of `y`, otherwise return
   * false.
   *
   */
  P.greaterThan = P.gt = function (y) {
    return this.cmp(y) > 0;
  };


  /*
   * Return true if the value of this Decimal is greater than or equal to the value of `y`,
   * otherwise return false.
   *
   */
  P.greaterThanOrEqualTo = P.gte = function (y) {
    var k = this.cmp(y);
    return k == 1 || k === 0;
  };


  /*
   * Return a new Decimal whose value is the hyperbolic cosine of the value in radians of this
   * Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [1, Infinity]
   *
   * cosh(x) = 1 + x^2/2! + x^4/4! + x^6/6! + ...
   *
   * cosh(0)         = 1
   * cosh(-0)        = 1
   * cosh(Infinity)  = Infinity
   * cosh(-Infinity) = Infinity
   * cosh(NaN)       = NaN
   *
   *  x        time taken (ms)   result
   * 1000      9                 9.8503555700852349694e+433
   * 10000     25                4.4034091128314607936e+4342
   * 100000    171               1.4033316802130615897e+43429
   * 1000000   3817              1.5166076984010437725e+434294
   * 10000000  abandoned after 2 minute wait
   *
   * TODO? Compare performance of cosh(x) = 0.5 * (exp(x) + exp(-x))
   *
   */
  P.hyperbolicCosine = P.cosh = function () {
    var k, n, pr, rm, len,
      x = this,
      Ctor = x.constructor,
      one = new Ctor(1);

    if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);
    if (x.isZero()) return one;

    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
    Ctor.rounding = 1;
    len = x.d.length;

    // Argument reduction: cos(4x) = 1 - 8cos^2(x) + 8cos^4(x) + 1
    // i.e. cos(x) = 1 - cos^2(x/4)(8 - 8cos^2(x/4))

    // Estimate the optimum number of times to use the argument reduction.
    // TODO? Estimation reused from cosine() and may not be optimal here.
    if (len < 32) {
      k = Math.ceil(len / 3);
      n = Math.pow(4, -k).toString();
    } else {
      k = 16;
      n = '2.3283064365386962890625e-10';
    }

    x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);

    // Reverse argument reduction
    var cosh2_x,
      i = k,
      d8 = new Ctor(8);
    for (; i--;) {
      cosh2_x = x.times(x);
      x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
    }

    return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
  };


  /*
   * Return a new Decimal whose value is the hyperbolic sine of the value in radians of this
   * Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-Infinity, Infinity]
   *
   * sinh(x) = x + x^3/3! + x^5/5! + x^7/7! + ...
   *
   * sinh(0)         = 0
   * sinh(-0)        = -0
   * sinh(Infinity)  = Infinity
   * sinh(-Infinity) = -Infinity
   * sinh(NaN)       = NaN
   *
   * x        time taken (ms)
   * 10       2 ms
   * 100      5 ms
   * 1000     14 ms
   * 10000    82 ms
   * 100000   886 ms            1.4033316802130615897e+43429
   * 200000   2613 ms
   * 300000   5407 ms
   * 400000   8824 ms
   * 500000   13026 ms          8.7080643612718084129e+217146
   * 1000000  48543 ms
   *
   * TODO? Compare performance of sinh(x) = 0.5 * (exp(x) - exp(-x))
   *
   */
  P.hyperbolicSine = P.sinh = function () {
    var k, pr, rm, len,
      x = this,
      Ctor = x.constructor;

    if (!x.isFinite() || x.isZero()) return new Ctor(x);

    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
    Ctor.rounding = 1;
    len = x.d.length;

    if (len < 3) {
      x = taylorSeries(Ctor, 2, x, x, true);
    } else {

      // Alternative argument reduction: sinh(3x) = sinh(x)(3 + 4sinh^2(x))
      // i.e. sinh(x) = sinh(x/3)(3 + 4sinh^2(x/3))
      // 3 multiplications and 1 addition

      // Argument reduction: sinh(5x) = sinh(x)(5 + sinh^2(x)(20 + 16sinh^2(x)))
      // i.e. sinh(x) = sinh(x/5)(5 + sinh^2(x/5)(20 + 16sinh^2(x/5)))
      // 4 multiplications and 2 additions

      // Estimate the optimum number of times to use the argument reduction.
      k = 1.4 * Math.sqrt(len);
      k = k > 16 ? 16 : k | 0;

      x = x.times(Math.pow(5, -k));

      x = taylorSeries(Ctor, 2, x, x, true);

      // Reverse argument reduction
      var sinh2_x,
        d5 = new Ctor(5),
        d16 = new Ctor(16),
        d20 = new Ctor(20);
      for (; k--;) {
        sinh2_x = x.times(x);
        x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
      }
    }

    Ctor.precision = pr;
    Ctor.rounding = rm;

    return finalise(x, pr, rm, true);
  };


  /*
   * Return a new Decimal whose value is the hyperbolic tangent of the value in radians of this
   * Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-1, 1]
   *
   * tanh(x) = sinh(x) / cosh(x)
   *
   * tanh(0)         = 0
   * tanh(-0)        = -0
   * tanh(Infinity)  = 1
   * tanh(-Infinity) = -1
   * tanh(NaN)       = NaN
   *
   */
  P.hyperbolicTangent = P.tanh = function () {
    var pr, rm,
      x = this,
      Ctor = x.constructor;

    if (!x.isFinite()) return new Ctor(x.s);
    if (x.isZero()) return new Ctor(x);

    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + 7;
    Ctor.rounding = 1;

    return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
  };


  /*
   * Return a new Decimal whose value is the arccosine (inverse cosine) in radians of the value of
   * this Decimal.
   *
   * Domain: [-1, 1]
   * Range: [0, pi]
   *
   * acos(x) = pi/2 - asin(x)
   *
   * acos(0)       = pi/2
   * acos(-0)      = pi/2
   * acos(1)       = 0
   * acos(-1)      = pi
   * acos(1/2)     = pi/3
   * acos(-1/2)    = 2*pi/3
   * acos(|x| > 1) = NaN
   * acos(NaN)     = NaN
   *
   */
  P.inverseCosine = P.acos = function () {
    var halfPi,
      x = this,
      Ctor = x.constructor,
      k = x.abs().cmp(1),
      pr = Ctor.precision,
      rm = Ctor.rounding;

    if (k !== -1) {
      return k === 0
        // |x| is 1
        ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0)
        // |x| > 1 or x is NaN
        : new Ctor(NaN);
    }

    if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);

    // TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3

    Ctor.precision = pr + 6;
    Ctor.rounding = 1;

    x = x.asin();
    halfPi = getPi(Ctor, pr + 4, rm).times(0.5);

    Ctor.precision = pr;
    Ctor.rounding = rm;

    return halfPi.minus(x);
  };


  /*
   * Return a new Decimal whose value is the inverse of the hyperbolic cosine in radians of the
   * value of this Decimal.
   *
   * Domain: [1, Infinity]
   * Range: [0, Infinity]
   *
   * acosh(x) = ln(x + sqrt(x^2 - 1))
   *
   * acosh(x < 1)     = NaN
   * acosh(NaN)       = NaN
   * acosh(Infinity)  = Infinity
   * acosh(-Infinity) = NaN
   * acosh(0)         = NaN
   * acosh(-0)        = NaN
   * acosh(1)         = 0
   * acosh(-1)        = NaN
   *
   */
  P.inverseHyperbolicCosine = P.acosh = function () {
    var pr, rm,
      x = this,
      Ctor = x.constructor;

    if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);
    if (!x.isFinite()) return new Ctor(x);

    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
    Ctor.rounding = 1;
    external = false;

    x = x.times(x).minus(1).sqrt().plus(x);

    external = true;
    Ctor.precision = pr;
    Ctor.rounding = rm;

    return x.ln();
  };


  /*
   * Return a new Decimal whose value is the inverse of the hyperbolic sine in radians of the value
   * of this Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-Infinity, Infinity]
   *
   * asinh(x) = ln(x + sqrt(x^2 + 1))
   *
   * asinh(NaN)       = NaN
   * asinh(Infinity)  = Infinity
   * asinh(-Infinity) = -Infinity
   * asinh(0)         = 0
   * asinh(-0)        = -0
   *
   */
  P.inverseHyperbolicSine = P.asinh = function () {
    var pr, rm,
      x = this,
      Ctor = x.constructor;

    if (!x.isFinite() || x.isZero()) return new Ctor(x);

    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
    Ctor.rounding = 1;
    external = false;

    x = x.times(x).plus(1).sqrt().plus(x);

    external = true;
    Ctor.precision = pr;
    Ctor.rounding = rm;

    return x.ln();
  };


  /*
   * Return a new Decimal whose value is the inverse of the hyperbolic tangent in radians of the
   * value of this Decimal.
   *
   * Domain: [-1, 1]
   * Range: [-Infinity, Infinity]
   *
   * atanh(x) = 0.5 * ln((1 + x) / (1 - x))
   *
   * atanh(|x| > 1)   = NaN
   * atanh(NaN)       = NaN
   * atanh(Infinity)  = NaN
   * atanh(-Infinity) = NaN
   * atanh(0)         = 0
   * atanh(-0)        = -0
   * atanh(1)         = Infinity
   * atanh(-1)        = -Infinity
   *
   */
  P.inverseHyperbolicTangent = P.atanh = function () {
    var pr, rm, wpr, xsd,
      x = this,
      Ctor = x.constructor;

    if (!x.isFinite()) return new Ctor(NaN);
    if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);

    pr = Ctor.precision;
    rm = Ctor.rounding;
    xsd = x.sd();

    if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);

    Ctor.precision = wpr = xsd - x.e;

    x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);

    Ctor.precision = pr + 4;
    Ctor.rounding = 1;

    x = x.ln();

    Ctor.precision = pr;
    Ctor.rounding = rm;

    return x.times(0.5);
  };


  /*
   * Return a new Decimal whose value is the arcsine (inverse sine) in radians of the value of this
   * Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-pi/2, pi/2]
   *
   * asin(x) = 2*atan(x/(1 + sqrt(1 - x^2)))
   *
   * asin(0)       = 0
   * asin(-0)      = -0
   * asin(1/2)     = pi/6
   * asin(-1/2)    = -pi/6
   * asin(1)       = pi/2
   * asin(-1)      = -pi/2
   * asin(|x| > 1) = NaN
   * asin(NaN)     = NaN
   *
   * TODO? Compare performance of Taylor series.
   *
   */
  P.inverseSine = P.asin = function () {
    var halfPi, k,
      pr, rm,
      x = this,
      Ctor = x.constructor;

    if (x.isZero()) return new Ctor(x);

    k = x.abs().cmp(1);
    pr = Ctor.precision;
    rm = Ctor.rounding;

    if (k !== -1) {

      // |x| is 1
      if (k === 0) {
        halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
        halfPi.s = x.s;
        return halfPi;
      }

      // |x| > 1 or x is NaN
      return new Ctor(NaN);
    }

    // TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6

    Ctor.precision = pr + 6;
    Ctor.rounding = 1;

    x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();

    Ctor.precision = pr;
    Ctor.rounding = rm;

    return x.times(2);
  };


  /*
   * Return a new Decimal whose value is the arctangent (inverse tangent) in radians of the value
   * of this Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-pi/2, pi/2]
   *
   * atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...
   *
   * atan(0)         = 0
   * atan(-0)        = -0
   * atan(1)         = pi/4
   * atan(-1)        = -pi/4
   * atan(Infinity)  = pi/2
   * atan(-Infinity) = -pi/2
   * atan(NaN)       = NaN
   *
   */
  P.inverseTangent = P.atan = function () {
    var i, j, k, n, px, t, r, wpr, x2,
      x = this,
      Ctor = x.constructor,
      pr = Ctor.precision,
      rm = Ctor.rounding;

    if (!x.isFinite()) {
      if (!x.s) return new Ctor(NaN);
      if (pr + 4 <= PI_PRECISION) {
        r = getPi(Ctor, pr + 4, rm).times(0.5);
        r.s = x.s;
        return r;
      }
    } else if (x.isZero()) {
      return new Ctor(x);
    } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
      r = getPi(Ctor, pr + 4, rm).times(0.25);
      r.s = x.s;
      return r;
    }

    Ctor.precision = wpr = pr + 10;
    Ctor.rounding = 1;

    // TODO? if (x >= 1 && pr <= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);

    // Argument reduction
    // Ensure |x| < 0.42
    // atan(x) = 2 * atan(x / (1 + sqrt(1 + x^2)))

    k = Math.min(28, wpr / LOG_BASE + 2 | 0);

    for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));

    external = false;

    j = Math.ceil(wpr / LOG_BASE);
    n = 1;
    x2 = x.times(x);
    r = new Ctor(x);
    px = x;

    // atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...
    for (; i !== -1;) {
      px = px.times(x2);
      t = r.minus(px.div(n += 2));

      px = px.times(x2);
      r = t.plus(px.div(n += 2));

      if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] && i--;);
    }

    if (k) r = r.times(2 << (k - 1));

    external = true;

    return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
  };


  /*
   * Return true if the value of this Decimal is a finite number, otherwise return false.
   *
   */
  P.isFinite = function () {
    return !!this.d;
  };


  /*
   * Return true if the value of this Decimal is an integer, otherwise return false.
   *
   */
  P.isInteger = P.isInt = function () {
    return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
  };


  /*
   * Return true if the value of this Decimal is NaN, otherwise return false.
   *
   */
  P.isNaN = function () {
    return !this.s;
  };


  /*
   * Return true if the value of this Decimal is negative, otherwise return false.
   *
   */
  P.isNegative = P.isNeg = function () {
    return this.s < 0;
  };


  /*
   * Return true if the value of this Decimal is positive, otherwise return false.
   *
   */
  P.isPositive = P.isPos = function () {
    return this.s > 0;
  };


  /*
   * Return true if the value of this Decimal is 0 or -0, otherwise return false.
   *
   */
  P.isZero = function () {
    return !!this.d && this.d[0] === 0;
  };


  /*
   * Return true if the value of this Decimal is less than `y`, otherwise return false.
   *
   */
  P.lessThan = P.lt = function (y) {
    return this.cmp(y) < 0;
  };


  /*
   * Return true if the value of this Decimal is less than or equal to `y`, otherwise return false.
   *
   */
  P.lessThanOrEqualTo = P.lte = function (y) {
    return this.cmp(y) < 1;
  };


  /*
   * Return the logarithm of the value of this Decimal to the specified base, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * If no base is specified, return log[10](arg).
   *
   * log[base](arg) = ln(arg) / ln(base)
   *
   * The result will always be correctly rounded if the base of the log is 10, and 'almost always'
   * otherwise:
   *
   * Depending on the rounding mode, the result may be incorrectly rounded if the first fifteen
   * rounding digits are [49]99999999999999 or [50]00000000000000. In that case, the maximum error
   * between the result and the correctly rounded result will be one ulp (unit in the last place).
   *
   * log[-b](a)       = NaN
   * log[0](a)        = NaN
   * log[1](a)        = NaN
   * log[NaN](a)      = NaN
   * log[Infinity](a) = NaN
   * log[b](0)        = -Infinity
   * log[b](-0)       = -Infinity
   * log[b](-a)       = NaN
   * log[b](1)        = 0
   * log[b](Infinity) = Infinity
   * log[b](NaN)      = NaN
   *
   * [base] {number|string|Decimal} The base of the logarithm.
   *
   */
  P.logarithm = P.log = function (base) {
    var isBase10, d, denominator, k, inf, num, sd, r,
      arg = this,
      Ctor = arg.constructor,
      pr = Ctor.precision,
      rm = Ctor.rounding,
      guard = 5;

    // Default base is 10.
    if (base == null) {
      base = new Ctor(10);
      isBase10 = true;
    } else {
      base = new Ctor(base);
      d = base.d;

      // Return NaN if base is negative, or non-finite, or is 0 or 1.
      if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);

      isBase10 = base.eq(10);
    }

    d = arg.d;

    // Is arg negative, non-finite, 0 or 1?
    if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
      return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
    }

    // The result will have a non-terminating decimal expansion if base is 10 and arg is not an
    // integer power of 10.
    if (isBase10) {
      if (d.length > 1) {
        inf = true;
      } else {
        for (k = d[0]; k % 10 === 0;) k /= 10;
        inf = k !== 1;
      }
    }

    external = false;
    sd = pr + guard;
    num = naturalLogarithm(arg, sd);
    denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);

    // The result will have 5 rounding digits.
    r = divide(num, denominator, sd, 1);

    // If at a rounding boundary, i.e. the result's rounding digits are [49]9999 or [50]0000,
    // calculate 10 further digits.
    //
    // If the result is known to have an infinite decimal expansion, repeat this until it is clear
    // that the result is above or below the boundary. Otherwise, if after calculating the 10
    // further digits, the last 14 are nines, round up and assume the result is exact.
    // Also assume the result is exact if the last 14 are zero.
    //
    // Example of a result that will be incorrectly rounded:
    // log[1048576](4503599627370502) = 2.60000000000000009610279511444746...
    // The above result correctly rounded using ROUND_CEIL to 1 decimal place should be 2.7, but it
    // will be given as 2.6 as there are 15 zeros immediately after the requested decimal place, so
    // the exact result would be assumed to be 2.6, which rounded using ROUND_CEIL to 1 decimal
    // place is still 2.6.
    if (checkRoundingDigits(r.d, k = pr, rm)) {

      do {
        sd += 10;
        num = naturalLogarithm(arg, sd);
        denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
        r = divide(num, denominator, sd, 1);

        if (!inf) {

          // Check for 14 nines from the 2nd rounding digit, as the first may be 4.
          if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
            r = finalise(r, pr + 1, 0);
          }

          break;
        }
      } while (checkRoundingDigits(r.d, k += 10, rm));
    }

    external = true;

    return finalise(r, pr, rm);
  };


  /*
   * Return a new Decimal whose value is the maximum of the arguments and the value of this Decimal.
   *
   * arguments {number|string|Decimal}
   *
  P.max = function () {
    Array.prototype.push.call(arguments, this);
    return maxOrMin(this.constructor, arguments, 'lt');
  };
   */


  /*
   * Return a new Decimal whose value is the minimum of the arguments and the value of this Decimal.
   *
   * arguments {number|string|Decimal}
   *
  P.min = function () {
    Array.prototype.push.call(arguments, this);
    return maxOrMin(this.constructor, arguments, 'gt');
  };
   */


  /*
   *  n - 0 = n
   *  n - N = N
   *  n - I = -I
   *  0 - n = -n
   *  0 - 0 = 0
   *  0 - N = N
   *  0 - I = -I
   *  N - n = N
   *  N - 0 = N
   *  N - N = N
   *  N - I = N
   *  I - n = I
   *  I - 0 = I
   *  I - N = N
   *  I - I = N
   *
   * Return a new Decimal whose value is the value of this Decimal minus `y`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   */
  P.minus = P.sub = function (y) {
    var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd,
      x = this,
      Ctor = x.constructor;

    y = new Ctor(y);

    // If either is not finite...
    if (!x.d || !y.d) {

      // Return NaN if either is NaN.
      if (!x.s || !y.s) y = new Ctor(NaN);

      // Return y negated if x is finite and y is ±Infinity.
      else if (x.d) y.s = -y.s;

      // Return x if y is finite and x is ±Infinity.
      // Return x if both are ±Infinity with different signs.
      // Return NaN if both are ±Infinity with the same sign.
      else y = new Ctor(y.d || x.s !== y.s ? x : NaN);

      return y;
    }

    // If signs differ...
    if (x.s != y.s) {
      y.s = -y.s;
      return x.plus(y);
    }

    xd = x.d;
    yd = y.d;
    pr = Ctor.precision;
    rm = Ctor.rounding;

    // If either is zero...
    if (!xd[0] || !yd[0]) {

      // Return y negated if x is zero and y is non-zero.
      if (yd[0]) y.s = -y.s;

      // Return x if y is zero and x is non-zero.
      else if (xd[0]) y = new Ctor(x);

      // Return zero if both are zero.
      // From IEEE 754 (2008) 6.3: 0 - 0 = -0 - -0 = -0 when rounding to -Infinity.
      else return new Ctor(rm === 3 ? -0 : 0);

      return external ? finalise(y, pr, rm) : y;
    }

    // x and y are finite, non-zero numbers with the same sign.

    // Calculate base 1e7 exponents.
    e = mathfloor(y.e / LOG_BASE);
    xe = mathfloor(x.e / LOG_BASE);

    xd = xd.slice();
    k = xe - e;

    // If base 1e7 exponents differ...
    if (k) {
      xLTy = k < 0;

      if (xLTy) {
        d = xd;
        k = -k;
        len = yd.length;
      } else {
        d = yd;
        e = xe;
        len = xd.length;
      }

      // Numbers with massively different exponents would result in a very high number of
      // zeros needing to be prepended, but this can be avoided while still ensuring correct
      // rounding by limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.
      i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;

      if (k > i) {
        k = i;
        d.length = 1;
      }

      // Prepend zeros to equalise exponents.
      d.reverse();
      for (i = k; i--;) d.push(0);
      d.reverse();

    // Base 1e7 exponents equal.
    } else {

      // Check digits to determine which is the bigger number.

      i = xd.length;
      len = yd.length;
      xLTy = i < len;
      if (xLTy) len = i;

      for (i = 0; i < len; i++) {
        if (xd[i] != yd[i]) {
          xLTy = xd[i] < yd[i];
          break;
        }
      }

      k = 0;
    }

    if (xLTy) {
      d = xd;
      xd = yd;
      yd = d;
      y.s = -y.s;
    }

    len = xd.length;

    // Append zeros to `xd` if shorter.
    // Don't add zeros to `yd` if shorter as subtraction only needs to start at `yd` length.
    for (i = yd.length - len; i > 0; --i) xd[len++] = 0;

    // Subtract yd from xd.
    for (i = yd.length; i > k;) {

      if (xd[--i] < yd[i]) {
        for (j = i; j && xd[--j] === 0;) xd[j] = BASE - 1;
        --xd[j];
        xd[i] += BASE;
      }

      xd[i] -= yd[i];
    }

    // Remove trailing zeros.
    for (; xd[--len] === 0;) xd.pop();

    // Remove leading zeros and adjust exponent accordingly.
    for (; xd[0] === 0; xd.shift()) --e;

    // Zero?
    if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);

    y.d = xd;
    y.e = getBase10Exponent(xd, e);

    return external ? finalise(y, pr, rm) : y;
  };


  /*
   *   n % 0 =  N
   *   n % N =  N
   *   n % I =  n
   *   0 % n =  0
   *  -0 % n = -0
   *   0 % 0 =  N
   *   0 % N =  N
   *   0 % I =  0
   *   N % n =  N
   *   N % 0 =  N
   *   N % N =  N
   *   N % I =  N
   *   I % n =  N
   *   I % 0 =  N
   *   I % N =  N
   *   I % I =  N
   *
   * Return a new Decimal whose value is the value of this Decimal modulo `y`, rounded to
   * `precision` significant digits using rounding mode `rounding`.
   *
   * The result depends on the modulo mode.
   *
   */
  P.modulo = P.mod = function (y) {
    var q,
      x = this,
      Ctor = x.constructor;

    y = new Ctor(y);

    // Return NaN if x is ±Infinity or NaN, or y is NaN or ±0.
    if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);

    // Return x if y is ±Infinity or x is ±0.
    if (!y.d || x.d && !x.d[0]) {
      return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
    }

    // Prevent rounding of intermediate calculations.
    external = false;

    if (Ctor.modulo == 9) {

      // Euclidian division: q = sign(y) * floor(x / abs(y))
      // result = x - q * y    where  0 <= result < abs(y)
      q = divide(x, y.abs(), 0, 3, 1);
      q.s *= y.s;
    } else {
      q = divide(x, y, 0, Ctor.modulo, 1);
    }

    q = q.times(y);

    external = true;

    return x.minus(q);
  };


  /*
   * Return a new Decimal whose value is the natural exponential of the value of this Decimal,
   * i.e. the base e raised to the power the value of this Decimal, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   */
  P.naturalExponential = P.exp = function () {
    return naturalExponential(this);
  };


  /*
   * Return a new Decimal whose value is the natural logarithm of the value of this Decimal,
   * rounded to `precision` significant digits using rounding mode `rounding`.
   *
   */
  P.naturalLogarithm = P.ln = function () {
    return naturalLogarithm(this);
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal negated, i.e. as if multiplied by
   * -1.
   *
   */
  P.negated = P.neg = function () {
    var x = new this.constructor(this);
    x.s = -x.s;
    return finalise(x);
  };


  /*
   *  n + 0 = n
   *  n + N = N
   *  n + I = I
   *  0 + n = n
   *  0 + 0 = 0
   *  0 + N = N
   *  0 + I = I
   *  N + n = N
   *  N + 0 = N
   *  N + N = N
   *  N + I = N
   *  I + n = I
   *  I + 0 = I
   *  I + N = N
   *  I + I = I
   *
   * Return a new Decimal whose value is the value of this Decimal plus `y`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   */
  P.plus = P.add = function (y) {
    var carry, d, e, i, k, len, pr, rm, xd, yd,
      x = this,
      Ctor = x.constructor;

    y = new Ctor(y);

    // If either is not finite...
    if (!x.d || !y.d) {

      // Return NaN if either is NaN.
      if (!x.s || !y.s) y = new Ctor(NaN);

      // Return x if y is finite and x is ±Infinity.
      // Return x if both are ±Infinity with the same sign.
      // Return NaN if both are ±Infinity with different signs.
      // Return y if x is finite and y is ±Infinity.
      else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);

      return y;
    }

     // If signs differ...
    if (x.s != y.s) {
      y.s = -y.s;
      return x.minus(y);
    }

    xd = x.d;
    yd = y.d;
    pr = Ctor.precision;
    rm = Ctor.rounding;

    // If either is zero...
    if (!xd[0] || !yd[0]) {

      // Return x if y is zero.
      // Return y if y is non-zero.
      if (!yd[0]) y = new Ctor(x);

      return external ? finalise(y, pr, rm) : y;
    }

    // x and y are finite, non-zero numbers with the same sign.

    // Calculate base 1e7 exponents.
    k = mathfloor(x.e / LOG_BASE);
    e = mathfloor(y.e / LOG_BASE);

    xd = xd.slice();
    i = k - e;

    // If base 1e7 exponents differ...
    if (i) {

      if (i < 0) {
        d = xd;
        i = -i;
        len = yd.length;
      } else {
        d = yd;
        e = k;
        len = xd.length;
      }

      // Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.
      k = Math.ceil(pr / LOG_BASE);
      len = k > len ? k + 1 : len + 1;

      if (i > len) {
        i = len;
        d.length = 1;
      }

      // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.
      d.reverse();
      for (; i--;) d.push(0);
      d.reverse();
    }

    len = xd.length;
    i = yd.length;

    // If yd is longer than xd, swap xd and yd so xd points to the longer array.
    if (len - i < 0) {
      i = len;
      d = yd;
      yd = xd;
      xd = d;
    }

    // Only start adding at yd.length - 1 as the further digits of xd can be left as they are.
    for (carry = 0; i;) {
      carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
      xd[i] %= BASE;
    }

    if (carry) {
      xd.unshift(carry);
      ++e;
    }

    // Remove trailing zeros.
    // No need to check for zero, as +x + +y != 0 && -x + -y != 0
    for (len = xd.length; xd[--len] == 0;) xd.pop();

    y.d = xd;
    y.e = getBase10Exponent(xd, e);

    return external ? finalise(y, pr, rm) : y;
  };


  /*
   * Return the number of significant digits of the value of this Decimal.
   *
   * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.
   *
   */
  P.precision = P.sd = function (z) {
    var k,
      x = this;

    if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);

    if (x.d) {
      k = getPrecision(x.d);
      if (z && x.e + 1 > k) k = x.e + 1;
    } else {
      k = NaN;
    }

    return k;
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number using
   * rounding mode `rounding`.
   *
   */
  P.round = function () {
    var x = this,
      Ctor = x.constructor;

    return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
  };


  /*
   * Return a new Decimal whose value is the sine of the value in radians of this Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-1, 1]
   *
   * sin(x) = x - x^3/3! + x^5/5! - ...
   *
   * sin(0)         = 0
   * sin(-0)        = -0
   * sin(Infinity)  = NaN
   * sin(-Infinity) = NaN
   * sin(NaN)       = NaN
   *
   */
  P.sine = P.sin = function () {
    var pr, rm,
      x = this,
      Ctor = x.constructor;

    if (!x.isFinite()) return new Ctor(NaN);
    if (x.isZero()) return new Ctor(x);

    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
    Ctor.rounding = 1;

    x = sine(Ctor, toLessThanHalfPi(Ctor, x));

    Ctor.precision = pr;
    Ctor.rounding = rm;

    return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
  };


  /*
   * Return a new Decimal whose value is the square root of this Decimal, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   *  sqrt(-n) =  N
   *  sqrt(N)  =  N
   *  sqrt(-I) =  N
   *  sqrt(I)  =  I
   *  sqrt(0)  =  0
   *  sqrt(-0) = -0
   *
   */
  P.squareRoot = P.sqrt = function () {
    var m, n, sd, r, rep, t,
      x = this,
      d = x.d,
      e = x.e,
      s = x.s,
      Ctor = x.constructor;

    // Negative/NaN/Infinity/zero?
    if (s !== 1 || !d || !d[0]) {
      return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
    }

    external = false;

    // Initial estimate.
    s = Math.sqrt(+x);

    // Math.sqrt underflow/overflow?
    // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
    if (s == 0 || s == 1 / 0) {
      n = digitsToString(d);

      if ((n.length + e) % 2 == 0) n += '0';
      s = Math.sqrt(n);
      e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);

      if (s == 1 / 0) {
        n = '1e' + e;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf('e') + 1) + e;
      }

      r = new Ctor(n);
    } else {
      r = new Ctor(s.toString());
    }

    sd = (e = Ctor.precision) + 3;

    // Newton-Raphson iteration.
    for (;;) {
      t = r;
      r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);

      // TODO? Replace with for-loop and checkRoundingDigits.
      if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
        n = n.slice(sd - 3, sd + 1);

        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or
        // 4999, i.e. approaching a rounding boundary, continue the iteration.
        if (n == '9999' || !rep && n == '4999') {

          // On the first iteration only, check to see if rounding up gives the exact result as the
          // nines may infinitely repeat.
          if (!rep) {
            finalise(t, e + 1, 0);

            if (t.times(t).eq(x)) {
              r = t;
              break;
            }
          }

          sd += 4;
          rep = 1;
        } else {

          // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.
          // If not, then there are further digits and m will be truthy.
          if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

            // Truncate to the first rounding digit.
            finalise(r, e + 1, 1);
            m = !r.times(r).eq(x);
          }

          break;
        }
      }
    }

    external = true;

    return finalise(r, e, Ctor.rounding, m);
  };


  /*
   * Return a new Decimal whose value is the tangent of the value in radians of this Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-Infinity, Infinity]
   *
   * tan(0)         = 0
   * tan(-0)        = -0
   * tan(Infinity)  = NaN
   * tan(-Infinity) = NaN
   * tan(NaN)       = NaN
   *
   */
  P.tangent = P.tan = function () {
    var pr, rm,
      x = this,
      Ctor = x.constructor;

    if (!x.isFinite()) return new Ctor(NaN);
    if (x.isZero()) return new Ctor(x);

    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + 10;
    Ctor.rounding = 1;

    x = x.sin();
    x.s = 1;
    x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);

    Ctor.precision = pr;
    Ctor.rounding = rm;

    return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
  };


  /*
   *  n * 0 = 0
   *  n * N = N
   *  n * I = I
   *  0 * n = 0
   *  0 * 0 = 0
   *  0 * N = N
   *  0 * I = N
   *  N * n = N
   *  N * 0 = N
   *  N * N = N
   *  N * I = N
   *  I * n = I
   *  I * 0 = N
   *  I * N = N
   *  I * I = I
   *
   * Return a new Decimal whose value is this Decimal times `y`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   */
  P.times = P.mul = function (y) {
    var carry, e, i, k, r, rL, t, xdL, ydL,
      x = this,
      Ctor = x.constructor,
      xd = x.d,
      yd = (y = new Ctor(y)).d;

    y.s *= x.s;

     // If either is NaN, ±Infinity or ±0...
    if (!xd || !xd[0] || !yd || !yd[0]) {

      return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd

        // Return NaN if either is NaN.
        // Return NaN if x is ±0 and y is ±Infinity, or y is ±0 and x is ±Infinity.
        ? NaN

        // Return ±Infinity if either is ±Infinity.
        // Return ±0 if either is ±0.
        : !xd || !yd ? y.s / 0 : y.s * 0);
    }

    e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
    xdL = xd.length;
    ydL = yd.length;

    // Ensure xd points to the longer array.
    if (xdL < ydL) {
      r = xd;
      xd = yd;
      yd = r;
      rL = xdL;
      xdL = ydL;
      ydL = rL;
    }

    // Initialise the result array with zeros.
    r = [];
    rL = xdL + ydL;
    for (i = rL; i--;) r.push(0);

    // Multiply!
    for (i = ydL; --i >= 0;) {
      carry = 0;
      for (k = xdL + i; k > i;) {
        t = r[k] + yd[i] * xd[k - i - 1] + carry;
        r[k--] = t % BASE | 0;
        carry = t / BASE | 0;
      }

      r[k] = (r[k] + carry) % BASE | 0;
    }

    // Remove trailing zeros.
    for (; !r[--rL];) r.pop();

    if (carry) ++e;
    else r.shift();

    // Remove trailing zeros.
    for (i = r.length; !r[--i];) r.pop();

    y.d = r;
    y.e = getBase10Exponent(r, e);

    return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
  };


  /*
   * Return a string representing the value of this Decimal in base 2, round to `sd` significant
   * digits using rounding mode `rm`.
   *
   * If the optional `sd` argument is present then return binary exponential notation.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */
  P.toBinary = function (sd, rm) {
    return toStringBinary(this, 2, sd, rm);
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `dp`
   * decimal places using rounding mode `rm` or `rounding` if `rm` is omitted.
   *
   * If `dp` is omitted, return a new Decimal whose value is the value of this Decimal.
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */
  P.toDecimalPlaces = P.toDP = function (dp, rm) {
    var x = this,
      Ctor = x.constructor;

    x = new Ctor(x);
    if (dp === void 0) return x;

    checkInt32(dp, 0, MAX_DIGITS);

    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);

    return finalise(x, dp + x.e + 1, rm);
  };


  /*
   * Return a string representing the value of this Decimal in exponential notation rounded to
   * `dp` fixed decimal places using rounding mode `rounding`.
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */
  P.toExponential = function (dp, rm) {
    var str,
      x = this,
      Ctor = x.constructor;

    if (dp === void 0) {
      str = finiteToString(x, true);
    } else {
      checkInt32(dp, 0, MAX_DIGITS);

      if (rm === void 0) rm = Ctor.rounding;
      else checkInt32(rm, 0, 8);

      x = finalise(new Ctor(x), dp + 1, rm);
      str = finiteToString(x, true, dp + 1);
    }

    return x.isNeg() && !x.isZero() ? '-' + str : str;
  };


  /*
   * Return a string representing the value of this Decimal in normal (fixed-point) notation to
   * `dp` fixed decimal places and rounded using rounding mode `rm` or `rounding` if `rm` is
   * omitted.
   *
   * As with JavaScript numbers, (-0).toFixed(0) is '0', but e.g. (-0.00001).toFixed(0) is '-0'.
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.
   * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
   * (-0).toFixed(3) is '0.000'.
   * (-0.5).toFixed(0) is '-0'.
   *
   */
  P.toFixed = function (dp, rm) {
    var str, y,
      x = this,
      Ctor = x.constructor;

    if (dp === void 0) {
      str = finiteToString(x);
    } else {
      checkInt32(dp, 0, MAX_DIGITS);

      if (rm === void 0) rm = Ctor.rounding;
      else checkInt32(rm, 0, 8);

      y = finalise(new Ctor(x), dp + x.e + 1, rm);
      str = finiteToString(y, false, dp + y.e + 1);
    }

    // To determine whether to add the minus sign look at the value before it was rounded,
    // i.e. look at `x` rather than `y`.
    return x.isNeg() && !x.isZero() ? '-' + str : str;
  };


  /*
   * Return an array representing the value of this Decimal as a simple fraction with an integer
   * numerator and an integer denominator.
   *
   * The denominator will be a positive non-zero value less than or equal to the specified maximum
   * denominator. If a maximum denominator is not specified, the denominator will be the lowest
   * value necessary to represent the number exactly.
   *
   * [maxD] {number|string|Decimal} Maximum denominator. Integer >= 1 and < Infinity.
   *
   */
  P.toFraction = function (maxD) {
    var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r,
      x = this,
      xd = x.d,
      Ctor = x.constructor;

    if (!xd) return new Ctor(x);

    n1 = d0 = new Ctor(1);
    d1 = n0 = new Ctor(0);

    d = new Ctor(d1);
    e = d.e = getPrecision(xd) - x.e - 1;
    k = e % LOG_BASE;
    d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);

    if (maxD == null) {

      // d is 10**e, the minimum max-denominator needed.
      maxD = e > 0 ? d : n1;
    } else {
      n = new Ctor(maxD);
      if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);
      maxD = n.gt(d) ? (e > 0 ? d : n1) : n;
    }

    external = false;
    n = new Ctor(digitsToString(xd));
    pr = Ctor.precision;
    Ctor.precision = e = xd.length * LOG_BASE * 2;

    for (;;)  {
      q = divide(n, d, 0, 1, 1);
      d2 = d0.plus(q.times(d1));
      if (d2.cmp(maxD) == 1) break;
      d0 = d1;
      d1 = d2;
      d2 = n1;
      n1 = n0.plus(q.times(d2));
      n0 = d2;
      d2 = d;
      d = n.minus(q.times(d2));
      n = d2;
    }

    d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
    n0 = n0.plus(d2.times(n1));
    d0 = d0.plus(d2.times(d1));
    n0.s = n1.s = x.s;

    // Determine which fraction is closer to x, n0/d0 or n1/d1?
    r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1
        ? [n1, d1] : [n0, d0];

    Ctor.precision = pr;
    external = true;

    return r;
  };


  /*
   * Return a string representing the value of this Decimal in base 16, round to `sd` significant
   * digits using rounding mode `rm`.
   *
   * If the optional `sd` argument is present then return binary exponential notation.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */
  P.toHexadecimal = P.toHex = function (sd, rm) {
    return toStringBinary(this, 16, sd, rm);
  };


  /*
   * Return a string representing the exact value of this Decimal in a compact base-88 based format.
   *
   * The number of characters of the string will always be equal to or less than the number of
   * characters returned by `toString` or `toExponential` - usually just over half as many.
   *
   * The original Decimal value can be recreated by passing the string to `Decimal.fromJSON`.
   *
   * Base 88 alphabet:
   * 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!#$%()*+,-./:;=?@[]^_`{|}~
   *
   * The following 7 printable ASCII characters are not used
   * (space) \ " & ' < >
   * so the return value is safe for strings, HTML, JSON, and XML.
   *
   *     0   0     g  16    w  32    M  48    $  64    ]  80
   *     1   1     h  17    x  33    N  49    %  65    ^  81
   *     2   2     i  18    y  34    O  50    (  66    _  82
   *     3   3     j  19    z  35    P  51    )  67    `  83
   *     4   4     k  20    A  36    Q  52    *  68    {  84
   *     5   5     l  21    B  37    R  53    +  69    |  85
   *     6   6     m  22    C  38    S  54    ,  70    }  86
   *     7   7     n  23    D  39    T  55    -  71    ~  87
   *     8   8     o  24    E  40    U  56    .  72
   *     9   9     p  25    F  41    V  57    /  73
   *     a  10     q  26    G  42    W  58    :  74
   *     b  11     r  27    H  43    X  59    ;  75
   *     c  12     s  28    I  44    Y  60    =  76
   *     d  13     t  29    J  45    Z  61    ?  77
   *     e  14     u  30    K  46    !  62    @  78
   *     f  15     v  31    L  47    #  63    [  79
   *
   * If the return value is just one character, it represents:
   * 0-81  [[0, 40][-0, -40]]
   * 82    -Infinity
   * 83    +Infinity
   * 84    NaN
   * 85-87 free
   *
   *   64 32 16  8  4  2  1
   *    1  0  1  0  1  1  1 = 87
   *
   */
   P.toJSON = function () {
    var arr, e, i, k, len, n, r, str,
      x = this,
      isNeg = x.s < 0;

    // -Infinity/Infinity/NaN.
    if (!x.d) return NUMERALS.charAt(x.s ? isNeg ? 82 : 83 : 84);
    e = x.e;

    // Small integer.
    if (x.d.length === 1 && e < 4 && e >= 0) {
      n = x.d[0];

      if (n < 2857) {

        // One character.
        // [[0, 40][-0, -40]]
        if (n < 41) return NUMERALS.charAt(isNeg ? n + 41 : n);

        // Two characters. High bit of first character unset.
        // 0XXXXXX
        // 63*88 + 87 = 5631 = 5632 values, 5632/2 = 2816
        // [[0, 2815][2816, 5631]]  (2816 * 2 = 5632 values)
        // [[0, 2815][-0, -2815]]
        // [[41, 2856][-41, -2856]]
        n -= 41;
        if (isNeg) n += 2816;
        k = n / 88 | 0;

        return NUMERALS.charAt(k) + NUMERALS.charAt(n - k * 88);
      }
    }

    str = digitsToString(x.d);
    r = '';

    // Values with a small exponent. Set high bit.
    // Positive value: 100XXXX
    // 1 0 0 {exponent [0, 15] -> [-7, 8]}
    if (!isNeg && e <= 8 && e >= -7) {
      k = 64 + e + 7;

    // Negative value: 1010XXX
    // 1 0 1 0 {exponent [0, 7] -> [-3, 4]}
    } else if (isNeg && e <= 4 && e >= -3) {
      k = 64 + 16 + e + 3;

    // Integer without trailing zeros: 0X00000
    // 0 {is negative} 0 0 0 0 0
    } else if (str.length === e + 1) {
      k = 32 * isNeg;

    // All remaining values: 0XXXXXX
    // Result will have at least 3 characters.
    // 0 {is negative} {is exponent negative} {exponent character count [1, 15]}
    } else {
      k = 32 * isNeg + 16 * (e < 0);
      e = Math.abs(e);

      // One character to represent the exponent.
      if (e < 88)  {
        k += 1;
        r = NUMERALS.charAt(e);

      // Two characters to represent the exponent.
      // 87*88 + 87 = 7743
      } else if (e < 7744) {
        k += 2;
        n = e / 88 | 0;
        r = NUMERALS.charAt(n) + NUMERALS.charAt(e - n * 88);

      // More than two characters to represent the exponent.
      } else {
        arr = convertBase(String(e), 10, 88);
        len = arr.length;
        k += len;
        for (i = 0; i < len; i++) r += NUMERALS.charAt(arr[i]);
      }
    }

    // At this point r contains the characters in base 88 representing the exponent value.
    // Prepend the first character, which describes the sign, the exponent sign, and the number of
    // characters that follow which represent the exponent value.
    r = NUMERALS.charAt(k) + r;
    arr = convertBase(str, 10, 88);
    len = arr.length;

    // Add the base 88 characters that represent the significand.
    for (i = 0; i < len; i++) r += NUMERALS.charAt(arr[i]);

    return r;
  };


  /*
   * Returns a new Decimal whose value is the nearest multiple of the magnitude of `y` to the value
   * of this Decimal.
   *
   * If the value of this Decimal is equidistant from two multiples of `y`, the rounding mode `rm`,
   * or `Decimal.rounding` if `rm` is omitted, determines the direction of the nearest multiple.
   *
   * In the context of this method, rounding mode 4 (ROUND_HALF_UP) is the same as rounding mode 0
   * (ROUND_UP), and so on.
   *
   * The return value will always have the same sign as this Decimal, unless either this Decimal
   * or `y` is NaN, in which case the return value will be also be NaN.
   *
   * The return value is not affected by the value of `precision`.
   *
   * y {number|string|Decimal} The magnitude to round to a multiple of.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * 'toNearest() rounding mode not an integer: {rm}'
   * 'toNearest() rounding mode out of range: {rm}'
   *
   */
  P.toNearest = function (y, rm) {
    var x = this,
      Ctor = x.constructor;

    x = new Ctor(x);

    if (y == null) {

      // If x is not finite, return x.
      if (!x.d) return x;

      y = new Ctor(1);
      rm = Ctor.rounding;
    } else {
      y = new Ctor(y);
      if (rm !== void 0) checkInt32(rm, 0, 8);

      // If x is not finite, return x if y is not NaN, else NaN.
      if (!x.d) return y.s ? x : y;

      // If y is not finite, return Infinity with the sign of x if y is Infinity, else NaN.
      if (!y.d) {
        if (y.s) y.s = x.s;
        return y;
      }
    }

    // If y is not zero, calculate the nearest multiple of y to x.
    if (y.d[0]) {
      external = false;
      if (rm < 4) rm = [4, 5, 7, 8][rm];
      x = divide(x, y, 0, rm, 1).times(y);
      external = true;
      finalise(x);

    // If y is zero, return zero with the sign of x.
    } else {
      y.s = x.s;
      x = y;
    }

    return x;
  };


  /*
   * Return the value of this Decimal converted to a number primitive.
   * Zero keeps its sign.
   *
   */
  P.toNumber = function () {
    return +this;
  };


  /*
   * Return a string representing the value of this Decimal in base 8, round to `sd` significant
   * digits using rounding mode `rm`.
   *
   * If the optional `sd` argument is present then return binary exponential notation.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */
  P.toOctal = function (sd, rm) {
    return toStringBinary(this, 8, sd, rm);
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal raised to the power `y`, rounded
   * to `precision` significant digits using rounding mode `rounding`.
   *
   * ECMAScript compliant.
   *
   *   pow(x, NaN)                           = NaN
   *   pow(x, ±0)                            = 1

   *   pow(NaN, non-zero)                    = NaN
   *   pow(abs(x) > 1, +Infinity)            = +Infinity
   *   pow(abs(x) > 1, -Infinity)            = +0
   *   pow(abs(x) == 1, ±Infinity)           = NaN
   *   pow(abs(x) < 1, +Infinity)            = +0
   *   pow(abs(x) < 1, -Infinity)            = +Infinity
   *   pow(+Infinity, y > 0)                 = +Infinity
   *   pow(+Infinity, y < 0)                 = +0
   *   pow(-Infinity, odd integer > 0)       = -Infinity
   *   pow(-Infinity, even integer > 0)      = +Infinity
   *   pow(-Infinity, odd integer < 0)       = -0
   *   pow(-Infinity, even integer < 0)      = +0
   *   pow(+0, y > 0)                        = +0
   *   pow(+0, y < 0)                        = +Infinity
   *   pow(-0, odd integer > 0)              = -0
   *   pow(-0, even integer > 0)             = +0
   *   pow(-0, odd integer < 0)              = -Infinity
   *   pow(-0, even integer < 0)             = +Infinity
   *   pow(finite x < 0, finite non-integer) = NaN
   *
   * For non-integer or very large exponents pow(x, y) is calculated using
   *
   *   x^y = exp(y*ln(x))
   *
   * Assuming the first 15 rounding digits are each equally likely to be any digit 0-9, the
   * probability of an incorrectly rounded result
   * P([49]9{14} | [50]0{14}) = 2 * 0.2 * 10^-14 = 4e-15 = 1/2.5e+14
   * i.e. 1 in 250,000,000,000,000
   *
   * If a result is incorrectly rounded the maximum error will be 1 ulp (unit in last place).
   *
   * y {number|string|Decimal} The power to which to raise this Decimal.
   *
   */
  P.toPower = P.pow = function (y) {
    var e, k, pr, r, rm, sign, yIsInt,
      x = this,
      Ctor = x.constructor,
      yn = +(y = new Ctor(y));

    // Either ±Infinity, NaN or ±0?
    if (!x.d || !y.d || !x.d[0] || !y.d[0]) return  new Ctor(mathpow(+x, yn));

    x = new Ctor(x);

    if (x.eq(1)) return x;

    pr = Ctor.precision;
    rm = Ctor.rounding;

    if (y.eq(1)) return finalise(x, pr, rm);

    e = mathfloor(y.e / LOG_BASE);
    k = y.d.length - 1;
    yIsInt = e >= k;
    sign = x.s;

    if (!yIsInt) {
      if (sign < 0) return new Ctor(NaN);

    // If y is a small integer use the 'exponentiation by squaring' algorithm.
    } else if ((k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
      r = intPow(Ctor, x, k, pr);
      return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
    }

    // Result is negative if x is negative and the last digit of integer y is odd.
    sign = sign < 0 && y.d[Math.max(e, k)] & 1 ? -1 : 1;

    // Estimate result exponent.
    // x^y = 10^e,  where e = y * log10(x)
    // log10(x) = log10(x_significand) + x_exponent
    // log10(x_significand) = ln(x_significand) / ln(10)
    k = mathpow(+x, yn);
    e = k == 0 || !isFinite(k)
      ? mathfloor(yn * (Math.log('0.' + digitsToString(x.d)) / Math.LN10 + x.e + 1))
      : new Ctor(k + '').e;

    // Estimate may be incorrect e.g. x: 0.999999999999999999, y: 2.29, e: 0, r.e: -1.

    // Overflow/underflow?
    if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? sign / 0 : 0);

    external = false;
    Ctor.rounding = x.s = 1;

    // Estimate the extra guard digits needed to ensure five correct rounding digits from
    // naturalLogarithm(x). Example of failure without these extra digits (precision: 10):
    // new Decimal(2.32456).pow('2087987436534566.46411')
    // should be 1.162377823e+764914905173815, but is 1.162355823e+764914905173815
    k = Math.min(12, (e + '').length);

    // r = x^y = exp(y*ln(x))
    r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);

    // Truncate to the required precision plus five rounding digits.
    r = finalise(r, pr + 5, 1);

    // If the rounding digits are [49]9999 or [50]0000 increase the precision by 10 and recalculate
    // the result.
    if (checkRoundingDigits(r.d, pr, rm)) {
      e = pr + 10;

      // Truncate to the increased precision plus five rounding digits.
      r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);

      // Check for 14 nines from the 2nd rounding digit (the first rounding digit may be 4 or 9).
      if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
        r = finalise(r, pr + 1, 0);
      }
    }

    r.s = sign;
    external = true;
    Ctor.rounding = rm;

    return finalise(r, pr, rm);
  };


  /*
   * Return a string representing the value of this Decimal rounded to `sd` significant digits
   * using rounding mode `rounding`.
   *
   * Return exponential notation if `sd` is less than the number of digits necessary to represent
   * the integer part of the value in normal notation.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */
  P.toPrecision = function (sd, rm) {
    var str,
      x = this,
      Ctor = x.constructor;

    if (sd === void 0) {
      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
    } else {
      checkInt32(sd, 1, MAX_DIGITS);

      if (rm === void 0) rm = Ctor.rounding;
      else checkInt32(rm, 0, 8);

      x = finalise(new Ctor(x), sd, rm);
      str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
    }

    return x.isNeg() && !x.isZero() ? '-' + str : str;
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `sd`
   * significant digits using rounding mode `rm`, or to `precision` and `rounding` respectively if
   * omitted.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * 'toSD() digits out of range: {sd}'
   * 'toSD() digits not an integer: {sd}'
   * 'toSD() rounding mode not an integer: {rm}'
   * 'toSD() rounding mode out of range: {rm}'
   *
   */
  P.toSignificantDigits = P.toSD = function (sd, rm) {
    var x = this,
      Ctor = x.constructor;

    if (sd === void 0) {
      sd = Ctor.precision;
      rm = Ctor.rounding;
    } else {
      checkInt32(sd, 1, MAX_DIGITS);

      if (rm === void 0) rm = Ctor.rounding;
      else checkInt32(rm, 0, 8);
    }

    return finalise(new Ctor(x), sd, rm);
  };


  /*
   * Return a string representing the value of this Decimal.
   *
   * Return exponential notation if this Decimal has a positive exponent equal to or greater than
   * `toExpPos`, or a negative exponent equal to or less than `toExpNeg`.
   *
   */
  P.toString = function () {
    var x = this,
      Ctor = x.constructor,
      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);

    return x.isNeg() && !x.isZero() ? '-' + str : str;
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal truncated to a whole number.
   *
   */
  P.truncated = P.trunc = function () {
    return finalise(new this.constructor(this), this.e + 1, 1);
  };


  /*
   * Return a string representing the value of this Decimal.
   * Unlike `toString`, negative zero will include the minus sign.
   *
   */
  P.valueOf = function () {
    var x = this,
      Ctor = x.constructor,
      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);

    return x.isNeg() ? '-' + str : str;
  };


  /*
  // Add aliases to match BigDecimal method names.
  // P.add = P.plus;
  P.subtract = P.minus;
  P.multiply = P.times;
  P.divide = P.div;
  P.remainder = P.mod;
  P.compareTo = P.cmp;
  P.negate = P.neg;
   */


  // Helper functions for Decimal.prototype (P) and/or Decimal methods, and their callers.


  /*
   *  digitsToString           P.cubeRoot, P.logarithm, P.squareRoot, P.toFraction, P.toJSON,
   *                           P.toPower, finiteToString, naturalExponential, naturalLogarithm
   *  checkInt32               P.toDecimalPlaces, P.toExponential, P.toFixed, P.toNearest,
   *                           P.toPrecision, P.toSignificantDigits, toStringBinary, random
   *  checkRoundingDigits      P.logarithm, P.toPower, naturalExponential, naturalLogarithm
   *  convertBase              P.toJSON, toStringBinary, fromJSON, parseOther
   *  cos                      P.cos
   *  divide                   P.atanh, P.cubeRoot, P.dividedBy, P.dividedToIntegerBy,
   *                           P.logarithm, P.modulo, P.squareRoot, P.tan, P.tanh, P.toFraction,
   *                           P.toNearest, toStringBinary, naturalExponential, naturalLogarithm,
   *                           taylorSeries, atan2, parseOther
   *  finalise                 P.absoluteValue, P.atan, P.atanh, P.ceil, P.cos, P.cosh,
   *                           P.cubeRoot, P.dividedToIntegerBy, P.floor, P.logarithm, P.minus,
   *                           P.modulo, P.negated, P.plus, P.round, P.sin, P.sinh, P.squareRoot,
   *                           P.tan, P.times, P.toDecimalPlaces, P.toExponential, P.toFixed,
   *                           P.toNearest, P.toPower, P.toPrecision, P.toSignificantDigits,
   *                           P.truncated, divide, getLn10, getPi, naturalExponential,
   *                           naturalLogarithm, ceil, floor, round, trunc
   *  finiteToString           P.toExponential, P.toFixed, P.toPrecision, P.toString, P.valueOf,
   *                           toStringBinary
   *  getBase10Exponent        P.minus, P.plus, P.times, parseOther
   *  getLn10                  P.logarithm, naturalLogarithm
   *  getPi                    P.acos, P.asin, P.atan, toLessThanHalfPi, atan2
   *  getPrecision             P.precision, P.toFraction
   *  getZeroString            digitsToString, finiteToString
   *  intPow                   P.toPower, parseOther
   *  isOdd                    toLessThanHalfPi
   *  maxOrMin                 max, min
   *  naturalExponential       P.naturalExponential, P.toPower
   *  naturalLogarithm         P.acosh, P.asinh, P.atanh, P.logarithm, P.naturalLogarithm,
   *                           P.toPower, naturalExponential
   *  nonFiniteToString        finiteToString, toStringBinary
   *  parseDecimal             Decimal
   *  parseOther               Decimal
   *  sin                      P.sin
   *  taylorSeries             P.cosh, P.sinh, cos, sin
   *  toLessThanHalfPi         P.cos, P.sin
   *  toStringBinary           P.toBinary, P.toHexadecimal, P.toOctal
   *  truncate                 intPow
   *
   *  Throws:                  P.logarithm, P.precision, P.toFraction, checkInt32, getLn10, getPi,
   *                           naturalLogarithm, config, fromJSON, parseOther, random, Decimal           *
   */


  function digitsToString(d) {
    var i, k, ws,
      indexOfLastWord = d.length - 1,
      str = '',
      w = d[0];

    if (indexOfLastWord > 0) {
      str += w;
      for (i = 1; i < indexOfLastWord; i++) {
        ws = d[i] + '';
        k = LOG_BASE - ws.length;
        if (k) str += getZeroString(k);
        str += ws;
      }

      w = d[i];
      ws = w + '';
      k = LOG_BASE - ws.length;
      if (k) str += getZeroString(k);
    } else if (w === 0) {
      return '0';
    }

    // Remove trailing zeros of last w.
    for (; w % 10 === 0;) w /= 10;

    return str + w;
  }


  function checkInt32(i, min, max) {
    if (i !== ~~i || i < min || i > max) {
      throw Error(invalidArgument + i);
    }
  }


  /*
   * Check 5 rounding digits if `repeating` is null, 4 otherwise.
   * `repeating == null` if caller is `log` or `pow`,
   * `repeating != null` if caller is `naturalLogarithm` or `naturalExponential`.
   */
  function checkRoundingDigits(d, i, rm, repeating) {
    var di, k, r, rd;

    // Get the length of the first word of the array d.
    for (k = d[0]; k >= 10; k /= 10) --i;

    // Is the rounding digit in the first word of d?
    if (--i < 0) {
      i += LOG_BASE;
      di = 0;
    } else {
      di = Math.ceil((i + 1) / LOG_BASE);
      i %= LOG_BASE;
    }

    // i is the index (0 - 6) of the rounding digit.
    // E.g. if within the word 3487563 the first rounding digit is 5,
    // then i = 4, k = 1000, rd = 3487563 % 1000 = 563
    k = mathpow(10, LOG_BASE - i);
    rd = d[di] % k | 0;

    if (repeating == null) {
      if (i < 3) {
        if (i == 0) rd = rd / 100 | 0;
        else if (i == 1) rd = rd / 10 | 0;
        r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 50000 || rd == 0;
      } else {
        r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) &&
          (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 ||
            (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
      }
    } else {
      if (i < 4) {
        if (i == 0) rd = rd / 1000 | 0;
        else if (i == 1) rd = rd / 100 | 0;
        else if (i == 2) rd = rd / 10 | 0;
        r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
      } else {
        r = ((repeating || rm < 4) && rd + 1 == k ||
        (!repeating && rm > 3) && rd + 1 == k / 2) &&
          (d[di + 1] / k / 1000 | 0) == mathpow(10, i - 3) - 1;
      }
    }

    return r;
  }


  // Convert string of `baseIn` to an array of numbers of `baseOut`.
  // Eg. convertBase('255', 10, 16) returns [15, 15].
  // Eg. convertBase('ff', 16, 10) returns [2, 5, 5].
  function convertBase(str, baseIn, baseOut) {
    var j,
      arr = [0],
      arrL,
      i = 0,
      strL = str.length;

    for (; i < strL;) {
      for (arrL = arr.length; arrL--;) arr[arrL] *= baseIn;
      arr[0] += NUMERALS.indexOf(str.charAt(i++));
      for (j = 0; j < arr.length; j++) {
        if (arr[j] > baseOut - 1) {
          if (arr[j + 1] === void 0) arr[j + 1] = 0;
          arr[j + 1] += arr[j] / baseOut | 0;
          arr[j] %= baseOut;
        }
      }
    }

    return arr.reverse();
  }


  /*
   * cos(x) = 1 - x^2/2! + x^4/4! - ...
   * |x| < pi/2
   *
   */
  function cosine(Ctor, x) {
    var k, y,
      len = x.d.length;

    // Argument reduction: cos(4x) = 8*(cos^4(x) - cos^2(x)) + 1
    // i.e. cos(x) = 8*(cos^4(x/4) - cos^2(x/4)) + 1

    // Estimate the optimum number of times to use the argument reduction.
    if (len < 32) {
      k = Math.ceil(len / 3);
      y = Math.pow(4, -k).toString();
    } else {
      k = 16;
      y = '2.3283064365386962890625e-10';
    }

    Ctor.precision += k;

    x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));

    // Reverse argument reduction
    for (var i = k; i--;) {
      var cos2x = x.times(x);
      x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
    }

    Ctor.precision -= k;

    return x;
  }


  /*
   * Perform division in the specified base.
   */
  var divide = (function () {

    // Assumes non-zero x and k, and hence non-zero result.
    function multiplyInteger(x, k, base) {
      var temp,
        carry = 0,
        i = x.length;

      for (x = x.slice(); i--;) {
        temp = x[i] * k + carry;
        x[i] = temp % base | 0;
        carry = temp / base | 0;
      }

      if (carry) x.unshift(carry);

      return x;
    }

    function compare(a, b, aL, bL) {
      var i, r;

      if (aL != bL) {
        r = aL > bL ? 1 : -1;
      } else {
        for (i = r = 0; i < aL; i++) {
          if (a[i] != b[i]) {
            r = a[i] > b[i] ? 1 : -1;
            break;
          }
        }
      }

      return r;
    }

    function subtract(a, b, aL, base) {
      var i = 0;

      // Subtract b from a.
      for (; aL--;) {
        a[aL] -= i;
        i = a[aL] < b[aL] ? 1 : 0;
        a[aL] = i * base + a[aL] - b[aL];
      }

      // Remove leading zeros.
      for (; !a[0] && a.length > 1;) a.shift();
    }

    return function (x, y, pr, rm, dp, base) {
      var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0,
        yL, yz,
        Ctor = x.constructor,
        sign = x.s == y.s ? 1 : -1,
        xd = x.d,
        yd = y.d;

      // Either NaN, Infinity or 0?
      if (!xd || !xd[0] || !yd || !yd[0]) {

        return new Ctor(// Return NaN if either NaN, or both Infinity or 0.
          !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN :

          // Return ±0 if x is 0 or y is ±Infinity, or return ±Infinity as y is 0.
          xd && xd[0] == 0 || !yd ? sign * 0 : sign / 0);
      }

      if (base) {
        logBase = 1;
        e = x.e - y.e;
      } else {
        base = BASE;
        logBase = LOG_BASE;
        e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
      }

      yL = yd.length;
      xL = xd.length;
      q = new Ctor(sign);
      qd = q.d = [];

      // Result exponent may be one less than e.
      // The digit array of a Decimal from toStringBinary may have trailing zeros.
      for (i = 0; yd[i] == (xd[i] || 0); i++);

      if (yd[i] > (xd[i] || 0)) e--;

      if (pr == null) {
        sd = pr = Ctor.precision;
        rm = Ctor.rounding;
      } else if (dp) {
        sd = pr + (x.e - y.e) + 1;
      } else {
        sd = pr;
      }

      if (sd < 0) {
        qd.push(1);
        more = true;
      } else {

        // Convert precision in number of base 10 digits to base 1e7 digits.
        sd = sd / logBase + 2 | 0;
        i = 0;

        // divisor < 1e7
        if (yL == 1) {
          k = 0;
          yd = yd[0];
          sd++;

          // k is the carry.
          for (; (i < xL || k) && sd--; i++) {
            t = k * base + (xd[i] || 0);
            qd[i] = t / yd | 0;
            k = t % yd | 0;
          }

          more = k || i < xL;

        // divisor >= 1e7
        } else {

          // Normalise xd and yd so highest order digit of yd is >= base/2
          k = base / (yd[0] + 1) | 0;

          if (k > 1) {
            yd = multiplyInteger(yd, k, base);
            xd = multiplyInteger(xd, k, base);
            yL = yd.length;
            xL = xd.length;
          }

          xi = yL;
          rem = xd.slice(0, yL);
          remL = rem.length;

          // Add zeros to make remainder as long as divisor.
          for (; remL < yL;) rem[remL++] = 0;

          yz = yd.slice();
          yz.unshift(0);
          yd0 = yd[0];

          if (yd[1] >= base / 2) ++yd0;

          do {
            k = 0;

            // Compare divisor and remainder.
            cmp = compare(yd, rem, yL, remL);

            // If divisor < remainder.
            if (cmp < 0) {

              // Calculate trial digit, k.
              rem0 = rem[0];
              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

              // k will be how many times the divisor goes into the current remainder.
              k = rem0 / yd0 | 0;

              //  Algorithm:
              //  1. product = divisor * trial digit (k)
              //  2. if product > remainder: product -= divisor, k--
              //  3. remainder -= product
              //  4. if product was < remainder at 2:
              //    5. compare new remainder and divisor
              //    6. If remainder > divisor: remainder -= divisor, k++

              if (k > 1) {
                if (k >= base) k = base - 1;

                // product = divisor * trial digit.
                prod = multiplyInteger(yd, k, base);
                prodL = prod.length;
                remL = rem.length;

                // Compare product and remainder.
                cmp = compare(prod, rem, prodL, remL);

                // product > remainder.
                if (cmp == 1) {
                  k--;

                  // Subtract divisor from product.
                  subtract(prod, yL < prodL ? yz : yd, prodL, base);
                }
              } else {

                // cmp is -1.
                // If k is 0, there is no need to compare yd and rem again below, so change cmp to 1
                // to avoid it. If k is 1 there is a need to compare yd and rem again below.
                if (k == 0) cmp = k = 1;
                prod = yd.slice();
              }

              prodL = prod.length;
              if (prodL < remL) prod.unshift(0);

              // Subtract product from remainder.
              subtract(rem, prod, remL, base);

              // If product was < previous remainder.
              if (cmp == -1) {
                remL = rem.length;

                // Compare divisor and new remainder.
                cmp = compare(yd, rem, yL, remL);

                // If divisor < new remainder, subtract divisor from remainder.
                if (cmp < 1) {
                  k++;

                  // Subtract divisor from remainder.
                  subtract(rem, yL < remL ? yz : yd, remL, base);
                }
              }

              remL = rem.length;
            } else if (cmp === 0) {
              k++;
              rem = [0];
            }    // if cmp === 1, k will be 0

            // Add the next digit, k, to the result array.
            qd[i++] = k;

            // Update the remainder.
            if (cmp && rem[0]) {
              rem[remL++] = xd[xi] || 0;
            } else {
              rem = [xd[xi]];
              remL = 1;
            }

          } while ((xi++ < xL || rem[0] !== void 0) && sd--);

          more = rem[0] !== void 0;
        }

        // Leading zero?
        if (!qd[0]) qd.shift();
      }

      // logBase is 1 when divide is being used for base conversion.
      if (logBase == 1) {
        q.e = e;
        inexact = more;
      } else {

        // To calculate q.e, first get the number of digits of qd[0].
        for (i = 1, k = qd[0]; k >= 10; k /= 10) i++;
        q.e = i + e * logBase - 1;

        finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
      }

      return q;
    };
  })();


  /*
   * Round `x` to `sd` significant digits using rounding mode `rm`.
   * Check for over/under-flow.
   */
   function finalise(x, sd, rm, isTruncated) {
    var digits, i, j, k, rd, roundUp, w, xd, xdi,
      Ctor = x.constructor;

    // Don't round if sd is null or undefined.
    out: if (sd != null) {
      xd = x.d;

      // Infinity/NaN.
      if (!xd) return x;

      // rd: the rounding digit, i.e. the digit after the digit that may be rounded up.
      // w: the word of xd containing rd, a base 1e7 number.
      // xdi: the index of w within xd.
      // digits: the number of digits of w.
      // i: what would be the index of rd within w if all the numbers were 7 digits long (i.e. if
      // they had leading zeros)
      // j: if > 0, the actual index of rd within w (if < 0, rd is a leading zero).

      // Get the length of the first word of the digits array xd.
      for (digits = 1, k = xd[0]; k >= 10; k /= 10) digits++;
      i = sd - digits;

      // Is the rounding digit in the first word of xd?
      if (i < 0) {
        i += LOG_BASE;
        j = sd;
        w = xd[xdi = 0];

        // Get the rounding digit at index j of w.
        rd = w / mathpow(10, digits - j - 1) % 10 | 0;
      } else {
        xdi = Math.ceil((i + 1) / LOG_BASE);
        k = xd.length;
        if (xdi >= k) {
          if (isTruncated) {

            // Needed by `naturalExponential`, `naturalLogarithm` and `squareRoot`.
            for (; k++ <= xdi;) xd.push(0);
            w = rd = 0;
            digits = 1;
            i %= LOG_BASE;
            j = i - LOG_BASE + 1;
          } else {
            break out;
          }
        } else {
          w = k = xd[xdi];

          // Get the number of digits of w.
          for (digits = 1; k >= 10; k /= 10) digits++;

          // Get the index of rd within w.
          i %= LOG_BASE;

          // Get the index of rd within w, adjusted for leading zeros.
          // The number of leading zeros of w is given by LOG_BASE - digits.
          j = i - LOG_BASE + digits;

          // Get the rounding digit at index j of w.
          rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;
        }
      }

      // Are there any non-zero digits after the rounding digit?
      isTruncated = isTruncated || sd < 0 ||
        xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));

      // The expression `w % mathpow(10, digits - j - 1)` returns all the digits of w to the right
      // of the digit at (left-to-right) index j, e.g. if w is 908714 and j is 2, the expression
      // will give 714.

      roundUp = rm < 4
        ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
        : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 &&

          // Check whether the digit to the left of the rounding digit is odd.
          ((i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10) & 1 ||
            rm == (x.s < 0 ? 8 : 7));

      if (sd < 1 || !xd[0]) {
        xd.length = 0;
        if (roundUp) {

          // Convert sd to decimal places.
          sd -= x.e + 1;

          // 1, 0.1, 0.01, 0.001, 0.0001 etc.
          xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
          x.e = -sd || 0;
        } else {

          // Zero.
          xd[0] = x.e = 0;
        }

        return x;
      }

      // Remove excess digits.
      if (i == 0) {
        xd.length = xdi;
        k = 1;
        xdi--;
      } else {
        xd.length = xdi + 1;
        k = mathpow(10, LOG_BASE - i);

        // E.g. 56700 becomes 56000 if 7 is the rounding digit.
        // j > 0 means i > number of leading zeros of w.
        xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;
      }

      if (roundUp) {
        for (;;) {

          // Is the digit to be rounded up in the first word of xd?
          if (xdi == 0) {

            // i will be the length of xd[0] before k is added.
            for (i = 1, j = xd[0]; j >= 10; j /= 10) i++;
            j = xd[0] += k;
            for (k = 1; j >= 10; j /= 10) k++;

            // if i != k the length has increased.
            if (i != k) {
              x.e++;
              if (xd[0] == BASE) xd[0] = 1;
            }

            break;
          } else {
            xd[xdi] += k;
            if (xd[xdi] != BASE) break;
            xd[xdi--] = 0;
            k = 1;
          }
        }
      }

      // Remove trailing zeros.
      for (i = xd.length; xd[--i] === 0;) xd.pop();
    }

    if (external) {

      // Overflow?
      if (x.e > Ctor.maxE) {

        // Infinity.
        x.d = null;
        x.e = NaN;

      // Underflow?
      } else if (x.e < Ctor.minE) {

        // Zero.
        x.e = 0;
        x.d = [0];
        // Ctor.underflow = true;
      } // else Ctor.underflow = false;
    }

    return x;
  }


  function finiteToString(x, isExp, sd) {
    if (!x.isFinite()) return nonFiniteToString(x);
    var k,
      e = x.e,
      str = digitsToString(x.d),
      len = str.length;

    if (isExp) {
      if (sd && (k = sd - len) > 0) {
        str = str.charAt(0) + '.' + str.slice(1) + getZeroString(k);
      } else if (len > 1) {
        str = str.charAt(0) + '.' + str.slice(1);
      }

      str = str + (x.e < 0 ? 'e' : 'e+') + x.e;
    } else if (e < 0) {
      str = '0.' + getZeroString(-e - 1) + str;
      if (sd && (k = sd - len) > 0) str += getZeroString(k);
    } else if (e >= len) {
      str += getZeroString(e + 1 - len);
      if (sd && (k = sd - e - 1) > 0) str = str + '.' + getZeroString(k);
    } else {
      if ((k = e + 1) < len) str = str.slice(0, k) + '.' + str.slice(k);
      if (sd && (k = sd - len) > 0) {
        if (e + 1 === len) str += '.';
        str += getZeroString(k);
      }
    }

    return str;
  }


  // Calculate the base 10 exponent from the base 1e7 exponent.
  function getBase10Exponent(digits, e) {

    // First get the number of digits of the first word of the digits array.
    for (var i = 1, w = digits[0]; w >= 10; w /= 10) i++;
    return i + e * LOG_BASE - 1;
  }


   function getLn10(Ctor, sd, pr) {
    if (sd > LN10_PRECISION) {

      // Reset global state in case the exception is caught.
      external = true;
      if (pr) Ctor.precision = pr;
      throw Error(precisionLimitExceeded);
    }
    return finalise(new Ctor(LN10), sd, 1, true);
  }


  function getPi(Ctor, sd, rm) {
    if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);
    return finalise(new Ctor(PI), sd, rm, true);
  }


  function getPrecision(digits) {
    var w = digits.length - 1,
      len = w * LOG_BASE + 1;

    w = digits[w];

    // If non-zero...
    if (w) {

      // Subtract the number of trailing zeros of the last word.
      for (; w % 10 == 0; w /= 10) len--;

      // Add the number of digits of the first word.
      for (w = digits[0]; w >= 10; w /= 10) len++;
    }

    return len;
  }


  function getZeroString(k) {
    var zs = '';
    for (; k--;) zs += '0';
    return zs;
  }


  /*
   * Return a new Decimal whose value is the value of Decimal `x` to the power `n`, where `n` is an
   * integer of type number.
   *
   * Implements 'exponentiation by squaring'. Called by `pow` and `parseOther`.
   *
   */
  function intPow(Ctor, x, n, pr) {
    var isTruncated,
      r = new Ctor(1),

      // Max n of 9007199254740991 takes 53 loop iterations.
      // Maximum digits array length; leaves [28, 34] guard digits.
      k = Math.ceil(pr / LOG_BASE + 4);

    external = false;

    for (;;) {
      if (n % 2) {
        r = r.times(x);
        if (truncate(r.d, k)) isTruncated = true;
      }

      n = mathfloor(n / 2);
      if (n === 0) {

        // To ensure correct rounding when r.d is truncated, increment the last word if it is zero.
        n = r.d.length - 1;
        if (isTruncated && r.d[n] === 0) ++r.d[n];
        break;
      }

      x = x.times(x);
      truncate(x.d, k);
    }

    external = true;

    return r;
  }


  function isOdd(n) {
    return n.d[n.d.length - 1] & 1;
  }


  /*
   * Handle `max` and `min`. `ltgt` is 'lt' or 'gt'.
   */
  function maxOrMin(Ctor, args, ltgt) {
    var y,
      x = new Ctor(args[0]),
      i = 0;

    for (; ++i < args.length;) {
      y = new Ctor(args[i]);
      if (!y.s) {
        x = y;
        break;
      } else if (x[ltgt](y)) {
        x = y;
      }
    }

    return x;
  }


  /*
   * Return a new Decimal whose value is the natural exponential of `x` rounded to `sd` significant
   * digits.
   *
   * Taylor/Maclaurin series.
   *
   * exp(x) = x^0/0! + x^1/1! + x^2/2! + x^3/3! + ...
   *
   * Argument reduction:
   *   Repeat x = x / 32, k += 5, until |x| < 0.1
   *   exp(x) = exp(x / 2^k)^(2^k)
   *
   * Previously, the argument was initially reduced by
   * exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)
   * to first put r in the range [0, ln10], before dividing by 32 until |x| < 0.1, but this was
   * found to be slower than just dividing repeatedly by 32 as above.
   *
   * Max integer argument: exp('20723265836946413') = 6.3e+9000000000000000
   * Min integer argument: exp('-20723265836946411') = 1.2e-9000000000000000
   * (Math object integer min/max: Math.exp(709) = 8.2e+307, Math.exp(-745) = 5e-324)
   *
   *  exp(Infinity)  = Infinity
   *  exp(-Infinity) = 0
   *  exp(NaN)       = NaN
   *  exp(±0)        = 1
   *
   *  exp(x) is non-terminating for any finite, non-zero x.
   *
   *  The result will always be correctly rounded.
   *
   */
  function naturalExponential(x, sd) {
    var denominator, guard, j, pow, sum, t, wpr,
      rep = 0,
      i = 0,
      k = 0,
      Ctor = x.constructor,
      rm = Ctor.rounding,
      pr = Ctor.precision;

    // 0/NaN/Infinity?
    if (!x.d || !x.d[0] || x.e > 17) {

      return new Ctor(x.d
        ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0
        : x.s ? x.s < 0 ? 0 : x : 0 / 0);
    }

    if (sd == null) {
      external = false;
      wpr = pr;
    } else {
      wpr = sd;
    }

    t = new Ctor(0.03125);

    // while abs(x) >= 0.1
    while (x.e > -2) {

      // x = x / 2^5
      x = x.times(t);
      k += 5;
    }

    // Use 2 * log10(2^k) + 5 (empirically derived) to estimate the increase in precision
    // necessary to ensure the first 4 rounding digits are correct.
    guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
    wpr += guard;
    denominator = pow = sum = new Ctor(1);
    Ctor.precision = wpr;

    for (;;) {
      pow = finalise(pow.times(x), wpr, 1);
      denominator = denominator.times(++i);
      t = sum.plus(divide(pow, denominator, wpr, 1));

      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
        j = k;
        while (j--) sum = finalise(sum.times(sum), wpr, 1);

        // Check to see if the first 4 rounding digits are [49]999.
        // If so, repeat the summation with a higher precision, otherwise
        // e.g. with precision: 18, rounding: 1
        // exp(18.404272462595034083567793919843761) = 98372560.1229999999 (should be 98372560.123)
        // `wpr - guard` is the index of first rounding digit.
        if (sd == null) {

          if (rep < 3 && checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {
            Ctor.precision = wpr += 10;
            denominator = pow = t = new Ctor(1);
            i = 0;
            rep++;
          } else {
            return finalise(sum, Ctor.precision = pr, rm, external = true);
          }
        } else {
          Ctor.precision = pr;
          return sum;
        }
      }

      sum = t;
    }
  }


  /*
   * Return a new Decimal whose value is the natural logarithm of `x` rounded to `sd` significant
   * digits.
   *
   *  ln(-n)        = NaN
   *  ln(0)         = -Infinity
   *  ln(-0)        = -Infinity
   *  ln(1)         = 0
   *  ln(Infinity)  = Infinity
   *  ln(-Infinity) = NaN
   *  ln(NaN)       = NaN
   *
   *  ln(n) (n != 1) is non-terminating.
   *
   */
  function naturalLogarithm(y, sd) {
    var c, c0, denominator, e, numerator, rep, sum, t, wpr, x1, x2,
      n = 1,
      guard = 10,
      x = y,
      xd = x.d,
      Ctor = x.constructor,
      rm = Ctor.rounding,
      pr = Ctor.precision;

    // Is x negative or Infinity, NaN, 0 or 1?
    if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
      return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
    }

    if (sd == null) {
      external = false;
      wpr = pr;
    } else {
      wpr = sd;
    }

    Ctor.precision = wpr += guard;
    c = digitsToString(xd);
    c0 = c.charAt(0);

    if (Math.abs(e = x.e) < 1.5e15) {

      // Argument reduction.
      // The series converges faster the closer the argument is to 1, so using
      // ln(a^b) = b * ln(a),   ln(a) = ln(a^b) / b
      // multiply the argument by itself until the leading digits of the significand are 7, 8, 9,
      // 10, 11, 12 or 13, recording the number of multiplications so the sum of the series can
      // later be divided by this number, then separate out the power of 10 using
      // ln(a*10^b) = ln(a) + b*ln(10).

      // max n is 21 (gives 0.9, 1.0 or 1.1) (9e15 / 21 = 4.2e14).
      //while (c0 < 9 && c0 != 1 || c0 == 1 && c.charAt(1) > 1) {
      // max n is 6 (gives 0.7 - 1.3)
      while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
        x = x.times(y);
        c = digitsToString(x.d);
        c0 = c.charAt(0);
        n++;
      }

      e = x.e;

      if (c0 > 1) {
        x = new Ctor('0.' + c);
        e++;
      } else {
        x = new Ctor(c0 + '.' + c.slice(1));
      }
    } else {

      // The argument reduction method above may result in overflow if the argument y is a massive
      // number with exponent >= 1500000000000000 (9e15 / 6 = 1.5e15), so instead recall this
      // function using ln(x*10^e) = ln(x) + e*ln(10).
      t = getLn10(Ctor, wpr + 2, pr).times(e + '');
      x = naturalLogarithm(new Ctor(c0 + '.' + c.slice(1)), wpr - guard).plus(t);
      Ctor.precision = pr;

      return sd == null ? finalise(x, pr, rm, external = true) : x;
    }

    // x1 is x reduced to a value near 1.
    x1 = x;

    // Taylor series.
    // ln(y) = ln((1 + x)/(1 - x)) = 2(x + x^3/3 + x^5/5 + x^7/7 + ...)
    // where x = (y - 1)/(y + 1)    (|x| < 1)
    sum = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);
    x2 = finalise(x.times(x), wpr, 1);
    denominator = 3;

    for (;;) {
      numerator = finalise(numerator.times(x2), wpr, 1);
      t = sum.plus(divide(numerator, new Ctor(denominator), wpr, 1));

      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
        sum = sum.times(2);

        // Reverse the argument reduction. Check that e is not 0 because, besides preventing an
        // unnecessary calculation, -0 + 0 = +0 and to ensure correct rounding -0 needs to stay -0.
        if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ''));
        sum = divide(sum, new Ctor(n), wpr, 1);

        // Is rm > 3 and the first 4 rounding digits 4999, or rm < 4 (or the summation has
        // been repeated previously) and the first 4 rounding digits 9999?
        // If so, restart the summation with a higher precision, otherwise
        // e.g. with precision: 12, rounding: 1
        // ln(135520028.6126091714265381533) = 18.7246299999 when it should be 18.72463.
        // `wpr - guard` is the index of first rounding digit.
        if (sd == null) {
          if (checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {
            Ctor.precision = wpr += guard;
            t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);
            x2 = finalise(x.times(x), wpr, 1);
            denominator = rep = 1;
          } else {
            return finalise(sum, Ctor.precision = pr, rm, external = true);
          }
        } else {
          Ctor.precision = pr;
          return sum;
        }
      }

      sum = t;
      denominator += 2;
    }
  }


  // ±Infinity, NaN.
  function nonFiniteToString(x) {
    // Unsigned.
    return String(x.s * x.s / 0);
  }


  /*
   * Parse the value of a new Decimal `x` from string `str`.
   */
  function parseDecimal(x, str) {
    var e, i, len;

    // Decimal point?
    if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

    // Exponential form?
    if ((i = str.search(/e/i)) > 0) {

      // Determine exponent.
      if (e < 0) e = i;
      e += +str.slice(i + 1);
      str = str.substring(0, i);
    } else if (e < 0) {

      // Integer.
      e = str.length;
    }

    // Determine leading zeros.
    for (i = 0; str.charCodeAt(i) === 48; i++);

    // Determine trailing zeros.
    for (len = str.length; str.charCodeAt(len - 1) === 48; --len);
    str = str.slice(i, len);

    if (str) {
      len -= i;
      x.e = e = e - i - 1;
      x.d = [];

      // Transform base

      // e is the base 10 exponent.
      // i is where to slice str to get the first word of the digits array.
      i = (e + 1) % LOG_BASE;
      if (e < 0) i += LOG_BASE;

      if (i < len) {
        if (i) x.d.push(+str.slice(0, i));
        for (len -= LOG_BASE; i < len;) x.d.push(+str.slice(i, i += LOG_BASE));
        str = str.slice(i);
        i = LOG_BASE - str.length;
      } else {
        i -= len;
      }

      for (; i--;) str += '0';
      x.d.push(+str);

      if (external) {

        // Overflow?
        if (x.e > x.constructor.maxE) {

          // Infinity.
          x.d = null;
          x.e = NaN;

        // Underflow?
        } else if (x.e < x.constructor.minE) {

          // Zero.
          x.e = 0;
          x.d = [0];
          // x.constructor.underflow = true;
        } // else x.constructor.underflow = false;
      }
    } else {

      // Zero.
      x.e = 0;
      x.d = [0];
    }

    return x;
  }


  /*
   * Parse the value of a new Decimal `x` from a string `str`, which is not a decimal value.
   */
  function parseOther(x, str) {
    var base, Ctor, divisor, i, isFloat, len, p, xd, xe;

    if (str === 'Infinity' || str === 'NaN') {
      if (!+str) x.s = NaN;
      x.e = NaN;
      x.d = null;
      return x;
    }

    if (isHex.test(str))  {
      base = 16;
      str = str.toLowerCase();
    } else if (isBinary.test(str))  {
      base = 2;
    } else if (isOctal.test(str))  {
      base = 8;
    } else {
      throw Error(invalidArgument + str);
    }

    // Is there a binary exponent part?
    i = str.search(/p/i);

    if (i > 0) {
      p = +str.slice(i + 1);
      str = str.substring(2, i);
    } else {
      str = str.slice(2);
    }

    // Convert `str` as an integer then divide the result by `base` raised to a power such that the
    // fraction part will be restored.
    i = str.indexOf('.');
    isFloat = i >= 0;
    Ctor = x.constructor;

    if (isFloat) {
      str = str.replace('.', '');
      len = str.length;
      i = len - i;

      // log[10](16) = 1.2041... , log[10](88) = 1.9444....
      divisor = intPow(Ctor, new Ctor(base), i, i * 2);
    }

    xd = convertBase(str, base, BASE);
    xe = xd.length - 1;

    // Remove trailing zeros.
    for (i = xe; xd[i] === 0; --i) xd.pop();
    if (i < 0) return new Ctor(x.s * 0);
    x.e = getBase10Exponent(xd, xe);
    x.d = xd;
    external = false;

    // At what precision to perform the division to ensure exact conversion?
    // maxDecimalIntegerPartDigitCount = ceil(log[10](b) * otherBaseIntegerPartDigitCount)
    // log[10](2) = 0.30103, log[10](8) = 0.90309, log[10](16) = 1.20412
    // E.g. ceil(1.2 * 3) = 4, so up to 4 decimal digits are needed to represent 3 hex int digits.
    // maxDecimalFractionPartDigitCount = {Hex:4|Oct:3|Bin:1} * otherBaseFractionPartDigitCount
    // Therefore using 4 * the number of digits of str will always be enough.
    if (isFloat) x = divide(x, divisor, len * 4);

    // Multiply by the binary exponent part if present.
    if (p) x = x.times(Math.abs(p) < 54 ? Math.pow(2, p) : Decimal.pow(2, p));
    external = true;

    return x;
  }


  /*
   * sin(x) = x - x^3/3! + x^5/5! - ...
   * |x| < pi/2
   *
   */
  function sine(Ctor, x) {
    var k,
      len = x.d.length;

    if (len < 3) return taylorSeries(Ctor, 2, x, x);

    // Argument reduction: sin(5x) = 16*sin^5(x) - 20*sin^3(x) + 5*sin(x)
    // i.e. sin(x) = 16*sin^5(x/5) - 20*sin^3(x/5) + 5*sin(x/5)
    // and  sin(x) = sin(x/5)(5 + sin^2(x/5)(16sin^2(x/5) - 20))

    // Estimate the optimum number of times to use the argument reduction.
    k = 1.4 * Math.sqrt(len);
    k = k > 16 ? 16 : k | 0;

    // Max k before Math.pow precision loss is 22
    x = x.times(Math.pow(5, -k));
    x = taylorSeries(Ctor, 2, x, x);

    // Reverse argument reduction
    var sin2_x,
      d5 = new Ctor(5),
      d16 = new Ctor(16),
      d20 = new Ctor(20);
    for (; k--;) {
      sin2_x = x.times(x);
      x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
    }

    return x;
  }


  // Calculate Taylor series for `cos`, `cosh`, `sin` and `sinh`.
  function taylorSeries(Ctor, n, x, y, isHyperbolic) {
    var j, t, u, x2,
      i = 1,
      pr = Ctor.precision,
      k = Math.ceil(pr / LOG_BASE);

    external = false;
    x2 = x.times(x);
    u = new Ctor(y);

    for (;;) {
      t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);
      u = isHyperbolic ? y.plus(t) : y.minus(t);
      y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);
      t = u.plus(y);

      if (t.d[k] !== void 0) {
        for (j = k; t.d[j] === u.d[j] && j--;);
        if (j == -1) break;
      }

      j = u;
      u = y;
      y = t;
      t = j;
      i++;
    }

    external = true;
    t.d.length = k + 1;

    return t;
  }


  // Return the absolute value of `x` reduced to less than or equal to half pi.
  function toLessThanHalfPi(Ctor, x) {
    var t,
      isNeg = x.s < 0,
      pi = getPi(Ctor, Ctor.precision, 1),
      halfPi = pi.times(0.5);

    x = x.abs();

    if (x.lte(halfPi)) {
      quadrant = isNeg ? 4 : 1;
      return x;
    }

    t = x.divToInt(pi);

    if (t.isZero()) {
      quadrant = isNeg ? 3 : 2;
    } else {
      x = x.minus(t.times(pi));

      // 0 <= x < pi
      if (x.lte(halfPi)) {
        quadrant = isOdd(t) ? (isNeg ? 2 : 3) : (isNeg ? 4 : 1);
        return x;
      }

      quadrant = isOdd(t) ? (isNeg ? 1 : 4) : (isNeg ? 3 : 2);
    }

    return x.minus(pi).abs();
  }


  /*
   * Return the value of Decimal `x` as a string in base `baseOut`.
   *
   * If the optional `sd` argument is present include a binary exponent suffix.
   */
  function toStringBinary(x, baseOut, sd, rm) {
    var base, e, i, k, len, roundUp, str, xd, y,
      Ctor = x.constructor,
      isExp = sd !== void 0;

    if (isExp) {
      checkInt32(sd, 1, MAX_DIGITS);
      if (rm === void 0) rm = Ctor.rounding;
      else checkInt32(rm, 0, 8);
    } else {
      sd = Ctor.precision;
      rm = Ctor.rounding;
    }

    if (!x.isFinite()) {
      str = nonFiniteToString(x);
    } else {
      str = finiteToString(x);
      i = str.indexOf('.');

      // Use exponential notation according to `toExpPos` and `toExpNeg`? No, but if required:
      // maxBinaryExponent = floor((decimalExponent + 1) * log[2](10))
      // minBinaryExponent = floor(decimalExponent * log[2](10))
      // log[2](10) = 3.321928094887362347870319429489390175864

      if (isExp) {
        base = 2;
        if (baseOut == 16) {
          sd = sd * 4 - 3;
        } else if (baseOut == 8) {
          sd = sd * 3 - 2;
        }
      } else {
        base = baseOut;
      }

      // Convert the number as an integer then divide the result by its base raised to a power such
      // that the fraction part will be restored.

      // Non-integer.
      if (i >= 0) {
        str = str.replace('.', '');
        y = new Ctor(1);
        y.e = str.length - i;
        y.d = convertBase(finiteToString(y), 10, base);
        y.e = y.d.length;
      }

      xd = convertBase(str, 10, base);
      e = len = xd.length;

      // Remove trailing zeros.
      for (; xd[--len] == 0;) xd.pop();

      if (!xd[0]) {
        str = isExp ? '0p+0' : '0';
      } else {
        if (i < 0) {
          e--;
        } else {
          x = new Ctor(x);
          x.d = xd;
          x.e = e;
          x = divide(x, y, sd, rm, 0, base);
          xd = x.d;
          e = x.e;
          roundUp = inexact;
        }

        // The rounding digit, i.e. the digit after the digit that may be rounded up.
        i = xd[sd];
        k = base / 2;
        roundUp = roundUp || xd[sd + 1] !== void 0;

        roundUp = rm < 4
          ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2))
          : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 ||
            rm === (x.s < 0 ? 8 : 7));

        xd.length = sd;

        if (roundUp) {

          // Rounding up may mean the previous digit has to be rounded up and so on.
          for (; ++xd[--sd] > base - 1;) {
            xd[sd] = 0;
            if (!sd) {
              ++e;
              xd.unshift(1);
            }
          }
        }

        // Determine trailing zeros.
        for (len = xd.length; !xd[len - 1]; --len);

        // E.g. [4, 11, 15] becomes 4bf.
        for (i = 0, str = ''; i < len; i++) str += NUMERALS.charAt(xd[i]);

        // Add binary exponent suffix?
        if (isExp) {
          if (len > 1) {
            if (baseOut == 16 || baseOut == 8) {
              i = baseOut == 16 ? 4 : 3;
              for (--len; len % i; len++) str += '0';
              xd = convertBase(str, base, baseOut);
              for (len = xd.length; !xd[len - 1]; --len);

              // xd[0] will always be be 1
              for (i = 1, str = '1.'; i < len; i++) str += NUMERALS.charAt(xd[i]);
            } else {
              str = str.charAt(0) + '.' + str.slice(1);
            }
          }

          str =  str + (e < 0 ? 'p' : 'p+') + e;
        } else if (e < 0) {
          for (; ++e;) str = '0' + str;
          str = '0.' + str;
        } else {
          if (++e > len) for (e -= len; e-- ;) str += '0';
          else if (e < len) str = str.slice(0, e) + '.' + str.slice(e);
        }
      }

      str = (baseOut == 16 ? '0x' : baseOut == 2 ? '0b' : baseOut == 8 ? '0o' : '') + str;
    }

    return x.s < 0 ? '-' + str : str;
  }


  // Does not strip trailing zeros.
  function truncate(arr, len) {
    if (arr.length > len) {
      arr.length = len;
      return true;
    }
  }


  // Decimal methods


  /*
   *  abs
   *  acos
   *  acosh
   *  add
   *  asin
   *  asinh
   *  atan
   *  atanh
   *  atan2
   *  cbrt
   *  ceil
   *  clone
   *  config
   *  cos
   *  cosh
   *  div
   *  exp
   *  floor
   *  fromJSON
   *  hypot
   *  ln
   *  log
   *  log2
   *  log10
   *  max
   *  min
   *  mod
   *  mul
   *  pow
   *  random
   *  round
   *  sign
   *  sin
   *  sinh
   *  sqrt
   *  sub
   *  tan
   *  tanh
   *  trunc
   */


  /*
   * Return a new Decimal whose value is the absolute value of `x`.
   *
   * x {number|string|Decimal}
   *
   */
  function abs(x) {
    return new this(x).abs();
  }


  /*
   * Return a new Decimal whose value is the arccosine in radians of `x`.
   *
   * x {number|string|Decimal}
   *
   */
  function acos(x) {
    return new this(x).acos();
  }


  /*
   * Return a new Decimal whose value is the inverse of the hyperbolic cosine of `x`, rounded to
   * `precision` significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function acosh(x) {
    return new this(x).acosh();
  }


  /*
   * Return a new Decimal whose value is the sum of `x` and `y`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   * y {number|string|Decimal}
   *
   */
  function add(x, y) {
    return new this(x).plus(y);
  }


  /*
   * Return a new Decimal whose value is the arcsine in radians of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */
  function asin(x) {
    return new this(x).asin();
  }


  /*
   * Return a new Decimal whose value is the inverse of the hyperbolic sine of `x`, rounded to
   * `precision` significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function asinh(x) {
    return new this(x).asinh();
  }


  /*
   * Return a new Decimal whose value is the arctangent in radians of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */
  function atan(x) {
    return new this(x).atan();
  }


  /*
   * Return a new Decimal whose value is the inverse of the hyperbolic tangent of `x`, rounded to
   * `precision` significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function atanh(x) {
    return new this(x).atanh();
  }


  /*
   * Return a new Decimal whose value is the arctangent in radians of `y/x` in the range -pi to pi
   * (inclusive), rounded to `precision` significant digits using rounding mode `rounding`.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-pi, pi]
   *
   * y {number|string|Decimal} The y-coordinate.
   * x {number|string|Decimal} The x-coordinate.
   *
   * atan2(±0, -0)               = ±pi
   * atan2(±0, +0)               = ±0
   * atan2(±0, -x)               = ±pi for x > 0
   * atan2(±0, x)                = ±0 for x > 0
   * atan2(-y, ±0)               = -pi/2 for y > 0
   * atan2(y, ±0)                = pi/2 for y > 0
   * atan2(±y, -Infinity)        = ±pi for finite y > 0
   * atan2(±y, +Infinity)        = ±0 for finite y > 0
   * atan2(±Infinity, x)         = ±pi/2 for finite x
   * atan2(±Infinity, -Infinity) = ±3*pi/4
   * atan2(±Infinity, +Infinity) = ±pi/4
   * atan2(NaN, x) = NaN
   * atan2(y, NaN) = NaN
   *
   */
  function atan2(y, x) {
    y = new this(y);
    x = new this(x);
    var r,
      pr = this.precision,
      rm = this.rounding,
      wpr = pr + 4;

    // Either NaN
    if (!y.s || !x.s) {
      r = new this(NaN);

    // Both ±Infinity
    } else if (!y.d && !x.d) {
      r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
      r.s = y.s;

    // x is ±Infinity or y is ±0
    } else if (!x.d || y.isZero()) {
      r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
      r.s = y.s;

    // y is ±Infinity or x is ±0
    } else if (!y.d || x.isZero()) {
      r = getPi(this, wpr, 1).times(0.5);
      r.s = y.s;

    // Both non-zero and finite
    } else if (x.s < 0) {
      this.precision = wpr;
      this.rounding = 1;
      r = this.atan(divide(y, x, wpr, 1));
      x = getPi(this, wpr, 1);
      this.precision = pr;
      this.rounding = rm;
      r = y.s < 0 ? r.minus(x) : r.plus(x);
    } else {
      r = this.atan(divide(y, x, wpr, 1));
    }

    return r;
  }


  /*
   * Return a new Decimal whose value is the cube root of `x`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */
  function cbrt(x) {
    return new this(x).cbrt();
  }


  /*
   * Return a new Decimal whose value is `x` rounded to an integer using `ROUND_CEIL`.
   *
   * x {number|string|Decimal}
   *
   */
  function ceil(x) {
    return finalise(x = new this(x), x.e + 1, 2);
  }


  /*
   * Configure global settings for a Decimal constructor.
   *
   * `obj` is an object with one or more of the following properties,
   *
   *   precision  {number}
   *   rounding   {number}
   *   toExpNeg   {number}
   *   toExpPos   {number}
   *   maxE       {number}
   *   minE       {number}
   *   modulo     {number}
   *   crypto     {boolean|number|undefined}
   *
   * E.g. Decimal.config({ precision: 20, rounding: 4 })
   *
   */
  function config(obj) {
    if (!obj || typeof obj !== 'object') throw Error(decimalError + 'Object expected');
    var i, p, v,
      ps = [
        'precision', 1, MAX_DIGITS,
        'rounding', 0, 8,
        'toExpNeg', -EXP_LIMIT, 0,
        'toExpPos', 0, EXP_LIMIT,
        'maxE', 0, EXP_LIMIT,
        'minE', -EXP_LIMIT, 0,
        'modulo', 0, 9
      ];

    for (i = 0; i < ps.length; i += 3) {
      if ((v = obj[p = ps[i]]) !== void 0) {
        if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;
        else throw Error(invalidArgument + p + ': ' + v);
      }
    }

    if (obj.hasOwnProperty(p = 'crypto')) {
      if ((v = obj[p]) === void 0) {
        this[p] = v;
      } else if (v === true || v === false || v === 0 || v === 1) {
        this[p] = !!(v && cryptoObject &&
            (cryptoObject.getRandomValues || cryptoObject.randomBytes));
      } else {
        throw Error(invalidArgument + p + ': ' + v);
      }
    }

    return this;
  }


  /*
   * Return a new Decimal whose value is the cosine of `x`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function cos(x) {
    return new this(x).cos();
  }


  /*
   * Return a new Decimal whose value is the hyperbolic cosine of `x`, rounded to precision
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function cosh(x) {
    return new this(x).cosh();
  }


  /*
   * Create and return a Decimal constructor with the same configuration properties as this Decimal
   * constructor.
   *
   */
  function clone(obj) {
    var i, p, ps;

    /*
     * The Decimal constructor and exported function.
     * Return a new Decimal instance.
     *
     * v {number|string|Decimal} A numeric value.
     *
     */
    function Decimal(v) {
      var e, i, t,
        x = this;

      // Decimal called without new.
      if (!(x instanceof Decimal)) return new Decimal(v);

      // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor
      // which points to Object.
      x.constructor = Decimal;

      // Duplicate.
      if (v instanceof Decimal) {
        x.s = v.s;
        x.e = v.e;
        x.d = (v = v.d) ? v.slice() : v;
        return;
      }

      t = typeof v;

      if (t === 'number') {
        if (v === 0) {
          x.s = 1 / v < 0 ? -1 : 1;
          x.e = 0;
          x.d = [0];
          return;
        }

        if (v < 0) {
          v = -v;
          x.s = -1;
        } else {
          x.s = 1;
        }

        // Fast path for small integers.
        if (v === ~~v && v < 1e7) {
          for (e = 0, i = v; i >= 10; i /= 10) e++;
          x.e = e;
          x.d = [v];
          return;

        // Infinity, NaN.
        } else if (v * 0 !== 0) {
          if (!v) x.s = NaN;
          x.e = NaN;
          x.d = null;
          return;
        }

        return parseDecimal(x, v.toString());

      } else if (t !== 'string') {
        throw Error(invalidArgument + v);
      }

      // Minus sign?
      if (v.charCodeAt(0) === 45) {
        v = v.slice(1);
        x.s = -1;
      } else {
        x.s = 1;
      }

      return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
    }

    Decimal.prototype = P;

    Decimal.ROUND_UP = 0;
    Decimal.ROUND_DOWN = 1;
    Decimal.ROUND_CEIL = 2;
    Decimal.ROUND_FLOOR = 3;
    Decimal.ROUND_HALF_UP = 4;
    Decimal.ROUND_HALF_DOWN = 5;
    Decimal.ROUND_HALF_EVEN = 6;
    Decimal.ROUND_HALF_CEIL = 7;
    Decimal.ROUND_HALF_FLOOR = 8;
    Decimal.EUCLID = 9;

    Decimal.config = config;
    Decimal.clone = clone;

    Decimal.abs = abs;
    Decimal.acos = acos;
    Decimal.acosh = acosh;        // ES6
    Decimal.add = add;
    Decimal.asin = asin;
    Decimal.asinh = asinh;        // ES6
    Decimal.atan = atan;
    Decimal.atanh = atanh;        // ES6
    Decimal.atan2 = atan2;
    Decimal.cbrt = cbrt;          // ES6
    Decimal.ceil = ceil;
    Decimal.cos = cos;
    Decimal.cosh = cosh;          // ES6
    Decimal.div = div;
    Decimal.exp = exp;
    Decimal.floor = floor;
    Decimal.fromJSON = fromJSON;
    Decimal.hypot = hypot;        // ES6
    Decimal.ln = ln;
    Decimal.log = log;
    Decimal.log10 = log10;        // ES6
    Decimal.log2 = log2;          // ES6
    Decimal.max = max;
    Decimal.min = min;
    Decimal.mod = mod;
    Decimal.mul = mul;
    Decimal.pow = pow;
    Decimal.random = random;
    Decimal.round = round;
    Decimal.sign = sign;          // ES6
    Decimal.sin = sin;
    Decimal.sinh = sinh;          // ES6
    Decimal.sqrt = sqrt;
    Decimal.sub = sub;
    Decimal.tan = tan;
    Decimal.tanh = tanh;          // ES6
    Decimal.trunc = trunc;        // ES6

    if (obj === void 0) obj = {};
    if (obj) {
      ps = ['precision', 'rounding', 'toExpNeg', 'toExpPos', 'maxE', 'minE', 'modulo', 'crypto'];
      for (i = 0; i < ps.length;) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];
    }

    Decimal.config(obj);

    return Decimal;
  }


  /*
   * Return a new Decimal whose value is `x` divided by `y`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   * y {number|string|Decimal}
   *
   */
  function div(x, y) {
    return new this(x).div(y);
  }


  /*
   * Return a new Decimal whose value is the natural exponential of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} The power to which to raise the base of the natural log.
   *
   */
  function exp(x) {
    return new this(x).exp();
  }


  /*
   * Return a new Decimal whose value is `x` round to an integer using `ROUND_FLOOR`.
   *
   * x {number|string|Decimal}
   *
   */
  function floor(x) {
    return finalise(x = new this(x), x.e + 1, 3);
  }


  /*
   * Return a new Decimal from `str`, a string value created by `toJSON`.
   *
   * Base 88 alphabet:
   * 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!#$%()*+,-./:;=?@[]^_`{|}~
   *
   * If `str` is just one character:
   * 0-81  [[0, 40][-0, -40]]
   * 82    -Infinity
   * 83    +Infinity
   * 84    NaN
   *
   *   64 32 16  8  4  2  1
   *    1  0  1  0  1  1  1 = 87
   *
   */
  function fromJSON(str) {
    var e, isNeg, k, n;

    if (typeof str !== 'string' || !str) throw Error(invalidArgument + str);
    k = str.length;
    n = NUMERALS.indexOf(str.charAt(0));

    //  [0, 81] -> [[0, 40][-0, -40]]
    if (k === 1) {
      return new this(n > 81 ? [-1 / 0, 1 / 0, 0 / 0][n - 82] : n > 40 ? -(n - 41) : n);
    } else if (n & 64) {
      isNeg = n & 16;

      // e = isNeg ? [-3, 4] : [-7, 8]
      e = isNeg ? (n & 7) - 3 : (n & 15) - 7;
      k = 1;
    } else if (k === 2) {
      n = n * 88 + NUMERALS.indexOf(str.charAt(1));

      // [0, 5631] -> [[0, 2815][-0, -2815]] -> [[41, 2856][-41, -2856]]
      return new this(n >= 2816 ? -(n - 2816) - 41 : n + 41);
    } else {

      // 0XXXXXX
      // 0 {is negative} {is exponent negative} {exponent digit count [0, 15]}
      isNeg = n & 32;

      // Has an exponent been specified?
      if (n & 31) {
        e = n & 15;    // Exponent character count [1, 15]
        k = e + 1;     // Index of first character of the significand.

        if (e === 1)  {
          e = NUMERALS.indexOf(str.charAt(1));
        } else if (e === 2) {
          e = NUMERALS.indexOf(str.charAt(1)) * 88 +
            NUMERALS.indexOf(str.charAt(2));
        } else {
          e = +convertBase(str.slice(1, k), 88, 10).join('');
        }

        // Negative exponent?
        if (n & 16) e = -e;
      } else {

        // Integer without trailing zeros.
        // 0X00000
        // 0 {is negative} 0 0 0 0 0
        str = convertBase(str.slice(1), 88, 10).join('');
        return new this(isNeg ? '-' + str : str);
      }
    }

    str = convertBase(str.slice(k), 88, 10).join('');
    e = e - str.length + 1;
    str = str + 'e' + e;

    return new this(isNeg ? '-' + str : str);
  }


  /*
   * Return a new Decimal whose value is the square root of the sum of the squares of the arguments,
   * rounded to `precision` significant digits using rounding mode `rounding`.
   *
   * hypot(a, b, ...) = sqrt(a^2 + b^2 + ...)
   *
   */
  function hypot() {
    var i, n,
      t = new this(0);

    external = false;

    for (i = 0; i < arguments.length;) {
      n = new this(arguments[i++]);
      if (!n.d) {
        if (n.s) {
          external = true;
          return new this(1 / 0);
        }
        t = n;
      } else if (t.d) {
        t = t.plus(n.times(n));
      }
    }

    external = true;

    return t.sqrt();
  }


  /*
   * Return a new Decimal whose value is the natural logarithm of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */
  function ln(x) {
    return new this(x).ln();
  }


  /*
   * Return a new Decimal whose value is the log of `x` to the base `y`, or to base 10 if no base
   * is specified, rounded to `precision` significant digits using rounding mode `rounding`.
   *
   * log[y](x)
   *
   * x {number|string|Decimal} The argument of the logarithm.
   * y {number|string|Decimal} The base of the logarithm.
   *
   */
  function log(x, y) {
    return new this(x).log(y);
  }


  /*
   * Return a new Decimal whose value is the base 2 logarithm of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */
  function log2(x) {
    return new this(x).log(2);
  }


  /*
   * Return a new Decimal whose value is the base 10 logarithm of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */
  function log10(x) {
    return new this(x).log(10);
  }


  /*
   * Return a new Decimal whose value is the maximum of the arguments.
   *
   * arguments {number|string|Decimal}
   *
   */
  function max() {
    return maxOrMin(this, arguments, 'lt');
  }


  /*
   * Return a new Decimal whose value is the minimum of the arguments.
   *
   * arguments {number|string|Decimal}
   *
   */
  function min() {
    return maxOrMin(this, arguments, 'gt');
  }


  /*
   * Return a new Decimal whose value is `x` modulo `y`, rounded to `precision` significant digits
   * using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   * y {number|string|Decimal}
   *
   */
  function mod(x, y) {
    return new this(x).mod(y);
  }


  /*
   * Return a new Decimal whose value is `x` multiplied by `y`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   * y {number|string|Decimal}
   *
   */
  function mul(x, y) {
    return new this(x).mul(y);
  }


  /*
   * Return a new Decimal whose value is `x` raised to the power `y`, rounded to precision
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} The base.
   * y {number|string|Decimal} The exponent.
   *
   */
  function pow(x, y) {
    return new this(x).pow(y);
  }


  /*
   * Returns a new Decimal with a random value equal to or greater than 0 and less than 1, and with
   * `sd`, or `Decimal.precision` if `sd` is omitted, significant digits (or less if trailing zeros
   * are produced).
   *
   * [sd] {number} Significant digits. Integer, 0 to MAX_DIGITS inclusive.
   *
   */
  function random(sd) {
    var d, e, k, n,
      i = 0,
      r = new this(1),
      rd = [];

    if (sd === void 0) sd = this.precision;
    else checkInt32(sd, 1, MAX_DIGITS);

    k = Math.ceil(sd / LOG_BASE);

    if (this.crypto === false) {
      for (; i < k;) rd[i++] = Math.random() * 1e7 | 0;

    // Browsers supporting crypto.getRandomValues.
    } else if (cryptoObject && cryptoObject.getRandomValues) {
      d = cryptoObject.getRandomValues(new Uint32Array(k));

      for (; i < k;) {
        n = d[i];

        // 0 <= n < 4294967296
        // Probability n >= 4.29e9, is 4967296 / 4294967296 = 0.00116 (1 in 865).
        if (n >= 4.29e9) {
          d[i] = cryptoObject.getRandomValues(new Uint32Array(1))[0];
        } else {

          // 0 <= n <= 4289999999
          // 0 <= (n % 1e7) <= 9999999
          rd[i++] = n % 1e7;
        }
      }

    // Node.js supporting crypto.randomBytes.
    } else if (cryptoObject && cryptoObject.randomBytes) {

      // buffer
      d = cryptoObject.randomBytes(k *= 4);

      for (; i < k;) {

        // 0 <= n < 2147483648
        n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 0x7f) << 24);

        // Probability n >= 2.14e9, is 7483648 / 2147483648 = 0.0035 (1 in 286).
        if (n >= 2.14e9) {
          cryptoObject.randomBytes(4).copy(d, i);
        } else {

          // 0 <= n <= 2139999999
          // 0 <= (n % 1e7) <= 9999999
          rd.push(n % 1e7);
          i += 4;
        }
      }

      i = k / 4;
    } else if (this.crypto) {
      throw Error(decimalError + 'crypto unavailable');
    } else {
      for (; i < k;) rd[i++] = Math.random() * 1e7 | 0;
    }

    k = rd[--i];
    sd %= LOG_BASE;

    // Convert trailing digits to zeros according to sd.
    if (k && sd) {
      n = mathpow(10, LOG_BASE - sd);
      rd[i] = (k / n | 0) * n;
    }

    // Remove trailing words which are zero.
    for (; rd[i] === 0; i--) rd.pop();

    // Zero?
    if (i < 0) {
      e = 0;
      rd = [0];
    } else {
      e = -1;

      // Remove leading words which are zero and adjust exponent accordingly.
      for (; rd[0] === 0; e -= LOG_BASE) rd.shift();

      // Count the digits of the first word of rd to determine leading zeros.
      for (k = 1, n = rd[0]; n >= 10; n /= 10) k++;

      // Adjust the exponent for leading zeros of the first word of rd.
      if (k < LOG_BASE) e -= LOG_BASE - k;
    }

    r.e = e;
    r.d = rd;

    return r;
  }


  /*
   * Return a new Decimal whose value is `x` rounded to an integer using rounding mode `rounding`.
   *
   * To emulate `Math.round`, set rounding to 7 (ROUND_HALF_CEIL).
   *
   * x {number|string|Decimal}
   *
   */
  function round(x) {
    return finalise(x = new this(x), x.e + 1, this.rounding);
  }


  /*
   * Return
   *   1    if x > 0,
   *  -1    if x < 0,
   *   0    if x is 0,
   *  -0    if x is -0,
   *   NaN  otherwise
   *
   */
  function sign(x) {
    x = new this(x);
    return x.d ? (x.d[0] ? x.s : 0 * x.s) : x.s || NaN;
  }


  /*
   * Return a new Decimal whose value is the sine of `x`, rounded to `precision` significant digits
   * using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function sin(x) {
    return new this(x).sin();
  }


  /*
   * Return a new Decimal whose value is the hyperbolic sine of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function sinh(x) {
    return new this(x).sinh();
  }


  /*
   * Return a new Decimal whose value is the square root of `x`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */
  function sqrt(x) {
    return new this(x).sqrt();
  }


  /*
   * Return a new Decimal whose value is `x` minus `y`, rounded to `precision` significant digits
   * using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   * y {number|string|Decimal}
   *
   */
  function sub(x, y) {
    return new this(x).sub(y);
  }


  /*
   * Return a new Decimal whose value is the tangent of `x`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function tan(x) {
    return new this(x).tan();
  }


  /*
   * Return a new Decimal whose value is the hyperbolic tangent of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function tanh(x) {
    return new this(x).tanh();
  }


  /*
   * Return a new Decimal whose value is `x` truncated to an integer.
   *
   * x {number|string|Decimal}
   *
   */
  function trunc(x) {
    return finalise(x = new this(x), x.e + 1, 1);
  }


  // Create and configure initial Decimal constructor.
  Decimal = clone(Decimal);

  // Create the internal constants from their string values.
  LN10 = new Decimal(LN10);
  PI = new Decimal(PI);


  // Export.


  // AMD.
  if (typeof define == 'function' && define.amd) {
    define(function () {
      return Decimal;
    });

  // Node and other environments that support module.exports.
  } else if (typeof module != 'undefined' && module.exports) {
    module.exports = Decimal;

    if (!cryptoObject) {
      try {
        cryptoObject = require('cry' + 'pto');
      } catch (e) {
        // Ignore.
      }
    }

  // Browser.
  } else {
    if (!globalScope) {
      globalScope = typeof self != 'undefined' && self && self.self == self
        ? self : Function('return this')();
    }

    noConflict = globalScope.Decimal;
    Decimal.noConflict = function () {
      globalScope.Decimal = noConflict;
      return Decimal;
    };

    globalScope.Decimal = Decimal;
  }
})(this);

},{}],490:[function(require,module,exports){
/**
 * @license Fraction.js v3.2.5 09/09/2015
 * http://www.xarg.org/2014/03/precise-calculations-in-javascript/
 *
 * Copyright (c) 2015, Robert Eisele (robert@xarg.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/


/**
 *
 * This class offers the possebility to calculate fractions.
 * You can pass a fraction in different formats. Either as array, as double, as string or as an integer.
 *
 * Array/Object form
 * [ 0 => <nominator>, 1 => <denominator> ]
 * [ n => <nominator>, d => <denominator> ]
 *
 * Integer form
 * - Single integer value
 *
 * Double form
 * - Single double value
 *
 * String form
 * 123.456 - a simple double
 * 123/456 - A string fraction
 * 123.'456' - a double with repeating decimal places
 * 123.(456) - synonym
 * 123.45'6' - a double with repeating last place
 * 123.45(6) - synonym
 *
 * Example:
 *
 * var f = new Fraction("9.4'31'");
 * f.mul([-4, 3]).div(4.9);
 *
 */

(function(root) {

  "use strict";

  // Maximum search depth for cyclic rational numbers. 2000 should be more than enough. 
  // Example: 1/7 = 0.(142857) has 6 repeating decimal places.
  // If MAX_CYCLE_LEN gets reduced, long cycles will not be detected and toString() only gets the first 10 digits
  var MAX_CYCLE_LEN = 2000;

  // Parsed data to avoid calling "new" all the time
  var P = {
    "s": 1,
    "n": 0,
    "d": 1
  };

  function assign(n, s) {

    if (isNaN(n = parseInt(n, 10))) {
      thorwInvalidParam();
    }
    return n * s;
  }

  function thorwInvalidParam() {
    throw "Invalid Param";
  }

  var parse = function(p1, p2) {

    var n = 0, d = 1, s = 1;
    var v = 0, w = 0, x = 0, y = 1, z = 1;

    var A = 0, B = 1;
    var C = 1, D = 1;

    var N = 10000000;
    var M;

    if (p1 === undefined || p1 === null) {
      /* void */
    } else if (p2 !== undefined) {
      n = p1;
      d = p2;
      s = n * d;
    } else
      switch (typeof p1) {

        case "object":
        {
          if ("d" in p1 && "n" in p1) {
            n = p1["n"];
            d = p1["d"];
            if ("s" in p1)
              n*= p1["s"];
          } else if (0 in p1) {
            n = p1[0];
            if (1 in p1)
              d = p1[1];
          } else {
            thorwInvalidParam();
          }
          s = n * d;
          break;
        }
        case "number":
        {
          if (p1 < 0) {
            s = p1;
            p1 = -p1;
          }

          if (p1 % 1 === 0) {
            n = p1;
          } else if (p1 > 0) { // check for != 0, scale would become NaN (log(0)), which converges really slow

            if (p1 >= 1) {
              z = Math.pow(10, Math.floor(1 + Math.log(p1) / Math.LN10));
              p1/= z;
            }

            // Using Farey Sequences
            // http://www.johndcook.com/blog/2010/10/20/best-rational-approximation/

            while (B <= N && D <= N) {
              M = (A + C) / (B + D);

              if (p1 === M) {
                if (B + D <= N) {
                  n = A + C;
                  d = B + D;
                } else if (D > B) {
                  n = C;
                  d = D;
                } else {
                  n = A;
                  d = B;
                }
                break;

              } else {

                if (p1 > M) {
                  A+= C;
                  B+= D;
                } else {
                  C+= A;
                  D+= B;
                }

                if (B > N) {
                  n = C;
                  d = D;
                } else {
                  n = A;
                  d = B;
                }
              }
            }
            n*= z;
          } else if (isNaN(p1) || isNaN(p2)) {
            d = n = NaN;
          }
          break;
        }
        case "string":
        {
          B = p1.match(/\d+|./g);

          if (B[A] === '-') {// Check for minus sign at the beginning
            s = -1;
            A++;
          } else if (B[A] === '+') {// Check for plus sign at the beginning
            A++;
          }

          if (B.length === A + 1) { // Check if it's just a simple number "1234"
            w = assign(B[A++], s);
          } else if (B[A + 1] === '.' || B[A] === '.') { // Check if it's a decimal number

            if (B[A] !== '.') { // Handle 0.5 and .5
              v = assign(B[A++], s);
            }
            A++;

            // Check for decimal places
            if (A + 1 === B.length || B[A + 1] === '(' && B[A + 3] === ')' || B[A + 1] === "'" && B[A + 3] === "'") {
              w = assign(B[A], s);
              y = Math.pow(10, B[A].length);
              A++;
            }

            // Check for repeating places
            if (B[A] === '(' && B[A + 2] === ')' || B[A] === "'" && B[A + 2] === "'") {
              x = assign(B[A + 1], s);
              z = Math.pow(10, B[A + 1].length) - 1;
              A+= 3;
            }

          } else if (B[A + 1] === '/' || B[A + 1] === ':') { // Check for a simple fraction "123/456" or "123:456"
            w = assign(B[A], s);
            y = assign(B[A + 2], 1);
            A+= 3;
          } else if (B[A + 3] === '/' && B[A + 1] === ' ') { // Check for a complex fraction "123 1/2"
            v = assign(B[A], s);
            w = assign(B[A + 2], s);
            y = assign(B[A + 4], 1);
            A+= 5;
          }

          if (B.length <= A) { // Check for more tokens on the stack
            d = y * z;
            s = /* void */
                    n = x + d * v + z * w;
            break;
          }

          /* Fall through on error */
        }
        default:
          thorwInvalidParam();
      }

    if (d === 0) {
      throw "DIV/0";
    }

    P["s"] = s < 0 ? -1 : 1;
    P["n"] = Math.abs(n);
    P["d"] = Math.abs(d);
  };

  var modpow = function(b, e, m) {

    for (var r = 1; e > 0; b = (b * b) % m, e >>= 1) {

      if (e & 1) {
        r = (r * b) % m;
      }
    }
    return r;
  };

  var cycleLen = function(n, d) {

    for (; d % 2 === 0;
            d/= 2) {}

    for (; d % 5 === 0;
            d/= 5) {}

    if (d === 1) // Catch non-cyclic numbers
      return 0;

    // If we would like to compute really large numbers quicker, we could make use of Fermat's little theorem:
    // 10^(d-1) % d == 1
    // However, we don't need such large numbers and MAX_CYCLE_LEN should be the capstone, 
    // as we want to translate the numbers to strings.

    var rem = 10 % d;

    for (var t = 1; rem !== 1; t++) {
      rem = rem * 10 % d;

      if (t > MAX_CYCLE_LEN)
        return 0; // Returning 0 here means that we don't print it as a cyclic number. It's likely that the answer is `d-1`
    }
    return t;
  };

  var cycleStart = function(n, d, len) {

    var rem1 = 1;
    var rem2 = modpow(10, len, d);

    for (var t = 0; t < 300; t++) { // s < ~log10(Number.MAX_VALUE)
      // Solve 10^s == 10^(s+t) (mod d)

      if (rem1 === rem2)
        return t;

      rem1 = rem1 * 10 % d;
      rem2 = rem2 * 10 % d;
    }
    return 0;
  };

  var gcd = function(a, b) {

    if (!a) return b;
    if (!b) return a;

    while (1) {
      a%= b;
      if (!a) return b;
      b%= a;
      if (!b) return a;
    }
  };

  /**
   * Module constructor
   *
   * @constructor
   * @param {number|Fraction} a
   * @param {number=} b
   */
  function Fraction(a, b) {

    if (!(this instanceof Fraction)) {
      return new Fraction(a, b);
    }

    parse(a, b);

    if (Fraction['REDUCE']) {
      a = gcd(P["d"], P["n"]); // Abuse a
    } else {
      a = 1;
    }

    this["s"] = P["s"];
    this["n"] = P["n"] / a;
    this["d"] = P["d"] / a;
  }

  /**
   * Boolean global variable to be able to disable automatic reduction of the fraction
   *
   */
  Fraction['REDUCE'] = 1;

  Fraction.prototype = {

    "s": 1,
    "n": 0,
    "d": 1,

    /**
     * Calculates the absolute value
     *
     * Ex: new Fraction(-4).abs() => 4
     **/
    "abs": function() {

      return new Fraction(this["n"], this["d"]);
    },

    /**
     * Inverts the sign of the current fraction
     *
     * Ex: new Fraction(-4).neg() => 4
     **/
    "neg": function() {

      return new Fraction(-this["s"] * this["n"], this["d"]);
    },

    /**
     * Adds two rational numbers
     *
     * Ex: new Fraction({n: 2, d: 3}).add("14.9") => 467 / 30
     **/
    "add": function(a, b) {

      parse(a, b);
      return new Fraction(
              this["s"] * this["n"] * P["d"] + P["s"] * this["d"] * P["n"],
              this["d"] * P["d"]
              );
    },

    /**
     * Subtracts two rational numbers
     *
     * Ex: new Fraction({n: 2, d: 3}).add("14.9") => -427 / 30
     **/
    "sub": function(a, b) {

      parse(a, b);
      return new Fraction(
              this["s"] * this["n"] * P["d"] - P["s"] * this["d"] * P["n"],
              this["d"] * P["d"]
              );
    },

    /**
     * Multiplies two rational numbers
     *
     * Ex: new Fraction("-17.(345)").mul(3) => 5776 / 111
     **/
    "mul": function(a, b) {

      parse(a, b);
      return new Fraction(
              this["s"] * P["s"] * this["n"] * P["n"],
              this["d"] * P["d"]
              );
    },

    /**
     * Divides two rational numbers
     *
     * Ex: new Fraction("-17.(345)").inverse().div(3)
     **/
    "div": function(a, b) {

      parse(a, b);
      return new Fraction(
              this["s"] * P["s"] * this["n"] * P["d"],
              this["d"] * P["n"]
              );
    },

    /**
     * Clones the actual object
     *
     * Ex: new Fraction("-17.(345)").clone()
     **/
    "clone": function() {
      return new Fraction(this);
    },

    /**
     * Calculates the modulo of two rational numbers - a more precise fmod
     *
     * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)
     **/
    "mod": function(a, b) {

      if (isNaN(this['n']) || isNaN(this['d'])) {
        return new Fraction(NaN);
      }

      if (a === undefined) {
        return new Fraction(this["s"] * this["n"] % this["d"], 1);
      }

      parse(a, b);
      if (0 === P["n"] && 0 === this["d"]) {
        Fraction(0, 0); // Throw div/0
      }

      /*
       * First silly attempt, kinda slow
       *
       return that["sub"]({
       "n": num["n"] * Math.floor((this.n / this.d) / (num.n / num.d)),
       "d": num["d"],
       "s": this["s"]
       });*/

      /*
       * New attempt: a1 / b1 = a2 / b2 * q + r
       * => b2 * a1 = a2 * b1 * q + b1 * b2 * r
       * => (b2 * a1 % a2 * b1) / (b1 * b2)
       */
      return new Fraction(
              (this["s"] * P["d"] * this["n"]) % (P["n"] * this["d"]),
              P["d"] * this["d"]
              );
    },

    /**
     * Calculates the fractional gcd of two rational numbers
     *
     * Ex: new Fraction(5,8).gcd(3,7) => 1/56
     */
    "gcd": function(a, b) {

      parse(a, b);

      // gcd(a / b, c / d) = gcd(a, c) / lcm(b, d)

      return new Fraction(gcd(P["n"], this["n"]), P["d"] * this["d"] / gcd(P["d"], this["d"]));
    },

    /**
     * Calculates the fractional lcm of two rational numbers
     *
     * Ex: new Fraction(5,8).lcm(3,7) => 15
     */
    "lcm": function(a, b) {

      parse(a, b);

      // lcm(a / b, c / d) = lcm(a, c) / gcd(b, d)

      if (P["n"] === 0 && this["n"] === 0) {
        return new Fraction;
      }
      return new Fraction(P["n"] * this["n"] / gcd(P["n"], this["n"]), gcd(P["d"], this["d"]));
    },

    /**
     * Calculates the ceil of a rational number
     *
     * Ex: new Fraction('4.(3)').ceil() => (5 / 1)
     **/
    "ceil": function(places) {

      places = Math.pow(10, places || 0);

      if (isNaN(this["n"]) || isNaN(this["d"])) {
        return new Fraction(NaN);
      }
      return new Fraction(Math.ceil(places * this["s"] * this["n"] / this["d"]), places);
    },

    /**
     * Calculates the floor of a rational number
     *
     * Ex: new Fraction('4.(3)').floor() => (4 / 1)
     **/
    "floor": function(places) {

      places = Math.pow(10, places || 0);

      if (isNaN(this["n"]) || isNaN(this["d"])) {
        return new Fraction(NaN);
      }
      return new Fraction(Math.floor(places * this["s"] * this["n"] / this["d"]), places);
    },

    /**
     * Rounds a rational numbers
     *
     * Ex: new Fraction('4.(3)').round() => (4 / 1)
     **/
    "round": function(places) {

      places = Math.pow(10, places || 0);

      if (isNaN(this["n"]) || isNaN(this["d"])) {
        return new Fraction(NaN);
      }
      return new Fraction(Math.round(places * this["s"] * this["n"] / this["d"]), places);
    },

    /**
     * Gets the inverse of the fraction, means numerator and denumerator are exchanged
     *
     * Ex: new Fraction([-3, 4]).inverse() => -4 / 3
     **/
    "inverse": function() {

      return new Fraction(this["s"] * this["d"], this["n"]);
    },

    /**
     * Calculates the fraction to some integer exponent
     *
     * Ex: new Fraction(-1,2).pow(-3) => -8
     */
    "pow": function(m) {

      if (m < 0) {
        return new Fraction(Math.pow(this['s'] * this["d"],-m), Math.pow(this["n"],-m));
      } else {
        return new Fraction(Math.pow(this['s'] * this["n"], m), Math.pow(this["d"], m));
      }
    },

    /**
     * Check if two rational numbers are the same
     *
     * Ex: new Fraction(19.6).equals([98, 5]);
     **/
    "equals": function(a, b) {

      parse(a, b);
      return this["s"] * this["n"] * P["d"] === P["s"] * P["n"] * this["d"]; // Same as compare() === 0
    },

    /**
     * Check if two rational numbers are the same
     *
     * Ex: new Fraction(19.6).equals([98, 5]);
     **/
    "compare": function(a, b) {

      parse(a, b);
      var t = (this["s"] * this["n"] * P["d"] - P["s"] * P["n"] * this["d"]);
      return (0 < t) - (t < 0);
    },

    /**
     * Check if two rational numbers are divisible
     *
     * Ex: new Fraction(19.6).divisible(1.5);
     */
    "divisible": function(a, b) {

      parse(a, b);
      return !(!(P["n"] * this["d"]) || ((this["n"] * P["d"]) % (P["n"] * this["d"])));
    },

    /**
     * Returns a decimal representation of the fraction
     *
     * Ex: new Fraction("100.'91823'").valueOf() => 100.91823918239183
     **/
    'valueOf': function() {

      return this["s"] * this["n"] / this["d"];
    },

    /**
     * Returns a string-fraction representation of a Fraction object
     *
     * Ex: new Fraction("1.'3'").toFraction() => "4 1/3"
     **/
    'toFraction': function(excludeWhole) {

      var whole, str = "";
      var n = this["n"];
      var d = this["d"];
      if (this["s"] < 0) {
        str+= '-';
      }

      if (d === 1) {
        str+= n;
      } else {

        if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
          str+= whole;
          str+= " ";
          n%= d;
        }

        str+= n;
        str+= '/';
        str+= d;
      }
      return str;
    },

    /**
     * Returns a latex representation of a Fraction object
     *
     * Ex: new Fraction("1.'3'").toLatex() => "\frac{4}{3}"
     **/
    'toLatex': function(excludeWhole) {

      var whole, str = "";
      var n = this["n"];
      var d = this["d"];
      if (this["s"] < 0) {
        str+= '-';
      }

      if (d === 1) {
        str+= n;
      } else {

        if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
          str+= whole;
          n%= d;
        }

        str+= "\\frac{";
        str+= n;
        str+= '}{';
        str+= d;
        str+= '}';
      }
      return str;
    },

    /**
     * Returns an array of continued fraction elements
     * 
     * Ex: new Fraction("7/8").toContinued() => [0,1,7]
     */
    'toContinued': function() {

      var t;
      var a = this['n'];
      var b = this['d'];
      var res = [];

      do {
        res.push(Math.floor(a / b));
        t = a % b;
        a = b;
        b = t;
      } while (a !== 1);

      return res;
    },

    /**
     * Creates a string representation of a fraction with all digits
     *
     * Ex: new Fraction("100.'91823'").toString() => "100.(91823)"
     **/
    'toString': function() {

      var g;
      var N = this["n"];
      var D = this["d"];

      if (isNaN(N) || isNaN(D)) {
        return "NaN";
      }

      if (!Fraction['REDUCE']) {
        g = gcd(N, D);
        N/= g;
        D/= g;
      }

      var p = String(N).split(""); // Numerator chars
      var t = 0; // Tmp var

      var ret = [~this["s"] ? "" : "-", "", ""]; // Return array, [0] is zero sign, [1] before comma, [2] after
      var zeros = ""; // Collection variable for zeros

      var cycLen = cycleLen(N, D); // Cycle length
      var cycOff = cycleStart(N, D, cycLen); // Cycle start

      var j = -1;
      var n = 1; // str index

      // rough estimate to fill zeros
      var length = 10 + cycLen + cycOff + p.length; // 10 = decimal places when no repitation

      for (var i = 0; i < length; i++, t*= 10) {

        if (i < p.length) {
          t+= Number(p[i]);
        } else {
          n = 2;
          j++; // Start now => after comma
        }

        if (cycLen > 0) { // If we have a repeating part
          if (j === cycOff) {
            ret[n]+= zeros + "(";
            zeros = "";
          } else if (j === cycLen + cycOff) {
            ret[n]+= zeros + ")";
            break;
          }
        }

        if (t >= D) {
          ret[n]+= zeros + ((t / D) | 0); // Flush zeros, Add current digit
          zeros = "";
          t = t % D;
        } else if (n > 1) { // Add zeros to the zero buffer
          zeros+= "0";
        } else if (ret[n]) { // If before comma, add zero only if already something was added
          ret[n]+= "0";
        }
      }

      // If it's empty, it's a leading zero only
      ret[0]+= ret[1] || "0";

      // If there is something after the comma, add the comma sign
      if (ret[2]) {
        return ret[0] + "." + ret[2];
      }
      return ret[0];
    }
  };

  if (typeof define === "function" && define["amd"]) {
    define([], function() {
      return Fraction;
    });
  } else if (typeof exports === "object") {
    module["exports"] = Fraction;
  } else {
    root['Fraction'] = Fraction;
  }

})(this);

},{}],491:[function(require,module,exports){
function E () {
	// Keep this empty so it's easier to inherit from
  // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)
}

E.prototype = {
	on: function (name, callback, ctx) {
    var e = this.e || (this.e = {});

    (e[name] || (e[name] = [])).push({
      fn: callback,
      ctx: ctx
    });

    return this;
  },

  once: function (name, callback, ctx) {
    var self = this;
    function listener () {
      self.off(name, listener);
      callback.apply(ctx, arguments);
    };

    listener._ = callback
    return this.on(name, listener, ctx);
  },

  emit: function (name) {
    var data = [].slice.call(arguments, 1);
    var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
    var i = 0;
    var len = evtArr.length;

    for (i; i < len; i++) {
      evtArr[i].fn.apply(evtArr[i].ctx, data);
    }

    return this;
  },

  off: function (name, callback) {
    var e = this.e || (this.e = {});
    var evts = e[name];
    var liveEvents = [];

    if (evts && callback) {
      for (var i = 0, len = evts.length; i < len; i++) {
        if (evts[i].fn !== callback && evts[i].fn._ !== callback)
          liveEvents.push(evts[i]);
      }
    }

    // Remove event from queue to prevent memory leak
    // Suggested by https://github.com/lazd
    // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910

    (liveEvents.length)
      ? e[name] = liveEvents
      : delete e[name];

    return this;
  }
};

module.exports = E;

},{}],492:[function(require,module,exports){
/**
 * typed-function
 *
 * Type checking for JavaScript functions
 *
 * https://github.com/josdejong/typed-function
 */
'use strict';

(function (factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define([], factory);
  } else if (typeof exports === 'object') {
    // OldNode. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like OldNode.
    module.exports = factory();
  } else {
    // Browser globals (root is window)
    window.typed = factory();
  }
}(function () {
  // factory function to create a new instance of typed-function
  // TODO: allow passing configuration, types, tests via the factory function
  function create() {
    /**
     * Get a type test function for a specific data type
     * @param {string} name                   Name of a data type like 'number' or 'string'
     * @returns {Function(obj: *) : boolean}  Returns a type testing function.
     *                                        Throws an error for an unknown type.
     */
    function getTypeTest(name) {
      var test;
      for (var i = 0; i < typed.types.length; i++) {
        var entry = typed.types[i];
        if (entry.name === name) {
          test = entry.test;
          break;
        }
      }

      if (!test) {
        var hint;
        for (i = 0; i < typed.types.length; i++) {
          entry = typed.types[i];
          if (entry.name.toLowerCase() == name.toLowerCase()) {
            hint = entry.name;
            break;
          }
        }

        throw new Error('Unknown type "' + name + '"' +
            (hint ? ('. Did you mean "' + hint + '"?') : ''));
      }
      return test;
    }

    /**
     * Retrieve the function name from a set of functions, and check
     * whether the name of all functions match (if given)
     * @param {Array.<function>} fns
     */
    function getName (fns) {
      var name = '';

      for (var i = 0; i < fns.length; i++) {
        var fn = fns[i];

        // merge function name
        if (fn.name != '') {
          if (name == '') {
            name = fn.name;
          }
          else if (name != fn.name) {
            var err = new Error('Function names do not match (expected: ' + name + ', actual: ' + fn.name + ')');
            err.data = {
              actual: fn.name,
              expected: name
            };
            throw err;
          }
        }
      }

      return name;
    }

    /**
     * Create an ArgumentsError. Creates messages like:
     *
     *   Unexpected type of argument (expected: ..., actual: ..., index: ...)
     *   Too few arguments (expected: ..., index: ...)
     *   Too many arguments (expected: ..., actual: ...)
     *
     * @param {String} fn         Function name
     * @param {number} argCount   Number of arguments
     * @param {Number} index      Current argument index
     * @param {*} actual          Current argument
     * @param {string} [expected] An optional, comma separated string with
     *                            expected types on given index
     * @extends Error
     */
    function createError(fn, argCount, index, actual, expected) {
      var actualType = getTypeOf(actual);
      var _expected = expected ? expected.split(',') : null;
      var _fn = (fn || 'unnamed');
      var anyType = _expected && contains(_expected, 'any');
      var message;
      var data = {
        fn: fn,
        index: index,
        actual: actual,
        expected: _expected
      };

      if (_expected) {
        if (argCount > index && !anyType) {
          // unexpected type
          message = 'Unexpected type of argument in function ' + _fn +
              ' (expected: ' + _expected.join(' or ') + ', actual: ' + actualType + ', index: ' + index + ')';
        }
        else {
          // too few arguments
          message = 'Too few arguments in function ' + _fn +
              ' (expected: ' + _expected.join(' or ') + ', index: ' + index + ')';
        }
      }
      else {
        // too many arguments
        message = 'Too many arguments in function ' + _fn +
            ' (expected: ' + index + ', actual: ' + argCount + ')'
      }

      var err = new TypeError(message);
      err.data = data;
      return err;
    }

    /**
     * Collection with function references (local shortcuts to functions)
     * @constructor
     * @param {string} [name='refs']  Optional name for the refs, used to generate
     *                                JavaScript code
     */
    function Refs(name) {
      this.name = name || 'refs';
      this.categories = {};
    }

    /**
     * Add a function reference.
     * @param {Function} fn
     * @param {string} [category='fn']    A function category, like 'fn' or 'signature'
     * @returns {string} Returns the function name, for example 'fn0' or 'signature2'
     */
    Refs.prototype.add = function (fn, category) {
      var cat = category || 'fn';
      if (!this.categories[cat]) this.categories[cat] = [];

      var index = this.categories[cat].indexOf(fn);
      if (index == -1) {
        index = this.categories[cat].length;
        this.categories[cat].push(fn);
      }

      return cat + index;
    };

    /**
     * Create code lines for all function references
     * @returns {string} Returns the code containing all function references
     */
    Refs.prototype.toCode = function () {
      var code = [];
      var path = this.name + '.categories';
      var categories = this.categories;

      for (var cat in categories) {
        if (categories.hasOwnProperty(cat)) {
          var category = categories[cat];

          for (var i = 0; i < category.length; i++) {
            code.push('var ' + cat + i + ' = ' + path + '[\'' + cat + '\'][' + i + '];');
          }
        }
      }

      return code.join('\n');
    };

    /**
     * A function parameter
     * @param {string | string[] | Param} types    A parameter type like 'string',
     *                                             'number | boolean'
     * @param {boolean} [varArgs=false]            Variable arguments if true
     * @constructor
     */
    function Param(types, varArgs) {
      // parse the types, can be a string with types separated by pipe characters |
      if (typeof types === 'string') {
        // parse variable arguments operator (ellipses '...number')
        var _types = types.trim();
        var _varArgs = _types.substr(0, 3) === '...';
        if (_varArgs) {
          _types = _types.substr(3);
        }
        if (_types === '') {
          this.types = ['any'];
        }
        else {
          this.types = _types.split('|');
          for (var i = 0; i < this.types.length; i++) {
            this.types[i] = this.types[i].trim();
          }
        }
      }
      else if (Array.isArray(types)) {
        this.types = types;
      }
      else if (types instanceof Param) {
        return types.clone();
      }
      else {
        throw new Error('String or Array expected');
      }

      // can hold a type to which to convert when handling this parameter
      this.conversions = [];
      // TODO: implement better API for conversions, be able to add conversions via constructor (support a new type Object?)

      // variable arguments
      this.varArgs = _varArgs || varArgs || false;

      // check for any type arguments
      this.anyType = this.types.indexOf('any') !== -1;
    }

    /**
     * Order Params
     * any type ('any') will be ordered last, and object as second last (as other
     * types may be an object as well, like Array).
     *
     * @param {Param} a
     * @param {Param} b
     * @returns {number} Returns 1 if a > b, -1 if a < b, and else 0.
     */
    Param.compare = function (a, b) {
      // TODO: simplify parameter comparison, it's a mess
      if (a.anyType) return 1;
      if (b.anyType) return -1;

      if (contains(a.types, 'Object')) return 1;
      if (contains(b.types, 'Object')) return -1;

      if (a.hasConversions()) {
        if (b.hasConversions()) {
          var i, ac, bc;

          for (i = 0; i < a.conversions.length; i++) {
            if (a.conversions[i] !== undefined) {
              ac = a.conversions[i];
              break;
            }
          }

          for (i = 0; i < b.conversions.length; i++) {
            if (b.conversions[i] !== undefined) {
              bc = b.conversions[i];
              break;
            }
          }

          return typed.conversions.indexOf(ac) - typed.conversions.indexOf(bc);
        }
        else {
          return 1;
        }
      }
      else {
        if (b.hasConversions()) {
          return -1;
        }
        else {
          // both params have no conversions
          var ai, bi;

          for (i = 0; i < typed.types.length; i++) {
            if (typed.types[i].name === a.types[0]) {
              ai = i;
              break;
            }
          }

          for (i = 0; i < typed.types.length; i++) {
            if (typed.types[i].name === b.types[0]) {
              bi = i;
              break;
            }
          }

          return ai - bi;
        }
      }
    };

    /**
     * Test whether this parameters types overlap an other parameters types.
     * @param {Param} other
     * @return {boolean} Returns true when there are conflicting types
     */
    Param.prototype.overlapping = function (other) {
      for (var i = 0; i < this.types.length; i++) {
        if (contains(other.types, this.types[i])) {
          return true;
        }
      }
      return false;
    };

    /**
     * Create a clone of this param
     * @returns {Param} Returns a cloned version of this param
     */
    Param.prototype.clone = function () {
      var param = new Param(this.types.slice(), this.varArgs);
      param.conversions = this.conversions.slice();
      return param;
    };

    /**
     * Test whether this parameter contains conversions
     * @returns {boolean} Returns true if the parameter contains one or
     *                    multiple conversions.
     */
    Param.prototype.hasConversions = function () {
      return this.conversions.length > 0;
    };

    /**
     * Tests whether this parameters contains any of the provided types
     * @param {Object} types  A Map with types, like {'number': true}
     * @returns {boolean}     Returns true when the parameter contains any
     *                        of the provided types
     */
    Param.prototype.contains = function (types) {
      for (var i = 0; i < this.types.length; i++) {
        if (types[this.types[i]]) {
          return true;
        }
      }
      return false;
    };

    /**
     * Return a string representation of this params types, like 'string' or
     * 'number | boolean' or '...number'
     * @param {boolean} [toConversion]   If true, the returned types string
     *                                   contains the types where the parameter
     *                                   will convert to. If false (default)
     *                                   the "from" types are returned
     * @returns {string}
     */
    Param.prototype.toString = function (toConversion) {
      var types = [];
      var keys = {};

      for (var i = 0; i < this.types.length; i++) {
        var conversion = this.conversions[i];
        var type = toConversion && conversion ? conversion.to : this.types[i];
        if (!(type in keys)) {
          keys[type] = true;
          types.push(type);
        }
      }

      return (this.varArgs ? '...' : '') + types.join('|');
    };

    /**
     * A function signature
     * @param {string | string[] | Param[]} params
     *                         Array with the type(s) of each parameter,
     *                         or a comma separated string with types
     * @param {Function} fn    The actual function
     * @constructor
     */
    function Signature(params, fn) {
      var _params;
      if (typeof params === 'string') {
        _params = (params !== '') ? params.split(',') : [];
      }
      else if (Array.isArray(params)) {
        _params = params;
      }
      else {
        throw new Error('string or Array expected');
      }

      this.params = new Array(_params.length);
      for (var i = 0; i < _params.length; i++) {
        var param = new Param(_params[i]);
        this.params[i] = param;
        if (i === _params.length - 1) {
          // the last argument
          this.varArgs = param.varArgs;
        }
        else {
          // non-last argument
          if (param.varArgs) {
            throw new SyntaxError('Unexpected variable arguments operator "..."');
          }
        }
      }

      this.fn = fn;
    }

    /**
     * Create a clone of this signature
     * @returns {Signature} Returns a cloned version of this signature
     */
    Signature.prototype.clone = function () {
      return new Signature(this.params.slice(), this.fn);
    };

    /**
     * Expand a signature: split params with union types in separate signatures
     * For example split a Signature "string | number" into two signatures.
     * @return {Signature[]} Returns an array with signatures (at least one)
     */
    Signature.prototype.expand = function () {
      var signatures = [];

      function recurse(signature, path) {
        if (path.length < signature.params.length) {
          var i, newParam, conversion;

          var param = signature.params[path.length];
          if (param.varArgs) {
            // a variable argument. do not split the types in the parameter
            newParam = param.clone();

            // add conversions to the parameter
            // recurse for all conversions
            for (i = 0; i < typed.conversions.length; i++) {
              conversion = typed.conversions[i];
              if (!contains(param.types, conversion.from) && contains(param.types, conversion.to)) {
                var j = newParam.types.length;
                newParam.types[j] = conversion.from;
                newParam.conversions[j] = conversion;
              }
            }

            recurse(signature, path.concat(newParam));
          }
          else {
            // split each type in the parameter
            for (i = 0; i < param.types.length; i++) {
              recurse(signature, path.concat(new Param(param.types[i])));
            }

            // recurse for all conversions
            for (i = 0; i < typed.conversions.length; i++) {
              conversion = typed.conversions[i];
              if (!contains(param.types, conversion.from) && contains(param.types, conversion.to)) {
                newParam = new Param(conversion.from);
                newParam.conversions[0] = conversion;
                recurse(signature, path.concat(newParam));
              }
            }
          }
        }
        else {
          signatures.push(new Signature(path, signature.fn));
        }
      }

      recurse(this, []);

      return signatures;
    };

    /**
     * Compare two signatures.
     *
     * When two params are equal and contain conversions, they will be sorted
     * by lowest index of the first conversions.
     *
     * @param {Signature} a
     * @param {Signature} b
     * @returns {number} Returns 1 if a > b, -1 if a < b, and else 0.
     */
    Signature.compare = function (a, b) {
      if (a.params.length > b.params.length) return 1;
      if (a.params.length < b.params.length) return -1;

      // count the number of conversions
      var i;
      var len = a.params.length; // a and b have equal amount of params
      var ac = 0;
      var bc = 0;
      for (i = 0; i < len; i++) {
        if (a.params[i].hasConversions()) ac++;
        if (b.params[i].hasConversions()) bc++;
      }

      if (ac > bc) return 1;
      if (ac < bc) return -1;

      // compare the order per parameter
      for (i = 0; i < a.params.length; i++) {
        var cmp = Param.compare(a.params[i], b.params[i]);
        if (cmp !== 0) {
          return cmp;
        }
      }

      return 0;
    };

    /**
     * Test whether any of the signatures parameters has conversions
     * @return {boolean} Returns true when any of the parameters contains
     *                   conversions.
     */
    Signature.prototype.hasConversions = function () {
      for (var i = 0; i < this.params.length; i++) {
        if (this.params[i].hasConversions()) {
          return true;
        }
      }
      return false;
    };

    /**
     * Test whether this signature should be ignored.
     * Checks whether any of the parameters contains a type listed in
     * typed.ignore
     * @return {boolean} Returns true when the signature should be ignored
     */
    Signature.prototype.ignore = function () {
      // create a map with ignored types
      var types = {};
      for (var i = 0; i < typed.ignore.length; i++) {
        types[typed.ignore[i]] = true;
      }

      // test whether any of the parameters contains this type
      for (i = 0; i < this.params.length; i++) {
        if (this.params[i].contains(types)) {
          return true;
        }
      }

      return false;
    };

    /**
     * Generate the code to invoke this signature
     * @param {Refs} refs
     * @param {string} prefix
     * @returns {string} Returns code
     */
    Signature.prototype.toCode = function (refs, prefix) {
      var code = [];

      var args = new Array(this.params.length);
      for (var i = 0; i < this.params.length; i++) {
        var param = this.params[i];
        var conversion = param.conversions[0];
        if (param.varArgs) {
          args[i] = 'varArgs';
        }
        else if (conversion) {
          args[i] = refs.add(conversion.convert, 'convert') + '(arg' + i + ')';
        }
        else {
          args[i] = 'arg' + i;
        }
      }

      var ref = this.fn ? refs.add(this.fn, 'signature') : undefined;
      if (ref) {
        return prefix + 'return ' + ref + '(' + args.join(', ') + '); // signature: ' + this.params.join(', ');
      }

      return code.join('\n');
    };

    /**
     * Return a string representation of the signature
     * @returns {string}
     */
    Signature.prototype.toString = function () {
      return this.params.join(', ');
    };

    /**
     * A group of signatures with the same parameter on given index
     * @param {Param[]} path
     * @param {Signature} [signature]
     * @param {Node[]} childs
     * @constructor
     */
    function Node(path, signature, childs) {
      this.path = path || [];
      this.param = path[path.length - 1] || null;
      this.signature = signature || null;
      this.childs = childs || [];
    }

    /**
     * Generate code for this group of signatures
     * @param {Refs} refs
     * @param {string} prefix
     * @param {Node | undefined} [anyType]  Sibling of this node with any type parameter
     * @returns {string} Returns the code as string
     */
    Node.prototype.toCode = function (refs, prefix, anyType) {
      // TODO: split this function in multiple functions, it's too large
      var code = [];

      if (this.param) {
        var index = this.path.length - 1;
        var conversion = this.param.conversions[0];
        var comment = '// type: ' + (conversion ?
                (conversion.from + ' (convert to ' + conversion.to + ')') :
                this.param);

        // non-root node (path is non-empty)
        if (this.param.varArgs) {
          if (this.param.anyType) {
            // variable arguments with any type
            code.push(prefix + 'if (arguments.length > ' + index + ') {');
            code.push(prefix + '  var varArgs = [];');
            code.push(prefix + '  for (var i = ' + index + '; i < arguments.length; i++) {');
            code.push(prefix + '    varArgs.push(arguments[i]);');
            code.push(prefix + '  }');
            code.push(this.signature.toCode(refs, prefix + '  '));
            code.push(prefix + '}');
          }
          else {
            // variable arguments with a fixed type
            var getTests = function (types, arg) {
              var tests = [];
              for (var i = 0; i < types.length; i++) {
                tests[i] = refs.add(getTypeTest(types[i]), 'test') + '(' + arg + ')';
              }
              return tests.join(' || ');
            }.bind(this);

            var allTypes = this.param.types;
            var exactTypes = [];
            for (var i = 0; i < allTypes.length; i++) {
              if (this.param.conversions[i] === undefined) {
                exactTypes.push(allTypes[i]);
              }
            }

            code.push(prefix + 'if (' + getTests(allTypes, 'arg' + index) + ') { ' + comment);
            code.push(prefix + '  var varArgs = [arg' + index + '];');
            code.push(prefix + '  for (var i = ' + (index + 1) + '; i < arguments.length; i++) {');
            code.push(prefix + '    if (' + getTests(exactTypes, 'arguments[i]') + ') {');
            code.push(prefix + '      varArgs.push(arguments[i]);');

            for (var i = 0; i < allTypes.length; i++) {
              var conversion_i = this.param.conversions[i];
              if (conversion_i) {
                var test = refs.add(getTypeTest(allTypes[i]), 'test');
                var convert = refs.add(conversion_i.convert, 'convert');
                code.push(prefix + '    }');
                code.push(prefix + '    else if (' + test + '(arguments[i])) {');
                code.push(prefix + '      varArgs.push(' + convert + '(arguments[i]));');
              }
            }
            code.push(prefix + '    } else {');
            code.push(prefix + '      throw createError(name, arguments.length, i, arguments[i], \'' + exactTypes.join(',') + '\');');
            code.push(prefix + '    }');
            code.push(prefix + '  }');
            code.push(this.signature.toCode(refs, prefix + '  '));
            code.push(prefix + '}');
          }
        }
        else {
          if (this.param.anyType) {
            // any type
            code.push(prefix + '// type: any');
            code.push(this._innerCode(refs, prefix, anyType));
          }
          else {
            // regular type
            var type = this.param.types[0];
            var test = type !== 'any' ? refs.add(getTypeTest(type), 'test') : null;

            code.push(prefix + 'if (' + test + '(arg' + index + ')) { ' + comment);
            code.push(this._innerCode(refs, prefix + '  ', anyType));
            code.push(prefix + '}');
          }
        }
      }
      else {
        // root node (path is empty)
        code.push(this._innerCode(refs, prefix, anyType));
      }

      return code.join('\n');
    };

    /**
     * Generate inner code for this group of signatures.
     * This is a helper function of Node.prototype.toCode
     * @param {Refs} refs
     * @param {string} prefix
     * @param {Node | undefined} [anyType]  Sibling of this node with any type parameter
     * @returns {string} Returns the inner code as string
     * @private
     */
    Node.prototype._innerCode = function (refs, prefix, anyType) {
      var code = [];
      var i;

      if (this.signature) {
        code.push(prefix + 'if (arguments.length === ' + this.path.length + ') {');
        code.push(this.signature.toCode(refs, prefix + '  '));
        code.push(prefix + '}');
      }

      var nextAnyType;
      for (i = 0; i < this.childs.length; i++) {
        if (this.childs[i].param.anyType) {
          nextAnyType = this.childs[i];
          break;
        }
      }

      for (i = 0; i < this.childs.length; i++) {
        code.push(this.childs[i].toCode(refs, prefix, nextAnyType));
      }

      if (anyType && !this.param.anyType) {
        code.push(anyType.toCode(refs, prefix, nextAnyType));
      }

      var exceptions = this._exceptions(refs, prefix);
      if (exceptions) {
        code.push(exceptions);
      }

      return code.join('\n');
    };

    /**
     * Generate code to throw exceptions
     * @param {Refs} refs
     * @param {string} prefix
     * @returns {string} Returns the inner code as string
     * @private
     */
    Node.prototype._exceptions = function (refs, prefix) {
      var index = this.path.length;

      if (this.childs.length === 0) {
        // TODO: can this condition be simplified? (we have a fall-through here)
        return [
          prefix + 'if (arguments.length > ' + index + ') {',
          prefix + '  throw createError(name, arguments.length, ' + index + ', arguments[' + index + ']);',
          prefix + '}'
        ].join('\n');
      }
      else {
        var keys = {};
        var types = [];

        for (var i = 0; i < this.childs.length; i++) {
          var node = this.childs[i];
          if (node.param) {
            for (var j = 0; j < node.param.types.length; j++) {
              var type = node.param.types[j];
              if (!(type in keys) && !node.param.conversions[j]) {
                keys[type] = true;
                types.push(type);
              }
            }
          }
        }

        return prefix + 'throw createError(name, arguments.length, ' + index + ', arguments[' + index + '], \'' + types.join(',') + '\');';
      }
    };

    /**
     * Split all raw signatures into an array with expanded Signatures
     * @param {Object.<string, Function>} rawSignatures
     * @return {Signature[]} Returns an array with expanded signatures
     */
    function parseSignatures(rawSignatures) {
      // FIXME: need to have deterministic ordering of signatures, do not create via object
      var signature;
      var keys = {};
      var signatures = [];
      var i;

      for (var types in rawSignatures) {
        if (rawSignatures.hasOwnProperty(types)) {
          var fn = rawSignatures[types];
          signature = new Signature(types, fn);

          if (signature.ignore()) {
            continue;
          }

          var expanded = signature.expand();

          for (i = 0; i < expanded.length; i++) {
            var signature_i = expanded[i];
            var key = signature_i.toString();
            var existing = keys[key];
            if (!existing) {
              keys[key] = signature_i;
            }
            else {
              var cmp = Signature.compare(signature_i, existing);
              if (cmp < 0) {
                // override if sorted first
                keys[key] = signature_i;
              }
              else if (cmp === 0) {
                throw new Error('Signature "' + key + '" is defined twice');
              }
              // else: just ignore
            }
          }
        }
      }

      // convert from map to array
      for (key in keys) {
        if (keys.hasOwnProperty(key)) {
          signatures.push(keys[key]);
        }
      }

      // order the signatures
      signatures.sort(function (a, b) {
        return Signature.compare(a, b);
      });

      // filter redundant conversions from signatures with varArgs
      // TODO: simplify this loop or move it to a separate function
      for (i = 0; i < signatures.length; i++) {
        signature = signatures[i];

        if (signature.varArgs) {
          var index = signature.params.length - 1;
          var param = signature.params[index];

          var t = 0;
          while (t < param.types.length) {
            if (param.conversions[t]) {
              var type = param.types[t];

              for (var j = 0; j < signatures.length; j++) {
                var other = signatures[j];
                var p = other.params[index];

                if (other !== signature &&
                    p &&
                    contains(p.types, type) && !p.conversions[index]) {
                  // this (conversion) type already exists, remove it
                  param.types.splice(t, 1);
                  param.conversions.splice(t, 1);
                  t--;
                  break;
                }
              }
            }
            t++;
          }
        }
      }

      return signatures;
    }

    /**
     * create a map with normalized signatures as key and the function as value
     * @param {Signature[]} signatures   An array with split signatures
     * @return {Object.<string, Function>} Returns a map with normalized
     *                                     signatures as key, and the function
     *                                     as value.
     */
    function mapSignatures(signatures) {
      var normalized = {};

      for (var i = 0; i < signatures.length; i++) {
        var signature = signatures[i];
        if (signature.fn && !signature.hasConversions()) {
          var params = signature.params.join(',');
          normalized[params] = signature.fn;
        }
      }

      return normalized;
    }

    /**
     * Parse signatures recursively in a node tree.
     * @param {Signature[]} signatures  Array with expanded signatures
     * @param {Param[]} path            Traversed path of parameter types
     * @return {Node}                   Returns a node tree
     */
    function parseTree(signatures, path) {
      var i, signature;
      var index = path.length;
      var nodeSignature;

      var filtered = [];
      for (i = 0; i < signatures.length; i++) {
        signature = signatures[i];

        // filter the first signature with the correct number of params
        if (signature.params.length === index && !nodeSignature) {
          nodeSignature = signature;
        }

        if (signature.params[index] != undefined) {
          filtered.push(signature);
        }
      }

      // sort the filtered signatures by param
      filtered.sort(function (a, b) {
        return Param.compare(a.params[index], b.params[index]);
      });

      // recurse over the signatures
      var entries = [];
      for (i = 0; i < filtered.length; i++) {
        signature = filtered[i];
        // group signatures with the same param at current index
        var param = signature.params[index];

        // TODO: replace the next filter loop
        var existing = entries.filter(function (entry) {
          return entry.param.overlapping(param);
        })[0];

        //var existing;
        //for (var j = 0; j < entries.length; j++) {
        //  if (entries[j].param.overlapping(param)) {
        //    existing = entries[j];
        //    break;
        //  }
        //}

        if (existing) {
          if (existing.param.varArgs) {
            throw new Error('Conflicting types "' + existing.param + '" and "' + param + '"');
          }
          existing.signatures.push(signature);
        }
        else {
          entries.push({
            param: param,
            signatures: [signature]
          });
        }
      }

      // parse the childs
      var childs = new Array(entries.length);
      for (i = 0; i < entries.length; i++) {
        var entry = entries[i];
        childs[i] = parseTree(entry.signatures, path.concat(entry.param))
      }

      return new Node(path, nodeSignature, childs);
    }

    /**
     * Generate an array like ['arg0', 'arg1', 'arg2']
     * @param {number} count Number of arguments to generate
     * @returns {Array} Returns an array with argument names
     */
    function getArgs(count) {
      // create an array with all argument names
      var args = [];
      for (var i = 0; i < count; i++) {
        args[i] = 'arg' + i;
      }

      return args;
    }

    /**
     * Compose a function from sub-functions each handling a single type signature.
     * Signatures:
     *   typed(signature: string, fn: function)
     *   typed(name: string, signature: string, fn: function)
     *   typed(signatures: Object.<string, function>)
     *   typed(name: string, signatures: Object.<string, function>)
     *
     * @param {string | null} name
     * @param {Object.<string, Function>} signatures
     * @return {Function} Returns the typed function
     * @private
     */
    function _typed(name, signatures) {
      var refs = new Refs();

      // parse signatures, expand them
      var _signatures = parseSignatures(signatures);
      if (_signatures.length == 0) {
        throw new Error('No signatures provided');
      }

      // parse signatures into a node tree
      var node = parseTree(_signatures, []);

      //var util = require('util');
      //console.log('ROOT');
      //console.log(util.inspect(node, { depth: null }));

      // generate code for the typed function
      var code = [];
      var _name = name || '';
      var _args = getArgs(maxParams(_signatures));
      code.push('function ' + _name + '(' + _args.join(', ') + ') {');
      code.push('  "use strict";');
      code.push('  var name = \'' + _name + '\';');
      code.push(node.toCode(refs, '  '));
      code.push('}');

      // generate body for the factory function
      var body = [
        refs.toCode(),
        'return ' + code.join('\n')
      ].join('\n');

      // evaluate the JavaScript code and attach function references
      var factory = (new Function(refs.name, 'createError', body));
      var fn = factory(refs, createError);

      //console.log('FN\n' + fn.toString()); // TODO: cleanup

      // attach the signatures with sub-functions to the constructed function
      fn.signatures = mapSignatures(_signatures);

      return fn;
    }

    /**
     * Calculate the maximum number of parameters in givens signatures
     * @param {Signature[]} signatures
     * @returns {number} The maximum number of parameters
     */
    function maxParams(signatures) {
      var max = 0;

      for (var i = 0; i < signatures.length; i++) {
        var len = signatures[i].params.length;
        if (len > max) {
          max = len;
        }
      }

      return max;
    }

    /**
     * Get the type of a value
     * @param {*} x
     * @returns {string} Returns a string with the type of value
     */
    function getTypeOf(x) {
      var obj;

      for (var i = 0; i < typed.types.length; i++) {
        var entry = typed.types[i];

        if (entry.name === 'Object') {
          // Array and Date are also Object, so test for Object afterwards
          obj = entry;
        }
        else {
          if (entry.test(x)) return entry.name;
        }
      }

      // at last, test whether an object
      if (obj && obj.test(x)) return obj.name;

      return 'unknown';
    }

    /**
     * Test whether an array contains some entry
     * @param {Array} array
     * @param {*} entry
     * @return {boolean} Returns true if array contains entry, false if not.
     */
    function contains(array, entry) {
      return array.indexOf(entry) !== -1;
    }

    // data type tests
    var types = [
      { name: 'number',    test: function (x) { return typeof x === 'number' } },
      { name: 'string',    test: function (x) { return typeof x === 'string' } },
      { name: 'boolean',   test: function (x) { return typeof x === 'boolean' } },
      { name: 'Function',  test: function (x) { return typeof x === 'function'} },
      { name: 'Array',     test: Array.isArray },
      { name: 'Date',      test: function (x) { return x instanceof Date } },
      { name: 'RegExp',    test: function (x) { return x instanceof RegExp } },
      { name: 'Object',    test: function (x) { return typeof x === 'object' } },
      { name: 'null',      test: function (x) { return x === null } },
      { name: 'undefined', test: function (x) { return x === undefined } }
    ];

    // configuration
    var config = {};

    // type conversions. Order is important
    var conversions = [];

    // types to be ignored
    var ignore = [];

    // temporary object for holding types and conversions, for constructing
    // the `typed` function itself
    // TODO: find a more elegant solution for this
    var typed = {
      config: config,
      types: types,
      conversions: conversions,
      ignore: ignore
    };

    /**
     * Construct the typed function itself with various signatures
     *
     * Signatures:
     *
     *   typed(signatures: Object.<string, function>)
     *   typed(name: string, signatures: Object.<string, function>)
     */
    typed = _typed('typed', {
      'Object': function (signatures) {
        var fns = [];
        for (var signature in signatures) {
          if (signatures.hasOwnProperty(signature)) {
            fns.push(signatures[signature]);
          }
        }
        var name = getName(fns);

        return _typed(name, signatures);
      },
      'string, Object': _typed,
      // TODO: add a signature 'Array.<function>'
      '...Function': function (fns) {
        var err;
        var name = getName(fns);
        var signatures = {};

        for (var i = 0; i < fns.length; i++) {
          var fn = fns[i];

          // test whether this is a typed-function
          if (!(typeof fn.signatures === 'object')) {
            err = new TypeError('Function is no typed-function (index: ' + i + ')');
            err.data = {index: i};
            throw err;
          }

          // merge the signatures
          for (var signature in fn.signatures) {
            if (fn.signatures.hasOwnProperty(signature)) {
              if (signatures.hasOwnProperty(signature)) {
                if (fn.signatures[signature] !== signatures[signature]) {
                  err = new Error('Signature "' + signature + '" is defined twice');
                  err.data = {signature: signature};
                  throw err;
                }
                // else: both signatures point to the same function, that's fine
              }
              else {
                signatures[signature] = fn.signatures[signature];
              }
            }
          }
        }

        return _typed(name, signatures);
      }
    });

    /**
     * Find a specific signature from a (composed) typed function, for
     * example:
     *
     *   typed.find(fn, ['number', 'string'])
     *   typed.find(fn, 'number, string')
     *
     * Function find only only works for exact matches.
     *
     * @param {Function} fn                   A typed-function
     * @param {string | string[]} signature   Signature to be found, can be
     *                                        an array or a comma separated string.
     * @return {Function}                     Returns the matching signature, or
     *                                        throws an errror when no signature
     *                                        is found.
     */
    function find (fn, signature) {
      if (!fn.signatures) {
        throw new TypeError('Function is no typed-function');
      }

      // normalize input
      var arr;
      if (typeof signature === 'string') {
        arr = signature.split(',');
        for (var i = 0; i < arr.length; i++) {
          arr[i] = arr[i].trim();
        }
      }
      else if (Array.isArray(signature)) {
        arr = signature;
      }
      else {
        throw new TypeError('String array or a comma separated string expected');
      }

      var str = arr.join(',');

      // find an exact match
      var match = fn.signatures[str];
      if (match) {
        return match;
      }

      // TODO: extend find to match non-exact signatures

      throw new TypeError('Signature not found (signature: ' + (fn.name || 'unnamed') + '(' + arr.join(', ') + '))');
    }

    /**
     * Convert a given value to another data type.
     * @param {*} value
     * @param {string} type
     */
    function convert (value, type) {
      var from = getTypeOf(value);

      // check conversion is needed
      if (type === from) {
        return value;
      }

      for (var i = 0; i < typed.conversions.length; i++) {
        var conversion = typed.conversions[i];
        if (conversion.from === from && conversion.to === type) {
          return conversion.convert(value);
        }
      }

      throw new Error('Cannot convert from ' + from + ' to ' + type);
    }

    // attach types and conversions to the final `typed` function
    typed.config = config;
    typed.types = types;
    typed.conversions = conversions;
    typed.ignore = ignore;
    typed.create = create;
    typed.find = find;
    typed.convert = convert;

    // add a type
    typed.addType = function (type) {
      if (!type || typeof type.name !== 'string' || typeof type.test !== 'function') {
        throw new TypeError('Object with properties {name: string, test: function} expected');
      }

      typed.types.push(type);
    };

    // add a conversion
    typed.addConversion = function (conversion) {
      if (!conversion
          || typeof conversion.from !== 'string'
          || typeof conversion.to !== 'string'
          || typeof conversion.convert !== 'function') {
        throw new TypeError('Object with properties {from: string, to: string, convert: function} expected');
      }

      typed.conversions.push(conversion);
    };

    return typed;
  }

  return create();
}));

},{}],493:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FullGenerationalReplacement = exports.FullGenerationalReplacement = function () {
    function FullGenerationalReplacement() {
        _classCallCheck(this, FullGenerationalReplacement);
    }

    _createClass(FullGenerationalReplacement, [{
        key: "select",
        value: function select(population, childGenerator) {
            var populationSize = population.length;
            var nextGeneration = new Array(populationSize);

            for (var i = 0; i != population.length; i++) {
                nextGeneration[i] = childGenerator.next().value;
            }

            return nextGeneration;
        }
    }]);

    return FullGenerationalReplacement;
}();

},{}],494:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Crossover = exports.Mutator = exports.Creator = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _mathjs = require('mathjs');

var math = _interopRequireWildcard(_mathjs);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Creator = exports.Creator = function () {
    function Creator(length) {
        var valueDistribution = arguments.length <= 1 || arguments[1] === undefined ? 0.5 : arguments[1];

        _classCallCheck(this, Creator);

        this.length = length;
        this.valueDistribution = valueDistribution;
    }

    _createClass(Creator, [{
        key: 'create',
        value: function create() {
            var _this = this;

            return Array.from({ length: this.length }, function () {
                return Math.random() < _this.valueDistribution;
            });
        }
    }]);

    return Creator;
}();

var Mutator = exports.Mutator = function () {
    function Mutator(bitMutationRate) {
        _classCallCheck(this, Mutator);

        this.bitMutationRate = bitMutationRate;
    }

    _createClass(Mutator, [{
        key: 'apply',
        value: function apply(value) {
            var _this2 = this;

            value.forEach(function (v, i, a) {
                if (Math.random() < _this2.bitMutationRate) {
                    a[i] = !a[i];
                }
            });

            return value;
        }
    }]);

    return Mutator;
}();

var Crossover = exports.Crossover = function () {
    function Crossover(minCrossoverPoints) {
        var maxCrossoverPoints = arguments.length <= 1 || arguments[1] === undefined ? undefined : arguments[1];

        _classCallCheck(this, Crossover);

        this.minCrossoverPoints = minCrossoverPoints;
        this.maxCrossoverPoints = maxCrossoverPoints || minCrossoverPoints;
    }

    _createClass(Crossover, [{
        key: 'apply',
        value: function apply(a, b) {
            var length = a.length;
            var point = math.randomInt(1, length);

            for (var i = point; i != length; i += 1) {
                var _ref = [b[i], a[i]];
                a[i] = _ref[0];
                b[i] = _ref[1];
            }

            return [a, b];
        }
    }]);

    return Crossover;
}();

},{"mathjs":4}],495:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tournament = exports.Sigma = exports.Rank = exports.FitnessProportionate = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _mathjs = require('mathjs');

var math = _interopRequireWildcard(_mathjs);

var _viUtility = require('../../vi-utility/vi-utility');

var utility = _interopRequireWildcard(_viUtility);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FitnessProportionate = exports.FitnessProportionate = function () {
    function FitnessProportionate() {
        _classCallCheck(this, FitnessProportionate);
    }

    _createClass(FitnessProportionate, [{
        key: 'prepare',
        value: function prepare(population) {
            var fitnessSum = population.reduce(function (sum, individual) {
                return sum + individual.fitness;
            }, 0);
            return { fitnessSum: fitnessSum };
        }
    }, {
        key: 'select',
        value: function select(population, artifacts) {
            var selectedIndividual = null;
            var randomFitnessSum = math.random(artifacts.fitnessSum);

            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = population[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var individual = _step.value;

                    if (individual.fitness > 0) {
                        selectedIndividual = individual;
                        randomFitnessSum -= individual.fitness;

                        if (randomFitnessSum < 0) {
                            break;
                        }
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            return selectedIndividual;
        }
    }]);

    return FitnessProportionate;
}();

var Rank = exports.Rank = function () {
    function Rank() {
        var maxExpectedValue = arguments.length <= 0 || arguments[0] === undefined ? 1.5 : arguments[0];

        _classCallCheck(this, Rank);

        this.maxExpectedValue = maxExpectedValue;
        this.minExpectedValue = 2 - maxExpectedValue;
    }

    _createClass(Rank, [{
        key: 'prepare',
        value: function prepare(population) {
            population.sort(function (a, b) {
                return a.fitness - b.fitness;
            });
        }
    }, {
        key: 'select',
        value: function select(population, artifacts) {
            var populationSize = population.length;

            var selectedIndividual = population[populationSize - 1];
            var randomExpectedValueSum = math.random(populationSize);

            for (var rankIndex = populationSize; rankIndex >= 1; rankIndex--) {
                var expectedValue = this.minExpectedValue + +(this.maxExpectedValue - this.minExpectedValue) * (rankIndex - 1) / (populationSize - 1);

                randomExpectedValueSum -= expectedValue;

                if (randomExpectedValueSum < 0) {
                    selectedIndividual = population[rankIndex - 1];
                    break;
                }
            }

            return selectedIndividual;
        }
    }]);

    return Rank;
}();

var Sigma = exports.Sigma = function () {
    function Sigma() {
        _classCallCheck(this, Sigma);
    }

    _createClass(Sigma, [{
        key: 'prepare',
        value: function prepare(population) {
            var fitnessValues = population.map(function (v) {
                return v.fitness;
            });
            var fitnessMean = math.mean(fitnessValues);
            var fitnessPStdDev = math.std(fitnessValues, 'uncorrected');

            var expectedValues = fitnessValues.map(function (fitnessValue) {
                return 1 + (fitnessPStdDev > 0 ? (fitnessValue - fitnessMean) / (2 * fitnessPStdDev) : 0);
            });

            var expectedValuesSum = expectedValues.reduce(function (sum, expectedValue) {
                return sum + expectedValue;
            }, 0);

            return { expectedValues: expectedValues, expectedValuesSum: expectedValuesSum };
        }
    }, {
        key: 'select',
        value: function select(population, artifacts) {
            var selectedIndividual = null;
            var randomExpectedValueSum = math.random(artifacts.expectedValuesSum);
            var populationSize = population.length;

            for (var i = 0; i < populationSize; i++) {
                var individual = population[i];
                var expectedValue = artifacts.expectedValues[i];

                selectedIndividual = individual;
                randomExpectedValueSum -= expectedValue;

                if (randomExpectedValueSum < 0) {
                    break;
                }
            }

            return selectedIndividual;
        }
    }]);

    return Sigma;
}();

var Tournament = exports.Tournament = function () {
    function Tournament(groupSize, randomSelectionProbability) {
        _classCallCheck(this, Tournament);

        this.groupSize = groupSize;
        this.randomSelectionProbability = randomSelectionProbability;
    }

    _createClass(Tournament, [{
        key: 'prepare',
        value: function prepare(population) {}
    }, {
        key: 'select',
        value: function select(population, artifacts) {
            var group = utility.sample(population, this.groupSize);

            // Either select the most fit individual by sorting the group,
            // otherwise select a random individual from the group by
            // not sorting.

            if (Math.random() >= this.randomSelectionProbability) {
                group.sort(function (a, b) {
                    return b.fitness - a.fitness;
                });
            }

            return group[0];
        }
    }]);

    return Tournament;
}();

},{"../../vi-utility/vi-utility":992,"mathjs":4}],496:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Sexual = exports.Sexual = function () {
    function Sexual(crossoverFunction, mutatorFunction) {
        _classCallCheck(this, Sexual);

        this.crossoverFunction = crossoverFunction;
        this.mutatorFunction = mutatorFunction;
    }

    _createClass(Sexual, [{
        key: "reproduce",
        value: function reproduce(parentSelector) {
            var firstParent = parentSelector.next().value;
            var secondParent = parentSelector.next().value;

            var firstChildGenotype = firstParent.genotype.slice();
            var secondChildGenotype = secondParent.genotype.slice();

            var _crossoverFunction$ap = this.crossoverFunction.apply(firstChildGenotype, secondChildGenotype);

            var _crossoverFunction$ap2 = _slicedToArray(_crossoverFunction$ap, 2);

            firstChildGenotype = _crossoverFunction$ap2[0];
            secondChildGenotype = _crossoverFunction$ap2[1];


            firstChildGenotype = this.mutatorFunction.apply(firstChildGenotype);
            secondChildGenotype = this.mutatorFunction.apply(secondChildGenotype);

            return [firstChildGenotype, secondChildGenotype];
        }
    }]);

    return Sexual;
}();

},{}],497:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.System = exports.Individual = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _mathjs = require('mathjs');

var math = _interopRequireWildcard(_mathjs);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Individual = exports.Individual = function Individual(genotype, phenotype, fitness) {
    _classCallCheck(this, Individual);

    this.genotype = genotype;
    this.phenotype = phenotype;
    this.fitness = fitness;
};

var System = exports.System = function () {
    function System(options) {
        _classCallCheck(this, System);

        this.populationSize = options.populationSize;
        this.elitismCount = options.elitismCount;
        this.genotypeCreationStrategy = options.genotypeCreationStrategy;
        this.parentSelectionStrategy = options.parentSelectionStrategy;
        this.adultSelectionStrategy = options.adultSelectionStrategy;
        this.reproductionStrategy = options.reproductionStrategy;
        this.fitnessEvaluationStrategy = options.fitnessEvaluationStrategy;
        this.developmentStrategy = options.developmentStrategy || null;

        this.population = this.createInitialPopulation();
        this.generation = 0;
    }

    _createClass(System, [{
        key: 'createInitialPopulation',
        value: function createInitialPopulation() {
            var population = new Array(this.populationSize);

            var individualGenerator = generator.individual(this.genotypeCreationStrategy, this.fitnessEvaluationStrategy, this.developmentStrategy);

            for (var i = 0; i != this.populationSize; i++) {
                population[i] = individualGenerator.next().value;
            }

            return population;
        }
    }, {
        key: 'evolve',
        value: function evolve() {
            var elitists = null;

            if (this.elitismCount) {
                this.population.sort(function (a, b) {
                    return b.fitness - a.fitness;
                });
                elitists = this.population.splice(0, this.elitismCount);
            }

            var artifacts = this.parentSelectionStrategy.prepare(this.population);
            var parentSelector = generator.parent(this.population, artifacts, this.parentSelectionStrategy);
            var childGenerator = generator.child(parentSelector, this.reproductionStrategy, this.developmentStrategy, this.fitnessEvaluationStrategy);

            var nextGeneration = this.adultSelectionStrategy.select(this.population, childGenerator);
            this.population = elitists ? elitists.concat(nextGeneration) : nextGeneration;

            this.generation++;
        }
    }, {
        key: 'stats',
        value: function stats() {
            var fitnessValues = this.population.map(function (v) {
                return v.fitness;
            });
            var fitnessMean = math.mean(fitnessValues);
            var fitnessPStdDev = math.std(fitnessValues, 'uncorrected');

            var bestIndividual = this.population.reduce(function (pv, cv) {
                return pv && pv.fitness > cv.fitness ? pv : cv;
            }, null);

            return {
                fitnessMean: fitnessMean,
                fitnessPStdDev: fitnessPStdDev,
                bestIndividual: bestIndividual,
                generation: this.generation };
        }
    }]);

    return System;
}();

var generator = Object.freeze(function () {
    var g = {};

    g.child = regeneratorRuntime.mark(function _callee(parentSelector, reproductionStrategy, developmentStrategy, fitnessEvaluationStrategy) {
        var childrenGenotypes, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, childGenotype, childPhenotype, childFitness;

        return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        if (!true) {
                            _context.next = 33;
                            break;
                        }

                        childrenGenotypes = reproductionStrategy.reproduce(parentSelector);
                        _iteratorNormalCompletion = true;
                        _didIteratorError = false;
                        _iteratorError = undefined;
                        _context.prev = 5;
                        _iterator = childrenGenotypes[Symbol.iterator]();

                    case 7:
                        if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                            _context.next = 17;
                            break;
                        }

                        childGenotype = _step.value;
                        childPhenotype = developmentStrategy ? developmentStrategy.develop(childGenotype) : childGenotype;

                        if (!childPhenotype) {
                            _context.next = 14;
                            break;
                        }

                        childFitness = fitnessEvaluationStrategy.evaluate(childPhenotype);
                        _context.next = 14;
                        return new Individual(childGenotype, childPhenotype, childFitness);

                    case 14:
                        _iteratorNormalCompletion = true;
                        _context.next = 7;
                        break;

                    case 17:
                        _context.next = 23;
                        break;

                    case 19:
                        _context.prev = 19;
                        _context.t0 = _context['catch'](5);
                        _didIteratorError = true;
                        _iteratorError = _context.t0;

                    case 23:
                        _context.prev = 23;
                        _context.prev = 24;

                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }

                    case 26:
                        _context.prev = 26;

                        if (!_didIteratorError) {
                            _context.next = 29;
                            break;
                        }

                        throw _iteratorError;

                    case 29:
                        return _context.finish(26);

                    case 30:
                        return _context.finish(23);

                    case 31:
                        _context.next = 0;
                        break;

                    case 33:
                    case 'end':
                        return _context.stop();
                }
            }
        }, _callee, this, [[5, 19, 23, 31], [24,, 26, 30]]);
    });

    g.individual = regeneratorRuntime.mark(function _callee2(genotypeCreationStrategy, fitnessEvaluationStrategy) {
        var developmentStrategy = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
        var genotype, phenotype, fitness;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
                switch (_context2.prev = _context2.next) {
                    case 0:
                        if (!true) {
                            _context2.next = 9;
                            break;
                        }

                        genotype = genotypeCreationStrategy.create();
                        phenotype = developmentStrategy ? developmentStrategy.develop(genotype) : genotype;

                        if (!phenotype) {
                            _context2.next = 7;
                            break;
                        }

                        fitness = fitnessEvaluationStrategy.evaluate(phenotype);
                        _context2.next = 7;
                        return new Individual(genotype, phenotype, fitness);

                    case 7:
                        _context2.next = 0;
                        break;

                    case 9:
                    case 'end':
                        return _context2.stop();
                }
            }
        }, _callee2, this);
    });

    g.parent = regeneratorRuntime.mark(function _callee3(population, artifacts, parentSelectionStrategy) {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
                switch (_context3.prev = _context3.next) {
                    case 0:
                        if (!true) {
                            _context3.next = 5;
                            break;
                        }

                        _context3.next = 3;
                        return parentSelectionStrategy.select(population, artifacts);

                    case 3:
                        _context3.next = 0;
                        break;

                    case 5:
                    case 'end':
                        return _context3.stop();
                }
            }
        }, _callee3, this);
    });

    return g;
}());

},{"mathjs":4}],498:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.System = exports.Individual = exports.parentSelection = exports.reproduction = exports.fixedBitVector = exports.adultSelection = undefined;

var _system = require('./src/system');

Object.defineProperty(exports, 'Individual', {
  enumerable: true,
  get: function get() {
    return _system.Individual;
  }
});
Object.defineProperty(exports, 'System', {
  enumerable: true,
  get: function get() {
    return _system.System;
  }
});

var _adult_selection = require('./src/adult_selection');

var adultSelection = _interopRequireWildcard(_adult_selection);

var _fixed_bit_vector = require('./src/fixed_bit_vector');

var fixedBitVector = _interopRequireWildcard(_fixed_bit_vector);

var _reproduction = require('./src/reproduction');

var reproduction = _interopRequireWildcard(_reproduction);

var _parent_selection = require('./src/parent_selection');

var parentSelection = _interopRequireWildcard(_parent_selection);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.adultSelection = adultSelection;
exports.fixedBitVector = fixedBitVector;
exports.reproduction = reproduction;
exports.parentSelection = parentSelection;

},{"./src/adult_selection":493,"./src/fixed_bit_vector":494,"./src/parent_selection":495,"./src/reproduction":496,"./src/system":497}],499:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Agent = exports.WorldEntity = exports.Heading = exports.Action = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.generateRandomWorld = generateRandomWorld;
exports.buildGameModelFromWorldModel = buildGameModelFromWorldModel;
exports.evaluateRun = evaluateRun;
exports.genotypeDevelopmentStrategy = genotypeDevelopmentStrategy;
exports.createFitnessFunction = createFitnessFunction;

var _viFlatlandWorld = require('../vi-flatland-world/vi-flatland-world');

var flatlandWorld = _interopRequireWildcard(_viFlatlandWorld);

var _viAnn = require('../vi-ann/vi-ann');

var ann = _interopRequireWildcard(_viAnn);

var _viEa = require('../vi-ea/vi-ea');

var ea = _interopRequireWildcard(_viEa);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Action = exports.Action = {
    stay: 1, moveLeft: 2, moveForward: 3, moveRight: 4
};

var Heading = exports.Heading = {
    up: 0, right: 1, down: 2, left: 3
};

var WorldEntity = exports.WorldEntity = Object.freeze({
    void: 0, food: 1, poison: 2
});

var utility = Object.freeze(function () {
    var u = {};

    u.clearGridNeighbors = function (cells, x, y, width, height) {
        if (x > 0) {
            cells[y * width + x - 1] = 0;
        }
        if (x < width - 1) {
            cells[y * width + x + 1] = 0;
        }
        if (y > 0) {
            cells[(y - 1) * width + x] = 0;
        }
        if (y < height - 1) {
            cells[(y + 1) * width + x] = 0;
        }
    };

    u.computeTargetCell = function (world, heading) {
        switch (heading) {
            case Heading.up:
                {
                    return { x: world.agent.x, y: (world.agent.y - 1 + world.height) % world.height };
                }
            case Heading.down:
                {
                    return { x: world.agent.x, y: (world.agent.y + 1) % world.height };
                }
            case Heading.left:
                {
                    return { x: (world.agent.x - 1 + world.width) % world.width, y: world.agent.y };
                }
            case Heading.right:
                {
                    return { x: (world.agent.x + 1) % world.width, y: world.agent.y };
                }
        }
    };

    u.getNeighborFromHeading = function (world, heading) {
        var target = u.computeTargetCell(world, heading);
        return world.cells[target.y * world.width + target.x];
    };

    u.getRandomIntInclusive = function (min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    };

    u.shuffle = function (array) {
        var currentIndex = array.length,
            temporaryValue,
            randomIndex;

        while (currentIndex !== 0) {
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex -= 1;

            temporaryValue = array[currentIndex];
            array[currentIndex] = array[randomIndex];
            array[randomIndex] = temporaryValue;
        }

        return array;
    };

    return u;
}());

function generateRandomWorld(worldWidth, worldHeight, foodProbability, poisonProbability) {
    var worldCellCount = worldWidth * worldHeight;
    var foodCellCount = Math.round(foodProbability * worldCellCount);
    var poisonCellCount = Math.round(poisonProbability * (worldCellCount - foodCellCount));

    var worldCells = new Array(worldCellCount).fill(WorldEntity.void);

    var availableCells = utility.shuffle(worldCells.map(function (cv, i) {
        return i;
    }));
    var foodCells = availableCells.splice(0, foodCellCount);
    var poisonCells = availableCells.splice(0, poisonCellCount);
    var agentCell = availableCells.splice(0, 1)[0];

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = foodCells[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var foodCell = _step.value;

            worldCells[foodCell] = WorldEntity.food;
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
        for (var _iterator2 = poisonCells[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var poisonCell = _step2.value;

            worldCells[poisonCell] = WorldEntity.poison;
        }
    } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
            }
        } finally {
            if (_didIteratorError2) {
                throw _iteratorError2;
            }
        }
    }

    return {
        cells: worldCells,
        width: worldWidth,
        height: worldHeight,
        foodProbability: foodProbability,
        poisonProbability: poisonProbability,
        foodCellCount: foodCellCount,
        poisonCellCount: poisonCellCount,
        agent: {
            x: agentCell % worldWidth,
            y: Math.floor(agentCell / worldWidth),
            heading: utility.getRandomIntInclusive(Heading.up, Heading.right)
        }
    };
}

function buildGameModelFromWorldModel(world) {
    var gridWidth = 2 * world.width - 1;
    var gridHeight = 2 * world.height - 1;
    var numGridCells = gridWidth * gridHeight;

    var gridCells = new Array(numGridCells).fill(flatlandWorld.GameEntity.void);

    // Place dots
    for (var y = 0; y < gridHeight; y += 1) {
        for (var x = 0; x < gridWidth; x += 1) {
            if (y % 2 == 0 || x % 2 == 0) {
                var index = y * gridWidth + x;
                gridCells[index] = flatlandWorld.GameEntity.dot;
            }
        }
    }

    // Place food and enemies

    // Food and enemy index is used such that the type of fruit
    // and type of enemy is chosen deterministically. Otherwise,
    // several runs with the same model will look confusing.
    var foodIndex = 0;
    var enemyIndex = 0;

    for (var row = 0; row < world.height; row += 1) {
        for (var column = 0; column < world.width; column += 1) {
            var worldIndex = row * world.width + column;
            var worldValue = world.cells[worldIndex];
            var gridIndex = 2 * row * gridWidth + 2 * column;

            var gridValue = flatlandWorld.GameEntity.void;

            if (worldValue === WorldEntity.food) {
                gridValue = flatlandWorld.Constants.food[foodIndex];
                foodIndex = (foodIndex + 1) % flatlandWorld.Constants.food.length;
            } else if (worldValue === WorldEntity.poison) {
                gridValue = flatlandWorld.Constants.enemies[enemyIndex];
                enemyIndex = (enemyIndex + 1) % flatlandWorld.Constants.enemies.length;
            }

            if (gridValue !== flatlandWorld.GameEntity.void) {
                gridCells[gridIndex] = gridValue;
                utility.clearGridNeighbors(gridCells, 2 * column, 2 * row, gridWidth, gridHeight);
            }
        }
    }

    gridCells[2 * world.agent.y * gridWidth + 2 * world.agent.x] = 0;
    utility.clearGridNeighbors(gridCells, 2 * world.agent.x, 2 * world.agent.y, gridWidth, gridHeight);

    return {
        cells: gridCells,
        width: gridWidth,
        height: gridHeight,
        agent: {
            x: world.agent.x * 2,
            y: world.agent.y * 2
        }
    };
}

function evaluateRun(world, agent, timeSteps) {
    world = JSON.parse(JSON.stringify(world));

    var foodEaten = 0,
        poisonEaten = 0,
        moves = [];

    while (timeSteps-- > 0) {
        var action = agent.act(world);

        if (action !== Action.stay) {
            switch (action) {
                case Action.moveLeft:
                    {
                        world.agent.heading = (world.agent.heading - 1 + 4) % 4;
                        break;
                    }
                case Action.moveRight:
                    {
                        world.agent.heading = (world.agent.heading + 1) % 4;
                        break;
                    }
            }

            switch (world.agent.heading) {
                case Heading.up:
                    {
                        moves.push(flatlandWorld.Action.moveUp);
                        world.agent.y = (world.agent.y - 1 + world.height) % world.height;
                        break;
                    }
                case Heading.down:
                    {
                        moves.push(flatlandWorld.Action.moveDown);
                        world.agent.y = (world.agent.y + 1) % world.height;
                        break;
                    }
                case Heading.left:
                    {
                        moves.push(flatlandWorld.Action.moveLeft);
                        world.agent.x = (world.agent.x - 1 + world.width) % world.width;
                        break;
                    }
                case Heading.right:
                    {
                        moves.push(flatlandWorld.Action.moveRight);
                        world.agent.x = (world.agent.x + 1) % world.width;
                        break;
                    }
            }

            var entityOffset = world.agent.y * world.width + world.agent.x;
            var entity = world.cells[entityOffset];

            switch (entity) {
                case WorldEntity.food:
                    {
                        foodEaten += 1;
                        break;
                    }
                case WorldEntity.poison:
                    {
                        poisonEaten += 1;
                        break;
                    }
            }

            world.cells[entityOffset] = WorldEntity.void;
        } else {
            moves.push(flatlandWorld.Action.stay);
        }
    }

    return { foodEaten: foodEaten, poisonEaten: poisonEaten, moves: moves };
}

var biasBits = 4;

function setBias(bias, genotype, inputNodes, layerNodes, genotypeLayerOffset) {
    for (var node = 0; node < layerNodes; node++) {
        var offset = genotypeLayerOffset + node * (2 * inputNodes + biasBits) + 2 * inputNodes;
        var isNegative = genotype[offset + 3];
        var value = (genotype[offset + 0] | 0) + (genotype[offset + 1] | 0) * 2 + (genotype[offset + 2] | 0) * 4;

        bias[node] = isNegative ? value - 8 : value;
    }
}

function setWeights(weights, genotype, inputNodes, layerNodes, genotypeOffset) {
    for (var node = 0; node < layerNodes; node++) {
        for (var inputNode = 0; inputNode < inputNodes; inputNode++) {
            var offset = genotypeOffset + node * (2 * inputNodes + biasBits) + 2 * inputNode;
            weights[node * inputNodes + inputNode] = (genotype[offset] | 0) * (genotype[offset + 1] ? 1 : -1);
        }
    }
}

var stepFunction = function stepFunction(stepValue) {
    return function (input) {
        return input >= stepValue ? 1 : 0;
    };
};

function genotypeDevelopmentStrategy(genotype) {
    var inputNodes = 6;
    var hiddenNodes = 6;
    var outputNodes = 3;

    var hiddenLayerBias = new Array(hiddenNodes);
    var hiddenLayerWeights = new Array(inputNodes * hiddenNodes);

    setWeights(hiddenLayerWeights, genotype, inputNodes, hiddenNodes, 0);
    setBias(hiddenLayerBias, genotype, inputNodes, hiddenNodes, 0);

    var outputLayerBias = new Array(outputNodes);
    var outputLayerWeights = new Array(hiddenNodes * outputNodes);

    setWeights(outputLayerWeights, genotype, hiddenNodes, outputNodes, 2 * inputNodes * hiddenNodes + biasBits * hiddenNodes);
    setBias(outputLayerBias, genotype, hiddenNodes, outputNodes, 2 * inputNodes * hiddenNodes + biasBits * hiddenNodes);

    return new ann.feedforward.Network([new ann.feedforward.Layer(hiddenLayerBias, hiddenLayerWeights, stepFunction(1)), new ann.feedforward.Layer(outputLayerBias, outputLayerWeights, stepFunction(1))]);
}

function createFitnessFunction(world) {
    return function (phenotype) {
        var agent = new Agent(phenotype);
        var result = evaluateRun(world, agent, 60);
        return (result.foodEaten - 5 * result.poisonEaten) / world.foodCellCount;
    };
}

var Agent = exports.Agent = function () {
    function Agent(network) {
        _classCallCheck(this, Agent);

        this.network = network;
    }

    _createClass(Agent, [{
        key: 'act',
        value: function act(world) {
            var leftHeading = (world.agent.heading - 1 + 4) % 4;
            var rightHeading = (world.agent.heading + 1) % 4;

            var leftValue = utility.getNeighborFromHeading(world, leftHeading);
            var forwardValue = utility.getNeighborFromHeading(world, world.agent.heading);
            var rightValue = utility.getNeighborFromHeading(world, rightHeading);

            var inputs = [forwardValue === WorldEntity.food ? 1 : 0, leftValue === WorldEntity.food ? 1 : 0, rightValue === WorldEntity.food ? 1 : 0, forwardValue === WorldEntity.poison ? 1 : 0, leftValue === WorldEntity.poison ? 1 : 0, rightValue === WorldEntity.poison ? 1 : 0];

            var outputs = this.network.evaluate(inputs);

            if (outputs[0] > outputs[1] && outputs[0] > outputs[2]) {
                return Action.moveForward;
            } else if (outputs[1] > outputs[0] && outputs[1] > outputs[2]) {
                return Action.moveLeft;
            } else if (outputs[2] > outputs[0] && outputs[2] > outputs[1]) {
                return Action.moveRight;
            } else {
                return Action.moveForward;
                //return Action.stay;
            }
        }
    }]);

    return Agent;
}();

//let system = new ea.System(
//{
//    populationSize:            50,
//    elitismCount:              5,
//    genotypeCreationStrategy:  new ea.fixedBitVector.Creator(144),
//    parentSelectionStrategy:   new ea.parentSelection.Sigma(),
//    adultSelectionStrategy:    new ea.adultSelection.FullGenerationalReplacement(),
//    reproductionStrategy:      new ea.reproduction.Sexual(
//        new ea.fixedBitVector.Crossover(1),
//        new ea.fixedBitVector.Mutator(0.005)),
//    fitnessEvaluationStrategy: { evaluate: fitnessFunction },
//    developmentStrategy: { develop: genotypeDevelopmentStrategy }
//});
//
//for (let generation = 0; generation <= 10000; generation += 1)
//{
//    const stats = system.stats();
//    console.log(`generation = ${generation} mean = ${stats.fitnessMean} std = ${stats.fitnessPStdDev} best = ${stats.bestIndividual.fitness} -> ${stats.bestIndividual.genotype}`);
//    system.evolve();
//}

//genotypeDevelopmentStrategy([false, false, true, true, false, false, true, true, true, false, false, true, false, false, true, true]);

//function translateRelativeActions(initialHeading, actions)
//{
//    actions = actions.slice();
//
//    while (actions.length > 0)
//    {
//        if (action
//    }
//
//
//}

//const world  = generateRandomWorld(10, 10, 1/3, 1/3);
//const result = evaluateRun(world, new Array(60).map(_ => utility.getRandomIntInclusive(Action.stay, Action.moveRight)));
//
//console.log(JSON.stringify(result));

//       this.model = buildGameModelFromWorldModel(
//            generateRandomWorld(options.worldWidth, options.worldHeight, 1/3, 1/3));

},{"../vi-ann/vi-ann":2,"../vi-ea/vi-ea":498,"../vi-flatland-world/vi-flatland-world":500}],500:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Action = exports.Action = Object.freeze({
    stay: 1,
    moveUp: 2,
    moveDown: 3,
    moveLeft: 4,
    moveRight: 5
});

var GameEntity = exports.GameEntity = Object.freeze({
    void: 0,
    dot: 1,
    cherry: 2,
    strawberry: 3,
    orange: 4,
    apple: 5,
    melon: 6,
    blinky: 7,
    pinky: 8,
    inky: 9,
    clyde: 10
});

var Constants = exports.Constants = Object.freeze(function () {
    var constants = {};

    constants.gameLoopDelayMs = 1000 / 30;

    constants.food = [GameEntity.cherry, GameEntity.strawberry, GameEntity.orange, GameEntity.apple, GameEntity.melon];

    constants.enemies = [GameEntity.blinky, GameEntity.pinky, GameEntity.inky, GameEntity.clyde];

    constants.spriteInfo = {};
    constants.spriteInfo[GameEntity.dot] = { x: 176, y: 0, frames: 1 };
    constants.spriteInfo[GameEntity.cherry] = { x: 192, y: 0, frames: 1 };
    constants.spriteInfo[GameEntity.strawberry] = { x: 192, y: 16, frames: 1 };
    constants.spriteInfo[GameEntity.orange] = { x: 192, y: 32, frames: 1 };
    constants.spriteInfo[GameEntity.apple] = { x: 192, y: 48, frames: 1 };
    constants.spriteInfo[GameEntity.melon] = { x: 192, y: 64, frames: 1 };
    constants.spriteInfo[GameEntity.blinky] = { x: 160, y: 16, frames: 2, divider: 8 };
    constants.spriteInfo[GameEntity.pinky] = { x: 160, y: 32, frames: 2, divider: 8 };
    constants.spriteInfo[GameEntity.inky] = { x: 160, y: 48, frames: 2, divider: 8 };
    constants.spriteInfo[GameEntity.clyde] = { x: 64, y: 64, frames: 8, divider: 8 };

    constants.agentSpriteInfo = {};
    constants.agentSpriteInfo[Action.stay] = { x: 0, y: 16, frames: 1 };
    constants.agentSpriteInfo[Action.moveUp] = { x: 0, y: 16, frames: 4 };
    constants.agentSpriteInfo[Action.moveDown] = { x: 0, y: 32, frames: 4 };
    constants.agentSpriteInfo[Action.moveLeft] = { x: 0, y: 48, frames: 4 };
    constants.agentSpriteInfo[Action.moveRight] = { x: 0, y: 64, frames: 4 };

    return constants;
}());

var Utility = exports.Utility = Object.freeze(function () {
    var utility = {};

    utility.getRandomIntInclusive = function (min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    };

    utility.isEnemy = function (entity) {
        return entity >= GameEntity.blinky && entity <= GameEntity.clyde;
    };

    utility.isFood = function (entity) {
        return entity >= GameEntity.cherry && entity <= GameEntity.melon;
    };

    return utility;
}());

var FlatlandWorld = exports.FlatlandWorld = function () {
    function FlatlandWorld(options) {
        _classCallCheck(this, FlatlandWorld);

        this.stepCallback = options.stepCallback || null;
        this.model = options.model || null;

        this.resetGameState();

        this.canvas = document.getElementById(options.elementId);
        this.context = this.canvas.getContext('2d');
        this.context.imageSmoothingEnabled = false;
        this.context.webkitImageSmoothingEnabled = false;
        this.context.mozImageSmoothingEnabled = false;
        this.context.fillStyle = 'black';

        this.sprites = new Image();
        this.sprites.onload = window.requestAnimationFrame.bind(window, this.update.bind(this));
        this.sprites.src = options.spriteSource || 'vi-flatland-world-sprites.png';
    }

    _createClass(FlatlandWorld, [{
        key: 'computeAgentSpritePositions',
        value: function computeAgentSpritePositions() {
            var x = this.model.agent.x * 8;
            var y = this.model.agent.y * 8;
            var cloneX = x,
                cloneY = y;

            var currentAction = this.currentAction;

            if (currentAction && currentAction !== Action.stay) {
                var movementOffset = 2 * this.movementIndex;

                switch (currentAction) {
                    case Action.moveUp:
                        {
                            y -= movementOffset;
                            cloneY = y < 0 ? y + 8 * (this.model.height + 1) : y;
                            break;
                        }
                    case Action.moveDown:
                        {
                            y += movementOffset;
                            cloneY = y >= 8 * (this.model.height - 1) ? y - 8 * (this.model.height + 1) : y;
                            break;
                        }
                    case Action.moveLeft:
                        {
                            x -= movementOffset;
                            cloneX = x < 0 ? x + 8 * (this.model.width + 1) : x;
                            break;
                        }
                    case Action.moveRight:
                        {
                            x += movementOffset;
                            cloneX = x >= 8 * (this.model.width - 1) ? x - 8 * (this.model.width + 1) : x;
                            break;
                        }
                }
            }

            return [{ x: x, y: y }, { x: cloneX, y: cloneY }];
        }
    }, {
        key: 'computeTargetCell',
        value: function computeTargetCell(position, action, steps) {
            switch (action) {
                case Action.stay:
                    {
                        return position;
                    }
                case Action.moveUp:
                    {
                        var y = position.y - steps;
                        return { x: position.x,
                            y: y < 0 ? y + this.model.height + 1 : y };
                    }
                case Action.moveDown:
                    {
                        var _y = position.y + steps;
                        return { x: position.x,
                            y: _y >= this.model.height ? _y - this.model.height - 1 : _y };
                    }
                case Action.moveLeft:
                    {
                        var x = position.x - steps;
                        return { x: x < 0 ? x + this.model.width + 1 : x,
                            y: position.y };
                    }
                case Action.moveRight:
                    {
                        var _x = position.x + steps;
                        return { x: _x >= this.model.width ? _x - this.model.width - 1 : _x,
                            y: position.y };
                    }
            }
        }
    }, {
        key: 'getCellIndex',
        value: function getCellIndex(position) {
            return position.y * this.model.width + position.x;
        }
    }, {
        key: 'perform',
        value: function perform(actions) {
            this.actionQueue.push.apply(this.actionQueue, actions);
        }
    }, {
        key: 'render',
        value: function render() {
            this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);

            for (var y = 0; y < this.model.height; y += 1) {
                for (var x = 0; x < this.model.height; x += 1) {
                    var index = y * this.model.width + x;
                    var entity = this.model.cells[index];

                    if (entity !== GameEntity.void) {
                        var animationOffset = this.animationOffsets[index];
                        this.renderSprite(Constants.spriteInfo[entity], x, y, animationOffset);
                    }
                }
            }

            var agentSpritePosition = void 0,
                agentCloneSpritePosition = void 0;

            var _computeAgentSpritePo = this.computeAgentSpritePositions();

            var _computeAgentSpritePo2 = _slicedToArray(_computeAgentSpritePo, 2);

            agentSpritePosition = _computeAgentSpritePo2[0];
            agentCloneSpritePosition = _computeAgentSpritePo2[1];

            this.renderAgent(agentSpritePosition, agentCloneSpritePosition);

            this.animationIndex += 1;
        }
    }, {
        key: 'renderAgent',
        value: function renderAgent(position, clonePosition) {
            var sprite = Constants.agentSpriteInfo[this.currentAction || Action.stay];
            var frameOffset = this.movementIndex % sprite.frames;
            var spriteAdjustedX = sprite.x + 16 * frameOffset;

            this.context.drawImage(this.sprites, spriteAdjustedX, sprite.y, 16, 16, position.x, position.y, 16, 16);

            this.context.drawImage(this.sprites, spriteAdjustedX, sprite.y, 16, 16, clonePosition.x, clonePosition.y, 16, 16);
        }
    }, {
        key: 'renderSprite',
        value: function renderSprite(sprite, x, y, animationOffset) {
            var frameOffset = 0;

            if (sprite.frames > 0) {
                var dividedAnimationIndex = sprite.divider ? Math.floor(this.animationIndex / sprite.divider) : this.animationIndex;
                frameOffset = (dividedAnimationIndex + (animationOffset || 0)) % sprite.frames;
            }

            this.context.drawImage(this.sprites, sprite.x + 16 * frameOffset, sprite.y, 16, 16, x * 8, y * 8, 16, 16);
        }
    }, {
        key: 'resetGameState',
        value: function resetGameState() {
            this.actionQueue = [];
            this.animationIndex = 0;
            this.currentAction = null;
            this.movementIndex = 0;
            this.stats = { foodEaten: 0, poisonEaten: 0, timeSteps: 0 };

            if (this.model) {
                this.animationOffsets = this.model.cells.map(function (v) {
                    return v in Constants.spriteInfo ? Utility.getRandomIntInclusive(0, Constants.spriteInfo[v].frames - 1) : 0;
                });
            }
        }
    }, {
        key: 'setGridValue',
        value: function setGridValue(position, value) {
            var index = this.getCellIndex(position);
            var previous = this.model.cells[index];
            this.model.cells[index] = value;
            return previous;
        }
    }, {
        key: 'setModel',
        value: function setModel(model) {
            this.model = JSON.parse(JSON.stringify(model));
            this.resetGameState();
        }
    }, {
        key: 'update',
        value: function update(currentTime) {
            if (this.model) {
                var ticks = currentTime && this.lastUpdateTime ? (currentTime - this.lastUpdateTime) / Constants.gameLoopDelayMs : 0;

                this.lastUpdateTime = currentTime;

                for (; ticks > 0; ticks -= 1) {
                    var currentAction = this.currentAction;

                    if (!currentAction) {
                        currentAction = this.currentAction = this.actionQueue.shift();
                    }

                    if (currentAction) {
                        var movementIndex = ++this.movementIndex;

                        if (currentAction !== Action.stay) {
                            if (movementIndex === 5) {
                                var dotCell = this.computeTargetCell(this.model.agent, currentAction, 1);
                                this.setGridValue(dotCell, GameEntity.void);
                            } else if (movementIndex === 8) {
                                var updatedAgentPosition = this.computeTargetCell(this.model.agent, currentAction, 2);

                                this.model.agent = updatedAgentPosition;

                                var eatenCellValue = this.setGridValue(updatedAgentPosition, GameEntity.void);

                                if (Utility.isFood(eatenCellValue)) {
                                    this.stats.foodEaten += 1;
                                } else if (Utility.isEnemy(eatenCellValue)) {
                                    this.stats.poisonEaten += 1;
                                }
                            }
                        }

                        if (movementIndex === 8) {
                            this.currentAction = null;
                            this.movementIndex = 0;

                            this.stats.timeSteps += 1;
                            this.stats.hasRemainingMoves = this.actionQueue.length !== 0;

                            if (this.stepCallback) {
                                this.stepCallback(this.stats);
                            }
                        }
                    }
                }

                this.render();
            }

            window.requestAnimationFrame(this.update.bind(this));
        }
    }]);

    return FlatlandWorld;
}();

},{}],501:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.flatlandWorld = exports.flatlandEa = exports.ea = exports.ann = undefined;

var _viAnn = require('../../vi-ann/vi-ann');

var ann = _interopRequireWildcard(_viAnn);

var _viEa = require('../../vi-ea/vi-ea');

var ea = _interopRequireWildcard(_viEa);

var _viFlatlandEa = require('../../vi-flatland-ea/vi-flatland-ea');

var flatlandEa = _interopRequireWildcard(_viFlatlandEa);

var _viFlatlandWorld = require('../../vi-flatland-world/vi-flatland-world');

var flatlandWorld = _interopRequireWildcard(_viFlatlandWorld);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.ann = ann;
exports.ea = ea;
exports.flatlandEa = flatlandEa;
exports.flatlandWorld = flatlandWorld;

},{"../../vi-ann/vi-ann":2,"../../vi-ea/vi-ea":498,"../../vi-flatland-ea/vi-flatland-ea":499,"../../vi-flatland-world/vi-flatland-world":500}],502:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./lib/core/core":505,"dup":3}],503:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"./core":502,"./lib":908,"dup":4}],504:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"./utils/array":960,"./utils/bignumber/constants":966,"./utils/object":983,"./version":986,"dup":5}],505:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"./../utils/emitter":978,"./../utils/object":983,"./function/config":506,"./function/import":507,"./typed":508,"dup":6}],506:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"../../utils/object":983,"dup":7}],507:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"../../error/ArgumentsError":509,"../../utils/object":983,"dup":8}],508:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./../utils/number":982,"dup":9,"typed-function":991}],509:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],510:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],511:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"dup":12}],512:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"./ArgumentsError":509,"./DimensionError":510,"./IndexError":511,"dup":13}],513:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"../utils/object":983,"../utils/string":984,"./function/parser":692,"dup":14}],514:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./parse":715,"dup":15}],515:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"dup":16}],516:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"dup":17}],517:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],518:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],519:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],520:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],521:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],522:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],523:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24}],524:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],525:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26}],526:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],527:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"dup":28}],528:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"dup":29}],529:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],530:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"dup":31}],531:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],532:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],533:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],534:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],535:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"dup":36}],536:[function(require,module,exports){
arguments[4][37][0].apply(exports,arguments)
},{"dup":37}],537:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"dup":38}],538:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"dup":39}],539:[function(require,module,exports){
arguments[4][40][0].apply(exports,arguments)
},{"dup":40}],540:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],541:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42}],542:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43}],543:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],544:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45}],545:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"dup":46}],546:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47}],547:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48}],548:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],549:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],550:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],551:[function(require,module,exports){
arguments[4][52][0].apply(exports,arguments)
},{"dup":52}],552:[function(require,module,exports){
arguments[4][53][0].apply(exports,arguments)
},{"dup":53}],553:[function(require,module,exports){
arguments[4][54][0].apply(exports,arguments)
},{"dup":54}],554:[function(require,module,exports){
arguments[4][55][0].apply(exports,arguments)
},{"dup":55}],555:[function(require,module,exports){
arguments[4][56][0].apply(exports,arguments)
},{"dup":56}],556:[function(require,module,exports){
arguments[4][57][0].apply(exports,arguments)
},{"dup":57}],557:[function(require,module,exports){
arguments[4][58][0].apply(exports,arguments)
},{"dup":58}],558:[function(require,module,exports){
arguments[4][59][0].apply(exports,arguments)
},{"dup":59}],559:[function(require,module,exports){
arguments[4][60][0].apply(exports,arguments)
},{"dup":60}],560:[function(require,module,exports){
arguments[4][61][0].apply(exports,arguments)
},{"dup":61}],561:[function(require,module,exports){
arguments[4][62][0].apply(exports,arguments)
},{"dup":62}],562:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"dup":63}],563:[function(require,module,exports){
arguments[4][64][0].apply(exports,arguments)
},{"dup":64}],564:[function(require,module,exports){
arguments[4][65][0].apply(exports,arguments)
},{"dup":65}],565:[function(require,module,exports){
arguments[4][66][0].apply(exports,arguments)
},{"dup":66}],566:[function(require,module,exports){
arguments[4][67][0].apply(exports,arguments)
},{"dup":67}],567:[function(require,module,exports){
arguments[4][68][0].apply(exports,arguments)
},{"dup":68}],568:[function(require,module,exports){
arguments[4][69][0].apply(exports,arguments)
},{"dup":69}],569:[function(require,module,exports){
arguments[4][70][0].apply(exports,arguments)
},{"dup":70}],570:[function(require,module,exports){
arguments[4][71][0].apply(exports,arguments)
},{"dup":71}],571:[function(require,module,exports){
arguments[4][72][0].apply(exports,arguments)
},{"dup":72}],572:[function(require,module,exports){
arguments[4][73][0].apply(exports,arguments)
},{"dup":73}],573:[function(require,module,exports){
arguments[4][74][0].apply(exports,arguments)
},{"dup":74}],574:[function(require,module,exports){
arguments[4][75][0].apply(exports,arguments)
},{"dup":75}],575:[function(require,module,exports){
arguments[4][76][0].apply(exports,arguments)
},{"dup":76}],576:[function(require,module,exports){
arguments[4][77][0].apply(exports,arguments)
},{"dup":77}],577:[function(require,module,exports){
arguments[4][78][0].apply(exports,arguments)
},{"dup":78}],578:[function(require,module,exports){
arguments[4][79][0].apply(exports,arguments)
},{"dup":79}],579:[function(require,module,exports){
arguments[4][80][0].apply(exports,arguments)
},{"dup":80}],580:[function(require,module,exports){
arguments[4][81][0].apply(exports,arguments)
},{"dup":81}],581:[function(require,module,exports){
arguments[4][82][0].apply(exports,arguments)
},{"dup":82}],582:[function(require,module,exports){
arguments[4][83][0].apply(exports,arguments)
},{"dup":83}],583:[function(require,module,exports){
arguments[4][84][0].apply(exports,arguments)
},{"dup":84}],584:[function(require,module,exports){
arguments[4][85][0].apply(exports,arguments)
},{"dup":85}],585:[function(require,module,exports){
arguments[4][86][0].apply(exports,arguments)
},{"dup":86}],586:[function(require,module,exports){
arguments[4][87][0].apply(exports,arguments)
},{"dup":87}],587:[function(require,module,exports){
arguments[4][88][0].apply(exports,arguments)
},{"dup":88}],588:[function(require,module,exports){
arguments[4][89][0].apply(exports,arguments)
},{"dup":89}],589:[function(require,module,exports){
arguments[4][90][0].apply(exports,arguments)
},{"dup":90}],590:[function(require,module,exports){
arguments[4][91][0].apply(exports,arguments)
},{"dup":91}],591:[function(require,module,exports){
arguments[4][92][0].apply(exports,arguments)
},{"dup":92}],592:[function(require,module,exports){
arguments[4][93][0].apply(exports,arguments)
},{"dup":93}],593:[function(require,module,exports){
arguments[4][94][0].apply(exports,arguments)
},{"dup":94}],594:[function(require,module,exports){
arguments[4][95][0].apply(exports,arguments)
},{"dup":95}],595:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],596:[function(require,module,exports){
arguments[4][97][0].apply(exports,arguments)
},{"dup":97}],597:[function(require,module,exports){
arguments[4][98][0].apply(exports,arguments)
},{"dup":98}],598:[function(require,module,exports){
arguments[4][99][0].apply(exports,arguments)
},{"dup":99}],599:[function(require,module,exports){
arguments[4][100][0].apply(exports,arguments)
},{"dup":100}],600:[function(require,module,exports){
arguments[4][101][0].apply(exports,arguments)
},{"dup":101}],601:[function(require,module,exports){
arguments[4][102][0].apply(exports,arguments)
},{"dup":102}],602:[function(require,module,exports){
arguments[4][103][0].apply(exports,arguments)
},{"dup":103}],603:[function(require,module,exports){
arguments[4][104][0].apply(exports,arguments)
},{"dup":104}],604:[function(require,module,exports){
arguments[4][105][0].apply(exports,arguments)
},{"dup":105}],605:[function(require,module,exports){
arguments[4][106][0].apply(exports,arguments)
},{"dup":106}],606:[function(require,module,exports){
arguments[4][107][0].apply(exports,arguments)
},{"dup":107}],607:[function(require,module,exports){
arguments[4][108][0].apply(exports,arguments)
},{"dup":108}],608:[function(require,module,exports){
arguments[4][109][0].apply(exports,arguments)
},{"dup":109}],609:[function(require,module,exports){
arguments[4][110][0].apply(exports,arguments)
},{"dup":110}],610:[function(require,module,exports){
arguments[4][111][0].apply(exports,arguments)
},{"dup":111}],611:[function(require,module,exports){
arguments[4][112][0].apply(exports,arguments)
},{"dup":112}],612:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"dup":113}],613:[function(require,module,exports){
arguments[4][114][0].apply(exports,arguments)
},{"dup":114}],614:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"dup":115}],615:[function(require,module,exports){
arguments[4][116][0].apply(exports,arguments)
},{"dup":116}],616:[function(require,module,exports){
arguments[4][117][0].apply(exports,arguments)
},{"dup":117}],617:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"dup":118}],618:[function(require,module,exports){
arguments[4][119][0].apply(exports,arguments)
},{"dup":119}],619:[function(require,module,exports){
arguments[4][120][0].apply(exports,arguments)
},{"dup":120}],620:[function(require,module,exports){
arguments[4][121][0].apply(exports,arguments)
},{"dup":121}],621:[function(require,module,exports){
arguments[4][122][0].apply(exports,arguments)
},{"dup":122}],622:[function(require,module,exports){
arguments[4][123][0].apply(exports,arguments)
},{"dup":123}],623:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],624:[function(require,module,exports){
arguments[4][125][0].apply(exports,arguments)
},{"dup":125}],625:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"dup":126}],626:[function(require,module,exports){
arguments[4][127][0].apply(exports,arguments)
},{"dup":127}],627:[function(require,module,exports){
arguments[4][128][0].apply(exports,arguments)
},{"dup":128}],628:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129}],629:[function(require,module,exports){
arguments[4][130][0].apply(exports,arguments)
},{"dup":130}],630:[function(require,module,exports){
arguments[4][131][0].apply(exports,arguments)
},{"dup":131}],631:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"dup":132}],632:[function(require,module,exports){
arguments[4][133][0].apply(exports,arguments)
},{"dup":133}],633:[function(require,module,exports){
arguments[4][134][0].apply(exports,arguments)
},{"dup":134}],634:[function(require,module,exports){
arguments[4][135][0].apply(exports,arguments)
},{"dup":135}],635:[function(require,module,exports){
arguments[4][136][0].apply(exports,arguments)
},{"dup":136}],636:[function(require,module,exports){
arguments[4][137][0].apply(exports,arguments)
},{"dup":137}],637:[function(require,module,exports){
arguments[4][138][0].apply(exports,arguments)
},{"dup":138}],638:[function(require,module,exports){
arguments[4][139][0].apply(exports,arguments)
},{"dup":139}],639:[function(require,module,exports){
arguments[4][140][0].apply(exports,arguments)
},{"dup":140}],640:[function(require,module,exports){
arguments[4][141][0].apply(exports,arguments)
},{"dup":141}],641:[function(require,module,exports){
arguments[4][142][0].apply(exports,arguments)
},{"dup":142}],642:[function(require,module,exports){
arguments[4][143][0].apply(exports,arguments)
},{"dup":143}],643:[function(require,module,exports){
arguments[4][144][0].apply(exports,arguments)
},{"dup":144}],644:[function(require,module,exports){
arguments[4][145][0].apply(exports,arguments)
},{"dup":145}],645:[function(require,module,exports){
arguments[4][146][0].apply(exports,arguments)
},{"dup":146}],646:[function(require,module,exports){
arguments[4][147][0].apply(exports,arguments)
},{"dup":147}],647:[function(require,module,exports){
arguments[4][148][0].apply(exports,arguments)
},{"dup":148}],648:[function(require,module,exports){
arguments[4][149][0].apply(exports,arguments)
},{"dup":149}],649:[function(require,module,exports){
arguments[4][150][0].apply(exports,arguments)
},{"dup":150}],650:[function(require,module,exports){
arguments[4][151][0].apply(exports,arguments)
},{"dup":151}],651:[function(require,module,exports){
arguments[4][152][0].apply(exports,arguments)
},{"dup":152}],652:[function(require,module,exports){
arguments[4][153][0].apply(exports,arguments)
},{"dup":153}],653:[function(require,module,exports){
arguments[4][154][0].apply(exports,arguments)
},{"dup":154}],654:[function(require,module,exports){
arguments[4][155][0].apply(exports,arguments)
},{"dup":155}],655:[function(require,module,exports){
arguments[4][156][0].apply(exports,arguments)
},{"dup":156}],656:[function(require,module,exports){
arguments[4][157][0].apply(exports,arguments)
},{"dup":157}],657:[function(require,module,exports){
arguments[4][158][0].apply(exports,arguments)
},{"dup":158}],658:[function(require,module,exports){
arguments[4][159][0].apply(exports,arguments)
},{"dup":159}],659:[function(require,module,exports){
arguments[4][160][0].apply(exports,arguments)
},{"dup":160}],660:[function(require,module,exports){
arguments[4][161][0].apply(exports,arguments)
},{"dup":161}],661:[function(require,module,exports){
arguments[4][162][0].apply(exports,arguments)
},{"dup":162}],662:[function(require,module,exports){
arguments[4][163][0].apply(exports,arguments)
},{"dup":163}],663:[function(require,module,exports){
arguments[4][164][0].apply(exports,arguments)
},{"dup":164}],664:[function(require,module,exports){
arguments[4][165][0].apply(exports,arguments)
},{"dup":165}],665:[function(require,module,exports){
arguments[4][166][0].apply(exports,arguments)
},{"dup":166}],666:[function(require,module,exports){
arguments[4][167][0].apply(exports,arguments)
},{"dup":167}],667:[function(require,module,exports){
arguments[4][168][0].apply(exports,arguments)
},{"dup":168}],668:[function(require,module,exports){
arguments[4][169][0].apply(exports,arguments)
},{"dup":169}],669:[function(require,module,exports){
arguments[4][170][0].apply(exports,arguments)
},{"dup":170}],670:[function(require,module,exports){
arguments[4][171][0].apply(exports,arguments)
},{"dup":171}],671:[function(require,module,exports){
arguments[4][172][0].apply(exports,arguments)
},{"dup":172}],672:[function(require,module,exports){
arguments[4][173][0].apply(exports,arguments)
},{"dup":173}],673:[function(require,module,exports){
arguments[4][174][0].apply(exports,arguments)
},{"dup":174}],674:[function(require,module,exports){
arguments[4][175][0].apply(exports,arguments)
},{"dup":175}],675:[function(require,module,exports){
arguments[4][176][0].apply(exports,arguments)
},{"dup":176}],676:[function(require,module,exports){
arguments[4][177][0].apply(exports,arguments)
},{"dup":177}],677:[function(require,module,exports){
arguments[4][178][0].apply(exports,arguments)
},{"dup":178}],678:[function(require,module,exports){
arguments[4][179][0].apply(exports,arguments)
},{"dup":179}],679:[function(require,module,exports){
arguments[4][180][0].apply(exports,arguments)
},{"dup":180}],680:[function(require,module,exports){
arguments[4][181][0].apply(exports,arguments)
},{"dup":181}],681:[function(require,module,exports){
arguments[4][182][0].apply(exports,arguments)
},{"dup":182}],682:[function(require,module,exports){
arguments[4][183][0].apply(exports,arguments)
},{"dup":183}],683:[function(require,module,exports){
arguments[4][184][0].apply(exports,arguments)
},{"dup":184}],684:[function(require,module,exports){
arguments[4][185][0].apply(exports,arguments)
},{"dup":185}],685:[function(require,module,exports){
arguments[4][186][0].apply(exports,arguments)
},{"dup":186}],686:[function(require,module,exports){
arguments[4][187][0].apply(exports,arguments)
},{"./constants/Infinity":515,"./constants/LN10":516,"./constants/LN2":517,"./constants/LOG10E":518,"./constants/LOG2E":519,"./constants/NaN":520,"./constants/SQRT1_2":521,"./constants/SQRT2":522,"./constants/e":523,"./constants/false":524,"./constants/i":525,"./constants/null":526,"./constants/phi":527,"./constants/pi":528,"./constants/tau":529,"./constants/true":530,"./constants/version":531,"./construction/bignumber":532,"./construction/boolean":533,"./construction/complex":534,"./construction/fraction":535,"./construction/index":536,"./construction/matrix":537,"./construction/number":538,"./construction/sparse":539,"./construction/string":540,"./construction/unit":541,"./core/config":542,"./core/import":543,"./core/typed":544,"./function/algebra/lsolve":545,"./function/algebra/lup":546,"./function/algebra/lusolve":547,"./function/algebra/slu":548,"./function/algebra/usolve":549,"./function/arithmetic/abs":550,"./function/arithmetic/add":551,"./function/arithmetic/cbrt":552,"./function/arithmetic/ceil":553,"./function/arithmetic/cube":554,"./function/arithmetic/divide":555,"./function/arithmetic/dotDivide":556,"./function/arithmetic/dotMultiply":557,"./function/arithmetic/dotPow":558,"./function/arithmetic/exp":559,"./function/arithmetic/fix":560,"./function/arithmetic/floor":561,"./function/arithmetic/gcd":562,"./function/arithmetic/hypot":563,"./function/arithmetic/lcm":564,"./function/arithmetic/log":565,"./function/arithmetic/log10":566,"./function/arithmetic/mod":567,"./function/arithmetic/multiply":568,"./function/arithmetic/norm":569,"./function/arithmetic/nthRoot":570,"./function/arithmetic/pow":571,"./function/arithmetic/round":572,"./function/arithmetic/sign":573,"./function/arithmetic/sqrt":574,"./function/arithmetic/square":575,"./function/arithmetic/subtract":576,"./function/arithmetic/unaryMinus":577,"./function/arithmetic/unaryPlus":578,"./function/arithmetic/xgcd":579,"./function/bitwise/bitAnd":580,"./function/bitwise/bitNot":581,"./function/bitwise/bitOr":582,"./function/bitwise/bitXor":583,"./function/bitwise/leftShift":584,"./function/bitwise/rightArithShift":585,"./function/bitwise/rightLogShift":586,"./function/combinatorics/bellNumbers":587,"./function/combinatorics/catalan":588,"./function/combinatorics/composition":589,"./function/combinatorics/stirlingS2":590,"./function/complex/arg":591,"./function/complex/conj":592,"./function/complex/im":593,"./function/complex/re":594,"./function/expression/eval":595,"./function/expression/help":596,"./function/geometry/distance":597,"./function/geometry/intersect":598,"./function/logical/and":599,"./function/logical/not":600,"./function/logical/or":601,"./function/logical/xor":602,"./function/matrix/concat":603,"./function/matrix/cross":604,"./function/matrix/det":605,"./function/matrix/diag":606,"./function/matrix/dot":607,"./function/matrix/eye":608,"./function/matrix/filter":609,"./function/matrix/flatten":610,"./function/matrix/forEach":611,"./function/matrix/inv":612,"./function/matrix/map":613,"./function/matrix/ones":614,"./function/matrix/partitionSelect":615,"./function/matrix/range":616,"./function/matrix/resize":617,"./function/matrix/size":618,"./function/matrix/sort":619,"./function/matrix/squeeze":620,"./function/matrix/subset":621,"./function/matrix/trace":622,"./function/matrix/transpose":623,"./function/matrix/zeros":624,"./function/probability/combinations":625,"./function/probability/factorial":626,"./function/probability/gamma":627,"./function/probability/kldivergence":628,"./function/probability/multinomial":629,"./function/probability/permutations":630,"./function/probability/pickRandom":631,"./function/probability/random":632,"./function/probability/randomInt":633,"./function/relational/compare":634,"./function/relational/deepEqual":635,"./function/relational/equal":636,"./function/relational/larger":637,"./function/relational/largerEq":638,"./function/relational/smaller":639,"./function/relational/smallerEq":640,"./function/relational/unequal":641,"./function/statistics/max":642,"./function/statistics/mean":643,"./function/statistics/median":644,"./function/statistics/min":645,"./function/statistics/mode":646,"./function/statistics/prod":647,"./function/statistics/quantileSeq":648,"./function/statistics/std":649,"./function/statistics/sum":650,"./function/statistics/var":651,"./function/trigonometry/acos":652,"./function/trigonometry/acosh":653,"./function/trigonometry/acot":654,"./function/trigonometry/acoth":655,"./function/trigonometry/acsc":656,"./function/trigonometry/acsch":657,"./function/trigonometry/asec":658,"./function/trigonometry/asech":659,"./function/trigonometry/asin":660,"./function/trigonometry/asinh":661,"./function/trigonometry/atan":662,"./function/trigonometry/atan2":663,"./function/trigonometry/atanh":664,"./function/trigonometry/cos":665,"./function/trigonometry/cosh":666,"./function/trigonometry/cot":667,"./function/trigonometry/coth":668,"./function/trigonometry/csc":669,"./function/trigonometry/csch":670,"./function/trigonometry/sec":671,"./function/trigonometry/sech":672,"./function/trigonometry/sin":673,"./function/trigonometry/sinh":674,"./function/trigonometry/tan":675,"./function/trigonometry/tanh":676,"./function/units/to":677,"./function/utils/clone":678,"./function/utils/format":679,"./function/utils/isInteger":680,"./function/utils/isNegative":681,"./function/utils/isNumeric":682,"./function/utils/isPositive":683,"./function/utils/isZero":684,"./function/utils/typeof":685,"dup":187}],687:[function(require,module,exports){
arguments[4][188][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"../parse":715,"dup":188}],688:[function(require,module,exports){
arguments[4][189][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"../parse":715,"dup":189}],689:[function(require,module,exports){
arguments[4][190][0].apply(exports,arguments)
},{"../docs":686,"dup":190}],690:[function(require,module,exports){
arguments[4][191][0].apply(exports,arguments)
},{"./compile":687,"./eval":688,"./help":689,"./parse":691,"./parser":692,"dup":191}],691:[function(require,module,exports){
arguments[4][192][0].apply(exports,arguments)
},{"../parse":715,"dup":192}],692:[function(require,module,exports){
arguments[4][193][0].apply(exports,arguments)
},{"../Parser":514,"dup":193}],693:[function(require,module,exports){
arguments[4][194][0].apply(exports,arguments)
},{"./Help":513,"./Parser":514,"./docs":686,"./function":690,"./node":711,"./parse":715,"./transform":720,"dup":194}],694:[function(require,module,exports){
arguments[4][195][0].apply(exports,arguments)
},{"dup":195}],695:[function(require,module,exports){
arguments[4][196][0].apply(exports,arguments)
},{"./Node":704,"./utils/access":712,"dup":196}],696:[function(require,module,exports){
arguments[4][197][0].apply(exports,arguments)
},{"./Node":704,"dup":197}],697:[function(require,module,exports){
arguments[4][198][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../utils/latex":981,"../keywords":694,"../operators":714,"./ArrayNode":696,"./Node":704,"./utils/access":712,"./utils/assign":713,"dup":198}],698:[function(require,module,exports){
arguments[4][199][0].apply(exports,arguments)
},{"../../type/resultset/ResultSet":952,"./Node":704,"dup":199}],699:[function(require,module,exports){
arguments[4][200][0].apply(exports,arguments)
},{"../../utils/latex":981,"../operators":714,"./Node":704,"dup":200}],700:[function(require,module,exports){
arguments[4][201][0].apply(exports,arguments)
},{"../../utils/types":985,"./Node":704,"dup":201}],701:[function(require,module,exports){
arguments[4][202][0].apply(exports,arguments)
},{"../../utils/latex":981,"../keywords":694,"../operators":714,"./Node":704,"dup":202}],702:[function(require,module,exports){
arguments[4][203][0].apply(exports,arguments)
},{"../../utils/latex":981,"./Node":704,"./SymbolNode":709,"dup":203}],703:[function(require,module,exports){
arguments[4][204][0].apply(exports,arguments)
},{"../../type/matrix/Range":930,"./Node":704,"./RangeNode":708,"./SymbolNode":709,"dup":204}],704:[function(require,module,exports){
arguments[4][205][0].apply(exports,arguments)
},{"../../utils/object":983,"../keywords":694,"dup":205}],705:[function(require,module,exports){
arguments[4][206][0].apply(exports,arguments)
},{"../../utils/string":984,"./Node":704,"dup":206}],706:[function(require,module,exports){
arguments[4][207][0].apply(exports,arguments)
},{"../../utils/latex":981,"../operators":714,"./ConstantNode":700,"./FunctionNode":702,"./Node":704,"./SymbolNode":709,"dup":207}],707:[function(require,module,exports){
arguments[4][208][0].apply(exports,arguments)
},{"./Node":704,"dup":208}],708:[function(require,module,exports){
arguments[4][209][0].apply(exports,arguments)
},{"../operators":714,"./Node":704,"dup":209}],709:[function(require,module,exports){
arguments[4][210][0].apply(exports,arguments)
},{"../../type/unit/Unit":955,"../../utils/latex":981,"./Node":704,"dup":210}],710:[function(require,module,exports){
arguments[4][211][0].apply(exports,arguments)
},{"dup":211}],711:[function(require,module,exports){
arguments[4][212][0].apply(exports,arguments)
},{"./AccessorNode":695,"./ArrayNode":696,"./AssignmentNode":697,"./BlockNode":698,"./ConditionalNode":699,"./ConstantNode":700,"./FunctionAssignmentNode":701,"./FunctionNode":702,"./IndexNode":703,"./Node":704,"./ObjectNode":705,"./OperatorNode":706,"./ParenthesisNode":707,"./RangeNode":708,"./SymbolNode":709,"./UpdateNode":710,"dup":212}],712:[function(require,module,exports){
arguments[4][213][0].apply(exports,arguments)
},{"../../../function/matrix/subset":833,"../../../type/matrix/function/matrix":934,"../../transform/error.transform":717,"dup":213}],713:[function(require,module,exports){
arguments[4][214][0].apply(exports,arguments)
},{"../../../function/matrix/subset":833,"../../../type/matrix/function/matrix":934,"../../transform/error.transform":717,"dup":214}],714:[function(require,module,exports){
arguments[4][215][0].apply(exports,arguments)
},{"dup":215}],715:[function(require,module,exports){
arguments[4][216][0].apply(exports,arguments)
},{"../error/ArgumentsError":509,"../utils/collection/deepMap":974,"./node/AccessorNode":695,"./node/ArrayNode":696,"./node/AssignmentNode":697,"./node/BlockNode":698,"./node/ConditionalNode":699,"./node/ConstantNode":700,"./node/FunctionAssignmentNode":701,"./node/FunctionNode":702,"./node/IndexNode":703,"./node/ObjectNode":705,"./node/OperatorNode":706,"./node/ParenthesisNode":707,"./node/RangeNode":708,"./node/SymbolNode":709,"dup":216}],716:[function(require,module,exports){
arguments[4][217][0].apply(exports,arguments)
},{"../../function/matrix/concat":814,"./error.transform":717,"dup":217}],717:[function(require,module,exports){
arguments[4][218][0].apply(exports,arguments)
},{"../../error/IndexError":511,"dup":218}],718:[function(require,module,exports){
arguments[4][219][0].apply(exports,arguments)
},{"../../function/matrix/filter":820,"../node/SymbolNode":709,"dup":219}],719:[function(require,module,exports){
arguments[4][220][0].apply(exports,arguments)
},{"../../function/matrix/forEach":822,"dup":220}],720:[function(require,module,exports){
arguments[4][221][0].apply(exports,arguments)
},{"./concat.transform":716,"./filter.transform":718,"./forEach.transform":719,"./index.transform":721,"./map.transform":722,"./max.transform":723,"./mean.transform":724,"./min.transform":725,"./range.transform":726,"./subset.transform":727,"dup":221}],721:[function(require,module,exports){
arguments[4][222][0].apply(exports,arguments)
},{"../../type/matrix/function/index":933,"dup":222}],722:[function(require,module,exports){
arguments[4][223][0].apply(exports,arguments)
},{"../../function/matrix/map":825,"../../type/matrix/function/matrix":934,"dup":223}],723:[function(require,module,exports){
arguments[4][224][0].apply(exports,arguments)
},{"../../function/statistics/max":859,"../../utils/collection/isCollection":975,"./error.transform":717,"dup":224}],724:[function(require,module,exports){
arguments[4][225][0].apply(exports,arguments)
},{"../../function/statistics/mean":860,"../../utils/collection/isCollection":975,"./error.transform":717,"dup":225}],725:[function(require,module,exports){
arguments[4][226][0].apply(exports,arguments)
},{"../../function/statistics/min":862,"../../utils/collection/isCollection":975,"./error.transform":717,"dup":226}],726:[function(require,module,exports){
arguments[4][227][0].apply(exports,arguments)
},{"../../function/matrix/range":828,"dup":227}],727:[function(require,module,exports){
arguments[4][228][0].apply(exports,arguments)
},{"../../function/matrix/subset":833,"./error.transform":717,"dup":228}],728:[function(require,module,exports){
arguments[4][229][0].apply(exports,arguments)
},{"../../../type/matrix/function/matrix":934,"../../../utils/index":980,"../../arithmetic/abs":753,"../../arithmetic/addScalar":755,"../../arithmetic/divideScalar":760,"../../arithmetic/multiplyScalar":775,"../../arithmetic/subtract":783,"../../arithmetic/unaryMinus":784,"../../relational/equalScalar":851,"../../relational/larger":853,"dup":229}],729:[function(require,module,exports){
arguments[4][230][0].apply(exports,arguments)
},{"../../../utils/index":980,"../../algebra/sparse/cs_lu":743,"../../algebra/sparse/cs_sqr":750,"dup":230}],730:[function(require,module,exports){
arguments[4][231][0].apply(exports,arguments)
},{"./decomposition/lup":728,"./decomposition/slu":729,"./solver/lsolve":731,"./solver/lusolve":732,"./solver/usolve":733,"dup":231}],731:[function(require,module,exports){
arguments[4][232][0].apply(exports,arguments)
},{"../../../type/matrix/function/matrix":934,"../../arithmetic/divideScalar":760,"../../arithmetic/multiplyScalar":775,"../../arithmetic/subtract":783,"../../relational/equalScalar":851,"./utils/solveValidation":734,"dup":232}],732:[function(require,module,exports){
arguments[4][233][0].apply(exports,arguments)
},{"../../../type/matrix/function/matrix":934,"../decomposition/lup":728,"../decomposition/slu":729,"../sparse/cs_ipvec":741,"./lsolve":731,"./usolve":733,"./utils/solveValidation":734,"dup":233}],733:[function(require,module,exports){
arguments[4][234][0].apply(exports,arguments)
},{"../../../type/matrix/function/matrix":934,"../../arithmetic/divideScalar":760,"../../arithmetic/multiplyScalar":775,"../../arithmetic/subtract":783,"../../relational/equalScalar":851,"./utils/solveValidation":734,"dup":234}],734:[function(require,module,exports){
arguments[4][235][0].apply(exports,arguments)
},{"../../../../utils/index":980,"dup":235}],735:[function(require,module,exports){
arguments[4][236][0].apply(exports,arguments)
},{"../../arithmetic/add":754,"../../arithmetic/multiply":774,"../../matrix/transpose":835,"./cs_fkeep":739,"./cs_flip":740,"./cs_tdfs":751,"dup":236}],736:[function(require,module,exports){
arguments[4][237][0].apply(exports,arguments)
},{"../../matrix/transpose":835,"./cs_leaf":742,"dup":237}],737:[function(require,module,exports){
arguments[4][238][0].apply(exports,arguments)
},{"./cs_mark":744,"./cs_marked":745,"./cs_unflip":752,"dup":238}],738:[function(require,module,exports){
arguments[4][239][0].apply(exports,arguments)
},{"dup":239}],739:[function(require,module,exports){
arguments[4][240][0].apply(exports,arguments)
},{"dup":240}],740:[function(require,module,exports){
arguments[4][241][0].apply(exports,arguments)
},{"dup":241}],741:[function(require,module,exports){
arguments[4][242][0].apply(exports,arguments)
},{"dup":242}],742:[function(require,module,exports){
arguments[4][243][0].apply(exports,arguments)
},{"dup":243}],743:[function(require,module,exports){
arguments[4][244][0].apply(exports,arguments)
},{"../../arithmetic/abs":753,"../../arithmetic/divideScalar":760,"../../arithmetic/multiply":774,"../../relational/larger":853,"../../relational/largerEq":854,"./cs_spsolve":749,"dup":244}],744:[function(require,module,exports){
arguments[4][245][0].apply(exports,arguments)
},{"./cs_flip":740,"dup":245}],745:[function(require,module,exports){
arguments[4][246][0].apply(exports,arguments)
},{"dup":246}],746:[function(require,module,exports){
arguments[4][247][0].apply(exports,arguments)
},{"dup":247}],747:[function(require,module,exports){
arguments[4][248][0].apply(exports,arguments)
},{"./cs_tdfs":751,"dup":248}],748:[function(require,module,exports){
arguments[4][249][0].apply(exports,arguments)
},{"./cs_dfs":737,"./cs_mark":744,"./cs_marked":745,"dup":249}],749:[function(require,module,exports){
arguments[4][250][0].apply(exports,arguments)
},{"../../arithmetic/divideScalar":760,"../../arithmetic/multiply":774,"../../arithmetic/subtract":783,"./cs_reach":748,"dup":250}],750:[function(require,module,exports){
arguments[4][251][0].apply(exports,arguments)
},{"./cs_amd":735,"./cs_counts":736,"./cs_etree":738,"./cs_permute":746,"./cs_post":747,"dup":251}],751:[function(require,module,exports){
arguments[4][252][0].apply(exports,arguments)
},{"dup":252}],752:[function(require,module,exports){
arguments[4][253][0].apply(exports,arguments)
},{"./cs_flip":740,"dup":253}],753:[function(require,module,exports){
arguments[4][254][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"dup":254}],754:[function(require,module,exports){
arguments[4][255][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../type/matrix/utils/algorithm01":937,"../../type/matrix/utils/algorithm04":940,"../../type/matrix/utils/algorithm10":946,"../../type/matrix/utils/algorithm13":949,"../../type/matrix/utils/algorithm14":950,"../../utils/latex.js":981,"../../utils/object":983,"./addScalar":755,"dup":255}],755:[function(require,module,exports){
arguments[4][256][0].apply(exports,arguments)
},{"dup":256}],756:[function(require,module,exports){
arguments[4][257][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../utils/collection/deepMap":974,"../utils/isNegative":903,"./unaryMinus":784,"dup":257}],757:[function(require,module,exports){
arguments[4][258][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"dup":258}],758:[function(require,module,exports){
arguments[4][259][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"dup":259}],759:[function(require,module,exports){
arguments[4][260][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../type/matrix/utils/algorithm11":947,"../../type/matrix/utils/algorithm14":950,"../../utils/object":983,"../matrix/inv":824,"./divideScalar":760,"./multiply":774,"dup":260}],760:[function(require,module,exports){
arguments[4][261][0].apply(exports,arguments)
},{"./multiplyScalar":775,"dup":261}],761:[function(require,module,exports){
arguments[4][262][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../type/matrix/utils/algorithm02":938,"../../type/matrix/utils/algorithm03":939,"../../type/matrix/utils/algorithm07":943,"../../type/matrix/utils/algorithm11":947,"../../type/matrix/utils/algorithm12":948,"../../type/matrix/utils/algorithm13":949,"../../type/matrix/utils/algorithm14":950,"../../utils/latex":981,"./divideScalar":760,"dup":262}],762:[function(require,module,exports){
arguments[4][263][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../type/matrix/utils/algorithm02":938,"../../type/matrix/utils/algorithm09":945,"../../type/matrix/utils/algorithm11":947,"../../type/matrix/utils/algorithm13":949,"../../type/matrix/utils/algorithm14":950,"../../utils/latex":981,"./multiplyScalar":775,"dup":263}],763:[function(require,module,exports){
arguments[4][264][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../type/matrix/utils/algorithm03":939,"../../type/matrix/utils/algorithm07":943,"../../type/matrix/utils/algorithm11":947,"../../type/matrix/utils/algorithm12":948,"../../type/matrix/utils/algorithm13":949,"../../type/matrix/utils/algorithm14":950,"../../utils/latex":981,"./pow":778,"dup":264}],764:[function(require,module,exports){
arguments[4][265][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"dup":265}],765:[function(require,module,exports){
arguments[4][266][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"dup":266}],766:[function(require,module,exports){
arguments[4][267][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"dup":267}],767:[function(require,module,exports){
arguments[4][268][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../type/matrix/utils/algorithm01":937,"../../type/matrix/utils/algorithm04":940,"../../type/matrix/utils/algorithm10":946,"../../type/matrix/utils/algorithm13":949,"../../type/matrix/utils/algorithm14":950,"../../utils/number":982,"dup":268}],768:[function(require,module,exports){
arguments[4][269][0].apply(exports,arguments)
},{"../../utils/array":960,"../relational/smaller":855,"../utils/isPositive":905,"./abs":753,"./addScalar":755,"./divideScalar":760,"./multiplyScalar":775,"./sqrt":781,"dup":269}],769:[function(require,module,exports){
arguments[4][270][0].apply(exports,arguments)
},{"./abs":753,"./add":754,"./addScalar":755,"./cbrt":756,"./ceil":757,"./cube":758,"./divide":759,"./dotDivide":761,"./dotMultiply":762,"./dotPow":763,"./exp":764,"./fix":765,"./floor":766,"./gcd":767,"./hypot":768,"./lcm":770,"./log":771,"./log10":772,"./mod":773,"./multiply":774,"./norm":776,"./nthRoot":777,"./pow":778,"./round":779,"./sign":780,"./sqrt":781,"./square":782,"./subtract":783,"./unaryMinus":784,"./unaryPlus":785,"./xgcd":786,"dup":270}],770:[function(require,module,exports){
arguments[4][271][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../type/matrix/utils/algorithm02":938,"../../type/matrix/utils/algorithm06":942,"../../type/matrix/utils/algorithm11":947,"../../type/matrix/utils/algorithm13":949,"../../type/matrix/utils/algorithm14":950,"../../utils/number":982,"dup":271}],771:[function(require,module,exports){
arguments[4][272][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"./divideScalar":760,"dup":272}],772:[function(require,module,exports){
arguments[4][273][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"dup":273}],773:[function(require,module,exports){
arguments[4][274][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../type/matrix/utils/algorithm02":938,"../../type/matrix/utils/algorithm03":939,"../../type/matrix/utils/algorithm05":941,"../../type/matrix/utils/algorithm11":947,"../../type/matrix/utils/algorithm12":948,"../../type/matrix/utils/algorithm13":949,"../../type/matrix/utils/algorithm14":950,"../../utils/latex":981,"dup":274}],774:[function(require,module,exports){
arguments[4][275][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../type/matrix/utils/algorithm11":947,"../../type/matrix/utils/algorithm14":950,"../../utils/array":960,"../../utils/latex":981,"../../utils/object":983,"../relational/equalScalar":851,"./addScalar":755,"./multiplyScalar":775,"dup":275}],775:[function(require,module,exports){
arguments[4][276][0].apply(exports,arguments)
},{"dup":276}],776:[function(require,module,exports){
arguments[4][277][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../arithmetic/abs":753,"../arithmetic/add":754,"../arithmetic/multiply":774,"../arithmetic/pow":778,"../arithmetic/sqrt":781,"../matrix/trace":834,"../matrix/transpose":835,"../relational/equalScalar":851,"../relational/larger":853,"../relational/smaller":855,"dup":277}],777:[function(require,module,exports){
arguments[4][278][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../type/matrix/utils/algorithm01":937,"../../type/matrix/utils/algorithm02":938,"../../type/matrix/utils/algorithm06":942,"../../type/matrix/utils/algorithm11":947,"../../type/matrix/utils/algorithm13":949,"../../type/matrix/utils/algorithm14":950,"dup":278}],778:[function(require,module,exports){
arguments[4][279][0].apply(exports,arguments)
},{"../../type/fraction/function/fraction":922,"../../type/matrix/function/matrix":934,"../../type/number":951,"../../utils/array":960,"../../utils/latex":981,"../../utils/number":982,"../matrix/eye":819,"./multiply":774,"dup":279}],779:[function(require,module,exports){
arguments[4][280][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../type/matrix/utils/algorithm11":947,"../../type/matrix/utils/algorithm12":948,"../../type/matrix/utils/algorithm14":950,"../../utils/collection/deepMap":974,"../../utils/number":982,"../matrix/zeros":836,"../relational/equalScalar":851,"dup":280}],780:[function(require,module,exports){
arguments[4][281][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"../../utils/number":982,"dup":281}],781:[function(require,module,exports){
arguments[4][282][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"dup":282}],782:[function(require,module,exports){
arguments[4][283][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"dup":283}],783:[function(require,module,exports){
arguments[4][284][0].apply(exports,arguments)
},{"../../error/DimensionError":510,"../../type/matrix/function/matrix":934,"../../type/matrix/utils/algorithm01":937,"../../type/matrix/utils/algorithm03":939,"../../type/matrix/utils/algorithm05":941,"../../type/matrix/utils/algorithm10":946,"../../type/matrix/utils/algorithm13":949,"../../type/matrix/utils/algorithm14":950,"../../utils/latex":981,"./addScalar":755,"./unaryMinus":784,"dup":284}],784:[function(require,module,exports){
arguments[4][285][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"../../utils/latex":981,"dup":285}],785:[function(require,module,exports){
arguments[4][286][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"../../utils/latex":981,"dup":286}],786:[function(require,module,exports){
arguments[4][287][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../utils/number":982,"dup":287}],787:[function(require,module,exports){
arguments[4][288][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../type/matrix/utils/algorithm02":938,"../../type/matrix/utils/algorithm06":942,"../../type/matrix/utils/algorithm11":947,"../../type/matrix/utils/algorithm13":949,"../../type/matrix/utils/algorithm14":950,"../../utils/bignumber/bitAnd":961,"../../utils/latex":981,"../../utils/number":982,"dup":288}],788:[function(require,module,exports){
arguments[4][289][0].apply(exports,arguments)
},{"../../utils/bignumber/bitNot":962,"../../utils/collection/deepMap":974,"../../utils/latex":981,"../../utils/number":982,"dup":289}],789:[function(require,module,exports){
arguments[4][290][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../type/matrix/utils/algorithm01":937,"../../type/matrix/utils/algorithm04":940,"../../type/matrix/utils/algorithm10":946,"../../type/matrix/utils/algorithm13":949,"../../type/matrix/utils/algorithm14":950,"../../utils/bignumber/bitOr":963,"../../utils/latex":981,"../../utils/number":982,"dup":290}],790:[function(require,module,exports){
arguments[4][291][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../type/matrix/utils/algorithm03":939,"../../type/matrix/utils/algorithm07":943,"../../type/matrix/utils/algorithm12":948,"../../type/matrix/utils/algorithm13":949,"../../type/matrix/utils/algorithm14":950,"../../utils/bignumber/bitXor":964,"../../utils/latex":981,"../../utils/number":982,"dup":291}],791:[function(require,module,exports){
arguments[4][292][0].apply(exports,arguments)
},{"./bitAnd":787,"./bitNot":788,"./bitOr":789,"./bitXor":790,"./leftShift":792,"./rightArithShift":793,"./rightLogShift":794,"dup":292}],792:[function(require,module,exports){
arguments[4][293][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../type/matrix/utils/algorithm01":937,"../../type/matrix/utils/algorithm02":938,"../../type/matrix/utils/algorithm08":944,"../../type/matrix/utils/algorithm10":946,"../../type/matrix/utils/algorithm11":947,"../../type/matrix/utils/algorithm13":949,"../../type/matrix/utils/algorithm14":950,"../../utils/bignumber/leftShift":968,"../../utils/latex":981,"../../utils/number":982,"../matrix/zeros":836,"../relational/equalScalar":851,"dup":293}],793:[function(require,module,exports){
arguments[4][294][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../type/matrix/utils/algorithm01":937,"../../type/matrix/utils/algorithm02":938,"../../type/matrix/utils/algorithm08":944,"../../type/matrix/utils/algorithm10":946,"../../type/matrix/utils/algorithm11":947,"../../type/matrix/utils/algorithm13":949,"../../type/matrix/utils/algorithm14":950,"../../utils/bignumber/rightArithShift":970,"../../utils/latex":981,"../../utils/number":982,"../matrix/zeros":836,"../relational/equalScalar":851,"dup":294}],794:[function(require,module,exports){
arguments[4][295][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../type/matrix/utils/algorithm01":937,"../../type/matrix/utils/algorithm02":938,"../../type/matrix/utils/algorithm08":944,"../../type/matrix/utils/algorithm10":946,"../../type/matrix/utils/algorithm11":947,"../../type/matrix/utils/algorithm13":949,"../../type/matrix/utils/algorithm14":950,"../../utils/latex":981,"../../utils/number":982,"../matrix/zeros":836,"../relational/equalScalar":851,"dup":295}],795:[function(require,module,exports){
arguments[4][296][0].apply(exports,arguments)
},{"../arithmetic/add":754,"../utils/isInteger":902,"../utils/isNegative":903,"./stirlingS2":799,"dup":296}],796:[function(require,module,exports){
arguments[4][297][0].apply(exports,arguments)
},{"../arithmetic/add":754,"../arithmetic/divide":759,"../arithmetic/multiply":774,"../probability/combinations":837,"../utils/isInteger":902,"../utils/isNegative":903,"dup":297}],797:[function(require,module,exports){
arguments[4][298][0].apply(exports,arguments)
},{"../arithmetic/addScalar":755,"../probability/combinations":837,"../relational/larger":853,"../utils/isInteger":902,"../utils/isPositive":905,"dup":298}],798:[function(require,module,exports){
arguments[4][299][0].apply(exports,arguments)
},{"./bellNumbers":795,"./catalan":796,"./composition":797,"./stirlingS2":799,"dup":299}],799:[function(require,module,exports){
arguments[4][300][0].apply(exports,arguments)
},{"../arithmetic/add":754,"../arithmetic/divide":759,"../arithmetic/multiply":774,"../arithmetic/pow":778,"../arithmetic/subtract":783,"../probability/combinations":837,"../probability/factorial":839,"../relational/larger":853,"../utils/isInteger":902,"../utils/isNegative":903,"dup":300}],800:[function(require,module,exports){
arguments[4][301][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"dup":301}],801:[function(require,module,exports){
arguments[4][302][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"dup":302}],802:[function(require,module,exports){
arguments[4][303][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"dup":303}],803:[function(require,module,exports){
arguments[4][304][0].apply(exports,arguments)
},{"./arg":800,"./conj":801,"./im":802,"./re":804,"dup":304}],804:[function(require,module,exports){
arguments[4][305][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"dup":305}],805:[function(require,module,exports){
arguments[4][306][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"dup":306}],806:[function(require,module,exports){
arguments[4][307][0].apply(exports,arguments)
},{"./distance":805,"./intersect":807,"dup":307}],807:[function(require,module,exports){
arguments[4][308][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../arithmetic/abs":753,"../arithmetic/add":754,"../arithmetic/multiply":774,"../arithmetic/subtract":783,"dup":308}],808:[function(require,module,exports){
arguments[4][309][0].apply(exports,arguments)
},{"./algebra":730,"./arithmetic":769,"./bitwise":791,"./combinatorics":798,"./complex":803,"./geometry":806,"./logical":810,"./matrix":823,"./probability":841,"./relational":852,"./statistics":858,"./string":870,"./trigonometry":891,"./unit":898,"./utils":901,"dup":309}],809:[function(require,module,exports){
arguments[4][310][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../type/matrix/utils/algorithm02":938,"../../type/matrix/utils/algorithm06":942,"../../type/matrix/utils/algorithm11":947,"../../type/matrix/utils/algorithm13":949,"../../type/matrix/utils/algorithm14":950,"../../utils/latex":981,"../matrix/zeros":836,"../utils/isZero":906,"./not":811,"dup":310}],810:[function(require,module,exports){
arguments[4][311][0].apply(exports,arguments)
},{"./and":809,"./not":811,"./or":812,"./xor":813,"dup":311}],811:[function(require,module,exports){
arguments[4][312][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"../../utils/latex":981,"dup":312}],812:[function(require,module,exports){
arguments[4][313][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../type/matrix/utils/algorithm03":939,"../../type/matrix/utils/algorithm05":941,"../../type/matrix/utils/algorithm12":948,"../../type/matrix/utils/algorithm13":949,"../../type/matrix/utils/algorithm14":950,"../../utils/latex":981,"dup":313}],813:[function(require,module,exports){
arguments[4][314][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../type/matrix/utils/algorithm03":939,"../../type/matrix/utils/algorithm07":943,"../../type/matrix/utils/algorithm12":948,"../../type/matrix/utils/algorithm13":949,"../../type/matrix/utils/algorithm14":950,"../../utils/latex":981,"dup":314}],814:[function(require,module,exports){
arguments[4][315][0].apply(exports,arguments)
},{"../../error/DimensionError":510,"../../error/IndexError":511,"../../type/matrix/function/matrix":934,"../../utils/array":960,"../../utils/number":982,"../../utils/object":983,"dup":315}],815:[function(require,module,exports){
arguments[4][316][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../utils/array":960,"../arithmetic/multiply":774,"../arithmetic/subtract":783,"dup":316}],816:[function(require,module,exports){
arguments[4][317][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../utils/index":980,"../arithmetic/add":754,"../arithmetic/multiply":774,"../arithmetic/subtract":783,"../arithmetic/unaryMinus":784,"dup":317}],817:[function(require,module,exports){
arguments[4][318][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../utils/array":960,"../../utils/number":982,"../../utils/object":983,"dup":318}],818:[function(require,module,exports){
arguments[4][319][0].apply(exports,arguments)
},{"../../utils/array":960,"../arithmetic/add":754,"../arithmetic/multiply":774,"dup":319}],819:[function(require,module,exports){
arguments[4][320][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../utils/array":960,"../../utils/number":982,"dup":320}],820:[function(require,module,exports){
arguments[4][321][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../utils/array":960,"dup":321}],821:[function(require,module,exports){
arguments[4][322][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../utils/array":960,"../../utils/object":983,"dup":322}],822:[function(require,module,exports){
arguments[4][323][0].apply(exports,arguments)
},{"dup":323}],823:[function(require,module,exports){
arguments[4][324][0].apply(exports,arguments)
},{"./concat":814,"./cross":815,"./det":816,"./diag":817,"./dot":818,"./eye":819,"./filter":820,"./flatten":821,"./forEach":822,"./inv":824,"./map":825,"./ones":826,"./partitionSelect":827,"./range":828,"./resize":829,"./size":830,"./sort":831,"./squeeze":832,"./subset":833,"./trace":834,"./transpose":835,"./zeros":836,"dup":324}],824:[function(require,module,exports){
arguments[4][325][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../utils/index":980,"../arithmetic/addScalar":755,"../arithmetic/divideScalar":760,"../arithmetic/multiply":774,"../arithmetic/unaryMinus":784,"../matrix/det":816,"./eye":819,"dup":325}],825:[function(require,module,exports){
arguments[4][326][0].apply(exports,arguments)
},{"dup":326}],826:[function(require,module,exports){
arguments[4][327][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../utils/array":960,"../../utils/number":982,"dup":327}],827:[function(require,module,exports){
arguments[4][328][0].apply(exports,arguments)
},{"../../utils/number":982,"../relational/compare":848,"dup":328}],828:[function(require,module,exports){
arguments[4][329][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"dup":329}],829:[function(require,module,exports){
arguments[4][330][0].apply(exports,arguments)
},{"../../error/ArgumentsError":509,"../../error/DimensionError":510,"../../type/matrix/function/matrix":934,"../../utils/array":960,"../../utils/number":982,"../../utils/object":983,"../../utils/string":984,"dup":330}],830:[function(require,module,exports){
arguments[4][331][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../utils/array":960,"dup":331}],831:[function(require,module,exports){
arguments[4][332][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../utils/array":960,"../relational/compare":848,"dup":332}],832:[function(require,module,exports){
arguments[4][333][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../utils/array":960,"../../utils/object":983,"dup":333}],833:[function(require,module,exports){
arguments[4][334][0].apply(exports,arguments)
},{"../../error/DimensionError":510,"../../type/matrix/function/matrix":934,"../../utils/array":960,"../../utils/object":983,"dup":334}],834:[function(require,module,exports){
arguments[4][335][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../utils/object":983,"../../utils/string":984,"../arithmetic/add":754,"dup":335}],835:[function(require,module,exports){
arguments[4][336][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../utils/latex":981,"../../utils/object":983,"../../utils/string":984,"dup":336}],836:[function(require,module,exports){
arguments[4][337][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../utils/array":960,"../../utils/number":982,"dup":337}],837:[function(require,module,exports){
arguments[4][338][0].apply(exports,arguments)
},{"../../utils/number":982,"dup":338}],838:[function(require,module,exports){
arguments[4][339][0].apply(exports,arguments)
},{"../../error/ArgumentsError":509,"../../type/matrix/function/matrix":934,"../../utils/array":960,"../../utils/collection/isCollection":975,"dup":339}],839:[function(require,module,exports){
arguments[4][340][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"../../utils/latex":981,"./gamma":840,"dup":340}],840:[function(require,module,exports){
arguments[4][341][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"../../utils/number":982,"../arithmetic/multiply":774,"../arithmetic/pow":778,"dup":341}],841:[function(require,module,exports){
arguments[4][342][0].apply(exports,arguments)
},{"./combinations":837,"./factorial":839,"./gamma":840,"./kldivergence":842,"./multinomial":843,"./permutations":844,"./pickRandom":845,"./random":846,"./randomInt":847,"dup":342}],842:[function(require,module,exports){
arguments[4][343][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../arithmetic/divide":759,"../arithmetic/dotDivide":761,"../arithmetic/log":771,"../arithmetic/multiply":774,"../statistics/sum":867,"../utils/isNumeric":904,"dup":343}],843:[function(require,module,exports){
arguments[4][344][0].apply(exports,arguments)
},{"../../utils/collection/deepForEach":973,"../arithmetic/add":754,"../arithmetic/divide":759,"../arithmetic/multiply":774,"../probability/factorial":839,"../utils/isInteger":902,"../utils/isPositive":905,"dup":344}],844:[function(require,module,exports){
arguments[4][345][0].apply(exports,arguments)
},{"../../utils/number":982,"./factorial":839,"dup":345}],845:[function(require,module,exports){
arguments[4][346][0].apply(exports,arguments)
},{"./distribution":838,"dup":346}],846:[function(require,module,exports){
arguments[4][347][0].apply(exports,arguments)
},{"./distribution":838,"dup":347}],847:[function(require,module,exports){
arguments[4][348][0].apply(exports,arguments)
},{"./distribution":838,"dup":348}],848:[function(require,module,exports){
arguments[4][349][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../type/matrix/utils/algorithm03":939,"../../type/matrix/utils/algorithm05":941,"../../type/matrix/utils/algorithm12":948,"../../type/matrix/utils/algorithm13":949,"../../type/matrix/utils/algorithm14":950,"../../utils/bignumber/nearlyEqual":969,"../../utils/number":982,"dup":349}],849:[function(require,module,exports){
arguments[4][350][0].apply(exports,arguments)
},{"./equal":850,"dup":350}],850:[function(require,module,exports){
arguments[4][351][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../type/matrix/utils/algorithm03":939,"../../type/matrix/utils/algorithm07":943,"../../type/matrix/utils/algorithm12":948,"../../type/matrix/utils/algorithm13":949,"../../type/matrix/utils/algorithm14":950,"../../utils/latex":981,"./equalScalar":851,"dup":351}],851:[function(require,module,exports){
arguments[4][352][0].apply(exports,arguments)
},{"../../utils/bignumber/nearlyEqual":969,"../../utils/number":982,"dup":352}],852:[function(require,module,exports){
arguments[4][353][0].apply(exports,arguments)
},{"./compare":848,"./deepEqual":849,"./equal":850,"./larger":853,"./largerEq":854,"./smaller":855,"./smallerEq":856,"./unequal":857,"dup":353}],853:[function(require,module,exports){
arguments[4][354][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../type/matrix/utils/algorithm03":939,"../../type/matrix/utils/algorithm07":943,"../../type/matrix/utils/algorithm12":948,"../../type/matrix/utils/algorithm13":949,"../../type/matrix/utils/algorithm14":950,"../../utils/bignumber/nearlyEqual":969,"../../utils/latex":981,"../../utils/number":982,"dup":354}],854:[function(require,module,exports){
arguments[4][355][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../type/matrix/utils/algorithm03":939,"../../type/matrix/utils/algorithm07":943,"../../type/matrix/utils/algorithm12":948,"../../type/matrix/utils/algorithm13":949,"../../type/matrix/utils/algorithm14":950,"../../utils/bignumber/nearlyEqual":969,"../../utils/latex":981,"../../utils/number":982,"dup":355}],855:[function(require,module,exports){
arguments[4][356][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../type/matrix/utils/algorithm03":939,"../../type/matrix/utils/algorithm07":943,"../../type/matrix/utils/algorithm12":948,"../../type/matrix/utils/algorithm13":949,"../../type/matrix/utils/algorithm14":950,"../../utils/bignumber/nearlyEqual":969,"../../utils/latex":981,"../../utils/number":982,"dup":356}],856:[function(require,module,exports){
arguments[4][357][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../type/matrix/utils/algorithm03":939,"../../type/matrix/utils/algorithm07":943,"../../type/matrix/utils/algorithm12":948,"../../type/matrix/utils/algorithm13":949,"../../type/matrix/utils/algorithm14":950,"../../utils/bignumber/nearlyEqual":969,"../../utils/latex":981,"../../utils/number":982,"dup":357}],857:[function(require,module,exports){
arguments[4][358][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../type/matrix/utils/algorithm03":939,"../../type/matrix/utils/algorithm07":943,"../../type/matrix/utils/algorithm12":948,"../../type/matrix/utils/algorithm13":949,"../../type/matrix/utils/algorithm14":950,"../../utils/bignumber/nearlyEqual":969,"../../utils/latex":981,"../../utils/number":982,"dup":358}],858:[function(require,module,exports){
arguments[4][359][0].apply(exports,arguments)
},{"./max":859,"./mean":860,"./median":861,"./min":862,"./mode":863,"./prod":864,"./quantileSeq":865,"./std":866,"./sum":867,"./var":868,"dup":359}],859:[function(require,module,exports){
arguments[4][360][0].apply(exports,arguments)
},{"../../utils/collection/containsCollections":972,"../../utils/collection/deepForEach":973,"../../utils/collection/reduce":976,"../relational/larger":853,"dup":360}],860:[function(require,module,exports){
arguments[4][361][0].apply(exports,arguments)
},{"../../utils/array":960,"../../utils/collection/containsCollections":972,"../../utils/collection/deepForEach":973,"../../utils/collection/reduce":976,"../arithmetic/add":754,"../arithmetic/divide":759,"dup":361}],861:[function(require,module,exports){
arguments[4][362][0].apply(exports,arguments)
},{"../../utils/array":960,"../../utils/collection/containsCollections":972,"../../utils/collection/reduce":976,"../arithmetic/addScalar":755,"../arithmetic/divideScalar":760,"../matrix/partitionSelect":827,"../relational/compare":848,"dup":362}],862:[function(require,module,exports){
arguments[4][363][0].apply(exports,arguments)
},{"../../utils/collection/containsCollections":972,"../../utils/collection/deepForEach":973,"../../utils/collection/reduce":976,"../relational/smaller":855,"dup":363}],863:[function(require,module,exports){
arguments[4][364][0].apply(exports,arguments)
},{"../../utils/array":960,"dup":364}],864:[function(require,module,exports){
arguments[4][365][0].apply(exports,arguments)
},{"../../utils/collection/deepForEach":973,"../arithmetic/multiplyScalar":775,"dup":365}],865:[function(require,module,exports){
arguments[4][366][0].apply(exports,arguments)
},{"../../utils/array":960,"../../utils/collection/isCollection":975,"../../utils/number":982,"../arithmetic/add":754,"../arithmetic/multiply":774,"../matrix/partitionSelect":827,"../relational/compare":848,"dup":366}],866:[function(require,module,exports){
arguments[4][367][0].apply(exports,arguments)
},{"../arithmetic/sqrt":781,"../statistics/var":868,"dup":367}],867:[function(require,module,exports){
arguments[4][368][0].apply(exports,arguments)
},{"../../utils/collection/deepForEach":973,"../arithmetic/addScalar":755,"dup":368}],868:[function(require,module,exports){
arguments[4][369][0].apply(exports,arguments)
},{"../../utils/collection/deepForEach":973,"../arithmetic/addScalar":755,"../arithmetic/divideScalar":760,"../arithmetic/multiplyScalar":775,"../arithmetic/subtract":783,"dup":369}],869:[function(require,module,exports){
arguments[4][370][0].apply(exports,arguments)
},{"../../utils/string":984,"dup":370}],870:[function(require,module,exports){
arguments[4][371][0].apply(exports,arguments)
},{"./format":869,"./print":871,"dup":371}],871:[function(require,module,exports){
arguments[4][372][0].apply(exports,arguments)
},{"../../utils/string":984,"dup":372}],872:[function(require,module,exports){
arguments[4][373][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"dup":373}],873:[function(require,module,exports){
arguments[4][374][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"dup":374}],874:[function(require,module,exports){
arguments[4][375][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"dup":375}],875:[function(require,module,exports){
arguments[4][376][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"dup":376}],876:[function(require,module,exports){
arguments[4][377][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"dup":377}],877:[function(require,module,exports){
arguments[4][378][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"dup":378}],878:[function(require,module,exports){
arguments[4][379][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"dup":379}],879:[function(require,module,exports){
arguments[4][380][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"./acosh":873,"dup":380}],880:[function(require,module,exports){
arguments[4][381][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"dup":381}],881:[function(require,module,exports){
arguments[4][382][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"dup":382}],882:[function(require,module,exports){
arguments[4][383][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"dup":383}],883:[function(require,module,exports){
arguments[4][384][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../type/matrix/utils/algorithm02":938,"../../type/matrix/utils/algorithm03":939,"../../type/matrix/utils/algorithm09":945,"../../type/matrix/utils/algorithm11":947,"../../type/matrix/utils/algorithm12":948,"../../type/matrix/utils/algorithm13":949,"../../type/matrix/utils/algorithm14":950,"dup":384}],884:[function(require,module,exports){
arguments[4][385][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"dup":385}],885:[function(require,module,exports){
arguments[4][386][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"dup":386}],886:[function(require,module,exports){
arguments[4][387][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"dup":387}],887:[function(require,module,exports){
arguments[4][388][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"dup":388}],888:[function(require,module,exports){
arguments[4][389][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"dup":389}],889:[function(require,module,exports){
arguments[4][390][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"dup":390}],890:[function(require,module,exports){
arguments[4][391][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"../../utils/number":982,"dup":391}],891:[function(require,module,exports){
arguments[4][392][0].apply(exports,arguments)
},{"./acos":872,"./acosh":873,"./acot":874,"./acoth":875,"./acsc":876,"./acsch":877,"./asec":878,"./asech":879,"./asin":880,"./asinh":881,"./atan":882,"./atan2":883,"./atanh":884,"./cos":885,"./cosh":886,"./cot":887,"./coth":888,"./csc":889,"./csch":890,"./sec":892,"./sech":893,"./sin":894,"./sinh":895,"./tan":896,"./tanh":897,"dup":392}],892:[function(require,module,exports){
arguments[4][393][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"dup":393}],893:[function(require,module,exports){
arguments[4][394][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"dup":394}],894:[function(require,module,exports){
arguments[4][395][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"dup":395}],895:[function(require,module,exports){
arguments[4][396][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"dup":396}],896:[function(require,module,exports){
arguments[4][397][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"dup":397}],897:[function(require,module,exports){
arguments[4][398][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"dup":398}],898:[function(require,module,exports){
arguments[4][399][0].apply(exports,arguments)
},{"./to":899,"dup":399}],899:[function(require,module,exports){
arguments[4][400][0].apply(exports,arguments)
},{"../../type/matrix/function/matrix":934,"../../type/matrix/utils/algorithm13":949,"../../type/matrix/utils/algorithm14":950,"../../utils/latex":981,"dup":400}],900:[function(require,module,exports){
arguments[4][401][0].apply(exports,arguments)
},{"../../utils/object":983,"dup":401}],901:[function(require,module,exports){
arguments[4][402][0].apply(exports,arguments)
},{"./clone":900,"./isInteger":902,"./isNegative":903,"./isNumeric":904,"./isPositive":905,"./isZero":906,"./typeof":907,"dup":402}],902:[function(require,module,exports){
arguments[4][403][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"../../utils/number":982,"dup":403}],903:[function(require,module,exports){
arguments[4][404][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"../../utils/number":982,"dup":404}],904:[function(require,module,exports){
arguments[4][405][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"../../utils/number":982,"dup":405}],905:[function(require,module,exports){
arguments[4][406][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"../../utils/number":982,"dup":406}],906:[function(require,module,exports){
arguments[4][407][0].apply(exports,arguments)
},{"../../utils/collection/deepMap":974,"../../utils/number":982,"dup":407}],907:[function(require,module,exports){
arguments[4][408][0].apply(exports,arguments)
},{"../../utils/types":985,"dup":408}],908:[function(require,module,exports){
arguments[4][409][0].apply(exports,arguments)
},{"./constants":504,"./error":512,"./expression":693,"./function":808,"./json":909,"./type":924,"dup":409}],909:[function(require,module,exports){
arguments[4][410][0].apply(exports,arguments)
},{"./reviver":910,"dup":410}],910:[function(require,module,exports){
arguments[4][411][0].apply(exports,arguments)
},{"dup":411}],911:[function(require,module,exports){
arguments[4][412][0].apply(exports,arguments)
},{"decimal.js":988,"dup":412}],912:[function(require,module,exports){
arguments[4][413][0].apply(exports,arguments)
},{"../../../utils/collection/deepMap":974,"dup":413}],913:[function(require,module,exports){
arguments[4][414][0].apply(exports,arguments)
},{"./BigNumber":911,"./function/bignumber":912,"dup":414}],914:[function(require,module,exports){
arguments[4][415][0].apply(exports,arguments)
},{"./../utils/collection/deepMap":974,"dup":415}],915:[function(require,module,exports){
arguments[4][416][0].apply(exports,arguments)
},{"../../utils/object":983,"../../utils/string":984,"dup":416}],916:[function(require,module,exports){
arguments[4][417][0].apply(exports,arguments)
},{"dup":417}],917:[function(require,module,exports){
arguments[4][418][0].apply(exports,arguments)
},{"./Chain":915,"./function/chain":916,"dup":418}],918:[function(require,module,exports){
arguments[4][419][0].apply(exports,arguments)
},{"../../utils/number":982,"complex.js":987,"dup":419}],919:[function(require,module,exports){
arguments[4][420][0].apply(exports,arguments)
},{"../../../utils/collection/deepMap":974,"../../../utils/latex":981,"dup":420}],920:[function(require,module,exports){
arguments[4][421][0].apply(exports,arguments)
},{"./Complex":918,"./function/complex":919,"dup":421}],921:[function(require,module,exports){
arguments[4][422][0].apply(exports,arguments)
},{"dup":422,"fraction.js":989}],922:[function(require,module,exports){
arguments[4][423][0].apply(exports,arguments)
},{"../../../utils/collection/deepMap":974,"dup":423}],923:[function(require,module,exports){
arguments[4][424][0].apply(exports,arguments)
},{"./Fraction":921,"./function/fraction":922,"dup":424}],924:[function(require,module,exports){
arguments[4][425][0].apply(exports,arguments)
},{"./bignumber":913,"./boolean":914,"./chain":917,"./complex":920,"./fraction":923,"./matrix":936,"./number":951,"./resultset":953,"./string":954,"./unit":957,"dup":425}],925:[function(require,module,exports){
arguments[4][426][0].apply(exports,arguments)
},{"../../error/DimensionError":510,"../../utils/index":980,"./Matrix":928,"dup":426}],926:[function(require,module,exports){
arguments[4][427][0].apply(exports,arguments)
},{"../../function/relational/larger":853,"../../function/relational/smaller":855,"dup":427}],927:[function(require,module,exports){
arguments[4][428][0].apply(exports,arguments)
},{"../../function/relational/smaller":855,"../../utils/index":980,"./DenseMatrix":925,"dup":428}],928:[function(require,module,exports){
arguments[4][429][0].apply(exports,arguments)
},{"../../utils/index":980,"dup":429}],929:[function(require,module,exports){
arguments[4][430][0].apply(exports,arguments)
},{"../../utils/number":982,"../../utils/object":983,"dup":430}],930:[function(require,module,exports){
arguments[4][431][0].apply(exports,arguments)
},{"../../utils/number":982,"dup":431}],931:[function(require,module,exports){
arguments[4][432][0].apply(exports,arguments)
},{"../../function/arithmetic/add":754,"../../function/relational/equalScalar":851,"dup":432}],932:[function(require,module,exports){
arguments[4][433][0].apply(exports,arguments)
},{"../../error/DimensionError":510,"../../function/relational/equalScalar":851,"../../utils/index":980,"./Matrix":928,"dup":433}],933:[function(require,module,exports){
arguments[4][434][0].apply(exports,arguments)
},{"dup":434}],934:[function(require,module,exports){
arguments[4][435][0].apply(exports,arguments)
},{"dup":435}],935:[function(require,module,exports){
arguments[4][436][0].apply(exports,arguments)
},{"dup":436}],936:[function(require,module,exports){
arguments[4][437][0].apply(exports,arguments)
},{"./DenseMatrix":925,"./FibonacciHeap":926,"./ImmutableDenseMatrix":927,"./Matrix":928,"./MatrixIndex":929,"./Range":930,"./Spa":931,"./SparseMatrix":932,"./function/index":933,"./function/matrix":934,"./function/sparse":935,"dup":437}],937:[function(require,module,exports){
arguments[4][438][0].apply(exports,arguments)
},{"../../../error/DimensionError":510,"dup":438}],938:[function(require,module,exports){
arguments[4][439][0].apply(exports,arguments)
},{"../../../error/DimensionError":510,"../../../function/relational/equalScalar":851,"dup":439}],939:[function(require,module,exports){
arguments[4][440][0].apply(exports,arguments)
},{"../../../error/DimensionError":510,"dup":440}],940:[function(require,module,exports){
arguments[4][441][0].apply(exports,arguments)
},{"../../../error/DimensionError":510,"../../../function/relational/equalScalar":851,"dup":441}],941:[function(require,module,exports){
arguments[4][442][0].apply(exports,arguments)
},{"../../../error/DimensionError":510,"../../../function/relational/equalScalar":851,"dup":442}],942:[function(require,module,exports){
arguments[4][443][0].apply(exports,arguments)
},{"../../../error/DimensionError":510,"../../../function/relational/equalScalar":851,"./../../../utils/collection/scatter":977,"dup":443}],943:[function(require,module,exports){
arguments[4][444][0].apply(exports,arguments)
},{"../../../error/DimensionError":510,"dup":444}],944:[function(require,module,exports){
arguments[4][445][0].apply(exports,arguments)
},{"../../../error/DimensionError":510,"../../../function/relational/equalScalar":851,"dup":445}],945:[function(require,module,exports){
arguments[4][446][0].apply(exports,arguments)
},{"../../../error/DimensionError":510,"../../../function/relational/equalScalar":851,"dup":446}],946:[function(require,module,exports){
arguments[4][447][0].apply(exports,arguments)
},{"dup":447}],947:[function(require,module,exports){
arguments[4][448][0].apply(exports,arguments)
},{"../../../function/relational/equalScalar":851,"dup":448}],948:[function(require,module,exports){
arguments[4][449][0].apply(exports,arguments)
},{"dup":449}],949:[function(require,module,exports){
arguments[4][450][0].apply(exports,arguments)
},{"../../../error/DimensionError":510,"../../../utils/index":980,"dup":450}],950:[function(require,module,exports){
arguments[4][451][0].apply(exports,arguments)
},{"../../../utils/object":983,"dup":451}],951:[function(require,module,exports){
arguments[4][452][0].apply(exports,arguments)
},{"./../utils/collection/deepMap":974,"dup":452}],952:[function(require,module,exports){
arguments[4][453][0].apply(exports,arguments)
},{"dup":453}],953:[function(require,module,exports){
arguments[4][454][0].apply(exports,arguments)
},{"./ResultSet":952,"dup":454}],954:[function(require,module,exports){
arguments[4][455][0].apply(exports,arguments)
},{"../utils/number":982,"./../utils/collection/deepMap":974,"dup":455}],955:[function(require,module,exports){
arguments[4][456][0].apply(exports,arguments)
},{"../../function/arithmetic/abs":753,"../../function/arithmetic/addScalar":755,"../../function/arithmetic/divideScalar":760,"../../function/arithmetic/multiplyScalar":775,"../../function/arithmetic/pow":778,"../../function/arithmetic/subtract":783,"../../function/relational/equal":850,"../../function/string/format":869,"../../function/utils/isNumeric":904,"../../function/utils/typeof":907,"../../type/complex/Complex":918,"../../type/number":951,"../../utils/bignumber/constants":966,"../../utils/object":983,"../../utils/string":984,"dup":456}],956:[function(require,module,exports){
arguments[4][457][0].apply(exports,arguments)
},{"../../../utils/collection/deepMap":974,"dup":457}],957:[function(require,module,exports){
arguments[4][458][0].apply(exports,arguments)
},{"./Unit":955,"./function/unit":956,"./physicalConstants":958,"dup":458}],958:[function(require,module,exports){
arguments[4][459][0].apply(exports,arguments)
},{"../../utils/object":983,"dup":459}],959:[function(require,module,exports){
arguments[4][460][0].apply(exports,arguments)
},{"dup":460}],960:[function(require,module,exports){
arguments[4][461][0].apply(exports,arguments)
},{"../error/DimensionError":510,"../error/IndexError":511,"./number":982,"./object":983,"./string":984,"./types":985,"dup":461}],961:[function(require,module,exports){
arguments[4][462][0].apply(exports,arguments)
},{"./bitwise":965,"dup":462}],962:[function(require,module,exports){
arguments[4][463][0].apply(exports,arguments)
},{"dup":463}],963:[function(require,module,exports){
arguments[4][464][0].apply(exports,arguments)
},{"./bitwise":965,"dup":464}],964:[function(require,module,exports){
arguments[4][465][0].apply(exports,arguments)
},{"./bitNot":962,"./bitwise":965,"dup":465}],965:[function(require,module,exports){
arguments[4][466][0].apply(exports,arguments)
},{"./bitNot":962,"dup":466}],966:[function(require,module,exports){
arguments[4][467][0].apply(exports,arguments)
},{"../function":979,"dup":467}],967:[function(require,module,exports){
arguments[4][468][0].apply(exports,arguments)
},{"dup":468}],968:[function(require,module,exports){
arguments[4][469][0].apply(exports,arguments)
},{"dup":469}],969:[function(require,module,exports){
arguments[4][470][0].apply(exports,arguments)
},{"dup":470}],970:[function(require,module,exports){
arguments[4][471][0].apply(exports,arguments)
},{"dup":471}],971:[function(require,module,exports){
arguments[4][472][0].apply(exports,arguments)
},{"dup":472}],972:[function(require,module,exports){
arguments[4][473][0].apply(exports,arguments)
},{"./isCollection":975,"dup":473}],973:[function(require,module,exports){
arguments[4][474][0].apply(exports,arguments)
},{"dup":474}],974:[function(require,module,exports){
arguments[4][475][0].apply(exports,arguments)
},{"dup":475}],975:[function(require,module,exports){
arguments[4][476][0].apply(exports,arguments)
},{"dup":476}],976:[function(require,module,exports){
arguments[4][477][0].apply(exports,arguments)
},{"../../error/IndexError":511,"../array":960,"dup":477}],977:[function(require,module,exports){
arguments[4][478][0].apply(exports,arguments)
},{"dup":478}],978:[function(require,module,exports){
arguments[4][479][0].apply(exports,arguments)
},{"dup":479,"tiny-emitter":990}],979:[function(require,module,exports){
arguments[4][480][0].apply(exports,arguments)
},{"dup":480}],980:[function(require,module,exports){
arguments[4][481][0].apply(exports,arguments)
},{"./array":960,"./boolean":971,"./emitter":978,"./function":979,"./number":982,"./object":983,"./string":984,"./types":985,"dup":481}],981:[function(require,module,exports){
arguments[4][482][0].apply(exports,arguments)
},{"dup":482}],982:[function(require,module,exports){
arguments[4][483][0].apply(exports,arguments)
},{"./NumberFormatter":959,"dup":483}],983:[function(require,module,exports){
arguments[4][484][0].apply(exports,arguments)
},{"dup":484}],984:[function(require,module,exports){
arguments[4][485][0].apply(exports,arguments)
},{"./bignumber/formatter":967,"./number":982,"dup":485}],985:[function(require,module,exports){
arguments[4][486][0].apply(exports,arguments)
},{"dup":486}],986:[function(require,module,exports){
arguments[4][487][0].apply(exports,arguments)
},{"dup":487}],987:[function(require,module,exports){
arguments[4][488][0].apply(exports,arguments)
},{"dup":488}],988:[function(require,module,exports){
arguments[4][489][0].apply(exports,arguments)
},{"dup":489}],989:[function(require,module,exports){
arguments[4][490][0].apply(exports,arguments)
},{"dup":490}],990:[function(require,module,exports){
arguments[4][491][0].apply(exports,arguments)
},{"dup":491}],991:[function(require,module,exports){
arguments[4][492][0].apply(exports,arguments)
},{"dup":492}],992:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.sample = sample;
exports.shuffle = shuffle;

var _mathjs = require('mathjs');

var math = _interopRequireWildcard(_mathjs);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function sample(values, k) {
    var samples = new Array(k);
    var lastIndex = values.length - 1;

    for (var i = 0; i < k; i++, lastIndex--) {
        var selected = math.randomInt(lastIndex + 1);
        var value = values[selected];
        values[selected] = values[lastIndex];
        values[lastIndex] = value;
        samples[i] = value;
    }

    return samples;
};

function shuffle(values) {
    for (var lastIndex = values.length - 1; lastIndex > 0; lastIndex--) {
        var randomIndex = math.randomInt(lastIndex + 1);
        var value = values[lastIndex];
        values[lastIndex] = values[randomIndex];
        values[randomIndex] = value;
    }

    return values;
};

},{"mathjs":503}]},{},[501])(501)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIuLi92aS1hbm4vc3JjL2ZlZWRmb3J3YXJkLmpzIiwiLi4vdmktYW5uL3ZpLWFubi5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvY29yZS5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvaW5kZXguanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9jb25zdGFudHMuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9jb3JlL2NvcmUuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9jb3JlL2Z1bmN0aW9uL2NvbmZpZy5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2NvcmUvZnVuY3Rpb24vaW1wb3J0LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvY29yZS90eXBlZC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Vycm9yL0FyZ3VtZW50c0Vycm9yLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXJyb3IvRGltZW5zaW9uRXJyb3IuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9lcnJvci9JbmRleEVycm9yLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXJyb3IvaW5kZXguanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL0hlbHAuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL1BhcnNlci5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9jb25zdGFudHMvSW5maW5pdHkuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvY29uc3RhbnRzL0xOMTAuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvY29uc3RhbnRzL0xOMi5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9jb25zdGFudHMvTE9HMTBFLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2NvbnN0YW50cy9MT0cyRS5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9jb25zdGFudHMvTmFOLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2NvbnN0YW50cy9TUVJUMV8yLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2NvbnN0YW50cy9TUVJUMi5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9jb25zdGFudHMvZS5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9jb25zdGFudHMvZmFsc2UuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvY29uc3RhbnRzL2kuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvY29uc3RhbnRzL251bGwuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvY29uc3RhbnRzL3BoaS5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9jb25zdGFudHMvcGkuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvY29uc3RhbnRzL3RhdS5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9jb25zdGFudHMvdHJ1ZS5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9jb25zdGFudHMvdmVyc2lvbi5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9jb25zdHJ1Y3Rpb24vYmlnbnVtYmVyLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2NvbnN0cnVjdGlvbi9ib29sZWFuLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2NvbnN0cnVjdGlvbi9jb21wbGV4LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2NvbnN0cnVjdGlvbi9mcmFjdGlvbi5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9jb25zdHJ1Y3Rpb24vaW5kZXguanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvY29uc3RydWN0aW9uL21hdHJpeC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9jb25zdHJ1Y3Rpb24vbnVtYmVyLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2NvbnN0cnVjdGlvbi9zcGFyc2UuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvY29uc3RydWN0aW9uL3N0cmluZy5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9jb25zdHJ1Y3Rpb24vdW5pdC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9jb3JlL2NvbmZpZy5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9jb3JlL2ltcG9ydC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9jb3JlL3R5cGVkLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2FsZ2VicmEvbHNvbHZlLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2FsZ2VicmEvbHVwLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2FsZ2VicmEvbHVzb2x2ZS5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9hbGdlYnJhL3NsdS5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9hbGdlYnJhL3Vzb2x2ZS5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9hcml0aG1ldGljL2Ficy5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9hcml0aG1ldGljL2FkZC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9hcml0aG1ldGljL2NicnQuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vYXJpdGhtZXRpYy9jZWlsLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2FyaXRobWV0aWMvY3ViZS5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9hcml0aG1ldGljL2RpdmlkZS5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9hcml0aG1ldGljL2RvdERpdmlkZS5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9hcml0aG1ldGljL2RvdE11bHRpcGx5LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2FyaXRobWV0aWMvZG90UG93LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2FyaXRobWV0aWMvZXhwLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2FyaXRobWV0aWMvZml4LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2FyaXRobWV0aWMvZmxvb3IuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vYXJpdGhtZXRpYy9nY2QuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vYXJpdGhtZXRpYy9oeXBvdC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9hcml0aG1ldGljL2xjbS5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9hcml0aG1ldGljL2xvZy5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9hcml0aG1ldGljL2xvZzEwLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2FyaXRobWV0aWMvbW9kLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2FyaXRobWV0aWMvbXVsdGlwbHkuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vYXJpdGhtZXRpYy9ub3JtLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2FyaXRobWV0aWMvbnRoUm9vdC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9hcml0aG1ldGljL3Bvdy5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9hcml0aG1ldGljL3JvdW5kLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2FyaXRobWV0aWMvc2lnbi5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9hcml0aG1ldGljL3NxcnQuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vYXJpdGhtZXRpYy9zcXVhcmUuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vYXJpdGhtZXRpYy9zdWJ0cmFjdC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9hcml0aG1ldGljL3VuYXJ5TWludXMuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vYXJpdGhtZXRpYy91bmFyeVBsdXMuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vYXJpdGhtZXRpYy94Z2NkLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2JpdHdpc2UvYml0QW5kLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2JpdHdpc2UvYml0Tm90LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2JpdHdpc2UvYml0T3IuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vYml0d2lzZS9iaXRYb3IuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vYml0d2lzZS9sZWZ0U2hpZnQuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vYml0d2lzZS9yaWdodEFyaXRoU2hpZnQuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vYml0d2lzZS9yaWdodExvZ1NoaWZ0LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2NvbWJpbmF0b3JpY3MvYmVsbE51bWJlcnMuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vY29tYmluYXRvcmljcy9jYXRhbGFuLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2NvbWJpbmF0b3JpY3MvY29tcG9zaXRpb24uanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vY29tYmluYXRvcmljcy9zdGlybGluZ1MyLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2NvbXBsZXgvYXJnLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2NvbXBsZXgvY29uai5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9jb21wbGV4L2ltLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2NvbXBsZXgvcmUuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vZXhwcmVzc2lvbi9ldmFsLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2V4cHJlc3Npb24vaGVscC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9nZW9tZXRyeS9kaXN0YW5jZS5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9nZW9tZXRyeS9pbnRlcnNlY3QuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vbG9naWNhbC9hbmQuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vbG9naWNhbC9ub3QuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vbG9naWNhbC9vci5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9sb2dpY2FsL3hvci5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9tYXRyaXgvY29uY2F0LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL21hdHJpeC9jcm9zcy5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9tYXRyaXgvZGV0LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL21hdHJpeC9kaWFnLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL21hdHJpeC9kb3QuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vbWF0cml4L2V5ZS5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9tYXRyaXgvZmlsdGVyLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL21hdHJpeC9mbGF0dGVuLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL21hdHJpeC9mb3JFYWNoLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL21hdHJpeC9pbnYuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vbWF0cml4L21hcC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9tYXRyaXgvb25lcy5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9tYXRyaXgvcGFydGl0aW9uU2VsZWN0LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL21hdHJpeC9yYW5nZS5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9tYXRyaXgvcmVzaXplLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL21hdHJpeC9zaXplLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL21hdHJpeC9zb3J0LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL21hdHJpeC9zcXVlZXplLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL21hdHJpeC9zdWJzZXQuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vbWF0cml4L3RyYWNlLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL21hdHJpeC90cmFuc3Bvc2UuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vbWF0cml4L3plcm9zLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3Byb2JhYmlsaXR5L2NvbWJpbmF0aW9ucy5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9wcm9iYWJpbGl0eS9mYWN0b3JpYWwuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vcHJvYmFiaWxpdHkvZ2FtbWEuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vcHJvYmFiaWxpdHkva2xkaXZlcmdlbmNlLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3Byb2JhYmlsaXR5L211bHRpbm9taWFsLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3Byb2JhYmlsaXR5L3Blcm11dGF0aW9ucy5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9wcm9iYWJpbGl0eS9waWNrUmFuZG9tLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3Byb2JhYmlsaXR5L3JhbmRvbS5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9wcm9iYWJpbGl0eS9yYW5kb21JbnQuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vcmVsYXRpb25hbC9jb21wYXJlLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3JlbGF0aW9uYWwvZGVlcEVxdWFsLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3JlbGF0aW9uYWwvZXF1YWwuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vcmVsYXRpb25hbC9sYXJnZXIuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vcmVsYXRpb25hbC9sYXJnZXJFcS5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9yZWxhdGlvbmFsL3NtYWxsZXIuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vcmVsYXRpb25hbC9zbWFsbGVyRXEuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vcmVsYXRpb25hbC91bmVxdWFsLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3N0YXRpc3RpY3MvbWF4LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3N0YXRpc3RpY3MvbWVhbi5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9zdGF0aXN0aWNzL21lZGlhbi5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9zdGF0aXN0aWNzL21pbi5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9zdGF0aXN0aWNzL21vZGUuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vc3RhdGlzdGljcy9wcm9kLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3N0YXRpc3RpY3MvcXVhbnRpbGVTZXEuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vc3RhdGlzdGljcy9zdGQuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vc3RhdGlzdGljcy9zdW0uanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vc3RhdGlzdGljcy92YXIuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vdHJpZ29ub21ldHJ5L2Fjb3MuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vdHJpZ29ub21ldHJ5L2Fjb3NoLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9hY290LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9hY290aC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi90cmlnb25vbWV0cnkvYWNzYy5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi90cmlnb25vbWV0cnkvYWNzY2guanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vdHJpZ29ub21ldHJ5L2FzZWMuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vdHJpZ29ub21ldHJ5L2FzZWNoLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9hc2luLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9hc2luaC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi90cmlnb25vbWV0cnkvYXRhbi5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi90cmlnb25vbWV0cnkvYXRhbjIuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vdHJpZ29ub21ldHJ5L2F0YW5oLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9jb3MuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vdHJpZ29ub21ldHJ5L2Nvc2guanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vdHJpZ29ub21ldHJ5L2NvdC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi90cmlnb25vbWV0cnkvY290aC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi90cmlnb25vbWV0cnkvY3NjLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9jc2NoLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9zZWMuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vdHJpZ29ub21ldHJ5L3NlY2guanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vdHJpZ29ub21ldHJ5L3Npbi5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi90cmlnb25vbWV0cnkvc2luaC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi90cmlnb25vbWV0cnkvdGFuLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS90YW5oLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3VuaXRzL3RvLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3V0aWxzL2Nsb25lLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3V0aWxzL2Zvcm1hdC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi91dGlscy9pc0ludGVnZXIuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vdXRpbHMvaXNOZWdhdGl2ZS5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi91dGlscy9pc051bWVyaWMuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vdXRpbHMvaXNQb3NpdGl2ZS5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi91dGlscy9pc1plcm8uanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vdXRpbHMvdHlwZW9mLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2luZGV4LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9mdW5jdGlvbi9jb21waWxlLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9mdW5jdGlvbi9ldmFsLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9mdW5jdGlvbi9oZWxwLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9mdW5jdGlvbi9pbmRleC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZnVuY3Rpb24vcGFyc2UuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2Z1bmN0aW9uL3BhcnNlci5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vaW5kZXguanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2tleXdvcmRzLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9ub2RlL0FjY2Vzc29yTm9kZS5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vbm9kZS9BcnJheU5vZGUuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL25vZGUvQXNzaWdubWVudE5vZGUuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL25vZGUvQmxvY2tOb2RlLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9ub2RlL0NvbmRpdGlvbmFsTm9kZS5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vbm9kZS9Db25zdGFudE5vZGUuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL25vZGUvRnVuY3Rpb25Bc3NpZ25tZW50Tm9kZS5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vbm9kZS9GdW5jdGlvbk5vZGUuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL25vZGUvSW5kZXhOb2RlLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9ub2RlL05vZGUuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL25vZGUvT2JqZWN0Tm9kZS5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vbm9kZS9PcGVyYXRvck5vZGUuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL25vZGUvUGFyZW50aGVzaXNOb2RlLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9ub2RlL1JhbmdlTm9kZS5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vbm9kZS9TeW1ib2xOb2RlLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9ub2RlL1VwZGF0ZU5vZGUuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL25vZGUvaW5kZXguanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL25vZGUvdXRpbHMvYWNjZXNzLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9ub2RlL3V0aWxzL2Fzc2lnbi5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vb3BlcmF0b3JzLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9wYXJzZS5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vdHJhbnNmb3JtL2NvbmNhdC50cmFuc2Zvcm0uanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL3RyYW5zZm9ybS9lcnJvci50cmFuc2Zvcm0uanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL3RyYW5zZm9ybS9maWx0ZXIudHJhbnNmb3JtLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi90cmFuc2Zvcm0vZm9yRWFjaC50cmFuc2Zvcm0uanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL3RyYW5zZm9ybS9pbmRleC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vdHJhbnNmb3JtL2luZGV4LnRyYW5zZm9ybS5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vdHJhbnNmb3JtL21hcC50cmFuc2Zvcm0uanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL3RyYW5zZm9ybS9tYXgudHJhbnNmb3JtLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi90cmFuc2Zvcm0vbWVhbi50cmFuc2Zvcm0uanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL3RyYW5zZm9ybS9taW4udHJhbnNmb3JtLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi90cmFuc2Zvcm0vcmFuZ2UudHJhbnNmb3JtLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi90cmFuc2Zvcm0vc3Vic2V0LnRyYW5zZm9ybS5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FsZ2VicmEvZGVjb21wb3NpdGlvbi9sdXAuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9hbGdlYnJhL2RlY29tcG9zaXRpb24vc2x1LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vYWxnZWJyYS9pbmRleC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FsZ2VicmEvc29sdmVyL2xzb2x2ZS5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FsZ2VicmEvc29sdmVyL2x1c29sdmUuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9hbGdlYnJhL3NvbHZlci91c29sdmUuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9hbGdlYnJhL3NvbHZlci91dGlscy9zb2x2ZVZhbGlkYXRpb24uanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9hbGdlYnJhL3NwYXJzZS9jc19hbWQuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9hbGdlYnJhL3NwYXJzZS9jc19jb3VudHMuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9hbGdlYnJhL3NwYXJzZS9jc19kZnMuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9hbGdlYnJhL3NwYXJzZS9jc19ldHJlZS5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FsZ2VicmEvc3BhcnNlL2NzX2ZrZWVwLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vYWxnZWJyYS9zcGFyc2UvY3NfZmxpcC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FsZ2VicmEvc3BhcnNlL2NzX2lwdmVjLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vYWxnZWJyYS9zcGFyc2UvY3NfbGVhZi5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FsZ2VicmEvc3BhcnNlL2NzX2x1LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vYWxnZWJyYS9zcGFyc2UvY3NfbWFyay5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FsZ2VicmEvc3BhcnNlL2NzX21hcmtlZC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FsZ2VicmEvc3BhcnNlL2NzX3Blcm11dGUuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9hbGdlYnJhL3NwYXJzZS9jc19wb3N0LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vYWxnZWJyYS9zcGFyc2UvY3NfcmVhY2guanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9hbGdlYnJhL3NwYXJzZS9jc19zcHNvbHZlLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vYWxnZWJyYS9zcGFyc2UvY3Nfc3FyLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vYWxnZWJyYS9zcGFyc2UvY3NfdGRmcy5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FsZ2VicmEvc3BhcnNlL2NzX3VuZmxpcC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FyaXRobWV0aWMvYWJzLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vYXJpdGhtZXRpYy9hZGQuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9hcml0aG1ldGljL2FkZFNjYWxhci5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FyaXRobWV0aWMvY2JydC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FyaXRobWV0aWMvY2VpbC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FyaXRobWV0aWMvY3ViZS5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FyaXRobWV0aWMvZGl2aWRlLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vYXJpdGhtZXRpYy9kaXZpZGVTY2FsYXIuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9hcml0aG1ldGljL2RvdERpdmlkZS5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FyaXRobWV0aWMvZG90TXVsdGlwbHkuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9hcml0aG1ldGljL2RvdFBvdy5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FyaXRobWV0aWMvZXhwLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vYXJpdGhtZXRpYy9maXguanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9hcml0aG1ldGljL2Zsb29yLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vYXJpdGhtZXRpYy9nY2QuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9hcml0aG1ldGljL2h5cG90LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vYXJpdGhtZXRpYy9pbmRleC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FyaXRobWV0aWMvbGNtLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vYXJpdGhtZXRpYy9sb2cuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9hcml0aG1ldGljL2xvZzEwLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vYXJpdGhtZXRpYy9tb2QuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9hcml0aG1ldGljL211bHRpcGx5LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vYXJpdGhtZXRpYy9tdWx0aXBseVNjYWxhci5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FyaXRobWV0aWMvbm9ybS5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FyaXRobWV0aWMvbnRoUm9vdC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FyaXRobWV0aWMvcG93LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vYXJpdGhtZXRpYy9yb3VuZC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FyaXRobWV0aWMvc2lnbi5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FyaXRobWV0aWMvc3FydC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FyaXRobWV0aWMvc3F1YXJlLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vYXJpdGhtZXRpYy9zdWJ0cmFjdC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FyaXRobWV0aWMvdW5hcnlNaW51cy5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FyaXRobWV0aWMvdW5hcnlQbHVzLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vYXJpdGhtZXRpYy94Z2NkLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vYml0d2lzZS9iaXRBbmQuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9iaXR3aXNlL2JpdE5vdC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2JpdHdpc2UvYml0T3IuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9iaXR3aXNlL2JpdFhvci5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2JpdHdpc2UvaW5kZXguanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9iaXR3aXNlL2xlZnRTaGlmdC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2JpdHdpc2UvcmlnaHRBcml0aFNoaWZ0LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vYml0d2lzZS9yaWdodExvZ1NoaWZ0LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vY29tYmluYXRvcmljcy9iZWxsTnVtYmVycy5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2NvbWJpbmF0b3JpY3MvY2F0YWxhbi5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2NvbWJpbmF0b3JpY3MvY29tcG9zaXRpb24uanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9jb21iaW5hdG9yaWNzL2luZGV4LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vY29tYmluYXRvcmljcy9zdGlybGluZ1MyLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vY29tcGxleC9hcmcuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9jb21wbGV4L2NvbmouanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9jb21wbGV4L2ltLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vY29tcGxleC9pbmRleC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2NvbXBsZXgvcmUuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9nZW9tZXRyeS9kaXN0YW5jZS5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2dlb21ldHJ5L2luZGV4LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vZ2VvbWV0cnkvaW50ZXJzZWN0LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vaW5kZXguanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9sb2dpY2FsL2FuZC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2xvZ2ljYWwvaW5kZXguanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9sb2dpY2FsL25vdC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2xvZ2ljYWwvb3IuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9sb2dpY2FsL3hvci5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL21hdHJpeC9jb25jYXQuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9tYXRyaXgvY3Jvc3MuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9tYXRyaXgvZGV0LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vbWF0cml4L2RpYWcuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9tYXRyaXgvZG90LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vbWF0cml4L2V5ZS5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL21hdHJpeC9maWx0ZXIuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9tYXRyaXgvZmxhdHRlbi5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL21hdHJpeC9mb3JFYWNoLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vbWF0cml4L2luZGV4LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vbWF0cml4L2ludi5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL21hdHJpeC9tYXAuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9tYXRyaXgvb25lcy5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL21hdHJpeC9wYXJ0aXRpb25TZWxlY3QuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9tYXRyaXgvcmFuZ2UuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9tYXRyaXgvcmVzaXplLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vbWF0cml4L3NpemUuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9tYXRyaXgvc29ydC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL21hdHJpeC9zcXVlZXplLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vbWF0cml4L3N1YnNldC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL21hdHJpeC90cmFjZS5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL21hdHJpeC90cmFuc3Bvc2UuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9tYXRyaXgvemVyb3MuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9wcm9iYWJpbGl0eS9jb21iaW5hdGlvbnMuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9wcm9iYWJpbGl0eS9kaXN0cmlidXRpb24uanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9wcm9iYWJpbGl0eS9mYWN0b3JpYWwuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9wcm9iYWJpbGl0eS9nYW1tYS5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3Byb2JhYmlsaXR5L2luZGV4LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vcHJvYmFiaWxpdHkva2xkaXZlcmdlbmNlLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vcHJvYmFiaWxpdHkvbXVsdGlub21pYWwuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9wcm9iYWJpbGl0eS9wZXJtdXRhdGlvbnMuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9wcm9iYWJpbGl0eS9waWNrUmFuZG9tLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vcHJvYmFiaWxpdHkvcmFuZG9tLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vcHJvYmFiaWxpdHkvcmFuZG9tSW50LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vcmVsYXRpb25hbC9jb21wYXJlLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vcmVsYXRpb25hbC9kZWVwRXF1YWwuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9yZWxhdGlvbmFsL2VxdWFsLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vcmVsYXRpb25hbC9lcXVhbFNjYWxhci5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3JlbGF0aW9uYWwvaW5kZXguanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9yZWxhdGlvbmFsL2xhcmdlci5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3JlbGF0aW9uYWwvbGFyZ2VyRXEuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9yZWxhdGlvbmFsL3NtYWxsZXIuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9yZWxhdGlvbmFsL3NtYWxsZXJFcS5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3JlbGF0aW9uYWwvdW5lcXVhbC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3N0YXRpc3RpY3MvaW5kZXguanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9zdGF0aXN0aWNzL21heC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3N0YXRpc3RpY3MvbWVhbi5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3N0YXRpc3RpY3MvbWVkaWFuLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vc3RhdGlzdGljcy9taW4uanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9zdGF0aXN0aWNzL21vZGUuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9zdGF0aXN0aWNzL3Byb2QuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9zdGF0aXN0aWNzL3F1YW50aWxlU2VxLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vc3RhdGlzdGljcy9zdGQuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9zdGF0aXN0aWNzL3N1bS5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3N0YXRpc3RpY3MvdmFyLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vc3RyaW5nL2Zvcm1hdC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3N0cmluZy9pbmRleC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3N0cmluZy9wcmludC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9hY29zLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vdHJpZ29ub21ldHJ5L2Fjb3NoLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vdHJpZ29ub21ldHJ5L2Fjb3QuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi90cmlnb25vbWV0cnkvYWNvdGguanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi90cmlnb25vbWV0cnkvYWNzYy5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9hY3NjaC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9hc2VjLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vdHJpZ29ub21ldHJ5L2FzZWNoLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vdHJpZ29ub21ldHJ5L2FzaW4uanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi90cmlnb25vbWV0cnkvYXNpbmguanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi90cmlnb25vbWV0cnkvYXRhbi5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9hdGFuMi5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9hdGFuaC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9jb3MuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi90cmlnb25vbWV0cnkvY29zaC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9jb3QuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi90cmlnb25vbWV0cnkvY290aC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9jc2MuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi90cmlnb25vbWV0cnkvY3NjaC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9pbmRleC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9zZWMuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi90cmlnb25vbWV0cnkvc2VjaC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9zaW4uanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi90cmlnb25vbWV0cnkvc2luaC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS90YW4uanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi90cmlnb25vbWV0cnkvdGFuaC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3VuaXQvaW5kZXguanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi91bml0L3RvLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vdXRpbHMvY2xvbmUuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi91dGlscy9pbmRleC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3V0aWxzL2lzSW50ZWdlci5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3V0aWxzL2lzTmVnYXRpdmUuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi91dGlscy9pc051bWVyaWMuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi91dGlscy9pc1Bvc2l0aXZlLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vdXRpbHMvaXNaZXJvLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vdXRpbHMvdHlwZW9mLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvaW5kZXguanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9qc29uL2luZGV4LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvanNvbi9yZXZpdmVyLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdHlwZS9iaWdudW1iZXIvQmlnTnVtYmVyLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdHlwZS9iaWdudW1iZXIvZnVuY3Rpb24vYmlnbnVtYmVyLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdHlwZS9iaWdudW1iZXIvaW5kZXguanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi90eXBlL2Jvb2xlYW4uanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi90eXBlL2NoYWluL0NoYWluLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdHlwZS9jaGFpbi9mdW5jdGlvbi9jaGFpbi5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL3R5cGUvY2hhaW4vaW5kZXguanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi90eXBlL2NvbXBsZXgvQ29tcGxleC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL3R5cGUvY29tcGxleC9mdW5jdGlvbi9jb21wbGV4LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdHlwZS9jb21wbGV4L2luZGV4LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdHlwZS9mcmFjdGlvbi9GcmFjdGlvbi5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL3R5cGUvZnJhY3Rpb24vZnVuY3Rpb24vZnJhY3Rpb24uanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi90eXBlL2ZyYWN0aW9uL2luZGV4LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdHlwZS9pbmRleC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL3R5cGUvbWF0cml4L0RlbnNlTWF0cml4LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdHlwZS9tYXRyaXgvRmlib25hY2NpSGVhcC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL3R5cGUvbWF0cml4L0ltbXV0YWJsZURlbnNlTWF0cml4LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdHlwZS9tYXRyaXgvTWF0cml4LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdHlwZS9tYXRyaXgvTWF0cml4SW5kZXguanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi90eXBlL21hdHJpeC9SYW5nZS5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL3R5cGUvbWF0cml4L1NwYS5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL3R5cGUvbWF0cml4L1NwYXJzZU1hdHJpeC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL3R5cGUvbWF0cml4L2Z1bmN0aW9uL2luZGV4LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdHlwZS9tYXRyaXgvZnVuY3Rpb24vbWF0cml4LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdHlwZS9tYXRyaXgvZnVuY3Rpb24vc3BhcnNlLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdHlwZS9tYXRyaXgvaW5kZXguanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0wMS5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTAyLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMDMuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0wNC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTA1LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMDYuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0wNy5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTA4LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMDkuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xMC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTExLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMTIuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xMy5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTE0LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdHlwZS9udW1iZXIuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi90eXBlL3Jlc3VsdHNldC9SZXN1bHRTZXQuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi90eXBlL3Jlc3VsdHNldC9pbmRleC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL3R5cGUvc3RyaW5nLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdHlwZS91bml0L1VuaXQuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi90eXBlL3VuaXQvZnVuY3Rpb24vdW5pdC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL3R5cGUvdW5pdC9pbmRleC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL3R5cGUvdW5pdC9waHlzaWNhbENvbnN0YW50cy5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL3V0aWxzL051bWJlckZvcm1hdHRlci5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL3V0aWxzL2FycmF5LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdXRpbHMvYmlnbnVtYmVyL2JpdEFuZC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL3V0aWxzL2JpZ251bWJlci9iaXROb3QuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi91dGlscy9iaWdudW1iZXIvYml0T3IuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi91dGlscy9iaWdudW1iZXIvYml0WG9yLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdXRpbHMvYmlnbnVtYmVyL2JpdHdpc2UuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi91dGlscy9iaWdudW1iZXIvY29uc3RhbnRzLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdXRpbHMvYmlnbnVtYmVyL2Zvcm1hdHRlci5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL3V0aWxzL2JpZ251bWJlci9sZWZ0U2hpZnQuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi91dGlscy9iaWdudW1iZXIvbmVhcmx5RXF1YWwuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi91dGlscy9iaWdudW1iZXIvcmlnaHRBcml0aFNoaWZ0LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdXRpbHMvYm9vbGVhbi5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL3V0aWxzL2NvbGxlY3Rpb24vY29udGFpbnNDb2xsZWN0aW9ucy5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL3V0aWxzL2NvbGxlY3Rpb24vZGVlcEZvckVhY2guanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi91dGlscy9jb2xsZWN0aW9uL2RlZXBNYXAuanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi91dGlscy9jb2xsZWN0aW9uL2lzQ29sbGVjdGlvbi5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL3V0aWxzL2NvbGxlY3Rpb24vcmVkdWNlLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdXRpbHMvY29sbGVjdGlvbi9zY2F0dGVyLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdXRpbHMvZW1pdHRlci5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL3V0aWxzL2Z1bmN0aW9uLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdXRpbHMvaW5kZXguanMiLCIuLi92aS1lYS9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi91dGlscy9sYXRleC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL3V0aWxzL251bWJlci5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL3V0aWxzL29iamVjdC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL3V0aWxzL3N0cmluZy5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL3V0aWxzL3R5cGVzLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdmVyc2lvbi5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbm9kZV9tb2R1bGVzL2NvbXBsZXguanMvY29tcGxleC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbm9kZV9tb2R1bGVzL2RlY2ltYWwuanMvZGVjaW1hbC5qcyIsIi4uL3ZpLWVhL25vZGVfbW9kdWxlcy9tYXRoanMvbm9kZV9tb2R1bGVzL2ZyYWN0aW9uLmpzL2ZyYWN0aW9uLmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9ub2RlX21vZHVsZXMvdGlueS1lbWl0dGVyL2luZGV4LmpzIiwiLi4vdmktZWEvbm9kZV9tb2R1bGVzL21hdGhqcy9ub2RlX21vZHVsZXMvdHlwZWQtZnVuY3Rpb24vdHlwZWQtZnVuY3Rpb24uanMiLCIuLi92aS1lYS9zcmMvYWR1bHRfc2VsZWN0aW9uLmpzIiwiLi4vdmktZWEvc3JjL2ZpeGVkX2JpdF92ZWN0b3IuanMiLCIuLi92aS1lYS9zcmMvcGFyZW50X3NlbGVjdGlvbi5qcyIsIi4uL3ZpLWVhL3NyYy9yZXByb2R1Y3Rpb24uanMiLCIuLi92aS1lYS9zcmMvc3lzdGVtLmpzIiwiLi4vdmktZWEvdmktZWEuanMiLCIuLi92aS1mbGF0bGFuZC1lYS92aS1mbGF0bGFuZC1lYS5qcyIsIi4uL3ZpLWZsYXRsYW5kLXdvcmxkL3ZpLWZsYXRsYW5kLXdvcmxkLmpzIiwic3JjL3ZpLWZsYXRsYW5kLmpzIiwiLi4vdmktdXRpbGl0eS92aS11dGlsaXR5LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7OztJQ0FhO0FBRVQsYUFGUyxPQUVULENBQVksTUFBWixFQUNBOzhCQUhTLFNBR1Q7O0FBQ0ksYUFBSyxNQUFMLEdBQWMsTUFBZCxDQURKO0tBREE7O2lCQUZTOztpQ0FPQSxRQUNUOzs7Ozs7QUFDSSxxQ0FBa0IsS0FBSyxNQUFMLDBCQUFsQixvR0FDQTt3QkFEUyxvQkFDVDs7QUFDSSw2QkFBUyxNQUFNLFNBQU4sQ0FBZ0IsTUFBaEIsQ0FBVCxDQURKO2lCQURBOzs7Ozs7Ozs7Ozs7OzthQURKOztBQU1JLG1CQUFPLE1BQVAsQ0FOSjs7OztXQVJTOzs7SUFrQkE7QUFFVCxhQUZTLEtBRVQsQ0FBWSxJQUFaLEVBQWtCLE9BQWxCLEVBQTJCLGtCQUEzQixFQUNBOzhCQUhTLE9BR1Q7O0FBQ0ksYUFBSyxJQUFMLEdBQTBCLElBQTFCLENBREo7QUFFSSxhQUFLLE9BQUwsR0FBMEIsT0FBMUIsQ0FGSjtBQUdJLGFBQUssa0JBQUwsR0FBMEIsa0JBQTFCLENBSEo7O0FBS0ksYUFBSyxPQUFMLEdBQWUsSUFBSSxLQUFKLENBQVUsS0FBSyxJQUFMLENBQXpCLENBTEo7S0FEQTs7aUJBRlM7O2tDQVdDLFFBQ1Y7QUFDSSxnQkFBTSxZQUFhLE9BQU8sTUFBUCxDQUR2QjtBQUVJLGdCQUFNLGFBQWEsS0FBSyxPQUFMLENBQWEsTUFBYixDQUZ2Qjs7QUFJSSxpQkFBSyxJQUFJLElBQUksQ0FBSixFQUFPLElBQUksVUFBSixFQUFnQixLQUFLLENBQUwsRUFDaEM7QUFDSSxvQkFBSSxNQUFNLEtBQUssSUFBTCxDQUFVLENBQVYsQ0FBTixDQURSOztBQUdJLHFCQUFLLElBQUksSUFBSSxDQUFKLEVBQU8sSUFBSSxTQUFKLEVBQWUsS0FBSyxDQUFMLEVBQy9CO0FBQ0ksMkJBQU8sS0FBSyxPQUFMLENBQWEsSUFBSSxTQUFKLEdBQWdCLENBQWhCLENBQWIsR0FBa0MsT0FBTyxDQUFQLENBQWxDLENBRFg7aUJBREE7O0FBS0EscUJBQUssT0FBTCxDQUFhLENBQWIsSUFBa0IsS0FBSyxrQkFBTCxDQUF3QixHQUF4QixDQUFsQixDQVJKO2FBREE7O0FBWUEsbUJBQU8sS0FBSyxPQUFMLENBaEJYOzs7OzRCQW9CQTtBQUNJLG1CQUFPLEtBQUssSUFBTCxDQUFVLE1BQVYsQ0FEWDs7OztXQWhDUzs7Ozs7Ozs7Ozs7QUNsQmI7O0lBQVk7Ozs7UUFDSDs7O0FDRFQ7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwOENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ROQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDck1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3oxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzF6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4eUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9wQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzc1SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzN3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7SUN6eENhOzs7Ozs7OytCQUVGLFlBQVksZ0JBQ25CO0FBQ0ksZ0JBQU0saUJBQWlCLFdBQVcsTUFBWCxDQUQzQjtBQUVJLGdCQUFJLGlCQUFtQixJQUFJLEtBQUosQ0FBVSxjQUFWLENBQW5CLENBRlI7O0FBSUksaUJBQUssSUFBSSxJQUFJLENBQUosRUFBTyxLQUFLLFdBQVcsTUFBWCxFQUFtQixHQUF4QyxFQUNBO0FBQ0ksK0JBQWUsQ0FBZixJQUFvQixlQUFlLElBQWYsR0FBc0IsS0FBdEIsQ0FEeEI7YUFEQTs7QUFLQSxtQkFBTyxjQUFQLENBVEo7Ozs7V0FIUzs7Ozs7Ozs7Ozs7OztBQ0FiOztJQUFZOzs7Ozs7SUFFQztBQUVULGFBRlMsT0FFVCxDQUFZLE1BQVosRUFDQTtZQURvQiwwRUFBb0IsbUJBQ3hDOzs4QkFIUyxTQUdUOztBQUNJLGFBQUssTUFBTCxHQUF5QixNQUF6QixDQURKO0FBRUksYUFBSyxpQkFBTCxHQUF5QixpQkFBekIsQ0FGSjtLQURBOztpQkFGUzs7aUNBU1Q7OztBQUNJLG1CQUFPLE1BQU0sSUFBTixDQUNILEVBQUMsUUFBUSxLQUFLLE1BQUwsRUFETixFQUVIO3VCQUFNLEtBQUssTUFBTCxLQUFnQixNQUFLLGlCQUFMO2FBQXRCLENBRkosQ0FESjs7OztXQVRTOzs7SUFnQkE7QUFFVCxhQUZTLE9BRVQsQ0FBWSxlQUFaLEVBQ0E7OEJBSFMsU0FHVDs7QUFDSSxhQUFLLGVBQUwsR0FBdUIsZUFBdkIsQ0FESjtLQURBOztpQkFGUzs7OEJBT0gsT0FDTjs7O0FBQ0ksa0JBQU0sT0FBTixDQUFjLFVBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQ2Q7QUFDSSxvQkFBSSxLQUFLLE1BQUwsS0FBZ0IsT0FBSyxlQUFMLEVBQ3BCO0FBQ0ksc0JBQUUsQ0FBRixJQUFPLENBQUMsRUFBRSxDQUFGLENBQUQsQ0FEWDtpQkFEQTthQUZVLENBQWQsQ0FESjs7QUFTSSxtQkFBTyxLQUFQLENBVEo7Ozs7V0FSUzs7O0lBcUJBO0FBRVQsYUFGUyxTQUVULENBQVksa0JBQVosRUFDQTtZQURnQywyRUFBcUIseUJBQ3JEOzs4QkFIUyxXQUdUOztBQUNJLGFBQUssa0JBQUwsR0FBMEIsa0JBQTFCLENBREo7QUFFSSxhQUFLLGtCQUFMLEdBQTBCLHNCQUFzQixrQkFBdEIsQ0FGOUI7S0FEQTs7aUJBRlM7OzhCQVFILEdBQUcsR0FDVDtBQUNJLGdCQUFNLFNBQVMsRUFBRSxNQUFGLENBRG5CO0FBRUksZ0JBQU0sUUFBUyxLQUFLLFNBQUwsQ0FBZSxDQUFmLEVBQWtCLE1BQWxCLENBQVQsQ0FGVjs7QUFJSSxpQkFBSyxJQUFJLElBQUksS0FBSixFQUFXLEtBQUssTUFBTCxFQUFhLEtBQUssQ0FBTCxFQUNqQzsyQkFDbUIsQ0FBQyxFQUFFLENBQUYsQ0FBRCxFQUFPLEVBQUUsQ0FBRixDQUFQLEVBRG5CO0FBQ0ssa0JBQUUsQ0FBRixZQURMO0FBQ1csa0JBQUUsQ0FBRixZQURYO2FBREE7O0FBS0EsbUJBQU8sQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFQLENBVEo7Ozs7V0FUUzs7Ozs7Ozs7Ozs7OztBQ3ZDYjs7SUFBWTs7QUFDWjs7SUFBWTs7Ozs7O0lBRUM7Ozs7Ozs7Z0NBRUQsWUFDUjtBQUNJLGdCQUFNLGFBQWEsV0FBVyxNQUFYLENBQ2YsVUFBQyxHQUFELEVBQU0sVUFBTjt1QkFBcUIsTUFBTSxXQUFXLE9BQVg7YUFBM0IsRUFBK0MsQ0FEaEMsQ0FBYixDQURWO0FBR0ksbUJBQU8sRUFBRSxZQUFZLFVBQVosRUFBVCxDQUhKOzs7OytCQU1PLFlBQVksV0FDbkI7QUFDSSxnQkFBSSxxQkFBcUIsSUFBckIsQ0FEUjtBQUVJLGdCQUFJLG1CQUFxQixLQUFLLE1BQUwsQ0FBWSxVQUFVLFVBQVYsQ0FBakMsQ0FGUjs7Ozs7OztBQUlJLHFDQUF1QixvQ0FBdkIsb0dBQ0E7d0JBRFMseUJBQ1Q7O0FBQ0ksd0JBQUksV0FBVyxPQUFYLEdBQXFCLENBQXJCLEVBQ0o7QUFDSSw2Q0FBc0IsVUFBdEIsQ0FESjtBQUVJLDRDQUFzQixXQUFXLE9BQVgsQ0FGMUI7O0FBSUksNEJBQUksbUJBQW1CLENBQW5CLEVBQ0o7QUFDSSxrQ0FESjt5QkFEQTtxQkFMSjtpQkFGSjs7Ozs7Ozs7Ozs7Ozs7YUFKSjs7QUFrQkksbUJBQU8sa0JBQVAsQ0FsQko7Ozs7V0FWUzs7O0lBZ0NBO0FBRVQsYUFGUyxJQUVULEdBQ0E7WUFEWSx5RUFBaUIsbUJBQzdCOzs4QkFIUyxNQUdUOztBQUNJLGFBQUssZ0JBQUwsR0FBd0IsZ0JBQXhCLENBREo7QUFFSSxhQUFLLGdCQUFMLEdBQXdCLElBQUksZ0JBQUosQ0FGNUI7S0FEQTs7aUJBRlM7O2dDQVFELFlBQ1I7QUFDSSx1QkFBVyxJQUFYLENBQWdCLFVBQUMsQ0FBRCxFQUFJLENBQUo7dUJBQVUsRUFBRSxPQUFGLEdBQVksRUFBRSxPQUFGO2FBQXRCLENBQWhCLENBREo7Ozs7K0JBSU8sWUFBWSxXQUNuQjtBQUNJLGdCQUFNLGlCQUFpQixXQUFXLE1BQVgsQ0FEM0I7O0FBR0ksZ0JBQUkscUJBQXlCLFdBQVcsaUJBQWlCLENBQWpCLENBQXBDLENBSFI7QUFJSSxnQkFBSSx5QkFBeUIsS0FBSyxNQUFMLENBQVksY0FBWixDQUF6QixDQUpSOztBQU1JLGlCQUFLLElBQUksWUFBWSxjQUFaLEVBQTRCLGFBQWEsQ0FBYixFQUFnQixXQUFyRCxFQUNBO0FBQ0ksb0JBQU0sZ0JBQWdCLEtBQUssZ0JBQUwsR0FDbEIsRUFBRyxLQUFLLGdCQUFMLEdBQXdCLEtBQUssZ0JBQUwsQ0FBM0IsSUFDTyxZQUFZLENBQVosQ0FEUCxJQUN5QixpQkFBaUIsQ0FBakIsQ0FEekIsQ0FGUjs7QUFLSSwwQ0FBMEIsYUFBMUIsQ0FMSjs7QUFPSSxvQkFBSSx5QkFBeUIsQ0FBekIsRUFDSjtBQUNJLHlDQUFxQixXQUFXLFlBQVksQ0FBWixDQUFoQyxDQURKO0FBRUksMEJBRko7aUJBREE7YUFSSjs7QUFlQSxtQkFBTyxrQkFBUCxDQXJCSjs7OztXQWRTOzs7SUF1Q0E7Ozs7Ozs7Z0NBRUQsWUFDUjtBQUNJLGdCQUFNLGdCQUFpQixXQUFXLEdBQVgsQ0FBZTt1QkFBSyxFQUFFLE9BQUY7YUFBTCxDQUFoQyxDQURWO0FBRUksZ0JBQU0sY0FBaUIsS0FBSyxJQUFMLENBQVUsYUFBVixDQUFqQixDQUZWO0FBR0ksZ0JBQU0saUJBQWlCLEtBQUssR0FBTCxDQUFTLGFBQVQsRUFBd0IsYUFBeEIsQ0FBakIsQ0FIVjs7QUFLSSxnQkFBTSxpQkFBaUIsY0FBYyxHQUFkLENBQ25CO3VCQUFnQixLQUNYLGlCQUFpQixDQUFqQixHQUNFLENBQUMsZUFBZSxXQUFmLENBQUQsSUFBZ0MsSUFBSSxjQUFKLENBQWhDLEdBQ0QsQ0FGRCxDQURXO2FBQWhCLENBREUsQ0FMVjs7QUFXSSxnQkFBTSxvQkFBb0IsZUFBZSxNQUFmLENBQXNCLFVBQUMsR0FBRCxFQUFNLGFBQU47dUJBQXdCLE1BQU0sYUFBTjthQUF4QixFQUE2QyxDQUFuRSxDQUFwQixDQVhWOztBQWFJLG1CQUFPLEVBQUUsZ0JBQWdCLGNBQWhCLEVBQWdDLG1CQUFtQixpQkFBbkIsRUFBekMsQ0FiSjs7OzsrQkFnQk8sWUFBWSxXQUNuQjtBQUNJLGdCQUFJLHFCQUF5QixJQUF6QixDQURSO0FBRUksZ0JBQUkseUJBQXlCLEtBQUssTUFBTCxDQUFZLFVBQVUsaUJBQVYsQ0FBckMsQ0FGUjtBQUdJLGdCQUFNLGlCQUF1QixXQUFXLE1BQVgsQ0FIakM7O0FBS0ksaUJBQUssSUFBSSxJQUFJLENBQUosRUFBTyxJQUFJLGNBQUosRUFBb0IsR0FBcEMsRUFDQTtBQUNJLG9CQUFNLGFBQWdCLFdBQVcsQ0FBWCxDQUFoQixDQURWO0FBRUksb0JBQU0sZ0JBQWdCLFVBQVUsY0FBVixDQUF5QixDQUF6QixDQUFoQixDQUZWOztBQUlJLHFDQUEwQixVQUExQixDQUpKO0FBS0ksMENBQTBCLGFBQTFCLENBTEo7O0FBT0ksb0JBQUkseUJBQXlCLENBQXpCLEVBQ0o7QUFDSSwwQkFESjtpQkFEQTthQVJKOztBQWNBLG1CQUFPLGtCQUFQLENBbkJKOzs7O1dBcEJTOzs7SUEyQ0E7QUFFVCxhQUZTLFVBRVQsQ0FBWSxTQUFaLEVBQXVCLDBCQUF2QixFQUNBOzhCQUhTLFlBR1Q7O0FBQ0ksYUFBSyxTQUFMLEdBQWtDLFNBQWxDLENBREo7QUFFSSxhQUFLLDBCQUFMLEdBQWtDLDBCQUFsQyxDQUZKO0tBREE7O2lCQUZTOztnQ0FRRCxZQUNSOzs7K0JBR08sWUFBWSxXQUNuQjtBQUNJLGdCQUFJLFFBQVEsUUFBUSxNQUFSLENBQWUsVUFBZixFQUEyQixLQUFLLFNBQUwsQ0FBbkM7Ozs7OztBQURSLGdCQU9RLEtBQUssTUFBTCxNQUFpQixLQUFLLDBCQUFMLEVBQ3JCO0FBQ0ksc0JBQU0sSUFBTixDQUFXLFVBQUMsQ0FBRCxFQUFJLENBQUo7MkJBQVUsRUFBRSxPQUFGLEdBQVksRUFBRSxPQUFGO2lCQUF0QixDQUFYLENBREo7YUFEQTs7QUFLQSxtQkFBTyxNQUFNLENBQU4sQ0FBUCxDQVpKOzs7O1dBYlM7Ozs7Ozs7Ozs7Ozs7Ozs7SUNySEE7QUFFVCxhQUZTLE1BRVQsQ0FBWSxpQkFBWixFQUErQixlQUEvQixFQUNBOzhCQUhTLFFBR1Q7O0FBQ0ksYUFBSyxpQkFBTCxHQUF5QixpQkFBekIsQ0FESjtBQUVJLGFBQUssZUFBTCxHQUF5QixlQUF6QixDQUZKO0tBREE7O2lCQUZTOztrQ0FRQyxnQkFDVjtBQUNJLGdCQUFNLGNBQWUsZUFBZSxJQUFmLEdBQXNCLEtBQXRCLENBRHpCO0FBRUksZ0JBQU0sZUFBZSxlQUFlLElBQWYsR0FBc0IsS0FBdEIsQ0FGekI7O0FBSUksZ0JBQUkscUJBQXNCLFlBQVksUUFBWixDQUFxQixLQUFyQixFQUF0QixDQUpSO0FBS0ksZ0JBQUksc0JBQXNCLGFBQWEsUUFBYixDQUFzQixLQUF0QixFQUF0QixDQUxSOzt3Q0FRUSxLQUFLLGlCQUFMLENBQXVCLEtBQXZCLENBQTZCLGtCQUE3QixFQUFpRCxtQkFBakQsRUFSUjs7OztBQU9LLDJEQVBMO0FBT3lCLDREQVB6Qjs7O0FBVUksaUNBQXNCLEtBQUssZUFBTCxDQUFxQixLQUFyQixDQUEyQixrQkFBM0IsQ0FBdEIsQ0FWSjtBQVdJLGtDQUFzQixLQUFLLGVBQUwsQ0FBcUIsS0FBckIsQ0FBMkIsbUJBQTNCLENBQXRCLENBWEo7O0FBYUksbUJBQU8sQ0FBQyxrQkFBRCxFQUFxQixtQkFBckIsQ0FBUCxDQWJKOzs7O1dBVFM7Ozs7Ozs7Ozs7Ozs7QUNBYjs7SUFBWTs7Ozs7O0lBRUMsa0NBRVQsU0FGUyxVQUVULENBQVksUUFBWixFQUFzQixTQUF0QixFQUFpQyxPQUFqQyxFQUNBOzBCQUhTLFlBR1Q7O0FBQ0ksU0FBSyxRQUFMLEdBQWlCLFFBQWpCLENBREo7QUFFSSxTQUFLLFNBQUwsR0FBaUIsU0FBakIsQ0FGSjtBQUdJLFNBQUssT0FBTCxHQUFpQixPQUFqQixDQUhKO0NBREE7O0lBUVM7QUFFVCxhQUZTLE1BRVQsQ0FBWSxPQUFaLEVBQ0E7OEJBSFMsUUFHVDs7QUFDSSxhQUFLLGNBQUwsR0FBaUMsUUFBUSxjQUFSLENBRHJDO0FBRUksYUFBSyxZQUFMLEdBQWlDLFFBQVEsWUFBUixDQUZyQztBQUdJLGFBQUssd0JBQUwsR0FBaUMsUUFBUSx3QkFBUixDQUhyQztBQUlJLGFBQUssdUJBQUwsR0FBaUMsUUFBUSx1QkFBUixDQUpyQztBQUtJLGFBQUssc0JBQUwsR0FBaUMsUUFBUSxzQkFBUixDQUxyQztBQU1JLGFBQUssb0JBQUwsR0FBaUMsUUFBUSxvQkFBUixDQU5yQztBQU9JLGFBQUsseUJBQUwsR0FBaUMsUUFBUSx5QkFBUixDQVByQztBQVFJLGFBQUssbUJBQUwsR0FBaUMsUUFBUSxtQkFBUixJQUErQixJQUEvQixDQVJyQzs7QUFVSSxhQUFLLFVBQUwsR0FBa0IsS0FBSyx1QkFBTCxFQUFsQixDQVZKO0FBV0ksYUFBSyxVQUFMLEdBQWtCLENBQWxCLENBWEo7S0FEQTs7aUJBRlM7O2tEQWtCVDtBQUNJLGdCQUFJLGFBQWEsSUFBSSxLQUFKLENBQVUsS0FBSyxjQUFMLENBQXZCLENBRFI7O0FBR0ksZ0JBQUksc0JBQXNCLFVBQVUsVUFBVixDQUN0QixLQUFLLHdCQUFMLEVBQStCLEtBQUsseUJBQUwsRUFBZ0MsS0FBSyxtQkFBTCxDQUQvRCxDQUhSOztBQU1JLGlCQUFLLElBQUksSUFBSSxDQUFKLEVBQU8sS0FBSyxLQUFLLGNBQUwsRUFBcUIsR0FBMUMsRUFDQTtBQUNJLDJCQUFXLENBQVgsSUFBZ0Isb0JBQW9CLElBQXBCLEdBQTJCLEtBQTNCLENBRHBCO2FBREE7O0FBS0EsbUJBQU8sVUFBUCxDQVhKOzs7O2lDQWVBO0FBQ0ksZ0JBQUksV0FBVyxJQUFYLENBRFI7O0FBR0ksZ0JBQUksS0FBSyxZQUFMLEVBQ0o7QUFDSSxxQkFBSyxVQUFMLENBQWdCLElBQWhCLENBQXFCLFVBQUMsQ0FBRCxFQUFJLENBQUo7MkJBQVUsRUFBRSxPQUFGLEdBQVksRUFBRSxPQUFGO2lCQUF0QixDQUFyQixDQURKO0FBRUksMkJBQVcsS0FBSyxVQUFMLENBQWdCLE1BQWhCLENBQXVCLENBQXZCLEVBQTBCLEtBQUssWUFBTCxDQUFyQyxDQUZKO2FBREE7O0FBTUEsZ0JBQU0sWUFBaUIsS0FBSyx1QkFBTCxDQUE2QixPQUE3QixDQUFxQyxLQUFLLFVBQUwsQ0FBdEQsQ0FUVjtBQVVJLGdCQUFNLGlCQUFpQixVQUFVLE1BQVYsQ0FBaUIsS0FBSyxVQUFMLEVBQWlCLFNBQWxDLEVBQTZDLEtBQUssdUJBQUwsQ0FBOUQsQ0FWVjtBQVdJLGdCQUFNLGlCQUFpQixVQUFVLEtBQVYsQ0FDbkIsY0FEbUIsRUFDSCxLQUFLLG9CQUFMLEVBQTJCLEtBQUssbUJBQUwsRUFBMEIsS0FBSyx5QkFBTCxDQURuRSxDQVhWOztBQWNJLGdCQUFNLGlCQUFpQixLQUFLLHNCQUFMLENBQTRCLE1BQTVCLENBQW1DLEtBQUssVUFBTCxFQUFpQixjQUFwRCxDQUFqQixDQWRWO0FBZUksaUJBQUssVUFBTCxHQUF1QixXQUFXLFNBQVMsTUFBVCxDQUFnQixjQUFoQixDQUFYLEdBQTZDLGNBQTdDLENBZjNCOztBQWlCSSxpQkFBSyxVQUFMLEdBakJKOzs7O2dDQXFCQTtBQUNJLGdCQUFNLGdCQUFpQixLQUFLLFVBQUwsQ0FBZ0IsR0FBaEIsQ0FBb0I7dUJBQUssRUFBRSxPQUFGO2FBQUwsQ0FBckMsQ0FEVjtBQUVJLGdCQUFNLGNBQWlCLEtBQUssSUFBTCxDQUFVLGFBQVYsQ0FBakIsQ0FGVjtBQUdJLGdCQUFNLGlCQUFpQixLQUFLLEdBQUwsQ0FBUyxhQUFULEVBQXdCLGFBQXhCLENBQWpCLENBSFY7O0FBS0ksZ0JBQU0saUJBQWlCLEtBQUssVUFBTCxDQUFnQixNQUFoQixDQUNuQixVQUFDLEVBQUQsRUFBSyxFQUFMO3VCQUFZLE1BQU0sR0FBRyxPQUFILEdBQWEsR0FBRyxPQUFILEdBQWEsRUFBaEMsR0FBcUMsRUFBckM7YUFBWixFQUFxRCxJQURsQyxDQUFqQixDQUxWOztBQVFJLG1CQUFPO0FBQ0gsNkJBQWdCLFdBQWhCO0FBQ0EsZ0NBQWdCLGNBQWhCO0FBQ0EsZ0NBQWdCLGNBQWhCO0FBQ0EsNEJBQWdCLEtBQUssVUFBTCxFQUpwQixDQVJKOzs7O1dBdERTOzs7QUFzRWIsSUFBTSxZQUFZLE9BQU8sTUFBUCxDQUFjLFlBQ2hDO0FBQ0ksUUFBSSxJQUFJLEVBQUosQ0FEUjs7QUFHSSxNQUFFLEtBQUYsMkJBQVUsaUJBQ04sY0FETSxFQUNVLG9CQURWLEVBQ2dDLG1CQURoQyxFQUNxRCx5QkFEckQ7WUFLSSxtR0FFSyxlQUVELGdCQU1FOzs7Ozs7NkJBWlQ7Ozs7O0FBRUcsNENBQW9CLHFCQUFxQixTQUFyQixDQUErQixjQUEvQjs7Ozs7b0NBRUU7Ozs7Ozs7O0FBQWpCO0FBRUQseUNBQWtCLHNCQUNsQixvQkFBb0IsT0FBcEIsQ0FBNEIsYUFBNUIsQ0FEa0IsR0FFbEIsYUFGa0I7OzZCQUlwQjs7Ozs7QUFFSSx1Q0FBZSwwQkFBMEIsUUFBMUIsQ0FBbUMsY0FBbkM7OytCQUNiLElBQUksVUFBSixDQUFlLGFBQWYsRUFBOEIsY0FBOUIsRUFBOEMsWUFBOUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQWhCWixDQUFWLENBSEo7O0FBeUJJLE1BQUUsVUFBRiwyQkFBZSxrQkFDWCx3QkFEVyxFQUNlLHlCQURmO1lBQzBDLDRFQUFzQjtZQUluRSxVQUNBLFdBS0k7Ozs7OzZCQVJMOzs7OztBQUVDLG1DQUFZLHlCQUF5QixNQUF6QjtBQUNaLG9DQUFhLHNCQUNYLG9CQUFvQixPQUFwQixDQUE0QixRQUE1QixDQURXLEdBQzZCLFFBRDdCOzs2QkFHYjs7Ozs7QUFFSSxrQ0FBVSwwQkFBMEIsUUFBMUIsQ0FBbUMsU0FBbkM7OytCQUNSLElBQUksVUFBSixDQUFlLFFBQWYsRUFBeUIsU0FBekIsRUFBb0MsT0FBcEM7Ozs7Ozs7Ozs7OztLQVpILENBQWYsQ0F6Qko7O0FBMENJLE1BQUUsTUFBRiwyQkFBVyxrQkFBVSxVQUFWLEVBQXNCLFNBQXRCLEVBQWlDLHVCQUFqQzs7Ozs7NkJBRUE7Ozs7OzsrQkFFRyx3QkFBd0IsTUFBeEIsQ0FBK0IsVUFBL0IsRUFBMkMsU0FBM0M7Ozs7Ozs7Ozs7OztLQUpILENBQVgsQ0ExQ0o7O0FBa0RJLFdBQU8sQ0FBUCxDQWxESjtDQURnQyxFQUFkLENBQVo7Ozs7Ozs7Ozs7Ozs7OzttQkN0RUc7Ozs7OzttQkFBWTs7OztBQVpyQjs7SUFBWTs7QUFHWjs7SUFBWTs7QUFHWjs7SUFBWTs7QUFHWjs7SUFBWTs7OztRQVJIO1FBR0E7UUFHQTtRQUdBOzs7Ozs7Ozs7Ozs7UUN1Rk87UUF5Q0E7UUEwRUE7UUFvSEE7UUF1QkE7O0FBL1ZoQjs7SUFBWTs7QUFDWjs7SUFBWTs7QUFDWjs7SUFBWTs7Ozs7O0FBRUwsSUFBTSwwQkFDYjtBQUNJLFVBQU0sQ0FBTixFQUFTLFVBQVUsQ0FBVixFQUFhLGFBQWEsQ0FBYixFQUFnQixXQUFXLENBQVg7Q0FGN0I7O0FBS04sSUFBTSw0QkFDYjtBQUNJLFFBQUksQ0FBSixFQUFPLE9BQU8sQ0FBUCxFQUFVLE1BQU0sQ0FBTixFQUFTLE1BQU0sQ0FBTjtDQUZqQjs7QUFLTixJQUFNLG9DQUFjLE9BQU8sTUFBUCxDQUMzQjtBQUNJLFVBQU0sQ0FBTixFQUFTLE1BQU0sQ0FBTixFQUFTLFFBQVEsQ0FBUjtDQUZLLENBQWQ7O0FBS2IsSUFBTSxVQUFVLE9BQU8sTUFBUCxDQUFjLFlBQzlCO0FBQ0ksUUFBSSxJQUFJLEVBQUosQ0FEUjs7QUFHSSxNQUFFLGtCQUFGLEdBQXVCLFVBQVMsS0FBVCxFQUFnQixDQUFoQixFQUFtQixDQUFuQixFQUFzQixLQUF0QixFQUE2QixNQUE3QixFQUN2QjtBQUNJLFlBQUksSUFBSSxDQUFKLEVBQ0o7QUFDSSxrQkFBTSxJQUFJLEtBQUosR0FBWSxDQUFaLEdBQWdCLENBQWhCLENBQU4sR0FBMkIsQ0FBM0IsQ0FESjtTQURBO0FBSUEsWUFBSSxJQUFJLFFBQVEsQ0FBUixFQUNSO0FBQ0ksa0JBQU0sSUFBSSxLQUFKLEdBQVksQ0FBWixHQUFnQixDQUFoQixDQUFOLEdBQTJCLENBQTNCLENBREo7U0FEQTtBQUlBLFlBQUksSUFBSSxDQUFKLEVBQ0o7QUFDSSxrQkFBTSxDQUFDLElBQUksQ0FBSixDQUFELEdBQVUsS0FBVixHQUFrQixDQUFsQixDQUFOLEdBQTZCLENBQTdCLENBREo7U0FEQTtBQUlBLFlBQUksSUFBSSxTQUFTLENBQVQsRUFDUjtBQUNJLGtCQUFNLENBQUMsSUFBSSxDQUFKLENBQUQsR0FBVSxLQUFWLEdBQWtCLENBQWxCLENBQU4sR0FBNkIsQ0FBN0IsQ0FESjtTQURBO0tBZG1CLENBSDNCOztBQXVCSSxNQUFFLGlCQUFGLEdBQXNCLFVBQVMsS0FBVCxFQUFnQixPQUFoQixFQUN0QjtBQUNJLGdCQUFRLE9BQVI7QUFFSSxpQkFBSyxRQUFRLEVBQVI7QUFDTDtBQUNJLDJCQUFPLEVBQUUsR0FBRyxNQUFNLEtBQU4sQ0FBWSxDQUFaLEVBQWUsR0FBRyxDQUFDLE1BQU0sS0FBTixDQUFZLENBQVosR0FBZ0IsQ0FBaEIsR0FBb0IsTUFBTSxNQUFOLENBQXJCLEdBQXFDLE1BQU0sTUFBTixFQUFuRSxDQURKO2lCQURBO0FBRkosaUJBTVMsUUFBUSxJQUFSO0FBQ0w7QUFDSSwyQkFBTyxFQUFFLEdBQUcsTUFBTSxLQUFOLENBQVksQ0FBWixFQUFlLEdBQUcsQ0FBQyxNQUFNLEtBQU4sQ0FBWSxDQUFaLEdBQWdCLENBQWhCLENBQUQsR0FBc0IsTUFBTSxNQUFOLEVBQXBELENBREo7aUJBREE7QUFOSixpQkFVUyxRQUFRLElBQVI7QUFDTDtBQUNJLDJCQUFPLEVBQUUsR0FBRyxDQUFDLE1BQU0sS0FBTixDQUFZLENBQVosR0FBZ0IsQ0FBaEIsR0FBb0IsTUFBTSxLQUFOLENBQXJCLEdBQW9DLE1BQU0sS0FBTixFQUFhLEdBQUcsTUFBTSxLQUFOLENBQVksQ0FBWixFQUFoRSxDQURKO2lCQURBO0FBVkosaUJBY1MsUUFBUSxLQUFSO0FBQ0w7QUFDSSwyQkFBTyxFQUFFLEdBQUcsQ0FBQyxNQUFNLEtBQU4sQ0FBWSxDQUFaLEdBQWdCLENBQWhCLENBQUQsR0FBc0IsTUFBTSxLQUFOLEVBQWEsR0FBRyxNQUFNLEtBQU4sQ0FBWSxDQUFaLEVBQWxELENBREo7aUJBREE7QUFkSixTQURKO0tBRHNCLENBdkIxQjs7QUE4Q0ksTUFBRSxzQkFBRixHQUEyQixVQUFTLEtBQVQsRUFBZ0IsT0FBaEIsRUFDM0I7QUFDSSxZQUFNLFNBQVMsRUFBRSxpQkFBRixDQUFvQixLQUFwQixFQUEyQixPQUEzQixDQUFULENBRFY7QUFFSSxlQUFPLE1BQU0sS0FBTixDQUFZLE9BQU8sQ0FBUCxHQUFXLE1BQU0sS0FBTixHQUFjLE9BQU8sQ0FBUCxDQUE1QyxDQUZKO0tBRDJCLENBOUMvQjs7QUFvREksTUFBRSxxQkFBRixHQUEwQixVQUFTLEdBQVQsRUFBYyxHQUFkLEVBQzFCO0FBQ0ksZUFBTyxLQUFLLEtBQUwsQ0FBVyxLQUFLLE1BQUwsTUFBaUIsTUFBTSxHQUFOLEdBQVksQ0FBWixDQUFqQixDQUFYLEdBQThDLEdBQTlDLENBRFg7S0FEMEIsQ0FwRDlCOztBQXlESSxNQUFFLE9BQUYsR0FBWSxVQUFTLEtBQVQsRUFDWjtBQUNJLFlBQUksZUFBZSxNQUFNLE1BQU47WUFBYyxjQUFqQztZQUFpRCxXQUFqRCxDQURKOztBQUdJLGVBQU8saUJBQWlCLENBQWpCLEVBQ1A7QUFDSSwwQkFBZ0IsS0FBSyxLQUFMLENBQVcsS0FBSyxNQUFMLEtBQWdCLFlBQWhCLENBQTNCLENBREo7QUFFSSw0QkFBZ0IsQ0FBaEIsQ0FGSjs7QUFJSSw2QkFBc0IsTUFBTSxZQUFOLENBQXRCLENBSko7QUFLSSxrQkFBTSxZQUFOLElBQXNCLE1BQU0sV0FBTixDQUF0QixDQUxKO0FBTUksa0JBQU0sV0FBTixJQUFzQixjQUF0QixDQU5KO1NBREE7O0FBVUEsZUFBTyxLQUFQLENBYko7S0FEWSxDQXpEaEI7O0FBMEVJLFdBQU8sQ0FBUCxDQTFFSjtDQUQ4QixFQUFkLENBQVY7O0FBOEVDLFNBQVMsbUJBQVQsQ0FDSCxVQURHLEVBQ1MsV0FEVCxFQUNzQixlQUR0QixFQUN1QyxpQkFEdkMsRUFFUDtBQUNJLFFBQU0saUJBQWtCLGFBQWEsV0FBYixDQUQ1QjtBQUVJLFFBQU0sZ0JBQWtCLEtBQUssS0FBTCxDQUFXLGtCQUFrQixjQUFsQixDQUE3QixDQUZWO0FBR0ksUUFBTSxrQkFBa0IsS0FBSyxLQUFMLENBQ3BCLHFCQUFxQixpQkFBaUIsYUFBakIsQ0FBckIsQ0FERSxDQUhWOztBQU1JLFFBQUksYUFBYSxJQUFJLEtBQUosQ0FBVSxjQUFWLEVBQTBCLElBQTFCLENBQStCLFlBQVksSUFBWixDQUE1QyxDQU5SOztBQVFJLFFBQUksaUJBQWlCLFFBQVEsT0FBUixDQUFnQixXQUFXLEdBQVgsQ0FBZSxVQUFDLEVBQUQsRUFBSyxDQUFMO2VBQVc7S0FBWCxDQUEvQixDQUFqQixDQVJSO0FBU0ksUUFBTSxZQUFlLGVBQWUsTUFBZixDQUFzQixDQUF0QixFQUF5QixhQUF6QixDQUFmLENBVFY7QUFVSSxRQUFNLGNBQWUsZUFBZSxNQUFmLENBQXNCLENBQXRCLEVBQXlCLGVBQXpCLENBQWYsQ0FWVjtBQVdJLFFBQU0sWUFBZSxlQUFlLE1BQWYsQ0FBc0IsQ0FBdEIsRUFBeUIsQ0FBekIsRUFBNEIsQ0FBNUIsQ0FBZixDQVhWOzs7Ozs7O0FBYUksNkJBQXFCLG1DQUFyQixvR0FDQTtnQkFEUyx1QkFDVDs7QUFDSSx1QkFBVyxRQUFYLElBQXVCLFlBQVksSUFBWixDQUQzQjtTQURBOzs7Ozs7Ozs7Ozs7OztLQWJKOzs7Ozs7O0FBa0JJLDhCQUF1QixzQ0FBdkIsd0dBQ0E7Z0JBRFMsMEJBQ1Q7O0FBQ0ksdUJBQVcsVUFBWCxJQUF5QixZQUFZLE1BQVosQ0FEN0I7U0FEQTs7Ozs7Ozs7Ozs7Ozs7S0FsQko7O0FBdUJJLFdBQU87QUFDSCxlQUFtQixVQUFuQjtBQUNBLGVBQW1CLFVBQW5CO0FBQ0EsZ0JBQW1CLFdBQW5CO0FBQ0EseUJBQW1CLGVBQW5CO0FBQ0EsMkJBQW1CLGlCQUFuQjtBQUNBLHVCQUFtQixhQUFuQjtBQUNBLHlCQUFtQixlQUFuQjtBQUNBLGVBQU87QUFDSCxlQUFTLFlBQVksVUFBWjtBQUNULGVBQVMsS0FBSyxLQUFMLENBQVcsWUFBWSxVQUFaLENBQXBCO0FBQ0EscUJBQVMsUUFBUSxxQkFBUixDQUE4QixRQUFRLEVBQVIsRUFBWSxRQUFRLEtBQVIsQ0FBbkQ7U0FISjtLQVJKLENBdkJKO0NBRk87O0FBeUNBLFNBQVMsNEJBQVQsQ0FBc0MsS0FBdEMsRUFDUDtBQUNJLFFBQU0sWUFBZSxJQUFJLE1BQU0sS0FBTixHQUFjLENBQWxCLENBRHpCO0FBRUksUUFBTSxhQUFlLElBQUksTUFBTSxNQUFOLEdBQWUsQ0FBbkIsQ0FGekI7QUFHSSxRQUFNLGVBQWUsWUFBWSxVQUFaLENBSHpCOztBQUtJLFFBQUksWUFBWSxJQUFJLEtBQUosQ0FBVSxZQUFWLEVBQXdCLElBQXhCLENBQTZCLGNBQWMsVUFBZCxDQUF5QixJQUF6QixDQUF6Qzs7O0FBTFIsU0FRUyxJQUFJLElBQUksQ0FBSixFQUFPLElBQUksVUFBSixFQUFnQixLQUFLLENBQUwsRUFDaEM7QUFDSSxhQUFLLElBQUksSUFBSSxDQUFKLEVBQU8sSUFBSSxTQUFKLEVBQWUsS0FBSyxDQUFMLEVBQy9CO0FBQ0ksZ0JBQUksSUFBSSxDQUFKLElBQVMsQ0FBVCxJQUFjLElBQUksQ0FBSixJQUFTLENBQVQsRUFDbEI7QUFDSSxvQkFBTSxRQUFhLElBQUksU0FBSixHQUFnQixDQUFoQixDQUR2QjtBQUVJLDBCQUFVLEtBQVYsSUFBbUIsY0FBYyxVQUFkLENBQXlCLEdBQXpCLENBRnZCO2FBREE7U0FGSjtLQUZKOzs7Ozs7O0FBUkosUUF5QlEsWUFBWSxDQUFaLENBekJSO0FBMEJJLFFBQUksYUFBYSxDQUFiLENBMUJSOztBQTRCSSxTQUFLLElBQUksTUFBTSxDQUFOLEVBQVMsTUFBTSxNQUFNLE1BQU4sRUFBYyxPQUFPLENBQVAsRUFDdEM7QUFDSSxhQUFLLElBQUksU0FBUyxDQUFULEVBQVksU0FBUyxNQUFNLEtBQU4sRUFBYSxVQUFVLENBQVYsRUFDM0M7QUFDSSxnQkFBTSxhQUFhLE1BQU0sTUFBTSxLQUFOLEdBQWMsTUFBcEIsQ0FEdkI7QUFFSSxnQkFBTSxhQUFhLE1BQU0sS0FBTixDQUFZLFVBQVosQ0FBYixDQUZWO0FBR0ksZ0JBQU0sWUFBYSxJQUFJLEdBQUosR0FBVSxTQUFWLEdBQXNCLElBQUksTUFBSixDQUg3Qzs7QUFLSSxnQkFBSSxZQUFZLGNBQWMsVUFBZCxDQUF5QixJQUF6QixDQUxwQjs7QUFPSSxnQkFBSSxlQUFlLFlBQVksSUFBWixFQUNuQjtBQUNJLDRCQUFZLGNBQWMsU0FBZCxDQUF3QixJQUF4QixDQUE2QixTQUE3QixDQUFaLENBREo7QUFFSSw0QkFBWSxDQUFDLFlBQVksQ0FBWixDQUFELEdBQWtCLGNBQWMsU0FBZCxDQUF3QixJQUF4QixDQUE2QixNQUE3QixDQUZsQzthQURBLE1BS0ssSUFBSSxlQUFlLFlBQVksTUFBWixFQUN4QjtBQUNJLDRCQUFZLGNBQWMsU0FBZCxDQUF3QixPQUF4QixDQUFnQyxVQUFoQyxDQUFaLENBREo7QUFFSSw2QkFBYSxDQUFDLGFBQWEsQ0FBYixDQUFELEdBQW1CLGNBQWMsU0FBZCxDQUF3QixPQUF4QixDQUFnQyxNQUFoQyxDQUZwQzthQURLOztBQU1MLGdCQUFJLGNBQWMsY0FBYyxVQUFkLENBQXlCLElBQXpCLEVBQ2xCO0FBQ0ksMEJBQVUsU0FBVixJQUF1QixTQUF2QixDQURKO0FBRUksd0JBQVEsa0JBQVIsQ0FDSSxTQURKLEVBQ2UsSUFBSSxNQUFKLEVBQVksSUFBSSxHQUFKLEVBQVMsU0FEcEMsRUFDK0MsVUFEL0MsRUFGSjthQURBO1NBbkJKO0tBRko7O0FBOEJBLGNBQVUsSUFBSSxNQUFNLEtBQU4sQ0FBWSxDQUFaLEdBQWdCLFNBQXBCLEdBQWdDLElBQUksTUFBTSxLQUFOLENBQVksQ0FBWixDQUE5QyxHQUErRCxDQUEvRCxDQTFESjtBQTJESSxZQUFRLGtCQUFSLENBQ0ksU0FESixFQUNlLElBQUksTUFBTSxLQUFOLENBQVksQ0FBWixFQUFlLElBQUksTUFBTSxLQUFOLENBQVksQ0FBWixFQUFlLFNBRHJELEVBQ2dFLFVBRGhFLEVBM0RKOztBQThESSxXQUFPO0FBQ0gsZUFBUSxTQUFSO0FBQ0EsZUFBUSxTQUFSO0FBQ0EsZ0JBQVEsVUFBUjtBQUNBLGVBQU87QUFDSCxlQUFHLE1BQU0sS0FBTixDQUFZLENBQVosR0FBZ0IsQ0FBaEI7QUFDSCxlQUFHLE1BQU0sS0FBTixDQUFZLENBQVosR0FBZ0IsQ0FBaEI7U0FGUDtLQUpKLENBOURKO0NBRE87O0FBMEVBLFNBQVMsV0FBVCxDQUFxQixLQUFyQixFQUE0QixLQUE1QixFQUFtQyxTQUFuQyxFQUNQO0FBQ0ksWUFBUSxLQUFLLEtBQUwsQ0FBVyxLQUFLLFNBQUwsQ0FBZSxLQUFmLENBQVgsQ0FBUixDQURKOztBQUdJLFFBQUksWUFBWSxDQUFaO1FBQWUsY0FBYyxDQUFkO1FBQWlCLFFBQVEsRUFBUixDQUh4Qzs7QUFLSSxXQUFPLGNBQWMsQ0FBZCxFQUNQO0FBQ0ksWUFBTSxTQUFTLE1BQU0sR0FBTixDQUFVLEtBQVYsQ0FBVCxDQURWOztBQUdJLFlBQUksV0FBVyxPQUFPLElBQVAsRUFDZjtBQUNJLG9CQUFRLE1BQVI7QUFFSSxxQkFBSyxPQUFPLFFBQVA7QUFDTDtBQUNJLDhCQUFNLEtBQU4sQ0FBWSxPQUFaLEdBQXNCLENBQUMsTUFBTSxLQUFOLENBQVksT0FBWixHQUFzQixDQUF0QixHQUEwQixDQUExQixDQUFELEdBQWdDLENBQWhDLENBRDFCO0FBRUksOEJBRko7cUJBREE7QUFGSixxQkFPUyxPQUFPLFNBQVA7QUFDTDtBQUNJLDhCQUFNLEtBQU4sQ0FBWSxPQUFaLEdBQXNCLENBQUMsTUFBTSxLQUFOLENBQVksT0FBWixHQUFzQixDQUF0QixDQUFELEdBQTRCLENBQTVCLENBRDFCO0FBRUksOEJBRko7cUJBREE7QUFQSixhQURKOztBQWVJLG9CQUFRLE1BQU0sS0FBTixDQUFZLE9BQVo7QUFFSixxQkFBSyxRQUFRLEVBQVI7QUFDTDtBQUNJLDhCQUFNLElBQU4sQ0FBVyxjQUFjLE1BQWQsQ0FBcUIsTUFBckIsQ0FBWCxDQURKO0FBRUksOEJBQU0sS0FBTixDQUFZLENBQVosR0FBZ0IsQ0FBQyxNQUFNLEtBQU4sQ0FBWSxDQUFaLEdBQWdCLENBQWhCLEdBQW9CLE1BQU0sTUFBTixDQUFyQixHQUFxQyxNQUFNLE1BQU4sQ0FGekQ7QUFHSSw4QkFISjtxQkFEQTtBQUZKLHFCQVFTLFFBQVEsSUFBUjtBQUNMO0FBQ0ksOEJBQU0sSUFBTixDQUFXLGNBQWMsTUFBZCxDQUFxQixRQUFyQixDQUFYLENBREo7QUFFSSw4QkFBTSxLQUFOLENBQVksQ0FBWixHQUFnQixDQUFDLE1BQU0sS0FBTixDQUFZLENBQVosR0FBZ0IsQ0FBaEIsQ0FBRCxHQUFzQixNQUFNLE1BQU4sQ0FGMUM7QUFHSSw4QkFISjtxQkFEQTtBQVJKLHFCQWNTLFFBQVEsSUFBUjtBQUNMO0FBQ0ksOEJBQU0sSUFBTixDQUFXLGNBQWMsTUFBZCxDQUFxQixRQUFyQixDQUFYLENBREo7QUFFSSw4QkFBTSxLQUFOLENBQVksQ0FBWixHQUFnQixDQUFDLE1BQU0sS0FBTixDQUFZLENBQVosR0FBZ0IsQ0FBaEIsR0FBb0IsTUFBTSxLQUFOLENBQXJCLEdBQW9DLE1BQU0sS0FBTixDQUZ4RDtBQUdJLDhCQUhKO3FCQURBO0FBZEoscUJBb0JTLFFBQVEsS0FBUjtBQUNMO0FBQ0ksOEJBQU0sSUFBTixDQUFXLGNBQWMsTUFBZCxDQUFxQixTQUFyQixDQUFYLENBREo7QUFFSSw4QkFBTSxLQUFOLENBQVksQ0FBWixHQUFnQixDQUFDLE1BQU0sS0FBTixDQUFZLENBQVosR0FBZ0IsQ0FBaEIsQ0FBRCxHQUFzQixNQUFNLEtBQU4sQ0FGMUM7QUFHSSw4QkFISjtxQkFEQTtBQXBCSixhQWZKOztBQTJDSSxnQkFBTSxlQUFlLE1BQU0sS0FBTixDQUFZLENBQVosR0FBZ0IsTUFBTSxLQUFOLEdBQWMsTUFBTSxLQUFOLENBQVksQ0FBWixDQTNDdkQ7QUE0Q0ksZ0JBQU0sU0FBZSxNQUFNLEtBQU4sQ0FBWSxZQUFaLENBQWYsQ0E1Q1Y7O0FBOENJLG9CQUFRLE1BQVI7QUFFSSxxQkFBSyxZQUFZLElBQVo7QUFDTDtBQUNJLHFDQUFhLENBQWIsQ0FESjtBQUVJLDhCQUZKO3FCQURBO0FBRkoscUJBT1MsWUFBWSxNQUFaO0FBQ0w7QUFDSSx1Q0FBZSxDQUFmLENBREo7QUFFSSw4QkFGSjtxQkFEQTtBQVBKLGFBOUNKOztBQTRESSxrQkFBTSxLQUFOLENBQVksWUFBWixJQUE0QixZQUFZLElBQVosQ0E1RGhDO1NBREEsTUFnRUE7QUFDSSxrQkFBTSxJQUFOLENBQVcsY0FBYyxNQUFkLENBQXFCLElBQXJCLENBQVgsQ0FESjtTQWhFQTtLQUpKOztBQXlFQSxXQUFPLEVBQUUsV0FBVyxTQUFYLEVBQXNCLGFBQWEsV0FBYixFQUEwQixPQUFPLEtBQVAsRUFBekQsQ0E5RUo7Q0FETzs7QUFrRlAsSUFBTSxXQUFXLENBQVg7O0FBRU4sU0FBUyxPQUFULENBQWlCLElBQWpCLEVBQXVCLFFBQXZCLEVBQWlDLFVBQWpDLEVBQTZDLFVBQTdDLEVBQXlELG1CQUF6RCxFQUNBO0FBQ0ksU0FBSyxJQUFJLE9BQU8sQ0FBUCxFQUFVLE9BQU8sVUFBUCxFQUFtQixNQUF0QyxFQUNBO0FBQ0ksWUFBTSxTQUFhLHNCQUFzQixRQUFRLElBQUksVUFBSixHQUFpQixRQUFqQixDQUFSLEdBQXFDLElBQUksVUFBSixDQURsRjtBQUVJLFlBQU0sYUFBYSxTQUFTLFNBQVMsQ0FBVCxDQUF0QixDQUZWO0FBR0ksWUFBTSxRQUFhLENBQUMsU0FBUyxTQUFTLENBQVQsQ0FBVCxHQUF1QixDQUF2QixDQUFELEdBQTZCLENBQUMsU0FBUyxTQUFTLENBQVQsQ0FBVCxHQUF1QixDQUF2QixDQUFELEdBQTZCLENBQTdCLEdBQWlDLENBQUMsU0FBUyxTQUFTLENBQVQsQ0FBVCxHQUF1QixDQUF2QixDQUFELEdBQTZCLENBQTdCLENBSHJGOztBQUtJLGFBQUssSUFBTCxJQUFhLGFBQWEsUUFBUSxDQUFSLEdBQVksS0FBekIsQ0FMakI7S0FEQTtDQUZKOztBQVlBLFNBQVMsVUFBVCxDQUFvQixPQUFwQixFQUE2QixRQUE3QixFQUF1QyxVQUF2QyxFQUFtRCxVQUFuRCxFQUErRCxjQUEvRCxFQUNBO0FBQ0ksU0FBSyxJQUFJLE9BQU8sQ0FBUCxFQUFVLE9BQU8sVUFBUCxFQUFtQixNQUF0QyxFQUNBO0FBQ0ksYUFBSyxJQUFJLFlBQVksQ0FBWixFQUFlLFlBQVksVUFBWixFQUF3QixXQUFoRCxFQUNBO0FBQ0ksZ0JBQU0sU0FBUyxpQkFBaUIsUUFBUSxJQUFJLFVBQUosR0FBaUIsUUFBakIsQ0FBUixHQUFxQyxJQUFJLFNBQUosQ0FEekU7QUFFSSxvQkFBUSxPQUFPLFVBQVAsR0FBb0IsU0FBcEIsQ0FBUixHQUF5QyxDQUFDLFNBQVMsTUFBVCxJQUFtQixDQUFuQixDQUFELElBQTBCLFNBQVMsU0FBUyxDQUFULENBQVQsR0FBdUIsQ0FBdkIsR0FBMkIsQ0FBQyxDQUFELENBQXJELENBRjdDO1NBREE7S0FGSjtDQUZKOztBQVlBLElBQUksZUFBZSxTQUFmLFlBQWUsQ0FBUyxTQUFULEVBQ25CO0FBQ0ksV0FBTyxVQUFTLEtBQVQsRUFDUDtBQUNJLGVBQU8sU0FBUyxTQUFULEdBQXFCLENBQXJCLEdBQXlCLENBQXpCLENBRFg7S0FETyxDQURYO0NBRG1COztBQVFaLFNBQVMsMkJBQVQsQ0FBcUMsUUFBckMsRUFDUDtBQUNJLFFBQU0sYUFBYyxDQUFkLENBRFY7QUFFSSxRQUFNLGNBQWMsQ0FBZCxDQUZWO0FBR0ksUUFBTSxjQUFjLENBQWQsQ0FIVjs7QUFLSSxRQUFJLGtCQUFxQixJQUFJLEtBQUosQ0FBVSxXQUFWLENBQXJCLENBTFI7QUFNSSxRQUFJLHFCQUFxQixJQUFJLEtBQUosQ0FBVSxhQUFhLFdBQWIsQ0FBL0IsQ0FOUjs7QUFRSSxlQUFXLGtCQUFYLEVBQStCLFFBQS9CLEVBQXlDLFVBQXpDLEVBQXFELFdBQXJELEVBQWtFLENBQWxFLEVBUko7QUFTSSxZQUFRLGVBQVIsRUFBeUIsUUFBekIsRUFBbUMsVUFBbkMsRUFBK0MsV0FBL0MsRUFBNEQsQ0FBNUQsRUFUSjs7QUFXSSxRQUFJLGtCQUFrQixJQUFJLEtBQUosQ0FBVSxXQUFWLENBQWxCLENBWFI7QUFZSSxRQUFJLHFCQUFxQixJQUFJLEtBQUosQ0FBVSxjQUFjLFdBQWQsQ0FBL0IsQ0FaUjs7QUFjSSxlQUFXLGtCQUFYLEVBQStCLFFBQS9CLEVBQXlDLFdBQXpDLEVBQXNELFdBQXRELEVBQW1FLElBQUksVUFBSixHQUFpQixXQUFqQixHQUErQixXQUFXLFdBQVgsQ0FBbEcsQ0FkSjtBQWVJLFlBQVEsZUFBUixFQUF5QixRQUF6QixFQUFtQyxXQUFuQyxFQUFnRCxXQUFoRCxFQUE2RCxJQUFJLFVBQUosR0FBaUIsV0FBakIsR0FBK0IsV0FBVyxXQUFYLENBQTVGLENBZko7O0FBaUJJLFdBQU8sSUFBSSxJQUFJLFdBQUosQ0FBZ0IsT0FBaEIsQ0FBd0IsQ0FDL0IsSUFBSSxJQUFJLFdBQUosQ0FBZ0IsS0FBaEIsQ0FBc0IsZUFBMUIsRUFBMkMsa0JBQTNDLEVBQStELGFBQWEsQ0FBYixDQUEvRCxDQUQrQixFQUUvQixJQUFJLElBQUksV0FBSixDQUFnQixLQUFoQixDQUFzQixlQUExQixFQUEyQyxrQkFBM0MsRUFBK0QsYUFBYSxDQUFiLENBQS9ELENBRitCLENBQTVCLENBQVAsQ0FqQko7Q0FETzs7QUF1QkEsU0FBUyxxQkFBVCxDQUErQixLQUEvQixFQUNQO0FBQ0ksV0FBTyxVQUFTLFNBQVQsRUFDUDtBQUNJLFlBQUksUUFBVyxJQUFJLEtBQUosQ0FBVSxTQUFWLENBQVgsQ0FEUjtBQUVJLFlBQU0sU0FBUyxZQUFZLEtBQVosRUFBbUIsS0FBbkIsRUFBMEIsRUFBMUIsQ0FBVCxDQUZWO0FBR0ksZUFBTyxDQUFDLE9BQU8sU0FBUCxHQUFtQixJQUFJLE9BQU8sV0FBUCxDQUF4QixHQUE4QyxNQUFNLGFBQU4sQ0FIekQ7S0FETyxDQURYO0NBRE87O0lBVU07QUFFVCxhQUZTLEtBRVQsQ0FBWSxPQUFaLEVBQ0E7OEJBSFMsT0FHVDs7QUFDSSxhQUFLLE9BQUwsR0FBZSxPQUFmLENBREo7S0FEQTs7aUJBRlM7OzRCQU9MLE9BQ0o7QUFDSSxnQkFBTSxjQUFlLENBQUMsTUFBTSxLQUFOLENBQVksT0FBWixHQUFzQixDQUF0QixHQUEwQixDQUExQixDQUFELEdBQWdDLENBQWhDLENBRHpCO0FBRUksZ0JBQU0sZUFBZSxDQUFDLE1BQU0sS0FBTixDQUFZLE9BQVosR0FBc0IsQ0FBdEIsQ0FBRCxHQUE0QixDQUE1QixDQUZ6Qjs7QUFJSSxnQkFBTSxZQUFlLFFBQVEsc0JBQVIsQ0FBK0IsS0FBL0IsRUFBc0MsV0FBdEMsQ0FBZixDQUpWO0FBS0ksZ0JBQU0sZUFBZSxRQUFRLHNCQUFSLENBQStCLEtBQS9CLEVBQXNDLE1BQU0sS0FBTixDQUFZLE9BQVosQ0FBckQsQ0FMVjtBQU1JLGdCQUFNLGFBQWUsUUFBUSxzQkFBUixDQUErQixLQUEvQixFQUFzQyxZQUF0QyxDQUFmLENBTlY7O0FBUUksZ0JBQU0sU0FBUyxDQUNYLGlCQUFpQixZQUFZLElBQVosR0FBcUIsQ0FBdEMsR0FBMEMsQ0FBMUMsRUFDQSxjQUFpQixZQUFZLElBQVosR0FBcUIsQ0FBdEMsR0FBMEMsQ0FBMUMsRUFDQSxlQUFpQixZQUFZLElBQVosR0FBcUIsQ0FBdEMsR0FBMEMsQ0FBMUMsRUFDQSxpQkFBaUIsWUFBWSxNQUFaLEdBQXFCLENBQXRDLEdBQTBDLENBQTFDLEVBQ0EsY0FBaUIsWUFBWSxNQUFaLEdBQXFCLENBQXRDLEdBQTBDLENBQTFDLEVBQ0EsZUFBaUIsWUFBWSxNQUFaLEdBQXFCLENBQXRDLEdBQTBDLENBQTFDLENBTkUsQ0FSVjs7QUFnQkksZ0JBQU0sVUFBVSxLQUFLLE9BQUwsQ0FBYSxRQUFiLENBQXNCLE1BQXRCLENBQVYsQ0FoQlY7O0FBa0JJLGdCQUFJLFFBQVEsQ0FBUixJQUFhLFFBQVEsQ0FBUixDQUFiLElBQTJCLFFBQVEsQ0FBUixJQUFhLFFBQVEsQ0FBUixDQUFiLEVBQy9CO0FBQ0ksdUJBQU8sT0FBTyxXQUFQLENBRFg7YUFEQSxNQUlLLElBQUksUUFBUSxDQUFSLElBQWEsUUFBUSxDQUFSLENBQWIsSUFBMkIsUUFBUSxDQUFSLElBQWEsUUFBUSxDQUFSLENBQWIsRUFDcEM7QUFDSSx1QkFBTyxPQUFPLFFBQVAsQ0FEWDthQURLLE1BSUEsSUFBSSxRQUFRLENBQVIsSUFBYSxRQUFRLENBQVIsQ0FBYixJQUEyQixRQUFRLENBQVIsSUFBYSxRQUFRLENBQVIsQ0FBYixFQUNwQztBQUNJLHVCQUFPLE9BQU8sU0FBUCxDQURYO2FBREssTUFLTDtBQUNJLHVCQUFPLE9BQU8sV0FBUDs7QUFEWCxhQUxLOzs7O1dBbENBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3pXTixJQUFNLDBCQUFTLE9BQU8sTUFBUCxDQUN0QjtBQUNJLFVBQVcsQ0FBWDtBQUNBLFlBQVcsQ0FBWDtBQUNBLGNBQVcsQ0FBWDtBQUNBLGNBQVcsQ0FBWDtBQUNBLGVBQVcsQ0FBWDtDQU5rQixDQUFUOztBQVNOLElBQU0sa0NBQWEsT0FBTyxNQUFQLENBQzFCO0FBQ0ksVUFBYSxDQUFiO0FBQ0EsU0FBYSxDQUFiO0FBQ0EsWUFBYSxDQUFiO0FBQ0EsZ0JBQWEsQ0FBYjtBQUNBLFlBQWEsQ0FBYjtBQUNBLFdBQWEsQ0FBYjtBQUNBLFdBQWEsQ0FBYjtBQUNBLFlBQWEsQ0FBYjtBQUNBLFdBQWEsQ0FBYjtBQUNBLFVBQWEsQ0FBYjtBQUNBLFdBQVksRUFBWjtDQVpzQixDQUFiOztBQWVOLElBQU0sZ0NBQVksT0FBTyxNQUFQLENBQWMsWUFDdkM7QUFDSSxRQUFJLFlBQVksRUFBWixDQURSOztBQUdJLGNBQVUsZUFBVixHQUE0QixPQUFPLEVBQVAsQ0FIaEM7O0FBS0ksY0FBVSxJQUFWLEdBQ0EsQ0FDSSxXQUFXLE1BQVgsRUFDQSxXQUFXLFVBQVgsRUFDQSxXQUFXLE1BQVgsRUFDQSxXQUFXLEtBQVgsRUFDQSxXQUFXLEtBQVgsQ0FOSixDQUxKOztBQWNJLGNBQVUsT0FBVixHQUNBLENBQ0ksV0FBVyxNQUFYLEVBQ0EsV0FBVyxLQUFYLEVBQ0EsV0FBVyxJQUFYLEVBQ0EsV0FBVyxLQUFYLENBTEosQ0FkSjs7QUFzQkksY0FBVSxVQUFWLEdBQThDLEVBQTlDLENBdEJKO0FBdUJJLGNBQVUsVUFBVixDQUFxQixXQUFXLEdBQVgsQ0FBckIsR0FBOEMsRUFBRSxHQUFHLEdBQUgsRUFBUSxHQUFJLENBQUosRUFBTyxRQUFRLENBQVIsRUFBL0QsQ0F2Qko7QUF3QkksY0FBVSxVQUFWLENBQXFCLFdBQVcsTUFBWCxDQUFyQixHQUE4QyxFQUFFLEdBQUcsR0FBSCxFQUFRLEdBQUksQ0FBSixFQUFPLFFBQVEsQ0FBUixFQUEvRCxDQXhCSjtBQXlCSSxjQUFVLFVBQVYsQ0FBcUIsV0FBVyxVQUFYLENBQXJCLEdBQThDLEVBQUUsR0FBRyxHQUFILEVBQVEsR0FBRyxFQUFILEVBQU8sUUFBUSxDQUFSLEVBQS9ELENBekJKO0FBMEJJLGNBQVUsVUFBVixDQUFxQixXQUFXLE1BQVgsQ0FBckIsR0FBOEMsRUFBRSxHQUFHLEdBQUgsRUFBUSxHQUFHLEVBQUgsRUFBTyxRQUFRLENBQVIsRUFBL0QsQ0ExQko7QUEyQkksY0FBVSxVQUFWLENBQXFCLFdBQVcsS0FBWCxDQUFyQixHQUE4QyxFQUFFLEdBQUcsR0FBSCxFQUFRLEdBQUcsRUFBSCxFQUFPLFFBQVEsQ0FBUixFQUEvRCxDQTNCSjtBQTRCSSxjQUFVLFVBQVYsQ0FBcUIsV0FBVyxLQUFYLENBQXJCLEdBQThDLEVBQUUsR0FBRyxHQUFILEVBQVEsR0FBRyxFQUFILEVBQU8sUUFBUSxDQUFSLEVBQS9ELENBNUJKO0FBNkJJLGNBQVUsVUFBVixDQUFxQixXQUFXLE1BQVgsQ0FBckIsR0FBOEMsRUFBRSxHQUFHLEdBQUgsRUFBUSxHQUFHLEVBQUgsRUFBTyxRQUFRLENBQVIsRUFBVyxTQUFTLENBQVQsRUFBMUUsQ0E3Qko7QUE4QkksY0FBVSxVQUFWLENBQXFCLFdBQVcsS0FBWCxDQUFyQixHQUE4QyxFQUFFLEdBQUcsR0FBSCxFQUFRLEdBQUcsRUFBSCxFQUFPLFFBQVEsQ0FBUixFQUFXLFNBQVMsQ0FBVCxFQUExRSxDQTlCSjtBQStCSSxjQUFVLFVBQVYsQ0FBcUIsV0FBVyxJQUFYLENBQXJCLEdBQThDLEVBQUUsR0FBRyxHQUFILEVBQVEsR0FBRyxFQUFILEVBQU8sUUFBUSxDQUFSLEVBQVcsU0FBUyxDQUFULEVBQTFFLENBL0JKO0FBZ0NJLGNBQVUsVUFBVixDQUFxQixXQUFXLEtBQVgsQ0FBckIsR0FBOEMsRUFBRSxHQUFJLEVBQUosRUFBUSxHQUFHLEVBQUgsRUFBTyxRQUFRLENBQVIsRUFBVyxTQUFTLENBQVQsRUFBMUUsQ0FoQ0o7O0FBa0NJLGNBQVUsZUFBVixHQUE4QyxFQUE5QyxDQWxDSjtBQW1DSSxjQUFVLGVBQVYsQ0FBMEIsT0FBTyxJQUFQLENBQTFCLEdBQThDLEVBQUUsR0FBRyxDQUFILEVBQU0sR0FBRyxFQUFILEVBQU8sUUFBUSxDQUFSLEVBQTdELENBbkNKO0FBb0NJLGNBQVUsZUFBVixDQUEwQixPQUFPLE1BQVAsQ0FBMUIsR0FBOEMsRUFBRSxHQUFHLENBQUgsRUFBTSxHQUFHLEVBQUgsRUFBTyxRQUFRLENBQVIsRUFBN0QsQ0FwQ0o7QUFxQ0ksY0FBVSxlQUFWLENBQTBCLE9BQU8sUUFBUCxDQUExQixHQUE4QyxFQUFFLEdBQUcsQ0FBSCxFQUFNLEdBQUcsRUFBSCxFQUFPLFFBQVEsQ0FBUixFQUE3RCxDQXJDSjtBQXNDSSxjQUFVLGVBQVYsQ0FBMEIsT0FBTyxRQUFQLENBQTFCLEdBQThDLEVBQUUsR0FBRyxDQUFILEVBQU0sR0FBRyxFQUFILEVBQU8sUUFBUSxDQUFSLEVBQTdELENBdENKO0FBdUNJLGNBQVUsZUFBVixDQUEwQixPQUFPLFNBQVAsQ0FBMUIsR0FBOEMsRUFBRSxHQUFHLENBQUgsRUFBTSxHQUFHLEVBQUgsRUFBTyxRQUFRLENBQVIsRUFBN0QsQ0F2Q0o7O0FBeUNJLFdBQU8sU0FBUCxDQXpDSjtDQUR1QyxFQUFkLENBQVo7O0FBNkNOLElBQU0sNEJBQVUsT0FBTyxNQUFQLENBQWMsWUFDckM7QUFDSSxRQUFJLFVBQVUsRUFBVixDQURSOztBQUdJLFlBQVEscUJBQVIsR0FBZ0MsVUFBUyxHQUFULEVBQWMsR0FBZCxFQUNoQztBQUNJLGVBQU8sS0FBSyxLQUFMLENBQVcsS0FBSyxNQUFMLE1BQWlCLE1BQU0sR0FBTixHQUFZLENBQVosQ0FBakIsQ0FBWCxHQUE4QyxHQUE5QyxDQURYO0tBRGdDLENBSHBDOztBQVFJLFlBQVEsT0FBUixHQUFrQixVQUFTLE1BQVQsRUFDbEI7QUFDSSxlQUFPLFVBQVUsV0FBVyxNQUFYLElBQXFCLFVBQVUsV0FBVyxLQUFYLENBRHBEO0tBRGtCLENBUnRCOztBQWFJLFlBQVEsTUFBUixHQUFpQixVQUFTLE1BQVQsRUFDakI7QUFDSSxlQUFPLFVBQVUsV0FBVyxNQUFYLElBQXFCLFVBQVUsV0FBVyxLQUFYLENBRHBEO0tBRGlCLENBYnJCOztBQWtCSSxXQUFPLE9BQVAsQ0FsQko7Q0FEcUMsRUFBZCxDQUFWOztJQXNCQTtBQUVULGFBRlMsYUFFVCxDQUFZLE9BQVosRUFDQTs4QkFIUyxlQUdUOztBQUNJLGFBQUssWUFBTCxHQUFvQixRQUFRLFlBQVIsSUFBd0IsSUFBeEIsQ0FEeEI7QUFFSSxhQUFLLEtBQUwsR0FBb0IsUUFBUSxLQUFSLElBQWlCLElBQWpCLENBRnhCOztBQUlJLGFBQUssY0FBTCxHQUpKOztBQU1JLGFBQUssTUFBTCxHQUFlLFNBQVMsY0FBVCxDQUF3QixRQUFRLFNBQVIsQ0FBdkMsQ0FOSjtBQU9JLGFBQUssT0FBTCxHQUFlLEtBQUssTUFBTCxDQUFZLFVBQVosQ0FBdUIsSUFBdkIsQ0FBZixDQVBKO0FBUUksYUFBSyxPQUFMLENBQWEscUJBQWIsR0FBMkMsS0FBM0MsQ0FSSjtBQVNJLGFBQUssT0FBTCxDQUFhLDJCQUFiLEdBQTJDLEtBQTNDLENBVEo7QUFVSSxhQUFLLE9BQUwsQ0FBYSx3QkFBYixHQUEyQyxLQUEzQyxDQVZKO0FBV0ksYUFBSyxPQUFMLENBQWEsU0FBYixHQUEyQyxPQUEzQyxDQVhKOztBQWFJLGFBQUssT0FBTCxHQUFzQixJQUFJLEtBQUosRUFBdEIsQ0FiSjtBQWNJLGFBQUssT0FBTCxDQUFhLE1BQWIsR0FBc0IsT0FBTyxxQkFBUCxDQUE2QixJQUE3QixDQUFrQyxNQUFsQyxFQUEwQyxLQUFLLE1BQUwsQ0FBWSxJQUFaLENBQWlCLElBQWpCLENBQTFDLENBQXRCLENBZEo7QUFlSSxhQUFLLE9BQUwsQ0FBYSxHQUFiLEdBQXNCLFFBQVEsWUFBUixJQUF3QiwrQkFBeEIsQ0FmMUI7S0FEQTs7aUJBRlM7O3NEQXNCVDtBQUNJLGdCQUFJLElBQUksS0FBSyxLQUFMLENBQVcsS0FBWCxDQUFpQixDQUFqQixHQUFxQixDQUFyQixDQURaO0FBRUksZ0JBQUksSUFBSSxLQUFLLEtBQUwsQ0FBVyxLQUFYLENBQWlCLENBQWpCLEdBQXFCLENBQXJCLENBRlo7QUFHSSxnQkFBSSxTQUFTLENBQVQ7Z0JBQVksU0FBUyxDQUFULENBSHBCOztBQUtJLGdCQUFNLGdCQUFnQixLQUFLLGFBQUwsQ0FMMUI7O0FBT0ksZ0JBQUksaUJBQWlCLGtCQUFrQixPQUFPLElBQVAsRUFDdkM7QUFDSSxvQkFBTSxpQkFBaUIsSUFBSSxLQUFLLGFBQUwsQ0FEL0I7O0FBR0ksd0JBQVEsYUFBUjtBQUVJLHlCQUFLLE9BQU8sTUFBUDtBQUNMO0FBQ0ksaUNBQUssY0FBTCxDQURKO0FBRUkscUNBQVMsSUFBSSxDQUFKLEdBQVEsSUFBSSxLQUFLLEtBQUssS0FBTCxDQUFXLE1BQVgsR0FBb0IsQ0FBcEIsQ0FBTCxHQUE4QixDQUExQyxDQUZiO0FBR0ksa0NBSEo7eUJBREE7QUFGSix5QkFRUyxPQUFPLFFBQVA7QUFDTDtBQUNJLGlDQUFLLGNBQUwsQ0FESjtBQUVJLHFDQUFVLEtBQUssS0FBSyxLQUFLLEtBQUwsQ0FBVyxNQUFYLEdBQW9CLENBQXBCLENBQUwsR0FDVCxJQUFJLEtBQUssS0FBSyxLQUFMLENBQVcsTUFBWCxHQUFvQixDQUFwQixDQUFMLEdBQThCLENBRDlCLENBRmQ7QUFJSSxrQ0FKSjt5QkFEQTtBQVJKLHlCQWVTLE9BQU8sUUFBUDtBQUNMO0FBQ0ksaUNBQUssY0FBTCxDQURKO0FBRUkscUNBQVMsSUFBSSxDQUFKLEdBQVEsSUFBSSxLQUFLLEtBQUssS0FBTCxDQUFXLEtBQVgsR0FBbUIsQ0FBbkIsQ0FBTCxHQUE2QixDQUF6QyxDQUZiO0FBR0ksa0NBSEo7eUJBREE7QUFmSix5QkFxQlMsT0FBTyxTQUFQO0FBQ0w7QUFDSSxpQ0FBSyxjQUFMLENBREo7QUFFSSxxQ0FBVSxLQUFLLEtBQUssS0FBSyxLQUFMLENBQVcsS0FBWCxHQUFtQixDQUFuQixDQUFMLEdBQ1QsSUFBSSxLQUFLLEtBQUssS0FBTCxDQUFXLEtBQVgsR0FBbUIsQ0FBbkIsQ0FBTCxHQUE2QixDQUQ3QixDQUZkO0FBSUksa0NBSko7eUJBREE7QUFyQkosaUJBSEo7YUFEQTs7QUFtQ0EsbUJBQU8sQ0FBRSxFQUFFLEdBQUcsQ0FBSCxFQUFNLEdBQUcsQ0FBSCxFQUFWLEVBQWtCLEVBQUUsR0FBRyxNQUFILEVBQVcsR0FBRyxNQUFILEVBQS9CLENBQVAsQ0ExQ0o7Ozs7MENBNkNrQixVQUFVLFFBQVEsT0FDcEM7QUFDSSxvQkFBUSxNQUFSO0FBRUkscUJBQUssT0FBTyxJQUFQO0FBQ0w7QUFDSSwrQkFBTyxRQUFQLENBREo7cUJBREE7QUFGSixxQkFNUyxPQUFPLE1BQVA7QUFDTDtBQUNJLDRCQUFNLElBQUksU0FBUyxDQUFULEdBQWEsS0FBYixDQURkO0FBRUksK0JBQU8sRUFBRSxHQUFHLFNBQVMsQ0FBVDtBQUNILCtCQUFHLElBQUksQ0FBSixHQUFRLElBQUksS0FBSyxLQUFMLENBQVcsTUFBWCxHQUFvQixDQUF4QixHQUE0QixDQUFwQyxFQURaLENBRko7cUJBREE7QUFOSixxQkFZUyxPQUFPLFFBQVA7QUFDTDtBQUNJLDRCQUFNLEtBQUksU0FBUyxDQUFULEdBQWEsS0FBYixDQURkO0FBRUksK0JBQU8sRUFBRSxHQUFHLFNBQVMsQ0FBVDtBQUNILCtCQUFHLE1BQUssS0FBSyxLQUFMLENBQVcsTUFBWCxHQUFvQixLQUFJLEtBQUssS0FBTCxDQUFXLE1BQVgsR0FBb0IsQ0FBeEIsR0FBNEIsRUFBckQsRUFEWixDQUZKO3FCQURBO0FBWkoscUJBa0JTLE9BQU8sUUFBUDtBQUNMO0FBQ0ksNEJBQU0sSUFBSSxTQUFTLENBQVQsR0FBYSxLQUFiLENBRGQ7QUFFSSwrQkFBTyxFQUFFLEdBQUcsSUFBSSxDQUFKLEdBQVEsSUFBSSxLQUFLLEtBQUwsQ0FBVyxLQUFYLEdBQW1CLENBQXZCLEdBQTJCLENBQW5DO0FBQ0gsK0JBQUcsU0FBUyxDQUFULEVBRFosQ0FGSjtxQkFEQTtBQWxCSixxQkF3QlMsT0FBTyxTQUFQO0FBQ0w7QUFDSSw0QkFBTSxLQUFJLFNBQVMsQ0FBVCxHQUFhLEtBQWIsQ0FEZDtBQUVJLCtCQUFPLEVBQUUsR0FBRyxNQUFLLEtBQUssS0FBTCxDQUFXLEtBQVgsR0FBbUIsS0FBSSxLQUFLLEtBQUwsQ0FBVyxLQUFYLEdBQW1CLENBQXZCLEdBQTBCLEVBQWxEO0FBQ0gsK0JBQUcsU0FBUyxDQUFULEVBRFosQ0FGSjtxQkFEQTtBQXhCSixhQURKOzs7O3FDQWtDYSxVQUNiO0FBQ0ksbUJBQU8sU0FBUyxDQUFULEdBQWEsS0FBSyxLQUFMLENBQVcsS0FBWCxHQUFtQixTQUFTLENBQVQsQ0FEM0M7Ozs7Z0NBSVEsU0FDUjtBQUNJLGlCQUFLLFdBQUwsQ0FBaUIsSUFBakIsQ0FBc0IsS0FBdEIsQ0FBNEIsS0FBSyxXQUFMLEVBQWtCLE9BQTlDLEVBREo7Ozs7aUNBS0E7QUFDSSxpQkFBSyxPQUFMLENBQWEsUUFBYixDQUFzQixDQUF0QixFQUF5QixDQUF6QixFQUE0QixLQUFLLE1BQUwsQ0FBWSxLQUFaLEVBQW1CLEtBQUssTUFBTCxDQUFZLE1BQVosQ0FBL0MsQ0FESjs7QUFHSSxpQkFBSyxJQUFJLElBQUksQ0FBSixFQUFPLElBQUksS0FBSyxLQUFMLENBQVcsTUFBWCxFQUFtQixLQUFLLENBQUwsRUFDdkM7QUFDSSxxQkFBSyxJQUFJLElBQUksQ0FBSixFQUFPLElBQUksS0FBSyxLQUFMLENBQVcsTUFBWCxFQUFtQixLQUFLLENBQUwsRUFDdkM7QUFDSSx3QkFBTSxRQUFTLElBQUksS0FBSyxLQUFMLENBQVcsS0FBWCxHQUFtQixDQUF2QixDQURuQjtBQUVJLHdCQUFNLFNBQVMsS0FBSyxLQUFMLENBQVcsS0FBWCxDQUFpQixLQUFqQixDQUFULENBRlY7O0FBSUksd0JBQUksV0FBVyxXQUFXLElBQVgsRUFDZjtBQUNJLDRCQUFNLGtCQUFrQixLQUFLLGdCQUFMLENBQXNCLEtBQXRCLENBQWxCLENBRFY7QUFFSSw2QkFBSyxZQUFMLENBQWtCLFVBQVUsVUFBVixDQUFxQixNQUFyQixDQUFsQixFQUFnRCxDQUFoRCxFQUFtRCxDQUFuRCxFQUFzRCxlQUF0RCxFQUZKO3FCQURBO2lCQUxKO2FBRko7O0FBZUEsZ0JBQUksNEJBQUo7Z0JBQXlCLGlDQUF6QixDQWxCSjs7d0NBbUJzRCxLQUFLLDJCQUFMLEdBbkJ0RDs7OztBQW1CSyw0REFuQkw7QUFtQjBCLGlFQW5CMUI7O0FBb0JJLGlCQUFLLFdBQUwsQ0FBaUIsbUJBQWpCLEVBQXNDLHdCQUF0QyxFQXBCSjs7QUFzQkksaUJBQUssY0FBTCxJQUF1QixDQUF2QixDQXRCSjs7OztvQ0F5QlksVUFBVSxlQUN0QjtBQUNJLGdCQUFNLFNBQWtCLFVBQVUsZUFBVixDQUEwQixLQUFLLGFBQUwsSUFBc0IsT0FBTyxJQUFQLENBQWxFLENBRFY7QUFFSSxnQkFBTSxjQUFrQixLQUFLLGFBQUwsR0FBcUIsT0FBTyxNQUFQLENBRmpEO0FBR0ksZ0JBQU0sa0JBQWtCLE9BQU8sQ0FBUCxHQUFXLEtBQUssV0FBTCxDQUh2Qzs7QUFLSSxpQkFBSyxPQUFMLENBQWEsU0FBYixDQUF1QixLQUFLLE9BQUwsRUFDQSxlQUR2QixFQUN3QyxPQUFPLENBQVAsRUFBVSxFQURsRCxFQUNzRCxFQUR0RCxFQUV1QixTQUFTLENBQVQsRUFBWSxTQUFTLENBQVQsRUFBWSxFQUYvQyxFQUVtRCxFQUZuRCxFQUxKOztBQVNJLGlCQUFLLE9BQUwsQ0FBYSxTQUFiLENBQXVCLEtBQUssT0FBTCxFQUNBLGVBRHZCLEVBQ3dDLE9BQU8sQ0FBUCxFQUFVLEVBRGxELEVBQ3NELEVBRHRELEVBRXVCLGNBQWMsQ0FBZCxFQUFpQixjQUFjLENBQWQsRUFBaUIsRUFGekQsRUFFNkQsRUFGN0QsRUFUSjs7OztxQ0FjYSxRQUFRLEdBQUcsR0FBRyxpQkFDM0I7QUFDSSxnQkFBSSxjQUFjLENBQWQsQ0FEUjs7QUFHSSxnQkFBSSxPQUFPLE1BQVAsR0FBZ0IsQ0FBaEIsRUFDSjtBQUNJLG9CQUFNLHdCQUF3QixPQUFPLE9BQVAsR0FBaUIsS0FBSyxLQUFMLENBQVcsS0FBSyxjQUFMLEdBQXNCLE9BQU8sT0FBUCxDQUFsRCxHQUFvRSxLQUFLLGNBQUwsQ0FEdEc7QUFFSSw4QkFBYyxDQUFDLHlCQUF5QixtQkFBbUIsQ0FBbkIsQ0FBekIsQ0FBRCxHQUFtRCxPQUFPLE1BQVAsQ0FGckU7YUFEQTs7QUFNQSxpQkFBSyxPQUFMLENBQWEsU0FBYixDQUF1QixLQUFLLE9BQUwsRUFDQSxPQUFPLENBQVAsR0FBVyxLQUFLLFdBQUwsRUFBa0IsT0FBTyxDQUFQLEVBQVUsRUFEOUQsRUFDa0UsRUFEbEUsRUFFdUIsSUFBSSxDQUFKLEVBQU8sSUFBSSxDQUFKLEVBQU8sRUFGckMsRUFFeUMsRUFGekMsRUFUSjs7Ozt5Q0FlQTtBQUNJLGlCQUFLLFdBQUwsR0FBc0IsRUFBdEIsQ0FESjtBQUVJLGlCQUFLLGNBQUwsR0FBc0IsQ0FBdEIsQ0FGSjtBQUdJLGlCQUFLLGFBQUwsR0FBc0IsSUFBdEIsQ0FISjtBQUlJLGlCQUFLLGFBQUwsR0FBc0IsQ0FBdEIsQ0FKSjtBQUtJLGlCQUFLLEtBQUwsR0FBc0IsRUFBRSxXQUFXLENBQVgsRUFBYyxhQUFhLENBQWIsRUFBZ0IsV0FBVyxDQUFYLEVBQXRELENBTEo7O0FBT0ksZ0JBQUksS0FBSyxLQUFMLEVBQ0o7QUFDSSxxQkFBSyxnQkFBTCxHQUF3QixLQUFLLEtBQUwsQ0FBVyxLQUFYLENBQWlCLEdBQWpCLENBQ3BCOzJCQUFLLEtBQUssVUFBVSxVQUFWLEdBQ0gsUUFBUSxxQkFBUixDQUE4QixDQUE5QixFQUFpQyxVQUFVLFVBQVYsQ0FBcUIsQ0FBckIsRUFBd0IsTUFBeEIsR0FBaUMsQ0FBakMsQ0FEbkMsR0FFRSxDQUZGO2lCQUFMLENBREosQ0FESjthQURBOzs7O3FDQVNTLFVBQVUsT0FDdkI7QUFDSSxnQkFBTSxRQUFXLEtBQUssWUFBTCxDQUFrQixRQUFsQixDQUFYLENBRFY7QUFFSSxnQkFBTSxXQUFXLEtBQUssS0FBTCxDQUFXLEtBQVgsQ0FBaUIsS0FBakIsQ0FBWCxDQUZWO0FBR0ksaUJBQUssS0FBTCxDQUFXLEtBQVgsQ0FBaUIsS0FBakIsSUFBMEIsS0FBMUIsQ0FISjtBQUlJLG1CQUFPLFFBQVAsQ0FKSjs7OztpQ0FPUyxPQUNUO0FBQ0ksaUJBQUssS0FBTCxHQUFhLEtBQUssS0FBTCxDQUFXLEtBQUssU0FBTCxDQUFlLEtBQWYsQ0FBWCxDQUFiLENBREo7QUFFSSxpQkFBSyxjQUFMLEdBRko7Ozs7K0JBS08sYUFDUDtBQUNJLGdCQUFJLEtBQUssS0FBTCxFQUNKO0FBQ0ksb0JBQUksUUFBUyxlQUFlLEtBQUssY0FBTCxHQUNoQixDQUFDLGNBQWMsS0FBSyxjQUFMLENBQWYsR0FBc0MsVUFBVSxlQUFWLEdBQTRCLENBRGpFLENBRGpCOztBQUlJLHFCQUFLLGNBQUwsR0FBc0IsV0FBdEIsQ0FKSjs7QUFNSSx1QkFBTyxRQUFRLENBQVIsRUFBVyxTQUFTLENBQVQsRUFDbEI7QUFDSSx3QkFBSSxnQkFBZ0IsS0FBSyxhQUFMLENBRHhCOztBQUdJLHdCQUFJLENBQUMsYUFBRCxFQUNKO0FBQ0ksd0NBQWdCLEtBQUssYUFBTCxHQUFxQixLQUFLLFdBQUwsQ0FBaUIsS0FBakIsRUFBckIsQ0FEcEI7cUJBREE7O0FBS0Esd0JBQUksYUFBSixFQUNBO0FBQ0ksNEJBQU0sZ0JBQWdCLEVBQUUsS0FBSyxhQUFMLENBRDVCOztBQUdJLDRCQUFJLGtCQUFrQixPQUFPLElBQVAsRUFDdEI7QUFDSSxnQ0FBSSxrQkFBa0IsQ0FBbEIsRUFDSjtBQUNJLG9DQUFNLFVBQVUsS0FBSyxpQkFBTCxDQUNaLEtBQUssS0FBTCxDQUFXLEtBQVgsRUFBa0IsYUFETixFQUNxQixDQURyQixDQUFWLENBRFY7QUFHSSxxQ0FBSyxZQUFMLENBQWtCLE9BQWxCLEVBQTJCLFdBQVcsSUFBWCxDQUEzQixDQUhKOzZCQURBLE1BTUssSUFBSSxrQkFBa0IsQ0FBbEIsRUFDVDtBQUNJLG9DQUFNLHVCQUF1QixLQUFLLGlCQUFMLENBQ3pCLEtBQUssS0FBTCxDQUFXLEtBQVgsRUFBa0IsYUFETyxFQUNRLENBRFIsQ0FBdkIsQ0FEVjs7QUFJSSxxQ0FBSyxLQUFMLENBQVcsS0FBWCxHQUFtQixvQkFBbkIsQ0FKSjs7QUFNSSxvQ0FBSSxpQkFBaUIsS0FBSyxZQUFMLENBQWtCLG9CQUFsQixFQUF3QyxXQUFXLElBQVgsQ0FBekQsQ0FOUjs7QUFRSSxvQ0FBSSxRQUFRLE1BQVIsQ0FBZSxjQUFmLENBQUosRUFDQTtBQUNJLHlDQUFLLEtBQUwsQ0FBVyxTQUFYLElBQXdCLENBQXhCLENBREo7aUNBREEsTUFJSyxJQUFJLFFBQVEsT0FBUixDQUFnQixjQUFoQixDQUFKLEVBQ0w7QUFDSSx5Q0FBSyxLQUFMLENBQVcsV0FBWCxJQUEwQixDQUExQixDQURKO2lDQURLOzZCQWJKO3lCQVJUOztBQTRCQSw0QkFBSSxrQkFBa0IsQ0FBbEIsRUFDSjtBQUNJLGlDQUFLLGFBQUwsR0FBcUIsSUFBckIsQ0FESjtBQUVJLGlDQUFLLGFBQUwsR0FBcUIsQ0FBckIsQ0FGSjs7QUFJSSxpQ0FBSyxLQUFMLENBQVcsU0FBWCxJQUFnQyxDQUFoQyxDQUpKO0FBS0ksaUNBQUssS0FBTCxDQUFXLGlCQUFYLEdBQWdDLEtBQUssV0FBTCxDQUFpQixNQUFqQixLQUE0QixDQUE1QixDQUxwQzs7QUFPSSxnQ0FBSSxLQUFLLFlBQUwsRUFDSjtBQUNJLHFDQUFLLFlBQUwsQ0FBa0IsS0FBSyxLQUFMLENBQWxCLENBREo7NkJBREE7eUJBUko7cUJBaENKO2lCQVRKOztBQXlEQSxxQkFBSyxNQUFMLEdBL0RKO2FBREE7O0FBbUVBLG1CQUFPLHFCQUFQLENBQTZCLEtBQUssTUFBTCxDQUFZLElBQVosQ0FBaUIsSUFBakIsQ0FBN0IsRUFwRUo7Ozs7V0F4TVM7Ozs7Ozs7Ozs7O0FDM0ZiOztJQUFZOztBQUNaOztJQUFZOztBQUNaOztJQUFZOztBQUNaOztJQUFZOzs7O1FBQ0g7UUFBSztRQUFJO1FBQVk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7UUNGZDtRQWlCQTs7QUFuQmhCOztJQUFZOzs7O0FBRUwsU0FBUyxNQUFULENBQWdCLE1BQWhCLEVBQXdCLENBQXhCLEVBQ1A7QUFDSSxRQUFJLFVBQVksSUFBSSxLQUFKLENBQVUsQ0FBVixDQUFaLENBRFI7QUFFSSxRQUFJLFlBQVksT0FBTyxNQUFQLEdBQWdCLENBQWhCLENBRnBCOztBQUlJLFNBQUssSUFBSSxJQUFJLENBQUosRUFBTyxJQUFJLENBQUosRUFBTyxLQUFLLFdBQUwsRUFDdkI7QUFDSSxZQUFNLFdBQWMsS0FBSyxTQUFMLENBQWUsWUFBWSxDQUFaLENBQTdCLENBRFY7QUFFSSxZQUFNLFFBQWMsT0FBTyxRQUFQLENBQWQsQ0FGVjtBQUdJLGVBQU8sUUFBUCxJQUFvQixPQUFPLFNBQVAsQ0FBcEIsQ0FISjtBQUlJLGVBQU8sU0FBUCxJQUFvQixLQUFwQixDQUpKO0FBS0ksZ0JBQVEsQ0FBUixJQUFvQixLQUFwQixDQUxKO0tBREE7O0FBU0EsV0FBTyxPQUFQLENBYko7Q0FETzs7QUFpQkEsU0FBUyxPQUFULENBQWlCLE1BQWpCLEVBQ1A7QUFDSSxTQUFLLElBQUksWUFBWSxPQUFPLE1BQVAsR0FBZ0IsQ0FBaEIsRUFBbUIsWUFBWSxDQUFaLEVBQWUsV0FBdkQsRUFDQTtBQUNJLFlBQU0sY0FBZ0IsS0FBSyxTQUFMLENBQWUsWUFBWSxDQUFaLENBQS9CLENBRFY7QUFFSSxZQUFNLFFBQWdCLE9BQU8sU0FBUCxDQUFoQixDQUZWO0FBR0ksZUFBTyxTQUFQLElBQXNCLE9BQU8sV0FBUCxDQUF0QixDQUhKO0FBSUksZUFBTyxXQUFQLElBQXNCLEtBQXRCLENBSko7S0FEQTs7QUFRQSxXQUFPLE1BQVAsQ0FUSjtDQURPIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsImV4cG9ydCBjbGFzcyBOZXR3b3JrXG57XG4gICAgY29uc3RydWN0b3IobGF5ZXJzKVxuICAgIHtcbiAgICAgICAgdGhpcy5sYXllcnMgPSBsYXllcnM7XG4gICAgfVxuXG4gICAgZXZhbHVhdGUoaW5wdXRzKVxuICAgIHtcbiAgICAgICAgZm9yIChsZXQgbGF5ZXIgb2YgdGhpcy5sYXllcnMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlucHV0cyA9IGxheWVyLnByb3BhZ2F0ZShpbnB1dHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlucHV0cztcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBMYXllclxue1xuICAgIGNvbnN0cnVjdG9yKGJpYXMsIHdlaWdodHMsIGFjdGl2YXRpb25GdW5jdGlvbilcbiAgICB7XG4gICAgICAgIHRoaXMuYmlhcyAgICAgICAgICAgICAgID0gYmlhcztcbiAgICAgICAgdGhpcy53ZWlnaHRzICAgICAgICAgICAgPSB3ZWlnaHRzO1xuICAgICAgICB0aGlzLmFjdGl2YXRpb25GdW5jdGlvbiA9IGFjdGl2YXRpb25GdW5jdGlvbjtcblxuICAgICAgICB0aGlzLm91dHB1dHMgPSBuZXcgQXJyYXkodGhpcy5zaXplKTtcbiAgICB9XG5cbiAgICBwcm9wYWdhdGUoaW5wdXRzKVxuICAgIHtcbiAgICAgICAgY29uc3QgaW5wdXRTaXplICA9IGlucHV0cy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IG91dHB1dFNpemUgPSB0aGlzLm91dHB1dHMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgb3V0cHV0U2l6ZTsgaiArPSAxKVxuICAgICAgICB7XG4gICAgICAgICAgICBsZXQgc3VtID0gdGhpcy5iaWFzW2pdO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0U2l6ZTsgaSArPSAxKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN1bSArPSB0aGlzLndlaWdodHNbaiAqIGlucHV0U2l6ZSArIGldICogaW5wdXRzW2ldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm91dHB1dHNbal0gPSB0aGlzLmFjdGl2YXRpb25GdW5jdGlvbihzdW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMub3V0cHV0cztcbiAgICB9XG5cbiAgICBnZXQgc2l6ZSgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5iaWFzLmxlbmd0aDtcbiAgICB9XG59XG4iLCJpbXBvcnQgKiBhcyBmZWVkZm9yd2FyZCBmcm9tICcuL3NyYy9mZWVkZm9yd2FyZCc7XG5leHBvcnQgeyBmZWVkZm9yd2FyZCB9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9jb3JlL2NvcmUnKTsiLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4vY29yZScpO1xuXG4vKipcbiAqIG1hdGguanMgZmFjdG9yeSBmdW5jdGlvbi4gQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBtYXRoLmpzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIEF2YWlsYWJsZSBjb25maWd1cmF0aW9uIG9wdGlvbnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bnVtYmVyfSBlcHNpbG9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1pbmltdW0gcmVsYXRpdmUgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3b1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wYXJlZCB2YWx1ZXMsIHVzZWQgYnkgYWxsIGNvbXBhcmlzb24gZnVuY3Rpb25zLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAge3N0cmluZ30gbWF0cml4XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEEgc3RyaW5nICdtYXRyaXgnIChkZWZhdWx0KSBvciAnYXJyYXknLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAge3N0cmluZ30gbnVtYmVyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEEgc3RyaW5nICdudW1iZXInIChkZWZhdWx0KSwgJ2JpZ251bWJlcicsIG9yXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmcmFjdGlvbidcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtudW1iZXJ9IHByZWNpc2lvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBmb3IgQmlnTnVtYmVycy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTm90IGFwcGxpY2FibGUgZm9yIE51bWJlcnMuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Ym9vbGVhbn0gcHJlZGljdGFibGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUHJlZGljdGFibGUgb3V0cHV0IHR5cGUgb2YgZnVuY3Rpb25zLiBXaGVuIHRydWUsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCB0eXBlIGRlcGVuZHMgb25seSBvbiB0aGUgaW5wdXQgdHlwZXMuIFdoZW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UgKGRlZmF1bHQpLCBvdXRwdXQgdHlwZSBjYW4gdmFyeSBkZXBlbmRpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb24gaW5wdXQgdmFsdWVzLiBGb3IgZXhhbXBsZSBgbWF0aC5zcXJ0KC0yKWBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJucyBgTmFOYCB3aGVuIHByZWRpY3RhYmxlIGlzIGZhbHNlLCBhbmRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJucyBgY29tcGxleCgnMmknKWAgd2hlbiB0cnVlLlxuICovXG5mdW5jdGlvbiBjcmVhdGUgKGNvbmZpZykge1xuICAvLyBjcmVhdGUgYSBuZXcgbWF0aC5qcyBpbnN0YW5jZVxuICB2YXIgbWF0aCA9IGNvcmUuY3JlYXRlKGNvbmZpZyk7XG4gIG1hdGguY3JlYXRlID0gY3JlYXRlO1xuXG4gIC8vIGltcG9ydCBkYXRhIHR5cGVzLCBmdW5jdGlvbnMsIGNvbnN0YW50cywgZXhwcmVzc2lvbiBwYXJzZXIsIGV0Yy5cbiAgbWF0aFsnaW1wb3J0J10ocmVxdWlyZSgnLi9saWInKSk7XG5cbiAgcmV0dXJuIG1hdGg7XG59XG5cbi8vIHJldHVybiBhIG5ldyBpbnN0YW5jZSBvZiBtYXRoLmpzXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZSgpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgb2JqZWN0ID0gcmVxdWlyZSgnLi91dGlscy9vYmplY3QnKTtcbnZhciBiaWdDb25zdGFudHMgPSByZXF1aXJlKCcuL3V0aWxzL2JpZ251bWJlci9jb25zdGFudHMnKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCwgbWF0aCkge1xuICAvLyBsaXN0ZW4gZm9yIGNoYW5nZWQgaW4gdGhlIGNvbmZpZ3VyYXRpb24sIGF1dG9tYXRpY2FsbHkgcmVsb2FkXG4gIC8vIGNvbnN0YW50cyB3aGVuIG5lZWRlZFxuICBtYXRoLm9uKCdjb25maWcnLCBmdW5jdGlvbiAoY3VyciwgcHJldikge1xuICAgIGlmIChjdXJyLm51bWJlciAhPT0gcHJldi5udW1iZXIpIHtcbiAgICAgIGZhY3RvcnkodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCwgbWF0aCk7XG4gICAgfVxuICB9KTtcblxuICBtYXRoWyd0cnVlJ10gICAgID0gdHJ1ZTtcbiAgbWF0aFsnZmFsc2UnXSAgICA9IGZhbHNlO1xuICBtYXRoWydudWxsJ10gICAgID0gbnVsbDtcbiAgbWF0aFsndW5pbml0aWFsaXplZCddID0gcmVxdWlyZSgnLi91dGlscy9hcnJheScpLlVOSU5JVElBTElaRUQ7XG5cbiAgaWYgKGNvbmZpZy5udW1iZXIgPT09ICdCaWdOdW1iZXInKSB7XG4gICAgbWF0aFsnSW5maW5pdHknXSA9IG5ldyB0eXBlLkJpZ051bWJlcihJbmZpbml0eSk7XG4gICAgbWF0aFsnTmFOJ10gICAgICA9IG5ldyB0eXBlLkJpZ051bWJlcihOYU4pO1xuXG4gICAgb2JqZWN0LmxhenkobWF0aCwgJ3BpJywgIGZ1bmN0aW9uICgpIHtyZXR1cm4gYmlnQ29uc3RhbnRzLnBpKHR5cGUuQmlnTnVtYmVyKX0pO1xuICAgIG9iamVjdC5sYXp5KG1hdGgsICd0YXUnLCBmdW5jdGlvbiAoKSB7cmV0dXJuIGJpZ0NvbnN0YW50cy50YXUodHlwZS5CaWdOdW1iZXIpfSk7XG4gICAgb2JqZWN0LmxhenkobWF0aCwgJ2UnLCAgIGZ1bmN0aW9uICgpIHtyZXR1cm4gYmlnQ29uc3RhbnRzLmUodHlwZS5CaWdOdW1iZXIpfSk7XG4gICAgb2JqZWN0LmxhenkobWF0aCwgJ3BoaScsIGZ1bmN0aW9uICgpIHtyZXR1cm4gYmlnQ29uc3RhbnRzLnBoaSh0eXBlLkJpZ051bWJlcil9KTsgLy8gZ29sZGVuIHJhdGlvLCAoMStzcXJ0KDUpKS8yXG5cbiAgICAvLyB1cHBlcmNhc2UgY29uc3RhbnRzIChmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGJ1aWx0LWluIE1hdGgpXG4gICAgb2JqZWN0LmxhenkobWF0aCwgJ0UnLCAgICAgICBmdW5jdGlvbiAoKSB7cmV0dXJuIG1hdGguZTt9KTtcbiAgICBvYmplY3QubGF6eShtYXRoLCAnTE4yJywgICAgIGZ1bmN0aW9uICgpIHtyZXR1cm4gbmV3IHR5cGUuQmlnTnVtYmVyKDIpLmxuKCk7fSk7XG4gICAgb2JqZWN0LmxhenkobWF0aCwgJ0xOMTAnLCAgICBmdW5jdGlvbiAoKSB7cmV0dXJuIG5ldyB0eXBlLkJpZ051bWJlcigxMCkubG4oKX0pO1xuICAgIG9iamVjdC5sYXp5KG1hdGgsICdMT0cyRScsICAgZnVuY3Rpb24gKCkge3JldHVybiBuZXcgdHlwZS5CaWdOdW1iZXIoMSkuZGl2KG5ldyB0eXBlLkJpZ051bWJlcigyKS5sbigpKTt9KTtcbiAgICBvYmplY3QubGF6eShtYXRoLCAnTE9HMTBFJywgIGZ1bmN0aW9uICgpIHtyZXR1cm4gbmV3IHR5cGUuQmlnTnVtYmVyKDEpLmRpdihuZXcgdHlwZS5CaWdOdW1iZXIoMTApLmxuKCkpfSk7XG4gICAgb2JqZWN0LmxhenkobWF0aCwgJ1BJJywgICAgICBmdW5jdGlvbiAoKSB7cmV0dXJuIG1hdGgucGl9KTtcbiAgICBvYmplY3QubGF6eShtYXRoLCAnU1FSVDFfMicsIGZ1bmN0aW9uICgpIHtyZXR1cm4gbmV3IHR5cGUuQmlnTnVtYmVyKCcwLjUnKS5zcXJ0KCl9KTtcbiAgICBvYmplY3QubGF6eShtYXRoLCAnU1FSVDInLCAgIGZ1bmN0aW9uICgpIHtyZXR1cm4gbmV3IHR5cGUuQmlnTnVtYmVyKDIpLnNxcnQoKX0pO1xuICB9XG4gIGVsc2Uge1xuICAgIG1hdGhbJ0luZmluaXR5J10gPSBJbmZpbml0eTtcbiAgICBtYXRoWydOYU4nXSAgICAgID0gTmFOO1xuXG4gICAgbWF0aC5waSAgPSBNYXRoLlBJO1xuICAgIG1hdGgudGF1ID0gTWF0aC5QSSAqIDI7XG4gICAgbWF0aC5lICAgPSBNYXRoLkU7XG4gICAgbWF0aC5waGkgPSAxLjYxODAzMzk4ODc0OTg5NDg0ODIwNDU4NjgzNDM2NTYzODExNzcyMDMwOTE3OTgwNTc2Mjg2MjEzNTQ1OyAvLyBnb2xkZW4gcmF0aW8sICgxK3NxcnQoNSkpLzJcblxuICAgIC8vIHVwcGVyY2FzZSBjb25zdGFudHMgKGZvciBjb21wYXRpYmlsaXR5IHdpdGggYnVpbHQtaW4gTWF0aClcbiAgICBtYXRoLkUgICAgICAgICAgID0gbWF0aC5lO1xuICAgIG1hdGguTE4yICAgICAgICAgPSBNYXRoLkxOMjtcbiAgICBtYXRoLkxOMTAgICAgICAgID0gTWF0aC5MTjEwO1xuICAgIG1hdGguTE9HMkUgICAgICAgPSBNYXRoLkxPRzJFO1xuICAgIG1hdGguTE9HMTBFICAgICAgPSBNYXRoLkxPRzEwRTtcbiAgICBtYXRoLlBJICAgICAgICAgID0gbWF0aC5waTtcbiAgICBtYXRoLlNRUlQxXzIgICAgID0gTWF0aC5TUVJUMV8yO1xuICAgIG1hdGguU1FSVDIgICAgICAgPSBNYXRoLlNRUlQyO1xuICB9XG5cbiAgLy8gY29tcGxleCBpXG4gIG1hdGguaSA9IHR5cGUuQ29tcGxleC5JO1xuXG4gIC8vIG1ldGEgaW5mb3JtYXRpb25cbiAgbWF0aC52ZXJzaW9uID0gcmVxdWlyZSgnLi92ZXJzaW9uJyk7XG59XG5cbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG5leHBvcnRzLmxhenkgPSBmYWxzZTsgIC8vIG5vIGxhenkgbG9hZGluZyBvZiBjb25zdGFudHMsIHRoZSBjb25zdGFudHMgdGhlbXNlbHZlcyBhcmUgbGF6eSB3aGVuIG5lZWRlZFxuZXhwb3J0cy5tYXRoID0gdHJ1ZTsgICAvLyByZXF1ZXN0IGFjY2VzcyB0byB0aGUgbWF0aCBuYW1lc3BhY2UiLCJ2YXIgaXNGYWN0b3J5ID0gcmVxdWlyZSgnLi8uLi91dGlscy9vYmplY3QnKS5pc0ZhY3Rvcnk7XG52YXIgZGVlcEV4dGVuZCA9IHJlcXVpcmUoJy4vLi4vdXRpbHMvb2JqZWN0JykuZGVlcEV4dGVuZDtcbnZhciB0eXBlZEZhY3RvcnkgPSByZXF1aXJlKCcuL3R5cGVkJyk7XG52YXIgZW1pdHRlciA9IHJlcXVpcmUoJy4vLi4vdXRpbHMvZW1pdHRlcicpO1xuXG52YXIgaW1wb3J0RmFjdG9yeSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vaW1wb3J0Jyk7XG52YXIgY29uZmlnRmFjdG9yeSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vY29uZmlnJyk7XG5cbi8qKlxuICogTWF0aC5qcyBjb3JlLiBDcmVhdGVzIGEgbmV3LCBlbXB0eSBtYXRoLmpzIGluc3RhbmNlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAge251bWJlcn0gZXBzaWxvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNaW5pbXVtIHJlbGF0aXZlIGRpZmZlcmVuY2UgYmV0d2VlbiB0d29cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGFyZWQgdmFsdWVzLCB1c2VkIGJ5IGFsbCBjb21wYXJpc29uIGZ1bmN0aW9ucy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzdHJpbmd9IG1hdHJpeFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBIHN0cmluZyAnTWF0cml4JyAoZGVmYXVsdCkgb3IgJ0FycmF5Jy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzdHJpbmd9IG51bWJlclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBIHN0cmluZyAnbnVtYmVyJyAoZGVmYXVsdCksICdCaWdOdW1iZXInLCBvciAnRnJhY3Rpb24nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bnVtYmVyfSBwcmVjaXNpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgZm9yIEJpZ051bWJlcnMuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5vdCBhcHBsaWNhYmxlIGZvciBOdW1iZXJzLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAge2Jvb2xlYW59IHByZWRpY3RhYmxlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFByZWRpY3RhYmxlIG91dHB1dCB0eXBlIG9mIGZ1bmN0aW9ucy4gV2hlbiB0cnVlLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgdHlwZSBkZXBlbmRzIG9ubHkgb24gdGhlIGlucHV0IHR5cGVzLiBXaGVuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlIChkZWZhdWx0KSwgb3V0cHV0IHR5cGUgY2FuIHZhcnkgZGVwZW5kaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uIGlucHV0IHZhbHVlcy4gRm9yIGV4YW1wbGUgYG1hdGguc3FydCgtMilgXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybnMgYE5hTmAgd2hlbiBwcmVkaWN0YWJsZSBpcyBmYWxzZSwgYW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybnMgYGNvbXBsZXgoJzJpJylgIHdoZW4gdHJ1ZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYSBiYXJlLWJvbmUgbWF0aC5qcyBpbnN0YW5jZSBjb250YWluaW5nXG4gKiAgICAgICAgICAgICAgICAgICBmdW5jdGlvbnM6XG4gKiAgICAgICAgICAgICAgICAgICAtIGBpbXBvcnRgIHRvIGFkZCBuZXcgZnVuY3Rpb25zXG4gKiAgICAgICAgICAgICAgICAgICAtIGBjb25maWdgIHRvIGNoYW5nZSBjb25maWd1cmF0aW9uXG4gKiAgICAgICAgICAgICAgICAgICAtIGBvbmAsIGBvZmZgLCBgb25jZWAsIGBlbWl0YCBmb3IgZXZlbnRzXG4gKi9cbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlIChvcHRpb25zKSB7XG4gIC8vIHNpbXBsZSB0ZXN0IGZvciBFUzUgc3VwcG9ydFxuICBpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0VTNSBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgSmF2YVNjcmlwdCBlbmdpbmUuICcgK1xuICAgICdQbGVhc2UgbG9hZCB0aGUgZXM1LXNoaW0gYW5kIGVzNS1zaGFtIGxpYnJhcnkgZm9yIGNvbXBhdGliaWxpdHkuJyk7XG4gIH1cblxuICAvLyBjYWNoZWQgZmFjdG9yaWVzIGFuZCBpbnN0YW5jZXNcbiAgdmFyIGZhY3RvcmllcyA9IFtdO1xuICB2YXIgaW5zdGFuY2VzID0gW107XG5cbiAgLy8gY3JlYXRlIGEgbmFtZXNwYWNlIGZvciB0aGUgbWF0aGpzIGluc3RhbmNlLCBhbmQgYXR0YWNoIGVtaXR0ZXIgZnVuY3Rpb25zXG4gIHZhciBtYXRoID0gZW1pdHRlci5taXhpbih7fSk7XG4gIG1hdGgudHlwZSA9IHt9O1xuICBtYXRoLmV4cHJlc3Npb24gPSB7XG4gICAgdHJhbnNmb3JtOiBPYmplY3QuY3JlYXRlKG1hdGgpXG4gIH07XG5cbiAgLy8gY3JlYXRlIGEgbmV3IHR5cGVkIGluc3RhbmNlXG4gIG1hdGgudHlwZWQgPSB0eXBlZEZhY3RvcnkuY3JlYXRlKG1hdGgudHlwZSk7XG5cbiAgLy8gY3JlYXRlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy4gVGhlc2UgYXJlIHByaXZhdGVcbiAgdmFyIF9jb25maWcgPSB7XG4gICAgLy8gbWluaW11bSByZWxhdGl2ZSBkaWZmZXJlbmNlIGJldHdlZW4gdHdvIGNvbXBhcmVkIHZhbHVlcyxcbiAgICAvLyB1c2VkIGJ5IGFsbCBjb21wYXJpc29uIGZ1bmN0aW9uc1xuICAgIGVwc2lsb246IDFlLTEyLFxuXG4gICAgLy8gdHlwZSBvZiBkZWZhdWx0IG1hdHJpeCBvdXRwdXQuIENob29zZSAnbWF0cml4JyAoZGVmYXVsdCkgb3IgJ2FycmF5J1xuICAgIG1hdHJpeDogJ01hdHJpeCcsXG5cbiAgICAvLyB0eXBlIG9mIGRlZmF1bHQgbnVtYmVyIG91dHB1dC4gQ2hvb3NlICdudW1iZXInIChkZWZhdWx0KSAnQmlnTnVtYmVyJywgb3IgJ0ZyYWN0aW9uXG4gICAgbnVtYmVyOiAnbnVtYmVyJyxcblxuICAgIC8vIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgaW4gQmlnTnVtYmVyc1xuICAgIHByZWNpc2lvbjogNjQsXG5cbiAgICAvLyBwcmVkaWN0YWJsZSBvdXRwdXQgdHlwZSBvZiBmdW5jdGlvbnMuIFdoZW4gdHJ1ZSwgb3V0cHV0IHR5cGUgZGVwZW5kcyBvbmx5XG4gICAgLy8gb24gdGhlIGlucHV0IHR5cGVzLiBXaGVuIGZhbHNlIChkZWZhdWx0KSwgb3V0cHV0IHR5cGUgY2FuIHZhcnkgZGVwZW5kaW5nXG4gICAgLy8gb24gaW5wdXQgdmFsdWVzLiBGb3IgZXhhbXBsZSBgbWF0aC5zcXJ0KC0yKWAgcmV0dXJucyBgTmFOYCB3aGVuXG4gICAgLy8gcHJlZGljdGFibGUgaXMgZmFsc2UsIGFuZCByZXR1cm5zIGBjb21wbGV4KCcyaScpYCB3aGVuIHRydWUuXG4gICAgcHJlZGljdGFibGU6IGZhbHNlXG4gIH07XG5cbiAgLyoqXG4gICAqIExvYWQgYSBmdW5jdGlvbiBvciBkYXRhIHR5cGUgZnJvbSBhIGZhY3RvcnkuXG4gICAqIElmIHRoZSBmdW5jdGlvbiBvciBkYXRhIHR5cGUgYWxyZWFkeSBleGlzdHMsIHRoZSBleGlzdGluZyBpbnN0YW5jZSBpc1xuICAgKiByZXR1cm5lZC5cbiAgICogQHBhcmFtIHt7dHlwZTogc3RyaW5nLCBuYW1lOiBzdHJpbmcsIGZhY3Rvcnk6IEZ1bmN0aW9ufX0gZmFjdG9yeVxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGZ1bmN0aW9uIGxvYWQgKGZhY3RvcnkpIHtcbiAgICBpZiAoIWlzRmFjdG9yeShmYWN0b3J5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWN0b3J5IG9iamVjdCB3aXRoIHByb3BlcnRpZXMgYHR5cGVgLCBgbmFtZWAsIGFuZCBgZmFjdG9yeWAgZXhwZWN0ZWQnKTtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSBmYWN0b3JpZXMuaW5kZXhPZihmYWN0b3J5KTtcbiAgICB2YXIgaW5zdGFuY2U7XG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgLy8gZG9lc24ndCB5ZXQgZXhpc3RcbiAgICAgIGlmIChmYWN0b3J5Lm1hdGggPT09IHRydWUpIHtcbiAgICAgICAgLy8gcGFzcyB3aXRoIG1hdGggbmFtZXNwYWNlXG4gICAgICAgIGluc3RhbmNlID0gZmFjdG9yeS5mYWN0b3J5KG1hdGgudHlwZSwgX2NvbmZpZywgbG9hZCwgbWF0aC50eXBlZCwgbWF0aCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaW5zdGFuY2UgPSBmYWN0b3J5LmZhY3RvcnkobWF0aC50eXBlLCBfY29uZmlnLCBsb2FkLCBtYXRoLnR5cGVkKTtcbiAgICAgIH1cblxuICAgICAgLy8gYXBwZW5kIHRvIHRoZSBjYWNoZVxuICAgICAgZmFjdG9yaWVzLnB1c2goZmFjdG9yeSk7XG4gICAgICBpbnN0YW5jZXMucHVzaChpbnN0YW5jZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gYWxyZWFkeSBleGlzdGluZyBmdW5jdGlvbiwgcmV0dXJuIHRoZSBjYWNoZWQgaW5zdGFuY2VcbiAgICAgIGluc3RhbmNlID0gaW5zdGFuY2VzW2luZGV4XTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cblxuICAvLyBsb2FkIHRoZSBpbXBvcnQgYW5kIGNvbmZpZyBmdW5jdGlvbnNcbiAgbWF0aFsnaW1wb3J0J10gPSBsb2FkKGltcG9ydEZhY3RvcnkpO1xuICBtYXRoWydjb25maWcnXSA9IGxvYWQoY29uZmlnRmFjdG9yeSk7XG5cbiAgLy8gYXBwbHkgb3B0aW9uc1xuICBpZiAob3B0aW9ucykge1xuICAgIG1hdGguY29uZmlnKG9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIG1hdGg7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgb2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0Jyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQsIG1hdGgpIHtcbiAgdmFyIE1BVFJJWCA9IFsnTWF0cml4JywgJ0FycmF5J107ICAgICAgICAgICAgICAgICAgIC8vIHZhbGlkIHZhbHVlcyBmb3Igb3B0aW9uIG1hdHJpeFxuICB2YXIgTlVNQkVSID0gWydudW1iZXInLCAnQmlnTnVtYmVyJywgJ0ZyYWN0aW9uJ107ICAgLy8gdmFsaWQgdmFsdWVzIGZvciBvcHRpb24gbnVtYmVyXG5cbiAgLyoqXG4gICAqIFNldCBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIG1hdGguanMsIGFuZCBnZXQgY3VycmVudCBvcHRpb25zLlxuICAgKiBXaWxsIGVtaXQgYSAnY29uZmlnJyBldmVudCwgd2l0aCBhcmd1bWVudHMgKGN1cnIsIHByZXYpLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgICBtYXRoLmNvbmZpZyhjb25maWc6IE9iamVjdCk6IE9iamVjdFxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgIG1hdGguY29uZmlnKCkubnVtYmVyOyAgICAgICAgICAgICAgICAvLyBvdXRwdXRzICdudW1iZXInXG4gICAqICAgICBtYXRoLmV2YWwoJzAuNCcpOyAgICAgICAgICAgICAgICAgICAgLy8gb3V0cHV0cyBudW1iZXIgMC40XG4gICAqICAgICBtYXRoLmNvbmZpZyh7bnVtYmVyOiAnRnJhY3Rpb24nfSk7XG4gICAqICAgICBtYXRoLmV2YWwoJzAuNCcpOyAgICAgICAgICAgICAgICAgICAgLy8gb3V0cHV0cyBGcmFjdGlvbiAyLzVcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBdmFpbGFibGUgb3B0aW9uczpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAge251bWJlcn0gZXBzaWxvblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1pbmltdW0gcmVsYXRpdmUgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3b1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBhcmVkIHZhbHVlcywgdXNlZCBieSBhbGwgY29tcGFyaXNvbiBmdW5jdGlvbnMuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzdHJpbmd9IG1hdHJpeFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEEgc3RyaW5nICdNYXRyaXgnIChkZWZhdWx0KSBvciAnQXJyYXknLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nfSBudW1iZXJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBIHN0cmluZyAnbnVtYmVyJyAoZGVmYXVsdCksICdCaWdOdW1iZXInLCBvciAnRnJhY3Rpb24nXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtudW1iZXJ9IHByZWNpc2lvblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIGZvciBCaWdOdW1iZXJzLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5vdCBhcHBsaWNhYmxlIGZvciBOdW1iZXJzLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nfSBwYXJlbnRoZXNpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEhvdyB0byBkaXNwbGF5IHBhcmVudGhlc2VzIGluIExhVGVYIGFuZCBzdHJpbmdcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuXG4gICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBjb25maWd1cmF0aW9uXG4gICAqL1xuICBmdW5jdGlvbiBfY29uZmlnKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgdmFyIHByZXYgPSBvYmplY3QuY2xvbmUoY29uZmlnKTtcblxuICAgICAgLy8gdmFsaWRhdGUgc29tZSBvZiB0aGUgb3B0aW9uc1xuICAgICAgdmFsaWRhdGVPcHRpb24ob3B0aW9ucywgJ21hdHJpeCcsIE1BVFJJWCk7XG4gICAgICB2YWxpZGF0ZU9wdGlvbihvcHRpb25zLCAnbnVtYmVyJywgTlVNQkVSKTtcblxuICAgICAgLy8gbWVyZ2Ugb3B0aW9uc1xuICAgICAgb2JqZWN0LmRlZXBFeHRlbmQoY29uZmlnLCBvcHRpb25zKTtcblxuICAgICAgdmFyIGN1cnIgPSBvYmplY3QuY2xvbmUoY29uZmlnKTtcblxuICAgICAgLy8gZW1pdCAnY29uZmlnJyBldmVudFxuICAgICAgbWF0aC5lbWl0KCdjb25maWcnLCBjdXJyLCBwcmV2KTtcblxuICAgICAgcmV0dXJuIGN1cnI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIG9iamVjdC5jbG9uZShjb25maWcpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGF0dGFjaCB0aGUgdmFsaWQgb3B0aW9ucyB0byB0aGUgZnVuY3Rpb24gc28gdGhleSBjYW4gYmUgZXh0ZW5kZWRcbiAgX2NvbmZpZy5NQVRSSVggPSBNQVRSSVg7XG4gIF9jb25maWcuTlVNQkVSID0gTlVNQkVSO1xuXG4gIHJldHVybiBfY29uZmlnO1xufVxuXG4vKipcbiAqIFRlc3Qgd2hldGhlciBhbiBBcnJheSBjb250YWlucyBhIHNwZWNpZmljIGl0ZW0uXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBhcnJheVxuICogQHBhcmFtIHtzdHJpbmd9IGl0ZW1cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGNvbnRhaW5zIChhcnJheSwgaXRlbSkge1xuICByZXR1cm4gYXJyYXkuaW5kZXhPZihpdGVtKSAhPT0gLTE7XG59XG5cbi8qKlxuICogRmluZCBhIHN0cmluZyBpbiBhbiBhcnJheS4gQ2FzZSBpbnNlbnNpdGl2ZSBzZWFyY2hcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGFycmF5XG4gKiBAcGFyYW0ge3N0cmluZ30gaXRlbVxuICogQHJldHVybiB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCB3aGVuIGZvdW5kLiBSZXR1cm5zIC0xIHdoZW4gbm90IGZvdW5kXG4gKi9cbmZ1bmN0aW9uIGZpbmRJbmRleCAoYXJyYXksIGl0ZW0pIHtcbiAgcmV0dXJuIGFycmF5XG4gICAgICAubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiBpLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9KVxuICAgICAgLmluZGV4T2YoaXRlbS50b0xvd2VyQ2FzZSgpKTtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBhbiBvcHRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zICAgICAgICAgT2JqZWN0IHdpdGggb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgICAgICAgICAgICBOYW1lIG9mIHRoZSBvcHRpb24gdG8gdmFsaWRhdGVcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IHZhbHVlcyAgQXJyYXkgd2l0aCB2YWxpZCB2YWx1ZXMgZm9yIHRoaXMgb3B0aW9uXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlT3B0aW9uKG9wdGlvbnMsIG5hbWUsIHZhbHVlcykge1xuICBpZiAob3B0aW9uc1tuYW1lXSAhPT0gdW5kZWZpbmVkICYmICFjb250YWlucyh2YWx1ZXMsIG9wdGlvbnNbbmFtZV0pKSB7XG4gICAgdmFyIGluZGV4ID0gZmluZEluZGV4KHZhbHVlcywgb3B0aW9uc1tuYW1lXSk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgLy8gcmlnaHQgdmFsdWUsIHdyb25nIGNhc2luZ1xuICAgICAgLy8gVE9ETzogbG93ZXIgY2FzZSB2YWx1ZXMgYXJlIGRlcHJlY2F0ZWQgc2luY2UgdjMsIHJlbW92ZSB0aGlzIHdhcm5pbmcgc29tZSBkYXkuXG4gICAgICBjb25zb2xlLndhcm4oJ1dhcm5pbmc6IFdyb25nIGNhc2luZyBmb3IgY29uZmlndXJhdGlvbiBvcHRpb24gXCInICsgbmFtZSArICdcIiwgc2hvdWxkIGJlIFwiJyArIHZhbHVlc1tpbmRleF0gKyAnXCIgaW5zdGVhZCBvZiBcIicgKyBvcHRpb25zW25hbWVdICsgJ1wiLicpO1xuXG4gICAgICBvcHRpb25zW25hbWVdID0gdmFsdWVzW2luZGV4XTsgLy8gY2hhbmdlIHRoZSBvcHRpb24gdG8gdGhlIHJpZ2h0IGNhc2luZ1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIHVua25vd24gdmFsdWVcbiAgICAgIGNvbnNvbGUud2FybignV2FybmluZzogVW5rbm93biB2YWx1ZSBcIicgKyBvcHRpb25zW25hbWVdICsgJ1wiIGZvciBjb25maWd1cmF0aW9uIG9wdGlvbiBcIicgKyBuYW1lICsgJ1wiLiBBdmFpbGFibGUgb3B0aW9uczogJyArIHZhbHVlcy5tYXAoSlNPTi5zdHJpbmdpZnkpLmpvaW4oJywgJykgKyAnLicpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnRzLm5hbWUgPSAnY29uZmlnJztcbmV4cG9ydHMubWF0aCA9IHRydWU7IC8vIHJlcXVlc3QgdGhlIG1hdGggbmFtZXNwYWNlIGFzIGZpZnRoIGFyZ3VtZW50XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbGF6eSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdCcpLmxhenk7XG52YXIgaXNGYWN0b3J5ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0JykuaXNGYWN0b3J5O1xudmFyIHRyYXZlcnNlID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0JykudHJhdmVyc2U7XG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0JykuZXh0ZW5kO1xudmFyIEFyZ3VtZW50c0Vycm9yID0gcmVxdWlyZSgnLi4vLi4vZXJyb3IvQXJndW1lbnRzRXJyb3InKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCwgbWF0aCkge1xuICAvKipcbiAgICogSW1wb3J0IGZ1bmN0aW9ucyBmcm9tIGFuIG9iamVjdCBvciBhIG1vZHVsZVxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguaW1wb3J0KG9iamVjdClcbiAgICogICAgbWF0aC5pbXBvcnQob2JqZWN0LCBvcHRpb25zKVxuICAgKlxuICAgKiBXaGVyZTpcbiAgICpcbiAgICogLSBgb2JqZWN0OiBPYmplY3RgXG4gICAqICAgQW4gb2JqZWN0IHdpdGggZnVuY3Rpb25zIHRvIGJlIGltcG9ydGVkLlxuICAgKiAtIGBvcHRpb25zOiBPYmplY3RgIEFuIG9iamVjdCB3aXRoIGltcG9ydCBvcHRpb25zLiBBdmFpbGFibGUgb3B0aW9uczpcbiAgICogICAtIGBvdmVycmlkZTogYm9vbGVhbmBcbiAgICogICAgIElmIHRydWUsIGV4aXN0aW5nIGZ1bmN0aW9ucyB3aWxsIGJlIG92ZXJ3cml0dGVuLiBGYWxzZSBieSBkZWZhdWx0LlxuICAgKiAgIC0gYHNpbGVudDogYm9vbGVhbmBcbiAgICogICAgIElmIHRydWUsIHRoZSBmdW5jdGlvbiB3aWxsIG5vdCB0aHJvdyBlcnJvcnMgb24gZHVwbGljYXRlcyBvciBpbnZhbGlkXG4gICAqICAgICB0eXBlcy4gRmFsc2UgYnkgZGVmYXVsdC5cbiAgICogICAtIGB3cmFwOiBib29sZWFuYFxuICAgKiAgICAgSWYgdHJ1ZSwgdGhlIGZ1bmN0aW9ucyB3aWxsIGJlIHdyYXBwZWQgaW4gYSB3cmFwcGVyIGZ1bmN0aW9uXG4gICAqICAgICB3aGljaCBjb252ZXJ0cyBkYXRhIHR5cGVzIGxpa2UgTWF0cml4IHRvIHByaW1pdGl2ZSBkYXRhIHR5cGVzIGxpa2UgQXJyYXkuXG4gICAqICAgICBUaGUgd3JhcHBlciBpcyBuZWVkZWQgd2hlbiBleHRlbmRpbmcgbWF0aC5qcyB3aXRoIGxpYnJhcmllcyB3aGljaCBkbyBub3RcbiAgICogICAgIHN1cHBvcnQgdGhlc2UgZGF0YSB0eXBlLiBGYWxzZSBieSBkZWZhdWx0LlxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgLy8gZGVmaW5lIG5ldyBmdW5jdGlvbnMgYW5kIHZhcmlhYmxlc1xuICAgKiAgICBtYXRoLmltcG9ydCh7XG4gICAqICAgICAgbXl2YWx1ZTogNDIsXG4gICAqICAgICAgaGVsbG86IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAqICAgICAgICByZXR1cm4gJ2hlbGxvLCAnICsgbmFtZSArICchJztcbiAgICogICAgICB9XG4gICAqICAgIH0pO1xuICAgKlxuICAgKiAgICAvLyB1c2UgdGhlIGltcG9ydGVkIGZ1bmN0aW9uIGFuZCB2YXJpYWJsZVxuICAgKiAgICBtYXRoLm15dmFsdWUgKiAyOyAgICAgICAgICAgICAgIC8vIDg0XG4gICAqICAgIG1hdGguaGVsbG8oJ3VzZXInKTsgICAgICAgICAgICAgLy8gJ2hlbGxvLCB1c2VyISdcbiAgICpcbiAgICogICAgLy8gaW1wb3J0IHRoZSBucG0gbW9kdWxlICdudW1iZXJzJ1xuICAgKiAgICAvLyAobXVzdCBiZSBpbnN0YWxsZWQgZmlyc3Qgd2l0aCBgbnBtIGluc3RhbGwgbnVtYmVyc2ApXG4gICAqICAgIG1hdGguaW1wb3J0KHJlcXVpcmUoJ251bWJlcnMnKSwge3dyYXA6IHRydWV9KTtcbiAgICpcbiAgICogICAgbWF0aC5maWJvbmFjY2koNyk7IC8vIHJldHVybnMgMTNcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3QgfCBBcnJheX0gb2JqZWN0ICAgT2JqZWN0IHdpdGggZnVuY3Rpb25zIHRvIGJlIGltcG9ydGVkLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgICAgICBJbXBvcnQgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIG1hdGhfaW1wb3J0KG9iamVjdCwgb3B0aW9ucykge1xuICAgIHZhciBudW0gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmIChudW0gIT0gMSAmJiBudW0gIT0gMikge1xuICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50c0Vycm9yKCdpbXBvcnQnLCBudW0sIDEsIDIpO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIGlmIChpc0ZhY3Rvcnkob2JqZWN0KSkge1xuICAgICAgX2ltcG9ydEZhY3Rvcnkob2JqZWN0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgLy8gVE9ETzogYWxsb3cgYSB0eXBlZC1mdW5jdGlvbiB3aXRoIG5hbWUgdG9vXG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICBvYmplY3QuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgbWF0aF9pbXBvcnQoZW50cnksIG9wdGlvbnMpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnKSB7XG4gICAgICAvLyBhIG1hcCB3aXRoIGZ1bmN0aW9uc1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBvYmplY3QpIHtcbiAgICAgICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtuYW1lXTtcbiAgICAgICAgICBpZiAoaXNTdXBwb3J0ZWRUeXBlKHZhbHVlKSkge1xuICAgICAgICAgICAgX2ltcG9ydChuYW1lLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGlzRmFjdG9yeShvYmplY3QpKSB7XG4gICAgICAgICAgICBfaW1wb3J0RmFjdG9yeShvYmplY3QsIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1hdGhfaW1wb3J0KHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZhY3RvcnksIE9iamVjdCwgb3IgQXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgcHJvcGVydHkgdG8gdGhlIG1hdGggbmFtZXNwYWNlIGFuZCBjcmVhdGUgYSBjaGFpbiBwcm94eSBmb3IgaXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgIFNlZSBpbXBvcnQgZm9yIGEgZGVzY3JpcHRpb24gb2YgdGhlIG9wdGlvbnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9pbXBvcnQobmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy53cmFwICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gY3JlYXRlIGEgd3JhcHBlciBhcm91bmQgdGhlIGZ1bmN0aW9uXG4gICAgICB2YWx1ZSA9IF93cmFwKHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAoaXNUeXBlZEZ1bmN0aW9uKG1hdGhbbmFtZV0pICYmIGlzVHlwZWRGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIGlmIChvcHRpb25zLm92ZXJyaWRlKSB7XG4gICAgICAgIC8vIGdpdmUgdGhlIHR5cGVkIGZ1bmN0aW9uIHRoZSByaWdodCBuYW1lXG4gICAgICAgIHZhbHVlID0gdHlwZWQobmFtZSwgdmFsdWUuc2lnbmF0dXJlcyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gbWVyZ2UgdGhlIGV4aXN0aW5nIGFuZCB0eXBlZCBmdW5jdGlvblxuICAgICAgICB2YWx1ZSA9IHR5cGVkKG1hdGhbbmFtZV0sIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgbWF0aFtuYW1lXSA9IHZhbHVlO1xuICAgICAgX2ltcG9ydFRyYW5zZm9ybShuYW1lLCB2YWx1ZSk7XG4gICAgICBtYXRoLmVtaXQoJ2ltcG9ydCcsIG5hbWUsIGZ1bmN0aW9uIHJlc29sdmVyKCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobWF0aFtuYW1lXSA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMub3ZlcnJpZGUpIHtcbiAgICAgIG1hdGhbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIF9pbXBvcnRUcmFuc2Zvcm0obmFtZSwgdmFsdWUpO1xuICAgICAgbWF0aC5lbWl0KCdpbXBvcnQnLCBuYW1lLCBmdW5jdGlvbiByZXNvbHZlcigpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLnNpbGVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW1wb3J0IFwiJyArIG5hbWUgKyAnXCI6IGFscmVhZHkgZXhpc3RzJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2ltcG9ydFRyYW5zZm9ybSAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbWF0aC5leHByZXNzaW9uLnRyYW5zZm9ybVtuYW1lXSA9IHZhbHVlLnRyYW5zZm9ybTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgd3JhcHBlciBhIHJvdW5kIGFuIGZ1bmN0aW9uIHdoaWNoIGNvbnZlcnRzIHRoZSBhcmd1bWVudHNcbiAgICogdG8gdGhlaXIgcHJpbWl0aXZlIHZhbHVlcyAobGlrZSBjb252ZXJ0IGEgTWF0cml4IHRvIEFycmF5KVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgd3JhcHBlZCBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX3dyYXAgKGZuKSB7XG4gICAgdmFyIHdyYXBwZXIgPSBmdW5jdGlvbiB3cmFwcGVyICgpIHtcbiAgICAgIHZhciBhcmdzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGFyZ3NbaV0gPSBhcmcgJiYgYXJnLnZhbHVlT2YoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmbi5hcHBseShtYXRoLCBhcmdzKTtcbiAgICB9O1xuXG4gICAgaWYgKGZuLnRyYW5zZm9ybSkge1xuICAgICAgd3JhcHBlci50cmFuc2Zvcm0gPSBmbi50cmFuc2Zvcm07XG4gICAgfVxuXG4gICAgcmV0dXJuIHdyYXBwZXI7XG4gIH1cblxuICAvKipcbiAgICogSW1wb3J0IGFuIGluc3RhbmNlIG9mIGEgZmFjdG9yeSBpbnRvIG1hdGguanNcbiAgICogQHBhcmFtIHt7ZmFjdG9yeTogRnVuY3Rpb24sIG5hbWU6IHN0cmluZywgcGF0aDogc3RyaW5nLCBtYXRoOiBib29sZWFufX0gZmFjdG9yeVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAgU2VlIGltcG9ydCBmb3IgYSBkZXNjcmlwdGlvbiBvZiB0aGUgb3B0aW9uc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX2ltcG9ydEZhY3RvcnkoZmFjdG9yeSwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgZmFjdG9yeS5uYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIG5hbWUgPSBmYWN0b3J5Lm5hbWU7XG4gICAgICB2YXIgbmFtZXNwYWNlID0gZmFjdG9yeS5wYXRoID8gdHJhdmVyc2UobWF0aCwgZmFjdG9yeS5wYXRoKSA6IG1hdGg7XG4gICAgICB2YXIgZXhpc3RpbmcgPSBuYW1lc3BhY2UuaGFzT3duUHJvcGVydHkobmFtZSkgPyBuYW1lc3BhY2VbbmFtZV0gOiB1bmRlZmluZWQ7XG5cbiAgICAgIHZhciByZXNvbHZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gbG9hZChmYWN0b3J5KTtcblxuICAgICAgICBpZiAoaXNUeXBlZEZ1bmN0aW9uKGV4aXN0aW5nKSAmJiBpc1R5cGVkRnVuY3Rpb24oaW5zdGFuY2UpKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMub3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIC8vIHJlcGxhY2UgdGhlIGV4aXN0aW5nIHR5cGVkIGZ1bmN0aW9uIChub3RoaW5nIHRvIGRvKVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG1lcmdlIHRoZSBleGlzdGluZyBhbmQgbmV3IHR5cGVkIGZ1bmN0aW9uXG4gICAgICAgICAgICBpbnN0YW5jZSA9IHR5cGVkKGV4aXN0aW5nLCBpbnN0YW5jZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5vdmVycmlkZSkge1xuICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbXBvcnQgXCInICsgbmFtZSArICdcIjogYWxyZWFkeSBleGlzdHMnKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKGZhY3RvcnkubGF6eSAhPT0gZmFsc2UpIHtcbiAgICAgICAgbGF6eShuYW1lc3BhY2UsIG5hbWUsIHJlc29sdmVyKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBuYW1lc3BhY2VbbmFtZV0gPSByZXNvbHZlcigpO1xuICAgICAgfVxuXG4gICAgICBtYXRoLmVtaXQoJ2ltcG9ydCcsIG5hbWUsIHJlc29sdmVyLCBmYWN0b3J5LnBhdGgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIHVubmFtZWQgZmFjdG9yeS5cbiAgICAgIC8vIG5vIGxhenkgbG9hZGluZ1xuICAgICAgbG9hZChmYWN0b3J5KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciBnaXZlbiBvYmplY3QgaXMgYSB0eXBlIHdoaWNoIGNhbiBiZSBpbXBvcnRlZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uIHwgbnVtYmVyIHwgc3RyaW5nIHwgYm9vbGVhbiB8IG51bGwgfCBVbml0IHwgQ29tcGxleH0gb2JqZWN0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBpc1N1cHBvcnRlZFR5cGUob2JqZWN0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICB8fCB0eXBlb2Ygb2JqZWN0ID09PSAnbnVtYmVyJ1xuICAgICAgICB8fCB0eXBlb2Ygb2JqZWN0ID09PSAnc3RyaW5nJ1xuICAgICAgICB8fCB0eXBlb2Ygb2JqZWN0ID09PSAnYm9vbGVhbidcbiAgICAgICAgfHwgb2JqZWN0ID09PSBudWxsXG4gICAgICAgIHx8IChvYmplY3QgJiYgb2JqZWN0LmlzVW5pdCA9PT0gdHJ1ZSlcbiAgICAgICAgfHwgKG9iamVjdCAmJiBvYmplY3QuaXNDb21wbGV4ID09PSB0cnVlKVxuICAgICAgICB8fCAob2JqZWN0ICYmIG9iamVjdC5pc0JpZ051bWJlciA9PT0gdHJ1ZSlcbiAgICAgICAgfHwgKG9iamVjdCAmJiBvYmplY3QuaXNGcmFjdGlvbiA9PT0gdHJ1ZSlcbiAgICAgICAgfHwgKG9iamVjdCAmJiBvYmplY3QuaXNNYXRyaXggPT09IHRydWUpXG4gICAgICAgIHx8IChvYmplY3QgJiYgQXJyYXkuaXNBcnJheShvYmplY3QpID09PSB0cnVlKVxuICB9XG5cbiAgLyoqXG4gICAqIFRlc3Qgd2hldGhlciBhIGdpdmVuIHRoaW5nIGlzIGEgdHlwZWQtZnVuY3Rpb25cbiAgICogQHBhcmFtIHsqfSBmblxuICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgd2hlbiBgZm5gIGlzIGEgdHlwZWQtZnVuY3Rpb25cbiAgICovXG4gIGZ1bmN0aW9uIGlzVHlwZWRGdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBmbi5zaWduYXR1cmVzID09PSAnb2JqZWN0JztcbiAgfVxuXG4gIHJldHVybiBtYXRoX2ltcG9ydDtcbn1cblxuZXhwb3J0cy5tYXRoID0gdHJ1ZTsgLy8gcmVxdWVzdCBhY2Nlc3MgdG8gdGhlIG1hdGggbmFtZXNwYWNlIGFzIDV0aCBhcmd1bWVudCBvZiB0aGUgZmFjdG9yeSBmdW5jdGlvblxuZXhwb3J0cy5uYW1lID0gJ2ltcG9ydCc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuZXhwb3J0cy5sYXp5ID0gdHJ1ZTtcbiIsInZhciB0eXBlZEZ1bmN0aW9uID0gcmVxdWlyZSgndHlwZWQtZnVuY3Rpb24nKTtcbnZhciBkaWdpdHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzL251bWJlcicpLmRpZ2l0cztcblxuLy8gcmV0dXJucyBhIG5ldyBpbnN0YW5jZSBvZiB0eXBlZC1mdW5jdGlvblxudmFyIGNyZWF0ZVR5cGVkID0gZnVuY3Rpb24gKCkge1xuICAvLyBpbml0aWFsbHksIHJldHVybiB0aGUgb3JpZ2luYWwgaW5zdGFuY2Ugb2YgdHlwZWQtZnVuY3Rpb25cbiAgLy8gY29uc2VjdXRpdmVseSwgcmV0dXJuIGEgbmV3IGluc3RhbmNlIGZyb20gdHlwZWQuY3JlYXRlLlxuICBjcmVhdGVUeXBlZCA9IHR5cGVkRnVuY3Rpb24uY3JlYXRlO1xuICByZXR1cm4gdHlwZWRGdW5jdGlvbjtcbn07XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSBuZXcgdHlwZWQgaW5zdGFuY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlICAgT2JqZWN0IHdpdGggZGF0YSB0eXBlcyBsaWtlIENvbXBsZXggYW5kIEJpZ051bWJlclxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZSh0eXBlKSB7XG4gIC8vIFRPRE86IHR5cGVkLWZ1bmN0aW9uIG11c3QgYmUgYWJsZSB0byBzaWxlbnRseSBpZ25vcmUgc2lnbmF0dXJlcyB3aXRoIHVua25vd24gZGF0YSB0eXBlc1xuXG4gIC8vIGdldCBhIG5ldyBpbnN0YW5jZSBvZiB0eXBlZC1mdW5jdGlvblxuICB2YXIgdHlwZWQgPSBjcmVhdGVUeXBlZCgpO1xuXG4gIC8vIGRlZmluZSBhbGwgdHlwZXMuIFRoZSBvcmRlciBvZiB0aGUgdHlwZXMgZGV0ZXJtaW5lcyBpbiB3aGljaCBvcmRlciBmdW5jdGlvblxuICAvLyBhcmd1bWVudHMgYXJlIHR5cGUtY2hlY2tlZCAoc28gZm9yIHBlcmZvcm1hbmNlIGl0J3MgaW1wb3J0YW50IHRvIHB1dCB0aGVcbiAgLy8gbW9zdCB1c2VkIHR5cGVzIGZpcnN0KS5cbiAgdHlwZWQudHlwZXMgPSBbXG4gICAgeyBuYW1lOiAnbnVtYmVyJywgICAgICAgICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoeCkgeyByZXR1cm4gdHlwZW9mIHggPT09ICdudW1iZXInOyB9IH0sXG4gICAgeyBuYW1lOiAnQ29tcGxleCcsICAgICAgICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCAmJiB4LmlzQ29tcGxleDsgfSB9LFxuICAgIHsgbmFtZTogJ0JpZ051bWJlcicsICAgICAgICAgICAgdGVzdDogZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggJiYgeC5pc0JpZ051bWJlcjsgfSB9LFxuICAgIHsgbmFtZTogJ0ZyYWN0aW9uJywgICAgICAgICAgICAgdGVzdDogZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggJiYgeC5pc0ZyYWN0aW9uOyB9IH0sXG4gICAgeyBuYW1lOiAnVW5pdCcsICAgICAgICAgICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCAmJiB4LmlzVW5pdDsgfSB9LFxuICAgIHsgbmFtZTogJ3N0cmluZycsICAgICAgICAgICAgICAgdGVzdDogZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHR5cGVvZiB4ID09PSAnc3RyaW5nJzsgfSB9LFxuICAgIHsgbmFtZTogJ0FycmF5JywgICAgICAgICAgICAgICAgdGVzdDogQXJyYXkuaXNBcnJheSB9LFxuICAgIHsgbmFtZTogJ01hdHJpeCcsICAgICAgICAgICAgICAgdGVzdDogZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggJiYgeC5pc01hdHJpeDsgfSB9LFxuICAgIHsgbmFtZTogJ0RlbnNlTWF0cml4JywgICAgICAgICAgdGVzdDogZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggJiYgeC5pc0RlbnNlTWF0cml4OyB9IH0sXG4gICAgeyBuYW1lOiAnU3BhcnNlTWF0cml4JywgICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCAmJiB4LmlzU3BhcnNlTWF0cml4OyB9IH0sXG4gICAgeyBuYW1lOiAnSW1tdXRhYmxlRGVuc2VNYXRyaXgnLCB0ZXN0OiBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCAmJiB4LmlzSW1tdXRhYmxlRGVuc2VNYXRyaXg7IH0gfSxcbiAgICB7IG5hbWU6ICdSYW5nZScsICAgICAgICAgICAgICAgIHRlc3Q6IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICYmIHguaXNSYW5nZTsgfSB9LFxuICAgIHsgbmFtZTogJ0luZGV4JywgICAgICAgICAgICAgICAgdGVzdDogZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggJiYgeC5pc0luZGV4OyB9IH0sXG4gICAgeyBuYW1lOiAnYm9vbGVhbicsICAgICAgICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoeCkgeyByZXR1cm4gdHlwZW9mIHggPT09ICdib29sZWFuJzsgfSB9LFxuICAgIHsgbmFtZTogJ1Jlc3VsdFNldCcsICAgICAgICAgICAgdGVzdDogZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggJiYgeC5pc1Jlc3VsdFNldDsgfSB9LFxuICAgIHsgbmFtZTogJ0hlbHAnLCAgICAgICAgICAgICAgICAgdGVzdDogZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggJiYgeC5pc0hlbHA7IH0gfSxcbiAgICB7IG5hbWU6ICdmdW5jdGlvbicsICAgICAgICAgICAgIHRlc3Q6IGZ1bmN0aW9uICh4KSB7IHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJzt9IH0sXG4gICAgeyBuYW1lOiAnRGF0ZScsICAgICAgICAgICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCBpbnN0YW5jZW9mIERhdGU7IH0gfSxcbiAgICB7IG5hbWU6ICdSZWdFeHAnLCAgICAgICAgICAgICAgIHRlc3Q6IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4IGluc3RhbmNlb2YgUmVnRXhwOyB9IH0sXG4gICAgeyBuYW1lOiAnT2JqZWN0JywgICAgICAgICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoeCkgeyByZXR1cm4gdHlwZW9mIHggPT09ICdvYmplY3QnOyB9IH0sXG4gICAgeyBuYW1lOiAnbnVsbCcsICAgICAgICAgICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCA9PT0gbnVsbDsgfSB9LFxuICAgIHsgbmFtZTogJ3VuZGVmaW5lZCcsICAgICAgICAgICAgdGVzdDogZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggPT09IHVuZGVmaW5lZDsgfSB9XG4gIF07XG5cbiAgLy8gVE9ETzogYWRkIGNvbnZlcnNpb24gZnJvbSBCaWdOdW1iZXIgdG8gbnVtYmVyP1xuICB0eXBlZC5jb252ZXJzaW9ucyA9IFtcbiAgICB7XG4gICAgICBmcm9tOiAnbnVtYmVyJyxcbiAgICAgIHRvOiAnQmlnTnVtYmVyJyxcbiAgICAgIGNvbnZlcnQ6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIC8vIG5vdGU6IGNvbnZlcnNpb24gZnJvbSBudW1iZXIgdG8gQmlnTnVtYmVyIGNhbiBmYWlsIGlmIHggaGFzID4xNSBkaWdpdHNcbiAgICAgICAgaWYgKGRpZ2l0cyh4KSA+IDE1KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGltcGxpY2l0bHkgY29udmVydCBhIG51bWJlciB3aXRoID4xNSBzaWduaWZpY2FudCBkaWdpdHMgdG8gQmlnTnVtYmVyICcgK1xuICAgICAgICAgICcodmFsdWU6ICcgKyB4ICsgJykuICcgK1xuICAgICAgICAgICdVc2UgZnVuY3Rpb24gYmlnbnVtYmVyKHgpIHRvIGNvbnZlcnQgdG8gQmlnTnVtYmVyLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgdHlwZS5CaWdOdW1iZXIoeCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgZnJvbTogJ251bWJlcicsXG4gICAgICB0bzogJ0NvbXBsZXgnLFxuICAgICAgY29udmVydDogZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0eXBlLkNvbXBsZXgoeCwgMCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgZnJvbTogJ251bWJlcicsXG4gICAgICB0bzogJ3N0cmluZycsXG4gICAgICBjb252ZXJ0OiBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geCArICcnO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGZyb206ICdCaWdOdW1iZXInLFxuICAgICAgdG86ICdDb21wbGV4JyxcbiAgICAgIGNvbnZlcnQ6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiBuZXcgdHlwZS5Db21wbGV4KHgudG9OdW1iZXIoKSwgMCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgZnJvbTogJ0ZyYWN0aW9uJyxcbiAgICAgIHRvOiAnQ29tcGxleCcsXG4gICAgICBjb252ZXJ0OiBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gbmV3IHR5cGUuQ29tcGxleCh4LnZhbHVlT2YoKSwgMCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgZnJvbTogJ251bWJlcicsXG4gICAgICB0bzogJ0ZyYWN0aW9uJyxcbiAgICAgIGNvbnZlcnQ6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGlmIChkaWdpdHMoeCkgPiAxNSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBpbXBsaWNpdGx5IGNvbnZlcnQgYSBudW1iZXIgd2l0aCA+MTUgc2lnbmlmaWNhbnQgZGlnaXRzIHRvIEZyYWN0aW9uICcgK1xuICAgICAgICAgICAgICAnKHZhbHVlOiAnICsgeCArICcpLiAnICtcbiAgICAgICAgICAgICAgJ1VzZSBmdW5jdGlvbiBmcmFjdGlvbih4KSB0byBjb252ZXJ0IHRvIEZyYWN0aW9uLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgdHlwZS5GcmFjdGlvbih4KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgLy8gRklYTUU6IGFkZCBjb252ZXJzaW9uIGZyb20gRnJhY3Rpb24gdG8gbnVtYmVyLCBmb3IgZXhhbXBsZSBmb3IgYHNxcnQoZnJhY3Rpb24oMSwzKSlgXG4gICAgLy8gIGZyb206ICdGcmFjdGlvbicsXG4gICAgLy8gIHRvOiAnbnVtYmVyJyxcbiAgICAvLyAgY29udmVydDogZnVuY3Rpb24gKHgpIHtcbiAgICAvLyAgICByZXR1cm4geC52YWx1ZU9mKCk7XG4gICAgLy8gIH1cbiAgICAvL30sIHtcbiAgICAgIGZyb206ICdzdHJpbmcnLFxuICAgICAgdG86ICdudW1iZXInLFxuICAgICAgY29udmVydDogZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIG4gPSBOdW1iZXIoeCk7XG4gICAgICAgIGlmIChpc05hTihuKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnZlcnQgXCInICsgeCArICdcIiB0byBhIG51bWJlcicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGZyb206ICdib29sZWFuJyxcbiAgICAgIHRvOiAnbnVtYmVyJyxcbiAgICAgIGNvbnZlcnQ6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiAreDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBmcm9tOiAnYm9vbGVhbicsXG4gICAgICB0bzogJ0JpZ051bWJlcicsXG4gICAgICBjb252ZXJ0OiBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gbmV3IHR5cGUuQmlnTnVtYmVyKCt4KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBmcm9tOiAnYm9vbGVhbicsXG4gICAgICB0bzogJ0ZyYWN0aW9uJyxcbiAgICAgIGNvbnZlcnQ6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiBuZXcgdHlwZS5GcmFjdGlvbigreCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgZnJvbTogJ2Jvb2xlYW4nLFxuICAgICAgdG86ICdzdHJpbmcnLFxuICAgICAgY29udmVydDogZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuICt4O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGZyb206ICdudWxsJyxcbiAgICAgIHRvOiAnbnVtYmVyJyxcbiAgICAgIGNvbnZlcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgZnJvbTogJ251bGwnLFxuICAgICAgdG86ICdzdHJpbmcnLFxuICAgICAgY29udmVydDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGZyb206ICdudWxsJyxcbiAgICAgIHRvOiAnQmlnTnVtYmVyJyxcbiAgICAgIGNvbnZlcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0eXBlLkJpZ051bWJlcigwKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBmcm9tOiAnbnVsbCcsXG4gICAgICB0bzogJ0ZyYWN0aW9uJyxcbiAgICAgIGNvbnZlcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0eXBlLkZyYWN0aW9uKDApO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGZyb206ICdBcnJheScsXG4gICAgICB0bzogJ01hdHJpeCcsXG4gICAgICBjb252ZXJ0OiBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgLy8gVE9ETzogaG93IHRvIGRlY2lkZSBvbiB0aGUgcmlnaHQgdHlwZSBvZiBtYXRyaXggdG8gY3JlYXRlP1xuICAgICAgICByZXR1cm4gbmV3IHR5cGUuRGVuc2VNYXRyaXgoYXJyYXkpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGZyb206ICdNYXRyaXgnLFxuICAgICAgdG86ICdBcnJheScsXG4gICAgICBjb252ZXJ0OiBmdW5jdGlvbiAobWF0cml4KSB7XG4gICAgICAgIHJldHVybiBtYXRyaXgudmFsdWVPZigpO1xuICAgICAgfVxuICAgIH1cbiAgXTtcblxuICByZXR1cm4gdHlwZWQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENyZWF0ZSBhIHN5bnRheCBlcnJvciB3aXRoIHRoZSBtZXNzYWdlOlxuICogICAgICdXcm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIGluIGZ1bmN0aW9uIDxmbj4gKDxjb3VudD4gcHJvdmlkZWQsIDxtaW4+LTxtYXg+IGV4cGVjdGVkKSdcbiAqIEBwYXJhbSB7c3RyaW5nfSBmbiAgICAgRnVuY3Rpb24gbmFtZVxuICogQHBhcmFtIHtudW1iZXJ9IGNvdW50ICBBY3R1YWwgYXJndW1lbnQgY291bnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gICAgTWluaW11bSByZXF1aXJlZCBhcmd1bWVudCBjb3VudFxuICogQHBhcmFtIHtudW1iZXJ9IFttYXhdICBNYXhpbXVtIHJlcXVpcmVkIGFyZ3VtZW50IGNvdW50XG4gKiBAZXh0ZW5kcyBFcnJvclxuICovXG5mdW5jdGlvbiBBcmd1bWVudHNFcnJvcihmbiwgY291bnQsIG1pbiwgbWF4KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBBcmd1bWVudHNFcnJvcikpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0NvbnN0cnVjdG9yIG11c3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBvcGVyYXRvcicpO1xuICB9XG5cbiAgdGhpcy5mbiA9IGZuO1xuICB0aGlzLmNvdW50ID0gY291bnQ7XG4gIHRoaXMubWluID0gbWluO1xuICB0aGlzLm1heCA9IG1heDtcblxuICB0aGlzLm1lc3NhZ2UgPSAnV3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyBpbiBmdW5jdGlvbiAnICsgZm4gK1xuICAgICAgJyAoJyArIGNvdW50ICsgJyBwcm92aWRlZCwgJyArXG4gICAgICBtaW4gKyAoKG1heCAhPSB1bmRlZmluZWQpID8gKCctJyArIG1heCkgOiAnJykgKyAnIGV4cGVjdGVkKSc7XG5cbiAgdGhpcy5zdGFjayA9IChuZXcgRXJyb3IoKSkuc3RhY2s7XG59XG5cbkFyZ3VtZW50c0Vycm9yLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuQXJndW1lbnRzRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRXJyb3I7XG5Bcmd1bWVudHNFcnJvci5wcm90b3R5cGUubmFtZSA9ICdBcmd1bWVudHNFcnJvcic7XG5Bcmd1bWVudHNFcnJvci5wcm90b3R5cGUuaXNBcmd1bWVudHNFcnJvciA9IHRydWU7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJndW1lbnRzRXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlIGEgcmFuZ2UgZXJyb3Igd2l0aCB0aGUgbWVzc2FnZTpcbiAqICAgICAnRGltZW5zaW9uIG1pc21hdGNoICg8YWN0dWFsIHNpemU+ICE9IDxleHBlY3RlZCBzaXplPiknXG4gKiBAcGFyYW0ge251bWJlciB8IG51bWJlcltdfSBhY3R1YWwgICAgICAgIFRoZSBhY3R1YWwgc2l6ZVxuICogQHBhcmFtIHtudW1iZXIgfCBudW1iZXJbXX0gZXhwZWN0ZWQgICAgICBUaGUgZXhwZWN0ZWQgc2l6ZVxuICogQHBhcmFtIHtzdHJpbmd9IFtyZWxhdGlvbj0nIT0nXSAgICAgICAgICBPcHRpb25hbCByZWxhdGlvbiBiZXR3ZWVuIGFjdHVhbFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgZXhwZWN0ZWQgc2l6ZTogJyE9JywgJzwnLCBldGMuXG4gKiBAZXh0ZW5kcyBSYW5nZUVycm9yXG4gKi9cbmZ1bmN0aW9uIERpbWVuc2lvbkVycm9yKGFjdHVhbCwgZXhwZWN0ZWQsIHJlbGF0aW9uKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEaW1lbnNpb25FcnJvcikpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0NvbnN0cnVjdG9yIG11c3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBvcGVyYXRvcicpO1xuICB9XG5cbiAgdGhpcy5hY3R1YWwgICA9IGFjdHVhbDtcbiAgdGhpcy5leHBlY3RlZCA9IGV4cGVjdGVkO1xuICB0aGlzLnJlbGF0aW9uID0gcmVsYXRpb247XG5cbiAgdGhpcy5tZXNzYWdlID0gJ0RpbWVuc2lvbiBtaXNtYXRjaCAoJyArXG4gICAgICAoQXJyYXkuaXNBcnJheShhY3R1YWwpID8gKCdbJyArIGFjdHVhbC5qb2luKCcsICcpICsgJ10nKSA6IGFjdHVhbCkgK1xuICAgICAgJyAnICsgKHRoaXMucmVsYXRpb24gfHwgJyE9JykgKyAnICcgK1xuICAgICAgKEFycmF5LmlzQXJyYXkoZXhwZWN0ZWQpID8gKCdbJyArIGV4cGVjdGVkLmpvaW4oJywgJykgKyAnXScpIDogZXhwZWN0ZWQpICtcbiAgICAgICcpJztcblxuICB0aGlzLnN0YWNrID0gKG5ldyBFcnJvcigpKS5zdGFjaztcbn1cblxuRGltZW5zaW9uRXJyb3IucHJvdG90eXBlID0gbmV3IFJhbmdlRXJyb3IoKTtcbkRpbWVuc2lvbkVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJhbmdlRXJyb3I7XG5EaW1lbnNpb25FcnJvci5wcm90b3R5cGUubmFtZSA9ICdEaW1lbnNpb25FcnJvcic7XG5EaW1lbnNpb25FcnJvci5wcm90b3R5cGUuaXNEaW1lbnNpb25FcnJvciA9IHRydWU7XG5cbm1vZHVsZS5leHBvcnRzID0gRGltZW5zaW9uRXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlIGEgcmFuZ2UgZXJyb3Igd2l0aCB0aGUgbWVzc2FnZTpcbiAqICAgICAnSW5kZXggb3V0IG9mIHJhbmdlIChpbmRleCA8IG1pbiknXG4gKiAgICAgJ0luZGV4IG91dCBvZiByYW5nZSAoaW5kZXggPCBtYXgpJ1xuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAgICAgVGhlIGFjdHVhbCBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IFttaW49MF0gICBNaW5pbXVtIGluZGV4IChpbmNsdWRlZClcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4XSAgICAgTWF4aW11bSBpbmRleCAoZXhjbHVkZWQpXG4gKiBAZXh0ZW5kcyBSYW5nZUVycm9yXG4gKi9cbmZ1bmN0aW9uIEluZGV4RXJyb3IoaW5kZXgsIG1pbiwgbWF4KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBJbmRleEVycm9yKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQ29uc3RydWN0b3IgbXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgbmV3IG9wZXJhdG9yJyk7XG4gIH1cblxuICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgIHRoaXMubWluID0gMDtcbiAgICB0aGlzLm1heCA9IG1pbjtcbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICB0aGlzLm1heCA9IG1heDtcbiAgfVxuXG4gIGlmICh0aGlzLm1pbiAhPT0gdW5kZWZpbmVkICYmIHRoaXMuaW5kZXggPCB0aGlzLm1pbikge1xuICAgIHRoaXMubWVzc2FnZSA9ICdJbmRleCBvdXQgb2YgcmFuZ2UgKCcgKyB0aGlzLmluZGV4ICsgJyA8ICcgKyB0aGlzLm1pbiArICcpJztcbiAgfVxuICBlbHNlIGlmICh0aGlzLm1heCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuaW5kZXggPj0gdGhpcy5tYXgpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSAnSW5kZXggb3V0IG9mIHJhbmdlICgnICsgdGhpcy5pbmRleCArICcgPiAnICsgKHRoaXMubWF4IC0gMSkgKyAnKSc7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy5tZXNzYWdlID0gJ0luZGV4IG91dCBvZiByYW5nZSAoJyArIHRoaXMuaW5kZXggKyAnKSc7XG4gIH1cblxuICB0aGlzLnN0YWNrID0gKG5ldyBFcnJvcigpKS5zdGFjaztcbn1cblxuSW5kZXhFcnJvci5wcm90b3R5cGUgPSBuZXcgUmFuZ2VFcnJvcigpO1xuSW5kZXhFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSYW5nZUVycm9yO1xuSW5kZXhFcnJvci5wcm90b3R5cGUubmFtZSA9ICdJbmRleEVycm9yJztcbkluZGV4RXJyb3IucHJvdG90eXBlLmlzSW5kZXhFcnJvciA9IHRydWU7XG5cbm1vZHVsZS5leHBvcnRzID0gSW5kZXhFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEFyZ3VtZW50c0Vycm9yID0gcmVxdWlyZSgnLi9Bcmd1bWVudHNFcnJvcicpO1xudmFyIERpbWVuc2lvbkVycm9yID0gcmVxdWlyZSgnLi9EaW1lbnNpb25FcnJvcicpO1xudmFyIEluZGV4RXJyb3IgPSByZXF1aXJlKCcuL0luZGV4RXJyb3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBbXG4gIHtcbiAgICBuYW1lOiAnQXJndW1lbnRzRXJyb3InLCBwYXRoOiAnZXJyb3InLFxuICAgIGZhY3Rvcnk6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBBcmd1bWVudHNFcnJvcjtcbiAgICB9XG4gIH0sXG4gIHtcbiAgICBuYW1lOiAnRGltZW5zaW9uRXJyb3InLFxuICAgIHBhdGg6ICdlcnJvcicsXG4gICAgZmFjdG9yeTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIERpbWVuc2lvbkVycm9yO1xuICAgIH1cbiAgfSxcbiAge1xuICAgIG5hbWU6ICdJbmRleEVycm9yJyxcbiAgICBwYXRoOiAnZXJyb3InLFxuICAgIGZhY3Rvcnk6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBJbmRleEVycm9yO1xuICAgIH1cbiAgfVxuXTtcblxuLy8gVE9ETzogaW1wbGVtZW50IGFuIEludmFsaWRWYWx1ZUVycm9yP1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgb2JqZWN0ID0gcmVxdWlyZSgnLi4vdXRpbHMvb2JqZWN0Jyk7XG52YXIgc3RyaW5nID0gcmVxdWlyZSgnLi4vdXRpbHMvc3RyaW5nJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIHBhcnNlciA9IGxvYWQocmVxdWlyZSgnLi9mdW5jdGlvbi9wYXJzZXInKSkoKTtcblxuICAvKipcbiAgICogRG9jdW1lbnRhdGlvbiBvYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IGRvYyAgT2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllczpcbiAgICogICAgICAgICAgICAgICAgICAgICAge3N0cmluZ30gbmFtZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nfSBjYXRlZ29yeVxuICAgKiAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nfSBkZXNjcmlwdGlvblxuICAgKiAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nW119IHN5bnRheFxuICAgKiAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nW119IGV4YW1wbGVzXG4gICAqICAgICAgICAgICAgICAgICAgICAgIHtzdHJpbmdbXX0gc2VlYWxzb1xuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIEhlbHAoZG9jKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEhlbHApKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0NvbnN0cnVjdG9yIG11c3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBvcGVyYXRvcicpO1xuICAgIH1cblxuICAgIGlmICghZG9jKSAgdGhyb3cgbmV3IEVycm9yKCdBcmd1bWVudCBcImRvY1wiIG1pc3NpbmcnKTtcblxuICAgIHRoaXMuZG9jID0gZG9jO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGFjaCB0eXBlIGluZm9ybWF0aW9uXG4gICAqL1xuICBIZWxwLnByb3RvdHlwZS50eXBlID0gJ0hlbHAnO1xuICBIZWxwLnByb3RvdHlwZS5pc0hlbHAgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgSGVscCBvYmplY3RcbiAgICogQHJldHVybiB7c3RyaW5nfSBSZXR1cm5zIGEgc3RyaW5nXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBIZWxwLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZG9jID0gdGhpcy5kb2MgfHwge307XG4gICAgdmFyIGRlc2MgPSAnXFxuJztcblxuICAgIGlmIChkb2MubmFtZSkge1xuICAgICAgZGVzYyArPSAnTmFtZTogJyArIGRvYy5uYW1lICsgJ1xcblxcbic7XG4gICAgfVxuICAgIGlmIChkb2MuY2F0ZWdvcnkpIHtcbiAgICAgIGRlc2MgKz0gJ0NhdGVnb3J5OiAnICsgZG9jLmNhdGVnb3J5ICsgJ1xcblxcbic7XG4gICAgfVxuICAgIGlmIChkb2MuZGVzY3JpcHRpb24pIHtcbiAgICAgIGRlc2MgKz0gJ0Rlc2NyaXB0aW9uOlxcbiAgICAnICsgZG9jLmRlc2NyaXB0aW9uICsgJ1xcblxcbic7XG4gICAgfVxuICAgIGlmIChkb2Muc3ludGF4KSB7XG4gICAgICBkZXNjICs9ICdTeW50YXg6XFxuICAgICcgKyBkb2Muc3ludGF4LmpvaW4oJ1xcbiAgICAnKSArICdcXG5cXG4nO1xuICAgIH1cbiAgICBpZiAoZG9jLmV4YW1wbGVzKSB7XG4gICAgICBkZXNjICs9ICdFeGFtcGxlczpcXG4nO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2MuZXhhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGV4cHIgPSBkb2MuZXhhbXBsZXNbaV07XG4gICAgICAgIGRlc2MgKz0gJyAgICAnICsgZXhwciArICdcXG4nO1xuXG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzID0gcGFyc2VyLmV2YWwoZXhwcik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXMgPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXMgJiYgIXJlcy5pc0hlbHApIHtcbiAgICAgICAgICBkZXNjICs9ICcgICAgICAgICcgKyBzdHJpbmcuZm9ybWF0KHJlcywge3ByZWNpc2lvbjogMTR9KSArICdcXG4nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkZXNjICs9ICdcXG4nO1xuICAgIH1cbiAgICBpZiAoZG9jLnNlZWFsc28pIHtcbiAgICAgIGRlc2MgKz0gJ1NlZSBhbHNvOiAnICsgZG9jLnNlZWFsc28uam9pbignLCAnKSArICdcXG4nO1xuICAgIH1cblxuICAgIHJldHVybiBkZXNjO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFeHBvcnQgdGhlIGhlbHAgb2JqZWN0IHRvIEpTT05cbiAgICovXG4gIEhlbHAucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0gb2JqZWN0LmNsb25lKHRoaXMuZG9jKTtcbiAgICBvYmoubWF0aGpzID0gJ0hlbHAnO1xuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluc3RhbnRpYXRlIGEgSGVscCBvYmplY3QgZnJvbSBhIEpTT04gb2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBqc29uXG4gICAqIEByZXR1cm5zIHtIZWxwfSBSZXR1cm5zIGEgbmV3IEhlbHAgb2JqZWN0XG4gICAqL1xuICBIZWxwLmZyb21KU09OID0gZnVuY3Rpb24gKGpzb24pIHtcbiAgICB2YXIgZG9jID0ge307XG4gICAgZm9yICh2YXIgcHJvcCBpbiBqc29uKSB7XG4gICAgICBpZiAocHJvcCAhPT0gJ21hdGhqcycpIHsgLy8gaWdub3JlIG1hdGhqcyBmaWVsZFxuICAgICAgICBkb2NbcHJvcF0gPSBqc29uW3Byb3BdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IEhlbHAoZG9jKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgSGVscCBvYmplY3RcbiAgICovXG4gIEhlbHAucHJvdG90eXBlLnZhbHVlT2YgPSBIZWxwLnByb3RvdHlwZS50b1N0cmluZztcblxuICByZXR1cm4gSGVscDtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ0hlbHAnO1xuZXhwb3J0cy5wYXRoID0gJ3R5cGUnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCwgbWF0aCkge1xuICB2YXIgX3BhcnNlID0gbG9hZChyZXF1aXJlKCcuL3BhcnNlJykpO1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3IgUGFyc2VyXG4gICAqIFBhcnNlciBjb250YWlucyBtZXRob2RzIHRvIGV2YWx1YXRlIG9yIHBhcnNlIGV4cHJlc3Npb25zLCBhbmQgaGFzIGEgbnVtYmVyXG4gICAqIG9mIGNvbnZlbmllbmNlIG1ldGhvZHMgdG8gZ2V0LCBzZXQsIGFuZCByZW1vdmUgdmFyaWFibGVzIGZyb20gbWVtb3J5LiBQYXJzZXJcbiAgICoga2VlcHMgYSBzY29wZSBjb250YWluaW5nIHZhcmlhYmxlcyBpbiBtZW1vcnksIHdoaWNoIGlzIHVzZWQgZm9yIGFsbFxuICAgKiBldmFsdWF0aW9ucy5cbiAgICpcbiAgICogTWV0aG9kczpcbiAgICogICAgdmFyIHJlc3VsdCA9IHBhcnNlci5ldmFsKGV4cHIpOyAgICAvLyBldmFsdWF0ZSBhbiBleHByZXNzaW9uXG4gICAqICAgIHZhciB2YWx1ZSA9IHBhcnNlci5nZXQobmFtZSk7ICAgICAgLy8gcmV0cmlldmUgYSB2YXJpYWJsZSBmcm9tIHRoZSBwYXJzZXJcbiAgICogICAgcGFyc2VyLnNldChuYW1lLCB2YWx1ZSk7ICAgICAgICAgICAvLyBzZXQgYSB2YXJpYWJsZSBpbiB0aGUgcGFyc2VyXG4gICAqICAgIHBhcnNlci5yZW1vdmUobmFtZSk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgYSB2YXJpYWJsZSBmcm9tIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBhcnNlcnMgc2NvcGVcbiAgICogICAgcGFyc2VyLmNsZWFyKCk7ICAgICAgICAgICAgICAgICAgICAvLyBjbGVhciB0aGUgcGFyc2VycyBzY29wZVxuICAgKlxuICAgKiBFeGFtcGxlIHVzYWdlOlxuICAgKiAgICB2YXIgcGFyc2VyID0gbmV3IFBhcnNlcigpO1xuICAgKiAgICAvLyBOb3RlOiB0aGVyZSBpcyBhIGNvbnZlbmllbmNlIG1ldGhvZCB3aGljaCBjYW4gYmUgdXNlZCBpbnN0ZWFkOlxuICAgKiAgICAvLyB2YXIgcGFyc2VyID0gbmV3IG1hdGgucGFyc2VyKCk7XG4gICAqXG4gICAqICAgIC8vIGV2YWx1YXRlIGV4cHJlc3Npb25zXG4gICAqICAgIHBhcnNlci5ldmFsKCdzcXJ0KDNeMiArIDReMiknKTsgICAgICAgICAvLyA1XG4gICAqICAgIHBhcnNlci5ldmFsKCdzcXJ0KC00KScpOyAgICAgICAgICAgICAgICAvLyAyaVxuICAgKiAgICBwYXJzZXIuZXZhbCgnMiBpbmNoIGluIGNtJyk7ICAgICAgICAgICAgLy8gNS4wOCBjbVxuICAgKiAgICBwYXJzZXIuZXZhbCgnY29zKDQ1IGRlZyknKTsgICAgICAgICAgICAgLy8gMC43MDcxMDY3ODExODY1NDc2XG4gICAqXG4gICAqICAgIC8vIGRlZmluZSB2YXJpYWJsZXMgYW5kIGZ1bmN0aW9uc1xuICAgKiAgICBwYXJzZXIuZXZhbCgneCA9IDcgLyAyJyk7ICAgICAgICAgICAgICAgLy8gMy41XG4gICAqICAgIHBhcnNlci5ldmFsKCd4ICsgMycpOyAgICAgICAgICAgICAgICAgICAvLyA2LjVcbiAgICogICAgcGFyc2VyLmV2YWwoJ2Z1bmN0aW9uIGYoeCwgeSkgPSB4XnknKTsgIC8vIGYoeCwgeSlcbiAgICogICAgcGFyc2VyLmV2YWwoJ2YoMiwgMyknKTsgICAgICAgICAgICAgICAgIC8vIDhcbiAgICpcbiAgICogICAgLy8gZ2V0IGFuZCBzZXQgdmFyaWFibGVzIGFuZCBmdW5jdGlvbnNcbiAgICogICAgdmFyIHggPSBwYXJzZXIuZ2V0KCd4Jyk7ICAgICAgICAgICAgICAgIC8vIDdcbiAgICogICAgdmFyIGYgPSBwYXJzZXIuZ2V0KCdmJyk7ICAgICAgICAgICAgICAgIC8vIGZ1bmN0aW9uXG4gICAqICAgIHZhciBnID0gZigzLCAyKTsgICAgICAgICAgICAgICAgICAgICAgICAvLyA5XG4gICAqICAgIHBhcnNlci5zZXQoJ2gnLCA1MDApO1xuICAgKiAgICB2YXIgaSA9IHBhcnNlci5ldmFsKCdoIC8gMicpOyAgICAgICAgICAgLy8gMjUwXG4gICAqICAgIHBhcnNlci5zZXQoJ2hlbGxvJywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICogICAgICAgIHJldHVybiAnaGVsbG8sICcgKyBuYW1lICsgJyEnO1xuICAgKiAgICB9KTtcbiAgICogICAgcGFyc2VyLmV2YWwoJ2hlbGxvKFwidXNlclwiKScpOyAgICAgICAgICAgLy8gXCJoZWxsbywgdXNlciFcIlxuICAgKlxuICAgKiAgICAvLyBjbGVhciBkZWZpbmVkIGZ1bmN0aW9ucyBhbmQgdmFyaWFibGVzXG4gICAqICAgIHBhcnNlci5jbGVhcigpO1xuICAgKlxuICAgKi9cbiAgZnVuY3Rpb24gUGFyc2VyKCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXJzZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICAgICAgJ0NvbnN0cnVjdG9yIG11c3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBvcGVyYXRvcicpO1xuICAgIH1cbiAgICB0aGlzLnNjb3BlID0ge307XG4gIH1cblxuICAvKipcbiAgICogQXR0YWNoIHR5cGUgaW5mb3JtYXRpb25cbiAgICovXG4gIFBhcnNlci5wcm90b3R5cGUudHlwZSA9ICdQYXJzZXInO1xuICBQYXJzZXIucHJvdG90eXBlLmlzUGFyc2VyID0gdHJ1ZTtcblxuICAvKipcbiAgICogUGFyc2UgYW4gZXhwcmVzc2lvbiBhbmQgcmV0dXJuIHRoZSBwYXJzZWQgZnVuY3Rpb24gbm9kZS5cbiAgICogVGhlIG5vZGUgdHJlZSBjYW4gYmUgY29tcGlsZWQgdmlhIGBjb2RlID0gbm9kZS5jb21waWxlKG1hdGgpYCxcbiAgICogYW5kIHRoZSBjb21waWxlZCBjb2RlIGNhbiBiZSBleGVjdXRlZCBhcyBgY29kZS5ldmFsKFtzY29wZV0pYFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwclxuICAgKiBAcmV0dXJuIHtOb2RlfSBub2RlXG4gICAqIEB0aHJvd3Mge0Vycm9yfVxuICAgKi9cbiAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChleHByKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYXJzZXIucGFyc2UgaXMgZGVwcmVjYXRlZC4gVXNlIG1hdGgucGFyc2UgaW5zdGVhZC4nKTtcbiAgfTtcblxuICAvKipcbiAgICogUGFyc2UgYW5kIGNvbXBpbGUgYW4gZXhwcmVzc2lvbiwgcmV0dXJuIHRoZSBjb21waWxlZCBqYXZhc2NyaXB0IGNvZGUuXG4gICAqIFRoZSBub2RlIGNhbiBiZSBldmFsdWF0ZWQgdmlhIGNvZGUuZXZhbChbc2NvcGVdKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwclxuICAgKiBAcmV0dXJuIHt7ZXZhbDogZnVuY3Rpb259fSBjb2RlXG4gICAqIEB0aHJvd3Mge0Vycm9yfVxuICAgKi9cbiAgUGFyc2VyLnByb3RvdHlwZS5jb21waWxlID0gZnVuY3Rpb24gKGV4cHIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcnNlci5jb21waWxlIGlzIGRlcHJlY2F0ZWQuIFVzZSBtYXRoLmNvbXBpbGUgaW5zdGVhZC4nKTtcbiAgfTtcblxuICAvKipcbiAgICogUGFyc2UgYW5kIGV2YWx1YXRlIHRoZSBnaXZlbiBleHByZXNzaW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBleHByICAgQSBzdHJpbmcgY29udGFpbmluZyBhbiBleHByZXNzaW9uLCBmb3IgZXhhbXBsZSBcIjIrM1wiXG4gICAqIEByZXR1cm4geyp9IHJlc3VsdCAgICAgVGhlIHJlc3VsdCwgb3IgdW5kZWZpbmVkIHdoZW4gdGhlIGV4cHJlc3Npb24gd2FzIGVtcHR5XG4gICAqIEB0aHJvd3Mge0Vycm9yfVxuICAgKi9cbiAgUGFyc2VyLnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24gKGV4cHIpIHtcbiAgICAvLyBUT0RPOiB2YWxpZGF0ZSBhcmd1bWVudHNcbiAgICByZXR1cm4gX3BhcnNlKGV4cHIpXG4gICAgICAgIC5jb21waWxlKClcbiAgICAgICAgLmV2YWwodGhpcy5zY29wZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhIHZhcmlhYmxlIChhIGZ1bmN0aW9uIG9yIHZhcmlhYmxlKSBieSBuYW1lIGZyb20gdGhlIHBhcnNlcnMgc2NvcGUuXG4gICAqIFJldHVybnMgdW5kZWZpbmVkIHdoZW4gbm90IGZvdW5kXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEByZXR1cm4geyogfCB1bmRlZmluZWR9IHZhbHVlXG4gICAqL1xuICBQYXJzZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgLy8gVE9ETzogdmFsaWRhdGUgYXJndW1lbnRzXG4gICAgcmV0dXJuIHRoaXMuc2NvcGVbbmFtZV07XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBhIHN5bWJvbCAoYSBmdW5jdGlvbiBvciB2YXJpYWJsZSkgYnkgbmFtZSBmcm9tIHRoZSBwYXJzZXJzIHNjb3BlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyogfCB1bmRlZmluZWR9IHZhbHVlXG4gICAqL1xuICBQYXJzZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIC8vIFRPRE86IHZhbGlkYXRlIGFyZ3VtZW50c1xuICAgIHJldHVybiB0aGlzLnNjb3BlW25hbWVdID0gdmFsdWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIHZhcmlhYmxlIGZyb20gdGhlIHBhcnNlcnMgc2NvcGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG4gIFBhcnNlci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAvLyBUT0RPOiB2YWxpZGF0ZSBhcmd1bWVudHNcbiAgICBkZWxldGUgdGhpcy5zY29wZVtuYW1lXTtcbiAgfTtcblxuICAvKipcbiAgICogQ2xlYXIgdGhlIHNjb3BlIHdpdGggdmFyaWFibGVzIGFuZCBmdW5jdGlvbnNcbiAgICovXG4gIFBhcnNlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLnNjb3BlKSB7XG4gICAgICBpZiAodGhpcy5zY29wZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICBkZWxldGUgdGhpcy5zY29wZVtuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFBhcnNlcjtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ1BhcnNlcic7XG5leHBvcnRzLnBhdGggPSAnZXhwcmVzc2lvbic7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuZXhwb3J0cy5tYXRoID0gdHJ1ZTsgLy8gcmVxdWlyZXMgdGhlIG1hdGggbmFtZXNwYWNlIGFzIDV0aCBhcmd1bWVudFxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ0luZmluaXR5JyxcbiAgJ2NhdGVnb3J5JzogJ0NvbnN0YW50cycsXG4gICdzeW50YXgnOiBbXG4gICAgJ0luZmluaXR5J1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnSW5maW5pdHksIGEgbnVtYmVyIHdoaWNoIGlzIGxhcmdlciB0aGFuIHRoZSBtYXhpbXVtIG51bWJlciB0aGF0IGNhbiBiZSBoYW5kbGVkIGJ5IGEgZmxvYXRpbmcgcG9pbnQgbnVtYmVyLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnSW5maW5pdHknLFxuICAgICcxIC8gMCdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdMTjEwJyxcbiAgJ2NhdGVnb3J5JzogJ0NvbnN0YW50cycsXG4gICdzeW50YXgnOiBbXG4gICAgJ0xOMTAnXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdSZXR1cm5zIHRoZSBuYXR1cmFsIGxvZ2FyaXRobSBvZiAxMCwgYXBwcm94aW1hdGVseSBlcXVhbCB0byAyLjMwMicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnTE4xMCcsXG4gICAgJ2xvZygxMCknXG4gIF0sXG4gICdzZWVhbHNvJzogW11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnTE4yJyxcbiAgJ2NhdGVnb3J5JzogJ0NvbnN0YW50cycsXG4gICdzeW50YXgnOiBbXG4gICAgJ0xOMidcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ1JldHVybnMgdGhlIG5hdHVyYWwgbG9nYXJpdGhtIG9mIDIsIGFwcHJveGltYXRlbHkgZXF1YWwgdG8gMC42OTMnLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ0xOMicsXG4gICAgJ2xvZygyKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdMT0cxMEUnLFxuICAnY2F0ZWdvcnknOiAnQ29uc3RhbnRzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnTE9HMTBFJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnUmV0dXJucyB0aGUgYmFzZS0xMCBsb2dhcml0aG0gb2YgRSwgYXBwcm94aW1hdGVseSBlcXVhbCB0byAwLjQzNCcsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnTE9HMTBFJyxcbiAgICAnbG9nKGUsIDEwKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdMT0cyRScsXG4gICdjYXRlZ29yeSc6ICdDb25zdGFudHMnLFxuICAnc3ludGF4JzogW1xuICAgICdMT0cyRSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ1JldHVybnMgdGhlIGJhc2UtMiBsb2dhcml0aG0gb2YgRSwgYXBwcm94aW1hdGVseSBlcXVhbCB0byAxLjQ0MicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnTE9HMkUnLFxuICAgICdsb2coZSwgMiknXG4gIF0sXG4gICdzZWVhbHNvJzogW11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnTmFOJyxcbiAgJ2NhdGVnb3J5JzogJ0NvbnN0YW50cycsXG4gICdzeW50YXgnOiBbXG4gICAgJ05hTidcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ05vdCBhIG51bWJlcicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnTmFOJyxcbiAgICAnMCAvIDAnXG4gIF0sXG4gICdzZWVhbHNvJzogW11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnU1FSVDFfMicsXG4gICdjYXRlZ29yeSc6ICdDb25zdGFudHMnLFxuICAnc3ludGF4JzogW1xuICAgICdTUVJUMV8yJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnUmV0dXJucyB0aGUgc3F1YXJlIHJvb3Qgb2YgMS8yLCBhcHByb3hpbWF0ZWx5IGVxdWFsIHRvIDAuNzA3JyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdTUVJUMV8yJyxcbiAgICAnc3FydCgxLzIpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ1NRUlQyJyxcbiAgJ2NhdGVnb3J5JzogJ0NvbnN0YW50cycsXG4gICdzeW50YXgnOiBbXG4gICAgJ1NRUlQyJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnUmV0dXJucyB0aGUgc3F1YXJlIHJvb3Qgb2YgMiwgYXBwcm94aW1hdGVseSBlcXVhbCB0byAxLjQxNCcsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnU1FSVDInLFxuICAgICdzcXJ0KDIpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2UnLFxuICAnY2F0ZWdvcnknOiAnQ29uc3RhbnRzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnZSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0V1bGVyXFwncyBudW1iZXIsIHRoZSBiYXNlIG9mIHRoZSBuYXR1cmFsIGxvZ2FyaXRobS4gQXBwcm94aW1hdGVseSBlcXVhbCB0byAyLjcxODI4JyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdlJyxcbiAgICAnZSBeIDInLFxuICAgICdleHAoMiknLFxuICAgICdsb2coZSknXG4gIF0sXG4gICdzZWVhbHNvJzogWydleHAnXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdmYWxzZScsXG4gICdjYXRlZ29yeSc6ICdDb25zdGFudHMnLFxuICAnc3ludGF4JzogW1xuICAgICdmYWxzZSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0Jvb2xlYW4gdmFsdWUgZmFsc2UnLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2ZhbHNlJ1xuICBdLFxuICAnc2VlYWxzbyc6IFsndHJ1ZSddXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2knLFxuICAnY2F0ZWdvcnknOiAnQ29uc3RhbnRzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnaSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0ltYWdpbmFyeSB1bml0LCBkZWZpbmVkIGFzIGkqaT0tMS4gQSBjb21wbGV4IG51bWJlciBpcyBkZXNjcmliZWQgYXMgYSArIGIqaSwgd2hlcmUgYSBpcyB0aGUgcmVhbCBwYXJ0LCBhbmQgYiBpcyB0aGUgaW1hZ2luYXJ5IHBhcnQuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdpJyxcbiAgICAnaSAqIGknLFxuICAgICdzcXJ0KC0xKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdudWxsJyxcbiAgJ2NhdGVnb3J5JzogJ0NvbnN0YW50cycsXG4gICdzeW50YXgnOiBbXG4gICAgJ251bGwnXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdWYWx1ZSBudWxsJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdudWxsJ1xuICBdLFxuICAnc2VlYWxzbyc6IFsndHJ1ZScsICdmYWxzZSddXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3BoaScsXG4gICdjYXRlZ29yeSc6ICdDb25zdGFudHMnLFxuICAnc3ludGF4JzogW1xuICAgICdwaGknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdQaGkgaXMgdGhlIGdvbGRlbiByYXRpby4gVHdvIHF1YW50aXRpZXMgYXJlIGluIHRoZSBnb2xkZW4gcmF0aW8gaWYgdGhlaXIgcmF0aW8gaXMgdGhlIHNhbWUgYXMgdGhlIHJhdGlvIG9mIHRoZWlyIHN1bSB0byB0aGUgbGFyZ2VyIG9mIHRoZSB0d28gcXVhbnRpdGllcy4gUGhpIGlzIGRlZmluZWQgYXMgYCgxICsgc3FydCg1KSkgLyAyYCBhbmQgaXMgYXBwcm94aW1hdGVseSAxLjYxODAzNC4uLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAndGF1J1xuICBdLFxuICAnc2VlYWxzbyc6IFtdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3BpJyxcbiAgJ2NhdGVnb3J5JzogJ0NvbnN0YW50cycsXG4gICdzeW50YXgnOiBbXG4gICAgJ3BpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnVGhlIG51bWJlciBwaSBpcyBhIG1hdGhlbWF0aWNhbCBjb25zdGFudCB0aGF0IGlzIHRoZSByYXRpbyBvZiBhIGNpcmNsZVxcJ3MgY2lyY3VtZmVyZW5jZSB0byBpdHMgZGlhbWV0ZXIsIGFuZCBpcyBhcHByb3hpbWF0ZWx5IGVxdWFsIHRvIDMuMTQxNTknLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ3BpJyxcbiAgICAnc2luKHBpLzIpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFsndGF1J11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAndGF1JyxcbiAgJ2NhdGVnb3J5JzogJ0NvbnN0YW50cycsXG4gICdzeW50YXgnOiBbXG4gICAgJ3RhdSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ1RhdSBpcyB0aGUgcmF0aW8gY29uc3RhbnQgb2YgYSBjaXJjbGVcXCdzIGNpcmN1bWZlcmVuY2UgdG8gcmFkaXVzLCBlcXVhbCB0byAyICogcGksIGFwcHJveGltYXRlbHkgNi4yODMyLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAndGF1JyxcbiAgICAnMiAqIHBpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFsncGknXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICd0cnVlJyxcbiAgJ2NhdGVnb3J5JzogJ0NvbnN0YW50cycsXG4gICdzeW50YXgnOiBbXG4gICAgJ3RydWUnXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdCb29sZWFuIHZhbHVlIHRydWUnLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ3RydWUnXG4gIF0sXG4gICdzZWVhbHNvJzogWydmYWxzZSddXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3ZlcnNpb24nLFxuICAnY2F0ZWdvcnknOiAnQ29uc3RhbnRzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAndmVyc2lvbidcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0Egc3RyaW5nIHdpdGggdGhlIHZlcnNpb24gbnVtYmVyIG9mIG1hdGguanMnLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ3ZlcnNpb24nXG4gIF0sXG4gICdzZWVhbHNvJzogW11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnYmlnbnVtYmVyJyxcbiAgJ2NhdGVnb3J5JzogJ0NvbnN0cnVjdGlvbicsXG4gICdzeW50YXgnOiBbXG4gICAgJ2JpZ251bWJlcih4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzpcbiAgICAgICdDcmVhdGUgYSBiaWcgbnVtYmVyIGZyb20gYSBudW1iZXIgb3Igc3RyaW5nLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnMC4xICsgMC4yJyxcbiAgICAnYmlnbnVtYmVyKDAuMSkgKyBiaWdudW1iZXIoMC4yKScsXG4gICAgJ2JpZ251bWJlcihcIjcuMlwiKScsXG4gICAgJ2JpZ251bWJlcihcIjcuMmU1MDBcIiknLFxuICAgICdiaWdudW1iZXIoWzAuMSwgMC4yLCAwLjNdKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2Jvb2xlYW4nLCAnY29tcGxleCcsICdmcmFjdGlvbicsICdpbmRleCcsICdtYXRyaXgnLCAnc3RyaW5nJywgJ3VuaXQnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnYm9vbGVhbicsXG4gICdjYXRlZ29yeSc6ICdDb25zdHJ1Y3Rpb24nLFxuICAnc3ludGF4JzogW1xuICAgICd4JyxcbiAgICAnYm9vbGVhbih4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzpcbiAgICAgICdDb252ZXJ0IGEgc3RyaW5nIG9yIG51bWJlciBpbnRvIGEgYm9vbGVhbi4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2Jvb2xlYW4oMCknLFxuICAgICdib29sZWFuKDEpJyxcbiAgICAnYm9vbGVhbigzKScsXG4gICAgJ2Jvb2xlYW4oXCJ0cnVlXCIpJyxcbiAgICAnYm9vbGVhbihcImZhbHNlXCIpJyxcbiAgICAnYm9vbGVhbihbMSwgMCwgMSwgMV0pJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnYmlnbnVtYmVyJywgJ2NvbXBsZXgnLCAnaW5kZXgnLCAnbWF0cml4JywgJ251bWJlcicsICdzdHJpbmcnLCAndW5pdCdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdjb21wbGV4JyxcbiAgJ2NhdGVnb3J5JzogJ0NvbnN0cnVjdGlvbicsXG4gICdzeW50YXgnOiBbXG4gICAgJ2NvbXBsZXgoKScsXG4gICAgJ2NvbXBsZXgocmUsIGltKScsXG4gICAgJ2NvbXBsZXgoc3RyaW5nKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzpcbiAgICAgICdDcmVhdGUgYSBjb21wbGV4IG51bWJlci4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2NvbXBsZXgoKScsXG4gICAgJ2NvbXBsZXgoMiwgMyknLFxuICAgICdjb21wbGV4KFwiNyAtIDJpXCIpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnYmlnbnVtYmVyJywgJ2Jvb2xlYW4nLCAnaW5kZXgnLCAnbWF0cml4JywgJ251bWJlcicsICdzdHJpbmcnLCAndW5pdCdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdmcmFjdGlvbicsXG4gICdjYXRlZ29yeSc6ICdDb25zdHJ1Y3Rpb24nLFxuICAnc3ludGF4JzogW1xuICAgICdmcmFjdGlvbihudW0pJyxcbiAgICAnZnJhY3Rpb24obnVtLGRlbiknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6XG4gICAgJ0NyZWF0ZSBhIGZyYWN0aW9uIGZyb20gYSBudW1iZXIgb3IgZnJvbSBhIG51bWVyYXRvciBhbmQgZGVub21pbmF0b3IuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdmcmFjdGlvbigwLjEyNSknLFxuICAgICdmcmFjdGlvbigxLCAzKSArIGZyYWN0aW9uKDIsIDUpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnYmlnbnVtYmVyJywgJ2Jvb2xlYW4nLCAnY29tcGxleCcsICdpbmRleCcsICdtYXRyaXgnLCAnc3RyaW5nJywgJ3VuaXQnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnaW5kZXgnLFxuICAnY2F0ZWdvcnknOiAnQ29uc3RydWN0aW9uJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnW3N0YXJ0XScsXG4gICAgJ1tzdGFydDplbmRdJyxcbiAgICAnW3N0YXJ0OnN0ZXA6ZW5kXScsXG4gICAgJ1tzdGFydDEsIHN0YXJ0IDIsIC4uLl0nLFxuICAgICdbc3RhcnQxOmVuZDEsIHN0YXJ0MjplbmQyLCAuLi5dJyxcbiAgICAnW3N0YXJ0MTpzdGVwMTplbmQxLCBzdGFydDI6c3RlcDI6ZW5kMiwgLi4uXSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzpcbiAgICAgICdDcmVhdGUgYW4gaW5kZXggdG8gZ2V0IG9yIHJlcGxhY2UgYSBzdWJzZXQgb2YgYSBtYXRyaXgnLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ1tdJyxcbiAgICAnWzEsIDIsIDNdJyxcbiAgICAnQSA9IFsxLCAyLCAzOyA0LCA1LCA2XScsXG4gICAgJ0FbMSwgOl0nLFxuICAgICdBWzEsIDJdID0gNTAnLFxuICAgICdBWzA6MiwgMDoyXSA9IG9uZXMoMiwgMiknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdiaWdudW1iZXInLCAnYm9vbGVhbicsICdjb21wbGV4JywgJ21hdHJpeCwnLCAnbnVtYmVyJywgJ3JhbmdlJywgJ3N0cmluZycsICd1bml0J1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ21hdHJpeCcsXG4gICdjYXRlZ29yeSc6ICdDb25zdHJ1Y3Rpb24nLFxuICAnc3ludGF4JzogW1xuICAgICdbXScsXG4gICAgJ1thMSwgYjEsIC4uLjsgYTIsIGIyLCAuLi5dJyxcbiAgICAnbWF0cml4KCknLFxuICAgICdtYXRyaXgoXCJkZW5zZVwiKScsXG4gICAgJ21hdHJpeChbLi4uXSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6XG4gICAgICAnQ3JlYXRlIGEgbWF0cml4LicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnW10nLFxuICAgICdbMSwgMiwgM10nLFxuICAgICdbMSwgMiwgMzsgNCwgNSwgNl0nLFxuICAgICdtYXRyaXgoKScsXG4gICAgJ21hdHJpeChbMywgNF0pJyxcbiAgICAnbWF0cml4KFszLCA0OyA1LCA2XSwgXCJzcGFyc2VcIiknLFxuICAgICdtYXRyaXgoWzMsIDQ7IDUsIDZdLCBcInNwYXJzZVwiLCBcIm51bWJlclwiKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2JpZ251bWJlcicsICdib29sZWFuJywgJ2NvbXBsZXgnLCAnaW5kZXgnLCAnbnVtYmVyJywgJ3N0cmluZycsICd1bml0JywgJ3NwYXJzZSdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdudW1iZXInLFxuICAnY2F0ZWdvcnknOiAnQ29uc3RydWN0aW9uJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAneCcsXG4gICAgJ251bWJlcih4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzpcbiAgICAgICdDcmVhdGUgYSBudW1iZXIgb3IgY29udmVydCBhIHN0cmluZyBvciBib29sZWFuIGludG8gYSBudW1iZXIuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICcyJyxcbiAgICAnMmUzJyxcbiAgICAnNC4wNScsXG4gICAgJ251bWJlcigyKScsXG4gICAgJ251bWJlcihcIjcuMlwiKScsXG4gICAgJ251bWJlcih0cnVlKScsXG4gICAgJ251bWJlcihbdHJ1ZSwgZmFsc2UsIHRydWUsIHRydWVdKScsXG4gICAgJ251bWJlcihcIjUyY21cIiwgXCJtXCIpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnYmlnbnVtYmVyJywgJ2Jvb2xlYW4nLCAnY29tcGxleCcsICdmcmFjdGlvbicsICdpbmRleCcsICdtYXRyaXgnLCAnc3RyaW5nJywgJ3VuaXQnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnc3BhcnNlJyxcbiAgJ2NhdGVnb3J5JzogJ0NvbnN0cnVjdGlvbicsXG4gICdzeW50YXgnOiBbXG4gICAgJ3NwYXJzZSgpJyxcbiAgICAnc3BhcnNlKFthMSwgYjEsIC4uLjsgYTEsIGIyLCAuLi5dKScsXG4gICAgJ3NwYXJzZShbYTEsIGIxLCAuLi47IGExLCBiMiwgLi4uXSwgXCJudW1iZXJcIiknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6XG4gICdDcmVhdGUgYSBzcGFyc2UgbWF0cml4LicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnc3BhcnNlKCknLFxuICAgICdzcGFyc2UoWzMsIDQ7IDUsIDZdKScsXG4gICAgJ3NwYXJzZShbMywgMDsgNSwgMF0sIFwibnVtYmVyXCIpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnYmlnbnVtYmVyJywgJ2Jvb2xlYW4nLCAnY29tcGxleCcsICdpbmRleCcsICdudW1iZXInLCAnc3RyaW5nJywgJ3VuaXQnLCAnbWF0cml4J1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3N0cmluZycsXG4gICdjYXRlZ29yeSc6ICdDb25zdHJ1Y3Rpb24nLFxuICAnc3ludGF4JzogW1xuICAgICdcInRleHRcIicsXG4gICAgJ3N0cmluZyh4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzpcbiAgICAgICdDcmVhdGUgYSBzdHJpbmcgb3IgY29udmVydCBhIHZhbHVlIHRvIGEgc3RyaW5nJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdcIkhlbGxvIFdvcmxkIVwiJyxcbiAgICAnc3RyaW5nKDQuMiknLFxuICAgICdzdHJpbmcoMyArIDJpKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2JpZ251bWJlcicsICdib29sZWFuJywgJ2NvbXBsZXgnLCAnaW5kZXgnLCAnbWF0cml4JywgJ251bWJlcicsICd1bml0J1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3VuaXQnLFxuICAnY2F0ZWdvcnknOiAnQ29uc3RydWN0aW9uJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAndmFsdWUgdW5pdCcsXG4gICAgJ3VuaXQodmFsdWUsIHVuaXQpJyxcbiAgICAndW5pdChzdHJpbmcpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ0NyZWF0ZSBhIHVuaXQuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICc1LjUgbW0nLFxuICAgICczIGluY2gnLFxuICAgICd1bml0KDcuMSwgXCJraWxvZ3JhbVwiKScsXG4gICAgJ3VuaXQoXCIyMyBkZWdcIiknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdiaWdudW1iZXInLCAnYm9vbGVhbicsICdjb21wbGV4JywgJ2luZGV4JywgJ21hdHJpeCcsICdudW1iZXInLCAnc3RyaW5nJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2NvbmZpZycsXG4gICdjYXRlZ29yeSc6ICdDb3JlJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnY29uZmlnKCknLFxuICAgICdjb25maWcob3B0aW9ucyknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdHZXQgY29uZmlndXJhdGlvbiBvciBjaGFuZ2UgY29uZmlndXJhdGlvbi4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2NvbmZpZygpJyxcbiAgICAnMS8zICsgMS80JyxcbiAgICAnY29uZmlnKHtudW1iZXI6IFwiRnJhY3Rpb25cIn0pJyxcbiAgICAnMS8zICsgMS80J1xuICBdLFxuICAnc2VlYWxzbyc6IFtdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2ltcG9ydCcsXG4gICdjYXRlZ29yeSc6ICdDb3JlJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnaW1wb3J0KGZ1bmN0aW9ucyknLFxuICAgICdpbXBvcnQoZnVuY3Rpb25zLCBvcHRpb25zKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0ltcG9ydCBmdW5jdGlvbnMgb3IgY29uc3RhbnRzIGZyb20gYW4gb2JqZWN0LicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnaW1wb3J0KHtteUZuOiBmKHgpPXheMiwgbXlDb25zdGFudDogMzIgfSknLFxuICAgICdteUZuKDIpJyxcbiAgICAnbXlDb25zdGFudCdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICd0eXBlZCcsXG4gICdjYXRlZ29yeSc6ICdDb3JlJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAndHlwZWQoc2lnbmF0dXJlcyknLFxuICAgICd0eXBlZChuYW1lLCBzaWduYXR1cmVzKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NyZWF0ZSBhIHR5cGVkIGZ1bmN0aW9uLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnZG91YmxlID0gdHlwZWQoeyBcIm51bWJlciwgbnVtYmVyXCI6IGYoeCk9eCt4IH0pJyxcbiAgICAnZG91YmxlKDIpJyxcbiAgICAnZG91YmxlKFwiaGVsbG9cIiknXG4gIF0sXG4gICdzZWVhbHNvJzogW11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnbHNvbHZlJyxcbiAgJ2NhdGVnb3J5JzogJ0FsZ2VicmEnLFxuICAnc3ludGF4JzogW1xuICAgICd4PWxzb2x2ZShMLCBiKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzpcbiAgJ1NvbHZlcyB0aGUgbGluZWFyIHN5c3RlbSBMICogeCA9IGIgd2hlcmUgTCBpcyBhbiBbbiB4IG5dIGxvd2VyIHRyaWFuZ3VsYXIgbWF0cml4IGFuZCBiIGlzIGEgW25dIGNvbHVtbiB2ZWN0b3IuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdhID0gWy0yLCAzOyAyLCAxXScsXG4gICAgJ2IgPSBbMTEsIDldJyxcbiAgICAneCA9IGxzb2x2ZShhLCBiKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2x1cCcsICdsdXNvbHZlJywgJ3Vzb2x2ZScsICdtYXRyaXgnLCAnc3BhcnNlJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2x1cCcsXG4gICdjYXRlZ29yeSc6ICdBbGdlYnJhJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnbHVwKG0pJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAnQ2FsY3VsYXRlIHRoZSBNYXRyaXggTFUgZGVjb21wb3NpdGlvbiB3aXRoIHBhcnRpYWwgcGl2b3RpbmcuIE1hdHJpeCBBIGlzIGRlY29tcG9zZWQgaW4gdGhyZWUgbWF0cmljZXMgKEwsIFUsIFApIHdoZXJlIFAgKiBBID0gTCAqIFUnLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2x1cChbWzIsIDFdLCBbMSwgNF1dKScsXG4gICAgJ2x1cChtYXRyaXgoW1syLCAxXSwgWzEsIDRdXSkpJyxcbiAgICAnbHVwKHNwYXJzZShbWzIsIDFdLCBbMSwgNF1dKSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdsdXNvbHZlJywgJ2xzb2x2ZScsICd1c29sdmUnLCAnbWF0cml4JywgJ3NwYXJzZScsICdzbHUnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnbHVzb2x2ZScsXG4gICdjYXRlZ29yeSc6ICdBbGdlYnJhJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAneD1sdXNvbHZlKEEsIGIpJyxcbiAgICAneD1sdXNvbHZlKGx1LCBiKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ1NvbHZlcyB0aGUgbGluZWFyIHN5c3RlbSBBICogeCA9IGIgd2hlcmUgQSBpcyBhbiBbbiB4IG5dIG1hdHJpeCBhbmQgYiBpcyBhIFtuXSBjb2x1bW4gdmVjdG9yLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnYSA9IFstMiwgMzsgMiwgMV0nLFxuICAgICdiID0gWzExLCA5XScsXG4gICAgJ3ggPSBsdXNvbHZlKGEsIGIpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnbHVwJywgJ3NsdScsICdsc29sdmUnLCAndXNvbHZlJywgJ21hdHJpeCcsICdzcGFyc2UnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnc2x1JyxcbiAgJ2NhdGVnb3J5JzogJ0FsZ2VicmEnLFxuICAnc3ludGF4JzogW1xuICAgICdzbHUoQSwgb3JkZXIsIHRocmVzaG9sZCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDYWxjdWxhdGUgdGhlIE1hdHJpeCBMVSBkZWNvbXBvc2l0aW9uIHdpdGggZnVsbCBwaXZvdGluZy4gTWF0cml4IEEgaXMgZGVjb21wb3NlZCBpbiB0d28gbWF0cmljZXMgKEwsIFUpIGFuZCB0d28gcGVybXV0YXRpb24gdmVjdG9ycyAocGludiwgcSkgd2hlcmUgUCAqIEEgKiBRID0gTCAqIFUnLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ3NsdShzcGFyc2UoWzQuNSwgMCwgMy4yLCAwOyAzLjEsIDIuOSwgMCwgMC45OyAwLCAxLjcsIDMsIDA7IDMuNSwgMC40LCAwLCAxXSksIDEsIDAuMDAxKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2x1c29sdmUnLCAnbHNvbHZlJywgJ3Vzb2x2ZScsICdtYXRyaXgnLCAnc3BhcnNlJywgJ2x1cCdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICd1c29sdmUnLFxuICAnY2F0ZWdvcnknOiAnQWxnZWJyYScsXG4gICdzeW50YXgnOiBbXG4gICAgJ3g9dXNvbHZlKFUsIGIpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAnU29sdmVzIHRoZSBsaW5lYXIgc3lzdGVtIFUgKiB4ID0gYiB3aGVyZSBVIGlzIGFuIFtuIHggbl0gdXBwZXIgdHJpYW5ndWxhciBtYXRyaXggYW5kIGIgaXMgYSBbbl0gY29sdW1uIHZlY3Rvci4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ3g9dXNvbHZlKHNwYXJzZShbMSwgMSwgMSwgMTsgMCwgMSwgMSwgMTsgMCwgMCwgMSwgMTsgMCwgMCwgMCwgMV0pLCBbMTsgMjsgMzsgNF0pJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnbHVwJywgJ2x1c29sdmUnLCAnbHNvbHZlJywgJ21hdHJpeCcsICdzcGFyc2UnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnYWJzJyxcbiAgJ2NhdGVnb3J5JzogJ0FyaXRobWV0aWMnLFxuICAnc3ludGF4JzogW1xuICAgICdhYnMoeCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDb21wdXRlIHRoZSBhYnNvbHV0ZSB2YWx1ZS4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2FicygzLjUpJyxcbiAgICAnYWJzKC00LjIpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFsnc2lnbiddXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2FkZCcsXG4gICdjYXRlZ29yeSc6ICdPcGVyYXRvcnMnLFxuICAnc3ludGF4JzogW1xuICAgICd4ICsgeScsXG4gICAgJ2FkZCh4LCB5KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0FkZCB0d28gdmFsdWVzLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnYSA9IDIuMSArIDMuNicsXG4gICAgJ2EgLSAzLjYnLFxuICAgICczICsgMmknLFxuICAgICczIGNtICsgMiBpbmNoJyxcbiAgICAnXCIyLjNcIiArIFwiNFwiJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnc3VidHJhY3QnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnY2JydCcsXG4gICdjYXRlZ29yeSc6ICdBcml0aG1ldGljJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnY2JydCh4KScsXG4gICAgJ2NicnQoeCwgYWxsUm9vdHMpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ0NvbXB1dGUgdGhlIGN1YmljIHJvb3QgdmFsdWUuIElmIHggPSB5ICogeSAqIHksIHRoZW4geSBpcyB0aGUgY3ViaWMgcm9vdCBvZiB4LiBXaGVuIGB4YCBpcyBhIG51bWJlciBvciBjb21wbGV4IG51bWJlciwgYW4gb3B0aW9uYWwgc2Vjb25kIGFyZ3VtZW50IGBhbGxSb290c2AgY2FuIGJlIHByb3ZpZGVkIHRvIHJldHVybiBhbGwgdGhyZWUgY3ViaWMgcm9vdHMuIElmIG5vdCBwcm92aWRlZCwgdGhlIHByaW5jaXBhbCByb290IGlzIHJldHVybmVkJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdjYnJ0KDY0KScsXG4gICAgJ2N1YmUoNCknLFxuICAgICdjYnJ0KC04KScsXG4gICAgJ2NicnQoMiArIDNpKScsXG4gICAgJ2NicnQoOGkpJyxcbiAgICAnY2JydCg4aSwgdHJ1ZSknLFxuICAgICdjYnJ0KDI3IG1eMyknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdzcXVhcmUnLFxuICAgICdzcXJ0JyxcbiAgICAnY3ViZScsXG4gICAgJ211bHRpcGx5J1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2NlaWwnLFxuICAnY2F0ZWdvcnknOiAnQXJpdGhtZXRpYycsXG4gICdzeW50YXgnOiBbXG4gICAgJ2NlaWwoeCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6XG4gICAgICAnUm91bmQgYSB2YWx1ZSB0b3dhcmRzIHBsdXMgaW5maW5pdHkuIElmIHggaXMgY29tcGxleCwgYm90aCByZWFsIGFuZCBpbWFnaW5hcnkgcGFydCBhcmUgcm91bmRlZCB0b3dhcmRzIHBsdXMgaW5maW5pdHkuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdjZWlsKDMuMiknLFxuICAgICdjZWlsKDMuOCknLFxuICAgICdjZWlsKC00LjIpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFsnZmxvb3InLCAnZml4JywgJ3JvdW5kJ11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnY3ViZScsXG4gICdjYXRlZ29yeSc6ICdBcml0aG1ldGljJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnY3ViZSh4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NvbXB1dGUgdGhlIGN1YmUgb2YgYSB2YWx1ZS4gVGhlIGN1YmUgb2YgeCBpcyB4ICogeCAqIHguJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdjdWJlKDIpJyxcbiAgICAnMl4zJyxcbiAgICAnMiAqIDIgKiAyJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnbXVsdGlwbHknLFxuICAgICdzcXVhcmUnLFxuICAgICdwb3cnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnZGl2aWRlJyxcbiAgJ2NhdGVnb3J5JzogJ09wZXJhdG9ycycsXG4gICdzeW50YXgnOiBbXG4gICAgJ3ggLyB5JyxcbiAgICAnZGl2aWRlKHgsIHkpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnRGl2aWRlIHR3byB2YWx1ZXMuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdhID0gMiAvIDMnLFxuICAgICdhICogMycsXG4gICAgJzQuNSAvIDInLFxuICAgICczICsgNCAvIDInLFxuICAgICcoMyArIDQpIC8gMicsXG4gICAgJzE4IGttIC8gNC41J1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnbXVsdGlwbHknXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnZG90RGl2aWRlJyxcbiAgJ2NhdGVnb3J5JzogJ09wZXJhdG9ycycsXG4gICdzeW50YXgnOiBbXG4gICAgJ3ggLi8geScsXG4gICAgJ2RvdERpdmlkZSh4LCB5KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0RpdmlkZSB0d28gdmFsdWVzIGVsZW1lbnQgd2lzZS4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2EgPSBbMSwgMiwgMzsgNCwgNSwgNl0nLFxuICAgICdiID0gWzIsIDEsIDE7IDMsIDIsIDVdJyxcbiAgICAnYSAuLyBiJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnbXVsdGlwbHknLFxuICAgICdkb3RNdWx0aXBseScsXG4gICAgJ2RpdmlkZSdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdkb3RNdWx0aXBseScsXG4gICdjYXRlZ29yeSc6ICdPcGVyYXRvcnMnLFxuICAnc3ludGF4JzogW1xuICAgICd4IC4qIHknLFxuICAgICdkb3RNdWx0aXBseSh4LCB5KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ011bHRpcGx5IHR3byB2YWx1ZXMgZWxlbWVudCB3aXNlLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnYSA9IFsxLCAyLCAzOyA0LCA1LCA2XScsXG4gICAgJ2IgPSBbMiwgMSwgMTsgMywgMiwgNV0nLFxuICAgICdhIC4qIGInXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdtdWx0aXBseScsXG4gICAgJ2RpdmlkZScsXG4gICAgJ2RvdERpdmlkZSdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdkb3Rwb3cnLFxuICAnY2F0ZWdvcnknOiAnT3BlcmF0b3JzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAneCAuXiB5JyxcbiAgICAnZG90cG93KHgsIHkpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ0NhbGN1bGF0ZXMgdGhlIHBvd2VyIG9mIHggdG8geSBlbGVtZW50IHdpc2UuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdhID0gWzEsIDIsIDM7IDQsIDUsIDZdJyxcbiAgICAnYSAuXiAyJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAncG93J1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2V4cCcsXG4gICdjYXRlZ29yeSc6ICdBcml0aG1ldGljJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnZXhwKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ2FsY3VsYXRlIHRoZSBleHBvbmVudCBvZiBhIHZhbHVlLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnZXhwKDEuMyknLFxuICAgICdlIF4gMS4zJyxcbiAgICAnbG9nKGV4cCgxLjMpKScsXG4gICAgJ3ggPSAyLjQnLFxuICAgICcoZXhwKGkqeCkgPT0gY29zKHgpICsgaSpzaW4oeCkpICAgIyBFdWxlclxcJ3MgZm9ybXVsYSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ3BvdycsXG4gICAgJ2xvZydcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdmaXgnLFxuICAnY2F0ZWdvcnknOiAnQXJpdGhtZXRpYycsXG4gICdzeW50YXgnOiBbXG4gICAgJ2ZpeCh4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzpcbiAgICAgICdSb3VuZCBhIHZhbHVlIHRvd2FyZHMgemVyby4gSWYgeCBpcyBjb21wbGV4LCBib3RoIHJlYWwgYW5kIGltYWdpbmFyeSBwYXJ0IGFyZSByb3VuZGVkIHRvd2FyZHMgemVyby4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2ZpeCgzLjIpJyxcbiAgICAnZml4KDMuOCknLFxuICAgICdmaXgoLTQuMiknLFxuICAgICdmaXgoLTQuOCknXG4gIF0sXG4gICdzZWVhbHNvJzogWydjZWlsJywgJ2Zsb29yJywgJ3JvdW5kJ11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnZmxvb3InLFxuICAnY2F0ZWdvcnknOiAnQXJpdGhtZXRpYycsXG4gICdzeW50YXgnOiBbXG4gICAgJ2Zsb29yKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ1JvdW5kIGEgdmFsdWUgdG93YXJkcyBtaW51cyBpbmZpbml0eS5JZiB4IGlzIGNvbXBsZXgsIGJvdGggcmVhbCBhbmQgaW1hZ2luYXJ5IHBhcnQgYXJlIHJvdW5kZWQgdG93YXJkcyBtaW51cyBpbmZpbml0eS4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2Zsb29yKDMuMiknLFxuICAgICdmbG9vcigzLjgpJyxcbiAgICAnZmxvb3IoLTQuMiknXG4gIF0sXG4gICdzZWVhbHNvJzogWydjZWlsJywgJ2ZpeCcsICdyb3VuZCddXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2djZCcsXG4gICdjYXRlZ29yeSc6ICdBcml0aG1ldGljJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnZ2NkKGEsIGIpJyxcbiAgICAnZ2NkKGEsIGIsIGMsIC4uLiknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDb21wdXRlIHRoZSBncmVhdGVzdCBjb21tb24gZGl2aXNvci4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2djZCg4LCAxMiknLFxuICAgICdnY2QoLTQsIDYpJyxcbiAgICAnZ2NkKDI1LCAxNSwgLTEwKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbICdsY20nLCAneGdjZCcgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdoeXBvdCcsXG4gICdjYXRlZ29yeSc6ICdBcml0aG1ldGljJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnaHlwb3QoYSwgYiwgYywgLi4uKScsXG4gICAgJ2h5cG90KFthLCBiLCBjLCAuLi5dKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NhbGN1bGF0ZSB0aGUgaHlwb3RlbnVzYSBvZiBhIGxpc3Qgd2l0aCB2YWx1ZXMuICcsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnaHlwb3QoMywgNCknLFxuICAgICdzcXJ0KDNeMiArIDReMiknLFxuICAgICdoeXBvdCgtMiknLFxuICAgICdoeXBvdChbMywgNCwgNV0pJ1xuICBdLFxuICAnc2VlYWxzbyc6IFsgJ2FicycsICdub3JtJyBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2xjbScsXG4gICdjYXRlZ29yeSc6ICdBcml0aG1ldGljJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnbGNtKHgsIHkpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ29tcHV0ZSB0aGUgbGVhc3QgY29tbW9uIG11bHRpcGxlLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnbGNtKDQsIDYpJyxcbiAgICAnbGNtKDYsIDIxKScsXG4gICAgJ2xjbSg2LCAyMSwgNSknXG4gIF0sXG4gICdzZWVhbHNvJzogWyAnZ2NkJyBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2xvZycsXG4gICdjYXRlZ29yeSc6ICdBcml0aG1ldGljJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnbG9nKHgpJyxcbiAgICAnbG9nKHgsIGJhc2UpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ29tcHV0ZSB0aGUgbG9nYXJpdGhtIG9mIGEgdmFsdWUuIElmIG5vIGJhc2UgaXMgcHJvdmlkZWQsIHRoZSBuYXR1cmFsIGxvZ2FyaXRobSBvZiB4IGlzIGNhbGN1bGF0ZWQuIElmIGJhc2UgaWYgcHJvdmlkZWQsIHRoZSBsb2dhcml0aG0gaXMgY2FsY3VsYXRlZCBmb3IgdGhlIHNwZWNpZmllZCBiYXNlLiBsb2coeCwgYmFzZSkgaXMgZGVmaW5lZCBhcyBsb2coeCkgLyBsb2coYmFzZSkuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdsb2coMy41KScsXG4gICAgJ2EgPSBsb2coMi40KScsXG4gICAgJ2V4cChhKScsXG4gICAgJzEwIF4gNCcsXG4gICAgJ2xvZygxMDAwMCwgMTApJyxcbiAgICAnbG9nKDEwMDAwKSAvIGxvZygxMCknLFxuICAgICdiID0gbG9nKDEwMjQsIDIpJyxcbiAgICAnMiBeIGInXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdleHAnLFxuICAgICdsb2cxMCdcbiAgXVxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnbG9nMTAnLFxuICAnY2F0ZWdvcnknOiAnQXJpdGhtZXRpYycsXG4gICdzeW50YXgnOiBbXG4gICAgJ2xvZzEwKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ29tcHV0ZSB0aGUgMTAtYmFzZSBsb2dhcml0aG0gb2YgYSB2YWx1ZS4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2xvZzEwKDAuMDAwMDEpJyxcbiAgICAnbG9nMTAoMTAwMDApJyxcbiAgICAnMTAgXiA0JyxcbiAgICAnbG9nKDEwMDAwKSAvIGxvZygxMCknLFxuICAgICdsb2coMTAwMDAsIDEwKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2V4cCcsXG4gICAgJ2xvZydcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdtb2QnLFxuICAnY2F0ZWdvcnknOiAnT3BlcmF0b3JzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAneCAlIHknLFxuICAgICd4IG1vZCB5JyxcbiAgICAnbW9kKHgsIHkpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ0NhbGN1bGF0ZXMgdGhlIG1vZHVsdXMsIHRoZSByZW1haW5kZXIgb2YgYW4gaW50ZWdlciBkaXZpc2lvbi4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJzcgJSAzJyxcbiAgICAnMTEgJSAyJyxcbiAgICAnMTAgbW9kIDQnLFxuICAgICdmdW5jdGlvbiBpc09kZCh4KSA9IHggJSAyJyxcbiAgICAnaXNPZGQoMiknLFxuICAgICdpc09kZCgzKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbJ2RpdmlkZSddXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ211bHRpcGx5JyxcbiAgJ2NhdGVnb3J5JzogJ09wZXJhdG9ycycsXG4gICdzeW50YXgnOiBbXG4gICAgJ3ggKiB5JyxcbiAgICAnbXVsdGlwbHkoeCwgeSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdtdWx0aXBseSB0d28gdmFsdWVzLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnYSA9IDIuMSAqIDMuNCcsXG4gICAgJ2EgLyAzLjQnLFxuICAgICcyICogMyArIDQnLFxuICAgICcyICogKDMgKyA0KScsXG4gICAgJzMgKiAyLjEga20nXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdkaXZpZGUnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnbm9ybScsXG4gICdjYXRlZ29yeSc6ICdBcml0aG1ldGljJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnbm9ybSh4KScsXG4gICAgJ25vcm0oeCwgcCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDYWxjdWxhdGUgdGhlIG5vcm0gb2YgYSBudW1iZXIsIHZlY3RvciBvciBtYXRyaXguJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdhYnMoLTMuNSknLFxuICAgICdub3JtKC0zLjUpJyxcbiAgICAnbm9ybSgzIC0gNGkpKScsXG4gICAgJ25vcm0oWzEsIDIsIC0zXSwgSW5maW5pdHkpJyxcbiAgICAnbm9ybShbMSwgMiwgLTNdLCAtSW5maW5pdHkpJyxcbiAgICAnbm9ybShbMywgNF0sIDIpJyxcbiAgICAnbm9ybShbWzEsIDJdLCBbMywgNF1dLCAxKScsXG4gICAgJ25vcm0oW1sxLCAyXSwgWzMsIDRdXSwgXFwnaW5mXFwnKScsXG4gICAgJ25vcm0oW1sxLCAyXSwgWzMsIDRdXSwgXFwnZnJvXFwnKSdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdudGhSb290JyxcbiAgJ2NhdGVnb3J5JzogJ0FyaXRobWV0aWMnLFxuICAnc3ludGF4JzogW1xuICAgICdudGhSb290KGEpJyxcbiAgICAnbnRoUm9vdChhLCByb290KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NhbGN1bGF0ZSB0aGUgbnRoIHJvb3Qgb2YgYSB2YWx1ZS4gJyArXG4gICAgICAnVGhlIHByaW5jaXBhbCBudGggcm9vdCBvZiBhIHBvc2l0aXZlIHJlYWwgbnVtYmVyIEEsICcgK1xuICAgICAgJ2lzIHRoZSBwb3NpdGl2ZSByZWFsIHNvbHV0aW9uIG9mIHRoZSBlcXVhdGlvbiBcInhecm9vdCA9IEFcIi4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJzQgXiAzJyxcbiAgICAnbnRoUm9vdCg2NCwgMyknLFxuICAgICdudGhSb290KDksIDIpJyxcbiAgICAnc3FydCg5KSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ3NxcnQnLFxuICAgICdwb3cnXG4gIF1cbn07IiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3BvdycsXG4gICdjYXRlZ29yeSc6ICdPcGVyYXRvcnMnLFxuICAnc3ludGF4JzogW1xuICAgICd4IF4geScsXG4gICAgJ3Bvdyh4LCB5KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzpcbiAgICAgICdDYWxjdWxhdGVzIHRoZSBwb3dlciBvZiB4IHRvIHksIHheeS4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJzJeMyA9IDgnLFxuICAgICcyKjIqMicsXG4gICAgJzEgKyBlIF4gKHBpICogaSknXG4gIF0sXG4gICdzZWVhbHNvJzogWyAnbXVsdGlwbHknIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAncm91bmQnLFxuICAnY2F0ZWdvcnknOiAnQXJpdGhtZXRpYycsXG4gICdzeW50YXgnOiBbXG4gICAgJ3JvdW5kKHgpJyxcbiAgICAncm91bmQoeCwgbiknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6XG4gICAgICAncm91bmQgYSB2YWx1ZSB0b3dhcmRzIHRoZSBuZWFyZXN0IGludGVnZXIuSWYgeCBpcyBjb21wbGV4LCBib3RoIHJlYWwgYW5kIGltYWdpbmFyeSBwYXJ0IGFyZSByb3VuZGVkIHRvd2FyZHMgdGhlIG5lYXJlc3QgaW50ZWdlci4gV2hlbiBuIGlzIHNwZWNpZmllZCwgdGhlIHZhbHVlIGlzIHJvdW5kZWQgdG8gbiBkZWNpbWFscy4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ3JvdW5kKDMuMiknLFxuICAgICdyb3VuZCgzLjgpJyxcbiAgICAncm91bmQoLTQuMiknLFxuICAgICdyb3VuZCgtNC44KScsXG4gICAgJ3JvdW5kKHBpLCAzKScsXG4gICAgJ3JvdW5kKDEyMy40NTY3OCwgMiknXG4gIF0sXG4gICdzZWVhbHNvJzogWydjZWlsJywgJ2Zsb29yJywgJ2ZpeCddXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3NpZ24nLFxuICAnY2F0ZWdvcnknOiAnQXJpdGhtZXRpYycsXG4gICdzeW50YXgnOiBbXG4gICAgJ3NpZ24oeCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6XG4gICAgICAnQ29tcHV0ZSB0aGUgc2lnbiBvZiBhIHZhbHVlLiBUaGUgc2lnbiBvZiBhIHZhbHVlIHggaXMgMSB3aGVuIHg+MSwgLTEgd2hlbiB4PDAsIGFuZCAwIHdoZW4geD0wLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnc2lnbigzLjUpJyxcbiAgICAnc2lnbigtNC4yKScsXG4gICAgJ3NpZ24oMCknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdhYnMnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnc3FydCcsXG4gICdjYXRlZ29yeSc6ICdBcml0aG1ldGljJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnc3FydCh4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzpcbiAgICAgICdDb21wdXRlIHRoZSBzcXVhcmUgcm9vdCB2YWx1ZS4gSWYgeCA9IHkgKiB5LCB0aGVuIHkgaXMgdGhlIHNxdWFyZSByb290IG9mIHguJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdzcXJ0KDI1KScsXG4gICAgJzUgKiA1JyxcbiAgICAnc3FydCgtMSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdzcXVhcmUnLFxuICAgICdtdWx0aXBseSdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdzcXVhcmUnLFxuICAnY2F0ZWdvcnknOiAnQXJpdGhtZXRpYycsXG4gICdzeW50YXgnOiBbXG4gICAgJ3NxdWFyZSh4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzpcbiAgICAgICdDb21wdXRlIHRoZSBzcXVhcmUgb2YgYSB2YWx1ZS4gVGhlIHNxdWFyZSBvZiB4IGlzIHggKiB4LicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnc3F1YXJlKDMpJyxcbiAgICAnc3FydCg5KScsXG4gICAgJzNeMicsXG4gICAgJzMgKiAzJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnbXVsdGlwbHknLFxuICAgICdwb3cnLFxuICAgICdzcXJ0JyxcbiAgICAnY3ViZSdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdzdWJ0cmFjdCcsXG4gICdjYXRlZ29yeSc6ICdPcGVyYXRvcnMnLFxuICAnc3ludGF4JzogW1xuICAgICd4IC0geScsXG4gICAgJ3N1YnRyYWN0KHgsIHkpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnc3VidHJhY3QgdHdvIHZhbHVlcy4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2EgPSA1LjMgLSAyJyxcbiAgICAnYSArIDInLFxuICAgICcyLzMgLSAxLzYnLFxuICAgICcyICogMyAtIDMnLFxuICAgICcyLjEga20gLSA1MDBtJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnYWRkJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3VuYXJ5TWludXMnLFxuICAnY2F0ZWdvcnknOiAnT3BlcmF0b3JzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnLXgnLFxuICAgICd1bmFyeU1pbnVzKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ0ludmVyc2UgdGhlIHNpZ24gb2YgYSB2YWx1ZS4gQ29udmVydHMgYm9vbGVhbnMgYW5kIHN0cmluZ3MgdG8gbnVtYmVycy4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJy00LjUnLFxuICAgICctKC01LjYpJyxcbiAgICAnLVwiMjJcIidcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2FkZCcsICdzdWJ0cmFjdCcsICd1bmFyeVBsdXMnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAndW5hcnlQbHVzJyxcbiAgJ2NhdGVnb3J5JzogJ09wZXJhdG9ycycsXG4gICdzeW50YXgnOiBbXG4gICAgJyt4JyxcbiAgICAndW5hcnlQbHVzKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ0NvbnZlcnRzIGJvb2xlYW5zIGFuZCBzdHJpbmdzIHRvIG51bWJlcnMuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICcrdHJ1ZScsXG4gICAgJytcIjJcIidcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2FkZCcsICdzdWJ0cmFjdCcsICd1bmFyeU1pbnVzJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3hnY2QnLFxuICAnY2F0ZWdvcnknOiAnQXJpdGhtZXRpYycsXG4gICdzeW50YXgnOiBbXG4gICAgJ3hnY2QoYSwgYiknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDYWxjdWxhdGUgdGhlIGV4dGVuZGVkIGdyZWF0ZXN0IGNvbW1vbiBkaXZpc29yIGZvciB0d28gdmFsdWVzJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICd4Z2NkKDgsIDEyKScsXG4gICAgJ2djZCg4LCAxMiknLFxuICAgICd4Z2NkKDM2MTYzLCAyMTE5OSknXG4gIF0sXG4gICdzZWVhbHNvJzogWyAnZ2NkJywgJ2xjbScgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdiaXRBbmQnLFxuICAnY2F0ZWdvcnknOiAnQml0d2lzZScsXG4gICdzeW50YXgnOiBbXG4gICAgJ3ggJiB5JyxcbiAgICAnYml0QW5kKHgsIHkpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQml0d2lzZSBBTkQgb3BlcmF0aW9uLiBQZXJmb3JtcyB0aGUgbG9naWNhbCBBTkQgb3BlcmF0aW9uIG9uIGVhY2ggcGFpciBvZiB0aGUgY29ycmVzcG9uZGluZyBiaXRzIG9mIHRoZSB0d28gZ2l2ZW4gdmFsdWVzIGJ5IG11bHRpcGx5aW5nIHRoZW0uIElmIGJvdGggYml0cyBpbiB0aGUgY29tcGFyZWQgcG9zaXRpb24gYXJlIDEsIHRoZSBiaXQgaW4gdGhlIHJlc3VsdGluZyBiaW5hcnkgcmVwcmVzZW50YXRpb24gaXMgMSwgb3RoZXJ3aXNlLCB0aGUgcmVzdWx0IGlzIDAnLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJzUgJiAzJyxcbiAgICAnYml0QW5kKDUzLCAxMzEpJyxcbiAgICAnWzEsIDEyLCAzMV0gJiA0MidcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2JpdE5vdCcsICdiaXRPcicsICdiaXRYb3InLCAnbGVmdFNoaWZ0JywgJ3JpZ2h0QXJpdGhTaGlmdCcsICdyaWdodExvZ1NoaWZ0J1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2JpdE5vdCcsXG4gICdjYXRlZ29yeSc6ICdCaXR3aXNlJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnfngnLFxuICAgICdiaXROb3QoeCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdCaXR3aXNlIE5PVCBvcGVyYXRpb24uIFBlcmZvcm1zIGEgbG9naWNhbCBuZWdhdGlvbiBvbiBlYWNoIGJpdCBvZiB0aGUgZ2l2ZW4gdmFsdWUuIEJpdHMgdGhhdCBhcmUgMCBiZWNvbWUgMSwgYW5kIHRob3NlIHRoYXQgYXJlIDEgYmVjb21lIDAuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICd+MScsXG4gICAgJ34yJyxcbiAgICAnYml0Tm90KFsyLCAtMywgNF0pJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnYml0QW5kJywgJ2JpdE9yJywgJ2JpdFhvcicsICdsZWZ0U2hpZnQnLCAncmlnaHRBcml0aFNoaWZ0JywgJ3JpZ2h0TG9nU2hpZnQnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnYml0T3InLFxuICAnY2F0ZWdvcnknOiAnQml0d2lzZScsXG4gICdzeW50YXgnOiBbXG4gICAgJ3ggfCB5JyxcbiAgICAnYml0T3IoeCwgeSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdCaXR3aXNlIE9SIG9wZXJhdGlvbi4gUGVyZm9ybXMgdGhlIGxvZ2ljYWwgaW5jbHVzaXZlIE9SIG9wZXJhdGlvbiBvbiBlYWNoIHBhaXIgb2YgY29ycmVzcG9uZGluZyBiaXRzIG9mIHRoZSB0d28gZ2l2ZW4gdmFsdWVzLiBUaGUgcmVzdWx0IGluIGVhY2ggcG9zaXRpb24gaXMgMSBpZiB0aGUgZmlyc3QgYml0IGlzIDEgb3IgdGhlIHNlY29uZCBiaXQgaXMgMSBvciBib3RoIGJpdHMgYXJlIDEsIG90aGVyd2lzZSwgdGhlIHJlc3VsdCBpcyAwLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnNSB8IDMnLFxuICAgICdiaXRPcihbMSwgMiwgM10sIDQpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnYml0QW5kJywgJ2JpdE5vdCcsICdiaXRYb3InLCAnbGVmdFNoaWZ0JywgJ3JpZ2h0QXJpdGhTaGlmdCcsICdyaWdodExvZ1NoaWZ0J1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2JpdFhvcicsXG4gICdjYXRlZ29yeSc6ICdCaXR3aXNlJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnYml0WG9yKHgsIHkpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQml0d2lzZSBYT1Igb3BlcmF0aW9uLCBleGNsdXNpdmUgT1IuIFBlcmZvcm1zIHRoZSBsb2dpY2FsIGV4Y2x1c2l2ZSBPUiBvcGVyYXRpb24gb24gZWFjaCBwYWlyIG9mIGNvcnJlc3BvbmRpbmcgYml0cyBvZiB0aGUgdHdvIGdpdmVuIHZhbHVlcy4gVGhlIHJlc3VsdCBpbiBlYWNoIHBvc2l0aW9uIGlzIDEgaWYgb25seSB0aGUgZmlyc3QgYml0IGlzIDEgb3Igb25seSB0aGUgc2Vjb25kIGJpdCBpcyAxLCBidXQgd2lsbCBiZSAwIGlmIGJvdGggYXJlIDAgb3IgYm90aCBhcmUgMS4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2JpdE9yKDEsIDIpJyxcbiAgICAnYml0WG9yKFsyLCAzLCA0XSwgNCknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdiaXRBbmQnLCAnYml0Tm90JywgJ2JpdE9yJywgJ2xlZnRTaGlmdCcsICdyaWdodEFyaXRoU2hpZnQnLCAncmlnaHRMb2dTaGlmdCdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdsZWZ0U2hpZnQnLFxuICAnY2F0ZWdvcnknOiAnQml0d2lzZScsXG4gICdzeW50YXgnOiBbXG4gICAgJ3ggPDwgeScsXG4gICAgJ2xlZnRTaGlmdCh4LCB5KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0JpdHdpc2UgbGVmdCBsb2dpY2FsIHNoaWZ0IG9mIGEgdmFsdWUgeCBieSB5IG51bWJlciBvZiBiaXRzLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnNCA8PCAxJyxcbiAgICAnOCA+PiAxJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnYml0QW5kJywgJ2JpdE5vdCcsICdiaXRPcicsICdiaXRYb3InLCAncmlnaHRBcml0aFNoaWZ0JywgJ3JpZ2h0TG9nU2hpZnQnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAncmlnaHRBcml0aFNoaWZ0JyxcbiAgJ2NhdGVnb3J5JzogJ0JpdHdpc2UnLFxuICAnc3ludGF4JzogW1xuICAgICd4ID4+IHknLFxuICAgICdsZWZ0U2hpZnQoeCwgeSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdCaXR3aXNlIHJpZ2h0IGFyaXRobWV0aWMgc2hpZnQgb2YgYSB2YWx1ZSB4IGJ5IHkgbnVtYmVyIG9mIGJpdHMuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICc4ID4+IDEnLFxuICAgICc0IDw8IDEnLFxuICAgICctMTIgPj4gMidcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2JpdEFuZCcsICdiaXROb3QnLCAnYml0T3InLCAnYml0WG9yJywgJ2xlZnRTaGlmdCcsICdyaWdodExvZ1NoaWZ0J1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3JpZ2h0TG9nU2hpZnQnLFxuICAnY2F0ZWdvcnknOiAnQml0d2lzZScsXG4gICdzeW50YXgnOiBbXG4gICAgJ3ggPj4geScsXG4gICAgJ2xlZnRTaGlmdCh4LCB5KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0JpdHdpc2UgcmlnaHQgbG9naWNhbCBzaGlmdCBvZiBhIHZhbHVlIHggYnkgeSBudW1iZXIgb2YgYml0cy4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJzggPj4+IDEnLFxuICAgICc0IDw8IDEnLFxuICAgICctMTIgPj4+IDInXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdiaXRBbmQnLCAnYml0Tm90JywgJ2JpdE9yJywgJ2JpdFhvcicsICdsZWZ0U2hpZnQnLCAncmlnaHRBcml0aFNoaWZ0J1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2JlbGxOdW1iZXJzJyxcbiAgJ2NhdGVnb3J5JzogJ0NvbWJpbmF0b3JpY3MnLFxuICAnc3ludGF4JzogW1xuICAgICdiZWxsTnVtYmVycyhuKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ1RoZSBCZWxsIE51bWJlcnMgY291bnQgdGhlIG51bWJlciBvZiBwYXJ0aXRpb25zIG9mIGEgc2V0LiBBIHBhcnRpdGlvbiBpcyBhIHBhaXJ3aXNlIGRpc2pvaW50IHN1YnNldCBvZiBTIHdob3NlIHVuaW9uIGlzIFMuIGBiZWxsTnVtYmVyc2Agb25seSB0YWtlcyBpbnRlZ2VyIGFyZ3VtZW50cy4gVGhlIGZvbGxvd2luZyBjb25kaXRpb24gbXVzdCBiZSBlbmZvcmNlZDogbiA+PSAwLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnYmVsbE51bWJlcnMoMyknLFxuICAgICdiZWxsTnVtYmVycyg4KSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbJ3N0aXJsaW5nUzInXVxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnY2F0YWxhbicsXG4gICdjYXRlZ29yeSc6ICdDb21iaW5hdG9yaWNzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnY2F0YWxhbihuKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ1RoZSBDYXRhbGFuIE51bWJlcnMgZW51bWVyYXRlIGNvbWJpbmF0b3JpYWwgc3RydWN0dXJlcyBvZiBtYW55IGRpZmZlcmVudCB0eXBlcy4gY2F0YWxhbiBvbmx5IHRha2VzIGludGVnZXIgYXJndW1lbnRzLiBUaGUgZm9sbG93aW5nIGNvbmRpdGlvbiBtdXN0IGJlIGVuZm9yY2VkOiBuID49IDAuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdjYXRhbGFuKDMpJyxcbiAgICAnY2F0YWxhbig4KSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbJ2JlbGxOdW1iZXJzJ11cbn07IiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2NvbXBvc2l0aW9uJyxcbiAgJ2NhdGVnb3J5JzogJ0NvbWJpbmF0b3JpY3MnLFxuICAnc3ludGF4JzogW1xuICAgICdjb21wb3NpdGlvbihuLCBrKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ1RoZSBjb21wb3NpdGlvbiBjb3VudHMgb2YgbiBpbnRvIGsgcGFydHMuIGNvbXBvc2l0aW9uIG9ubHkgdGFrZXMgaW50ZWdlciBhcmd1bWVudHMuIFRoZSBmb2xsb3dpbmcgY29uZGl0aW9uIG11c3QgYmUgZW5mb3JjZWQ6IGsgPD0gbi4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2NvbXBvc2l0aW9uKDUsIDMpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFsnY29tYmluYXRpb25zJ11cbn07IiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3N0aXJsaW5nUzInLFxuICAnY2F0ZWdvcnknOiAnQ29tYmluYXRvcmljcycsXG4gICdzeW50YXgnOiBbXG4gICAgJ3N0aXJsaW5nUzIobiwgayknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdoZSBTdGlybGluZyBudW1iZXJzIG9mIHRoZSBzZWNvbmQga2luZCwgY291bnRzIHRoZSBudW1iZXIgb2Ygd2F5cyB0byBwYXJ0aXRpb24gYSBzZXQgb2YgbiBsYWJlbGxlZCBvYmplY3RzIGludG8gayBub25lbXB0eSB1bmxhYmVsbGVkIHN1YnNldHMuIGBzdGlybGluZ1MyYCBvbmx5IHRha2VzIGludGVnZXIgYXJndW1lbnRzLiBUaGUgZm9sbG93aW5nIGNvbmRpdGlvbiBtdXN0IGJlIGVuZm9yY2VkOiBrIDw9IG4uIElmIG4gPSBrIG9yIGsgPSAxLCB0aGVuIHMobixrKSA9IDEuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdzdGlybGluZ1MyKDUsIDMpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFsnYmVsbE51bWJlcnMnXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdhcmcnLFxuICAnY2F0ZWdvcnknOiAnQ29tcGxleCcsXG4gICdzeW50YXgnOiBbXG4gICAgJ2FyZyh4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzpcbiAgICAgICdDb21wdXRlIHRoZSBhcmd1bWVudCBvZiBhIGNvbXBsZXggdmFsdWUuIElmIHggPSBhK2JpLCB0aGUgYXJndW1lbnQgaXMgY29tcHV0ZWQgYXMgYXRhbjIoYiwgYSkuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdhcmcoMiArIDJpKScsXG4gICAgJ2F0YW4yKDMsIDIpJyxcbiAgICAnYXJnKDIgKyAzaSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdyZScsXG4gICAgJ2ltJyxcbiAgICAnY29uaicsXG4gICAgJ2FicydcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdjb25qJyxcbiAgJ2NhdGVnb3J5JzogJ0NvbXBsZXgnLFxuICAnc3ludGF4JzogW1xuICAgICdjb25qKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ0NvbXB1dGUgdGhlIGNvbXBsZXggY29uanVnYXRlIG9mIGEgY29tcGxleCB2YWx1ZS4gSWYgeCA9IGErYmksIHRoZSBjb21wbGV4IGNvbmp1Z2F0ZSBpcyBhLWJpLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnY29uaigyICsgM2kpJyxcbiAgICAnY29uaigyIC0gM2kpJyxcbiAgICAnY29uaigtNS4yaSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdyZScsXG4gICAgJ2ltJyxcbiAgICAnYWJzJyxcbiAgICAnYXJnJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2ltJyxcbiAgJ2NhdGVnb3J5JzogJ0NvbXBsZXgnLFxuICAnc3ludGF4JzogW1xuICAgICdpbSh4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0dldCB0aGUgaW1hZ2luYXJ5IHBhcnQgb2YgYSBjb21wbGV4IG51bWJlci4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2ltKDIgKyAzaSknLFxuICAgICdyZSgyICsgM2kpJyxcbiAgICAnaW0oLTUuMmkpJyxcbiAgICAnaW0oMi40KSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ3JlJyxcbiAgICAnY29uaicsXG4gICAgJ2FicycsXG4gICAgJ2FyZydcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdyZScsXG4gICdjYXRlZ29yeSc6ICdDb21wbGV4JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAncmUoeCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdHZXQgdGhlIHJlYWwgcGFydCBvZiBhIGNvbXBsZXggbnVtYmVyLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAncmUoMiArIDNpKScsXG4gICAgJ2ltKDIgKyAzaSknLFxuICAgICdyZSgtNS4yaSknLFxuICAgICdyZSgyLjQpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnaW0nLFxuICAgICdjb25qJyxcbiAgICAnYWJzJyxcbiAgICAnYXJnJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2V2YWwnLFxuICAnY2F0ZWdvcnknOiAnRXhwcmVzc2lvbicsXG4gICdzeW50YXgnOiBbXG4gICAgJ2V2YWwoZXhwcmVzc2lvbiknLFxuICAgICdldmFsKFtleHByMSwgZXhwcjIsIGV4cHIzLCAuLi5dKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0V2YWx1YXRlIGFuIGV4cHJlc3Npb24gb3IgYW4gYXJyYXkgd2l0aCBleHByZXNzaW9ucy4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2V2YWwoXCIyICsgM1wiKScsXG4gICAgJ2V2YWwoXCJzcXJ0KFwiICsgNCArIFwiKVwiKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdoZWxwJyxcbiAgJ2NhdGVnb3J5JzogJ0V4cHJlc3Npb24nLFxuICAnc3ludGF4JzogW1xuICAgICdoZWxwKG9iamVjdCknLFxuICAgICdoZWxwKHN0cmluZyknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdEaXNwbGF5IGRvY3VtZW50YXRpb24gb24gYSBmdW5jdGlvbiBvciBkYXRhIHR5cGUuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdoZWxwKHNxcnQpJyxcbiAgICAnaGVscChcImNvbXBsZXhcIiknXG4gIF0sXG4gICdzZWVhbHNvJzogW11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnZGlzdGFuY2UnLFxuICAnY2F0ZWdvcnknOiAnR2VvbWV0cnknLFxuICAnc3ludGF4JzogW1xuICAgICdkaXN0YW5jZShbeDEsIHkxXSwgW3gyLCB5Ml0pJyxcbiAgICAnZGlzdGFuY2UoW1t4MSwgeTFdLCBbeDIsIHkyXSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDYWxjdWxhdGVzIHRoZSBFdWNsaWRlYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnZGlzdGFuY2UoWzAsMF0sIFs0LDRdKScsXG4gICAgJ2Rpc3RhbmNlKFtbMCwwXSwgWzQsNF1dKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdpbnRlcnNlY3QnLFxuICAnY2F0ZWdvcnknOiAnR2VvbWV0cnknLFxuICAnc3ludGF4JzogW1xuICAgICdpbnRlcnNlY3QoZXhwcjEsIGV4cHIyLCBleHByMywgZXhwcjQpJyxcbiAgICAnaW50ZXJzZWN0KGV4cHIxLCBleHByMiwgZXhwcjMpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ29tcHV0ZXMgdGhlIGludGVyc2VjdGlvbiBwb2ludCBvZiBsaW5lcyBhbmQvb3IgcGxhbmVzLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnaW50ZXJzZWN0KFswLCAwXSwgWzEwLCAxMF0sIFsxMCwgMF0sIFswLCAxMF0pJyxcbiAgICAnaW50ZXJzZWN0KFsxLCAwLCAxXSwgIFs0LCAtMiwgMl0sIFsxLCAxLCAxLCA2XSknXG4gIF0sXG4gICdzZWVhbHNvJzogW11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnYW5kJyxcbiAgJ2NhdGVnb3J5JzogJ0xvZ2ljYWwnLFxuICAnc3ludGF4JzogW1xuICAgICd4IGFuZCB5JyxcbiAgICAnYW5kKHgsIHkpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnTG9naWNhbCBhbmQuIFRlc3Qgd2hldGhlciB0d28gdmFsdWVzIGFyZSBib3RoIGRlZmluZWQgd2l0aCBhIG5vbnplcm8vbm9uZW1wdHkgdmFsdWUuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICd0cnVlIGFuZCBmYWxzZScsXG4gICAgJ3RydWUgYW5kIHRydWUnLFxuICAgICcyIGFuZCA0J1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnbm90JywgJ29yJywgJ3hvcidcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdub3QnLFxuICAnY2F0ZWdvcnknOiAnTG9naWNhbCcsXG4gICdzeW50YXgnOiBbXG4gICAgJ25vdCB4JyxcbiAgICAnbm90KHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnTG9naWNhbCBub3QuIEZsaXBzIHRoZSBib29sZWFuIHZhbHVlIG9mIGdpdmVuIGFyZ3VtZW50LicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnbm90IHRydWUnLFxuICAgICdub3QgZmFsc2UnLFxuICAgICdub3QgMicsXG4gICAgJ25vdCAwJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnYW5kJywgJ29yJywgJ3hvcidcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdvcicsXG4gICdjYXRlZ29yeSc6ICdMb2dpY2FsJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAneCBvciB5JyxcbiAgICAnb3IoeCwgeSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdMb2dpY2FsIG9yLiBUZXN0IGlmIGF0IGxlYXN0IG9uZSB2YWx1ZSBpcyBkZWZpbmVkIHdpdGggYSBub256ZXJvL25vbmVtcHR5IHZhbHVlLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAndHJ1ZSBvciBmYWxzZScsXG4gICAgJ2ZhbHNlIG9yIGZhbHNlJyxcbiAgICAnMCBvciA0J1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnbm90JywgJ2FuZCcsICd4b3InXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAneG9yJyxcbiAgJ2NhdGVnb3J5JzogJ0xvZ2ljYWwnLFxuICAnc3ludGF4JzogW1xuICAgICd4IG9yIHknLFxuICAgICdvcih4LCB5KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0xvZ2ljYWwgZXhjbHVzaXZlIG9yLCB4b3IuIFRlc3Qgd2hldGhlciBvbmUgYW5kIG9ubHkgb25lIHZhbHVlIGlzIGRlZmluZWQgd2l0aCBhIG5vbnplcm8vbm9uZW1wdHkgdmFsdWUuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICd0cnVlIHhvciBmYWxzZScsXG4gICAgJ2ZhbHNlIHhvciBmYWxzZScsXG4gICAgJ3RydWUgeG9yIHRydWUnLFxuICAgICcwIG9yIDQnXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdub3QnLCAnYW5kJywgJ29yJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2NvbmNhdCcsXG4gICdjYXRlZ29yeSc6ICdNYXRyaXgnLFxuICAnc3ludGF4JzogW1xuICAgICdjb25jYXQoQSwgQiwgQywgLi4uKScsXG4gICAgJ2NvbmNhdChBLCBCLCBDLCAuLi4sIGRpbSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDb25jYXRlbmF0ZSBtYXRyaWNlcy4gQnkgZGVmYXVsdCwgdGhlIG1hdHJpY2VzIGFyZSBjb25jYXRlbmF0ZWQgYnkgdGhlIGxhc3QgZGltZW5zaW9uLiBUaGUgZGltZW5zaW9uIG9uIHdoaWNoIHRvIGNvbmNhdGVuYXRlIGNhbiBiZSBwcm92aWRlZCBhcyBsYXN0IGFyZ3VtZW50LicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnQSA9IFsxLCAyOyA1LCA2XScsXG4gICAgJ0IgPSBbMywgNDsgNywgOF0nLFxuICAgICdjb25jYXQoQSwgQiknLFxuICAgICdjb25jYXQoQSwgQiwgMSknLFxuICAgICdjb25jYXQoQSwgQiwgMiknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdkZXQnLCAnZGlhZycsICdleWUnLCAnaW52JywgJ29uZXMnLCAncmFuZ2UnLCAnc2l6ZScsICdzcXVlZXplJywgJ3N1YnNldCcsICd0cmFjZScsICd0cmFuc3Bvc2UnLCAnemVyb3MnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnY3Jvc3MnLFxuICAnY2F0ZWdvcnknOiAnTWF0cml4JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnY3Jvc3MoQSwgQiknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDYWxjdWxhdGUgdGhlIGNyb3NzIHByb2R1Y3QgZm9yIHR3byB2ZWN0b3JzIGluIHRocmVlIGRpbWVuc2lvbmFsIHNwYWNlLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnY3Jvc3MoWzEsIDEsIDBdLCAgWzAsIDEsIDFdKScsXG4gICAgJ2Nyb3NzKFszLCAtMywgMV0sIFs0LCA5LCAyXSknLFxuICAgICdjcm9zcyhbMiwgMywgNF0sICBbNSwgNiwgN10pJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnbXVsdGlwbHknLFxuICAgICdkb3QnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnZGV0JyxcbiAgJ2NhdGVnb3J5JzogJ01hdHJpeCcsXG4gICdzeW50YXgnOiBbXG4gICAgJ2RldCh4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXRyaXgnLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2RldChbMSwgMjsgMywgNF0pJyxcbiAgICAnZGV0KFstMiwgMiwgMzsgLTEsIDEsIDM7IDIsIDAsIC0xXSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdjb25jYXQnLCAnZGlhZycsICdleWUnLCAnaW52JywgJ29uZXMnLCAncmFuZ2UnLCAnc2l6ZScsICdzcXVlZXplJywgJ3N1YnNldCcsICd0cmFjZScsICd0cmFuc3Bvc2UnLCAnemVyb3MnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnZGlhZycsXG4gICdjYXRlZ29yeSc6ICdNYXRyaXgnLFxuICAnc3ludGF4JzogW1xuICAgICdkaWFnKHgpJyxcbiAgICAnZGlhZyh4LCBrKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NyZWF0ZSBhIGRpYWdvbmFsIG1hdHJpeCBvciByZXRyaWV2ZSB0aGUgZGlhZ29uYWwgb2YgYSBtYXRyaXguIFdoZW4geCBpcyBhIHZlY3RvciwgYSBtYXRyaXggd2l0aCB0aGUgdmVjdG9yIHZhbHVlcyBvbiB0aGUgZGlhZ29uYWwgd2lsbCBiZSByZXR1cm5lZC4gV2hlbiB4IGlzIGEgbWF0cml4LCBhIHZlY3RvciB3aXRoIHRoZSBkaWFnb25hbCB2YWx1ZXMgb2YgdGhlIG1hdHJpeCBpcyByZXR1cm5lZC4gV2hlbiBrIGlzIHByb3ZpZGVkLCB0aGUgay10aCBkaWFnb25hbCB3aWxsIGJlIGZpbGxlZCBpbiBvciByZXRyaWV2ZWQsIGlmIGsgaXMgcG9zaXRpdmUsIHRoZSB2YWx1ZXMgYXJlIHBsYWNlZCBvbiB0aGUgc3VwZXIgZGlhZ29uYWwuIFdoZW4gayBpcyBuZWdhdGl2ZSwgdGhlIHZhbHVlcyBhcmUgcGxhY2VkIG9uIHRoZSBzdWIgZGlhZ29uYWwuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdkaWFnKDE6MyknLFxuICAgICdkaWFnKDE6MywgMSknLFxuICAgICdhID0gWzEsIDIsIDM7IDQsIDUsIDY7IDcsIDgsIDldJyxcbiAgICAnZGlhZyhhKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2NvbmNhdCcsICdkZXQnLCAnZXllJywgJ2ludicsICdvbmVzJywgJ3JhbmdlJywgJ3NpemUnLCAnc3F1ZWV6ZScsICdzdWJzZXQnLCAndHJhY2UnLCAndHJhbnNwb3NlJywgJ3plcm9zJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2RvdCcsXG4gICdjYXRlZ29yeSc6ICdNYXRyaXgnLFxuICAnc3ludGF4JzogW1xuICAgICdkb3QoQSwgQiknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDYWxjdWxhdGUgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWN0b3JzLiAnICtcbiAgICAgICdUaGUgZG90IHByb2R1Y3Qgb2YgQSA9IFthMSwgYTIsIGEzLCAuLi4sIGFuXSBhbmQgQiA9IFtiMSwgYjIsIGIzLCAuLi4sIGJuXSAnICtcbiAgICAgICdpcyBkZWZpbmVkIGFzIGRvdChBLCBCKSA9IGExICogYjEgKyBhMiAqIGIyICsgYTMgKiBiMyArIC4uLiArIGFuICogYm4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2RvdChbMiwgNCwgMV0sIFsyLCAyLCAzXSknLFxuICAgICdbMiwgNCwgMV0gKiBbMiwgMiwgM10nXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdtdWx0aXBseScsXG4gICAgJ2Nyb3NzJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2V5ZScsXG4gICdjYXRlZ29yeSc6ICdNYXRyaXgnLFxuICAnc3ludGF4JzogW1xuICAgICdleWUobiknLFxuICAgICdleWUobSwgbiknLFxuICAgICdleWUoW20sIG5dKScsXG4gICAgJ2V5ZSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ1JldHVybnMgdGhlIGlkZW50aXR5IG1hdHJpeCB3aXRoIHNpemUgbS1ieS1uLiBUaGUgbWF0cml4IGhhcyBvbmVzIG9uIHRoZSBkaWFnb25hbCBhbmQgemVyb3MgZWxzZXdoZXJlLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnZXllKDMpJyxcbiAgICAnZXllKDMsIDUpJyxcbiAgICAnYSA9IFsxLCAyLCAzOyA0LCA1LCA2XScsXG4gICAgJ2V5ZShzaXplKGEpKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2NvbmNhdCcsICdkZXQnLCAnZGlhZycsICdpbnYnLCAnb25lcycsICdyYW5nZScsICdzaXplJywgJ3NxdWVlemUnLCAnc3Vic2V0JywgJ3RyYWNlJywgJ3RyYW5zcG9zZScsICd6ZXJvcydcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdmaWx0ZXInLFxuICAnY2F0ZWdvcnknOiAnTWF0cml4JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnZmlsdGVyKHgsIHRlc3QpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnRmlsdGVyIGl0ZW1zIGluIGEgbWF0cml4LicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnaXNQb3NpdGl2ZSh4KSA9IHggPiAwJyxcbiAgICAnZmlsdGVyKFs2LCAtMiwgLTEsIDQsIDNdLCBpc1Bvc2l0aXZlKScsXG4gICAgJ2ZpbHRlcihbNiwgLTIsIDAsIDEsIDBdLCB4ICE9IDApJ1xuICBdLFxuICAnc2VlYWxzbyc6IFsnc29ydCcsICdtYXAnLCAnZm9yRWFjaCddXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2ZsYXR0ZW4nLFxuICAnY2F0ZWdvcnknOiAnTWF0cml4JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnZmxhdHRlbih4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0ZsYXR0ZW4gYSBtdWx0aSBkaW1lbnNpb25hbCBtYXRyaXggaW50byBhIHNpbmdsZSBkaW1lbnNpb25hbCBtYXRyaXguJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdhID0gWzEsIDIsIDM7IDQsIDUsIDZdJyxcbiAgICAnc2l6ZShhKScsXG4gICAgJ2IgPSBmbGF0dGVuKGEpJyxcbiAgICAnc2l6ZShiKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2NvbmNhdCcsICdyZXNpemUnLCAnc2l6ZScsICdzcXVlZXplJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2ZvckVhY2gnLFxuICAnY2F0ZWdvcnknOiAnTWF0cml4JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnZm9yRWFjaCh4LCBjYWxsYmFjayknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdJdGVyYXRlcyBvdmVyIGFsbCBlbGVtZW50cyBvZiBhIG1hdHJpeC9hcnJheSwgYW5kIGV4ZWN1dGVzIHRoZSBnaXZlbiBjYWxsYmFjayBmdW5jdGlvbi4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2ZvckVhY2goWzEsIDIsIDNdLCBmdW5jdGlvbih2YWwpIHsgY29uc29sZS5sb2codmFsKSB9KSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbJ21hcCcsICdzb3J0JywgJ2ZpbHRlciddXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2ludicsXG4gICdjYXRlZ29yeSc6ICdNYXRyaXgnLFxuICAnc3ludGF4JzogW1xuICAgICdpbnYoeCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDYWxjdWxhdGUgdGhlIGludmVyc2Ugb2YgYSBtYXRyaXgnLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2ludihbMSwgMjsgMywgNF0pJyxcbiAgICAnaW52KDQpJyxcbiAgICAnMSAvIDQnXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdjb25jYXQnLCAnZGV0JywgJ2RpYWcnLCAnZXllJywgJ29uZXMnLCAncmFuZ2UnLCAnc2l6ZScsICdzcXVlZXplJywgJ3N1YnNldCcsICd0cmFjZScsICd0cmFuc3Bvc2UnLCAnemVyb3MnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnbWFwJyxcbiAgJ2NhdGVnb3J5JzogJ01hdHJpeCcsXG4gICdzeW50YXgnOiBbXG4gICAgJ21hcCh4LCBjYWxsYmFjayknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDcmVhdGUgYSBuZXcgbWF0cml4IG9yIGFycmF5IHdpdGggdGhlIHJlc3VsdHMgb2YgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGV4ZWN1dGVkIG9uIGVhY2ggZW50cnkgb2YgdGhlIG1hdHJpeC9hcnJheS4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ21hcChbMSwgMiwgM10sIGZ1bmN0aW9uKHZhbCkgeyByZXR1cm4gdmFsdWUgKiB2YWx1ZSB9KSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbJ2ZpbHRlcicsICdmb3JFYWNoJ11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnb25lcycsXG4gICdjYXRlZ29yeSc6ICdNYXRyaXgnLFxuICAnc3ludGF4JzogW1xuICAgICdvbmVzKG0pJyxcbiAgICAnb25lcyhtLCBuKScsXG4gICAgJ29uZXMobSwgbiwgcCwgLi4uKScsXG4gICAgJ29uZXMoW21dKScsXG4gICAgJ29uZXMoW20sIG5dKScsXG4gICAgJ29uZXMoW20sIG4sIHAsIC4uLl0pJyxcbiAgICAnb25lcydcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NyZWF0ZSBhIG1hdHJpeCBjb250YWluaW5nIG9uZXMuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdvbmVzKDMpJyxcbiAgICAnb25lcygzLCA1KScsXG4gICAgJ29uZXMoWzIsM10pICogNC41JyxcbiAgICAnYSA9IFsxLCAyLCAzOyA0LCA1LCA2XScsXG4gICAgJ29uZXMoc2l6ZShhKSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdjb25jYXQnLCAnZGV0JywgJ2RpYWcnLCAnZXllJywgJ2ludicsICdyYW5nZScsICdzaXplJywgJ3NxdWVlemUnLCAnc3Vic2V0JywgJ3RyYWNlJywgJ3RyYW5zcG9zZScsICd6ZXJvcydcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdwYXJ0aXRpb25TZWxlY3QnLFxuICAnY2F0ZWdvcnknOiAnTWF0cml4JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAncGFydGl0aW9uU2VsZWN0KHgsIGspJyxcbiAgICAncGFydGl0aW9uU2VsZWN0KHgsIGssIGNvbXBhcmUpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnUGFydGl0aW9uLWJhc2VkIHNlbGVjdGlvbiBvZiBhbiBhcnJheSBvciAxRCBtYXRyaXguIFdpbGwgZmluZCB0aGUga3RoIHNtYWxsZXN0IHZhbHVlLCBhbmQgbXV0YXRlcyB0aGUgaW5wdXQgYXJyYXkuIFVzZXMgUXVpY2tzZWxlY3QuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdwYXJ0aXRpb25TZWxlY3QoWzUsIDEwLCAxXSwgMiknLFxuICAgICdwYXJ0aXRpb25TZWxlY3QoW1wiQ1wiLCBcIkJcIiwgXCJBXCIsIFwiRFwiXSwgMSknXG4gIF0sXG4gICdzZWVhbHNvJzogWydzb3J0J11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAncmFuZ2UnLFxuICAnY2F0ZWdvcnknOiAnVHlwZScsXG4gICdzeW50YXgnOiBbXG4gICAgJ3N0YXJ0OmVuZCcsXG4gICAgJ3N0YXJ0OnN0ZXA6ZW5kJyxcbiAgICAncmFuZ2Uoc3RhcnQsIGVuZCknLFxuICAgICdyYW5nZShzdGFydCwgZW5kLCBzdGVwKScsXG4gICAgJ3JhbmdlKHN0cmluZyknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6XG4gICAgICAnQ3JlYXRlIGEgcmFuZ2UuIExvd2VyIGJvdW5kIG9mIHRoZSByYW5nZSBpcyBpbmNsdWRlZCwgdXBwZXIgYm91bmQgaXMgZXhjbHVkZWQuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICcxOjUnLFxuICAgICczOi0xOi0zJyxcbiAgICAncmFuZ2UoMywgNyknLFxuICAgICdyYW5nZSgwLCAxMiwgMiknLFxuICAgICdyYW5nZShcIjQ6MTBcIiknLFxuICAgICdhID0gWzEsIDIsIDMsIDQ7IDUsIDYsIDcsIDhdJyxcbiAgICAnYVsxOjIsIDE6Ml0nXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdjb25jYXQnLCAnZGV0JywgJ2RpYWcnLCAnZXllJywgJ2ludicsICdvbmVzJywgJ3NpemUnLCAnc3F1ZWV6ZScsICdzdWJzZXQnLCAndHJhY2UnLCAndHJhbnNwb3NlJywgJ3plcm9zJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3Jlc2l6ZScsXG4gICdjYXRlZ29yeSc6ICdNYXRyaXgnLFxuICAnc3ludGF4JzogW1xuICAgICdyZXNpemUoeCwgc2l6ZSknLFxuICAgICdyZXNpemUoeCwgc2l6ZSwgZGVmYXVsdFZhbHVlKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ1Jlc2l6ZSBhIG1hdHJpeC4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ3Jlc2l6ZShbMSwyLDMsNCw1XSwgWzNdKScsXG4gICAgJ3Jlc2l6ZShbMSwyLDNdLCBbNV0pJyxcbiAgICAncmVzaXplKFsxLDIsM10sIFs1XSwgLTEpJyxcbiAgICAncmVzaXplKDIsIFsyLCAzXSknLFxuICAgICdyZXNpemUoXCJoZWxsb1wiLCBbOF0sIFwiIVwiKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ3NpemUnLCAnc3Vic2V0JywgJ3NxdWVlemUnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnc2l6ZScsXG4gICdjYXRlZ29yeSc6ICdNYXRyaXgnLFxuICAnc3ludGF4JzogW1xuICAgICdzaXplKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ2FsY3VsYXRlIHRoZSBzaXplIG9mIGEgbWF0cml4LicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnc2l6ZSgyLjMpJyxcbiAgICAnc2l6ZShcImhlbGxvIHdvcmxkXCIpJyxcbiAgICAnYSA9IFsxLCAyOyAzLCA0OyA1LCA2XScsXG4gICAgJ3NpemUoYSknLFxuICAgICdzaXplKDE6NiknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdjb25jYXQnLCAnZGV0JywgJ2RpYWcnLCAnZXllJywgJ2ludicsICdvbmVzJywgJ3JhbmdlJywgJ3NxdWVlemUnLCAnc3Vic2V0JywgJ3RyYWNlJywgJ3RyYW5zcG9zZScsICd6ZXJvcydcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdzb3J0JyxcbiAgJ2NhdGVnb3J5JzogJ01hdHJpeCcsXG4gICdzeW50YXgnOiBbXG4gICAgJ3NvcnQoeCknLFxuICAgICdzb3J0KHgsIGNvbXBhcmUpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnU29ydCB0aGUgaXRlbXMgaW4gYSBtYXRyaXguIENvbXBhcmUgY2FuIGJlIGEgc3RyaW5nIFwiYXNjXCIgb3IgXCJkZXNjXCIsIG9yIGEgY3VzdG9tIHNvcnQgZnVuY3Rpb24uJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdzb3J0KFs1LCAxMCwgMV0pJyxcbiAgICAnc29ydChbXCJDXCIsIFwiQlwiLCBcIkFcIiwgXCJEXCJdKScsXG4gICAgJ3NvcnRCeUxlbmd0aChhLCBiKSA9IHNpemUoYSlbMV0gLSBzaXplKGIpWzFdJyxcbiAgICAnc29ydChbXCJMYW5nZG9uXCIsIFwiVG9tXCIsIFwiU2FyYVwiXSwgc29ydEJ5TGVuZ3RoKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbJ21hcCcsICdmaWx0ZXInLCAnZm9yRWFjaCddXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3NxdWVlemUnLFxuICAnY2F0ZWdvcnknOiAnTWF0cml4JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnc3F1ZWV6ZSh4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ1JlbW92ZSBpbm5lciBhbmQgb3V0ZXIgc2luZ2xldG9uIGRpbWVuc2lvbnMgZnJvbSBhIG1hdHJpeC4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2EgPSB6ZXJvcygzLDIsMSknLFxuICAgICdzaXplKHNxdWVlemUoYSkpJyxcbiAgICAnYiA9IHplcm9zKDEsMSwzKScsXG4gICAgJ3NpemUoc3F1ZWV6ZShiKSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdjb25jYXQnLCAnZGV0JywgJ2RpYWcnLCAnZXllJywgJ2ludicsICdvbmVzJywgJ3JhbmdlJywgJ3NpemUnLCAnc3Vic2V0JywgJ3RyYWNlJywgJ3RyYW5zcG9zZScsICd6ZXJvcydcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdzdWJzZXQnLFxuICAnY2F0ZWdvcnknOiAnTWF0cml4JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAndmFsdWUoaW5kZXgpJyxcbiAgICAndmFsdWUoaW5kZXgpID0gcmVwbGFjZW1lbnQnLFxuICAgICdzdWJzZXQodmFsdWUsIFtpbmRleF0pJyxcbiAgICAnc3Vic2V0KHZhbHVlLCBbaW5kZXhdLCByZXBsYWNlbWVudCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdHZXQgb3Igc2V0IGEgc3Vic2V0IG9mIGEgbWF0cml4IG9yIHN0cmluZy4gJyArXG4gICAgICAnSW5kZXhlcyBhcmUgb25lLWJhc2VkLiAnICtcbiAgICAgICdCb3RoIHRoZSByYW5nZXMgbG93ZXItYm91bmQgYW5kIHVwcGVyLWJvdW5kIGFyZSBpbmNsdWRlZC4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2QgPSBbMSwgMjsgMywgNF0nLFxuICAgICdlID0gW10nLFxuICAgICdlWzEsIDE6Ml0gPSBbNSwgNl0nLFxuICAgICdlWzIsIDpdID0gWzcsIDhdJyxcbiAgICAnZiA9IGQgKiBlJyxcbiAgICAnZlsyLCAxXScsXG4gICAgJ2ZbOiwgMV0nXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdjb25jYXQnLCAnZGV0JywgJ2RpYWcnLCAnZXllJywgJ2ludicsICdvbmVzJywgJ3JhbmdlJywgJ3NpemUnLCAnc3F1ZWV6ZScsICd0cmFjZScsICd0cmFuc3Bvc2UnLCAnemVyb3MnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAndHJhY2UnLFxuICAnY2F0ZWdvcnknOiAnTWF0cml4JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAndHJhY2UoQSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDYWxjdWxhdGUgdGhlIHRyYWNlIG9mIGEgbWF0cml4OiB0aGUgc3VtIG9mIHRoZSBlbGVtZW50cyBvbiB0aGUgbWFpbiBkaWFnb25hbCBvZiBhIHNxdWFyZSBtYXRyaXguJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdBID0gWzEsIDIsIDM7IC0xLCAyLCAzOyAyLCAwLCAzXScsXG4gICAgJ3RyYWNlKEEpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnY29uY2F0JywgJ2RldCcsICdkaWFnJywgJ2V5ZScsICdpbnYnLCAnb25lcycsICdyYW5nZScsICdzaXplJywgJ3NxdWVlemUnLCAnc3Vic2V0JywgJ3RyYW5zcG9zZScsICd6ZXJvcydcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICd0cmFuc3Bvc2UnLFxuICAnY2F0ZWdvcnknOiAnTWF0cml4JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAneFxcJycsXG4gICAgJ3RyYW5zcG9zZSh4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ1RyYW5zcG9zZSBhIG1hdHJpeCcsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnYSA9IFsxLCAyLCAzOyA0LCA1LCA2XScsXG4gICAgJ2FcXCcnLFxuICAgICd0cmFuc3Bvc2UoYSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdjb25jYXQnLCAnZGV0JywgJ2RpYWcnLCAnZXllJywgJ2ludicsICdvbmVzJywgJ3JhbmdlJywgJ3NpemUnLCAnc3F1ZWV6ZScsICdzdWJzZXQnLCAndHJhY2UnLCAnemVyb3MnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnemVyb3MnLFxuICAnY2F0ZWdvcnknOiAnTWF0cml4JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnemVyb3MobSknLFxuICAgICd6ZXJvcyhtLCBuKScsXG4gICAgJ3plcm9zKG0sIG4sIHAsIC4uLiknLFxuICAgICd6ZXJvcyhbbV0pJyxcbiAgICAnemVyb3MoW20sIG5dKScsXG4gICAgJ3plcm9zKFttLCBuLCBwLCAuLi5dKScsXG4gICAgJ3plcm9zJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ3JlYXRlIGEgbWF0cml4IGNvbnRhaW5pbmcgemVyb3MuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICd6ZXJvcygzKScsXG4gICAgJ3plcm9zKDMsIDUpJyxcbiAgICAnYSA9IFsxLCAyLCAzOyA0LCA1LCA2XScsXG4gICAgJ3plcm9zKHNpemUoYSkpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnY29uY2F0JywgJ2RldCcsICdkaWFnJywgJ2V5ZScsICdpbnYnLCAnb25lcycsICdyYW5nZScsICdzaXplJywgJ3NxdWVlemUnLCAnc3Vic2V0JywgJ3RyYWNlJywgJ3RyYW5zcG9zZSdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdjb21iaW5hdGlvbnMnLFxuICAnY2F0ZWdvcnknOiAnUHJvYmFiaWxpdHknLFxuICAnc3ludGF4JzogW1xuICAgICdjb21iaW5hdGlvbnMobiwgayknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDb21wdXRlIHRoZSBudW1iZXIgb2YgY29tYmluYXRpb25zIG9mIG4gaXRlbXMgdGFrZW4gayBhdCBhIHRpbWUnLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2NvbWJpbmF0aW9ucyg3LCA1KSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbJ3Blcm11dGF0aW9ucycsICdmYWN0b3JpYWwnXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdmYWN0b3JpYWwnLFxuICAnY2F0ZWdvcnknOiAnUHJvYmFiaWxpdHknLFxuICAnc3ludGF4JzogW1xuICAgICdrbGRpdmVyZ2VuY2UoeCwgeSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDb21wdXRlIHRoZSBmYWN0b3JpYWwgb2YgYSB2YWx1ZScsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnNSEnLFxuICAgICc1ICogNCAqIDMgKiAyICogMScsXG4gICAgJzMhJ1xuICBdLFxuICAnc2VlYWxzbyc6IFsnY29tYmluYXRpb25zJywgJ3Blcm11dGF0aW9ucycsICdnYW1tYSddXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2dhbW1hJyxcbiAgJ2NhdGVnb3J5JzogJ1Byb2JhYmlsaXR5JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnZ2FtbWEobiknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDb21wdXRlIHRoZSBnYW1tYSBmdW5jdGlvbi4gRm9yIHNtYWxsIHZhbHVlcywgdGhlIExhbmN6b3MgYXBwcm94aW1hdGlvbiBpcyB1c2VkLCBhbmQgZm9yIGxhcmdlIHZhbHVlcyB0aGUgZXh0ZW5kZWQgU3RpcmxpbmcgYXBwcm94aW1hdGlvbi4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2dhbW1hKDQpJyxcbiAgICAnMyEnLFxuICAgICdnYW1tYSgxLzIpJyxcbiAgICAnc3FydChwaSknXG4gIF0sXG4gICdzZWVhbHNvJzogWydmYWN0b3JpYWwnXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdrbGRpdmVyZ2VuY2UnLFxuICAnY2F0ZWdvcnknOiAnUHJvYmFiaWxpdHknLFxuICAnc3ludGF4JzogW1xuICAgICduIScsXG4gICAgJ2ZhY3RvcmlhbChuKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NhbGN1bGF0ZSB0aGUgS3VsbGJhY2stTGVpYmxlciAoS0wpIGRpdmVyZ2VuY2UgIGJldHdlZW4gdHdvIGRpc3RyaWJ1dGlvbnMuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdtYXRoLmtsZGl2ZXJnZW5jZShbMC43LDAuNSwwLjRdLCBbMC4yLDAuOSwwLjVdKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdtdWx0aW5vbWlhbCcsXG4gICdjYXRlZ29yeSc6ICdQcm9iYWJpbGl0eScsXG4gICdzeW50YXgnOiBbXG4gICAgJ211bHRpbm9taWFsKEEpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnTXVsdGlub21pYWwgQ29lZmZpY2llbnRzIGNvbXB1dGUgdGhlIG51bWJlciBvZiB3YXlzIG9mIHBpY2tpbmcgYTEsIGEyLCAuLi4sIGFpIHVub3JkZXJlZCBvdXRjb21lcyBmcm9tIGBuYCBwb3NzaWJpbGl0aWVzLiBtdWx0aW5vbWlhbCB0YWtlcyBvbmUgYXJyYXkgb2YgaW50ZWdlcnMgYXMgYW4gYXJndW1lbnQuIFRoZSBmb2xsb3dpbmcgY29uZGl0aW9uIG11c3QgYmUgZW5mb3JjZWQ6IGV2ZXJ5IGFpIDw9IDAuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdtdWx0aW5vbWlhbChbMSwgMiwgMV0pJ1xuICBdLFxuICAnc2VlYWxzbyc6IFsnY29tYmluYXRpb25zJywgJ2ZhY3RvcmlhbCddXG59OyIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdwZXJtdXRhdGlvbnMnLFxuICAnY2F0ZWdvcnknOiAnUHJvYmFiaWxpdHknLFxuICAnc3ludGF4JzogW1xuICAgICdwZXJtdXRhdGlvbnMobiknLFxuICAgICdwZXJtdXRhdGlvbnMobiwgayknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDb21wdXRlIHRoZSBudW1iZXIgb2YgcGVybXV0YXRpb25zIG9mIG4gaXRlbXMgdGFrZW4gayBhdCBhIHRpbWUnLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ3Blcm11dGF0aW9ucyg1KScsXG4gICAgJ3Blcm11dGF0aW9ucyg1LCAzKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbJ2NvbWJpbmF0aW9ucycsICdmYWN0b3JpYWwnXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdwaWNrUmFuZG9tJyxcbiAgJ2NhdGVnb3J5JzogJ1Byb2JhYmlsaXR5JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAncGlja1JhbmRvbShhcnJheSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6XG4gICAgICAnUGljayBhIHJhbmRvbSBlbnRyeSBmcm9tIGEgZ2l2ZW4gYXJyYXkuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdwaWNrUmFuZG9tKDA6MTApJyxcbiAgICAncGlja1JhbmRvbShbMSwgMywgMSwgNl0pJ1xuICBdLFxuICAnc2VlYWxzbyc6IFsncmFuZG9tJywgJ3JhbmRvbUludCddXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3JhbmRvbScsXG4gICdjYXRlZ29yeSc6ICdQcm9iYWJpbGl0eScsXG4gICdzeW50YXgnOiBbXG4gICAgJ3JhbmRvbSgpJyxcbiAgICAncmFuZG9tKG1heCknLFxuICAgICdyYW5kb20obWluLCBtYXgpJyxcbiAgICAncmFuZG9tKHNpemUpJyxcbiAgICAncmFuZG9tKHNpemUsIG1heCknLFxuICAgICdyYW5kb20oc2l6ZSwgbWluLCBtYXgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ1JldHVybiBhIHJhbmRvbSBudW1iZXIuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdyYW5kb20oKScsXG4gICAgJ3JhbmRvbSgxMCwgMjApJyxcbiAgICAncmFuZG9tKFsyLCAzXSknXG4gIF0sXG4gICdzZWVhbHNvJzogWydwaWNrUmFuZG9tJywgJ3JhbmRvbUludCddXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3JhbmRJbnQnLFxuICAnY2F0ZWdvcnknOiAnUHJvYmFiaWxpdHknLFxuICAnc3ludGF4JzogW1xuICAgICdyYW5kSW50KG1heCknLFxuICAgICdyYW5kSW50KG1pbiwgbWF4KScsXG4gICAgJ3JhbmRJbnQoc2l6ZSknLFxuICAgICdyYW5kSW50KHNpemUsIG1heCknLFxuICAgICdyYW5kSW50KHNpemUsIG1pbiwgbWF4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzpcbiAgICAgICdSZXR1cm4gYSByYW5kb20gaW50ZWdlciBudW1iZXInLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ3JhbmRJbnQoMTAsIDIwKScsXG4gICAgJ3JhbmRJbnQoWzIsIDNdLCAxMCknXG4gIF0sXG4gICdzZWVhbHNvJzogWydwaWNrUmFuZG9tJywgJ3JhbmRvbSddXG59OyIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdjb21wYXJlJyxcbiAgJ2NhdGVnb3J5JzogJ1JlbGF0aW9uYWwnLFxuICAnc3ludGF4JzogW1xuICAgICdjb21wYXJlKHgsIHkpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ0NvbXBhcmUgdHdvIHZhbHVlcy4gUmV0dXJucyAxIGlmIHggaXMgbGFyZ2VyIHRoYW4geSwgLTEgaWYgeCBpcyBzbWFsbGVyIHRoYW4geSwgYW5kIDAgaWYgeCBhbmQgeSBhcmUgZXF1YWwuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdjb21wYXJlKDIsIDMpJyxcbiAgICAnY29tcGFyZSgzLCAyKScsXG4gICAgJ2NvbXBhcmUoMiwgMiknLFxuICAgICdjb21wYXJlKDVjbSwgNDBtbSknLFxuICAgICdjb21wYXJlKDIsIFsxLCAyLCAzXSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdlcXVhbCcsICd1bmVxdWFsJywgJ3NtYWxsZXInLCAnc21hbGxlckVxJywgJ2xhcmdlckVxJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2RlZXBFcXVhbCcsXG4gICdjYXRlZ29yeSc6ICdSZWxhdGlvbmFsJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnZGVlcEVxdWFsKHgsIHkpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ0NoZWNrIGVxdWFsaXR5IG9mIHR3byBtYXRyaWNlcyBlbGVtZW50IHdpc2UuIFJldHVybnMgdHJ1ZSBpZiB0aGUgc2l6ZSBvZiBib3RoIG1hdHJpY2VzIGlzIGVxdWFsIGFuZCB3aGVuIGFuZCBlYWNoIG9mIHRoZSBlbGVtZW50cyBhcmUgZXF1YWwuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdbMSwzLDRdID09IFsxLDMsNF0nLFxuICAgICdbMSwzLDRdID09IFsxLDNdJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnZXF1YWwnLCAndW5lcXVhbCcsICdzbWFsbGVyJywgJ2xhcmdlcicsICdzbWFsbGVyRXEnLCAnbGFyZ2VyRXEnLCAnY29tcGFyZSdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdlcXVhbCcsXG4gICdjYXRlZ29yeSc6ICdSZWxhdGlvbmFsJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAneCA9PSB5JyxcbiAgICAnZXF1YWwoeCwgeSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6XG4gICAgICAnQ2hlY2sgZXF1YWxpdHkgb2YgdHdvIHZhbHVlcy4gUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWFsLCBhbmQgZmFsc2UgaWYgbm90LicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnMisyID09IDMnLFxuICAgICcyKzIgPT0gNCcsXG4gICAgJ2EgPSAzLjInLFxuICAgICdiID0gNi0yLjgnLFxuICAgICdhID09IGInLFxuICAgICc1MGNtID09IDAuNW0nXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICd1bmVxdWFsJywgJ3NtYWxsZXInLCAnbGFyZ2VyJywgJ3NtYWxsZXJFcScsICdsYXJnZXJFcScsICdjb21wYXJlJywgJ2RlZXBFcXVhbCdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdsYXJnZXInLFxuICAnY2F0ZWdvcnknOiAnUmVsYXRpb25hbCcsXG4gICdzeW50YXgnOiBbXG4gICAgJ3ggPiB5JyxcbiAgICAnbGFyZ2VyKHgsIHkpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ0NoZWNrIGlmIHZhbHVlIHggaXMgbGFyZ2VyIHRoYW4geS4gUmV0dXJucyB0cnVlIGlmIHggaXMgbGFyZ2VyIHRoYW4geSwgYW5kIGZhbHNlIGlmIG5vdC4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJzIgPiAzJyxcbiAgICAnNSA+IDIqMicsXG4gICAgJ2EgPSAzLjMnLFxuICAgICdiID0gNi0yLjgnLFxuICAgICcoYSA+IGIpJyxcbiAgICAnKGIgPCBhKScsXG4gICAgJzUgY20gPiAyIGluY2gnXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdlcXVhbCcsICd1bmVxdWFsJywgJ3NtYWxsZXInLCAnc21hbGxlckVxJywgJ2xhcmdlckVxJywgJ2NvbXBhcmUnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnbGFyZ2VyRXEnLFxuICAnY2F0ZWdvcnknOiAnUmVsYXRpb25hbCcsXG4gICdzeW50YXgnOiBbXG4gICAgJ3ggPj0geScsXG4gICAgJ2xhcmdlckVxKHgsIHkpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ0NoZWNrIGlmIHZhbHVlIHggaXMgbGFyZ2VyIG9yIGVxdWFsIHRvIHkuIFJldHVybnMgdHJ1ZSBpZiB4IGlzIGxhcmdlciBvciBlcXVhbCB0byB5LCBhbmQgZmFsc2UgaWYgbm90LicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnMiA+IDErMScsXG4gICAgJzIgPj0gMSsxJyxcbiAgICAnYSA9IDMuMicsXG4gICAgJ2IgPSA2LTIuOCcsXG4gICAgJyhhID4gYiknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdlcXVhbCcsICd1bmVxdWFsJywgJ3NtYWxsZXJFcScsICdzbWFsbGVyJywgJ2xhcmdlckVxJywgJ2NvbXBhcmUnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnc21hbGxlcicsXG4gICdjYXRlZ29yeSc6ICdSZWxhdGlvbmFsJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAneCA8IHknLFxuICAgICdzbWFsbGVyKHgsIHkpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ0NoZWNrIGlmIHZhbHVlIHggaXMgc21hbGxlciB0aGFuIHZhbHVlIHkuIFJldHVybnMgdHJ1ZSBpZiB4IGlzIHNtYWxsZXIgdGhhbiB5LCBhbmQgZmFsc2UgaWYgbm90LicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnMiA8IDMnLFxuICAgICc1IDwgMioyJyxcbiAgICAnYSA9IDMuMycsXG4gICAgJ2IgPSA2LTIuOCcsXG4gICAgJyhhIDwgYiknLFxuICAgICc1IGNtIDwgMiBpbmNoJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnZXF1YWwnLCAndW5lcXVhbCcsICdsYXJnZXInLCAnc21hbGxlckVxJywgJ2xhcmdlckVxJywgJ2NvbXBhcmUnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnc21hbGxlckVxJyxcbiAgJ2NhdGVnb3J5JzogJ1JlbGF0aW9uYWwnLFxuICAnc3ludGF4JzogW1xuICAgICd4IDw9IHknLFxuICAgICdzbWFsbGVyRXEoeCwgeSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6XG4gICAgICAnQ2hlY2sgaWYgdmFsdWUgeCBpcyBzbWFsbGVyIG9yIGVxdWFsIHRvIHZhbHVlIHkuIFJldHVybnMgdHJ1ZSBpZiB4IGlzIHNtYWxsZXIgdGhhbiB5LCBhbmQgZmFsc2UgaWYgbm90LicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnMiA8IDErMScsXG4gICAgJzIgPD0gMSsxJyxcbiAgICAnYSA9IDMuMicsXG4gICAgJ2IgPSA2LTIuOCcsXG4gICAgJyhhIDwgYiknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdlcXVhbCcsICd1bmVxdWFsJywgJ2xhcmdlcicsICdzbWFsbGVyJywgJ2xhcmdlckVxJywgJ2NvbXBhcmUnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAndW5lcXVhbCcsXG4gICdjYXRlZ29yeSc6ICdSZWxhdGlvbmFsJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAneCAhPSB5JyxcbiAgICAndW5lcXVhbCh4LCB5KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzpcbiAgICAgICdDaGVjayB1bmVxdWFsaXR5IG9mIHR3byB2YWx1ZXMuIFJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWVzIGFyZSB1bmVxdWFsLCBhbmQgZmFsc2UgaWYgdGhleSBhcmUgZXF1YWwuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICcyKzIgIT0gMycsXG4gICAgJzIrMiAhPSA0JyxcbiAgICAnYSA9IDMuMicsXG4gICAgJ2IgPSA2LTIuOCcsXG4gICAgJ2EgIT0gYicsXG4gICAgJzUwY20gIT0gMC41bScsXG4gICAgJzUgY20gIT0gMiBpbmNoJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnZXF1YWwnLCAnc21hbGxlcicsICdsYXJnZXInLCAnc21hbGxlckVxJywgJ2xhcmdlckVxJywgJ2NvbXBhcmUnLCAnZGVlcEVxdWFsJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ21heCcsXG4gICdjYXRlZ29yeSc6ICdTdGF0aXN0aWNzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnbWF4KGEsIGIsIGMsIC4uLiknLFxuICAgICdtYXgoQSknLFxuICAgICdtYXgoQSwgZGltKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NvbXB1dGUgdGhlIG1heGltdW0gdmFsdWUgb2YgYSBsaXN0IG9mIHZhbHVlcy4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ21heCgyLCAzLCA0LCAxKScsXG4gICAgJ21heChbMiwgMywgNCwgMV0pJyxcbiAgICAnbWF4KFsyLCA1OyA0LCAzXSknLFxuICAgICdtYXgoWzIsIDU7IDQsIDNdLCAxKScsXG4gICAgJ21heChbMiwgNTsgNCwgM10sIDIpJyxcbiAgICAnbWF4KDIuNywgNy4xLCAtNC41LCAyLjAsIDQuMSknLFxuICAgICdtaW4oMi43LCA3LjEsIC00LjUsIDIuMCwgNC4xKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ21lYW4nLFxuICAgICdtZWRpYW4nLFxuICAgICdtaW4nLFxuICAgICdwcm9kJyxcbiAgICAnc3RkJyxcbiAgICAnc3VtJyxcbiAgICAndmFyJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ21lYW4nLFxuICAnY2F0ZWdvcnknOiAnU3RhdGlzdGljcycsXG4gICdzeW50YXgnOiBbXG4gICAgJ21lYW4oYSwgYiwgYywgLi4uKScsXG4gICAgJ21lYW4oQSknLFxuICAgICdtZWFuKEEsIGRpbSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDb21wdXRlIHRoZSBhcml0aG1ldGljIG1lYW4gb2YgYSBsaXN0IG9mIHZhbHVlcy4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ21lYW4oMiwgMywgNCwgMSknLFxuICAgICdtZWFuKFsyLCAzLCA0LCAxXSknLFxuICAgICdtZWFuKFsyLCA1OyA0LCAzXSknLFxuICAgICdtZWFuKFsyLCA1OyA0LCAzXSwgMSknLFxuICAgICdtZWFuKFsyLCA1OyA0LCAzXSwgMiknLFxuICAgICdtZWFuKFsxLjAsIDIuNywgMy4yLCA0LjBdKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ21heCcsXG4gICAgJ21lZGlhbicsXG4gICAgJ21pbicsXG4gICAgJ3Byb2QnLFxuICAgICdzdGQnLFxuICAgICdzdW0nLFxuICAgICd2YXInXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnbWVkaWFuJyxcbiAgJ2NhdGVnb3J5JzogJ1N0YXRpc3RpY3MnLFxuICAnc3ludGF4JzogW1xuICAgICdtZWRpYW4oYSwgYiwgYywgLi4uKScsXG4gICAgJ21lZGlhbihBKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NvbXB1dGUgdGhlIG1lZGlhbiBvZiBhbGwgdmFsdWVzLiBUaGUgdmFsdWVzIGFyZSBzb3J0ZWQgYW5kIHRoZSBtaWRkbGUgdmFsdWUgaXMgcmV0dXJuZWQuIEluIGNhc2Ugb2YgYW4gZXZlbiBudW1iZXIgb2YgdmFsdWVzLCB0aGUgYXZlcmFnZSBvZiB0aGUgdHdvIG1pZGRsZSB2YWx1ZXMgaXMgcmV0dXJuZWQuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdtZWRpYW4oNSwgMiwgNyknLFxuICAgICdtZWRpYW4oWzMsIC0xLCA1LCA3XSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdtYXgnLFxuICAgICdtZWFuJyxcbiAgICAnbWluJyxcbiAgICAncHJvZCcsXG4gICAgJ3N0ZCcsXG4gICAgJ3N1bScsXG4gICAgJ3ZhcidcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdtaW4nLFxuICAnY2F0ZWdvcnknOiAnU3RhdGlzdGljcycsXG4gICdzeW50YXgnOiBbXG4gICAgJ21pbihhLCBiLCBjLCAuLi4pJyxcbiAgICAnbWluKEEpJyxcbiAgICAnbWluKEEsIGRpbSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDb21wdXRlIHRoZSBtaW5pbXVtIHZhbHVlIG9mIGEgbGlzdCBvZiB2YWx1ZXMuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdtaW4oMiwgMywgNCwgMSknLFxuICAgICdtaW4oWzIsIDMsIDQsIDFdKScsXG4gICAgJ21pbihbMiwgNTsgNCwgM10pJyxcbiAgICAnbWluKFsyLCA1OyA0LCAzXSwgMSknLFxuICAgICdtaW4oWzIsIDU7IDQsIDNdLCAyKScsXG4gICAgJ21pbigyLjcsIDcuMSwgLTQuNSwgMi4wLCA0LjEpJyxcbiAgICAnbWF4KDIuNywgNy4xLCAtNC41LCAyLjAsIDQuMSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdtYXgnLFxuICAgICdtZWFuJyxcbiAgICAnbWVkaWFuJyxcbiAgICAncHJvZCcsXG4gICAgJ3N0ZCcsXG4gICAgJ3N1bScsXG4gICAgJ3ZhcidcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdtb2RlJyxcbiAgJ2NhdGVnb3J5JzogJ1N0YXRpc3RpY3MnLFxuICAnc3ludGF4JzogW1xuICAgICdtb2RlKGEsIGIsIGMsIC4uLiknLFxuICAgICdtb2RlKEEpJyxcbiAgICAnbW9kZShBLCBhLCBiLCBCLCBjLCAuLi4pJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ29tcHV0ZXMgdGhlIG1vZGUgb2YgYWxsIHZhbHVlcyBhcyBhbiBhcnJheS4gSW4gY2FzZSBtb2RlIGJlaW5nIG1vcmUgdGhhbiBvbmUsIG11bHRpcGxlIHZhbHVlcyBhcmUgcmV0dXJuZWQgaW4gYW4gYXJyYXkuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdtb2RlKDUsIDIsIDcpJyxcbiAgICAnbW9kZShbMywgLTEsIDUsIDddKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ21heCcsXG4gICAgJ21lYW4nLFxuICAgICdtaW4nLFxuICAgICdtZWRpYW4nLFxuICAgICdwcm9kJyxcbiAgICAnc3RkJyxcbiAgICAnc3VtJyxcbiAgICAndmFyJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3Byb2QnLFxuICAnY2F0ZWdvcnknOiAnU3RhdGlzdGljcycsXG4gICdzeW50YXgnOiBbXG4gICAgJ3Byb2QoYSwgYiwgYywgLi4uKScsXG4gICAgJ3Byb2QoQSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDb21wdXRlIHRoZSBwcm9kdWN0IG9mIGFsbCB2YWx1ZXMuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdwcm9kKDIsIDMsIDQpJyxcbiAgICAncHJvZChbMiwgMywgNF0pJyxcbiAgICAncHJvZChbMiwgNTsgNCwgM10pJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnbWF4JyxcbiAgICAnbWVhbicsXG4gICAgJ21pbicsXG4gICAgJ21lZGlhbicsXG4gICAgJ21pbicsXG4gICAgJ3N0ZCcsXG4gICAgJ3N1bScsXG4gICAgJ3ZhcidcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdxdWFudGlsZVNlcScsXG4gICdjYXRlZ29yeSc6ICdTdGF0aXN0aWNzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAncXVhbnRpbGVTZXEoQSwgcHJvYlssIHNvcnRlZF0pJyxcbiAgICAncXVhbnRpbGVTZXEoQSwgW3Byb2IxLCBwcm9iMiwgLi4uXVssIHNvcnRlZF0pJyxcbiAgICAncXVhbnRpbGVTZXEoQSwgTlssIHNvcnRlZF0pJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ29tcHV0ZSB0aGUgcHJvYiBvcmRlciBxdWFudGlsZSBvZiBhIG1hdHJpeCBvciBhIGxpc3Qgd2l0aCB2YWx1ZXMuIFRoZSBzZXF1ZW5jZSBpcyBzb3J0ZWQgYW5kIHRoZSBtaWRkbGUgdmFsdWUgaXMgcmV0dXJuZWQuIFN1cHBvcnRlZCB0eXBlcyBvZiBzZXF1ZW5jZSB2YWx1ZXMgYXJlOiBOdW1iZXIsIEJpZ051bWJlciwgVW5pdCBTdXBwb3J0ZWQgdHlwZXMgb2YgcHJvYmFibGl0eSBhcmU6IE51bWJlciwgQmlnTnVtYmVyLiBcXG5cXG5JbiBjYXNlIG9mIGEgKG11bHRpIGRpbWVuc2lvbmFsKSBhcnJheSBvciBtYXRyaXgsIHRoZSBwcm9iIG9yZGVyIHF1YW50aWxlIG9mIGFsbCBlbGVtZW50cyB3aWxsIGJlIGNhbGN1bGF0ZWQuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdxdWFudGlsZVNlcShbMywgLTEsIDUsIDddLCAwLjUpJyxcbiAgICAncXVhbnRpbGVTZXEoWzMsIC0xLCA1LCA3XSwgWzEvMywgMi8zXSknLFxuICAgICdxdWFudGlsZVNlcShbMywgLTEsIDUsIDddLCAyKScsXG4gICAgJ3F1YW50aWxlU2VxKFstMSwgMywgNSwgN10sIDAuNSwgdHJ1ZSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdtZWFuJyxcbiAgICAnbWVkaWFuJyxcbiAgICAnbWluJyxcbiAgICAnbWF4JyxcbiAgICAncHJvZCcsXG4gICAgJ3N0ZCcsXG4gICAgJ3N1bScsXG4gICAgJ3ZhcidcbiAgXVxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnc3RkJyxcbiAgJ2NhdGVnb3J5JzogJ1N0YXRpc3RpY3MnLFxuICAnc3ludGF4JzogW1xuICAgICdzdGQoYSwgYiwgYywgLi4uKScsXG4gICAgJ3N0ZChBKScsXG4gICAgJ3N0ZChBLCBub3JtYWxpemF0aW9uKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NvbXB1dGUgdGhlIHN0YW5kYXJkIGRldmlhdGlvbiBvZiBhbGwgdmFsdWVzLCBkZWZpbmVkIGFzIHN0ZChBKSA9IHNxcnQodmFyKEEpKS4gT3B0aW9uYWwgcGFyYW1ldGVyIG5vcm1hbGl6YXRpb24gY2FuIGJlIFwidW5iaWFzZWRcIiAoZGVmYXVsdCksIFwidW5jb3JyZWN0ZWRcIiwgb3IgXCJiaWFzZWRcIi4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ3N0ZCgyLCA0LCA2KScsXG4gICAgJ3N0ZChbMiwgNCwgNiwgOF0pJyxcbiAgICAnc3RkKFsyLCA0LCA2LCA4XSwgXCJ1bmNvcnJlY3RlZFwiKScsXG4gICAgJ3N0ZChbMiwgNCwgNiwgOF0sIFwiYmlhc2VkXCIpJyxcbiAgICAnc3RkKFsxLCAyLCAzOyA0LCA1LCA2XSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdtYXgnLFxuICAgICdtZWFuJyxcbiAgICAnbWluJyxcbiAgICAnbWVkaWFuJyxcbiAgICAnbWluJyxcbiAgICAncHJvZCcsXG4gICAgJ3N1bScsXG4gICAgJ3ZhcidcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdzdW0nLFxuICAnY2F0ZWdvcnknOiAnU3RhdGlzdGljcycsXG4gICdzeW50YXgnOiBbXG4gICAgJ3N1bShhLCBiLCBjLCAuLi4pJyxcbiAgICAnc3VtKEEpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ29tcHV0ZSB0aGUgc3VtIG9mIGFsbCB2YWx1ZXMuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdzdW0oMiwgMywgNCwgMSknLFxuICAgICdzdW0oWzIsIDMsIDQsIDFdKScsXG4gICAgJ3N1bShbMiwgNTsgNCwgM10pJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnbWF4JyxcbiAgICAnbWVhbicsXG4gICAgJ21lZGlhbicsXG4gICAgJ21pbicsXG4gICAgJ3Byb2QnLFxuICAgICdzdGQnLFxuICAgICdzdW0nLFxuICAgICd2YXInXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAndmFyJyxcbiAgJ2NhdGVnb3J5JzogJ1N0YXRpc3RpY3MnLFxuICAnc3ludGF4JzogW1xuICAgICd2YXIoYSwgYiwgYywgLi4uKScsXG4gICAgJ3ZhcihBKScsXG4gICAgJ3ZhcihBLCBub3JtYWxpemF0aW9uKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NvbXB1dGUgdGhlIHZhcmlhbmNlIG9mIGFsbCB2YWx1ZXMuIE9wdGlvbmFsIHBhcmFtZXRlciBub3JtYWxpemF0aW9uIGNhbiBiZSBcInVuYmlhc2VkXCIgKGRlZmF1bHQpLCBcInVuY29ycmVjdGVkXCIsIG9yIFwiYmlhc2VkXCIuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICd2YXIoMiwgNCwgNiknLFxuICAgICd2YXIoWzIsIDQsIDYsIDhdKScsXG4gICAgJ3ZhcihbMiwgNCwgNiwgOF0sIFwidW5jb3JyZWN0ZWRcIiknLFxuICAgICd2YXIoWzIsIDQsIDYsIDhdLCBcImJpYXNlZFwiKScsXG4gICAgJ3ZhcihbMSwgMiwgMzsgNCwgNSwgNl0pJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnbWF4JyxcbiAgICAnbWVhbicsXG4gICAgJ21pbicsXG4gICAgJ21lZGlhbicsXG4gICAgJ21pbicsXG4gICAgJ3Byb2QnLFxuICAgICdzdGQnLFxuICAgICdzdW0nXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnYWNvcycsXG4gICdjYXRlZ29yeSc6ICdUcmlnb25vbWV0cnknLFxuICAnc3ludGF4JzogW1xuICAgICdhY29zKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ29tcHV0ZSB0aGUgaW52ZXJzZSBjb3NpbmUgb2YgYSB2YWx1ZSBpbiByYWRpYW5zLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnYWNvcygwLjUpJyxcbiAgICAnYWNvcyhjb3MoMi4zKSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdjb3MnLFxuICAgICdhdGFuJyxcbiAgICAnYXNpbidcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdhY29zaCcsXG4gICdjYXRlZ29yeSc6ICdUcmlnb25vbWV0cnknLFxuICAnc3ludGF4JzogW1xuICAgICdhY29zaCh4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NhbGN1bGF0ZSB0aGUgaHlwZXJib2xpYyBhcmNjb3Mgb2YgYSB2YWx1ZSwgZGVmaW5lZCBhcyBgYWNvc2goeCkgPSBsbihzcXJ0KHheMiAtIDEpICsgeClgLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnYWNvc2goMS41KSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2Nvc2gnLFxuICAgICdhc2luaCcsXG4gICAgJ2F0YW5oJ1xuICBdXG59OyIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdhY290JyxcbiAgJ2NhdGVnb3J5JzogJ1RyaWdvbm9tZXRyeScsXG4gICdzeW50YXgnOiBbXG4gICAgJ2Fjb3QoeCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDYWxjdWxhdGUgdGhlIGludmVyc2UgY290YW5nZW50IG9mIGEgdmFsdWUuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdhY290KDAuNSknLFxuICAgICdhY290KGNvdCgwLjUpKScsXG4gICAgJ2Fjb3QoMiknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdjb3QnLFxuICAgICdhdGFuJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2Fjb3RoJyxcbiAgJ2NhdGVnb3J5JzogJ1RyaWdvbm9tZXRyeScsXG4gICdzeW50YXgnOiBbXG4gICAgJ2Fjb3RoKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ2FsY3VsYXRlIHRoZSBoeXBlcmJvbGljIGFyY2NvdGFuZ2VudCBvZiBhIHZhbHVlLCBkZWZpbmVkIGFzIGBhY290aCh4KSA9IChsbigoeCsxKS94KSArIGxuKHgvKHgtMSkpKSAvIDJgLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnYWNvdGgoMC41KSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2Fjc2NoJyxcbiAgICAnYXNlY2gnXG4gIF1cbn07IiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2Fjc2MnLFxuICAnY2F0ZWdvcnknOiAnVHJpZ29ub21ldHJ5JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnYWNzYyh4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NhbGN1bGF0ZSB0aGUgaW52ZXJzZSBjb3RhbmdlbnQgb2YgYSB2YWx1ZS4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2Fjc2MoMC41KScsXG4gICAgJ2Fjc2MoY3NjKDAuNSkpJyxcbiAgICAnYWNzYygyKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2NzYycsXG4gICAgJ2FzaW4nLFxuICAgICdhc2VjJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2Fjc2NoJyxcbiAgJ2NhdGVnb3J5JzogJ1RyaWdvbm9tZXRyeScsXG4gICdzeW50YXgnOiBbXG4gICAgJ2Fjc2NoKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ2FsY3VsYXRlIHRoZSBoeXBlcmJvbGljIGFyY2Nvc2VjYW50IG9mIGEgdmFsdWUsIGRlZmluZWQgYXMgYGFjc2NoKHgpID0gbG4oMS94ICsgc3FydCgxL3heMiArIDEpKWAuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdhY3NjaCgwLjUpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnYXNlY2gnLFxuICAgICdhY290aCdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdhc2VjJyxcbiAgJ2NhdGVnb3J5JzogJ1RyaWdvbm9tZXRyeScsXG4gICdzeW50YXgnOiBbXG4gICAgJ2FzZWMoeCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDYWxjdWxhdGUgdGhlIGludmVyc2Ugc2VjYW50IG9mIGEgdmFsdWUuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdhc2VjKDAuNSknLFxuICAgICdhc2VjKHNlYygwLjUpKScsXG4gICAgJ2FzZWMoMiknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdhY29zJyxcbiAgICAnYWNvdCcsXG4gICAgJ2Fjc2MnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnYXNlY2gnLFxuICAnY2F0ZWdvcnknOiAnVHJpZ29ub21ldHJ5JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnYXNlY2goeCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDYWxjdWxhdGUgdGhlIGludmVyc2Ugc2VjYW50IG9mIGEgdmFsdWUuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdhc2VjaCgwLjUpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnYWNzY2gnLFxuICAgICdhY290aCdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdhc2luJyxcbiAgJ2NhdGVnb3J5JzogJ1RyaWdvbm9tZXRyeScsXG4gICdzeW50YXgnOiBbXG4gICAgJ2FzaW4oeCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDb21wdXRlIHRoZSBpbnZlcnNlIHNpbmUgb2YgYSB2YWx1ZSBpbiByYWRpYW5zLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnYXNpbigwLjUpJyxcbiAgICAnYXNpbihzaW4oMi4zKSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdzaW4nLFxuICAgICdhY29zJyxcbiAgICAnYXRhbidcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdhc2luaCcsXG4gICdjYXRlZ29yeSc6ICdUcmlnb25vbWV0cnknLFxuICAnc3ludGF4JzogW1xuICAgICdhc2luaCh4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NhbGN1bGF0ZSB0aGUgaHlwZXJib2xpYyBhcmNzaW5lIG9mIGEgdmFsdWUsIGRlZmluZWQgYXMgYGFzaW5oKHgpID0gbG4oeCArIHNxcnQoeF4yICsgMSkpYC4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2FzaW5oKDAuNSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdhY29zaCcsXG4gICAgJ2F0YW5oJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2F0YW4nLFxuICAnY2F0ZWdvcnknOiAnVHJpZ29ub21ldHJ5JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnYXRhbih4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NvbXB1dGUgdGhlIGludmVyc2UgdGFuZ2VudCBvZiBhIHZhbHVlIGluIHJhZGlhbnMuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdhdGFuKDAuNSknLFxuICAgICdhdGFuKHRhbigyLjMpKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ3RhbicsXG4gICAgJ2Fjb3MnLFxuICAgICdhc2luJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2F0YW4yJyxcbiAgJ2NhdGVnb3J5JzogJ1RyaWdvbm9tZXRyeScsXG4gICdzeW50YXgnOiBbXG4gICAgJ2F0YW4yKHksIHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ0NvbXB1dGVzIHRoZSBwcmluY2lwYWwgdmFsdWUgb2YgdGhlIGFyYyB0YW5nZW50IG9mIHkveCBpbiByYWRpYW5zLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnYXRhbjIoMiwgMikgLyBwaScsXG4gICAgJ2FuZ2xlID0gNjAgZGVnIGluIHJhZCcsXG4gICAgJ3ggPSBjb3MoYW5nbGUpJyxcbiAgICAneSA9IHNpbihhbmdsZSknLFxuICAgICdhdGFuMih5LCB4KSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ3NpbicsXG4gICAgJ2NvcycsXG4gICAgJ3RhbidcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdhdGFuaCcsXG4gICdjYXRlZ29yeSc6ICdUcmlnb25vbWV0cnknLFxuICAnc3ludGF4JzogW1xuICAgICdhdGFuaCh4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NhbGN1bGF0ZSB0aGUgaHlwZXJib2xpYyBhcmN0YW5nZW50IG9mIGEgdmFsdWUsIGRlZmluZWQgYXMgYGF0YW5oKHgpID0gbG4oKDEgKyB4KS8oMSAtIHgpKSAvIDJgLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnYXRhbmgoMC41KSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2Fjb3NoJyxcbiAgICAnYXNpbmgnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnY29zJyxcbiAgJ2NhdGVnb3J5JzogJ1RyaWdvbm9tZXRyeScsXG4gICdzeW50YXgnOiBbXG4gICAgJ2Nvcyh4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NvbXB1dGUgdGhlIGNvc2luZSBvZiB4IGluIHJhZGlhbnMuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdjb3MoMiknLFxuICAgICdjb3MocGkgLyA0KSBeIDInLFxuICAgICdjb3MoMTgwIGRlZyknLFxuICAgICdjb3MoNjAgZGVnKScsXG4gICAgJ3NpbigwLjIpXjIgKyBjb3MoMC4yKV4yJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnYWNvcycsXG4gICAgJ3NpbicsXG4gICAgJ3RhbidcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICduYW1lJzogJ2Nvc2gnLFxyXG4gICdjYXRlZ29yeSc6ICdUcmlnb25vbWV0cnknLFxyXG4gICdzeW50YXgnOiBbXHJcbiAgICAnY29zaCh4KSdcclxuICBdLFxyXG4gICdkZXNjcmlwdGlvbic6ICdDb21wdXRlIHRoZSBoeXBlcmJvbGljIGNvc2luZSBvZiB4IGluIHJhZGlhbnMuJyxcclxuICAnZXhhbXBsZXMnOiBbXHJcbiAgICAnY29zaCgwLjUpJ1xyXG4gIF0sXHJcbiAgJ3NlZWFsc28nOiBbXHJcbiAgICAnc2luaCcsXHJcbiAgICAndGFuaCcsXHJcbiAgICAnY290aCdcclxuICBdXHJcbn07XHJcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdjb3QnLFxuICAnY2F0ZWdvcnknOiAnVHJpZ29ub21ldHJ5JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnY290KHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ29tcHV0ZSB0aGUgY290YW5nZW50IG9mIHggaW4gcmFkaWFucy4gRGVmaW5lZCBhcyAxL3Rhbih4KScsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnY290KDIpJyxcbiAgICAnMSAvIHRhbigyKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ3NlYycsXG4gICAgJ2NzYycsXG4gICAgJ3RhbidcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICduYW1lJzogJ2NvdGgnLFxyXG4gICdjYXRlZ29yeSc6ICdUcmlnb25vbWV0cnknLFxyXG4gICdzeW50YXgnOiBbXHJcbiAgICAnY290aCh4KSdcclxuICBdLFxyXG4gICdkZXNjcmlwdGlvbic6ICdDb21wdXRlIHRoZSBoeXBlcmJvbGljIGNvdGFuZ2VudCBvZiB4IGluIHJhZGlhbnMuJyxcclxuICAnZXhhbXBsZXMnOiBbXHJcbiAgICAnY290aCgyKScsXHJcbiAgICAnMSAvIHRhbmgoMiknXHJcbiAgXSxcclxuICAnc2VlYWxzbyc6IFtcclxuICAgICdzZWNoJyxcclxuICAgICdjc2NoJyxcclxuICAgICd0YW5oJ1xyXG4gIF1cclxufTtcclxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2NzYycsXG4gICdjYXRlZ29yeSc6ICdUcmlnb25vbWV0cnknLFxuICAnc3ludGF4JzogW1xuICAgICdjc2MoeCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDb21wdXRlIHRoZSBjb3NlY2FudCBvZiB4IGluIHJhZGlhbnMuIERlZmluZWQgYXMgMS9zaW4oeCknLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2NzYygyKScsXG4gICAgJzEgLyBzaW4oMiknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdzZWMnLFxuICAgICdjb3QnLFxuICAgICdzaW4nXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAnbmFtZSc6ICdjc2NoJyxcclxuICAnY2F0ZWdvcnknOiAnVHJpZ29ub21ldHJ5JyxcclxuICAnc3ludGF4JzogW1xyXG4gICAgJ2NzY2goeCknXHJcbiAgXSxcclxuICAnZGVzY3JpcHRpb24nOiAnQ29tcHV0ZSB0aGUgaHlwZXJib2xpYyBjb3NlY2FudCBvZiB4IGluIHJhZGlhbnMuIERlZmluZWQgYXMgMS9zaW5oKHgpJyxcclxuICAnZXhhbXBsZXMnOiBbXHJcbiAgICAnY3NjaCgyKScsXHJcbiAgICAnMSAvIHNpbmgoMiknXHJcbiAgXSxcclxuICAnc2VlYWxzbyc6IFtcclxuICAgICdzZWNoJyxcclxuICAgICdjb3RoJyxcclxuICAgICdzaW5oJ1xyXG4gIF1cclxufTtcclxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3NlYycsXG4gICdjYXRlZ29yeSc6ICdUcmlnb25vbWV0cnknLFxuICAnc3ludGF4JzogW1xuICAgICdzZWMoeCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDb21wdXRlIHRoZSBzZWNhbnQgb2YgeCBpbiByYWRpYW5zLiBEZWZpbmVkIGFzIDEvY29zKHgpJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdzZWMoMiknLFxuICAgICcxIC8gY29zKDIpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnY290JyxcbiAgICAnY3NjJyxcbiAgICAnY29zJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgJ25hbWUnOiAnc2VjaCcsXHJcbiAgJ2NhdGVnb3J5JzogJ1RyaWdvbm9tZXRyeScsXHJcbiAgJ3N5bnRheCc6IFtcclxuICAgICdzZWNoKHgpJ1xyXG4gIF0sXHJcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NvbXB1dGUgdGhlIGh5cGVyYm9saWMgc2VjYW50IG9mIHggaW4gcmFkaWFucy4gRGVmaW5lZCBhcyAxL2Nvc2goeCknLFxyXG4gICdleGFtcGxlcyc6IFtcclxuICAgICdzZWNoKDIpJyxcclxuICAgICcxIC8gY29zaCgyKSdcclxuICBdLFxyXG4gICdzZWVhbHNvJzogW1xyXG4gICAgJ2NvdGgnLFxyXG4gICAgJ2NzY2gnLFxyXG4gICAgJ2Nvc2gnXHJcbiAgXVxyXG59O1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnc2luJyxcbiAgJ2NhdGVnb3J5JzogJ1RyaWdvbm9tZXRyeScsXG4gICdzeW50YXgnOiBbXG4gICAgJ3Npbih4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NvbXB1dGUgdGhlIHNpbmUgb2YgeCBpbiByYWRpYW5zLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnc2luKDIpJyxcbiAgICAnc2luKHBpIC8gNCkgXiAyJyxcbiAgICAnc2luKDkwIGRlZyknLFxuICAgICdzaW4oMzAgZGVnKScsXG4gICAgJ3NpbigwLjIpXjIgKyBjb3MoMC4yKV4yJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnYXNpbicsXG4gICAgJ2NvcycsXG4gICAgJ3RhbidcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICduYW1lJzogJ3NpbmgnLFxyXG4gICdjYXRlZ29yeSc6ICdUcmlnb25vbWV0cnknLFxyXG4gICdzeW50YXgnOiBbXHJcbiAgICAnc2luaCh4KSdcclxuICBdLFxyXG4gICdkZXNjcmlwdGlvbic6ICdDb21wdXRlIHRoZSBoeXBlcmJvbGljIHNpbmUgb2YgeCBpbiByYWRpYW5zLicsXHJcbiAgJ2V4YW1wbGVzJzogW1xyXG4gICAgJ3NpbmgoMC41KSdcclxuICBdLFxyXG4gICdzZWVhbHNvJzogW1xyXG4gICAgJ2Nvc2gnLFxyXG4gICAgJ3RhbmgnXHJcbiAgXVxyXG59O1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAndGFuJyxcbiAgJ2NhdGVnb3J5JzogJ1RyaWdvbm9tZXRyeScsXG4gICdzeW50YXgnOiBbXG4gICAgJ3Rhbih4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NvbXB1dGUgdGhlIHRhbmdlbnQgb2YgeCBpbiByYWRpYW5zLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAndGFuKDAuNSknLFxuICAgICdzaW4oMC41KSAvIGNvcygwLjUpJyxcbiAgICAndGFuKHBpIC8gNCknLFxuICAgICd0YW4oNDUgZGVnKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2F0YW4nLFxuICAgICdzaW4nLFxuICAgICdjb3MnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAnbmFtZSc6ICd0YW5oJyxcclxuICAnY2F0ZWdvcnknOiAnVHJpZ29ub21ldHJ5JyxcclxuICAnc3ludGF4JzogW1xyXG4gICAgJ3RhbmgoeCknXHJcbiAgXSxcclxuICAnZGVzY3JpcHRpb24nOiAnQ29tcHV0ZSB0aGUgaHlwZXJib2xpYyB0YW5nZW50IG9mIHggaW4gcmFkaWFucy4nLFxyXG4gICdleGFtcGxlcyc6IFtcclxuICAgICd0YW5oKDAuNSknLFxyXG4gICAgJ3NpbmgoMC41KSAvIGNvc2goMC41KSdcclxuICBdLFxyXG4gICdzZWVhbHNvJzogW1xyXG4gICAgJ3NpbmgnLFxyXG4gICAgJ2Nvc2gnXHJcbiAgXVxyXG59O1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAndG8nLFxuICAnY2F0ZWdvcnknOiAnVW5pdHMnLFxuICAnc3ludGF4JzogW1xuICAgICd4IHRvIHVuaXQnLFxuICAgICd0byh4LCB1bml0KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NoYW5nZSB0aGUgdW5pdCBvZiBhIHZhbHVlLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnNSBpbmNoIHRvIGNtJyxcbiAgICAnMy4ya2cgdG8gZycsXG4gICAgJzE2IGJ5dGVzIGluIGJpdHMnXG4gIF0sXG4gICdzZWVhbHNvJzogW11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnY2xvbmUnLFxuICAnY2F0ZWdvcnknOiAnVXRpbHMnLFxuICAnc3ludGF4JzogW1xuICAgICdjbG9uZSh4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0Nsb25lIGEgdmFyaWFibGUuIENyZWF0ZXMgYSBjb3B5IG9mIHByaW1pdGl2ZSB2YXJpYWJsZXMsYW5kIGEgZGVlcCBjb3B5IG9mIG1hdHJpY2VzJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdjbG9uZSgzLjUpJyxcbiAgICAnY2xvbmUoMiAtIDRpKScsXG4gICAgJ2Nsb25lKDQ1IGRlZyknLFxuICAgICdjbG9uZShbMSwgMjsgMywgNF0pJyxcbiAgICAnY2xvbmUoXCJoZWxsbyB3b3JsZFwiKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdmb3JtYXQnLFxuICAnY2F0ZWdvcnknOiAnVXRpbHMnLFxuICAnc3ludGF4JzogW1xuICAgICdmb3JtYXQodmFsdWUpJyxcbiAgICAnZm9ybWF0KHZhbHVlLCBwcmVjaXNpb24pJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnRm9ybWF0IGEgdmFsdWUgb2YgYW55IHR5cGUgYXMgc3RyaW5nLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnZm9ybWF0KDIuMyknLFxuICAgICdmb3JtYXQoMyAtIDRpKScsXG4gICAgJ2Zvcm1hdChbXSknLFxuICAgICdmb3JtYXQocGksIDMpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFsncHJpbnQnXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdpc0ludGVnZXInLFxuICAnY2F0ZWdvcnknOiAnVXRpbHMnLFxuICAnc3ludGF4JzogW1xuICAgICdpc0ludGVnZXIoeCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdUZXN0IHdoZXRoZXIgYSB2YWx1ZSBpcyBhbiBpbnRlZ2VyIG51bWJlci4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2lzSW50ZWdlcigyKScsXG4gICAgJ2lzSW50ZWdlcigzLjUpJyxcbiAgICAnaXNJbnRlZ2VyKFszLCAwLjUsIC0yXSknXG4gIF0sXG4gICdzZWVhbHNvJzogWydpc05lZ2F0aXZlJywgJ2lzTnVtZXJpYycsICdpc1Bvc2l0aXZlJywgJ2lzWmVybyddXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2lzTmVnYXRpdmUnLFxuICAnY2F0ZWdvcnknOiAnVXRpbHMnLFxuICAnc3ludGF4JzogW1xuICAgICdpc05lZ2F0aXZlKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnVGVzdCB3aGV0aGVyIGEgdmFsdWUgaXMgbmVnYXRpdmU6IHNtYWxsZXIgdGhhbiB6ZXJvLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnaXNOZWdhdGl2ZSgyKScsXG4gICAgJ2lzTmVnYXRpdmUoMCknLFxuICAgICdpc05lZ2F0aXZlKC00KScsXG4gICAgJ2lzTmVnYXRpdmUoWzMsIDAuNSwgLTJdKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbJ2lzSW50ZWdlcicsICdpc051bWVyaWMnLCAnaXNQb3NpdGl2ZScsICdpc1plcm8nXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdpc051bWVyaWMnLFxuICAnY2F0ZWdvcnknOiAnVXRpbHMnLFxuICAnc3ludGF4JzogW1xuICAgICdpc051bWVyaWMoeCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdUZXN0IHdoZXRoZXIgYSB2YWx1ZSBpcyBhIG51bWVyaWMgdmFsdWUuICcgK1xuICAgICdSZXR1cm5zIHRydWUgd2hlbiB0aGUgaW5wdXQgaXMgYSBudW1iZXIsIEJpZ051bWJlciwgRnJhY3Rpb24sIG9yIGJvb2xlYW4uJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdpc051bWVyaWMoMiknLFxuICAgICdpc051bWVyaWMoMCknLFxuICAgICdpc051bWVyaWMoYmlnbnVtYmVyKDUwMCkpJyxcbiAgICAnaXNOdW1lcmljKGZyYWN0aW9uKDAuMTI1KSknLFxuICAgICdpc051bWVyaWMoXCIzXCIpJyxcbiAgICAnaXNOdW1lcmljKDIgKyAzaSknLFxuICAgICdpc051bWVyaWMoWzIuMywgXCJmb29cIiwgZmFsc2VdKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbJ2lzSW50ZWdlcicsICdpc1plcm8nLCAnaXNOZWdhdGl2ZScsICdpc1Bvc2l0aXZlJ11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnaXNQb3NpdGl2ZScsXG4gICdjYXRlZ29yeSc6ICdVdGlscycsXG4gICdzeW50YXgnOiBbXG4gICAgJ2lzUG9zaXRpdmUoeCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdUZXN0IHdoZXRoZXIgYSB2YWx1ZSBpcyBwb3NpdGl2ZTogbGFyZ2VyIHRoYW4gemVyby4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2lzUG9zaXRpdmUoMiknLFxuICAgICdpc1Bvc2l0aXZlKDApJyxcbiAgICAnaXNQb3NpdGl2ZSgtNCknLFxuICAgICdpc1Bvc2l0aXZlKFszLCAwLjUsIC0yXSknXG4gIF0sXG4gICdzZWVhbHNvJzogWydpc0ludGVnZXInLCAnaXNOdW1lcmljJywgJ2lzTmVnYXRpdmUnLCAnaXNaZXJvJ11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnaXNaZXJvJyxcbiAgJ2NhdGVnb3J5JzogJ1V0aWxzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnaXNaZXJvKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnVGVzdCB3aGV0aGVyIGEgdmFsdWUgaXMgemVyby4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2lzWmVybygyKScsXG4gICAgJ2lzWmVybygwKScsXG4gICAgJ2lzWmVybygtNCknLFxuICAgICdpc1plcm8oWzMsIDAsIC0yLCAwXSknXG4gIF0sXG4gICdzZWVhbHNvJzogWydpc0ludGVnZXInLCAnaXNOdW1lcmljJywgJ2lzTmVnYXRpdmUnLCAnaXNQb3NpdGl2ZSddXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3R5cGVvZicsXG4gICdjYXRlZ29yeSc6ICdVdGlscycsXG4gICdzeW50YXgnOiBbXG4gICAgJ3R5cGVvZih4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0dldCB0aGUgdHlwZSBvZiBhIHZhcmlhYmxlLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAndHlwZW9mKDMuNSknLFxuICAgICd0eXBlb2YoMiAtIDRpKScsXG4gICAgJ3R5cGVvZig0NSBkZWcpJyxcbiAgICAndHlwZW9mKFwiaGVsbG8gd29ybGRcIiknXG4gIF0sXG4gICdzZWVhbHNvJzogW11cbn07XG4iLCJmdW5jdGlvbiBmYWN0b3J5IChjb25zdHJ1Y3Rpb24sIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIGRvY3MgPSB7fTtcblxuXG4gIC8vIGNvbnN0cnVjdGlvbiBmdW5jdGlvbnNcbiAgZG9jcy5iaWdudW1iZXIgPSByZXF1aXJlKCcuL2NvbnN0cnVjdGlvbi9iaWdudW1iZXInKTtcbiAgZG9jc1snYm9vbGVhbiddID0gcmVxdWlyZSgnLi9jb25zdHJ1Y3Rpb24vYm9vbGVhbicpO1xuICBkb2NzLmNvbXBsZXggPSByZXF1aXJlKCcuL2NvbnN0cnVjdGlvbi9jb21wbGV4Jyk7XG4gIGRvY3MuZnJhY3Rpb24gPSByZXF1aXJlKCcuL2NvbnN0cnVjdGlvbi9mcmFjdGlvbicpO1xuICBkb2NzLmluZGV4ID0gcmVxdWlyZSgnLi9jb25zdHJ1Y3Rpb24vaW5kZXgnKTtcbiAgZG9jcy5tYXRyaXggPSByZXF1aXJlKCcuL2NvbnN0cnVjdGlvbi9tYXRyaXgnKTtcbiAgZG9jcy5udW1iZXIgPSByZXF1aXJlKCcuL2NvbnN0cnVjdGlvbi9udW1iZXInKTtcbiAgZG9jcy5zcGFyc2UgPSByZXF1aXJlKCcuL2NvbnN0cnVjdGlvbi9zcGFyc2UnKTtcbiAgZG9jcy5zdHJpbmcgPSByZXF1aXJlKCcuL2NvbnN0cnVjdGlvbi9zdHJpbmcnKTtcbiAgZG9jcy51bml0ID0gcmVxdWlyZSgnLi9jb25zdHJ1Y3Rpb24vdW5pdCcpO1xuXG4gIC8vIGNvbnN0YW50c1xuICBkb2NzLmUgPSByZXF1aXJlKCcuL2NvbnN0YW50cy9lJyk7XG4gIGRvY3MuRSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzL2UnKTtcbiAgZG9jc1snZmFsc2UnXSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzL2ZhbHNlJyk7XG4gIGRvY3MuaSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzL2knKTtcbiAgZG9jc1snSW5maW5pdHknXSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzL0luZmluaXR5Jyk7XG4gIGRvY3MuTE4yID0gcmVxdWlyZSgnLi9jb25zdGFudHMvTE4yJyk7XG4gIGRvY3MuTE4xMCA9IHJlcXVpcmUoJy4vY29uc3RhbnRzL0xOMTAnKTtcbiAgZG9jcy5MT0cyRSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzL0xPRzJFJyk7XG4gIGRvY3MuTE9HMTBFID0gcmVxdWlyZSgnLi9jb25zdGFudHMvTE9HMTBFJyk7XG4gIGRvY3MuTmFOID0gcmVxdWlyZSgnLi9jb25zdGFudHMvTmFOJyk7XG4gIGRvY3NbJ251bGwnXSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzL251bGwnKTtcbiAgZG9jcy5waSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzL3BpJyk7XG4gIGRvY3MuUEkgPSByZXF1aXJlKCcuL2NvbnN0YW50cy9waScpO1xuICBkb2NzLnBoaSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzL3BoaScpO1xuICBkb2NzLlNRUlQxXzIgPSByZXF1aXJlKCcuL2NvbnN0YW50cy9TUVJUMV8yJyk7XG4gIGRvY3MuU1FSVDIgPSByZXF1aXJlKCcuL2NvbnN0YW50cy9TUVJUMicpO1xuICBkb2NzLnRhdSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzL3RhdScpO1xuICBkb2NzWyd0cnVlJ10gPSByZXF1aXJlKCcuL2NvbnN0YW50cy90cnVlJyk7XG4gIGRvY3MudmVyc2lvbiA9IHJlcXVpcmUoJy4vY29uc3RhbnRzL3ZlcnNpb24nKTtcblxuICAvLyBwaHlzaWNhbCBjb25zdGFudHNcbiAgLy8gVE9ETzogbW9yZSBkZXRhaWxlZCBkb2NzIGZvciBwaHlzaWNhbCBjb25zdGFudHNcbiAgZG9jcy5zcGVlZE9mTGlnaHQgPSB7ZGVzY3JpcHRpb246ICdTcGVlZCBvZiBsaWdodCBpbiB2YWN1dW0nLCBleGFtcGxlczogWydzcGVlZE9mTGlnaHQnXX07XG4gIGRvY3MuZ3Jhdml0YXRpb25Db25zdGFudCA9IHtkZXNjcmlwdGlvbjogJ05ld3RvbmlhbiBjb25zdGFudCBvZiBncmF2aXRhdGlvbicsIGV4YW1wbGVzOiBbJ2dyYXZpdGF0aW9uQ29uc3RhbnQnXX07XG4gIGRvY3MucGxhbmNrQ29uc3RhbnQgPSB7ZGVzY3JpcHRpb246ICdQbGFuY2sgY29uc3RhbnQnLCBleGFtcGxlczogWydwbGFuY2tDb25zdGFudCddfTtcbiAgZG9jcy5yZWR1Y2VkUGxhbmNrQ29uc3RhbnQgPSB7ZGVzY3JpcHRpb246ICdSZWR1Y2VkIFBsYW5jayBjb25zdGFudCcsIGV4YW1wbGVzOiBbJ3JlZHVjZWRQbGFuY2tDb25zdGFudCddfTtcblxuICBkb2NzLm1hZ25ldGljQ29uc3RhbnQgPSB7ZGVzY3JpcHRpb246ICdNYWduZXRpYyBjb25zdGFudCAodmFjdXVtIHBlcm1lYWJpbGl0eSknLCBleGFtcGxlczogWydtYWduZXRpY0NvbnN0YW50J119O1xuICBkb2NzLmVsZWN0cmljQ29uc3RhbnQgPSB7ZGVzY3JpcHRpb246ICdFbGVjdHJpYyBjb25zdGFudCAodmFjdXVtIHBlcm1lYWJpbGl0eSknLCBleGFtcGxlczogWydlbGVjdHJpY0NvbnN0YW50J119O1xuICBkb2NzLnZhY3V1bUltcGVkYW5jZSA9IHtkZXNjcmlwdGlvbjogJ0NoYXJhY3RlcmlzdGljIGltcGVkYW5jZSBvZiB2YWN1dW0nLCBleGFtcGxlczogWyd2YWN1dW1JbXBlZGFuY2UnXX07XG4gIGRvY3MuY291bG9tYiA9IHtkZXNjcmlwdGlvbjogJ0NvdWxvbWJcXCdzIGNvbnN0YW50JywgZXhhbXBsZXM6IFsnY291bG9tYiddfTtcbiAgZG9jcy5lbGVtZW50YXJ5Q2hhcmdlID0ge2Rlc2NyaXB0aW9uOiAnRWxlbWVudGFyeSBjaGFyZ2UnLCBleGFtcGxlczogWydlbGVtZW50YXJ5Q2hhcmdlJ119O1xuICBkb2NzLmJvaHJNYWduZXRvbiA9IHtkZXNjcmlwdGlvbjogJ0JvcmggbWFnbmV0b24nLCBleGFtcGxlczogWydib2hyTWFnbmV0b24nXX07XG4gIGRvY3MuY29uZHVjdGFuY2VRdWFudHVtID0ge2Rlc2NyaXB0aW9uOiAnQ29uZHVjdGFuY2UgcXVhbnR1bScsIGV4YW1wbGVzOiBbJ2NvbmR1Y3RhbmNlUXVhbnR1bSddfTtcbiAgZG9jcy5pbnZlcnNlQ29uZHVjdGFuY2VRdWFudHVtID0ge2Rlc2NyaXB0aW9uOiAnSW52ZXJzZSBjb25kdWN0YW5jZSBxdWFudHVtJywgZXhhbXBsZXM6IFsnaW52ZXJzZUNvbmR1Y3RhbmNlUXVhbnR1bSddfTtcbiAgLy9kb2NzLmpvc2VwaHNvbiA9IHtkZXNjcmlwdGlvbjogJ0pvc2VwaHNvbiBjb25zdGFudCcsIGV4YW1wbGVzOiBbJ2pvc2VwaHNvbiddfTtcbiAgZG9jcy5tYWduZXRpY0ZsdXhRdWFudHVtID0ge2Rlc2NyaXB0aW9uOiAnTWFnbmV0aWMgZmx1eCBxdWFudHVtJywgZXhhbXBsZXM6IFsnbWFnbmV0aWNGbHV4UXVhbnR1bSddfTtcbiAgZG9jcy5udWNsZWFyTWFnbmV0b24gPSB7ZGVzY3JpcHRpb246ICdOdWNsZWFyIG1hZ25ldG9uJywgZXhhbXBsZXM6IFsnbnVjbGVhck1hZ25ldG9uJ119O1xuICBkb2NzLmtsaXR6aW5nID0ge2Rlc2NyaXB0aW9uOiAnVm9uIEtsaXR6aW5nIGNvbnN0YW50JywgZXhhbXBsZXM6IFsna2xpdHppbmcnXX07XG5cbiAgZG9jcy5ib2hyUmFkaXVzID0ge2Rlc2NyaXB0aW9uOiAnQm9yaCByYWRpdXMnLCBleGFtcGxlczogWydib2hyUmFkaXVzJ119O1xuICBkb2NzLmNsYXNzaWNhbEVsZWN0cm9uUmFkaXVzID0ge2Rlc2NyaXB0aW9uOiAnQ2xhc3NpY2FsIGVsZWN0cm9uIHJhZGl1cycsIGV4YW1wbGVzOiBbJ2NsYXNzaWNhbEVsZWN0cm9uUmFkaXVzJ119O1xuICBkb2NzLmVsZWN0cm9uTWFzcyA9IHtkZXNjcmlwdGlvbjogJ0VsZWN0cm9uIG1hc3MnLCBleGFtcGxlczogWydlbGVjdHJvbk1hc3MnXX07XG4gIGRvY3MuZmVybWlDb3VwbGluZyA9IHtkZXNjcmlwdGlvbjogJ0Zlcm1pIGNvdXBsaW5nIGNvbnN0YW50JywgZXhhbXBsZXM6IFsnZmVybWlDb3VwbGluZyddfTtcbiAgZG9jcy5maW5lU3RydWN0dXJlID0ge2Rlc2NyaXB0aW9uOiAnRmluZS1zdHJ1Y3R1cmUgY29uc3RhbnQnLCBleGFtcGxlczogWydmaW5lU3RydWN0dXJlJ119O1xuICBkb2NzLmhhcnRyZWVFbmVyZ3kgPSB7ZGVzY3JpcHRpb246ICdIYXJ0cmVlIGVuZXJneScsIGV4YW1wbGVzOiBbJ2hhcnRyZWVFbmVyZ3knXX07XG4gIGRvY3MucHJvdG9uTWFzcyA9IHtkZXNjcmlwdGlvbjogJ1Byb3RvbiBtYXNzJywgZXhhbXBsZXM6IFsncHJvdG9uTWFzcyddfTtcbiAgZG9jcy5kZXV0ZXJvbk1hc3MgPSB7ZGVzY3JpcHRpb246ICdEZXV0ZXJvbiBNYXNzJywgZXhhbXBsZXM6IFsnZGV1dGVyb25NYXNzJ119O1xuICBkb2NzLm5ldXRyb25NYXNzID0ge2Rlc2NyaXB0aW9uOiAnTmV1dHJvbiBtYXNzJywgZXhhbXBsZXM6IFsnbmV1dHJvbk1hc3MnXX07XG4gIGRvY3MucXVhbnR1bU9mQ2lyY3VsYXRpb24gPSB7ZGVzY3JpcHRpb246ICdRdWFudHVtIG9mIGNpcmN1bGF0aW9uJywgZXhhbXBsZXM6IFsncXVhbnR1bU9mQ2lyY3VsYXRpb24nXX07XG4gIGRvY3MucnlkYmVyZyA9IHtkZXNjcmlwdGlvbjogJ1J5ZGJlcmcgY29uc3RhbnQnLCBleGFtcGxlczogWydyeWRiZXJnJ119O1xuICBkb2NzLnRob21zb25Dcm9zc1NlY3Rpb24gPSB7ZGVzY3JpcHRpb246ICdUaG9tc29uIGNyb3NzIHNlY3Rpb24nLCBleGFtcGxlczogWyd0aG9tc29uQ3Jvc3NTZWN0aW9uJ119O1xuICBkb2NzLndlYWtNaXhpbmdBbmdsZSA9IHtkZXNjcmlwdGlvbjogJ1dlYWsgbWl4aW5nIGFuZ2xlJywgZXhhbXBsZXM6IFsnd2Vha01peGluZ0FuZ2xlJ119O1xuICBkb2NzLmVmaW1vdkZhY3RvciA9IHtkZXNjcmlwdGlvbjogJ0VmaW1vdiBmYWN0b3InLCBleGFtcGxlczogWydlZmltb3ZGYWN0b3InXX07XG5cbiAgZG9jcy5hdG9taWNNYXNzID0ge2Rlc2NyaXB0aW9uOiAnQXRvbWljIG1hc3MgY29uc3RhbnQnLCBleGFtcGxlczogWydhdG9taWNNYXNzJ119O1xuICBkb2NzLmF2b2dhZHJvID0ge2Rlc2NyaXB0aW9uOiAnQXZvZ2Fkcm9cXCdzIG51bWJlcicsIGV4YW1wbGVzOiBbJ2F2b2dhZHJvJ119O1xuICBkb2NzLmJvbHR6bWFubiA9IHtkZXNjcmlwdGlvbjogJ0JvbHR6bWFubiBjb25zdGFudCcsIGV4YW1wbGVzOiBbJ2JvbHR6bWFubiddfTtcbiAgZG9jcy5mYXJhZGF5ID0ge2Rlc2NyaXB0aW9uOiAnRmFyYWRheSBjb25zdGFudCcsIGV4YW1wbGVzOiBbJ2ZhcmFkYXknXX07XG4gIGRvY3MuZmlyc3RSYWRpYXRpb24gPSB7ZGVzY3JpcHRpb246ICdGaXJzdCByYWRpYXRpb24gY29uc3RhbnQnLCBleGFtcGxlczogWydmaXJzdFJhZGlhdGlvbiddfTtcbiAgZG9jcy5sb3NjaG1pZHQgPSB7ZGVzY3JpcHRpb246ICdMb3NjaG1pZHQgY29uc3RhbnQgYXQgVD0yNzMuMTUgSyBhbmQgcD0xMDEuMzI1IGtQYScsIGV4YW1wbGVzOiBbJ2xvc2NobWlkdCddfTtcbiAgZG9jcy5nYXNDb25zdGFudCA9IHtkZXNjcmlwdGlvbjogJ0dhcyBjb25zdGFudCcsIGV4YW1wbGVzOiBbJ2dhc0NvbnN0YW50J119O1xuICBkb2NzLm1vbGFyUGxhbmNrQ29uc3RhbnQgPSB7ZGVzY3JpcHRpb246ICdNb2xhciBQbGFuY2sgY29uc3RhbnQnLCBleGFtcGxlczogWydtb2xhclBsYW5ja0NvbnN0YW50J119O1xuICBkb2NzLm1vbGFyVm9sdW1lID0ge2Rlc2NyaXB0aW9uOiAnTW9sYXIgdm9sdW1lIG9mIGFuIGlkZWFsIGdhcyBhdCBUPTI3My4xNSBLIGFuZCBwPTEwMS4zMjUga1BhJywgZXhhbXBsZXM6IFsnbW9sYXJWb2x1bWUnXX07XG4gIGRvY3Muc2Fja3VyVGV0cm9kZSA9IHtkZXNjcmlwdGlvbjogJ1NhY2t1ci1UZXRyb2RlIGNvbnN0YW50IGF0IFQ9MSBLIGFuZCBwPTEwMS4zMjUga1BhJywgZXhhbXBsZXM6IFsnc2Fja3VyVGV0cm9kZSddfTtcbiAgZG9jcy5zZWNvbmRSYWRpYXRpb24gPSB7ZGVzY3JpcHRpb246ICdTZWNvbmQgcmFkaWF0aW9uIGNvbnN0YW50JywgZXhhbXBsZXM6IFsnc2Vjb25kUmFkaWF0aW9uJ119O1xuICBkb2NzLnN0ZWZhbkJvbHR6bWFubiA9IHtkZXNjcmlwdGlvbjogJ1N0ZWZhbi1Cb2x0em1hbm4gY29uc3RhbnQnLCBleGFtcGxlczogWydzdGVmYW5Cb2x0em1hbm4nXX07XG4gIGRvY3Mud2llbkRpc3BsYWNlbWVudCA9IHtkZXNjcmlwdGlvbjogJ1dpZW4gZGlzcGxhY2VtZW50IGxhdyBjb25zdGFudCcsIGV4YW1wbGVzOiBbJ3dpZW5EaXNwbGFjZW1lbnQnXX07XG4gIC8vZG9jcy5zcGVjdHJhbFJhZGlhbmNlID0ge2Rlc2NyaXB0aW9uOiAnRmlyc3QgcmFkaWF0aW9uIGNvbnN0YW50IGZvciBzcGVjdHJhbCByYWRpYW5jZScsIGV4YW1wbGVzOiBbJ3NwZWN0cmFsUmFkaWFuY2UnXX07XG5cbiAgZG9jcy5tb2xhck1hc3MgPSB7ZGVzY3JpcHRpb246ICdNb2xhciBtYXNzIGNvbnN0YW50JywgZXhhbXBsZXM6IFsnbW9sYXJNYXNzJ119O1xuICBkb2NzLm1vbGFyTWFzc0MxMiA9IHtkZXNjcmlwdGlvbjogJ01vbGFyIG1hc3MgY29uc3RhbnQgb2YgY2FyYm9uLTEyJywgZXhhbXBsZXM6IFsnbW9sYXJNYXNzQzEyJ119O1xuICBkb2NzLmdyYXZpdHkgPSB7ZGVzY3JpcHRpb246ICdTdGFuZGFyZCBhY2NlbGVyYXRpb24gb2YgZ3Jhdml0eSAoc3RhbmRhcmQgYWNjZWxlcmF0aW9uIG9mIGZyZWUtZmFsbCBvbiBFYXJ0aCknLCBleGFtcGxlczogWydncmF2aXR5J119O1xuXG4gIGRvY3MucGxhbmNrTGVuZ3RoID0ge2Rlc2NyaXB0aW9uOiAnUGxhbmNrIGxlbmd0aCcsIGV4YW1wbGVzOiBbJ3BsYW5ja0xlbmd0aCddfTtcbiAgZG9jcy5wbGFuY2tNYXNzID0ge2Rlc2NyaXB0aW9uOiAnUGxhbmNrIG1hc3MnLCBleGFtcGxlczogWydwbGFuY2tNYXNzJ119O1xuICBkb2NzLnBsYW5ja1RpbWUgPSB7ZGVzY3JpcHRpb246ICdQbGFuY2sgdGltZScsIGV4YW1wbGVzOiBbJ3BsYW5ja1RpbWUnXX07XG4gIGRvY3MucGxhbmNrQ2hhcmdlID0ge2Rlc2NyaXB0aW9uOiAnUGxhbmNrIGNoYXJnZScsIGV4YW1wbGVzOiBbJ3BsYW5ja0NoYXJnZSddfTtcbiAgZG9jcy5wbGFuY2tUZW1wZXJhdHVyZSA9IHtkZXNjcmlwdGlvbjogJ1BsYW5jayB0ZW1wZXJhdHVyZScsIGV4YW1wbGVzOiBbJ3BsYW5ja1RlbXBlcmF0dXJlJ119O1xuXG4gIC8vIGZ1bmN0aW9ucyAtIGFsZ2VicmFcbiAgZG9jcy5sc29sdmUgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL2FsZ2VicmEvbHNvbHZlJyk7XG4gIGRvY3MubHVwID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9hbGdlYnJhL2x1cCcpO1xuICBkb2NzLmx1c29sdmUgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL2FsZ2VicmEvbHVzb2x2ZScpO1xuICBkb2NzLnNsdSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYWxnZWJyYS9zbHUnKTtcbiAgZG9jcy51c29sdmUgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL2FsZ2VicmEvdXNvbHZlJyk7XG5cbiAgLy8gZnVuY3Rpb25zIC0gYXJpdGhtZXRpY1xuICBkb2NzLmFicyA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9hYnMnKTtcbiAgZG9jcy5hZGQgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL2FyaXRobWV0aWMvYWRkJyk7XG4gIGRvY3MuY2JydCA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9jYnJ0Jyk7XG4gIGRvY3MuY2VpbCA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9jZWlsJyk7XG4gIGRvY3MuY3ViZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9jdWJlJyk7XG4gIGRvY3MuZGl2aWRlID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9hcml0aG1ldGljL2RpdmlkZScpO1xuICBkb2NzLmRvdERpdmlkZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9kb3REaXZpZGUnKTtcbiAgZG9jcy5kb3RNdWx0aXBseSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9kb3RNdWx0aXBseScpO1xuICBkb2NzLmRvdFBvdyA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9kb3RQb3cnKTtcbiAgZG9jcy5leHAgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL2FyaXRobWV0aWMvZXhwJyk7XG4gIGRvY3MuZml4ID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9hcml0aG1ldGljL2ZpeCcpO1xuICBkb2NzLmZsb29yID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9hcml0aG1ldGljL2Zsb29yJyk7XG4gIGRvY3MuZ2NkID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9hcml0aG1ldGljL2djZCcpO1xuICBkb2NzLmh5cG90ID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9hcml0aG1ldGljL2h5cG90Jyk7XG4gIGRvY3MubGNtID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9hcml0aG1ldGljL2xjbScpO1xuICBkb2NzLmxvZyA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9sb2cnKTtcbiAgZG9jcy5sb2cxMCA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9sb2cxMCcpO1xuICBkb2NzLm1vZCA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9tb2QnKTtcbiAgZG9jcy5tdWx0aXBseSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9tdWx0aXBseScpO1xuICBkb2NzLm5vcm0gPSByZXF1aXJlKCcuL2Z1bmN0aW9uL2FyaXRobWV0aWMvbm9ybScpO1xuICBkb2NzLm50aFJvb3QgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL2FyaXRobWV0aWMvbnRoUm9vdCcpO1xuICBkb2NzLnBvdyA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9wb3cnKTtcbiAgZG9jcy5yb3VuZCA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9yb3VuZCcpO1xuICBkb2NzLnNpZ24gPSByZXF1aXJlKCcuL2Z1bmN0aW9uL2FyaXRobWV0aWMvc2lnbicpO1xuICBkb2NzLnNxcnQgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL2FyaXRobWV0aWMvc3FydCcpO1xuICBkb2NzLnNxdWFyZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9zcXVhcmUnKTtcbiAgZG9jcy5zdWJ0cmFjdCA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9zdWJ0cmFjdCcpO1xuICBkb2NzLnVuYXJ5TWludXMgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL2FyaXRobWV0aWMvdW5hcnlNaW51cycpO1xuICBkb2NzLnVuYXJ5UGx1cyA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy91bmFyeVBsdXMnKTtcbiAgZG9jcy54Z2NkID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9hcml0aG1ldGljL3hnY2QnKTtcblxuICAvLyBmdW5jdGlvbnMgLSBiaXR3aXNlXG4gIGRvY3MuYml0QW5kID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9iaXR3aXNlL2JpdEFuZCcpO1xuICBkb2NzLmJpdE5vdCA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYml0d2lzZS9iaXROb3QnKTtcbiAgZG9jcy5iaXRPciA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYml0d2lzZS9iaXRPcicpO1xuICBkb2NzLmJpdFhvciA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYml0d2lzZS9iaXRYb3InKTtcbiAgZG9jcy5sZWZ0U2hpZnQgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL2JpdHdpc2UvbGVmdFNoaWZ0Jyk7XG4gIGRvY3MucmlnaHRBcml0aFNoaWZ0ID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9iaXR3aXNlL3JpZ2h0QXJpdGhTaGlmdCcpO1xuICBkb2NzLnJpZ2h0TG9nU2hpZnQgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL2JpdHdpc2UvcmlnaHRMb2dTaGlmdCcpO1xuXG4gIC8vIGZ1bmN0aW9ucyAtIGNvbWJpbmF0b3JpY3NcbiAgZG9jcy5iZWxsTnVtYmVycyA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vY29tYmluYXRvcmljcy9iZWxsTnVtYmVycycpO1xuICBkb2NzLmNhdGFsYW4gPSByZXF1aXJlKCcuL2Z1bmN0aW9uL2NvbWJpbmF0b3JpY3MvY2F0YWxhbicpO1xuICBkb2NzLmNvbXBvc2l0aW9uID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9jb21iaW5hdG9yaWNzL2NvbXBvc2l0aW9uJyk7XG4gIGRvY3Muc3RpcmxpbmdTMiA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vY29tYmluYXRvcmljcy9zdGlybGluZ1MyJyk7XG5cbiAgLy8gZnVuY3Rpb25zIC0gY29yZVxuICBkb2NzWydjb25maWcnXSA9ICByZXF1aXJlKCcuL2NvcmUvY29uZmlnJyk7XG4gIGRvY3NbJ2ltcG9ydCddID0gIHJlcXVpcmUoJy4vY29yZS9pbXBvcnQnKTtcbiAgZG9jc1sndHlwZWQnXSA9ICByZXF1aXJlKCcuL2NvcmUvdHlwZWQnKTtcblxuICAvLyBmdW5jdGlvbnMgLSBjb21wbGV4XG4gIGRvY3MuYXJnID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9jb21wbGV4L2FyZycpO1xuICBkb2NzLmNvbmogPSByZXF1aXJlKCcuL2Z1bmN0aW9uL2NvbXBsZXgvY29uaicpO1xuICBkb2NzLnJlID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9jb21wbGV4L3JlJyk7XG4gIGRvY3MuaW0gPSByZXF1aXJlKCcuL2Z1bmN0aW9uL2NvbXBsZXgvaW0nKTtcblxuICAvLyBmdW5jdGlvbnMgLSBleHByZXNzaW9uXG4gIGRvY3NbJ2V2YWwnXSA9ICByZXF1aXJlKCcuL2Z1bmN0aW9uL2V4cHJlc3Npb24vZXZhbCcpO1xuICBkb2NzLmhlbHAgPSAgcmVxdWlyZSgnLi9mdW5jdGlvbi9leHByZXNzaW9uL2hlbHAnKTtcblxuICAvLyBmdW5jdGlvbnMgLSBnZW9tZXRyeVxuICBkb2NzLmRpc3RhbmNlID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9nZW9tZXRyeS9kaXN0YW5jZScpO1xuICBkb2NzLmludGVyc2VjdCA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vZ2VvbWV0cnkvaW50ZXJzZWN0Jyk7XG5cbiAgLy8gZnVuY3Rpb25zIC0gbG9naWNhbFxuICBkb2NzWydhbmQnXSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vbG9naWNhbC9hbmQnKTtcbiAgZG9jc1snbm90J10gPSByZXF1aXJlKCcuL2Z1bmN0aW9uL2xvZ2ljYWwvbm90Jyk7XG4gIGRvY3NbJ29yJ10gPSByZXF1aXJlKCcuL2Z1bmN0aW9uL2xvZ2ljYWwvb3InKTtcbiAgZG9jc1sneG9yJ10gPSByZXF1aXJlKCcuL2Z1bmN0aW9uL2xvZ2ljYWwveG9yJyk7XG5cbiAgLy8gZnVuY3Rpb25zIC0gbWF0cml4XG4gIGRvY3NbJ2NvbmNhdCddID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9tYXRyaXgvY29uY2F0Jyk7XG4gIGRvY3MuY3Jvc3MgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL21hdHJpeC9jcm9zcycpO1xuICBkb2NzLmRldCA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vbWF0cml4L2RldCcpO1xuICBkb2NzLmRpYWcgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL21hdHJpeC9kaWFnJyk7XG4gIGRvY3MuZG90ID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9tYXRyaXgvZG90Jyk7XG4gIGRvY3MuZXllID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9tYXRyaXgvZXllJyk7XG4gIGRvY3MuZmlsdGVyID0gIHJlcXVpcmUoJy4vZnVuY3Rpb24vbWF0cml4L2ZpbHRlcicpO1xuICBkb2NzLmZsYXR0ZW4gPSByZXF1aXJlKCcuL2Z1bmN0aW9uL21hdHJpeC9mbGF0dGVuJyk7XG4gIGRvY3MuZm9yRWFjaCA9ICByZXF1aXJlKCcuL2Z1bmN0aW9uL21hdHJpeC9mb3JFYWNoJyk7XG4gIGRvY3MuaW52ID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9tYXRyaXgvaW52Jyk7XG4gIGRvY3MubWFwID0gIHJlcXVpcmUoJy4vZnVuY3Rpb24vbWF0cml4L21hcCcpO1xuICBkb2NzLm9uZXMgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL21hdHJpeC9vbmVzJyk7XG4gIGRvY3MucGFydGl0aW9uU2VsZWN0ID0gIHJlcXVpcmUoJy4vZnVuY3Rpb24vbWF0cml4L3BhcnRpdGlvblNlbGVjdCcpO1xuICBkb2NzLnJhbmdlID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9tYXRyaXgvcmFuZ2UnKTtcbiAgZG9jcy5yZXNpemUgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL21hdHJpeC9yZXNpemUnKTtcbiAgZG9jcy5zaXplID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9tYXRyaXgvc2l6ZScpO1xuICBkb2NzLnNvcnQgPSAgcmVxdWlyZSgnLi9mdW5jdGlvbi9tYXRyaXgvc29ydCcpO1xuICBkb2NzLnNxdWVlemUgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL21hdHJpeC9zcXVlZXplJyk7XG4gIGRvY3Muc3Vic2V0ID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9tYXRyaXgvc3Vic2V0Jyk7XG4gIGRvY3MudHJhY2UgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL21hdHJpeC90cmFjZScpO1xuICBkb2NzLnRyYW5zcG9zZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vbWF0cml4L3RyYW5zcG9zZScpO1xuICBkb2NzLnplcm9zID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9tYXRyaXgvemVyb3MnKTtcblxuICAvLyBmdW5jdGlvbnMgLSBwcm9iYWJpbGl0eVxuICBkb2NzLmNvbWJpbmF0aW9ucyA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vcHJvYmFiaWxpdHkvY29tYmluYXRpb25zJyk7XG4gIC8vZG9jcy5kaXN0cmlidXRpb24gPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3Byb2JhYmlsaXR5L2Rpc3RyaWJ1dGlvbicpO1xuICBkb2NzLmZhY3RvcmlhbCA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vcHJvYmFiaWxpdHkvZmFjdG9yaWFsJyk7XG4gIGRvY3MuZ2FtbWEgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3Byb2JhYmlsaXR5L2dhbW1hJyk7XG4gIGRvY3Mua2xkaXZlcmdlbmNlID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9wcm9iYWJpbGl0eS9rbGRpdmVyZ2VuY2UnKTtcbiAgZG9jcy5tdWx0aW5vbWlhbCA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vcHJvYmFiaWxpdHkvbXVsdGlub21pYWwnKTtcbiAgZG9jcy5wZXJtdXRhdGlvbnMgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3Byb2JhYmlsaXR5L3Blcm11dGF0aW9ucycpO1xuICBkb2NzLnBpY2tSYW5kb20gPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3Byb2JhYmlsaXR5L3BpY2tSYW5kb20nKTtcbiAgZG9jcy5yYW5kb20gPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3Byb2JhYmlsaXR5L3JhbmRvbScpO1xuICBkb2NzLnJhbmRvbUludCA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vcHJvYmFiaWxpdHkvcmFuZG9tSW50Jyk7XG5cbiAgLy8gZnVuY3Rpb25zIC0gcmVsYXRpb25hbFxuICBkb2NzLmNvbXBhcmUgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3JlbGF0aW9uYWwvY29tcGFyZScpO1xuICBkb2NzLmRlZXBFcXVhbCA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vcmVsYXRpb25hbC9kZWVwRXF1YWwnKTtcbiAgZG9jc1snZXF1YWwnXSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vcmVsYXRpb25hbC9lcXVhbCcpO1xuICBkb2NzLmxhcmdlciA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vcmVsYXRpb25hbC9sYXJnZXInKTtcbiAgZG9jcy5sYXJnZXJFcSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vcmVsYXRpb25hbC9sYXJnZXJFcScpO1xuICBkb2NzLnNtYWxsZXIgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3JlbGF0aW9uYWwvc21hbGxlcicpO1xuICBkb2NzLnNtYWxsZXJFcSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vcmVsYXRpb25hbC9zbWFsbGVyRXEnKTtcbiAgZG9jcy51bmVxdWFsID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9yZWxhdGlvbmFsL3VuZXF1YWwnKTtcblxuICAvLyBmdW5jdGlvbnMgLSBzdGF0aXN0aWNzXG4gIGRvY3MubWF4ID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9zdGF0aXN0aWNzL21heCcpO1xuICBkb2NzLm1lYW4gPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3N0YXRpc3RpY3MvbWVhbicpO1xuICBkb2NzLm1lZGlhbiA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vc3RhdGlzdGljcy9tZWRpYW4nKTtcbiAgZG9jcy5taW4gPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3N0YXRpc3RpY3MvbWluJyk7XG4gIGRvY3MubW9kZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vc3RhdGlzdGljcy9tb2RlJyk7XG4gIGRvY3MucHJvZCA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vc3RhdGlzdGljcy9wcm9kJyk7XG4gIGRvY3MucXVhbnRpbGVTZXEgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3N0YXRpc3RpY3MvcXVhbnRpbGVTZXEnKTtcbiAgZG9jcy5zdGQgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3N0YXRpc3RpY3Mvc3RkJyk7XG4gIGRvY3Muc3VtID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9zdGF0aXN0aWNzL3N1bScpO1xuICBkb2NzWyd2YXInXSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vc3RhdGlzdGljcy92YXInKTtcblxuICAvLyBmdW5jdGlvbnMgLSB0cmlnb25vbWV0cnlcbiAgZG9jcy5hY29zID0gcmVxdWlyZSgnLi9mdW5jdGlvbi90cmlnb25vbWV0cnkvYWNvcycpO1xuICBkb2NzLmFjb3NoID0gcmVxdWlyZSgnLi9mdW5jdGlvbi90cmlnb25vbWV0cnkvYWNvc2gnKTtcbiAgZG9jcy5hY290ID0gcmVxdWlyZSgnLi9mdW5jdGlvbi90cmlnb25vbWV0cnkvYWNvdCcpO1xuICBkb2NzLmFjb3RoID0gcmVxdWlyZSgnLi9mdW5jdGlvbi90cmlnb25vbWV0cnkvYWNvdGgnKTtcbiAgZG9jcy5hY3NjID0gcmVxdWlyZSgnLi9mdW5jdGlvbi90cmlnb25vbWV0cnkvYWNzYycpO1xuICBkb2NzLmFjc2NoID0gcmVxdWlyZSgnLi9mdW5jdGlvbi90cmlnb25vbWV0cnkvYWNzY2gnKTtcbiAgZG9jcy5hc2VjID0gcmVxdWlyZSgnLi9mdW5jdGlvbi90cmlnb25vbWV0cnkvYXNlYycpO1xuICBkb2NzLmFzZWNoID0gcmVxdWlyZSgnLi9mdW5jdGlvbi90cmlnb25vbWV0cnkvYXNlY2gnKTtcbiAgZG9jcy5hc2luID0gcmVxdWlyZSgnLi9mdW5jdGlvbi90cmlnb25vbWV0cnkvYXNpbicpO1xuICBkb2NzLmFzaW5oID0gcmVxdWlyZSgnLi9mdW5jdGlvbi90cmlnb25vbWV0cnkvYXNpbmgnKTtcbiAgZG9jcy5hdGFuID0gcmVxdWlyZSgnLi9mdW5jdGlvbi90cmlnb25vbWV0cnkvYXRhbicpO1xuICBkb2NzLmF0YW5oID0gcmVxdWlyZSgnLi9mdW5jdGlvbi90cmlnb25vbWV0cnkvYXRhbmgnKTtcbiAgZG9jcy5hdGFuMiA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vdHJpZ29ub21ldHJ5L2F0YW4yJyk7XG4gIGRvY3MuY29zID0gcmVxdWlyZSgnLi9mdW5jdGlvbi90cmlnb25vbWV0cnkvY29zJyk7XG4gIGRvY3MuY29zaCA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vdHJpZ29ub21ldHJ5L2Nvc2gnKTtcbiAgZG9jcy5jb3QgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9jb3QnKTtcbiAgZG9jcy5jb3RoID0gcmVxdWlyZSgnLi9mdW5jdGlvbi90cmlnb25vbWV0cnkvY290aCcpO1xuICBkb2NzLmNzYyA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vdHJpZ29ub21ldHJ5L2NzYycpO1xuICBkb2NzLmNzY2ggPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9jc2NoJyk7XG4gIGRvY3Muc2VjID0gcmVxdWlyZSgnLi9mdW5jdGlvbi90cmlnb25vbWV0cnkvc2VjJyk7XG4gIGRvY3Muc2VjaCA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vdHJpZ29ub21ldHJ5L3NlY2gnKTtcbiAgZG9jcy5zaW4gPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9zaW4nKTtcbiAgZG9jcy5zaW5oID0gcmVxdWlyZSgnLi9mdW5jdGlvbi90cmlnb25vbWV0cnkvc2luaCcpO1xuICBkb2NzLnRhbiA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vdHJpZ29ub21ldHJ5L3RhbicpO1xuICBkb2NzLnRhbmggPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS90YW5oJyk7XG5cbiAgLy8gZnVuY3Rpb25zIC0gdW5pdHNcbiAgZG9jcy50byA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vdW5pdHMvdG8nKTtcblxuICAvLyBmdW5jdGlvbnMgLSB1dGlsc1xuICBkb2NzLmNsb25lID0gIHJlcXVpcmUoJy4vZnVuY3Rpb24vdXRpbHMvY2xvbmUnKTtcbiAgZG9jcy5mb3JtYXQgPSAgcmVxdWlyZSgnLi9mdW5jdGlvbi91dGlscy9mb3JtYXQnKTtcbiAgZG9jcy5pc0ludGVnZXIgPSAgcmVxdWlyZSgnLi9mdW5jdGlvbi91dGlscy9pc0ludGVnZXInKTtcbiAgZG9jcy5pc05lZ2F0aXZlID0gIHJlcXVpcmUoJy4vZnVuY3Rpb24vdXRpbHMvaXNOZWdhdGl2ZScpO1xuICBkb2NzLmlzTnVtZXJpYyA9ICByZXF1aXJlKCcuL2Z1bmN0aW9uL3V0aWxzL2lzTnVtZXJpYycpO1xuICBkb2NzLmlzUG9zaXRpdmUgPSAgcmVxdWlyZSgnLi9mdW5jdGlvbi91dGlscy9pc1Bvc2l0aXZlJyk7XG4gIGRvY3MuaXNaZXJvID0gIHJlcXVpcmUoJy4vZnVuY3Rpb24vdXRpbHMvaXNaZXJvJyk7XG4gIC8vIGRvY3MucHJpbnQgPSAgcmVxdWlyZSgnLi9mdW5jdGlvbi91dGlscy9wcmludCcpOyAvLyBUT0RPOiBhZGQgZG9jdW1lbnRhdGlvbiBmb3IgcHJpbnQgYXMgc29vbiBhcyB0aGUgcGFyc2VyIHN1cHBvcnRzIG9iamVjdHMuXG4gIGRvY3NbJ3R5cGVvZiddID0gIHJlcXVpcmUoJy4vZnVuY3Rpb24vdXRpbHMvdHlwZW9mJyk7XG5cbiAgcmV0dXJuIGRvY3M7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdkb2NzJztcbmV4cG9ydHMucGF0aCA9ICdleHByZXNzaW9uJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWVwTWFwID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9kZWVwTWFwJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIHBhcnNlID0gbG9hZChyZXF1aXJlKCcuLi9wYXJzZScpKTtcblxuICAvKipcbiAgICogUGFyc2UgYW5kIGNvbXBpbGUgYW4gZXhwcmVzc2lvbi5cbiAgICogUmV0dXJucyBhIGFuIG9iamVjdCB3aXRoIGEgZnVuY3Rpb24gYGV2YWwoW3Njb3BlXSlgIHRvIGV2YWx1YXRlIHRoZVxuICAgKiBjb21waWxlZCBleHByZXNzaW9uLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgICBtYXRoLmNvbXBpbGUoZXhwcikgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgb25lIG5vZGVcbiAgICogICAgIG1hdGguY29tcGlsZShbZXhwcjEsIGV4cHIyLCBleHByMywgLi4uXSkgLy8gcmV0dXJucyBhbiBhcnJheSB3aXRoIG5vZGVzXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICAgdmFyIGNvZGUgPSBtYXRoLmNvbXBpbGUoJ3NxcnQoM14yICsgNF4yKScpO1xuICAgKiAgICAgY29kZS5ldmFsKCk7IC8vIDVcbiAgICpcbiAgICogICAgIHZhciBzY29wZSA9IHthOiAzLCBiOiA0fVxuICAgKiAgICAgdmFyIGNvZGUgPSBtYXRoLmNvbXBpbGUoJ2EgKiBiJyk7IC8vIDEyXG4gICAqICAgICBjb2RlLmV2YWwoc2NvcGUpOyAvLyAxMlxuICAgKiAgICAgc2NvcGUuYSA9IDU7XG4gICAqICAgICBjb2RlLmV2YWwoc2NvcGUpOyAvLyAyMFxuICAgKlxuICAgKiAgICAgdmFyIG5vZGVzID0gbWF0aC5jb21waWxlKFsnYSA9IDMnLCAnYiA9IDQnLCAnYSAqIGInXSk7XG4gICAqICAgICBub2Rlc1syXS5ldmFsKCk7IC8vIDEyXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBwYXJzZSwgZXZhbFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHN0cmluZ1tdIHwgQXJyYXkgfCBNYXRyaXh9IGV4cHJcbiAgICogICAgICAgICAgICBUaGUgZXhwcmVzc2lvbiB0byBiZSBjb21waWxlZFxuICAgKiBAcmV0dXJuIHt7ZXZhbDogRnVuY3Rpb259IHwgQXJyYXkuPHtldmFsOiBGdW5jdGlvbn0+fSBjb2RlXG4gICAqICAgICAgICAgICAgQW4gb2JqZWN0IHdpdGggdGhlIGNvbXBpbGVkIGV4cHJlc3Npb25cbiAgICogQHRocm93cyB7RXJyb3J9XG4gICAqL1xuICByZXR1cm4gdHlwZWQoJ2NvbXBpbGUnLCB7XG4gICAgJ3N0cmluZyc6IGZ1bmN0aW9uIChleHByKSB7XG4gICAgICByZXR1cm4gcGFyc2UoZXhwcikuY29tcGlsZSgpO1xuICAgIH0sXG5cbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiAoZXhwcikge1xuICAgICAgcmV0dXJuIGRlZXBNYXAoZXhwciwgZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgIHJldHVybiBwYXJzZShlbnRyeSkuY29tcGlsZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2NvbXBpbGUnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZXBNYXAgPSByZXF1aXJlKCcuLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBNYXAnKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgcGFyc2UgPSBsb2FkKHJlcXVpcmUoJy4uL3BhcnNlJykpO1xuXG4gIC8qKlxuICAgKiBFdmFsdWF0ZSBhbiBleHByZXNzaW9uLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgICBtYXRoLmV2YWwoZXhwcilcbiAgICogICAgIG1hdGguZXZhbChleHByLCBzY29wZSlcbiAgICogICAgIG1hdGguZXZhbChbZXhwcjEsIGV4cHIyLCBleHByMywgLi4uXSlcbiAgICogICAgIG1hdGguZXZhbChbZXhwcjEsIGV4cHIyLCBleHByMywgLi4uXSwgc2NvcGUpXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqXG4gICAqICAgICBtYXRoLmV2YWwoJygyKzMpLzQnKTsgICAgICAgICAgICAgICAgLy8gMS4yNVxuICAgKiAgICAgbWF0aC5ldmFsKCdzcXJ0KDNeMiArIDReMiknKTsgICAgICAgIC8vIDVcbiAgICogICAgIG1hdGguZXZhbCgnc3FydCgtNCknKTsgICAgICAgICAgICAgICAvLyAyaVxuICAgKiAgICAgbWF0aC5ldmFsKFsnYT0zJywgJ2I9NCcsICdhKmInXSk7LCAgIC8vIFszLCA0LCAxMl1cbiAgICpcbiAgICogICAgIHZhciBzY29wZSA9IHthOjMsIGI6NH07XG4gICAqICAgICBtYXRoLmV2YWwoJ2EgKiBiJywgc2NvcGUpOyAgICAgICAgICAgLy8gMTJcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIHBhcnNlLCBjb21waWxlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgc3RyaW5nW10gfCBNYXRyaXh9IGV4cHIgICBUaGUgZXhwcmVzc2lvbiB0byBiZSBldmFsdWF0ZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV0gICAgICAgICAgICAgICAgICAgIFNjb3BlIHRvIHJlYWQvd3JpdGUgdmFyaWFibGVzXG4gICAqIEByZXR1cm4geyp9IFRoZSByZXN1bHQgb2YgdGhlIGV4cHJlc3Npb25cbiAgICogQHRocm93cyB7RXJyb3J9XG4gICAqL1xuICByZXR1cm4gdHlwZWQoJ2NvbXBpbGUnLCB7XG4gICAgJ3N0cmluZyc6IGZ1bmN0aW9uIChleHByKSB7XG4gICAgICB2YXIgc2NvcGUgPSB7fTtcbiAgICAgIHJldHVybiBwYXJzZShleHByKS5jb21waWxlKCkuZXZhbChzY29wZSk7XG4gICAgfSxcblxuICAgICdzdHJpbmcsIE9iamVjdCc6IGZ1bmN0aW9uIChleHByLCBzY29wZSkge1xuICAgICAgcmV0dXJuIHBhcnNlKGV4cHIpLmNvbXBpbGUoKS5ldmFsKHNjb3BlKTtcbiAgICB9LFxuXG4gICAgJ0FycmF5IHwgTWF0cml4JzogZnVuY3Rpb24gKGV4cHIpIHtcbiAgICAgIHZhciBzY29wZSA9IHt9O1xuICAgICAgcmV0dXJuIGRlZXBNYXAoZXhwciwgZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgIHJldHVybiBwYXJzZShlbnRyeSkuY29tcGlsZSgpLmV2YWwoc2NvcGUpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgICdBcnJheSB8IE1hdHJpeCwgT2JqZWN0JzogZnVuY3Rpb24gKGV4cHIsIHNjb3BlKSB7XG4gICAgICByZXR1cm4gZGVlcE1hcChleHByLCBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlKGVudHJ5KS5jb21waWxlKCkuZXZhbChzY29wZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnZXZhbCc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5OyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCwgbWF0aCkge1xuICB2YXIgZG9jcyA9IGxvYWQocmVxdWlyZSgnLi4vZG9jcycpKTtcblxuICAvKipcbiAgICogUmV0cmlldmUgaGVscCBvbiBhIGZ1bmN0aW9uIG9yIGRhdGEgdHlwZS5cbiAgICogSGVscCBmaWxlcyBhcmUgcmV0cmlldmVkIGZyb20gdGhlIGRvY3VtZW50YXRpb24gaW4gbWF0aC5leHByZXNzaW9uLmRvY3MuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5oZWxwKHNlYXJjaClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIGNvbnNvbGUubG9nKG1hdGguaGVscCgnc2luJykudG9TdHJpbmcoKSk7XG4gICAqICAgIGNvbnNvbGUubG9nKG1hdGguaGVscChtYXRoLmFkZCkudG9TdHJpbmcoKSk7XG4gICAqICAgIGNvbnNvbGUubG9nKG1hdGguaGVscChtYXRoLmFkZCkudG9KU09OKCkpO1xuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uIHwgc3RyaW5nIHwgT2JqZWN0fSBzZWFyY2ggICBBIGZ1bmN0aW9uIG9yIGZ1bmN0aW9uIG5hbWVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIHdoaWNoIHRvIGdldCBoZWxwXG4gICAqIEByZXR1cm4ge0hlbHB9IEEgaGVscCBvYmplY3RcbiAgICovXG4gIHJldHVybiB0eXBlZCgnaGVscCcsIHtcbiAgICAnYW55JzogZnVuY3Rpb24gKHNlYXJjaCkge1xuICAgICAgdmFyIHByb3A7XG4gICAgICB2YXIgbmFtZSA9IHNlYXJjaDtcblxuICAgICAgaWYgKHR5cGVvZiBzZWFyY2ggIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGZvciAocHJvcCBpbiBtYXRoKSB7XG4gICAgICAgICAgLy8gc2VhcmNoIGluIGZ1bmN0aW9ucyBhbmQgY29uc3RhbnRzXG4gICAgICAgICAgaWYgKG1hdGguaGFzT3duUHJvcGVydHkocHJvcCkgJiYgKHNlYXJjaCA9PT0gbWF0aFtwcm9wXSkpIHtcbiAgICAgICAgICAgIG5hbWUgPSBwcm9wO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyogVE9ETzogaW1wbGVtZW50IGhlbHAgZm9yIGRhdGEgdHlwZXNcbiAgICAgICAgIGlmICghdGV4dCkge1xuICAgICAgICAgLy8gc2VhcmNoIGRhdGEgdHlwZVxuICAgICAgICAgZm9yIChwcm9wIGluIG1hdGgudHlwZSkge1xuICAgICAgICAgaWYgKG1hdGgudHlwZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgaWYgKHNlYXJjaCA9PT0gbWF0aC50eXBlW3Byb3BdKSB7XG4gICAgICAgICB0ZXh0ID0gcHJvcDtcbiAgICAgICAgIGJyZWFrO1xuICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgICAgKi9cbiAgICAgIH1cblxuICAgICAgdmFyIGRvYyA9IGRvY3NbbmFtZV07XG4gICAgICBpZiAoIWRvYykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGRvY3VtZW50YXRpb24gZm91bmQgb24gXCInICsgbmFtZSArICdcIicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyB0eXBlLkhlbHAoZG9jKTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnRzLm1hdGggPSB0cnVlOyAvLyByZXF1ZXN0IGFjY2VzcyB0byB0aGUgbWF0aCBuYW1lc3BhY2UgYXMgNXRoIGFyZ3VtZW50IG9mIHRoZSBmYWN0b3J5IGZ1bmN0aW9uXG5leHBvcnRzLm5hbWUgPSAnaGVscCc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBbXG4gIHJlcXVpcmUoJy4vY29tcGlsZScpLFxuICByZXF1aXJlKCcuL2V2YWwnKSxcbiAgcmVxdWlyZSgnLi9oZWxwJyksXG4gIHJlcXVpcmUoJy4vcGFyc2UnKSxcbiAgcmVxdWlyZSgnLi9wYXJzZXInKVxuXTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgcGFyc2UgPSBsb2FkKHJlcXVpcmUoJy4uL3BhcnNlJykpO1xuXG4gIC8qKlxuICAgKiBQYXJzZSBhbiBleHByZXNzaW9uLiBSZXR1cm5zIGEgbm9kZSB0cmVlLCB3aGljaCBjYW4gYmUgZXZhbHVhdGVkIGJ5XG4gICAqIGludm9raW5nIG5vZGUuZXZhbCgpO1xuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgICBtYXRoLnBhcnNlKGV4cHIpXG4gICAqICAgICBtYXRoLnBhcnNlKGV4cHIsIG9wdGlvbnMpXG4gICAqICAgICBtYXRoLnBhcnNlKFtleHByMSwgZXhwcjIsIGV4cHIzLCAuLi5dKVxuICAgKiAgICAgbWF0aC5wYXJzZShbZXhwcjEsIGV4cHIyLCBleHByMywgLi4uXSwgb3B0aW9ucylcbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICpcbiAgICogICAgIHZhciBub2RlID0gbWF0aC5wYXJzZSgnc3FydCgzXjIgKyA0XjIpJyk7XG4gICAqICAgICBub2RlLmNvbXBpbGUoKS5ldmFsKCk7IC8vIDVcbiAgICpcbiAgICogICAgIHZhciBzY29wZSA9IHthOjMsIGI6NH1cbiAgICogICAgIHZhciBub2RlID0gbWF0aC5wYXJzZSgnYSAqIGInKTsgLy8gMTJcbiAgICogICAgIHZhciBjb2RlID0gbm9kZS5jb21waWxlKCk7XG4gICAqICAgICBjb2RlLmV2YWwoc2NvcGUpOyAvLyAxMlxuICAgKiAgICAgc2NvcGUuYSA9IDU7XG4gICAqICAgICBjb2RlLmV2YWwoc2NvcGUpOyAvLyAyMFxuICAgKlxuICAgKiAgICAgdmFyIG5vZGVzID0gbWF0aC5wYXJzZShbJ2EgPSAzJywgJ2IgPSA0JywgJ2EgKiBiJ10pO1xuICAgKiAgICAgbm9kZXNbMl0uY29tcGlsZSgpLmV2YWwoKTsgLy8gMTJcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgICBldmFsLCBjb21waWxlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgc3RyaW5nW10gfCBNYXRyaXh9IGV4cHIgICAgICAgICAgRXhwcmVzc2lvbiB0byBiZSBwYXJzZWRcbiAgICogQHBhcmFtIHt7bm9kZXM6IE9iamVjdDxzdHJpbmcsIE5vZGU+fX0gW29wdGlvbnNdICBBdmFpbGFibGUgb3B0aW9uczpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIGBub2Rlc2AgYSBzZXQgb2YgY3VzdG9tIG5vZGVzXG4gICAqIEByZXR1cm4ge05vZGUgfCBOb2RlW119IG5vZGVcbiAgICogQHRocm93cyB7RXJyb3J9XG4gICAqL1xuICByZXR1cm4gdHlwZWQoJ3BhcnNlJywge1xuICAgICdzdHJpbmcgfCBBcnJheSB8IE1hdHJpeCc6IHBhcnNlLFxuICAgICdzdHJpbmcgfCBBcnJheSB8IE1hdHJpeCwgT2JqZWN0JzogcGFyc2VcbiAgfSk7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdwYXJzZSc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkLCBtYXRoKSB7XG4gIHZhciBQYXJzZXIgPSBsb2FkKHJlcXVpcmUoJy4uL1BhcnNlcicpKTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgcGFyc2VyLiBUaGUgZnVuY3Rpb24gY3JlYXRlcyBhIG5ldyBgbWF0aC5leHByZXNzaW9uLlBhcnNlcmAgb2JqZWN0LlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGgucGFyc2VyKClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgICB2YXIgcGFyc2VyID0gbmV3IG1hdGgucGFyc2VyKCk7XG4gICAqXG4gICAqICAgICAvLyBldmFsdWF0ZSBleHByZXNzaW9uc1xuICAgKiAgICAgdmFyIGEgPSBwYXJzZXIuZXZhbCgnc3FydCgzXjIgKyA0XjIpJyk7IC8vIDVcbiAgICogICAgIHZhciBiID0gcGFyc2VyLmV2YWwoJ3NxcnQoLTQpJyk7ICAgICAgICAvLyAyaVxuICAgKiAgICAgdmFyIGMgPSBwYXJzZXIuZXZhbCgnMiBpbmNoIGluIGNtJyk7ICAgIC8vIDUuMDggY21cbiAgICogICAgIHZhciBkID0gcGFyc2VyLmV2YWwoJ2Nvcyg0NSBkZWcpJyk7ICAgICAvLyAwLjcwNzEwNjc4MTE4NjU0NzZcbiAgICpcbiAgICogICAgIC8vIGRlZmluZSB2YXJpYWJsZXMgYW5kIGZ1bmN0aW9uc1xuICAgKiAgICAgcGFyc2VyLmV2YWwoJ3ggPSA3IC8gMicpOyAgICAgICAgICAgICAgIC8vIDMuNVxuICAgKiAgICAgcGFyc2VyLmV2YWwoJ3ggKyAzJyk7ICAgICAgICAgICAgICAgICAgIC8vIDYuNVxuICAgKiAgICAgcGFyc2VyLmV2YWwoJ2Z1bmN0aW9uIGYoeCwgeSkgPSB4XnknKTsgIC8vIGYoeCwgeSlcbiAgICogICAgIHBhcnNlci5ldmFsKCdmKDIsIDMpJyk7ICAgICAgICAgICAgICAgICAvLyA4XG4gICAqXG4gICAqICAgICAvLyBnZXQgYW5kIHNldCB2YXJpYWJsZXMgYW5kIGZ1bmN0aW9uc1xuICAgKiAgICAgdmFyIHggPSBwYXJzZXIuZ2V0KCd4Jyk7ICAgICAgICAgICAgICAgIC8vIDdcbiAgICogICAgIHZhciBmID0gcGFyc2VyLmdldCgnZicpOyAgICAgICAgICAgICAgICAvLyBmdW5jdGlvblxuICAgKiAgICAgdmFyIGcgPSBmKDMsIDIpOyAgICAgICAgICAgICAgICAgICAgICAgIC8vIDlcbiAgICogICAgIHBhcnNlci5zZXQoJ2gnLCA1MDApO1xuICAgKiAgICAgdmFyIGkgPSBwYXJzZXIuZXZhbCgnaCAvIDInKTsgICAgICAgICAgIC8vIDI1MFxuICAgKiAgICAgcGFyc2VyLnNldCgnaGVsbG8nLCBmdW5jdGlvbiAobmFtZSkge1xuICAgKiAgICAgICByZXR1cm4gJ2hlbGxvLCAnICsgbmFtZSArICchJztcbiAgICogICAgIH0pO1xuICAgKiAgICAgcGFyc2VyLmV2YWwoJ2hlbGxvKFwidXNlclwiKScpOyAgICAgICAgICAgLy8gXCJoZWxsbywgdXNlciFcIlxuICAgKlxuICAgKiAgICAgLy8gY2xlYXIgZGVmaW5lZCBmdW5jdGlvbnMgYW5kIHZhcmlhYmxlc1xuICAgKiAgICAgcGFyc2VyLmNsZWFyKCk7XG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBldmFsLCBjb21waWxlLCBwYXJzZVxuICAgKlxuICAgKiBAcmV0dXJuIHtQYXJzZXJ9IFBhcnNlclxuICAgKi9cbiAgcmV0dXJuIHR5cGVkKCdwYXJzZXInLCB7XG4gICAgJyc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgUGFyc2VyKG1hdGgpO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdwYXJzZXInO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbmV4cG9ydHMubWF0aCA9IHRydWU7IC8vIHJlcXVpcmVzIHRoZSBtYXRoIG5hbWVzcGFjZSBhcyA1dGggYXJndW1lbnRcbiIsIm1vZHVsZS5leHBvcnRzID0gW1xuICByZXF1aXJlKCcuL2RvY3MnKSxcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbicpLFxuICByZXF1aXJlKCcuL25vZGUnKSxcbiAgcmVxdWlyZSgnLi90cmFuc2Zvcm0nKSxcblxuICByZXF1aXJlKCcuL0hlbHAnKSxcbiAgcmVxdWlyZSgnLi9wYXJzZScpLFxuICByZXF1aXJlKCcuL1BhcnNlcicpXG5dO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBSZXNlcnZlZCBrZXl3b3JkcyBub3QgYWxsb3dlZCB0byB1c2UgaW4gdGhlIHBhcnNlclxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGVuZDogdHJ1ZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgTm9kZSA9IGxvYWQocmVxdWlyZSgnLi9Ob2RlJykpO1xuICB2YXIgYWNjZXNzID0gbG9hZChyZXF1aXJlKCcuL3V0aWxzL2FjY2VzcycpKTtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yIEFjY2Vzc29yTm9kZVxuICAgKiBAZXh0ZW5kcyB7Tm9kZX1cbiAgICogQWNjZXNzIGFuIG9iamVjdCBwcm9wZXJ0eSBvciBnZXQgYSBtYXRyaXggc3Vic2V0XG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gb2JqZWN0ICAgICAgICAgICAgICAgICBUaGUgb2JqZWN0IGZyb20gd2hpY2ggdG8gcmV0cmlldmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgcHJvcGVydHkgb3Igc3Vic2V0LlxuICAgKiBAcGFyYW0ge0luZGV4Tm9kZX0gaW5kZXggICAgICAgICAgICAgSW5kZXhOb2RlIGNvbnRhaW5pbmcgcmFuZ2VzXG4gICAqL1xuICBmdW5jdGlvbiBBY2Nlc3Nvck5vZGUob2JqZWN0LCBpbmRleCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBBY2Nlc3Nvck5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0NvbnN0cnVjdG9yIG11c3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBvcGVyYXRvcicpO1xuICAgIH1cblxuICAgIGlmICghKG9iamVjdCAmJiBvYmplY3QuaXNOb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm9kZSBleHBlY3RlZCBmb3IgcGFyYW1ldGVyIFwib2JqZWN0XCInKTtcbiAgICB9XG4gICAgaWYgKCEoaW5kZXggJiYgaW5kZXguaXNJbmRleE5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbmRleE5vZGUgZXhwZWN0ZWQgZm9yIHBhcmFtZXRlciBcImluZGV4XCInKTtcbiAgICB9XG5cbiAgICB0aGlzLm9iamVjdCA9IG9iamVjdCB8fCBudWxsO1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcblxuICAgIC8vIHJlYWRvbmx5IHByb3BlcnR5IG5hbWVcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ25hbWUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gKHRoaXMuaW5kZXguaXNPYmplY3RQcm9wZXJ0eSgpKVxuICAgICAgICAgICAgICA/IHRoaXMuaW5kZXguZ2V0T2JqZWN0UHJvcGVydHkoKVxuICAgICAgICAgICAgICA6ICcnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLm9iamVjdC5uYW1lIHx8ICcnO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcyksXG4gICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYXNzaWduIGEgbmV3IG5hbWUsIG5hbWUgaXMgcmVhZC1vbmx5Jyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBBY2Nlc3Nvck5vZGUucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcblxuICBBY2Nlc3Nvck5vZGUucHJvdG90eXBlLnR5cGUgPSAnQWNjZXNzb3JOb2RlJztcblxuICBBY2Nlc3Nvck5vZGUucHJvdG90eXBlLmlzQWNjZXNzb3JOb2RlID0gdHJ1ZTtcblxuICAvKipcbiAgICogQ29tcGlsZSB0aGUgbm9kZSB0byBqYXZhc2NyaXB0IGNvZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlZnMgICAgIE9iamVjdCB3aGljaCBjYW4gYmUgdXNlZCB0byBkZWZpbmUgZnVuY3Rpb25zXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBvciBjb25zdGFudHMgZ2xvYmFsbHkgYXZhaWxhYmxlIGZvciB0aGUgY29tcGlsZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgICAgIE9iamVjdCB3aXRoIGxvY2FsIGZ1bmN0aW9uIGFyZ3VtZW50cywgdGhlIGtleSBpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG5hbWUgb2YgdGhlIGFyZ3VtZW50LCBhbmQgdGhlIHZhbHVlIGlzIGB0cnVlYC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBvYmplY3QgbWF5IG5vdCBiZSBtdXRhdGVkLCBidXQgbXVzdCBiZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kZWQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7c3RyaW5nfSBqc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQWNjZXNzb3JOb2RlLnByb3RvdHlwZS5fY29tcGlsZSA9IGZ1bmN0aW9uIChkZWZzLCBhcmdzKSB7XG4gICAgZGVmcy5hY2Nlc3MgPSBhY2Nlc3M7XG5cbiAgICB2YXIgb2JqZWN0ID0gdGhpcy5vYmplY3QuX2NvbXBpbGUoZGVmcywgYXJncyk7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleC5fY29tcGlsZShkZWZzLCBhcmdzKTtcblxuICAgIGlmICh0aGlzLmluZGV4LmlzT2JqZWN0UHJvcGVydHkoKSkge1xuICAgICAgcmV0dXJuIG9iamVjdCArICdbXCInICsgdGhpcy5pbmRleC5nZXRPYmplY3RQcm9wZXJ0eSgpICsgJ1wiXSc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuaW5kZXgubmVlZHNTaXplKCkpIHtcbiAgICAgIC8vIGlmIHNvbWUgcGFyYW1ldGVycyB1c2UgdGhlICdlbmQnIHBhcmFtZXRlciwgd2UgbmVlZCB0byBjYWxjdWxhdGUgdGhlIHNpemVcbiAgICAgIHJldHVybiAnKGZ1bmN0aW9uICgpIHsnICtcbiAgICAgICAgICAnICB2YXIgb2JqZWN0ID0gJyArIG9iamVjdCArICc7JyArXG4gICAgICAgICAgJyAgdmFyIHNpemUgPSBtYXRoLnNpemUob2JqZWN0KS52YWx1ZU9mKCk7JyArXG4gICAgICAgICAgJyAgcmV0dXJuIGFjY2VzcyhvYmplY3QsICcgKyBpbmRleCArICcpOycgK1xuICAgICAgICAgICd9KSgpJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gJ2FjY2VzcygnICsgb2JqZWN0ICsgJywgJyArIGluZGV4ICsgJyknO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBlYWNoIG9mIHRoZSBjaGlsZCBub2RlcyBvZiB0aGlzIG5vZGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbihjaGlsZDogTm9kZSwgcGF0aDogc3RyaW5nLCBwYXJlbnQ6IE5vZGUpfSBjYWxsYmFja1xuICAgKi9cbiAgQWNjZXNzb3JOb2RlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vYmplY3QsICdvYmplY3QnLCB0aGlzKTtcbiAgICBjYWxsYmFjayh0aGlzLmluZGV4LCAnaW5kZXgnLCB0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IEFjY2Vzc29yTm9kZSBoYXZpbmcgaXQncyBjaGlsZHMgYmUgdGhlIHJlc3VsdHMgb2YgY2FsbGluZ1xuICAgKiB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIGVhY2ggb2YgdGhlIGNoaWxkcyBvZiB0aGUgb3JpZ2luYWwgbm9kZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihjaGlsZDogTm9kZSwgcGF0aDogc3RyaW5nLCBwYXJlbnQ6IE5vZGUpOiBOb2RlfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7QWNjZXNzb3JOb2RlfSBSZXR1cm5zIGEgdHJhbnNmb3JtZWQgY29weSBvZiB0aGUgbm9kZVxuICAgKi9cbiAgQWNjZXNzb3JOb2RlLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gbmV3IEFjY2Vzc29yTm9kZShcbiAgICAgICAgdGhpcy5faWZOb2RlKGNhbGxiYWNrKHRoaXMub2JqZWN0LCAnb2JqZWN0JywgdGhpcykpLFxuICAgICAgICB0aGlzLl9pZk5vZGUoY2FsbGJhY2sodGhpcy5pbmRleCwgJ2luZGV4JywgdGhpcykpXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgY2xvbmUgb2YgdGhpcyBub2RlLCBhIHNoYWxsb3cgY29weVxuICAgKiBAcmV0dXJuIHtBY2Nlc3Nvck5vZGV9XG4gICAqL1xuICBBY2Nlc3Nvck5vZGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgQWNjZXNzb3JOb2RlKHRoaXMub2JqZWN0LCB0aGlzLmluZGV4KTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBBY2Nlc3Nvck5vZGUucHJvdG90eXBlLl90b1N0cmluZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIG9iamVjdCA9IHRoaXMub2JqZWN0LnRvU3RyaW5nKG9wdGlvbnMpO1xuICAgIGlmIChuZWVkUGFyZW50aGVzaXModGhpcy5vYmplY3QpKSB7XG4gICAgICBvYmplY3QgPSAnKCcgKyBvYmplY3QgKyAnKSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iamVjdCArIHRoaXMuaW5kZXgudG9TdHJpbmcob3B0aW9ucyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBMYVRlWCByZXByZXNlbnRhdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBBY2Nlc3Nvck5vZGUucHJvdG90eXBlLl90b1RleCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIG9iamVjdCA9IHRoaXMub2JqZWN0LnRvVGV4KG9wdGlvbnMpO1xuICAgIGlmIChuZWVkUGFyZW50aGVzaXModGhpcy5vYmplY3QpKSB7XG4gICAgICBvYmplY3QgPSAnXFxcXGxlZnQoJyArIG9iamVjdCArICdcXFxccmlnaHQpJztcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqZWN0ICsgdGhpcy5pbmRleC50b1RleChvcHRpb25zKTtcbiAgfTtcblxuICAvKipcbiAgICogQXJlIHBhcmVudGhlc2lzIG5lZWRlZD9cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIG5lZWRQYXJlbnRoZXNpcyhub2RlKSB7XG4gICAgLy8gVE9ETzogbWF5YmUgbWFrZSBhIG1ldGhvZCBvbiB0aGUgbm9kZXMgd2hpY2ggdGVsbHMgd2hldGhlciB0aGV5IG5lZWQgcGFyZW50aGVzaXM/XG4gICAgcmV0dXJuICEobm9kZS5pc0FjY2Vzc29yTm9kZSB8fCBub2RlLmlzQXJyYXlOb2RlIHx8IG5vZGUuaXNDb25zdGFudE5vZGVcbiAgICAgICAgfHwgbm9kZS5pc0Z1bmN0aW9uTm9kZSB8fCBub2RlLmlzT2JqZWN0Tm9kZSB8fCBub2RlLmlzUGFyZW50aGVzaXNOb2RlXG4gICAgICAgIHx8IG5vZGUuaXNTeW1ib2xOb2RlKTtcbiAgfVxuXG4gIHJldHVybiBBY2Nlc3Nvck5vZGU7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdBY2Nlc3Nvck5vZGUnO1xuZXhwb3J0cy5wYXRoID0gJ2V4cHJlc3Npb24ubm9kZSc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBOb2RlID0gbG9hZChyZXF1aXJlKCcuL05vZGUnKSk7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvciBBcnJheU5vZGVcbiAgICogQGV4dGVuZHMge05vZGV9XG4gICAqIEhvbGRzIGFuIDEtZGltZW5zaW9uYWwgYXJyYXkgd2l0aCBpdGVtc1xuICAgKiBAcGFyYW0ge05vZGVbXX0gW2l0ZW1zXSAgIDEgZGltZW5zaW9uYWwgYXJyYXkgd2l0aCBpdGVtc1xuICAgKi9cbiAgZnVuY3Rpb24gQXJyYXlOb2RlKGl0ZW1zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEFycmF5Tm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQ29uc3RydWN0b3IgbXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgbmV3IG9wZXJhdG9yJyk7XG4gICAgfVxuXG4gICAgdGhpcy5pdGVtcyA9IGl0ZW1zIHx8IFtdO1xuXG4gICAgLy8gdmFsaWRhdGUgaW5wdXRcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodGhpcy5pdGVtcylcbiAgICAgICAgfHwgIXRoaXMuaXRlbXMuZXZlcnkoZnVuY3Rpb24gKGl0ZW0pIHtyZXR1cm4gaXRlbSAmJiBpdGVtLmlzTm9kZTt9KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkgY29udGFpbmluZyBOb2RlcyBleHBlY3RlZCcpO1xuICAgIH1cblxuICAgIC8vIFRPRE86IGRlcHJlY2F0ZWQgc2luY2UgdjMsIHJlbW92ZSBzb21lIGRheVxuICAgIHZhciBkZXByZWNhdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9wZXJ0eSBgQXJyYXlOb2RlLm5vZGVzYCBpcyBkZXByZWNhdGVkLCB1c2UgYEFycmF5Tm9kZS5pdGVtc2AgaW5zdGVhZCcpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdub2RlcycsIHsgZ2V0OiBkZXByZWNhdGVkLCBzZXQ6IGRlcHJlY2F0ZWQgfSk7XG4gIH1cblxuICBBcnJheU5vZGUucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcblxuICBBcnJheU5vZGUucHJvdG90eXBlLnR5cGUgPSAnQXJyYXlOb2RlJztcblxuICBBcnJheU5vZGUucHJvdG90eXBlLmlzQXJyYXlOb2RlID0gdHJ1ZTtcblxuICAvKipcbiAgICogQ29tcGlsZSB0aGUgbm9kZSB0byBqYXZhc2NyaXB0IGNvZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlZnMgICAgIE9iamVjdCB3aGljaCBjYW4gYmUgdXNlZCB0byBkZWZpbmUgZnVuY3Rpb25zXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBvciBjb25zdGFudHMgZ2xvYmFsbHkgYXZhaWxhYmxlIGZvciB0aGUgY29tcGlsZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgICAgIE9iamVjdCB3aXRoIGxvY2FsIGZ1bmN0aW9uIGFyZ3VtZW50cywgdGhlIGtleSBpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG5hbWUgb2YgdGhlIGFyZ3VtZW50LCBhbmQgdGhlIHZhbHVlIGlzIGB0cnVlYC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBvYmplY3QgbWF5IG5vdCBiZSBtdXRhdGVkLCBidXQgbXVzdCBiZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kZWQgaW5zdGVhZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIEFycmF5Tm9kZS5wcm90b3R5cGUuX2NvbXBpbGUgPSBmdW5jdGlvbiAoZGVmcywgYXJncykge1xuICAgIHZhciBhc01hdHJpeCA9IChkZWZzLm1hdGguY29uZmlnKCkubWF0cml4ICE9PSAnQXJyYXknKTtcblxuICAgIHZhciBpdGVtcyA9IHRoaXMuaXRlbXMubWFwKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS5fY29tcGlsZShkZWZzLCBhcmdzKTtcbiAgICB9KTtcblxuICAgIHJldHVybiAoYXNNYXRyaXggPyAnbWF0aC5tYXRyaXgoWycgOiAnWycpICtcbiAgICAgICAgaXRlbXMuam9pbignLCcpICtcbiAgICAgICAgKGFzTWF0cml4ID8gJ10pJyA6ICddJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZWFjaCBvZiB0aGUgY2hpbGQgbm9kZXMgb2YgdGhpcyBub2RlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oY2hpbGQ6IE5vZGUsIHBhdGg6IHN0cmluZywgcGFyZW50OiBOb2RlKX0gY2FsbGJhY2tcbiAgICovXG4gIEFycmF5Tm9kZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLml0ZW1zW2ldO1xuICAgICAgY2FsbGJhY2sobm9kZSwgJ2l0ZW1zWycgKyBpICsgJ10nLCB0aGlzKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBBcnJheU5vZGUgaGF2aW5nIGl0J3MgY2hpbGRzIGJlIHRoZSByZXN1bHRzIG9mIGNhbGxpbmdcbiAgICogdGhlIHByb3ZpZGVkIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBlYWNoIG9mIHRoZSBjaGlsZHMgb2YgdGhlIG9yaWdpbmFsIG5vZGUuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oY2hpbGQ6IE5vZGUsIHBhdGg6IHN0cmluZywgcGFyZW50OiBOb2RlKTogTm9kZX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge0FycmF5Tm9kZX0gUmV0dXJucyBhIHRyYW5zZm9ybWVkIGNvcHkgb2YgdGhlIG5vZGVcbiAgICovXG4gIEFycmF5Tm9kZS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdmFyIGl0ZW1zID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLml0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpdGVtc1tpXSA9IHRoaXMuX2lmTm9kZShjYWxsYmFjayh0aGlzLml0ZW1zW2ldLCAnaXRlbXNbJyArIGkgKyAnXScsIHRoaXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBcnJheU5vZGUoaXRlbXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBjbG9uZSBvZiB0aGlzIG5vZGUsIGEgc2hhbGxvdyBjb3B5XG4gICAqIEByZXR1cm4ge0FycmF5Tm9kZX1cbiAgICovXG4gIEFycmF5Tm9kZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IEFycmF5Tm9kZSh0aGlzLml0ZW1zLnNsaWNlKDApKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHN0clxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIEFycmF5Tm9kZS5wcm90b3R5cGUuX3RvU3RyaW5nID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBpdGVtcyA9IHRoaXMuaXRlbXMubWFwKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS50b1N0cmluZyhvcHRpb25zKTtcbiAgICB9KTtcbiAgICByZXR1cm4gJ1snICsgaXRlbXMuam9pbignLCAnKSArICddJztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IExhVGVYIHJlcHJlc2VudGF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge3N0cmluZ30gc3RyXG4gICAqL1xuICBBcnJheU5vZGUucHJvdG90eXBlLl90b1RleCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgcyA9ICdcXFxcYmVnaW57Ym1hdHJpeH0nO1xuXG4gICAgdGhpcy5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIGlmIChub2RlLml0ZW1zKSB7XG4gICAgICAgIHMgKz0gbm9kZS5pdGVtcy5tYXAoZnVuY3Rpb24oY2hpbGROb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIGNoaWxkTm9kZS50b1RleChvcHRpb25zKTtcbiAgICAgICAgfSkuam9pbignJicpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHMgKz0gbm9kZS50b1RleChvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgLy8gbmV3IGxpbmVcbiAgICAgIHMgKz0gJ1xcXFxcXFxcJztcbiAgICB9KTtcbiAgICBzICs9ICdcXFxcZW5ke2JtYXRyaXh9JztcbiAgICByZXR1cm4gcztcbiAgfTtcblxuICByZXR1cm4gQXJyYXlOb2RlO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnQXJyYXlOb2RlJztcbmV4cG9ydHMucGF0aCA9ICdleHByZXNzaW9uLm5vZGUnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGxhdGV4ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbGF0ZXgnKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgTm9kZSA9IGxvYWQocmVxdWlyZSgnLi9Ob2RlJykpO1xuICB2YXIgQXJyYXlOb2RlID0gbG9hZChyZXF1aXJlKCcuL0FycmF5Tm9kZScpKTtcbiAgdmFyIG1hdHJpeCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvZnVuY3Rpb24vbWF0cml4JykpO1xuICB2YXIgYXNzaWduID0gbG9hZChyZXF1aXJlKCcuL3V0aWxzL2Fzc2lnbicpKTtcbiAgdmFyIGFjY2VzcyA9IGxvYWQocmVxdWlyZSgnLi91dGlscy9hY2Nlc3MnKSk7XG5cbiAgdmFyIGtleXdvcmRzID0gcmVxdWlyZSgnLi4va2V5d29yZHMnKTtcbiAgdmFyIG9wZXJhdG9ycyA9IHJlcXVpcmUoJy4uL29wZXJhdG9ycycpO1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3IgQXNzaWdubWVudE5vZGVcbiAgICogQGV4dGVuZHMge05vZGV9XG4gICAqXG4gICAqIERlZmluZSBhIHN5bWJvbCwgbGlrZSBgYT0zLjJgLCB1cGRhdGUgYSBwcm9wZXJ0eSBsaWtlIGBhLmI9My4yYCwgb3JcbiAgICogcmVwbGFjZSBhIHN1YnNldCBvZiBhIG1hdHJpeCBsaWtlIGBBWzIsMl09NDJgLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgICBuZXcgQXNzaWdubWVudE5vZGUoc3ltYm9sLCB2YWx1ZSlcbiAgICogICAgIG5ldyBBc3NpZ25tZW50Tm9kZShvYmplY3QsIGluZGV4LCB2YWx1ZSlcbiAgICpcbiAgICogVXNhZ2U6XG4gICAqXG4gICAqICAgIG5ldyBBc3NpZ25tZW50Tm9kZShuZXcgU3ltYm9sTm9kZSgnYScpLCBuZXcgQ29uc3RhbnROb2RlKDIpKTsgICAgICAgICAgICAgICAgICAgICAgLy8gYT0yXG4gICAqICAgIG5ldyBBc3NpZ25tZW50Tm9kZShuZXcgU3ltYm9sTm9kZSgnYScpLCBuZXcgSW5kZXhOb2RlKCdiJyksIG5ldyBDb25zdGFudE5vZGUoMikpICAgLy8gYS5iPTJcbiAgICogICAgbmV3IEFzc2lnbm1lbnROb2RlKG5ldyBTeW1ib2xOb2RlKCdhJyksIG5ldyBJbmRleE5vZGUoMSwgMiksIG5ldyBDb25zdGFudE5vZGUoMykpICAvLyBhWzEsMl09M1xuICAgKlxuICAgKiBAcGFyYW0ge1N5bWJvbE5vZGUgfCBBY2Nlc3Nvck5vZGV9IG9iamVjdCAgT2JqZWN0IG9uIHdoaWNoIHRvIGFzc2lnbiBhIHZhbHVlXG4gICAqIEBwYXJhbSB7SW5kZXhOb2RlfSBbaW5kZXg9bnVsbF0gICAgICAgICAgICBJbmRleCwgcHJvcGVydHkgbmFtZSBvciBtYXRyaXhcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LiBPcHRpb25hbC4gSWYgbm90IHByb3ZpZGVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgYG9iamVjdGAgaXMgYSBTeW1ib2xOb2RlLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHByb3BlcnR5IGlzIGFzc2lnbmVkIHRvIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsIHNjb3BlLlxuICAgKiBAcGFyYW0ge05vZGV9IHZhbHVlICAgICAgICAgICAgICAgICAgICAgICAgVGhlIHZhbHVlIHRvIGJlIGFzc2lnbmVkXG4gICAqL1xuICBmdW5jdGlvbiBBc3NpZ25tZW50Tm9kZShvYmplY3QsIGluZGV4LCB2YWx1ZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBBc3NpZ25tZW50Tm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQ29uc3RydWN0b3IgbXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgbmV3IG9wZXJhdG9yJyk7XG4gICAgfVxuXG4gICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XG4gICAgdGhpcy5pbmRleCA9IHZhbHVlID8gaW5kZXggOiBudWxsO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZSA/IHZhbHVlIDogaW5kZXg7XG5cbiAgICAvLyB2YWxpZGF0ZSBpbnB1dFxuICAgIGlmICghb2JqZWN0IHx8ICEob2JqZWN0LmlzU3ltYm9sTm9kZSB8fCBvYmplY3QuaXNBY2Nlc3Nvck5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTeW1ib2xOb2RlIG9yIEFjY2Vzc29yTm9kZSBleHBlY3RlZCBhcyBcIm9iamVjdFwiJyk7XG4gICAgfVxuICAgIGlmIChvYmplY3QgJiYgb2JqZWN0LmlzU3ltYm9sTm9kZSAmJiBvYmplY3QubmFtZSA9PT0gJ2VuZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFzc2lnbiB0byBzeW1ib2wgXCJlbmRcIicpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pbmRleCAmJiAhdGhpcy5pbmRleC5pc0luZGV4Tm9kZSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW5kZXhOb2RlIGV4cGVjdGVkIGFzIFwiaW5kZXhcIicpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMudmFsdWUgfHwgIXRoaXMudmFsdWUuaXNOb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb2RlIGV4cGVjdGVkIGFzIFwidmFsdWVcIicpO1xuICAgIH1cblxuICAgIC8vIHJlYWRvbmx5IHByb3BlcnR5IG5hbWVcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ25hbWUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gKHRoaXMuaW5kZXguaXNPYmplY3RQcm9wZXJ0eSgpKVxuICAgICAgICAgICAgICA/IHRoaXMuaW5kZXguZ2V0T2JqZWN0UHJvcGVydHkoKVxuICAgICAgICAgICAgICA6ICcnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLm9iamVjdC5uYW1lIHx8ICcnO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcyksXG4gICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYXNzaWduIGEgbmV3IG5hbWUsIG5hbWUgaXMgcmVhZC1vbmx5Jyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBBc3NpZ25tZW50Tm9kZS5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuXG4gIEFzc2lnbm1lbnROb2RlLnByb3RvdHlwZS50eXBlID0gJ0Fzc2lnbm1lbnROb2RlJztcblxuICBBc3NpZ25tZW50Tm9kZS5wcm90b3R5cGUuaXNBc3NpZ25tZW50Tm9kZSA9IHRydWU7XG5cbiAgLyoqXG4gICAqIENvbXBpbGUgdGhlIG5vZGUgdG8gamF2YXNjcmlwdCBjb2RlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkZWZzICAgICBPYmplY3Qgd2hpY2ggY2FuIGJlIHVzZWQgdG8gZGVmaW5lIGZ1bmN0aW9uc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgb3IgY29uc3RhbnRzIGdsb2JhbGx5IGF2YWlsYWJsZSBmb3IgdGhlIGNvbXBpbGVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzICAgICBPYmplY3Qgd2l0aCBsb2NhbCBmdW5jdGlvbiBhcmd1bWVudHMsIHRoZSBrZXkgaXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBuYW1lIG9mIHRoZSBhcmd1bWVudCwgYW5kIHRoZSB2YWx1ZSBpcyBgdHJ1ZWAuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgb2JqZWN0IG1heSBub3QgYmUgbXV0YXRlZCwgYnV0IG11c3QgYmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuZGVkIGluc3RlYWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBBc3NpZ25tZW50Tm9kZS5wcm90b3R5cGUuX2NvbXBpbGUgPSBmdW5jdGlvbiAoZGVmcywgYXJncykge1xuICAgIGRlZnMuYXNzaWduID0gYXNzaWduO1xuICAgIGRlZnMuYWNjZXNzID0gYWNjZXNzO1xuXG4gICAgdmFyIHNpemU7XG4gICAgdmFyIG9iamVjdCA9IHRoaXMub2JqZWN0Ll9jb21waWxlKGRlZnMsIGFyZ3MpO1xuICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXggPyB0aGlzLmluZGV4Ll9jb21waWxlKGRlZnMsIGFyZ3MpIDogbnVsbDtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlLl9jb21waWxlKGRlZnMsIGFyZ3MpO1xuXG4gICAgaWYgKCF0aGlzLmluZGV4KSB7XG4gICAgICAvLyBhcHBseSBhIHZhcmlhYmxlIHRvIHRoZSBzY29wZSwgZm9yIGV4YW1wbGUgYGE9MmBcbiAgICAgIGlmICghdGhpcy5vYmplY3QuaXNTeW1ib2xOb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1N5bWJvbE5vZGUgZXhwZWN0ZWQgYXMgb2JqZWN0Jyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnc2NvcGVbXCInICsgdGhpcy5vYmplY3QubmFtZSArICdcIl0gPSAnICsgdmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuaW5kZXguaXNPYmplY3RQcm9wZXJ0eSgpKSB7XG4gICAgICAvLyBhcHBseSBhbiBvYmplY3QgcHJvcGVydHkgZm9yIGV4YW1wbGUgYGEuYj0yYFxuICAgICAgcmV0dXJuIG9iamVjdCArICdbXCInICsgdGhpcy5pbmRleC5nZXRPYmplY3RQcm9wZXJ0eSgpICsgJ1wiXSA9ICcgKyB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5vYmplY3QuaXNTeW1ib2xOb2RlKSB7XG4gICAgICAvLyB1cGRhdGUgYSBtYXRyaXggc3Vic2V0LCBmb3IgZXhhbXBsZSBgYVsyXT0zYFxuICAgICAgc2l6ZSA9IHRoaXMuaW5kZXgubmVlZHNTaXplKCkgPyAndmFyIHNpemUgPSBtYXRoLnNpemUob2JqZWN0KS52YWx1ZU9mKCk7JyA6ICcnO1xuXG4gICAgICAvLyBhcHBseSB1cGRhdGVkIG9iamVjdCB0byBzY29wZVxuICAgICAgcmV0dXJuICcoZnVuY3Rpb24gKCkgeycgK1xuICAgICAgICAgICcgIHZhciBvYmplY3QgPSAnICsgb2JqZWN0ICsgJzsnICtcbiAgICAgICAgICAnICB2YXIgdmFsdWUgPSAnICsgdmFsdWUgKyAnOycgK1xuICAgICAgICAgICcgICcgKyBzaXplICtcbiAgICAgICAgICAnICBzY29wZVtcIicgKyB0aGlzLm9iamVjdC5uYW1lICsgJ1wiXSA9IGFzc2lnbihvYmplY3QsICcgKyBpbmRleCArICcsIHZhbHVlKTsnICtcbiAgICAgICAgICAnICByZXR1cm4gdmFsdWU7JyArXG4gICAgICAgICAgJ30pKCknO1xuICAgIH1cbiAgICBlbHNlIHsgLy8gdGhpcy5vYmplY3QuaXNBY2Nlc3Nvck5vZGUgPT09IHRydWVcbiAgICAgIC8vIHVwZGF0ZSBhIG1hdHJpeCBzdWJzZXQsIGZvciBleGFtcGxlIGBhLmJbMl09M2BcbiAgICAgIHNpemUgPSB0aGlzLmluZGV4Lm5lZWRzU2l6ZSgpID8gJ3ZhciBzaXplID0gbWF0aC5zaXplKG9iamVjdCkudmFsdWVPZigpOycgOiAnJztcblxuICAgICAgLy8gd2Ugd2lsbCBub3QgdXNlIHRoZSBfY29tcGlsZSBvZiB0aGUgQWNjZXNzb3JOb2RlLCBidXQgY29tcGlsZSBpdFxuICAgICAgLy8gb3Vyc2VsdmVzIGhlcmUgYXMgd2UgbmVlZCB0aGUgcGFyZW50IG9iamVjdCBvZiB0aGUgQWNjZXNzb3JOb2RlOlxuICAgICAgLy8gd2VlIG5lZWQgdG8gYXBwbHkgdGhlIHVwZGF0ZWQgb2JqZWN0IHRvIHBhcmVudCBvYmplY3RcbiAgICAgIHZhciBwYXJlbnRPYmplY3QgPSB0aGlzLm9iamVjdC5vYmplY3QuX2NvbXBpbGUoZGVmcywgYXJncyk7XG5cbiAgICAgIGlmICh0aGlzLm9iamVjdC5pbmRleC5pc09iamVjdFByb3BlcnR5KCkpIHtcbiAgICAgICAgdmFyIHBhcmVudFByb3BlcnR5ID0gJ1tcIicgKyB0aGlzLm9iamVjdC5pbmRleC5nZXRPYmplY3RQcm9wZXJ0eSgpICsgJ1wiXSc7XG4gICAgICAgIHJldHVybiAnKGZ1bmN0aW9uICgpIHsnICtcbiAgICAgICAgICAgICcgIHZhciBwYXJlbnQgPSAnICsgcGFyZW50T2JqZWN0ICsgJzsnICtcbiAgICAgICAgICAgICcgIHZhciBvYmplY3QgPSBwYXJlbnQnICsgcGFyZW50UHJvcGVydHkgKyAnOycgKyAvLyBwYXJlbnRJbmRleCBpcyBhIHByb3BlcnR5XG4gICAgICAgICAgICAnICB2YXIgdmFsdWUgPSAnICsgdmFsdWUgKyAnOycgK1xuICAgICAgICAgICAgc2l6ZSArXG4gICAgICAgICAgICAnICBwYXJlbnQnICsgcGFyZW50UHJvcGVydHkgKyAnID0gYXNzaWduKG9iamVjdCwgJyArIGluZGV4ICsgJywgdmFsdWUpOycgK1xuICAgICAgICAgICAgJyAgcmV0dXJuIHZhbHVlOycgK1xuICAgICAgICAgICAgJ30pKCknO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIGlmIHNvbWUgcGFyYW1ldGVycyB1c2UgdGhlICdlbmQnIHBhcmFtZXRlciwgd2UgbmVlZCB0byBjYWxjdWxhdGUgdGhlIHNpemVcbiAgICAgICAgdmFyIHBhcmVudFNpemUgPSB0aGlzLm9iamVjdC5pbmRleC5uZWVkc1NpemUoKSA/ICd2YXIgc2l6ZSA9IG1hdGguc2l6ZShwYXJlbnQpLnZhbHVlT2YoKTsnIDogJyc7XG4gICAgICAgIHZhciBwYXJlbnRJbmRleCA9IHRoaXMub2JqZWN0LmluZGV4Ll9jb21waWxlKGRlZnMsIGFyZ3MpO1xuXG4gICAgICAgIHJldHVybiAnKGZ1bmN0aW9uICgpIHsnICtcbiAgICAgICAgICAgICcgIHZhciBwYXJlbnQgPSAnICsgcGFyZW50T2JqZWN0ICsgJzsnICtcbiAgICAgICAgICAgICcgICcgKyBwYXJlbnRTaXplICtcbiAgICAgICAgICAgICcgIHZhciBwYXJlbnRJbmRleCA9ICcgKyBwYXJlbnRJbmRleCArICc7JyArXG4gICAgICAgICAgICAnICB2YXIgb2JqZWN0ID0gYWNjZXNzKHBhcmVudCwgcGFyZW50SW5kZXgpOycgK1xuICAgICAgICAgICAgJyAgdmFyIHZhbHVlID0gJyArIHZhbHVlICsgJzsnICtcbiAgICAgICAgICAgICcgICcgKyBzaXplICtcbiAgICAgICAgICAgICcgIGFzc2lnbihwYXJlbnQsIHBhcmVudEluZGV4LCBhc3NpZ24ob2JqZWN0LCAnICsgaW5kZXggKyAnLCB2YWx1ZSkpOycgK1xuICAgICAgICAgICAgJyAgcmV0dXJuIHZhbHVlOycgK1xuICAgICAgICAgICAgJ30pKCknO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGVhY2ggb2YgdGhlIGNoaWxkIG5vZGVzIG9mIHRoaXMgbm9kZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGNoaWxkOiBOb2RlLCBwYXRoOiBzdHJpbmcsIHBhcmVudDogTm9kZSl9IGNhbGxiYWNrXG4gICAqL1xuICBBc3NpZ25tZW50Tm9kZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKHRoaXMub2JqZWN0LCAnb2JqZWN0JywgdGhpcyk7XG4gICAgaWYgKHRoaXMuaW5kZXgpIHtcbiAgICAgIGNhbGxiYWNrKHRoaXMuaW5kZXgsICdpbmRleCcsIHRoaXMpO1xuICAgIH1cbiAgICBjYWxsYmFjayh0aGlzLnZhbHVlLCAndmFsdWUnLCB0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IEFzc2lnbm1lbnROb2RlIGhhdmluZyBpdCdzIGNoaWxkcyBiZSB0aGUgcmVzdWx0cyBvZiBjYWxsaW5nXG4gICAqIHRoZSBwcm92aWRlZCBjYWxsYmFjayBmdW5jdGlvbiBmb3IgZWFjaCBvZiB0aGUgY2hpbGRzIG9mIHRoZSBvcmlnaW5hbCBub2RlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGNoaWxkOiBOb2RlLCBwYXRoOiBzdHJpbmcsIHBhcmVudDogTm9kZSk6IE5vZGV9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtBc3NpZ25tZW50Tm9kZX0gUmV0dXJucyBhIHRyYW5zZm9ybWVkIGNvcHkgb2YgdGhlIG5vZGVcbiAgICovXG4gIEFzc2lnbm1lbnROb2RlLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB2YXIgb2JqZWN0ID0gdGhpcy5faWZOb2RlKGNhbGxiYWNrKHRoaXMub2JqZWN0LCAnb2JqZWN0JywgdGhpcykpO1xuICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXhcbiAgICAgICAgPyB0aGlzLl9pZk5vZGUoY2FsbGJhY2sodGhpcy5pbmRleCwgJ2luZGV4JywgdGhpcykpXG4gICAgICAgIDogbnVsbDtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLl9pZk5vZGUoY2FsbGJhY2sodGhpcy52YWx1ZSwgJ3ZhbHVlJywgdGhpcykpO1xuXG4gICAgcmV0dXJuIG5ldyBBc3NpZ25tZW50Tm9kZShvYmplY3QsIGluZGV4LCB2YWx1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGNsb25lIG9mIHRoaXMgbm9kZSwgYSBzaGFsbG93IGNvcHlcbiAgICogQHJldHVybiB7QXNzaWdubWVudE5vZGV9XG4gICAqL1xuICBBc3NpZ25tZW50Tm9kZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IEFzc2lnbm1lbnROb2RlKHRoaXMub2JqZWN0LCB0aGlzLmluZGV4LCB0aGlzLnZhbHVlKTtcbiAgfTtcblxuICAvKlxuICAgKiBJcyBwYXJlbnRoZXNpcyBuZWVkZWQ/XG4gICAqIEBwYXJhbSB7bm9kZX0gbm9kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhcmVudGhlc2lzPSdrZWVwJ11cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIG5lZWRQYXJlbnRoZXNpcyhub2RlLCBwYXJlbnRoZXNpcykge1xuICAgIGlmICghcGFyZW50aGVzaXMpIHtcbiAgICAgIHBhcmVudGhlc2lzID0gJ2tlZXAnO1xuICAgIH1cblxuICAgIHZhciBwcmVjZWRlbmNlID0gb3BlcmF0b3JzLmdldFByZWNlZGVuY2Uobm9kZSwgcGFyZW50aGVzaXMpO1xuICAgIHZhciBleHByUHJlY2VkZW5jZSA9IG9wZXJhdG9ycy5nZXRQcmVjZWRlbmNlKG5vZGUudmFsdWUsIHBhcmVudGhlc2lzKTtcbiAgICByZXR1cm4gKHBhcmVudGhlc2lzID09PSAnYWxsJylcbiAgICAgIHx8ICgoZXhwclByZWNlZGVuY2UgIT09IG51bGwpICYmIChleHByUHJlY2VkZW5jZSA8PSBwcmVjZWRlbmNlKSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBBc3NpZ25tZW50Tm9kZS5wcm90b3R5cGUuX3RvU3RyaW5nID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBvYmplY3QgPSB0aGlzLm9iamVjdC50b1N0cmluZyhvcHRpb25zKTtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4ID8gdGhpcy5pbmRleC50b1N0cmluZyhvcHRpb25zKSA6ICcnO1xuICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWUudG9TdHJpbmcob3B0aW9ucyk7XG4gICAgaWYgKG5lZWRQYXJlbnRoZXNpcyh0aGlzLCBvcHRpb25zICYmIG9wdGlvbnMucGFyZW50aGVzaXMpKSB7XG4gICAgICB2YWx1ZSA9ICcoJyArIHZhbHVlICsgJyknO1xuICAgIH1cblxuICAgIHJldHVybiBvYmplY3QgKyBpbmRleCArICcgPSAnICsgdmFsdWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBMYVRlWCByZXByZXNlbnRhdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBBc3NpZ25tZW50Tm9kZS5wcm90b3R5cGUuX3RvVGV4ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBvYmplY3QgPSB0aGlzLm9iamVjdC50b1RleChvcHRpb25zKTtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4ID8gdGhpcy5pbmRleC50b1RleChvcHRpb25zKSA6ICcnO1xuICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWUudG9UZXgob3B0aW9ucyk7XG4gICAgaWYgKG5lZWRQYXJlbnRoZXNpcyh0aGlzLCBvcHRpb25zICYmIG9wdGlvbnMucGFyZW50aGVzaXMpKSB7XG4gICAgICB2YWx1ZSA9ICdcXFxcbGVmdCgnICsgdmFsdWUgKyAnXFxcXHJpZ2h0KSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iamVjdCArIGluZGV4ICsgJzo9JyArIHZhbHVlO1xuICB9O1xuXG4gIHJldHVybiBBc3NpZ25tZW50Tm9kZTtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ0Fzc2lnbm1lbnROb2RlJztcbmV4cG9ydHMucGF0aCA9ICdleHByZXNzaW9uLm5vZGUnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgTm9kZSA9IGxvYWQocmVxdWlyZSgnLi9Ob2RlJykpO1xuICB2YXIgUmVzdWx0U2V0ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL3Jlc3VsdHNldC9SZXN1bHRTZXQnKSk7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvciBCbG9ja05vZGVcbiAgICogQGV4dGVuZHMge05vZGV9XG4gICAqIEhvbGRzIGEgc2V0IHdpdGggYmxvY2tzXG4gICAqIEBwYXJhbSB7QXJyYXkuPHtub2RlOiBOb2RlfSB8IHtub2RlOiBOb2RlLCB2aXNpYmxlOiBib29sZWFufT59IGJsb2Nrc1xuICAgKiAgICAgICAgICAgIEFuIGFycmF5IHdpdGggYmxvY2tzLCB3aGVyZSBhIGJsb2NrIGlzIGNvbnN0cnVjdGVkIGFzIGFuIE9iamVjdFxuICAgKiAgICAgICAgICAgIHdpdGggcHJvcGVydGllcyBibG9jaywgd2hpY2ggaXMgYSBOb2RlLCBhbmQgdmlzaWJsZSwgd2hpY2ggaXNcbiAgICogICAgICAgICAgICBhIGJvb2xlYW4uIFRoZSBwcm9wZXJ0eSB2aXNpYmxlIGlzIG9wdGlvbmFsIGFuZCBpcyB0cnVlIGJ5IGRlZmF1bHRcbiAgICovXG4gIGZ1bmN0aW9uIEJsb2NrTm9kZShibG9ja3MpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQmxvY2tOb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdDb25zdHJ1Y3RvciBtdXN0IGJlIGNhbGxlZCB3aXRoIHRoZSBuZXcgb3BlcmF0b3InKTtcbiAgICB9XG5cbiAgICAvLyB2YWxpZGF0ZSBpbnB1dCwgY29weSBibG9ja3NcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYmxvY2tzKSkgdGhyb3cgbmV3IEVycm9yKCdBcnJheSBleHBlY3RlZCcpO1xuICAgIHRoaXMuYmxvY2tzID0gYmxvY2tzLm1hcChmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgIHZhciBub2RlID0gYmxvY2sgJiYgYmxvY2subm9kZTtcbiAgICAgIHZhciB2aXNpYmxlID0gYmxvY2sgJiYgYmxvY2sudmlzaWJsZSAhPT0gdW5kZWZpbmVkID8gYmxvY2sudmlzaWJsZSA6IHRydWU7XG5cbiAgICAgIGlmICghKG5vZGUgJiYgbm9kZS5pc05vZGUpKSAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb3BlcnR5IFwibm9kZVwiIG11c3QgYmUgYSBOb2RlJyk7XG4gICAgICBpZiAodHlwZW9mIHZpc2libGUgIT09ICdib29sZWFuJykgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJvcGVydHkgXCJ2aXNpYmxlXCIgbXVzdCBiZSBhIGJvb2xlYW4nKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgdmlzaWJsZTogdmlzaWJsZVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgQmxvY2tOb2RlLnByb3RvdHlwZSA9IG5ldyBOb2RlKCk7XG5cbiAgQmxvY2tOb2RlLnByb3RvdHlwZS50eXBlID0gJ0Jsb2NrTm9kZSc7XG5cbiAgQmxvY2tOb2RlLnByb3RvdHlwZS5pc0Jsb2NrTm9kZSA9IHRydWU7XG5cbiAgLyoqXG4gICAqIENvbXBpbGUgdGhlIG5vZGUgdG8gamF2YXNjcmlwdCBjb2RlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkZWZzICAgICBPYmplY3Qgd2hpY2ggY2FuIGJlIHVzZWQgdG8gZGVmaW5lIGZ1bmN0aW9uc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgb3IgY29uc3RhbnRzIGdsb2JhbGx5IGF2YWlsYWJsZSBmb3IgdGhlIGNvbXBpbGVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzICAgICBPYmplY3Qgd2l0aCBsb2NhbCBmdW5jdGlvbiBhcmd1bWVudHMsIHRoZSBrZXkgaXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBuYW1lIG9mIHRoZSBhcmd1bWVudCwgYW5kIHRoZSB2YWx1ZSBpcyBgdHJ1ZWAuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgb2JqZWN0IG1heSBub3QgYmUgbXV0YXRlZCwgYnV0IG11c3QgYmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuZGVkIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge3N0cmluZ30ganNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEJsb2NrTm9kZS5wcm90b3R5cGUuX2NvbXBpbGUgPSBmdW5jdGlvbiAoZGVmcywgYXJncykge1xuICAgIGRlZnMuUmVzdWx0U2V0ID0gUmVzdWx0U2V0O1xuICAgIHZhciBibG9ja3MgPSB0aGlzLmJsb2Nrcy5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICB2YXIganMgPSBwYXJhbS5ub2RlLl9jb21waWxlKGRlZnMsIGFyZ3MpO1xuICAgICAgaWYgKHBhcmFtLnZpc2libGUpIHtcbiAgICAgICAgcmV0dXJuICdyZXN1bHRzLnB1c2goJyArIGpzICsgJyk7JztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4ganMgKyAnOyc7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gJyhmdW5jdGlvbiAoKSB7JyArXG4gICAgICAgICd2YXIgcmVzdWx0cyA9IFtdOycgK1xuICAgICAgICBibG9ja3Muam9pbignJykgK1xuICAgICAgICAncmV0dXJuIG5ldyBSZXN1bHRTZXQocmVzdWx0cyk7JyArXG4gICAgICAgICd9KSgpJztcbiAgfTtcblxuICAvKipcbiAgICogRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBlYWNoIG9mIHRoZSBjaGlsZCBibG9ja3Mgb2YgdGhpcyBub2RlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oY2hpbGQ6IE5vZGUsIHBhdGg6IHN0cmluZywgcGFyZW50OiBOb2RlKX0gY2FsbGJhY2tcbiAgICovXG4gIEJsb2NrTm9kZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ibG9ja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNhbGxiYWNrKHRoaXMuYmxvY2tzW2ldLm5vZGUsICdibG9ja3NbJyArIGkgKyAnXS5ub2RlJywgdGhpcyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgQmxvY2tOb2RlIGhhdmluZyBpdCdzIGNoaWxkcyBiZSB0aGUgcmVzdWx0cyBvZiBjYWxsaW5nXG4gICAqIHRoZSBwcm92aWRlZCBjYWxsYmFjayBmdW5jdGlvbiBmb3IgZWFjaCBvZiB0aGUgY2hpbGRzIG9mIHRoZSBvcmlnaW5hbCBub2RlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGNoaWxkOiBOb2RlLCBwYXRoOiBzdHJpbmcsIHBhcmVudDogTm9kZSk6IE5vZGV9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtCbG9ja05vZGV9IFJldHVybnMgYSB0cmFuc2Zvcm1lZCBjb3B5IG9mIHRoZSBub2RlXG4gICAqL1xuICBCbG9ja05vZGUucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHZhciBibG9ja3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYmxvY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYmxvY2sgPSB0aGlzLmJsb2Nrc1tpXTtcbiAgICAgIHZhciBub2RlID0gdGhpcy5faWZOb2RlKGNhbGxiYWNrKGJsb2NrLm5vZGUsICdibG9ja3NbJyArIGkgKyAnXS5ub2RlJywgdGhpcykpO1xuICAgICAgYmxvY2tzW2ldID0ge1xuICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICB2aXNpYmxlOiBibG9jay52aXNpYmxlXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEJsb2NrTm9kZShibG9ja3MpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBjbG9uZSBvZiB0aGlzIG5vZGUsIGEgc2hhbGxvdyBjb3B5XG4gICAqIEByZXR1cm4ge0Jsb2NrTm9kZX1cbiAgICovXG4gIEJsb2NrTm9kZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJsb2NrcyA9IHRoaXMuYmxvY2tzLm1hcChmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5vZGU6IGJsb2NrLm5vZGUsXG4gICAgICAgIHZpc2libGU6IGJsb2NrLnZpc2libGVcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmV3IEJsb2NrTm9kZShibG9ja3MpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge3N0cmluZ30gc3RyXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgQmxvY2tOb2RlLnByb3RvdHlwZS5fdG9TdHJpbmcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmJsb2Nrcy5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICByZXR1cm4gcGFyYW0ubm9kZS50b1N0cmluZyhvcHRpb25zKSArIChwYXJhbS52aXNpYmxlID8gJycgOiAnOycpO1xuICAgIH0pLmpvaW4oJ1xcbicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgTGFUZVggcmVwcmVzZW50YXRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7c3RyaW5nfSBzdHJcbiAgICovXG4gIEJsb2NrTm9kZS5wcm90b3R5cGUuX3RvVGV4ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5ibG9ja3MubWFwKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgcmV0dXJuIHBhcmFtLm5vZGUudG9UZXgob3B0aW9ucykgKyAocGFyYW0udmlzaWJsZSA/ICcnIDogJzsnKTtcbiAgICB9KS5qb2luKCdcXFxcO1xcXFw7XFxuJyk7XG4gIH07XG5cbiAgcmV0dXJuIEJsb2NrTm9kZTtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ0Jsb2NrTm9kZSc7XG5leHBvcnRzLnBhdGggPSAnZXhwcmVzc2lvbi5ub2RlJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBsYXRleCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2xhdGV4Jyk7XG52YXIgb3BlcmF0b3JzID0gcmVxdWlyZSgnLi4vb3BlcmF0b3JzJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIE5vZGUgPSBsb2FkKHJlcXVpcmUoJy4vTm9kZScpKTtcblxuICAvKipcbiAgICogQSBsYXp5IGV2YWx1YXRpbmcgY29uZGl0aW9uYWwgb3BlcmF0b3I6ICdjb25kaXRpb24gPyB0cnVlRXhwciA6IGZhbHNlRXhwcidcbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBjb25kaXRpb24gICBDb25kaXRpb24sIG11c3QgcmVzdWx0IGluIGEgYm9vbGVhblxuICAgKiBAcGFyYW0ge05vZGV9IHRydWVFeHByICAgIEV4cHJlc3Npb24gZXZhbHVhdGVkIHdoZW4gY29uZGl0aW9uIGlzIHRydWVcbiAgICogQHBhcmFtIHtOb2RlfSBmYWxzZUV4cHIgICBFeHByZXNzaW9uIGV2YWx1YXRlZCB3aGVuIGNvbmRpdGlvbiBpcyB0cnVlXG4gICAqXG4gICAqIEBjb25zdHJ1Y3RvciBDb25kaXRpb25hbE5vZGVcbiAgICogQGV4dGVuZHMge05vZGV9XG4gICAqL1xuICBmdW5jdGlvbiBDb25kaXRpb25hbE5vZGUoY29uZGl0aW9uLCB0cnVlRXhwciwgZmFsc2VFeHByKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENvbmRpdGlvbmFsTm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQ29uc3RydWN0b3IgbXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgbmV3IG9wZXJhdG9yJyk7XG4gICAgfVxuICAgIGlmICghKGNvbmRpdGlvbiAmJiBjb25kaXRpb24uaXNOb2RlKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignUGFyYW1ldGVyIGNvbmRpdGlvbiBtdXN0IGJlIGEgTm9kZScpO1xuICAgIGlmICghKHRydWVFeHByICYmIHRydWVFeHByLmlzTm9kZSkpICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQYXJhbWV0ZXIgdHJ1ZUV4cHIgbXVzdCBiZSBhIE5vZGUnKTtcbiAgICBpZiAoIShmYWxzZUV4cHIgJiYgZmFsc2VFeHByLmlzTm9kZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BhcmFtZXRlciBmYWxzZUV4cHIgbXVzdCBiZSBhIE5vZGUnKTtcblxuICAgIHRoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgIHRoaXMudHJ1ZUV4cHIgPSB0cnVlRXhwcjtcbiAgICB0aGlzLmZhbHNlRXhwciA9IGZhbHNlRXhwcjtcbiAgfVxuXG4gIENvbmRpdGlvbmFsTm9kZS5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuXG4gIENvbmRpdGlvbmFsTm9kZS5wcm90b3R5cGUudHlwZSA9ICdDb25kaXRpb25hbE5vZGUnO1xuXG4gIENvbmRpdGlvbmFsTm9kZS5wcm90b3R5cGUuaXNDb25kaXRpb25hbE5vZGUgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBDb21waWxlIHRoZSBub2RlIHRvIGphdmFzY3JpcHQgY29kZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGVmcyAgICAgT2JqZWN0IHdoaWNoIGNhbiBiZSB1c2VkIHRvIGRlZmluZSBmdW5jdGlvbnNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGNvbnN0YW50cyBnbG9iYWxseSBhdmFpbGFibGUgZm9yIHRoZSBjb21waWxlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvblxuICAgKiBAcGFyYW0ge09iamVjdH0gYXJncyAgICAgT2JqZWN0IHdpdGggbG9jYWwgZnVuY3Rpb24gYXJndW1lbnRzLCB0aGUga2V5IGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgbmFtZSBvZiB0aGUgYXJndW1lbnQsIGFuZCB0aGUgdmFsdWUgaXMgYHRydWVgLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG9iamVjdCBtYXkgbm90IGJlIG11dGF0ZWQsIGJ1dCBtdXN0IGJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbmRlZCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IGpzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBDb25kaXRpb25hbE5vZGUucHJvdG90eXBlLl9jb21waWxlID0gZnVuY3Rpb24gKGRlZnMsIGFyZ3MpIHtcbiAgICAvKipcbiAgICAgKiBUZXN0IHdoZXRoZXIgYSBjb25kaXRpb24gaXMgbWV0XG4gICAgICogQHBhcmFtIHsqfSBjb25kaXRpb25cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBjb25kaXRpb24gaXMgdHJ1ZSBvciBub24temVybywgZWxzZSBmYWxzZVxuICAgICAqL1xuICAgIGRlZnMudGVzdENvbmRpdGlvbiA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHtcbiAgICAgIGlmICh0eXBlb2YgY29uZGl0aW9uID09PSAnbnVtYmVyJ1xuICAgICAgICAgIHx8IHR5cGVvZiBjb25kaXRpb24gPT09ICdib29sZWFuJ1xuICAgICAgICAgIHx8IHR5cGVvZiBjb25kaXRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBjb25kaXRpb24gPyB0cnVlIDogZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb25kaXRpb24pIHtcbiAgICAgICAgaWYgKGNvbmRpdGlvbi5pc0JpZ051bWJlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybiBjb25kaXRpb24uaXNaZXJvKCkgPyBmYWxzZSA6IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZGl0aW9uLmlzQ29tcGxleCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybiAoY29uZGl0aW9uLnJlIHx8IGNvbmRpdGlvbi5pbSkgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZGl0aW9uLmlzVW5pdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybiBjb25kaXRpb24udmFsdWUgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNvbmRpdGlvbiA9PT0gbnVsbCB8fCBjb25kaXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vuc3VwcG9ydGVkIHR5cGUgb2YgY29uZGl0aW9uIFwiJyArIGRlZnMubWF0aFsndHlwZW9mJ10oY29uZGl0aW9uKSArICdcIicpO1xuICAgIH07XG5cbiAgICByZXR1cm4gKFxuICAgICAgJ3Rlc3RDb25kaXRpb24oJyArIHRoaXMuY29uZGl0aW9uLl9jb21waWxlKGRlZnMsIGFyZ3MpICsgJykgPyAnICtcbiAgICAgICcoICcgKyB0aGlzLnRydWVFeHByLl9jb21waWxlKGRlZnMsIGFyZ3MpICsgJykgOiAnICtcbiAgICAgICcoICcgKyB0aGlzLmZhbHNlRXhwci5fY29tcGlsZShkZWZzLCBhcmdzKSArICcpJ1xuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZWFjaCBvZiB0aGUgY2hpbGQgbm9kZXMgb2YgdGhpcyBub2RlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oY2hpbGQ6IE5vZGUsIHBhdGg6IHN0cmluZywgcGFyZW50OiBOb2RlKX0gY2FsbGJhY2tcbiAgICovXG4gIENvbmRpdGlvbmFsTm9kZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKHRoaXMuY29uZGl0aW9uLCAnY29uZGl0aW9uJywgdGhpcyk7XG4gICAgY2FsbGJhY2sodGhpcy50cnVlRXhwciwgJ3RydWVFeHByJywgdGhpcyk7XG4gICAgY2FsbGJhY2sodGhpcy5mYWxzZUV4cHIsICdmYWxzZUV4cHInLCB0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IENvbmRpdGlvbmFsTm9kZSBoYXZpbmcgaXQncyBjaGlsZHMgYmUgdGhlIHJlc3VsdHMgb2YgY2FsbGluZ1xuICAgKiB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIGVhY2ggb2YgdGhlIGNoaWxkcyBvZiB0aGUgb3JpZ2luYWwgbm9kZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihjaGlsZDogTm9kZSwgcGF0aDogc3RyaW5nLCBwYXJlbnQ6IE5vZGUpOiBOb2RlfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7Q29uZGl0aW9uYWxOb2RlfSBSZXR1cm5zIGEgdHJhbnNmb3JtZWQgY29weSBvZiB0aGUgbm9kZVxuICAgKi9cbiAgQ29uZGl0aW9uYWxOb2RlLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gbmV3IENvbmRpdGlvbmFsTm9kZShcbiAgICAgICAgdGhpcy5faWZOb2RlKGNhbGxiYWNrKHRoaXMuY29uZGl0aW9uLCAnY29uZGl0aW9uJywgdGhpcykpLFxuICAgICAgICB0aGlzLl9pZk5vZGUoY2FsbGJhY2sodGhpcy50cnVlRXhwciwgJ3RydWVFeHByJywgdGhpcykpLFxuICAgICAgICB0aGlzLl9pZk5vZGUoY2FsbGJhY2sodGhpcy5mYWxzZUV4cHIsICdmYWxzZUV4cHInLCB0aGlzKSlcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBjbG9uZSBvZiB0aGlzIG5vZGUsIGEgc2hhbGxvdyBjb3B5XG4gICAqIEByZXR1cm4ge0NvbmRpdGlvbmFsTm9kZX1cbiAgICovXG4gIENvbmRpdGlvbmFsTm9kZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBDb25kaXRpb25hbE5vZGUodGhpcy5jb25kaXRpb24sIHRoaXMudHJ1ZUV4cHIsIHRoaXMuZmFsc2VFeHByKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHN0clxuICAgKi9cbiAgQ29uZGl0aW9uYWxOb2RlLnByb3RvdHlwZS5fdG9TdHJpbmcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBwYXJlbnRoZXNpcyA9IChvcHRpb25zICYmIG9wdGlvbnMucGFyZW50aGVzaXMpID8gb3B0aW9ucy5wYXJlbnRoZXNpcyA6ICdrZWVwJztcbiAgICB2YXIgcHJlY2VkZW5jZSA9IG9wZXJhdG9ycy5nZXRQcmVjZWRlbmNlKHRoaXMsIHBhcmVudGhlc2lzKTtcblxuICAgIC8vRW5jbG9zZSBBcmd1bWVudHMgaW4gcGFyZW50aGVzZXMgaWYgdGhleSBhcmUgYW4gT3BlcmF0b3JOb2RlXG4gICAgLy9vciBoYXZlIGxvd2VyIG9yIGVxdWFsIHByZWNlZGVuY2VcbiAgICAvL05PVEU6IGVuY2xvc2luZyBhbGwgT3BlcmF0b3JOb2RlcyBpbiBwYXJlbnRoZXNlcyBpcyBhIGRlY2lzaW9uXG4gICAgLy9wdXJlbHkgYmFzZWQgb24gYWVzdGhldGljcyBhbmQgcmVhZGFiaWxpdHlcbiAgICB2YXIgY29uZGl0aW9uID0gdGhpcy5jb25kaXRpb24udG9TdHJpbmcob3B0aW9ucyk7XG4gICAgdmFyIGNvbmRpdGlvblByZWNlZGVuY2UgPSBvcGVyYXRvcnMuZ2V0UHJlY2VkZW5jZSh0aGlzLmNvbmRpdGlvbiwgcGFyZW50aGVzaXMpO1xuICAgIGlmICgocGFyZW50aGVzaXMgPT09ICdhbGwnKVxuICAgICAgICB8fCAodGhpcy5jb25kaXRpb24udHlwZSA9PT0gJ09wZXJhdG9yTm9kZScpXG4gICAgICAgIHx8ICgoY29uZGl0aW9uUHJlY2VkZW5jZSAhPT0gbnVsbCkgJiYgKGNvbmRpdGlvblByZWNlZGVuY2UgPD0gcHJlY2VkZW5jZSkpKSB7XG4gICAgICBjb25kaXRpb24gPSAnKCcgKyBjb25kaXRpb24gKyAnKSc7XG4gICAgfVxuXG4gICAgdmFyIHRydWVFeHByID0gdGhpcy50cnVlRXhwci50b1N0cmluZyhvcHRpb25zKTtcbiAgICB2YXIgdHJ1ZVByZWNlZGVuY2UgPSBvcGVyYXRvcnMuZ2V0UHJlY2VkZW5jZSh0aGlzLnRydWVFeHByLCBwYXJlbnRoZXNpcyk7XG4gICAgaWYgKChwYXJlbnRoZXNpcyA9PT0gJ2FsbCcpXG4gICAgICAgIHx8ICh0aGlzLnRydWVFeHByLnR5cGUgPT09ICdPcGVyYXRvck5vZGUnKVxuICAgICAgICB8fCAoKHRydWVQcmVjZWRlbmNlICE9PSBudWxsKSAmJiAodHJ1ZVByZWNlZGVuY2UgPD0gcHJlY2VkZW5jZSkpKSB7XG4gICAgICB0cnVlRXhwciA9ICcoJyArIHRydWVFeHByICsgJyknO1xuICAgIH1cblxuICAgIHZhciBmYWxzZUV4cHIgPSB0aGlzLmZhbHNlRXhwci50b1N0cmluZyhvcHRpb25zKTtcbiAgICB2YXIgZmFsc2VQcmVjZWRlbmNlID0gb3BlcmF0b3JzLmdldFByZWNlZGVuY2UodGhpcy5mYWxzZUV4cHIsIHBhcmVudGhlc2lzKTtcbiAgICBpZiAoKHBhcmVudGhlc2lzID09PSAnYWxsJylcbiAgICAgICAgfHwgKHRoaXMuZmFsc2VFeHByLnR5cGUgPT09ICdPcGVyYXRvck5vZGUnKVxuICAgICAgICB8fCAoKGZhbHNlUHJlY2VkZW5jZSAhPT0gbnVsbCkgJiYgKGZhbHNlUHJlY2VkZW5jZSA8PSBwcmVjZWRlbmNlKSkpIHtcbiAgICAgIGZhbHNlRXhwciA9ICcoJyArIGZhbHNlRXhwciArICcpJztcbiAgICB9XG4gICAgcmV0dXJuIGNvbmRpdGlvbiArICcgPyAnICsgdHJ1ZUV4cHIgKyAnIDogJyArIGZhbHNlRXhwcjtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IExhVGVYIHJlcHJlc2VudGF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge3N0cmluZ30gc3RyXG4gICAqL1xuICBDb25kaXRpb25hbE5vZGUucHJvdG90eXBlLl90b1RleCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgcmV0dXJuICdcXFxcYmVnaW57Y2FzZXN9IHsnXG4gICAgICAgICsgdGhpcy50cnVlRXhwci50b1RleChvcHRpb25zKSArICd9LCAmXFxcXHF1YWR7XFxcXHRleHR7aWYgfVxcXFw7J1xuICAgICAgICArIHRoaXMuY29uZGl0aW9uLnRvVGV4KG9wdGlvbnMpXG4gICAgICAgICsgJ31cXFxcXFxcXHsnICsgdGhpcy5mYWxzZUV4cHIudG9UZXgob3B0aW9ucylcbiAgICAgICAgKyAnfSwgJlxcXFxxdWFke1xcXFx0ZXh0e290aGVyd2lzZX19XFxcXGVuZHtjYXNlc30nO1xuICB9O1xuXG4gIHJldHVybiBDb25kaXRpb25hbE5vZGU7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdDb25kaXRpb25hbE5vZGUnO1xuZXhwb3J0cy5wYXRoID0gJ2V4cHJlc3Npb24ubm9kZSc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2V0VHlwZSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3R5cGVzJykudHlwZTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgTm9kZSA9IGxvYWQocmVxdWlyZSgnLi9Ob2RlJykpO1xuXG4gIC8qKlxuICAgKiBBIENvbnN0YW50Tm9kZSBob2xkcyBhIGNvbnN0YW50IHZhbHVlIGxpa2UgYSBudW1iZXIgb3Igc3RyaW5nLiBBIENvbnN0YW50Tm9kZVxuICAgKiBzdG9yZXMgYSBzdHJpbmdpZmllZCB2ZXJzaW9uIG9mIHRoZSB2YWx1ZSBhbmQgdXNlcyB0aGlzIHRvIGNvbXBpbGUgdG9cbiAgICogSmF2YVNjcmlwdC5cbiAgICpcbiAgICogSW4gY2FzZSBvZiBhIHN0cmluZ2lmaWVkIG51bWJlciBhcyBpbnB1dCwgdGhpcyBtYXkgYmUgY29tcGlsZWQgdG8gYSBCaWdOdW1iZXJcbiAgICogd2hlbiB0aGUgbWF0aCBpbnN0YW5jZSBpcyBjb25maWd1cmVkIGZvciBCaWdOdW1iZXJzLlxuICAgKlxuICAgKiBVc2FnZTpcbiAgICpcbiAgICogICAgIC8vIHN0cmluZ2lmaWVkIHZhbHVlcyB3aXRoIHR5cGVcbiAgICogICAgIG5ldyBDb25zdGFudE5vZGUoJzIuMycsICdudW1iZXInKTtcbiAgICogICAgIG5ldyBDb25zdGFudE5vZGUoJ3RydWUnLCAnYm9vbGVhbicpO1xuICAgKiAgICAgbmV3IENvbnN0YW50Tm9kZSgnaGVsbG8nLCAnc3RyaW5nJyk7XG4gICAqXG4gICAqICAgICAvLyBub24tc3RyaW5naWZpZWQgdmFsdWVzLCB0eXBlIHdpbGwgYmUgYXV0b21hdGljYWxseSBkZXRlY3RlZFxuICAgKiAgICAgbmV3IENvbnN0YW50Tm9kZSgyLjMpO1xuICAgKiAgICAgbmV3IENvbnN0YW50Tm9kZSgnaGVsbG8nKTtcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gdmFsdWVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgV2hlbiB2YWx1ZVR5cGUgaXMgcHJvdmlkZWQsIHZhbHVlIG11c3QgY29udGFpblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbiB1bmludGVycHJldGVkIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBXaGVuIHZhbHVlVHlwZSBpcyB1bmRlZmluZWQsIHZhbHVlIGNhbiBiZSBhXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlciwgc3RyaW5nLCBib29sZWFuLCBudWxsLCBvciB1bmRlZmluZWQsIGFuZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgdHlwZSB3aWxsIGJlIGRldGVybWluZWQgYXV0b21hdGljYWxseS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFt2YWx1ZVR5cGVdICBUaGUgdHlwZSBvZiB2YWx1ZS4gQ2hvb3NlIGZyb20gJ251bWJlcicsICdzdHJpbmcnLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdib29sZWFuJywgJ3VuZGVmaW5lZCcsICdudWxsJ1xuICAgKiBAY29uc3RydWN0b3IgQ29uc3RhbnROb2RlXG4gICAqIEBleHRlbmRzIHtOb2RlfVxuICAgKi9cbiAgZnVuY3Rpb24gQ29uc3RhbnROb2RlKHZhbHVlLCB2YWx1ZVR5cGUpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ29uc3RhbnROb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdDb25zdHJ1Y3RvciBtdXN0IGJlIGNhbGxlZCB3aXRoIHRoZSBuZXcgb3BlcmF0b3InKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWVUeXBlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlVHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU3RyaW5nIGV4cGVjdGVkIGZvciBwYXJhbWV0ZXIgXCJ2YWx1ZVR5cGVcIicpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU3RyaW5nIGV4cGVjdGVkIGZvciBwYXJhbWV0ZXIgXCJ2YWx1ZVwiJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHRoaXMudmFsdWVUeXBlID0gdmFsdWVUeXBlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIHN0cmluZ2lmeSB0aGUgdmFsdWUgYW5kIGRldGVybWluZSB0aGUgdHlwZVxuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlICsgJyc7XG4gICAgICB0aGlzLnZhbHVlVHlwZSA9IGdldFR5cGUodmFsdWUpO1xuICAgIH1cblxuICAgIGlmICghU1VQUE9SVEVEX1RZUEVTW3RoaXMudmFsdWVUeXBlXSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5zdXBwb3J0ZWQgdHlwZSBvZiB2YWx1ZSBcIicgKyB0aGlzLnZhbHVlVHlwZSArICdcIicpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBTVVBQT1JURURfVFlQRVMgPSB7XG4gICAgJ251bWJlcic6IHRydWUsXG4gICAgJ3N0cmluZyc6IHRydWUsXG4gICAgJ2Jvb2xlYW4nOiB0cnVlLFxuICAgICd1bmRlZmluZWQnOiB0cnVlLFxuICAgICdudWxsJzogdHJ1ZVxuICB9O1xuXG4gIENvbnN0YW50Tm9kZS5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuXG4gIENvbnN0YW50Tm9kZS5wcm90b3R5cGUudHlwZSA9ICdDb25zdGFudE5vZGUnO1xuXG4gIENvbnN0YW50Tm9kZS5wcm90b3R5cGUuaXNDb25zdGFudE5vZGUgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBDb21waWxlIHRoZSBub2RlIHRvIGphdmFzY3JpcHQgY29kZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGVmcyAgICAgT2JqZWN0IHdoaWNoIGNhbiBiZSB1c2VkIHRvIGRlZmluZSBmdW5jdGlvbnNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGNvbnN0YW50cyBnbG9iYWxseSBhdmFpbGFibGUgZm9yIHRoZSBjb21waWxlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvblxuICAgKiBAcGFyYW0ge09iamVjdH0gYXJncyAgICAgT2JqZWN0IHdpdGggbG9jYWwgZnVuY3Rpb24gYXJndW1lbnRzLCB0aGUga2V5IGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgbmFtZSBvZiB0aGUgYXJndW1lbnQsIGFuZCB0aGUgdmFsdWUgaXMgYHRydWVgLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG9iamVjdCBtYXkgbm90IGJlIG11dGF0ZWQsIGJ1dCBtdXN0IGJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbmRlZCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IGpzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBDb25zdGFudE5vZGUucHJvdG90eXBlLl9jb21waWxlID0gZnVuY3Rpb24gKGRlZnMsIGFyZ3MpIHtcbiAgICBzd2l0Y2ggKHRoaXMudmFsdWVUeXBlKSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAvLyBUT0RPOiByZXBsYWNlIHRoaXMgd2l0aCB1c2luZyBjb25maWcubnVtYmVyXG4gICAgICAgIHZhciBudW1Db25maWcgPSBkZWZzLm1hdGguY29uZmlnKCkubnVtYmVyO1xuICAgICAgICBpZiAobnVtQ29uZmlnID09PSAnQmlnTnVtYmVyJykge1xuICAgICAgICAgIHJldHVybiAnbWF0aC5iaWdudW1iZXIoXCInICsgdGhpcy52YWx1ZSArICdcIiknO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG51bUNvbmZpZyA9PT0gJ0ZyYWN0aW9uJykge1xuICAgICAgICAgIHJldHVybiAnbWF0aC5mcmFjdGlvbihcIicgKyB0aGlzLnZhbHVlICsgJ1wiKSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIGxlYWRpbmcgemVyb3MgbGlrZSAnMDAzLjInIHdoaWNoIGFyZSBub3QgYWxsb3dlZCBieSBKYXZhU2NyaXB0XG4gICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUucmVwbGFjZSgvXigwKilbMC05XS8sIGZ1bmN0aW9uIChtYXRjaCwgemVyb3MpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaC5zdWJzdHJpbmcoemVyb3MubGVuZ3RoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICByZXR1cm4gJ1wiJyArIHRoaXMudmFsdWUgKyAnXCInO1xuXG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG5cbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuXG4gICAgICBjYXNlICdudWxsJzpcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIFRPRE86IG1vdmUgdGhpcyBlcnJvciB0byB0aGUgY29uc3RydWN0b3I/XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vuc3VwcG9ydGVkIHR5cGUgb2YgY29uc3RhbnQgXCInICsgdGhpcy52YWx1ZVR5cGUgKyAnXCInKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZWFjaCBvZiB0aGUgY2hpbGQgbm9kZXMgb2YgdGhpcyBub2RlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oY2hpbGQ6IE5vZGUsIHBhdGg6IHN0cmluZywgcGFyZW50OiBOb2RlKX0gY2FsbGJhY2tcbiAgICovXG4gIENvbnN0YW50Tm9kZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIC8vIG5vdGhpbmcgdG8gZG8sIHdlIGRvbid0IGhhdmUgY2hpbGRzXG4gIH07XG5cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IENvbnN0YW50Tm9kZSBoYXZpbmcgaXQncyBjaGlsZHMgYmUgdGhlIHJlc3VsdHMgb2YgY2FsbGluZ1xuICAgKiB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIGVhY2ggb2YgdGhlIGNoaWxkcyBvZiB0aGUgb3JpZ2luYWwgbm9kZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihjaGlsZDogTm9kZSwgcGF0aDogc3RyaW5nLCBwYXJlbnQ6IE5vZGUpIDogTm9kZX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge0NvbnN0YW50Tm9kZX0gUmV0dXJucyBhIGNsb25lIG9mIHRoZSBub2RlXG4gICAqL1xuICBDb25zdGFudE5vZGUucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGNsb25lIG9mIHRoaXMgbm9kZSwgYSBzaGFsbG93IGNvcHlcbiAgICogQHJldHVybiB7Q29uc3RhbnROb2RlfVxuICAgKi9cbiAgQ29uc3RhbnROb2RlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IENvbnN0YW50Tm9kZSh0aGlzLnZhbHVlLCB0aGlzLnZhbHVlVHlwZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7c3RyaW5nfSBzdHJcbiAgICovXG4gIENvbnN0YW50Tm9kZS5wcm90b3R5cGUuX3RvU3RyaW5nID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBzd2l0Y2ggKHRoaXMudmFsdWVUeXBlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICByZXR1cm4gJ1wiJyArIHRoaXMudmFsdWUgKyAnXCInO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBMYVRlWCByZXByZXNlbnRhdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHN0clxuICAgKi9cbiAgQ29uc3RhbnROb2RlLnByb3RvdHlwZS5fdG9UZXggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWUsXG4gICAgICAgIGluZGV4O1xuICAgIHN3aXRjaCAodGhpcy52YWx1ZVR5cGUpIHtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIHJldHVybiAnXFxcXG1hdGh0dHtcIicgKyB2YWx1ZSArICdcIn0nO1xuXG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBpbmRleCA9IHZhbHVlLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignZScpO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlLnN1YnN0cmluZygwLCBpbmRleCkgKyAnXFxcXGNkb3QxMF57JyArXG4gICAgICAgICAgICAgIHZhbHVlLnN1YnN0cmluZyhpbmRleCArIDEpICsgJ30nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gQ29uc3RhbnROb2RlO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnQ29uc3RhbnROb2RlJztcbmV4cG9ydHMucGF0aCA9ICdleHByZXNzaW9uLm5vZGUnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGtleXdvcmRzID0gcmVxdWlyZSgnLi4va2V5d29yZHMnKTtcbnZhciBsYXRleCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2xhdGV4Jyk7XG52YXIgb3BlcmF0b3JzID0gcmVxdWlyZSgnLi4vb3BlcmF0b3JzJyk7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nICh4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ3N0cmluZyc7XG59XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIE5vZGUgPSBsb2FkKHJlcXVpcmUoJy4vTm9kZScpKTtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yIEZ1bmN0aW9uQXNzaWdubWVudE5vZGVcbiAgICogQGV4dGVuZHMge05vZGV9XG4gICAqIEZ1bmN0aW9uIGFzc2lnbm1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgICAgICAgICAgIEZ1bmN0aW9uIG5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1zICAgICAgIEZ1bmN0aW9uIHBhcmFtZXRlciBuYW1lc1xuICAgKiBAcGFyYW0ge05vZGV9IGV4cHIgICAgICAgICAgICAgVGhlIGZ1bmN0aW9uIGV4cHJlc3Npb25cbiAgICovXG4gIGZ1bmN0aW9uIEZ1bmN0aW9uQXNzaWdubWVudE5vZGUobmFtZSwgcGFyYW1zLCBleHByKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEZ1bmN0aW9uQXNzaWdubWVudE5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0NvbnN0cnVjdG9yIG11c3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBvcGVyYXRvcicpO1xuICAgIH1cblxuICAgIC8vIHZhbGlkYXRlIGlucHV0XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IFR5cGVFcnJvcignU3RyaW5nIGV4cGVjdGVkIGZvciBwYXJhbWV0ZXIgXCJuYW1lXCInKTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocGFyYW1zKSB8fCAhcGFyYW1zLmV2ZXJ5KGlzU3RyaW5nKSkgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5IGNvbnRhaW5pbmcgc3RyaW5ncyBleHBlY3RlZCBmb3IgcGFyYW1ldGVyIFwicGFyYW1zXCInKTtcbiAgICBpZiAoIShleHByICYmIGV4cHIuaXNOb2RlKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignTm9kZSBleHBlY3RlZCBmb3IgcGFyYW1ldGVyIFwiZXhwclwiJyk7XG4gICAgaWYgKG5hbWUgaW4ga2V5d29yZHMpIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBmdW5jdGlvbiBuYW1lLCBcIicgKyBuYW1lICsgJ1wiIGlzIGEgcmVzZXJ2ZWQga2V5d29yZCcpO1xuXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICB0aGlzLmV4cHIgPSBleHByO1xuICB9XG5cbiAgRnVuY3Rpb25Bc3NpZ25tZW50Tm9kZS5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuXG4gIEZ1bmN0aW9uQXNzaWdubWVudE5vZGUucHJvdG90eXBlLnR5cGUgPSAnRnVuY3Rpb25Bc3NpZ25tZW50Tm9kZSc7XG5cbiAgRnVuY3Rpb25Bc3NpZ25tZW50Tm9kZS5wcm90b3R5cGUuaXNGdW5jdGlvbkFzc2lnbm1lbnROb2RlID0gdHJ1ZTtcblxuICAvKipcbiAgICogQ29tcGlsZSB0aGUgbm9kZSB0byBqYXZhc2NyaXB0IGNvZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlZnMgICAgIE9iamVjdCB3aGljaCBjYW4gYmUgdXNlZCB0byBkZWZpbmUgZnVuY3Rpb25zXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBvciBjb25zdGFudHMgZ2xvYmFsbHkgYXZhaWxhYmxlIGZvciB0aGUgY29tcGlsZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgICAgIE9iamVjdCB3aXRoIGxvY2FsIGZ1bmN0aW9uIGFyZ3VtZW50cywgdGhlIGtleSBpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG5hbWUgb2YgdGhlIGFyZ3VtZW50LCBhbmQgdGhlIHZhbHVlIGlzIGB0cnVlYC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBvYmplY3QgbWF5IG5vdCBiZSBtdXRhdGVkLCBidXQgbXVzdCBiZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kZWQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7c3RyaW5nfSBqc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgRnVuY3Rpb25Bc3NpZ25tZW50Tm9kZS5wcm90b3R5cGUuX2NvbXBpbGUgPSBmdW5jdGlvbiAoZGVmcywgYXJncykge1xuICAgIC8vIHdlIGV4dGVuZCB0aGUgb3JpZ2luYWwgYXJncyBhbmQgYWRkIHRoZSBhcmdzIHRvIHRoZSBjaGlsZCBvYmplY3RcbiAgICB2YXIgY2hpbGRBcmdzID0gT2JqZWN0LmNyZWF0ZShhcmdzKTtcbiAgICB0aGlzLnBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uICh2YXJpYWJsZSkge1xuICAgICAgY2hpbGRBcmdzW3ZhcmlhYmxlXSA9IHRydWU7XG4gICAgfSk7XG5cbiAgICAvLyBjb21waWxlIHRoZSBmdW5jdGlvbiBleHByZXNzaW9uIHdpdGggdGhlIGNoaWxkIGFyZ3NcbiAgICB2YXIganNFeHByID0gdGhpcy5leHByLl9jb21waWxlKGRlZnMsIGNoaWxkQXJncyk7XG5cbiAgICByZXR1cm4gJ3Njb3BlW1wiJyArIHRoaXMubmFtZSArICdcIl0gPSAnICtcbiAgICAgICAgJyAgKGZ1bmN0aW9uICgpIHsnICtcbiAgICAgICAgJyAgICB2YXIgZm4gPSBmdW5jdGlvbiAnICsgdGhpcy5uYW1lICsgJygnICsgdGhpcy5wYXJhbXMuam9pbignLCcpICsgJykgeycgK1xuICAgICAgICAnICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gJyArIHRoaXMucGFyYW1zLmxlbmd0aCArICcpIHsnICtcbiAgICAgICAgICAvLyBUT0RPOiB1c2UgdXRpbC5lcnJvci5Bcmd1bWVudHNFcnJvciBoZXJlP1xuICAgICAgICAgIC8vIFRPRE86IHRlc3QgYXJndW1lbnRzIGVycm9yXG4gICAgICAgICcgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIldyb25nIG51bWJlciBvZiBhcmd1bWVudHMgaW4gZnVuY3Rpb24gJyArIHRoaXMubmFtZSArICcgKFwiICsgYXJndW1lbnRzLmxlbmd0aCArIFwiIHByb3ZpZGVkLCAnICsgdGhpcy5wYXJhbXMubGVuZ3RoICsgJyBleHBlY3RlZClcIik7JyArXG4gICAgICAgICcgICAgICB9JyArXG4gICAgICAgICcgICAgICByZXR1cm4gJyArIGpzRXhwciArICcnICtcbiAgICAgICAgJyAgICB9OycgK1xuICAgICAgICAnICAgIGZuLnN5bnRheCA9IFwiJyArIHRoaXMubmFtZSArICcoJyArIHRoaXMucGFyYW1zLmpvaW4oJywgJykgKyAnKVwiOycgK1xuICAgICAgICAnICAgIHJldHVybiBmbjsnICtcbiAgICAgICAgJyAgfSkoKSc7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZWFjaCBvZiB0aGUgY2hpbGQgbm9kZXMgb2YgdGhpcyBub2RlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oY2hpbGQ6IE5vZGUsIHBhdGg6IHN0cmluZywgcGFyZW50OiBOb2RlKX0gY2FsbGJhY2tcbiAgICovXG4gIEZ1bmN0aW9uQXNzaWdubWVudE5vZGUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayh0aGlzLmV4cHIsICdleHByJywgdGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBGdW5jdGlvbkFzc2lnbm1lbnROb2RlIGhhdmluZyBpdCdzIGNoaWxkcyBiZSB0aGUgcmVzdWx0cyBvZiBjYWxsaW5nXG4gICAqIHRoZSBwcm92aWRlZCBjYWxsYmFjayBmdW5jdGlvbiBmb3IgZWFjaCBvZiB0aGUgY2hpbGRzIG9mIHRoZSBvcmlnaW5hbCBub2RlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGNoaWxkOiBOb2RlLCBwYXRoOiBzdHJpbmcsIHBhcmVudDogTm9kZSk6IE5vZGV9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbkFzc2lnbm1lbnROb2RlfSBSZXR1cm5zIGEgdHJhbnNmb3JtZWQgY29weSBvZiB0aGUgbm9kZVxuICAgKi9cbiAgRnVuY3Rpb25Bc3NpZ25tZW50Tm9kZS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdmFyIGV4cHIgPSB0aGlzLl9pZk5vZGUoY2FsbGJhY2sodGhpcy5leHByLCAnZXhwcicsIHRoaXMpKTtcblxuICAgIHJldHVybiBuZXcgRnVuY3Rpb25Bc3NpZ25tZW50Tm9kZSh0aGlzLm5hbWUsIHRoaXMucGFyYW1zLnNsaWNlKDApLCBleHByKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgY2xvbmUgb2YgdGhpcyBub2RlLCBhIHNoYWxsb3cgY29weVxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbkFzc2lnbm1lbnROb2RlfVxuICAgKi9cbiAgRnVuY3Rpb25Bc3NpZ25tZW50Tm9kZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbkFzc2lnbm1lbnROb2RlKHRoaXMubmFtZSwgdGhpcy5wYXJhbXMuc2xpY2UoMCksIHRoaXMuZXhwcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIElzIHBhcmVudGhlc2lzIG5lZWRlZD9cbiAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnRoZXNpc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gbmVlZFBhcmVudGhlc2lzKG5vZGUsIHBhcmVudGhlc2lzKSB7XG4gICAgdmFyIHByZWNlZGVuY2UgPSBvcGVyYXRvcnMuZ2V0UHJlY2VkZW5jZShub2RlLCBwYXJlbnRoZXNpcyk7XG4gICAgdmFyIGV4cHJQcmVjZWRlbmNlID0gb3BlcmF0b3JzLmdldFByZWNlZGVuY2Uobm9kZS5leHByLCBwYXJlbnRoZXNpcyk7XG5cbiAgICByZXR1cm4gKHBhcmVudGhlc2lzID09PSAnYWxsJylcbiAgICAgIHx8ICgoZXhwclByZWNlZGVuY2UgIT09IG51bGwpICYmIChleHByUHJlY2VkZW5jZSA8PSBwcmVjZWRlbmNlKSk7XG4gIH1cblxuICAvKipcbiAgICogZ2V0IHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHN0clxuICAgKi9cbiAgRnVuY3Rpb25Bc3NpZ25tZW50Tm9kZS5wcm90b3R5cGUuX3RvU3RyaW5nID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgcGFyZW50aGVzaXMgPSAob3B0aW9ucyAmJiBvcHRpb25zLnBhcmVudGhlc2lzKSA/IG9wdGlvbnMucGFyZW50aGVzaXMgOiAna2VlcCc7XG4gICAgdmFyIGV4cHIgPSB0aGlzLmV4cHIudG9TdHJpbmcob3B0aW9ucyk7XG4gICAgaWYgKG5lZWRQYXJlbnRoZXNpcyh0aGlzLCBwYXJlbnRoZXNpcykpIHtcbiAgICAgIGV4cHIgPSAnKCcgKyBleHByICsgJyknO1xuICAgIH1cbiAgICByZXR1cm4gJ2Z1bmN0aW9uICcgKyB0aGlzLm5hbWUgK1xuICAgICAgICAnKCcgKyB0aGlzLnBhcmFtcy5qb2luKCcsICcpICsgJykgPSAnICsgZXhwcjtcbiAgfTtcblxuICAvKipcbiAgICogZ2V0IExhVGVYIHJlcHJlc2VudGF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge3N0cmluZ30gc3RyXG4gICAqL1xuICBGdW5jdGlvbkFzc2lnbm1lbnROb2RlLnByb3RvdHlwZS5fdG9UZXggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBwYXJlbnRoZXNpcyA9IChvcHRpb25zICYmIG9wdGlvbnMucGFyZW50aGVzaXMpID8gb3B0aW9ucy5wYXJlbnRoZXNpcyA6ICdrZWVwJztcbiAgICB2YXIgZXhwciA9IHRoaXMuZXhwci50b1RleChvcHRpb25zKTtcbiAgICBpZiAobmVlZFBhcmVudGhlc2lzKHRoaXMsIHBhcmVudGhlc2lzKSkge1xuICAgICAgZXhwciA9ICdcXFxcbGVmdCgnICsgZXhwciArICdcXFxccmlnaHQpJztcbiAgICB9XG5cbiAgICByZXR1cm4gJ1xcXFxtYXRocm17JyArIHRoaXMubmFtZVxuICAgICAgICArICd9XFxcXGxlZnQoJyArIHRoaXMucGFyYW1zLm1hcChsYXRleC50b1N5bWJvbCkuam9pbignLCcpICsgJ1xcXFxyaWdodCk6PScgKyBleHByO1xuICB9O1xuXG4gIHJldHVybiBGdW5jdGlvbkFzc2lnbm1lbnROb2RlO1xufVxuZXhwb3J0cy5uYW1lID0gJ0Z1bmN0aW9uQXNzaWdubWVudE5vZGUnO1xuZXhwb3J0cy5wYXRoID0gJ2V4cHJlc3Npb24ubm9kZSc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbGF0ZXggPSByZXF1aXJlKCcuLi8uLi91dGlscy9sYXRleCcpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkLCBtYXRoKSB7XG4gIHZhciBOb2RlID0gbG9hZChyZXF1aXJlKCcuL05vZGUnKSk7XG4gIHZhciBTeW1ib2xOb2RlID0gbG9hZChyZXF1aXJlKCcuL1N5bWJvbE5vZGUnKSk7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvciBGdW5jdGlvbk5vZGVcbiAgICogQGV4dGVuZHMgey4vTm9kZX1cbiAgICogaW52b2tlIGEgbGlzdCB3aXRoIGFyZ3VtZW50cyBvbiBhIG5vZGVcbiAgICogQHBhcmFtIHsuL05vZGV9IGZuICAgICAgIE5vZGUgcmVzb2x2aW5nIHdpdGggYSBmdW5jdGlvbiBvbiB3aGljaCB0byBpbnZva2VcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBhcmd1bWVudHMsIHR5cGljYWxseSBhIFN5bWJvTm9kZSBvciBBY2Nlc3Nvck5vZGVcbiAgICogQHBhcmFtIHsuL05vZGVbXX0gYXJnc1xuICAgKi9cbiAgZnVuY3Rpb24gRnVuY3Rpb25Ob2RlKGZuLCBhcmdzKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEZ1bmN0aW9uTm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQ29uc3RydWN0b3IgbXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgbmV3IG9wZXJhdG9yJyk7XG4gICAgfVxuXG4gICAgLy8gVE9ETyBkZXByZWNhdGVkIHNpbmNlIHYzLjAsIGNsZWFudXAgc29tZSBkYXlcbiAgICBpZiAodHlwZW9mIGZuID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBwYXNzaW5nIGEgc3RyaW5nIHRvIEZ1bmN0aW9uTm9kZSBpcyBkZXByZWNhdGVkLCBwYXNzIGEgU3ltYm9sTm9kZSBpbnN0ZWFkLicpO1xuICAgICAgZm4gPSBuZXcgU3ltYm9sTm9kZShmbik7XG4gICAgfVxuXG4gICAgLy8gdmFsaWRhdGUgaW5wdXRcbiAgICBpZiAoIWZuIHx8ICFmbi5pc05vZGUpIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vZGUgZXhwZWN0ZWQgYXMgcGFyYW1ldGVyIFwiZm5cIicpO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcmdzKVxuICAgICAgICB8fCAhYXJncy5ldmVyeShmdW5jdGlvbiAoYXJnKSB7cmV0dXJuIGFyZyAmJiBhcmcuaXNOb2RlO30pKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheSBjb250YWluaW5nIE5vZGVzIGV4cGVjdGVkIGZvciBwYXJhbWV0ZXIgXCJhcmdzXCInKTtcbiAgICB9XG5cbiAgICB0aGlzLmZuID0gZm47XG4gICAgdGhpcy5hcmdzID0gYXJncyB8fCBbXTtcblxuICAgIC8vIHJlYWRvbmx5IHByb3BlcnR5IG5hbWVcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ25hbWUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm4ubmFtZSB8fCAnJztcbiAgICAgIH0uYmluZCh0aGlzKSxcbiAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhc3NpZ24gYSBuZXcgbmFtZSwgbmFtZSBpcyByZWFkLW9ubHknKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFRPRE86IGRlcHJlY2F0ZWQgc2luY2UgdjMsIHJlbW92ZSBzb21lIGRheVxuICAgIHZhciBkZXByZWNhdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9wZXJ0eSBgRnVuY3Rpb25Ob2RlLm9iamVjdGAgaXMgZGVwcmVjYXRlZCwgdXNlIGBGdW5jdGlvbk5vZGUuZm5gIGluc3RlYWQnKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnb2JqZWN0JywgeyBnZXQ6IGRlcHJlY2F0ZWQsIHNldDogZGVwcmVjYXRlZCB9KTtcbiAgfVxuXG4gIEZ1bmN0aW9uTm9kZS5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuXG4gIEZ1bmN0aW9uTm9kZS5wcm90b3R5cGUudHlwZSA9ICdGdW5jdGlvbk5vZGUnO1xuXG4gIEZ1bmN0aW9uTm9kZS5wcm90b3R5cGUuaXNGdW5jdGlvbk5vZGUgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBDb21waWxlIHRoZSBub2RlIHRvIGphdmFzY3JpcHQgY29kZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGVmcyAgICAgT2JqZWN0IHdoaWNoIGNhbiBiZSB1c2VkIHRvIGRlZmluZSBmdW5jdGlvbnNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGNvbnN0YW50cyBnbG9iYWxseSBhdmFpbGFibGUgZm9yIHRoZSBjb21waWxlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvblxuICAgKiBAcGFyYW0ge09iamVjdH0gYXJncyAgICAgT2JqZWN0IHdpdGggbG9jYWwgZnVuY3Rpb24gYXJndW1lbnRzLCB0aGUga2V5IGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgbmFtZSBvZiB0aGUgYXJndW1lbnQsIGFuZCB0aGUgdmFsdWUgaXMgYHRydWVgLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG9iamVjdCBtYXkgbm90IGJlIG11dGF0ZWQsIGJ1dCBtdXN0IGJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbmRlZCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IGpzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBGdW5jdGlvbk5vZGUucHJvdG90eXBlLl9jb21waWxlID0gZnVuY3Rpb24gKGRlZnMsIGFyZ3MpIHtcbiAgICAvLyBjb21waWxlIGZuIGFuZCBhcmd1bWVudHNcbiAgICB2YXIganNGbiA9IHRoaXMuZm4uX2NvbXBpbGUoZGVmcywgYXJncyk7XG4gICAgdmFyIGpzQXJncyA9IHRoaXMuYXJncy5tYXAoZnVuY3Rpb24gKGFyZykge1xuICAgICAgcmV0dXJuIGFyZy5fY29tcGlsZShkZWZzLCBhcmdzKTtcbiAgICB9KTtcbiAgICB2YXIgYXJnc05hbWU7XG5cbiAgICBpZiAodGhpcy5mbi5pc1N5bWJvbE5vZGUpIHtcbiAgICAgIC8vIHdlIGNhbiBzdGF0aWNhbGx5IGRldGVybWluZSB3aGV0aGVyIHRoZSBmdW5jdGlvbiBoYXMgYW4gcmF3QXJncyBwcm9wZXJ0eVxuICAgICAgdmFyIG5hbWUgPSB0aGlzLmZuLm5hbWU7XG4gICAgICB2YXIgZm4gPSBkZWZzLm1hdGhbbmFtZV07XG4gICAgICB2YXIgaXNSYXcgPSAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSAmJiAoZm4ucmF3QXJncyA9PSB0cnVlKTtcblxuICAgICAgaWYgKGlzUmF3KSB7XG4gICAgICAgIC8vIHBhc3MgdW5ldmFsdWF0ZWQgcGFyYW1ldGVycyAobm9kZXMpIHRvIHRoZSBmdW5jdGlvblxuICAgICAgICBhcmdzTmFtZSA9IHRoaXMuX2dldFVuaXF1ZUFyZ3VtZW50c05hbWUoZGVmcyk7XG4gICAgICAgIGRlZnNbYXJnc05hbWVdID0gdGhpcy5hcmdzO1xuXG4gICAgICAgIHJldHVybiBqc0ZuICsgJygnICsgYXJnc05hbWUgKyAnLCBtYXRoLCBzY29wZSknO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIFwicmVndWxhclwiIGV2YWx1YXRpb25cbiAgICAgICAgcmV0dXJuIGpzRm4gKyAnKCcgKyBqc0FyZ3Muam9pbignLCAnKSArICcpJztcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5mbi5pc0FjY2Vzc29yTm9kZSAmJiB0aGlzLmZuLmluZGV4LmlzT2JqZWN0UHJvcGVydHkoKSkge1xuICAgICAgLy8gZXhlY3V0ZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgcmlnaHQgY29udGV4dDogdGhlIG9iamVjdCBvZiB0aGUgQWNjZXNzb3JOb2RlXG4gICAgICBhcmdzTmFtZSA9IHRoaXMuX2dldFVuaXF1ZUFyZ3VtZW50c05hbWUoZGVmcyk7XG4gICAgICBkZWZzW2FyZ3NOYW1lXSA9IHRoaXMuYXJncztcblxuICAgICAgdmFyIGpzT2JqZWN0ID0gdGhpcy5mbi5vYmplY3QuX2NvbXBpbGUoZGVmcywgYXJncyk7XG4gICAgICB2YXIgcHJvcCA9IHRoaXMuZm4uaW5kZXguZ2V0T2JqZWN0UHJvcGVydHkoKTtcblxuICAgICAgcmV0dXJuICcoZnVuY3Rpb24gKCkgeycgK1xuICAgICAgICAgICd2YXIgb2JqZWN0ID0gJyArIGpzT2JqZWN0ICsgJzsnICtcbiAgICAgICAgICAncmV0dXJuIChvYmplY3RbXCInICsgcHJvcCArICdcIl0gJiYgb2JqZWN0W1wiJyArIHByb3AgKyAnXCJdLnJhd0FyZ3MpICcgK1xuICAgICAgICAgICcgPyBvYmplY3RbXCInICsgcHJvcCArICdcIl0oJyArIGFyZ3NOYW1lICsgJywgbWF0aCwgc2NvcGUpJyArXG4gICAgICAgICAgJyA6IG9iamVjdFtcIicgKyBwcm9wICsgJ1wiXSgnICsganNBcmdzLmpvaW4oJywgJykgKyAnKScgK1xuICAgICAgICAgICd9KSgpJztcbiAgICB9XG4gICAgZWxzZSB7IC8vIHRoaXMuZm4uaXNBY2Nlc3Nvck5vZGUgJiYgIXRoaXMuZm4uaW5kZXguaXNPYmplY3RQcm9wZXJ0eSgpXG4gICAgICAvLyB3ZSBoYXZlIHRvIGR5bmFtaWNhbGx5IGRldGVybWluZSB3aGV0aGVyIHRoZSBmdW5jdGlvbiBoYXMgYSByYXdBcmdzIHByb3BlcnR5XG4gICAgICBhcmdzTmFtZSA9IHRoaXMuX2dldFVuaXF1ZUFyZ3VtZW50c05hbWUoZGVmcyk7XG4gICAgICBkZWZzW2FyZ3NOYW1lXSA9IHRoaXMuYXJncztcblxuICAgICAgcmV0dXJuICcoZnVuY3Rpb24gKCkgeycgK1xuICAgICAgICAgICd2YXIgZm4gPSAnICsganNGbiArICc7JyArXG4gICAgICAgICAgJ3JldHVybiAoZm4gJiYgZm4ucmF3QXJncykgJyArXG4gICAgICAgICAgJyA/IGZuKCcgKyBhcmdzTmFtZSArICcsIG1hdGgsIHNjb3BlKScgK1xuICAgICAgICAgICcgOiBmbignICsganNBcmdzLmpvaW4oJywgJykgKyAnKScgK1xuICAgICAgICAgICd9KSgpJztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhIHVuaXF1ZSBuYW1lIGZvciBhIGFyZ3VtZW50cyB0byBzdG9yZSBpbiBkZWZzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkZWZzXG4gICAqIEByZXR1cm4ge3N0cmluZ30gQSBzdHJpbmcgbGlrZSAnYXJnczEnLCAnYXJnczInLCAuLi5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIEZ1bmN0aW9uTm9kZS5wcm90b3R5cGUuX2dldFVuaXF1ZUFyZ3VtZW50c05hbWUgPSBmdW5jdGlvbiAoZGVmcykge1xuICAgIHZhciBhcmdzTmFtZTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICBkbyB7XG4gICAgICBhcmdzTmFtZSA9ICdhcmdzJyArIGk7XG4gICAgICBpKys7XG4gICAgfVxuICAgIHdoaWxlIChhcmdzTmFtZSBpbiBkZWZzKTtcblxuICAgIHJldHVybiBhcmdzTmFtZTtcbiAgfTtcblxuICAvKipcbiAgICogRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBlYWNoIG9mIHRoZSBjaGlsZCBub2RlcyBvZiB0aGlzIG5vZGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbihjaGlsZDogTm9kZSwgcGF0aDogc3RyaW5nLCBwYXJlbnQ6IE5vZGUpfSBjYWxsYmFja1xuICAgKi9cbiAgRnVuY3Rpb25Ob2RlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNhbGxiYWNrKHRoaXMuYXJnc1tpXSwgJ2FyZ3NbJyArIGkgKyAnXScsIHRoaXMpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IEZ1bmN0aW9uTm9kZSBoYXZpbmcgaXQncyBjaGlsZHMgYmUgdGhlIHJlc3VsdHMgb2YgY2FsbGluZ1xuICAgKiB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIGVhY2ggb2YgdGhlIGNoaWxkcyBvZiB0aGUgb3JpZ2luYWwgbm9kZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihjaGlsZDogTm9kZSwgcGF0aDogc3RyaW5nLCBwYXJlbnQ6IE5vZGUpOiBOb2RlfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7RnVuY3Rpb25Ob2RlfSBSZXR1cm5zIGEgdHJhbnNmb3JtZWQgY29weSBvZiB0aGUgbm9kZVxuICAgKi9cbiAgRnVuY3Rpb25Ob2RlLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB2YXIgZm4gPSB0aGlzLmZuLm1hcChjYWxsYmFjayk7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IHRoaXMuX2lmTm9kZShjYWxsYmFjayh0aGlzLmFyZ3NbaV0sICdhcmdzWycgKyBpICsgJ10nLCB0aGlzKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRnVuY3Rpb25Ob2RlKGZuLCBhcmdzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgY2xvbmUgb2YgdGhpcyBub2RlLCBhIHNoYWxsb3cgY29weVxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbk5vZGV9XG4gICAqL1xuICBGdW5jdGlvbk5vZGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb25Ob2RlKHRoaXMuZm4sIHRoaXMuYXJncy5zbGljZSgwKSk7XG4gIH07XG5cbiAgLy9iYWNrdXAgTm9kZSdzIHRvU3RyaW5nIGZ1bmN0aW9uXG4gIC8vQHByaXZhdGVcbiAgdmFyIG5vZGVUb1N0cmluZyA9IEZ1bmN0aW9uTm9kZS5wcm90b3R5cGUudG9TdHJpbmc7XG5cbiAgLyoqXG4gICAqIEdldCBzdHJpbmcgcmVwcmVzZW50YXRpb24uICh3cmFwcGVyIGZ1bmN0aW9uKVxuICAgKiBUaGlzIG92ZXJyaWRlcyBwYXJ0cyBvZiBOb2RlJ3MgdG9TdHJpbmcgZnVuY3Rpb24uXG4gICAqIElmIGNhbGxiYWNrIGlzIGFuIG9iamVjdCBjb250YWluaW5nIGNhbGxiYWNrcywgaXRcbiAgICogY2FsbHMgdGhlIGNvcnJlY3QgY2FsbGJhY2sgZm9yIHRoZSBjdXJyZW50IG5vZGUsXG4gICAqIG90aGVyd2lzZSBpdCBmYWxscyBiYWNrIHRvIGNhbGxpbmcgTm9kZSdzIHRvU3RyaW5nXG4gICAqIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHN0clxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIEZ1bmN0aW9uTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBjdXN0b21TdHJpbmc7XG4gICAgdmFyIG5hbWUgPSB0aGlzLmZuLnRvU3RyaW5nKCk7XG4gICAgaWYgKG9wdGlvbnMgJiYgKHR5cGVvZiBvcHRpb25zLmhhbmRsZXIgPT09ICdvYmplY3QnKSAmJiBvcHRpb25zLmhhbmRsZXIuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIC8vY2FsbGJhY2sgaXMgYSBtYXAgb2YgY2FsbGJhY2sgZnVuY3Rpb25zXG4gICAgICBjdXN0b21TdHJpbmcgPSBvcHRpb25zLmhhbmRsZXJbbmFtZV0odGhpcywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjdXN0b21TdHJpbmcgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gY3VzdG9tU3RyaW5nO1xuICAgIH1cblxuICAgIC8vZmFsbCBiYWNrIHRvIE5vZGUncyB0b1N0cmluZ1xuICAgIHJldHVybiBub2RlVG9TdHJpbmcuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHN0clxuICAgKi9cbiAgRnVuY3Rpb25Ob2RlLnByb3RvdHlwZS5fdG9TdHJpbmcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIC8vIGZvcm1hdCB0aGUgcGFyYW1ldGVycyBsaWtlIFwiYWRkKDIsIDQuMilcIlxuICAgIHJldHVybiB0aGlzLmZuLnRvU3RyaW5nKCkgKyAnKCcgKyB0aGlzLmFyZ3Muam9pbignLCAnKSArICcpJztcbiAgfTtcblxuICAvKlxuICAgKiBFeHBhbmQgYSBMYVRlWCB0ZW1wbGF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGVtcGxhdGVcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwcml2YXRlXG4gICAqKi9cbiAgZnVuY3Rpb24gZXhwYW5kVGVtcGxhdGUodGVtcGxhdGUsIG5vZGUsIG9wdGlvbnMpIHtcbiAgICB2YXIgbGF0ZXggPSAnJztcblxuICAgIC8vIE1hdGNoIGV2ZXJ5dGhpbmcgb2YgdGhlIGZvcm0gJHtpZGVudGlmaWVyfSBvciAke2lkZW50aWZpZXJbMl19IG9yICQkXG4gICAgLy8gd2hpbGUgc3VibWF0Y2hpbmcgaWRlbnRpZmllciBhbmQgMiAoaW4gdGhlIHNlY29uZCBjYXNlKVxuICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoJ1xcXFwkKD86XFxcXHsoW2Etel9dW2Etel8wLTldKikoPzpcXFxcWyhbMC05XSspXFxcXF0pP1xcXFx9fFxcXFwkKScsICdpZycpO1xuXG4gICAgdmFyIGlucHV0UG9zID0gMDsgICAvL3Bvc2l0aW9uIGluIHRoZSBpbnB1dCBzdHJpbmdcbiAgICB2YXIgbWF0Y2g7XG4gICAgd2hpbGUgKChtYXRjaCA9IHJlZ2V4LmV4ZWModGVtcGxhdGUpKSAhPT0gbnVsbCkgeyAgIC8vZ28gdGhyb3VnaCBhbGwgbWF0Y2hlc1xuICAgICAgLy8gYWRkIGV2ZXJ5dGhpbmcgaW4gZnJvbnQgb2YgdGhlIG1hdGNoIHRvIHRoZSBMYVRlWCBzdHJpbmdcbiAgICAgIGxhdGV4ICs9IHRlbXBsYXRlLnN1YnN0cmluZyhpbnB1dFBvcywgbWF0Y2guaW5kZXgpO1xuICAgICAgaW5wdXRQb3MgPSBtYXRjaC5pbmRleDtcblxuICAgICAgaWYgKG1hdGNoWzBdID09PSAnJCQnKSB7IC8vIGVzY2FwZWQgZG9sbGFyIHNpZ25cbiAgICAgICAgbGF0ZXggKz0gJyQnO1xuICAgICAgICBpbnB1dFBvcysrO1xuICAgICAgfVxuICAgICAgZWxzZSB7IC8vIHRlbXBsYXRlIHBhcmFtZXRlclxuICAgICAgICBpbnB1dFBvcyArPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgIHZhciBwcm9wZXJ0eSA9IG5vZGVbbWF0Y2hbMV1dO1xuICAgICAgICBpZiAoIXByb3BlcnR5KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKCdUZW1wbGF0ZTogUHJvcGVydHkgJyArIG1hdGNoWzFdICsgJyBkb2VzIG5vdCBleGlzdC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2hbMl0gPT09IHVuZGVmaW5lZCkgeyAvL25vIHNxdWFyZSBicmFja2V0c1xuICAgICAgICAgIHN3aXRjaCAodHlwZW9mIHByb3BlcnR5KSB7XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICBsYXRleCArPSBwcm9wZXJ0eTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICBpZiAocHJvcGVydHkuaXNOb2RlKSB7XG4gICAgICAgICAgICAgICAgbGF0ZXggKz0gcHJvcGVydHkudG9UZXgob3B0aW9ucyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICAvL21ha2UgYXJyYXkgb2YgTm9kZXMgaW50byBjb21tYSBzZXBhcmF0ZWQgbGlzdFxuICAgICAgICAgICAgICAgIGxhdGV4ICs9IHByb3BlcnR5Lm1hcChmdW5jdGlvbiAoYXJnLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGFyZyAmJiBhcmcuaXNOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmcudG9UZXgob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUZW1wbGF0ZTogJyArIG1hdGNoWzFdICsgJ1snICsgaW5kZXggKyAnXSBpcyBub3QgYSBOb2RlLicpO1xuICAgICAgICAgICAgICAgIH0pLmpvaW4oJywnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUZW1wbGF0ZTogJyArIG1hdGNoWzFdICsgJyBoYXMgdG8gYmUgYSBOb2RlLCBTdHJpbmcgb3IgYXJyYXkgb2YgTm9kZXMnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RlbXBsYXRlOiAnICsgbWF0Y2hbMV0gKyAnIGhhcyB0byBiZSBhIE5vZGUsIFN0cmluZyBvciBhcnJheSBvZiBOb2RlcycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy93aXRoIHNxdWFyZSBicmFja2V0c1xuICAgICAgICAgIGlmIChwcm9wZXJ0eVttYXRjaFsyXV0gJiYgcHJvcGVydHlbbWF0Y2hbMl1dLmlzTm9kZSkge1xuICAgICAgICAgICAgbGF0ZXggKz0gcHJvcGVydHlbbWF0Y2hbMl1dLnRvVGV4KG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RlbXBsYXRlOiAnICsgbWF0Y2hbMV0gKyAnWycgKyBtYXRjaFsyXSArICddIGlzIG5vdCBhIE5vZGUuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxhdGV4ICs9IHRlbXBsYXRlLnNsaWNlKGlucHV0UG9zKTsgIC8vYXBwZW5kIHJlc3Qgb2YgdGhlIHRlbXBsYXRlXG5cbiAgICByZXR1cm4gbGF0ZXg7XG4gIH1cblxuICAvL2JhY2t1cCBOb2RlJ3MgdG9UZXggZnVuY3Rpb25cbiAgLy9AcHJpdmF0ZVxuICB2YXIgbm9kZVRvVGV4ID0gRnVuY3Rpb25Ob2RlLnByb3RvdHlwZS50b1RleDtcblxuICAvKipcbiAgICogR2V0IExhVGVYIHJlcHJlc2VudGF0aW9uLiAod3JhcHBlciBmdW5jdGlvbilcbiAgICogVGhpcyBvdmVycmlkZXMgcGFydHMgb2YgTm9kZSdzIHRvVGV4IGZ1bmN0aW9uLlxuICAgKiBJZiBjYWxsYmFjayBpcyBhbiBvYmplY3QgY29udGFpbmluZyBjYWxsYmFja3MsIGl0XG4gICAqIGNhbGxzIHRoZSBjb3JyZWN0IGNhbGxiYWNrIGZvciB0aGUgY3VycmVudCBub2RlLFxuICAgKiBvdGhlcndpc2UgaXQgZmFsbHMgYmFjayB0byBjYWxsaW5nIE5vZGUncyB0b1RleFxuICAgKiBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgRnVuY3Rpb25Ob2RlLnByb3RvdHlwZS50b1RleCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIGN1c3RvbVRleDtcbiAgICBpZiAob3B0aW9ucyAmJiAodHlwZW9mIG9wdGlvbnMuaGFuZGxlciA9PT0gJ29iamVjdCcpICYmIG9wdGlvbnMuaGFuZGxlci5oYXNPd25Qcm9wZXJ0eSh0aGlzLm5hbWUpKSB7XG4gICAgICAvL2NhbGxiYWNrIGlzIGEgbWFwIG9mIGNhbGxiYWNrIGZ1bmN0aW9uc1xuICAgICAgY3VzdG9tVGV4ID0gb3B0aW9ucy5oYW5kbGVyW3RoaXMubmFtZV0odGhpcywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjdXN0b21UZXggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gY3VzdG9tVGV4O1xuICAgIH1cblxuICAgIC8vZmFsbCBiYWNrIHRvIE5vZGUncyB0b1RleFxuICAgIHJldHVybiBub2RlVG9UZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IExhVGVYIHJlcHJlc2VudGF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge3N0cmluZ30gc3RyXG4gICAqL1xuICBGdW5jdGlvbk5vZGUucHJvdG90eXBlLl90b1RleCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIHBhcmVudGhlc2lzID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5wYXJlbnRoZXNpcykgPyBvcHRpb25zLnBhcmVudGhlc2lzIDogJ2tlZXAnO1xuXG5cbiAgICB2YXIgYXJncyA9IHRoaXMuYXJncy5tYXAoZnVuY3Rpb24gKGFyZykgeyAvL2dldCBMYVRlWCBvZiB0aGUgYXJndW1lbnRzXG4gICAgICByZXR1cm4gYXJnLnRvVGV4KG9wdGlvbnMpO1xuICAgIH0pO1xuXG4gICAgdmFyIGxhdGV4Q29udmVydGVyO1xuXG4gICAgaWYgKG1hdGhbdGhpcy5uYW1lXSAmJiAoKHR5cGVvZiBtYXRoW3RoaXMubmFtZV0udG9UZXggPT09ICdmdW5jdGlvbicpIHx8ICh0eXBlb2YgbWF0aFt0aGlzLm5hbWVdLnRvVGV4ID09PSAnb2JqZWN0JykgfHwgKHR5cGVvZiBtYXRoW3RoaXMubmFtZV0udG9UZXggPT09ICdzdHJpbmcnKSkpIHtcbiAgICAgIC8vLnRvVGV4IGlzIGEgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgIGxhdGV4Q29udmVydGVyID0gbWF0aFt0aGlzLm5hbWVdLnRvVGV4O1xuICAgIH1cblxuICAgIHZhciBjdXN0b21Ub1RleDtcbiAgICBzd2l0Y2ggKHR5cGVvZiBsYXRleENvbnZlcnRlcikge1xuICAgICAgY2FzZSAnZnVuY3Rpb24nOiAvL2EgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgY3VzdG9tVG9UZXggPSBsYXRleENvbnZlcnRlcih0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzdHJpbmcnOiAvL2EgdGVtcGxhdGUgc3RyaW5nXG4gICAgICAgIGN1c3RvbVRvVGV4ID0gZXhwYW5kVGVtcGxhdGUobGF0ZXhDb252ZXJ0ZXIsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ29iamVjdCc6IC8vYW4gb2JqZWN0IHdpdGggZGlmZmVyZW50IFwiY29udmVydGVyc1wiIGZvciBkaWZmZXJlbnQgbnVtYmVycyBvZiBhcmd1bWVudHNcbiAgICAgICAgc3dpdGNoICh0eXBlb2YgbGF0ZXhDb252ZXJ0ZXJbYXJncy5sZW5ndGhdKSB7XG4gICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgY3VzdG9tVG9UZXggPSBsYXRleENvbnZlcnRlclthcmdzLmxlbmd0aF0odGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgY3VzdG9tVG9UZXggPSBleHBhbmRUZW1wbGF0ZShsYXRleENvbnZlcnRlclthcmdzLmxlbmd0aF0sIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGN1c3RvbVRvVGV4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGN1c3RvbVRvVGV4O1xuICAgIH1cblxuICAgIHJldHVybiBleHBhbmRUZW1wbGF0ZShsYXRleC5kZWZhdWx0VGVtcGxhdGUsIHRoaXMsIG9wdGlvbnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgaWRlbnRpZmllci5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgRnVuY3Rpb25Ob2RlLnByb3RvdHlwZS5nZXRJZGVudGlmaWVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgKyAnOicgKyB0aGlzLm5hbWU7XG4gIH07XG5cbiAgcmV0dXJuIEZ1bmN0aW9uTm9kZTtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ0Z1bmN0aW9uTm9kZSc7XG5leHBvcnRzLnBhdGggPSAnZXhwcmVzc2lvbi5ub2RlJztcbmV4cG9ydHMubWF0aCA9IHRydWU7IC8vIHJlcXVlc3QgYWNjZXNzIHRvIHRoZSBtYXRoIG5hbWVzcGFjZSBhcyA1dGggYXJndW1lbnQgb2YgdGhlIGZhY3RvcnkgZnVuY3Rpb25cbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIE5vZGUgPSBsb2FkKHJlcXVpcmUoJy4vTm9kZScpKTtcbiAgdmFyIFJhbmdlTm9kZSA9IGxvYWQocmVxdWlyZSgnLi9SYW5nZU5vZGUnKSk7XG4gIHZhciBTeW1ib2xOb2RlID0gbG9hZChyZXF1aXJlKCcuL1N5bWJvbE5vZGUnKSk7XG5cbiAgdmFyIFJhbmdlID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC9SYW5nZScpKTtcblxuICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvciBJbmRleE5vZGVcbiAgICogQGV4dGVuZHMgTm9kZVxuICAgKlxuICAgKiBEZXNjcmliZXMgYSBzdWJzZXQgb2YgYSBtYXRyaXggb3IgYW4gb2JqZWN0IHByb3BlcnR5LlxuICAgKiBDYW5ub3QgYmUgdXNlZCBvbiBpdHMgb3duLCBuZWVkcyB0byBiZSB1c2VkIHdpdGhpbiBhbiBBY2Nlc3Nvck5vZGUgb3JcbiAgICogQXNzaWdubWVudE5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZVtdfSBkaW1lbnNpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RvdE5vdGF0aW9uPWZhbHNlXSAgT3B0aW9uYWwgcHJvcGVydHkgZGVzY3JpYmluZyB3aGV0aGVyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyBpbmRleCB3YXMgd3JpdHRlbiB1c2luZyBkb3RcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RhdGlvbiBsaWtlIGBhLmJgLCBvciB1c2luZyBicmFja2V0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90YXRpb24gbGlrZSBgYVtcImJcIl1gIChkZWZhdWx0KS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBVc2VkIHRvIHN0cmluZ2lmeSBhbiBJbmRleE5vZGUuXG4gICAqL1xuICBmdW5jdGlvbiBJbmRleE5vZGUoZGltZW5zaW9ucywgZG90Tm90YXRpb24pIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSW5kZXhOb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdDb25zdHJ1Y3RvciBtdXN0IGJlIGNhbGxlZCB3aXRoIHRoZSBuZXcgb3BlcmF0b3InKTtcbiAgICB9XG5cbiAgICB0aGlzLmRpbWVuc2lvbnMgPSBkaW1lbnNpb25zO1xuICAgIHRoaXMuZG90Tm90YXRpb24gPSBkb3ROb3RhdGlvbiB8fCBmYWxzZTtcblxuICAgIC8vIHZhbGlkYXRlIGlucHV0XG4gICAgaWYgKCFpc0FycmF5KGRpbWVuc2lvbnMpXG4gICAgICAgIHx8ICFkaW1lbnNpb25zLmV2ZXJ5KGZ1bmN0aW9uIChyYW5nZSkge3JldHVybiByYW5nZSAmJiByYW5nZS5pc05vZGU7fSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5IGNvbnRhaW5pbmcgTm9kZXMgZXhwZWN0ZWQgZm9yIHBhcmFtZXRlciBcImRpbWVuc2lvbnNcIicpO1xuICAgIH1cbiAgICBpZiAodGhpcy5kb3ROb3RhdGlvbiAmJiAhdGhpcy5pc09iamVjdFByb3BlcnR5KCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZG90Tm90YXRpb24gb25seSBhcHBsaWNhYmxlIGZvciBvYmplY3QgcHJvcGVydGllcycpO1xuICAgIH1cblxuICAgIC8vIFRPRE86IGRlcHJlY2F0ZWQgc2luY2UgdjMsIHJlbW92ZSBzb21lIGRheVxuICAgIHZhciBkZXByZWNhdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9wZXJ0eSBgSW5kZXhOb2RlLm9iamVjdGAgaXMgZGVwcmVjYXRlZCwgdXNlIGBJbmRleE5vZGUuZm5gIGluc3RlYWQnKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnb2JqZWN0JywgeyBnZXQ6IGRlcHJlY2F0ZWQsIHNldDogZGVwcmVjYXRlZCB9KTtcbiAgfVxuXG4gIEluZGV4Tm9kZS5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuXG4gIEluZGV4Tm9kZS5wcm90b3R5cGUudHlwZSA9ICdJbmRleE5vZGUnO1xuXG4gIEluZGV4Tm9kZS5wcm90b3R5cGUuaXNJbmRleE5vZGUgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBDb21waWxlIGFsbCByYW5nZSBub2Rlc1xuICAgKlxuICAgKiBXaGVuIHNvbWUgb2YgdGhlIGRpbWVuc2lvbnMgaGFzIGBlbmRgIGRlZmluZWQsIHRoZSBJbmRleE5vZGUgcmVxdWlyZXNcbiAgICogYSB2YXJpYWJsZSBgc2l6ZWAgdG8gYmUgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBjbG9zdXJlLCBhbmQgbXVzdCBjb250YWluXG4gICAqIHRoZSBzaXplIG9mIHRoZSBtYXRyaXggdGhhdCdzIGJlaW5nIGhhbmRsZWQuIFRvIGNoZWNrIHdoZXRoZXIgdGhlIGBzaXplYFxuICAgKiB2YXJpYWJsZSBpcyBuZWVkZWQsIGNhbGwgSW5kZXhOb2RlLm5lZWRzU2l6ZSgpLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGVmcyAgICAgICAgICAgT2JqZWN0IHdoaWNoIGNhbiBiZSB1c2VkIHRvIGRlZmluZSBmdW5jdGlvbnNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGNvbnN0YW50cyBnbG9iYWxseSBhdmFpbGFibGUgZm9yIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGlsZWQgZXhwcmVzc2lvblxuICAgKiBAcGFyYW0ge09iamVjdH0gYXJncyAgICAgICAgICAgT2JqZWN0IHdpdGggbG9jYWwgZnVuY3Rpb24gYXJndW1lbnRzLCB0aGUga2V5IGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgbmFtZSBvZiB0aGUgYXJndW1lbnQsIGFuZCB0aGUgdmFsdWUgaXMgYHRydWVgLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG9iamVjdCBtYXkgbm90IGJlIG11dGF0ZWQsIGJ1dCBtdXN0IGJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbmRlZCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IGNvZGVcbiAgICovXG4gIEluZGV4Tm9kZS5wcm90b3R5cGUuX2NvbXBpbGUgPSBmdW5jdGlvbiAoZGVmcywgYXJncykge1xuICAgIC8vIGFyZ3MgY2FuIGJlIG11dGF0ZWQgYnkgSW5kZXhOb2RlLCB3aGVuIGRpbWVuc2lvbnMgdXNlIGBlbmRgXG4gICAgdmFyIGNoaWxkQXJncyA9IE9iamVjdC5jcmVhdGUoYXJncyk7XG5cbiAgICAvLyBoZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIGEgUmFuZ2UgZnJvbSBzdGFydCwgc3RlcCBhbmQgZW5kXG4gICAgZGVmcy5yYW5nZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBzdGVwKSB7XG4gICAgICByZXR1cm4gbmV3IFJhbmdlKFxuICAgICAgICAgIChzdGFydCAmJiBzdGFydC5pc0JpZ051bWJlciA9PT0gdHJ1ZSkgPyBzdGFydC50b051bWJlcigpIDogc3RhcnQsXG4gICAgICAgICAgKGVuZCAgICYmIGVuZC5pc0JpZ051bWJlciA9PT0gdHJ1ZSkgICA/IGVuZC50b051bWJlcigpICAgOiBlbmQsXG4gICAgICAgICAgKHN0ZXAgICYmIHN0ZXAuaXNCaWdOdW1iZXIgPT09IHRydWUpICA/IHN0ZXAudG9OdW1iZXIoKSAgOiBzdGVwXG4gICAgICApO1xuICAgIH07XG5cbiAgICAvLyBUT0RPOiBpbXBsZW1lbnQgc3VwcG9ydCBmb3IgYmlnbnVtYmVyIChjdXJyZW50bHkgYmlnbnVtYmVycyBhcmUgc2lsZW50bHlcbiAgICAvLyAgICAgICByZWR1Y2VkIHRvIG51bWJlcnMgd2hlbiBjaGFuZ2luZyB0aGUgdmFsdWUgdG8gemVyby1iYXNlZClcblxuICAgIC8vIFRPRE86IE9wdGltaXphdGlvbjogd2hlbiB0aGUgcmFuZ2UgdmFsdWVzIGFyZSBDb25zdGFudE5vZGVzLFxuICAgIC8vICAgICAgIHdlIGNhbiBiZWZvcmVoYW5kIHJlc29sdmUgdGhlIHplcm8tYmFzZWQgdmFsdWVcblxuICAgIC8vIG9wdGltaXphdGlvbiBmb3IgYSBzaW1wbGUgb2JqZWN0IHByb3BlcnR5XG4gICAgdmFyIGRpbWVuc2lvbnMgPSB0aGlzLmRpbWVuc2lvbnMubWFwKGZ1bmN0aW9uIChyYW5nZSwgaSkge1xuICAgICAgaWYgKHJhbmdlICYmIHJhbmdlLmlzUmFuZ2VOb2RlKSB7XG4gICAgICAgIGlmIChyYW5nZS5uZWVkc0VuZCgpKSB7XG4gICAgICAgICAgY2hpbGRBcmdzLmVuZCA9IHRydWU7XG5cbiAgICAgICAgICAvLyByZXNvbHZlIGVuZCBhbmQgY3JlYXRlIHJhbmdlXG4gICAgICAgICAgcmV0dXJuICcoZnVuY3Rpb24gKCkgeycgK1xuICAgICAgICAgICAgICAndmFyIGVuZCA9IHNpemVbJyArIGkgKyAnXTsgJyArXG4gICAgICAgICAgICAgICdyZXR1cm4gcmFuZ2UoJyArXG4gICAgICAgICAgICAgIHJhbmdlLnN0YXJ0Ll9jb21waWxlKGRlZnMsIGNoaWxkQXJncykgKyAnLCAnICtcbiAgICAgICAgICAgICAgcmFuZ2UuZW5kLl9jb21waWxlKGRlZnMsIGNoaWxkQXJncykgKyAnLCAnICtcbiAgICAgICAgICAgICAgKHJhbmdlLnN0ZXAgPyByYW5nZS5zdGVwLl9jb21waWxlKGRlZnMsIGNoaWxkQXJncykgOiAnMScpICtcbiAgICAgICAgICAgICAgJyk7ICcgK1xuICAgICAgICAgICAgICAnfSkoKSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgLy8gY3JlYXRlIHJhbmdlXG4gICAgICAgICAgcmV0dXJuICdyYW5nZSgnICtcbiAgICAgICAgICAgICAgcmFuZ2Uuc3RhcnQuX2NvbXBpbGUoZGVmcywgY2hpbGRBcmdzKSArICcsICcgK1xuICAgICAgICAgICAgICByYW5nZS5lbmQuX2NvbXBpbGUoZGVmcywgY2hpbGRBcmdzKSArICcsICcgK1xuICAgICAgICAgICAgICAocmFuZ2Uuc3RlcCA/IHJhbmdlLnN0ZXAuX2NvbXBpbGUoZGVmcywgY2hpbGRBcmdzKSA6ICcxJykgK1xuICAgICAgICAgICAgICAnKSc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyYW5nZS5pc1N5bWJvbE5vZGUgJiYgcmFuZ2UubmFtZSA9PT0gJ2VuZCcpIHtcbiAgICAgICAgY2hpbGRBcmdzLmVuZCA9IHRydWU7XG5cbiAgICAgICAgLy8gcmVzb2x2ZSB0aGUgcGFyYW1ldGVyICdlbmQnXG4gICAgICAgIHJldHVybiAnKGZ1bmN0aW9uICgpIHsnICtcbiAgICAgICAgICAgICd2YXIgZW5kID0gc2l6ZVsnICsgaSArICddOyAnICtcbiAgICAgICAgICAgICdyZXR1cm4gJyArIHJhbmdlLl9jb21waWxlKGRlZnMsIGNoaWxkQXJncykgKyAnOyAnICtcbiAgICAgICAgICAgICd9KSgpJ1xuICAgICAgfVxuICAgICAgZWxzZSB7IC8vIENvbnN0YW50Tm9kZVxuICAgICAgICByZXR1cm4gcmFuZ2UuX2NvbXBpbGUoZGVmcywgY2hpbGRBcmdzKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiAnbWF0aC5pbmRleCgnICsgZGltZW5zaW9ucy5qb2luKCcsICcpICsgJyknO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGVhY2ggb2YgdGhlIGNoaWxkIG5vZGVzIG9mIHRoaXMgbm9kZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGNoaWxkOiBOb2RlLCBwYXRoOiBzdHJpbmcsIHBhcmVudDogTm9kZSl9IGNhbGxiYWNrXG4gICAqL1xuICBJbmRleE5vZGUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGltZW5zaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgY2FsbGJhY2sodGhpcy5kaW1lbnNpb25zW2ldLCAnZGltZW5zaW9uc1snICsgaSArICddJywgdGhpcyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgSW5kZXhOb2RlIGhhdmluZyBpdCdzIGNoaWxkcyBiZSB0aGUgcmVzdWx0cyBvZiBjYWxsaW5nXG4gICAqIHRoZSBwcm92aWRlZCBjYWxsYmFjayBmdW5jdGlvbiBmb3IgZWFjaCBvZiB0aGUgY2hpbGRzIG9mIHRoZSBvcmlnaW5hbCBub2RlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGNoaWxkOiBOb2RlLCBwYXRoOiBzdHJpbmcsIHBhcmVudDogTm9kZSk6IE5vZGV9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtJbmRleE5vZGV9IFJldHVybnMgYSB0cmFuc2Zvcm1lZCBjb3B5IG9mIHRoZSBub2RlXG4gICAqL1xuICBJbmRleE5vZGUucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHZhciBkaW1lbnNpb25zID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRpbWVuc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRpbWVuc2lvbnNbaV0gPSB0aGlzLl9pZk5vZGUoY2FsbGJhY2sodGhpcy5kaW1lbnNpb25zW2ldLCAnZGltZW5zaW9uc1snICsgaSArICddJywgdGhpcykpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgSW5kZXhOb2RlKGRpbWVuc2lvbnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBjbG9uZSBvZiB0aGlzIG5vZGUsIGEgc2hhbGxvdyBjb3B5XG4gICAqIEByZXR1cm4ge0luZGV4Tm9kZX1cbiAgICovXG4gIEluZGV4Tm9kZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBJbmRleE5vZGUodGhpcy5kaW1lbnNpb25zLnNsaWNlKDApKTtcbiAgfTtcblxuICAvKipcbiAgICogVGVzdCB3aGV0aGVyIHRoaXMgSW5kZXhOb2RlIGNvbnRhaW5zIGEgc2luZ2xlIHByb3BlcnR5IG5hbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIEluZGV4Tm9kZS5wcm90b3R5cGUuaXNPYmplY3RQcm9wZXJ0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5kaW1lbnNpb25zLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICB0aGlzLmRpbWVuc2lvbnNbMF0uaXNDb25zdGFudE5vZGUgJiZcbiAgICAgICAgdGhpcy5kaW1lbnNpb25zWzBdLnZhbHVlVHlwZSA9PT0gJ3N0cmluZyc7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHByb3BlcnR5IG5hbWUgaWYgSW5kZXhOb2RlIGNvbnRhaW5zIGEgcHJvcGVydHkuXG4gICAqIElmIG5vdCwgcmV0dXJucyBudWxsLlxuICAgKiBAcmV0dXJuIHtzdHJpbmcgfCBudWxsfVxuICAgKi9cbiAgSW5kZXhOb2RlLnByb3RvdHlwZS5nZXRPYmplY3RQcm9wZXJ0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pc09iamVjdFByb3BlcnR5KCkgPyB0aGlzLmRpbWVuc2lvbnNbMF0udmFsdWUgOiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge3N0cmluZ30gc3RyXG4gICAqL1xuICBJbmRleE5vZGUucHJvdG90eXBlLl90b1N0cmluZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgLy8gZm9ybWF0IHRoZSBwYXJhbWV0ZXJzIGxpa2UgXCJbMSwgMDo1XVwiXG4gICAgcmV0dXJuIHRoaXMuZG90Tm90YXRpb25cbiAgICAgICAgPyAoJy4nICsgdGhpcy5nZXRPYmplY3RQcm9wZXJ0eSgpKVxuICAgICAgICA6ICgnWycgKyB0aGlzLmRpbWVuc2lvbnMuam9pbignLCAnKSArICddJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBMYVRlWCByZXByZXNlbnRhdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHN0clxuICAgKi9cbiAgSW5kZXhOb2RlLnByb3RvdHlwZS5fdG9UZXggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBkaW1lbnNpb25zID0gdGhpcy5kaW1lbnNpb25zLm1hcChmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgIHJldHVybiByYW5nZS50b1RleChvcHRpb25zKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLmRvdE5vdGF0aW9uXG4gICAgICAgID8gKCcuJyArIHRoaXMuZ2V0T2JqZWN0UHJvcGVydHkoKSArICcnKVxuICAgICAgICA6ICgnX3snICsgZGltZW5zaW9ucy5qb2luKCcsJykgKyAnfScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUZXN0IHdoZXRoZXIgdGhpcyBJbmRleE5vZGUgbmVlZHMgdGhlIG9iamVjdCBzaXplLCBzaXplIG9mIHRoZSBNYXRyaXhcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIEluZGV4Tm9kZS5wcm90b3R5cGUubmVlZHNTaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmRpbWVuc2lvbnMuc29tZShmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgIHJldHVybiAocmFuZ2UuaXNSYW5nZU5vZGUgJiYgcmFuZ2UubmVlZHNFbmQoKSkgfHxcbiAgICAgICAgICAocmFuZ2UuaXNTeW1ib2xOb2RlICYmIHJhbmdlLm5hbWUgPT09ICdlbmQnKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gSW5kZXhOb2RlO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnSW5kZXhOb2RlJztcbmV4cG9ydHMucGF0aCA9ICdleHByZXNzaW9uLm5vZGUnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGtleXdvcmRzID0gcmVxdWlyZSgnLi4va2V5d29yZHMnKTtcbnZhciBleHRlbmQgPSByZXF1aXJlKCcuLi8uLi91dGlscy9vYmplY3QnKS5leHRlbmQ7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQsIG1hdGgpIHtcbiAgLyoqXG4gICAqIE5vZGVcbiAgICovXG4gIGZ1bmN0aW9uIE5vZGUoKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0NvbnN0cnVjdG9yIG11c3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBvcGVyYXRvcicpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFdmFsdWF0ZSB0aGUgbm9kZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXSAgU2NvcGUgdG8gcmVhZC93cml0ZSB2YXJpYWJsZXNcbiAgICogQHJldHVybiB7Kn0gICAgICAgICAgICAgIFJldHVybnMgdGhlIHJlc3VsdFxuICAgKi9cbiAgTm9kZS5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uKHNjb3BlKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcGlsZSgpLmV2YWwoc2NvcGUpO1xuICB9O1xuXG4gIE5vZGUucHJvdG90eXBlLnR5cGUgPSAnTm9kZSc7XG5cbiAgTm9kZS5wcm90b3R5cGUuaXNOb2RlID0gdHJ1ZTtcblxuICAvKipcbiAgICogQ29tcGlsZSB0aGUgbm9kZSB0byBqYXZhc2NyaXB0IGNvZGVcbiAgICogQHJldHVybiB7e2V2YWw6IGZ1bmN0aW9ufX0gZXhwciAgUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBhIGZ1bmN0aW9uICdldmFsJyxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpY2ggY2FuIGJlIGludm9rZWQgYXMgZXhwci5ldmFsKFtzY29wZV0pLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGVyZSBzY29wZSBpcyBhbiBvcHRpb25hbCBvYmplY3Qgd2l0aFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXMuXG4gICAqL1xuICBOb2RlLnByb3RvdHlwZS5jb21waWxlID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFRPRE86IGNhbGxpbmcgY29tcGlsZShtYXRoKSBpcyBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi4wLjAuIFJlbW92ZSB0aGlzIHdhcm5pbmcgc29tZSBkYXlcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyBjb21waWxlKG1hdGgpIGlzIGRlcHJlY2F0ZWQuIENhbGwgdGhlIGZ1bmN0aW9uIGFzIGNvbXBpbGUoKSBpbnN0ZWFkLicpO1xuICAgIH1cblxuICAgIC8vIGRlZmluaXRpb25zIGdsb2JhbGx5IGF2YWlsYWJsZSBpbnNpZGUgdGhlIGNsb3N1cmUgb2YgdGhlIGNvbXBpbGVkIGV4cHJlc3Npb25zXG4gICAgdmFyIGRlZnMgPSB7XG4gICAgICBtYXRoOiBtYXRoLmV4cHJlc3Npb24udHJhbnNmb3JtLFxuICAgICAgYXJnczoge30sIC8vIGNhbiBiZSBmaWxsZWQgd2l0aCBuYW1lcyBvZiBGdW5jdGlvbkFzc2lnbm1lbnQgYXJndW1lbnRzXG4gICAgICBfdmFsaWRhdGVTY29wZTogX3ZhbGlkYXRlU2NvcGVcbiAgICB9O1xuXG4gICAgLy8gd2lsbCBiZSB1c2VkIHRvIHB1dCBsb2NhbCBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICB2YXIgYXJncyA9IHt9O1xuXG4gICAgdmFyIGNvZGUgPSB0aGlzLl9jb21waWxlKGRlZnMsIGFyZ3MpO1xuXG4gICAgdmFyIGRlZnNDb2RlID0gT2JqZWN0LmtleXMoZGVmcykubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXR1cm4gJyAgICB2YXIgJyArIG5hbWUgKyAnID0gZGVmc1tcIicgKyBuYW1lICsgJ1wiXTsnO1xuICAgIH0pO1xuXG4gICAgdmFyIGZhY3RvcnlDb2RlID1cbiAgICAgICAgZGVmc0NvZGUuam9pbignICcpICtcbiAgICAgICAgJ3JldHVybiB7JyArXG4gICAgICAgICcgIFwiZXZhbFwiOiBmdW5jdGlvbiAoc2NvcGUpIHsnICtcbiAgICAgICAgJyAgICBpZiAoc2NvcGUpIF92YWxpZGF0ZVNjb3BlKHNjb3BlKTsnICtcbiAgICAgICAgJyAgICBzY29wZSA9IHNjb3BlIHx8IHt9OycgK1xuICAgICAgICAnICAgIHJldHVybiAnICsgY29kZSArICc7JyArXG4gICAgICAgICcgIH0nICtcbiAgICAgICAgJ307JztcblxuICAgIHZhciBmYWN0b3J5ID0gbmV3IEZ1bmN0aW9uKCdkZWZzJywgZmFjdG9yeUNvZGUpO1xuICAgIHJldHVybiBmYWN0b3J5KGRlZnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb21waWxlIHRoZSBub2RlIHRvIGphdmFzY3JpcHQgY29kZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGVmcyAgICAgT2JqZWN0IHdoaWNoIGNhbiBiZSB1c2VkIHRvIGRlZmluZSBmdW5jdGlvbnNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCBjb25zdGFudHMgZ2xvYmFsbHkgYXZhaWxhYmxlIGluc2lkZSB0aGUgY2xvc3VyZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgdGhlIGNvbXBpbGVkIGV4cHJlc3Npb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgICAgIE9iamVjdCB3aXRoIGxvY2FsIGZ1bmN0aW9uIGFyZ3VtZW50cywgdGhlIGtleSBpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG5hbWUgb2YgdGhlIGFyZ3VtZW50LCBhbmQgdGhlIHZhbHVlIGlzIGB0cnVlYC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBvYmplY3QgbWF5IG5vdCBiZSBtdXRhdGVkLCBidXQgbXVzdCBiZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kZWQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7c3RyaW5nfSBqc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTm9kZS5wcm90b3R5cGUuX2NvbXBpbGUgPSBmdW5jdGlvbiAoZGVmcywgYXJncykge1xuICAgIC8vIG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgZWFjaCBvZiB0aGUgTm9kZSBpbXBsZW1lbnRhdGlvbnNcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb21waWxlIGEgTm9kZSBpbnRlcmZhY2UnKTtcbiAgfTtcblxuICAvKipcbiAgICogRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBlYWNoIG9mIHRoZSBjaGlsZCBub2RlcyBvZiB0aGlzIG5vZGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbihjaGlsZDogTm9kZSwgcGF0aDogc3RyaW5nLCBwYXJlbnQ6IE5vZGUpfSBjYWxsYmFja1xuICAgKi9cbiAgTm9kZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIC8vIG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgZWFjaCBvZiB0aGUgTm9kZSBpbXBsZW1lbnRhdGlvbnNcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBydW4gZm9yRWFjaCBvbiBhIE5vZGUgaW50ZXJmYWNlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBOb2RlIGhhdmluZyBpdCdzIGNoaWxkcyBiZSB0aGUgcmVzdWx0cyBvZiBjYWxsaW5nXG4gICAqIHRoZSBwcm92aWRlZCBjYWxsYmFjayBmdW5jdGlvbiBmb3IgZWFjaCBvZiB0aGUgY2hpbGRzIG9mIHRoZSBvcmlnaW5hbCBub2RlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGNoaWxkOiBOb2RlLCBwYXRoOiBzdHJpbmcsIHBhcmVudDogTm9kZSk6IE5vZGV9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtPcGVyYXRvck5vZGV9IFJldHVybnMgYSB0cmFuc2Zvcm1lZCBjb3B5IG9mIHRoZSBub2RlXG4gICAqL1xuICBOb2RlLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAvLyBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IGVhY2ggb2YgdGhlIE5vZGUgaW1wbGVtZW50YXRpb25zXG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcnVuIG1hcCBvbiBhIE5vZGUgaW50ZXJmYWNlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIHdoZXRoZXIgYW4gb2JqZWN0IGlzIGEgTm9kZSwgZm9yIHVzZSB3aXRoIG1hcFxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICogQHJldHVybnMge05vZGV9IFJldHVybnMgdGhlIGlucHV0IGlmIGl0J3MgYSBub2RlLCBlbHNlIHRocm93cyBhbiBFcnJvclxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBOb2RlLnByb3RvdHlwZS5faWZOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBpZiAoIShub2RlICYmIG5vZGUuaXNOb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2FsbGJhY2sgZnVuY3Rpb24gbXVzdCByZXR1cm4gYSBOb2RlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFsbCBub2RlcyBpbiBhIG5vZGUgdHJlZS4gRXhlY3V0ZXMgZ2l2ZW4gY2FsbGJhY2sgZm9yXG4gICAqIHRoaXMgbm9kZSBhbmQgZWFjaCBvZiBpdHMgY2hpbGQgbm9kZXMuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24obm9kZTogTm9kZSwgcGF0aDogc3RyaW5nLCBwYXJlbnQ6IE5vZGUpfSBjYWxsYmFja1xuICAgKiAgICAgICAgICBBIGNhbGxiYWNrIGNhbGxlZCBmb3IgZXZlcnkgbm9kZSBpbiB0aGUgbm9kZSB0cmVlLlxuICAgKi9cbiAgTm9kZS5wcm90b3R5cGUudHJhdmVyc2UgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAvLyBleGVjdXRlIGNhbGxiYWNrIGZvciBpdHNlbGZcbiAgICBjYWxsYmFjayh0aGlzLCBudWxsLCBudWxsKTtcblxuICAgIC8vIHJlY3Vyc2l2ZWx5IHRyYXZlcnNlIG92ZXIgYWxsIGNoaWxkcyBvZiBhIG5vZGVcbiAgICBmdW5jdGlvbiBfdHJhdmVyc2Uobm9kZSwgY2FsbGJhY2spIHtcbiAgICAgIG5vZGUuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQsIHBhdGgsIHBhcmVudCkge1xuICAgICAgICBjYWxsYmFjayhjaGlsZCwgcGF0aCwgcGFyZW50KTtcbiAgICAgICAgX3RyYXZlcnNlKGNoaWxkLCBjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBfdHJhdmVyc2UodGhpcywgY2FsbGJhY2spO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWN1cnNpdmVseSB0cmFuc2Zvcm0gYSBub2RlIHRyZWUgdmlhIGEgdHJhbnNmb3JtIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBGb3IgZXhhbXBsZSwgdG8gcmVwbGFjZSBhbGwgbm9kZXMgb2YgdHlwZSBTeW1ib2xOb2RlIGhhdmluZyBuYW1lICd4JyB3aXRoIGFcbiAgICogQ29uc3RhbnROb2RlIHdpdGggdmFsdWUgMjpcbiAgICpcbiAgICogICAgIHZhciByZXMgPSBOb2RlLnRyYW5zZm9ybShmdW5jdGlvbiAobm9kZSwgcGF0aCwgcGFyZW50KSB7XG4gICAqICAgICAgIGlmIChub2RlICYmIG5vZGUuaXNTeW1ib2xOb2RlKSAmJiAobm9kZS5uYW1lID09ICd4JykpIHtcbiAgICogICAgICAgICByZXR1cm4gbmV3IENvbnN0YW50Tm9kZSgyKTtcbiAgICogICAgICAgfVxuICAgKiAgICAgICBlbHNlIHtcbiAgICogICAgICAgICByZXR1cm4gbm9kZTtcbiAgICogICAgICAgfVxuICAgKiAgICAgfSk7XG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24obm9kZTogTm9kZSwgcGF0aDogc3RyaW5nLCBwYXJlbnQ6IE5vZGUpIDogTm9kZX0gY2FsbGJhY2tcbiAgICogICAgICAgICAgQSBtYXBwaW5nIGZ1bmN0aW9uIGFjY2VwdGluZyBhIG5vZGUsIGFuZCByZXR1cm5pbmdcbiAgICogICAgICAgICAgYSByZXBsYWNlbWVudCBmb3IgdGhlIG5vZGUgb3IgdGhlIG9yaWdpbmFsIG5vZGUuXG4gICAqICAgICAgICAgIFNpZ25hdHVyZTogY2FsbGJhY2sobm9kZTogTm9kZSwgaW5kZXg6IHN0cmluZywgcGFyZW50OiBOb2RlKSA6IE5vZGVcbiAgICogQHJldHVybiB7Tm9kZX0gUmV0dXJucyB0aGUgb3JpZ2luYWwgbm9kZSBvciBpdHMgcmVwbGFjZW1lbnRcbiAgICovXG4gIE5vZGUucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIC8vIHRyYXZlcnNlIG92ZXIgYWxsIGNoaWxkc1xuICAgIGZ1bmN0aW9uIF90cmFuc2Zvcm0gKG5vZGUsIGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gbm9kZS5tYXAoZnVuY3Rpb24oY2hpbGQsIHBhdGgsIHBhcmVudCkge1xuICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSBjYWxsYmFjayhjaGlsZCwgcGF0aCwgcGFyZW50KTtcbiAgICAgICAgcmV0dXJuIF90cmFuc2Zvcm0ocmVwbGFjZW1lbnQsIGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciByZXBsYWNlbWVudCA9IGNhbGxiYWNrKHRoaXMsIG51bGwsIG51bGwpO1xuICAgIHJldHVybiBfdHJhbnNmb3JtKHJlcGxhY2VtZW50LCBjYWxsYmFjayk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpbmQgYW55IG5vZGUgaW4gdGhlIG5vZGUgdHJlZSBtYXRjaGluZyBnaXZlbiBmaWx0ZXIgZnVuY3Rpb24uIEZvciBleGFtcGxlLCB0b1xuICAgKiBmaW5kIGFsbCBub2RlcyBvZiB0eXBlIFN5bWJvbE5vZGUgaGF2aW5nIG5hbWUgJ3gnOlxuICAgKlxuICAgKiAgICAgdmFyIHJlc3VsdHMgPSBOb2RlLmZpbHRlcihmdW5jdGlvbiAobm9kZSkge1xuICAgKiAgICAgICByZXR1cm4gKG5vZGUgJiYgbm9kZS5pc1N5bWJvbE5vZGUpICYmIChub2RlLm5hbWUgPT0gJ3gnKTtcbiAgICogICAgIH0pO1xuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG5vZGU6IE5vZGUsIHBhdGg6IHN0cmluZywgcGFyZW50OiBOb2RlKSA6IE5vZGV9IGNhbGxiYWNrXG4gICAqICAgICAgICAgICAgQSB0ZXN0IGZ1bmN0aW9uIHJldHVybmluZyB0cnVlIHdoZW4gYSBub2RlIG1hdGNoZXMsIGFuZCBmYWxzZVxuICAgKiAgICAgICAgICAgIG90aGVyd2lzZS4gRnVuY3Rpb24gc2lnbmF0dXJlOlxuICAgKiAgICAgICAgICAgIGNhbGxiYWNrKG5vZGU6IE5vZGUsIGluZGV4OiBzdHJpbmcsIHBhcmVudDogTm9kZSkgOiBib29sZWFuXG4gICAqIEByZXR1cm4ge05vZGVbXX0gbm9kZXMgICAgICAgQW4gYXJyYXkgd2l0aCBub2RlcyBtYXRjaGluZyBnaXZlbiBmaWx0ZXIgY3JpdGVyaWFcbiAgICovXG4gIE5vZGUucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHZhciBub2RlcyA9IFtdO1xuXG4gICAgdGhpcy50cmF2ZXJzZShmdW5jdGlvbiAobm9kZSwgcGF0aCwgcGFyZW50KSB7XG4gICAgICBpZiAoY2FsbGJhY2sobm9kZSwgcGF0aCwgcGFyZW50KSkge1xuICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5vZGVzO1xuICB9O1xuXG4gIC8vIFRPRE86IGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAxLjEuMCwgcmVtb3ZlIHRoaXMgc29tZSBkYXlcbiAgTm9kZS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uIE5vZGUuZmluZCBpcyBkZXByZWNhdGVkLiBVc2UgTm9kZS5maWx0ZXIgaW5zdGVhZC4nKTtcbiAgfTtcblxuICAvLyBUT0RPOiBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMS4xLjAsIHJlbW92ZSB0aGlzIHNvbWUgZGF5XG4gIE5vZGUucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gTm9kZS5tYXRjaCBpcyBkZXByZWNhdGVkLiBTZWUgZnVuY3Rpb25zIE5vZGUuZmlsdGVyLCBOb2RlLnRyYW5zZm9ybSwgTm9kZS50cmF2ZXJzZS4nKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgY2xvbmUgb2YgdGhpcyBub2RlLCBhIHNoYWxsb3cgY29weVxuICAgKiBAcmV0dXJuIHtOb2RlfVxuICAgKi9cbiAgTm9kZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gbXVzdCBiZSBpbXBsZW1lbnRlZCBieSBlYWNoIG9mIHRoZSBOb2RlIGltcGxlbWVudGF0aW9uc1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNsb25lIGEgTm9kZSBpbnRlcmZhY2UnKTtcbiAgfTtcblxuICAvKipcbiAgLyoqXG4gICAqIEdldCBzdHJpbmcgcmVwcmVzZW50YXRpb24uICh3cmFwcGVyIGZ1bmN0aW9uKVxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGNhbiBnZXQgYW4gb2JqZWN0IG9mIHRoZSBmb2xsb3dpbmcgZm9ybTpcbiAgICoge1xuICAgKiAgICBoYW5kbGVyOiAvL1RoaXMgY2FuIGJlIGEgY2FsbGJhY2sgZnVuY3Rpb24gb2YgdGhlIGZvcm1cbiAgICogICAgICAgICAgICAgLy8gXCJmdW5jdGlvbiBjYWxsYmFjayhub2RlLCBvcHRpb25zKVwib3JcbiAgICogICAgICAgICAgICAgLy8gYSBtYXAgdGhhdCBtYXBzIGZ1bmN0aW9uIG5hbWVzICh1c2VkIGluIEZ1bmN0aW9uTm9kZXMpXG4gICAqICAgICAgICAgICAgIC8vIHRvIGNhbGxiYWNrc1xuICAgKiAgICBwYXJlbnRoZXNpczogXCJrZWVwXCIgLy90aGUgcGFyZW50aGVzaXMgb3B0aW9uIChUaGlzIGlzIG9wdGlvbmFsKVxuICAgKiB9XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBjdXN0b21TdHJpbmc7XG4gICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMgPT0gXCJvYmplY3RcIikge1xuICAgICAgICBzd2l0Y2ggKHR5cGVvZiBvcHRpb25zLmhhbmRsZXIpIHtcbiAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICBjdXN0b21TdHJpbmcgPSBvcHRpb25zLmhhbmRsZXIodGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0IG9yIGZ1bmN0aW9uIGV4cGVjdGVkIGFzIGNhbGxiYWNrJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGN1c3RvbVN0cmluZyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBjdXN0b21TdHJpbmc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3RvU3RyaW5nKG9wdGlvbnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBmdW5jdGlvbiB0byBnZW5lcmF0ZSB0aGUgc3RyaW5nIG91dHB1dC5cbiAgICogVGhpcyBoYXMgdG8gYmUgaW1wbGVtZW50ZWQgYnkgZXZlcnkgTm9kZVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn1cbiAgICovXG4gIE5vZGUucHJvdG90eXBlLl90b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvL211c3QgYmUgaW1wbGVtZW50ZWQgYnkgZWFjaCBvZiB0aGUgTm9kZSBpbXBsZW1lbnRhdGlvbnNcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ190b1N0cmluZyBub3QgaW1wbGVtZW50ZWQgZm9yICcgKyB0aGlzLnR5cGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgTGFUZVggcmVwcmVzZW50YXRpb24uICh3cmFwcGVyIGZ1bmN0aW9uKVxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGNhbiBnZXQgYW4gb2JqZWN0IG9mIHRoZSBmb2xsb3dpbmcgZm9ybTpcbiAgICoge1xuICAgKiAgICBoYW5kbGVyOiAvL1RoaXMgY2FuIGJlIGEgY2FsbGJhY2sgZnVuY3Rpb24gb2YgdGhlIGZvcm1cbiAgICogICAgICAgICAgICAgLy8gXCJmdW5jdGlvbiBjYWxsYmFjayhub2RlLCBvcHRpb25zKVwib3JcbiAgICogICAgICAgICAgICAgLy8gYSBtYXAgdGhhdCBtYXBzIGZ1bmN0aW9uIG5hbWVzICh1c2VkIGluIEZ1bmN0aW9uTm9kZXMpXG4gICAqICAgICAgICAgICAgIC8vIHRvIGNhbGxiYWNrc1xuICAgKiAgICBwYXJlbnRoZXNpczogXCJrZWVwXCIgLy90aGUgcGFyZW50aGVzaXMgb3B0aW9uIChUaGlzIGlzIG9wdGlvbmFsKVxuICAgKiB9XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgTm9kZS5wcm90b3R5cGUudG9UZXggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBjdXN0b21UZXg7XG4gICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMgPT0gJ29iamVjdCcpIHtcbiAgICAgIHN3aXRjaCAodHlwZW9mIG9wdGlvbnMuaGFuZGxlcikge1xuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgY3VzdG9tVGV4ID0gb3B0aW9ucy5oYW5kbGVyKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdCBvciBmdW5jdGlvbiBleHBlY3RlZCBhcyBjYWxsYmFjaycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY3VzdG9tVGV4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGN1c3RvbVRleDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fdG9UZXgob3B0aW9ucyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEludGVybmFsIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIHRoZSBMYVRlWCBvdXRwdXQuXG4gICAqIFRoaXMgaGFzIHRvIGJlIGltcGxlbWVudGVkIGJ5IGV2ZXJ5IE5vZGVcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiBAdGhyb3dzIHtFcnJvcn1cbiAgICovXG4gIE5vZGUucHJvdG90eXBlLl90b1RleCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgLy9tdXN0IGJlIGltcGxlbWVudGVkIGJ5IGVhY2ggb2YgdGhlIE5vZGUgaW1wbGVtZW50YXRpb25zXG4gICAgdGhyb3cgbmV3IEVycm9yKCdfdG9UZXggbm90IGltcGxlbWVudGVkIGZvciAnICsgdGhpcy50eXBlKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGlkZW50aWZpZXIuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIE5vZGUucHJvdG90eXBlLmdldElkZW50aWZpZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjb250ZW50IG9mIHRoZSBjdXJyZW50IE5vZGUuXG4gICAqIEByZXR1cm4ge05vZGV9IG5vZGVcbiAgICoqL1xuICBOb2RlLnByb3RvdHlwZS5nZXRDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSB0aGUgc3ltYm9sIG5hbWVzIG9mIGEgc2NvcGUuXG4gICAqIFRocm93cyBhbiBlcnJvciB3aGVuIHRoZSBzY29wZSBjb250YWlucyBhbiBpbGxlZ2FsIHN5bWJvbC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHNjb3BlXG4gICAqL1xuICBmdW5jdGlvbiBfdmFsaWRhdGVTY29wZShzY29wZSkge1xuICAgIGZvciAodmFyIHN5bWJvbCBpbiBzY29wZSkge1xuICAgICAgaWYgKHNjb3BlLmhhc093blByb3BlcnR5KHN5bWJvbCkpIHtcbiAgICAgICAgaWYgKHN5bWJvbCBpbiBrZXl3b3Jkcykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2NvcGUgY29udGFpbnMgYW4gaWxsZWdhbCBzeW1ib2wsIFwiJyArIHN5bWJvbCArICdcIiBpcyBhIHJlc2VydmVkIGtleXdvcmQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBOb2RlO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnTm9kZSc7XG5leHBvcnRzLnBhdGggPSAnZXhwcmVzc2lvbi5ub2RlJztcbmV4cG9ydHMubWF0aCA9IHRydWU7IC8vIHJlcXVlc3QgYWNjZXNzIHRvIHRoZSBtYXRoIG5hbWVzcGFjZSBhcyA1dGggYXJndW1lbnQgb2YgdGhlIGZhY3RvcnkgZnVuY3Rpb25cbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmcgPSByZXF1aXJlKCcuLi8uLi91dGlscy9zdHJpbmcnKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgTm9kZSA9IGxvYWQocmVxdWlyZSgnLi9Ob2RlJykpO1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3IgT2JqZWN0Tm9kZVxuICAgKiBAZXh0ZW5kcyB7Tm9kZX1cbiAgICogSG9sZHMgYW4gb2JqZWN0IHdpdGgga2V5cy92YWx1ZXNcbiAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgTm9kZT59IFtwcm9wZXJ0aWVzXSAgIGFycmF5IHdpdGgga2V5L3ZhbHVlIHBhaXJzXG4gICAqL1xuICBmdW5jdGlvbiBPYmplY3ROb2RlKHByb3BlcnRpZXMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgT2JqZWN0Tm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQ29uc3RydWN0b3IgbXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgbmV3IG9wZXJhdG9yJyk7XG4gICAgfVxuXG4gICAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcyB8fCB7fTtcblxuICAgIC8vIHZhbGlkYXRlIGlucHV0XG4gICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgIGlmICghKHR5cGVvZiBwcm9wZXJ0aWVzID09PSAnb2JqZWN0JykgfHwgT2JqZWN0LmtleXMocHJvcGVydGllcykuc29tZShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gIXByb3BlcnRpZXNba2V5XSB8fCAhcHJvcGVydGllc1trZXldLmlzTm9kZTtcbiAgICAgICAgICB9KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QgY29udGFpbmluZyBOb2RlcyBleHBlY3RlZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIE9iamVjdE5vZGUucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcblxuICBPYmplY3ROb2RlLnByb3RvdHlwZS50eXBlID0gJ09iamVjdE5vZGUnO1xuXG4gIE9iamVjdE5vZGUucHJvdG90eXBlLmlzT2JqZWN0Tm9kZSA9IHRydWU7XG5cbiAgLyoqXG4gICAqIENvbXBpbGUgdGhlIG5vZGUgdG8gamF2YXNjcmlwdCBjb2RlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkZWZzICAgICBPYmplY3Qgd2hpY2ggY2FuIGJlIHVzZWQgdG8gZGVmaW5lIGZ1bmN0aW9uc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgb3IgY29uc3RhbnRzIGdsb2JhbGx5IGF2YWlsYWJsZSBmb3IgdGhlIGNvbXBpbGVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzICAgICBPYmplY3Qgd2l0aCBsb2NhbCBmdW5jdGlvbiBhcmd1bWVudHMsIHRoZSBrZXkgaXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBuYW1lIG9mIHRoZSBhcmd1bWVudCwgYW5kIHRoZSB2YWx1ZSBpcyBgdHJ1ZWAuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgb2JqZWN0IG1heSBub3QgYmUgbXV0YXRlZCwgYnV0IG11c3QgYmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuZGVkIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gY29kZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgT2JqZWN0Tm9kZS5wcm90b3R5cGUuX2NvbXBpbGUgPSBmdW5jdGlvbiAoZGVmcywgYXJncykge1xuICAgIHZhciBlbnRyaWVzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMucHJvcGVydGllcykge1xuICAgICAgaWYgKHRoaXMucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGVudHJpZXMucHVzaCgnXCInICsga2V5ICsgJ1wiOiAnICsgdGhpcy5wcm9wZXJ0aWVzW2tleV0uX2NvbXBpbGUoZGVmcywgYXJncykpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJ3snICsgZW50cmllcy5qb2luKCcsICcpICsgJ30nO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGVhY2ggb2YgdGhlIGNoaWxkIG5vZGVzIG9mIHRoaXMgbm9kZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGNoaWxkOiBOb2RlLCBwYXRoOiBzdHJpbmcsIHBhcmVudDogTm9kZSl9IGNhbGxiYWNrXG4gICAqL1xuICBPYmplY3ROb2RlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMucHJvcGVydGllcykge1xuICAgICAgaWYgKHRoaXMucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGNhbGxiYWNrKHRoaXMucHJvcGVydGllc1trZXldLCAncHJvcGVydGllc1tcIicgKyBrZXkgKyAnXCJdJywgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgT2JqZWN0Tm9kZSBoYXZpbmcgaXQncyBjaGlsZHMgYmUgdGhlIHJlc3VsdHMgb2YgY2FsbGluZ1xuICAgKiB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIGVhY2ggb2YgdGhlIGNoaWxkcyBvZiB0aGUgb3JpZ2luYWwgbm9kZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihjaGlsZDogTm9kZSwgcGF0aDogc3RyaW5nLCBwYXJlbnQ6IE5vZGUpOiBOb2RlfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7T2JqZWN0Tm9kZX0gUmV0dXJucyBhIHRyYW5zZm9ybWVkIGNvcHkgb2YgdGhlIG5vZGVcbiAgICovXG4gIE9iamVjdE5vZGUucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHZhciBwcm9wZXJ0aWVzID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMucHJvcGVydGllcykge1xuICAgICAgaWYgKHRoaXMucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHByb3BlcnRpZXNba2V5XSA9IHRoaXMuX2lmTm9kZShjYWxsYmFjayh0aGlzLnByb3BlcnRpZXNba2V5XSwgJ3Byb3BlcnRpZXNbXCInICsga2V5ICsgJ1wiXScsIHRoaXMpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBPYmplY3ROb2RlKHByb3BlcnRpZXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBjbG9uZSBvZiB0aGlzIG5vZGUsIGEgc2hhbGxvdyBjb3B5XG4gICAqIEByZXR1cm4ge09iamVjdE5vZGV9XG4gICAqL1xuICBPYmplY3ROb2RlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwcm9wZXJ0aWVzID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMucHJvcGVydGllcykge1xuICAgICAgaWYgKHRoaXMucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHByb3BlcnRpZXNba2V5XSA9IHRoaXMucHJvcGVydGllc1trZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IE9iamVjdE5vZGUocHJvcGVydGllcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7c3RyaW5nfSBzdHJcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBPYmplY3ROb2RlLnByb3RvdHlwZS5fdG9TdHJpbmcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGVudHJpZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5wcm9wZXJ0aWVzKSB7XG4gICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgZW50cmllcy5wdXNoKCdcIicgKyBrZXkgKyAnXCI6ICcgKyB0aGlzLnByb3BlcnRpZXNba2V5XS50b1N0cmluZyhvcHRpb25zKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAneycgKyBlbnRyaWVzLmpvaW4oJywgJykgKyAnfSc7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBMYVRlWCByZXByZXNlbnRhdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHN0clxuICAgKi9cbiAgT2JqZWN0Tm9kZS5wcm90b3R5cGUuX3RvVGV4ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBlbnRyaWVzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMucHJvcGVydGllcykge1xuICAgICAgaWYgKHRoaXMucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGVudHJpZXMucHVzaChcIlxcXFxtYXRoYmZ7XCIgKyBrZXkgKyAnOn0gJiAnICsgdGhpcy5wcm9wZXJ0aWVzW2tleV0udG9UZXgob3B0aW9ucykgKyBcIlxcXFxcXFxcXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJ1xcXFxsZWZ0XFxcXHtcXFxcYmVnaW57YXJyYXl9e2xsfScgKyBlbnRyaWVzLmpvaW4oJ1xcbicpICsgJ1xcXFxlbmR7YXJyYXl9XFxcXHJpZ2h0XFxcXH0nO1xuICB9O1xuXG4gIHJldHVybiBPYmplY3ROb2RlO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnT2JqZWN0Tm9kZSc7XG5leHBvcnRzLnBhdGggPSAnZXhwcmVzc2lvbi5ub2RlJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBsYXRleCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2xhdGV4Jyk7XG52YXIgb3BlcmF0b3JzID0gcmVxdWlyZSgnLi4vb3BlcmF0b3JzJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQsIG1hdGgpIHtcbiAgdmFyIE5vZGUgICAgICAgICA9IGxvYWQocmVxdWlyZSgnLi9Ob2RlJykpO1xuICB2YXIgQ29uc3RhbnROb2RlID0gbG9hZChyZXF1aXJlKCcuL0NvbnN0YW50Tm9kZScpKTtcbiAgdmFyIFN5bWJvbE5vZGUgICA9IGxvYWQocmVxdWlyZSgnLi9TeW1ib2xOb2RlJykpO1xuICB2YXIgRnVuY3Rpb25Ob2RlID0gbG9hZChyZXF1aXJlKCcuL0Z1bmN0aW9uTm9kZScpKTtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yIE9wZXJhdG9yTm9kZVxuICAgKiBAZXh0ZW5kcyB7Tm9kZX1cbiAgICogQW4gb3BlcmF0b3Igd2l0aCB0d28gYXJndW1lbnRzLCBsaWtlIDIrM1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3AgICAgICAgT3BlcmF0b3IgbmFtZSwgZm9yIGV4YW1wbGUgJysnXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmbiAgICAgICBGdW5jdGlvbiBuYW1lLCBmb3IgZXhhbXBsZSAnYWRkJ1xuICAgKiBAcGFyYW0ge05vZGVbXX0gYXJncyAgICAgT3BlcmF0b3IgYXJndW1lbnRzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW1wbGljaXQgSXMgdGhpcyBhbiBpbXBsaWNpdCBtdWx0aXBsaWNhdGlvbj9cbiAgICovXG4gIGZ1bmN0aW9uIE9wZXJhdG9yTm9kZShvcCwgZm4sIGFyZ3MsIGltcGxpY2l0KSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE9wZXJhdG9yTm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQ29uc3RydWN0b3IgbXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgbmV3IG9wZXJhdG9yJyk7XG4gICAgfVxuXG4gICAgLy92YWxpZGF0ZSBpbnB1dFxuICAgIGlmICh0eXBlb2Ygb3AgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzdHJpbmcgZXhwZWN0ZWQgZm9yIHBhcmFtZXRlciBcIm9wXCInKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmluZyBleHBlY3RlZCBmb3IgcGFyYW1ldGVyIFwiZm5cIicpO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJncylcbiAgICAgICAgfHwgIWFyZ3MuZXZlcnkoZnVuY3Rpb24gKG5vZGUpIHtyZXR1cm4gbm9kZSAmJiBub2RlLmlzTm9kZTt9KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkgY29udGFpbmluZyBOb2RlcyBleHBlY3RlZCBmb3IgcGFyYW1ldGVyIFwiYXJnc1wiJyk7XG4gICAgfVxuXG4gICAgdGhpcy5pbXBsaWNpdCA9IChpbXBsaWNpdCA9PT0gdHJ1ZSk7XG4gICAgdGhpcy5vcCA9IG9wO1xuICAgIHRoaXMuZm4gPSBmbjtcbiAgICB0aGlzLmFyZ3MgPSBhcmdzIHx8IFtdO1xuICB9XG5cbiAgT3BlcmF0b3JOb2RlLnByb3RvdHlwZSA9IG5ldyBOb2RlKCk7XG5cbiAgT3BlcmF0b3JOb2RlLnByb3RvdHlwZS50eXBlID0gJ09wZXJhdG9yTm9kZSc7XG5cbiAgT3BlcmF0b3JOb2RlLnByb3RvdHlwZS5pc09wZXJhdG9yTm9kZSA9IHRydWU7XG5cbiAgLyoqXG4gICAqIENvbXBpbGUgdGhlIG5vZGUgdG8gamF2YXNjcmlwdCBjb2RlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkZWZzICAgICBPYmplY3Qgd2hpY2ggY2FuIGJlIHVzZWQgdG8gZGVmaW5lIGZ1bmN0aW9uc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgb3IgY29uc3RhbnRzIGdsb2JhbGx5IGF2YWlsYWJsZSBmb3IgdGhlIGNvbXBpbGVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzICAgICBPYmplY3Qgd2l0aCBsb2NhbCBmdW5jdGlvbiBhcmd1bWVudHMsIHRoZSBrZXkgaXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBuYW1lIG9mIHRoZSBhcmd1bWVudCwgYW5kIHRoZSB2YWx1ZSBpcyBgdHJ1ZWAuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgb2JqZWN0IG1heSBub3QgYmUgbXV0YXRlZCwgYnV0IG11c3QgYmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuZGVkIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge3N0cmluZ30ganNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIE9wZXJhdG9yTm9kZS5wcm90b3R5cGUuX2NvbXBpbGUgPSBmdW5jdGlvbiAoZGVmcywgYXJncykge1xuICAgIGlmICghZGVmcy5tYXRoW3RoaXMuZm5dKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uICcgKyB0aGlzLmZuICsgJyBtaXNzaW5nIGluIHByb3ZpZGVkIG5hbWVzcGFjZSBcIm1hdGhcIicpO1xuICAgIH1cblxuICAgIHZhciBqc0FyZ3MgPSB0aGlzLmFyZ3MubWFwKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgIHJldHVybiBhcmcuX2NvbXBpbGUoZGVmcywgYXJncyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gJ21hdGguJyArIHRoaXMuZm4gKyAnKCcgKyBqc0FyZ3Muam9pbignLCAnKSArICcpJztcbiAgfTtcblxuICAvKipcbiAgICogRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBlYWNoIG9mIHRoZSBjaGlsZCBub2RlcyBvZiB0aGlzIG5vZGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbihjaGlsZDogTm9kZSwgcGF0aDogc3RyaW5nLCBwYXJlbnQ6IE5vZGUpfSBjYWxsYmFja1xuICAgKi9cbiAgT3BlcmF0b3JOb2RlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNhbGxiYWNrKHRoaXMuYXJnc1tpXSwgJ2FyZ3NbJyArIGkgKyAnXScsIHRoaXMpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IE9wZXJhdG9yTm9kZSBoYXZpbmcgaXQncyBjaGlsZHMgYmUgdGhlIHJlc3VsdHMgb2YgY2FsbGluZ1xuICAgKiB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIGVhY2ggb2YgdGhlIGNoaWxkcyBvZiB0aGUgb3JpZ2luYWwgbm9kZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihjaGlsZDogTm9kZSwgcGF0aDogc3RyaW5nLCBwYXJlbnQ6IE5vZGUpOiBOb2RlfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7T3BlcmF0b3JOb2RlfSBSZXR1cm5zIGEgdHJhbnNmb3JtZWQgY29weSBvZiB0aGUgbm9kZVxuICAgKi9cbiAgT3BlcmF0b3JOb2RlLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gdGhpcy5faWZOb2RlKGNhbGxiYWNrKHRoaXMuYXJnc1tpXSwgJ2FyZ3NbJyArIGkgKyAnXScsIHRoaXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBPcGVyYXRvck5vZGUodGhpcy5vcCwgdGhpcy5mbiwgYXJncyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGNsb25lIG9mIHRoaXMgbm9kZSwgYSBzaGFsbG93IGNvcHlcbiAgICogQHJldHVybiB7T3BlcmF0b3JOb2RlfVxuICAgKi9cbiAgT3BlcmF0b3JOb2RlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IE9wZXJhdG9yTm9kZSh0aGlzLm9wLCB0aGlzLmZuLCB0aGlzLmFyZ3Muc2xpY2UoMCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgd2hpY2ggcGFyZW50aGVzZXMgYXJlIG5lY2Vzc2FyeS4gR2V0cyBhbiBPcGVyYXRvck5vZGVcbiAgICogKHdoaWNoIGlzIHRoZSByb290IG9mIHRoZSB0cmVlKSBhbmQgYW4gQXJyYXkgb2YgTm9kZXNcbiAgICogKHRoaXMuYXJncykgYW5kIHJldHVybnMgYW4gYXJyYXkgd2hlcmUgJ3RydWUnIG1lYW5zIHRoYXQgYW4gYXJndW1lbnRcbiAgICogaGFzIHRvIGJlIGVuY2xvc2VkIGluIHBhcmVudGhlc2VzIHdoZXJlYXMgJ2ZhbHNlJyBtZWFucyB0aGUgb3Bwb3NpdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7T3BlcmF0b3JOb2RlfSByb290XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRoZXNpc1xuICAgKiBAcGFyYW0ge05vZGVbXX0gYXJnc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxhdGV4XG4gICAqIEByZXR1cm4ge2Jvb2xlYW5bXX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGNhbGN1bGF0ZU5lY2Vzc2FyeVBhcmVudGhlc2VzKHJvb3QsIHBhcmVudGhlc2lzLCBhcmdzLCBsYXRleCkge1xuICAgIC8vcHJlY2VkZW5jZSBvZiB0aGUgcm9vdCBPcGVyYXRvck5vZGVcbiAgICB2YXIgcHJlY2VkZW5jZSA9IG9wZXJhdG9ycy5nZXRQcmVjZWRlbmNlKHJvb3QsIHBhcmVudGhlc2lzKTtcbiAgICB2YXIgYXNzb2NpYXRpdml0eSA9IG9wZXJhdG9ycy5nZXRBc3NvY2lhdGl2aXR5KHJvb3QsIHBhcmVudGhlc2lzKTtcblxuICAgIGlmICgocGFyZW50aGVzaXMgPT09ICdhbGwnKSB8fCAoYXJncy5sZW5ndGggPiAyKSkge1xuICAgICAgdmFyIHBhcmVucyA9IFtdO1xuICAgICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgc3dpdGNoIChhcmcuZ2V0Q29udGVudCgpLnR5cGUpIHsgLy9Ob2RlcyB0aGF0IGRvbid0IG5lZWQgZXh0cmEgcGFyZW50aGVzZXNcbiAgICAgICAgICBjYXNlICdBcnJheU5vZGUnOlxuICAgICAgICAgIGNhc2UgJ0NvbnN0YW50Tm9kZSc6XG4gICAgICAgICAgY2FzZSAnU3ltYm9sTm9kZSc6XG4gICAgICAgICAgY2FzZSAnUGFyZW50aGVzaXNOb2RlJzpcbiAgICAgICAgICAgIHBhcmVucy5wdXNoKGZhbHNlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBwYXJlbnMucHVzaCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcGFyZW5zO1xuICAgIH1cblxuICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgY2FzZSAxOiAvL3VuYXJ5IG9wZXJhdG9yc1xuICAgICAgICAgICAgICAvL3ByZWNlZGVuY2Ugb2YgdGhlIG9wZXJhbmRcbiAgICAgICAgdmFyIG9wZXJhbmRQcmVjZWRlbmNlID0gb3BlcmF0b3JzLmdldFByZWNlZGVuY2UoYXJnc1swXSwgcGFyZW50aGVzaXMpO1xuXG4gICAgICAgIC8vaGFuZGxlIHNwZWNpYWwgY2FzZXMgZm9yIExhVGVYLCB3aGVyZSBzb21lIG9mIHRoZSBwYXJlbnRoZXNlcyBhcmVuJ3QgbmVlZGVkXG4gICAgICAgIGlmIChsYXRleCAmJiAob3BlcmFuZFByZWNlZGVuY2UgIT09IG51bGwpKSB7XG4gICAgICAgICAgdmFyIG9wZXJhbmRJZGVudGlmaWVyO1xuICAgICAgICAgIHZhciByb290SWRlbnRpZmllcjtcbiAgICAgICAgICBpZiAocGFyZW50aGVzaXMgPT09ICdrZWVwJykge1xuICAgICAgICAgICAgb3BlcmFuZElkZW50aWZpZXIgPSBhcmdzWzBdLmdldElkZW50aWZpZXIoKTtcbiAgICAgICAgICAgIHJvb3RJZGVudGlmaWVyID0gcm9vdC5nZXRJZGVudGlmaWVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy9JZ25vcmUgUGFyZW50aGVzaXMgTm9kZXMgd2hlbiBub3QgaW4gJ2tlZXAnIG1vZGVcbiAgICAgICAgICAgIG9wZXJhbmRJZGVudGlmaWVyID0gYXJnc1swXS5nZXRDb250ZW50KCkuZ2V0SWRlbnRpZmllcigpO1xuICAgICAgICAgICAgcm9vdElkZW50aWZpZXIgPSByb290LmdldENvbnRlbnQoKS5nZXRJZGVudGlmaWVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcGVyYXRvcnMucHJvcGVydGllc1twcmVjZWRlbmNlXVtyb290SWRlbnRpZmllcl0ubGF0ZXhMZWZ0UGFyZW5zID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIFtmYWxzZV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG9wZXJhdG9ycy5wcm9wZXJ0aWVzW29wZXJhbmRQcmVjZWRlbmNlXVtvcGVyYW5kSWRlbnRpZmllcl0ubGF0ZXhQYXJlbnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gW2ZhbHNlXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3BlcmFuZFByZWNlZGVuY2UgPT09IG51bGwpIHtcbiAgICAgICAgICAvL2lmIHRoZSBvcGVyYW5kIGhhcyBubyBkZWZpbmVkIHByZWNlZGVuY2UsIG5vIHBhcmVucyBhcmUgbmVlZGVkXG4gICAgICAgICAgcmV0dXJuIFtmYWxzZV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3BlcmFuZFByZWNlZGVuY2UgPD0gcHJlY2VkZW5jZSkge1xuICAgICAgICAgIC8vaWYgdGhlIG9wZXJhbmRzIHByZWNlZGVuY2UgaXMgbG93ZXIsIHBhcmVucyBhcmUgbmVlZGVkXG4gICAgICAgICAgcmV0dXJuIFt0cnVlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vb3RoZXJ3aXNlLCBubyBwYXJlbnMgbmVlZGVkXG4gICAgICAgIHJldHVybiBbZmFsc2VdO1xuXG4gICAgICBjYXNlIDI6IC8vYmluYXJ5IG9wZXJhdG9yc1xuICAgICAgICB2YXIgbGhzUGFyZW5zOyAvL2xlZnQgaGFuZCBzaWRlIG5lZWRzIHBhcmVudGhlc2lzP1xuICAgICAgICAvL3ByZWNlZGVuY2Ugb2YgdGhlIGxlZnQgaGFuZCBzaWRlXG4gICAgICAgIHZhciBsaHNQcmVjZWRlbmNlID0gb3BlcmF0b3JzLmdldFByZWNlZGVuY2UoYXJnc1swXSwgcGFyZW50aGVzaXMpO1xuICAgICAgICAvL2lzIHRoZSByb290IG5vZGUgYXNzb2NpYXRpdmUgd2l0aCB0aGUgbGVmdCBoYW5kIHNpZGVcbiAgICAgICAgdmFyIGFzc29jV2l0aExocyA9IG9wZXJhdG9ycy5pc0Fzc29jaWF0aXZlV2l0aChyb290LCBhcmdzWzBdLCBwYXJlbnRoZXNpcyk7XG5cbiAgICAgICAgaWYgKGxoc1ByZWNlZGVuY2UgPT09IG51bGwpIHtcbiAgICAgICAgICAvL2lmIHRoZSBsZWZ0IGhhbmQgc2lkZSBoYXMgbm8gZGVmaW5lZCBwcmVjZWRlbmNlLCBubyBwYXJlbnMgYXJlIG5lZWRlZFxuICAgICAgICAgIC8vRnVuY3Rpb25Ob2RlIGZvciBleGFtcGxlXG4gICAgICAgICAgbGhzUGFyZW5zID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGxoc1ByZWNlZGVuY2UgPT09IHByZWNlZGVuY2UpICYmIChhc3NvY2lhdGl2aXR5ID09PSAncmlnaHQnKSAmJiAhYXNzb2NXaXRoTGhzKSB7XG4gICAgICAgICAgLy9JbiBjYXNlIG9mIGVxdWFsIHByZWNlZGVuY2UsIGlmIHRoZSByb290IG5vZGUgaXMgbGVmdCBhc3NvY2lhdGl2ZVxuICAgICAgICAgIC8vIHBhcmVucyBhcmUgKipuZXZlcioqIG5lY2Vzc2FyeSBmb3IgdGhlIGxlZnQgaGFuZCBzaWRlLlxuICAgICAgICAgIC8vSWYgaXQgaXMgcmlnaHQgYXNzb2NpYXRpdmUgaG93ZXZlciwgcGFyZW5zIGFyZSBuZWNlc3NhcnlcbiAgICAgICAgICAvL2lmIHRoZSByb290IG5vZGUgaXNuJ3QgYXNzb2NpYXRpdmUgd2l0aCB0aGUgbGVmdCBoYW5kIHNpZGVcbiAgICAgICAgICBsaHNQYXJlbnMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxoc1ByZWNlZGVuY2UgPCBwcmVjZWRlbmNlKSB7XG4gICAgICAgICAgbGhzUGFyZW5zID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBsaHNQYXJlbnMgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByaHNQYXJlbnM7IC8vcmlnaHQgaGFuZCBzaWRlIG5lZWRzIHBhcmVudGhlc2lzP1xuICAgICAgICAvL3ByZWNlZGVuY2Ugb2YgdGhlIHJpZ2h0IGhhbmQgc2lkZVxuICAgICAgICB2YXIgcmhzUHJlY2VkZW5jZSA9IG9wZXJhdG9ycy5nZXRQcmVjZWRlbmNlKGFyZ3NbMV0sIHBhcmVudGhlc2lzKTtcbiAgICAgICAgLy9pcyB0aGUgcm9vdCBub2RlIGFzc29jaWF0aXZlIHdpdGggdGhlIHJpZ2h0IGhhbmQgc2lkZT9cbiAgICAgICAgdmFyIGFzc29jV2l0aFJocyA9IG9wZXJhdG9ycy5pc0Fzc29jaWF0aXZlV2l0aChyb290LCBhcmdzWzFdLCBwYXJlbnRoZXNpcyk7XG5cbiAgICAgICAgaWYgKHJoc1ByZWNlZGVuY2UgPT09IG51bGwpIHtcbiAgICAgICAgICAvL2lmIHRoZSByaWdodCBoYW5kIHNpZGUgaGFzIG5vIGRlZmluZWQgcHJlY2VkZW5jZSwgbm8gcGFyZW5zIGFyZSBuZWVkZWRcbiAgICAgICAgICAvL0Z1bmN0aW9uTm9kZSBmb3IgZXhhbXBsZVxuICAgICAgICAgIHJoc1BhcmVucyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChyaHNQcmVjZWRlbmNlID09PSBwcmVjZWRlbmNlKSAmJiAoYXNzb2NpYXRpdml0eSA9PT0gJ2xlZnQnKSAmJiAhYXNzb2NXaXRoUmhzKSB7XG4gICAgICAgICAgLy9JbiBjYXNlIG9mIGVxdWFsIHByZWNlZGVuY2UsIGlmIHRoZSByb290IG5vZGUgaXMgcmlnaHQgYXNzb2NpYXRpdmVcbiAgICAgICAgICAvLyBwYXJlbnMgYXJlICoqbmV2ZXIqKiBuZWNlc3NhcnkgZm9yIHRoZSByaWdodCBoYW5kIHNpZGUuXG4gICAgICAgICAgLy9JZiBpdCBpcyBsZWZ0IGFzc29jaWF0aXZlIGhvd2V2ZXIsIHBhcmVucyBhcmUgbmVjZXNzYXJ5XG4gICAgICAgICAgLy9pZiB0aGUgcm9vdCBub2RlIGlzbid0IGFzc29jaWF0aXZlIHdpdGggdGhlIHJpZ2h0IGhhbmQgc2lkZVxuICAgICAgICAgIHJoc1BhcmVucyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmhzUHJlY2VkZW5jZSA8IHByZWNlZGVuY2UpIHtcbiAgICAgICAgICByaHNQYXJlbnMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJoc1BhcmVucyA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9oYW5kbGUgc3BlY2lhbCBjYXNlcyBmb3IgTGFUZVgsIHdoZXJlIHNvbWUgb2YgdGhlIHBhcmVudGhlc2VzIGFyZW4ndCBuZWVkZWRcbiAgICAgICAgaWYgKGxhdGV4KSB7XG4gICAgICAgICAgdmFyIHJvb3RJZGVudGlmaWVyO1xuICAgICAgICAgIHZhciBsaHNJZGVudGlmaWVyO1xuICAgICAgICAgIHZhciByaHNJZGVudGlmaWVyO1xuICAgICAgICAgIGlmIChwYXJlbnRoZXNpcyA9PT0gJ2tlZXAnKSB7XG4gICAgICAgICAgICByb290SWRlbnRpZmllciA9IHJvb3QuZ2V0SWRlbnRpZmllcigpO1xuICAgICAgICAgICAgbGhzSWRlbnRpZmllciA9IHJvb3QuYXJnc1swXS5nZXRJZGVudGlmaWVyKCk7XG4gICAgICAgICAgICByaHNJZGVudGlmaWVyID0gcm9vdC5hcmdzWzFdLmdldElkZW50aWZpZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvL0lnbm9yZSBQYXJlbnRoZXNpc05vZGVzIHdoZW4gbm90IGluICdrZWVwJyBtb2RlXG4gICAgICAgICAgICByb290SWRlbnRpZmllciA9IHJvb3QuZ2V0Q29udGVudCgpLmdldElkZW50aWZpZXIoKTtcbiAgICAgICAgICAgIGxoc0lkZW50aWZpZXIgPSByb290LmFyZ3NbMF0uZ2V0Q29udGVudCgpLmdldElkZW50aWZpZXIoKTtcbiAgICAgICAgICAgIHJoc0lkZW50aWZpZXIgPSByb290LmFyZ3NbMV0uZ2V0Q29udGVudCgpLmdldElkZW50aWZpZXIoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobGhzUHJlY2VkZW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKG9wZXJhdG9ycy5wcm9wZXJ0aWVzW3ByZWNlZGVuY2VdW3Jvb3RJZGVudGlmaWVyXS5sYXRleExlZnRQYXJlbnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIGxoc1BhcmVucyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3BlcmF0b3JzLnByb3BlcnRpZXNbbGhzUHJlY2VkZW5jZV1bbGhzSWRlbnRpZmllcl0ubGF0ZXhQYXJlbnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIGxoc1BhcmVucyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyaHNQcmVjZWRlbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAob3BlcmF0b3JzLnByb3BlcnRpZXNbcHJlY2VkZW5jZV1bcm9vdElkZW50aWZpZXJdLmxhdGV4UmlnaHRQYXJlbnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHJoc1BhcmVucyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3BlcmF0b3JzLnByb3BlcnRpZXNbcmhzUHJlY2VkZW5jZV1bcmhzSWRlbnRpZmllcl0ubGF0ZXhQYXJlbnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHJoc1BhcmVucyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbbGhzUGFyZW5zLCByaHNQYXJlbnNdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHN0clxuICAgKi9cbiAgT3BlcmF0b3JOb2RlLnByb3RvdHlwZS5fdG9TdHJpbmcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBwYXJlbnRoZXNpcyA9IChvcHRpb25zICYmIG9wdGlvbnMucGFyZW50aGVzaXMpID8gb3B0aW9ucy5wYXJlbnRoZXNpcyA6ICdrZWVwJztcbiAgICB2YXIgaW1wbGljaXQgPSAob3B0aW9ucyAmJiBvcHRpb25zLmltcGxpY2l0KSA/IG9wdGlvbnMuaW1wbGljaXQgOiAnaGlkZSc7XG4gICAgdmFyIGFyZ3MgPSB0aGlzLmFyZ3M7XG4gICAgdmFyIHBhcmVucyA9IGNhbGN1bGF0ZU5lY2Vzc2FyeVBhcmVudGhlc2VzKHRoaXMsIHBhcmVudGhlc2lzLCBhcmdzLCBmYWxzZSk7XG5cbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICBjYXNlIDE6IC8vdW5hcnkgb3BlcmF0b3JzXG4gICAgICAgIHZhciBhc3NvYyA9IG9wZXJhdG9ycy5nZXRBc3NvY2lhdGl2aXR5KHRoaXMsIHBhcmVudGhlc2lzKTtcblxuICAgICAgICB2YXIgb3BlcmFuZCA9IGFyZ3NbMF0udG9TdHJpbmcob3B0aW9ucyk7XG4gICAgICAgIGlmIChwYXJlbnNbMF0pIHtcbiAgICAgICAgICBvcGVyYW5kID0gJygnICsgb3BlcmFuZCArICcpJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhc3NvYyA9PT0gJ3JpZ2h0JykgeyAvL3ByZWZpeCBvcGVyYXRvclxuICAgICAgICAgIHJldHVybiB0aGlzLm9wICsgb3BlcmFuZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhc3NvYyA9PT0gJ2xlZnQnKSB7IC8vcG9zdGZpeFxuICAgICAgICAgIHJldHVybiBvcGVyYW5kICsgdGhpcy5vcDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vZmFsbCBiYWNrIHRvIHBvc3RmaXhcbiAgICAgICAgcmV0dXJuIG9wZXJhbmQgKyB0aGlzLm9wO1xuXG4gICAgICBjYXNlIDI6XG4gICAgICAgIHZhciBsaHMgPSBhcmdzWzBdLnRvU3RyaW5nKG9wdGlvbnMpOyAvL2xlZnQgaGFuZCBzaWRlXG4gICAgICAgIHZhciByaHMgPSBhcmdzWzFdLnRvU3RyaW5nKG9wdGlvbnMpOyAvL3JpZ2h0IGhhbmQgc2lkZVxuICAgICAgICBpZiAocGFyZW5zWzBdKSB7IC8vbGVmdCBoYW5kIHNpZGUgaW4gcGFyZW50aGVzaXM/XG4gICAgICAgICAgbGhzID0gJygnICsgbGhzICsgJyknO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJlbnNbMV0pIHsgLy9yaWdodCBoYW5kIHNpZGUgaW4gcGFyZW50aGVzaXM/XG4gICAgICAgICAgcmhzID0gJygnICsgcmhzICsgJyknO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaW1wbGljaXQgJiYgKHRoaXMuZ2V0SWRlbnRpZmllcigpID09PSAnT3BlcmF0b3JOb2RlOm11bHRpcGx5JykgJiYgKGltcGxpY2l0ID09ICdoaWRlJykpIHtcbiAgICAgICAgICByZXR1cm4gbGhzICsgJyAnICsgcmhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxocyArICcgJyArIHRoaXMub3AgKyAnICcgKyByaHM7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vZmFsbGJhY2sgdG8gZm9ybWF0dGluZyBhcyBhIGZ1bmN0aW9uIGNhbGxcbiAgICAgICAgcmV0dXJuIHRoaXMuZm4gKyAnKCcgKyB0aGlzLmFyZ3Muam9pbignLCAnKSArICcpJztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBMYVRlWCByZXByZXNlbnRhdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHN0clxuICAgKi9cbiAgT3BlcmF0b3JOb2RlLnByb3RvdHlwZS5fdG9UZXggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBwYXJlbnRoZXNpcyA9IChvcHRpb25zICYmIG9wdGlvbnMucGFyZW50aGVzaXMpID8gb3B0aW9ucy5wYXJlbnRoZXNpcyA6ICdrZWVwJztcbiAgICB2YXIgaW1wbGljaXQgPSAob3B0aW9ucyAmJiBvcHRpb25zLmltcGxpY2l0KSA/IG9wdGlvbnMuaW1wbGljaXQgOiAnaGlkZSc7XG4gICAgdmFyIGFyZ3MgPSB0aGlzLmFyZ3M7XG4gICAgdmFyIHBhcmVucyA9IGNhbGN1bGF0ZU5lY2Vzc2FyeVBhcmVudGhlc2VzKHRoaXMsIHBhcmVudGhlc2lzLCBhcmdzLCB0cnVlKTtcbiAgICB2YXIgb3AgPSBsYXRleC5vcGVyYXRvcnNbdGhpcy5mbl07XG4gICAgb3AgPSB0eXBlb2Ygb3AgPT09ICd1bmRlZmluZWQnID8gdGhpcy5vcCA6IG9wOyAvL2ZhbGwgYmFjayB0byB1c2luZyB0aGlzLm9wXG5cbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICBjYXNlIDE6IC8vdW5hcnkgb3BlcmF0b3JzXG4gICAgICAgIHZhciBhc3NvYyA9IG9wZXJhdG9ycy5nZXRBc3NvY2lhdGl2aXR5KHRoaXMsIHBhcmVudGhlc2lzKTtcblxuICAgICAgICB2YXIgb3BlcmFuZCA9IGFyZ3NbMF0udG9UZXgob3B0aW9ucyk7XG4gICAgICAgIGlmIChwYXJlbnNbMF0pIHtcbiAgICAgICAgICBvcGVyYW5kID0gJ1xcXFxsZWZ0KCcgKyBvcGVyYW5kICsgJ1xcXFxyaWdodCknO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFzc29jID09PSAncmlnaHQnKSB7IC8vcHJlZml4IG9wZXJhdG9yXG4gICAgICAgICAgcmV0dXJuIG9wICsgb3BlcmFuZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhc3NvYyA9PT0gJ2xlZnQnKSB7IC8vcG9zdGZpeCBvcGVyYXRvclxuICAgICAgICAgIHJldHVybiBvcGVyYW5kICsgb3A7XG4gICAgICAgIH1cblxuICAgICAgICAvL2ZhbGwgYmFjayB0byBwb3N0Zml4XG4gICAgICAgIHJldHVybiBvcGVyYW5kICsgb3A7XG5cbiAgICAgIGNhc2UgMjogLy9iaW5hcnkgb3BlcmF0b3JzXG4gICAgICAgIHZhciBsaHMgPSBhcmdzWzBdOyAvL2xlZnQgaGFuZCBzaWRlXG4gICAgICAgIHZhciBsaHNUZXggPSBsaHMudG9UZXgob3B0aW9ucyk7XG4gICAgICAgIGlmIChwYXJlbnNbMF0pIHtcbiAgICAgICAgICBsaHNUZXggPSAnXFxcXGxlZnQoJyArIGxoc1RleCArICdcXFxccmlnaHQpJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByaHMgPSBhcmdzWzFdOyAvL3JpZ2h0IGhhbmQgc2lkZVxuICAgICAgICB2YXIgcmhzVGV4ID0gcmhzLnRvVGV4KG9wdGlvbnMpO1xuICAgICAgICBpZiAocGFyZW5zWzFdKSB7XG4gICAgICAgICAgcmhzVGV4ID0gJ1xcXFxsZWZ0KCcgKyByaHNUZXggKyAnXFxcXHJpZ2h0KSc7XG4gICAgICAgIH1cblxuICAgICAgICAvL2hhbmRsZSBzb21lIGV4Y2VwdGlvbnMgKGR1ZSB0byB0aGUgd2F5IExhVGVYIHdvcmtzKVxuICAgICAgICB2YXIgbGhzSWRlbnRpZmllcjtcbiAgICAgICAgaWYgKHBhcmVudGhlc2lzID09PSAna2VlcCcpIHtcbiAgICAgICAgICBsaHNJZGVudGlmaWVyID0gbGhzLmdldElkZW50aWZpZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvL0lnbm9yZSBQYXJlbnRoZXNpc05vZGVzIGlmIGluICdrZWVwJyBtb2RlXG4gICAgICAgICAgbGhzSWRlbnRpZmllciA9IGxocy5nZXRDb250ZW50KCkuZ2V0SWRlbnRpZmllcigpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodGhpcy5nZXRJZGVudGlmaWVyKCkpIHtcbiAgICAgICAgICBjYXNlICdPcGVyYXRvck5vZGU6ZGl2aWRlJzpcbiAgICAgICAgICAgIC8vb3AgY29udGFpbnMgJ1xcXFxmcmFjJyBhdCB0aGlzIHBvaW50XG4gICAgICAgICAgICByZXR1cm4gb3AgKyAneycgKyBsaHNUZXggKyAnfScgKyAneycgKyByaHNUZXggKyAnfSc7XG4gICAgICAgICAgY2FzZSAnT3BlcmF0b3JOb2RlOnBvdyc6XG4gICAgICAgICAgICBsaHNUZXggPSAneycgKyBsaHNUZXggKyAnfSc7XG4gICAgICAgICAgICByaHNUZXggPSAneycgKyByaHNUZXggKyAnfSc7XG4gICAgICAgICAgICBzd2l0Y2ggKGxoc0lkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgY2FzZSAnQ29uZGl0aW9uYWxOb2RlJzogLy9cbiAgICAgICAgICAgICAgY2FzZSAnT3BlcmF0b3JOb2RlOmRpdmlkZSc6XG4gICAgICAgICAgICAgICAgbGhzVGV4ID0gJ1xcXFxsZWZ0KCcgKyBsaHNUZXggKyAnXFxcXHJpZ2h0KSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnT3BlcmF0b3JOb2RlOm11bHRpcGx5JzpcbiAgICAgICAgICAgIGlmICh0aGlzLmltcGxpY2l0ICYmIChpbXBsaWNpdCA9PT0gJ2hpZGUnKSkge1xuICAgICAgICAgICAgICByZXR1cm4gbGhzVGV4ICsgJ34nICsgcmhzVGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaHNUZXggKyBvcCArIHJoc1RleDtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy9mYWxsIGJhY2sgdG8gZm9ybWF0dGluZyBhcyBhIGZ1bmN0aW9uIGNhbGxcbiAgICAgICAgLy9hcyB0aGlzIGlzIGEgZmFsbGJhY2ssIGl0IGRvZXNuJ3QgdXNlXG4gICAgICAgIC8vZmFuY3kgZnVuY3Rpb24gbmFtZXNcbiAgICAgICAgcmV0dXJuICdcXFxcbWF0aHJteycgKyB0aGlzLmZuICsgJ31cXFxcbGVmdCgnXG4gICAgICAgICAgICArIGFyZ3MubWFwKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGFyZy50b1RleChvcHRpb25zKTtcbiAgICAgICAgICAgIH0pLmpvaW4oJywnKSArICdcXFxccmlnaHQpJztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBpZGVudGlmaWVyLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBPcGVyYXRvck5vZGUucHJvdG90eXBlLmdldElkZW50aWZpZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZSArICc6JyArIHRoaXMuZm47XG4gIH07XG5cbiAgcmV0dXJuIE9wZXJhdG9yTm9kZTtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ09wZXJhdG9yTm9kZSc7XG5leHBvcnRzLnBhdGggPSAnZXhwcmVzc2lvbi5ub2RlJztcbmV4cG9ydHMubWF0aCA9IHRydWU7IC8vIHJlcXVlc3QgYWNjZXNzIHRvIHRoZSBtYXRoIG5hbWVzcGFjZSBhcyA1dGggYXJndW1lbnQgb2YgdGhlIGZhY3RvcnkgZnVuY3Rpb25cbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIE5vZGUgPSBsb2FkKHJlcXVpcmUoJy4vTm9kZScpKTtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yIFBhcmVudGhlc2lzTm9kZVxuICAgKiBAZXh0ZW5kcyB7Tm9kZX1cbiAgICogQSBwYXJlbnRoZXNpcyBub2RlIGRlc2NyaWJlcyBtYW51YWwgcGFyZW50aGVzaXMgZnJvbSB0aGUgdXNlciBpbnB1dFxuICAgKiBAcGFyYW0ge05vZGV9IGNvbnRlbnRcbiAgICogQGV4dGVuZHMge05vZGV9XG4gICAqL1xuICBmdW5jdGlvbiBQYXJlbnRoZXNpc05vZGUoY29udGVudCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXJlbnRoZXNpc05vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0NvbnN0cnVjdG9yIG11c3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBvcGVyYXRvcicpO1xuICAgIH1cblxuICAgIC8vIHZhbGlkYXRlIGlucHV0XG4gICAgaWYgKCEoY29udGVudCAmJiBjb250ZW50LmlzTm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vZGUgZXhwZWN0ZWQgZm9yIHBhcmFtZXRlciBcImNvbnRlbnRcIicpO1xuICAgIH1cblxuICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gIH1cblxuICBQYXJlbnRoZXNpc05vZGUucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcblxuICBQYXJlbnRoZXNpc05vZGUucHJvdG90eXBlLnR5cGUgPSAnUGFyZW50aGVzaXNOb2RlJztcblxuICBQYXJlbnRoZXNpc05vZGUucHJvdG90eXBlLmlzUGFyZW50aGVzaXNOb2RlID0gdHJ1ZTtcblxuICAvKipcbiAgICogQ29tcGlsZSB0aGUgbm9kZSB0byBqYXZhc2NyaXB0IGNvZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlZnMgICAgIE9iamVjdCB3aGljaCBjYW4gYmUgdXNlZCB0byBkZWZpbmUgZnVuY3Rpb25zXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBvciBjb25zdGFudHMgZ2xvYmFsbHkgYXZhaWxhYmxlIGZvciB0aGUgY29tcGlsZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgICAgIE9iamVjdCB3aXRoIGxvY2FsIGZ1bmN0aW9uIGFyZ3VtZW50cywgdGhlIGtleSBpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG5hbWUgb2YgdGhlIGFyZ3VtZW50LCBhbmQgdGhlIHZhbHVlIGlzIGB0cnVlYC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBvYmplY3QgbWF5IG5vdCBiZSBtdXRhdGVkLCBidXQgbXVzdCBiZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kZWQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7c3RyaW5nfSBqc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgUGFyZW50aGVzaXNOb2RlLnByb3RvdHlwZS5fY29tcGlsZSA9IGZ1bmN0aW9uIChkZWZzLCBhcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudC5fY29tcGlsZShkZWZzLCBhcmdzKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjb250ZW50IG9mIHRoZSBjdXJyZW50IE5vZGUuXG4gICAqIEByZXR1cm4ge05vZGV9IGNvbnRlbnRcbiAgICogQG92ZXJyaWRlXG4gICAqKi9cbiAgUGFyZW50aGVzaXNOb2RlLnByb3RvdHlwZS5nZXRDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQuZ2V0Q29udGVudCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGVhY2ggb2YgdGhlIGNoaWxkIG5vZGVzIG9mIHRoaXMgbm9kZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGNoaWxkOiBOb2RlLCBwYXRoOiBzdHJpbmcsIHBhcmVudDogTm9kZSl9IGNhbGxiYWNrXG4gICAqL1xuICBQYXJlbnRoZXNpc05vZGUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayh0aGlzLmNvbnRlbnQsICdjb250ZW50JywgdGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBQYXJlbnRoZXNpc05vZGUgaGF2aW5nIGl0J3MgY2hpbGRzIGJlIHRoZSByZXN1bHRzIG9mIGNhbGxpbmdcbiAgICogdGhlIHByb3ZpZGVkIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBlYWNoIG9mIHRoZSBjaGlsZHMgb2YgdGhlIG9yaWdpbmFsIG5vZGUuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oY2hpbGQ6IE5vZGUsIHBhdGg6IHN0cmluZywgcGFyZW50OiBOb2RlKSA6IE5vZGV9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtQYXJlbnRoZXNpc05vZGV9IFJldHVybnMgYSBjbG9uZSBvZiB0aGUgbm9kZVxuICAgKi9cbiAgUGFyZW50aGVzaXNOb2RlLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB2YXIgY29udGVudCA9IGNhbGxiYWNrKHRoaXMuY29udGVudCwgJ2NvbnRlbnQnLCB0aGlzKTtcbiAgICByZXR1cm4gbmV3IFBhcmVudGhlc2lzTm9kZShjb250ZW50KTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgY2xvbmUgb2YgdGhpcyBub2RlLCBhIHNoYWxsb3cgY29weVxuICAgKiBAcmV0dXJuIHtQYXJlbnRoZXNpc05vZGV9XG4gICAqL1xuICBQYXJlbnRoZXNpc05vZGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBQYXJlbnRoZXNpc05vZGUodGhpcy5jb250ZW50KTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHN0clxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIFBhcmVudGhlc2lzTm9kZS5wcm90b3R5cGUuX3RvU3RyaW5nID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmICgoIW9wdGlvbnMpIHx8IChvcHRpb25zICYmICFvcHRpb25zLnBhcmVudGhlc2lzKSB8fCAob3B0aW9ucyAmJiBvcHRpb25zLnBhcmVudGhlc2lzID09PSAna2VlcCcpKSB7XG4gICAgICByZXR1cm4gJygnICsgdGhpcy5jb250ZW50LnRvU3RyaW5nKG9wdGlvbnMpICsgJyknO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250ZW50LnRvU3RyaW5nKG9wdGlvbnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgTGFUZVggcmVwcmVzZW50YXRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7c3RyaW5nfSBzdHJcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBQYXJlbnRoZXNpc05vZGUucHJvdG90eXBlLl90b1RleCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAoKCFvcHRpb25zKSB8fCAob3B0aW9ucyAmJiAhb3B0aW9ucy5wYXJlbnRoZXNpcykgfHwgKG9wdGlvbnMgJiYgb3B0aW9ucy5wYXJlbnRoZXNpcyA9PT0gJ2tlZXAnKSkge1xuICAgICAgcmV0dXJuICdcXFxcbGVmdCgnICsgdGhpcy5jb250ZW50LnRvVGV4KG9wdGlvbnMpICsgJ1xcXFxyaWdodCknO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250ZW50LnRvVGV4KG9wdGlvbnMpO1xuICB9O1xuXG4gIHJldHVybiBQYXJlbnRoZXNpc05vZGU7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdQYXJlbnRoZXNpc05vZGUnO1xuZXhwb3J0cy5wYXRoID0gJ2V4cHJlc3Npb24ubm9kZSc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgb3BlcmF0b3JzID0gcmVxdWlyZSgnLi4vb3BlcmF0b3JzJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIE5vZGUgPSBsb2FkKHJlcXVpcmUoJy4vTm9kZScpKTtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yIFJhbmdlTm9kZVxuICAgKiBAZXh0ZW5kcyB7Tm9kZX1cbiAgICogY3JlYXRlIGEgcmFuZ2VcbiAgICogQHBhcmFtIHtOb2RlfSBzdGFydCAgaW5jbHVkZWQgbG93ZXItYm91bmRcbiAgICogQHBhcmFtIHtOb2RlfSBlbmQgICAgaW5jbHVkZWQgdXBwZXItYm91bmRcbiAgICogQHBhcmFtIHtOb2RlfSBbc3RlcF0gb3B0aW9uYWwgc3RlcFxuICAgKi9cbiAgZnVuY3Rpb24gUmFuZ2VOb2RlKHN0YXJ0LCBlbmQsIHN0ZXApIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmFuZ2VOb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdDb25zdHJ1Y3RvciBtdXN0IGJlIGNhbGxlZCB3aXRoIHRoZSBuZXcgb3BlcmF0b3InKTtcbiAgICB9XG5cbiAgICAvLyB2YWxpZGF0ZSBpbnB1dHNcbiAgICBpZiAoIShzdGFydCAmJiBzdGFydC5pc05vZGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb2RlIGV4cGVjdGVkJyk7XG4gICAgaWYgKCEoZW5kICYmIGVuZC5pc05vZGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb2RlIGV4cGVjdGVkJyk7XG4gICAgaWYgKHN0ZXAgJiYgIShzdGVwICYmIHN0ZXAuaXNOb2RlKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignTm9kZSBleHBlY3RlZCcpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMykgdGhyb3cgbmV3IEVycm9yKCdUb28gbWFueSBhcmd1bWVudHMnKTtcblxuICAgIHRoaXMuc3RhcnQgPSBzdGFydDsgICAgICAgICAvLyBpbmNsdWRlZCBsb3dlci1ib3VuZFxuICAgIHRoaXMuZW5kID0gZW5kOyAgICAgICAgICAgLy8gaW5jbHVkZWQgdXBwZXItYm91bmRcbiAgICB0aGlzLnN0ZXAgPSBzdGVwIHx8IG51bGw7ICAvLyBvcHRpb25hbCBzdGVwXG4gIH1cblxuICBSYW5nZU5vZGUucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcblxuICBSYW5nZU5vZGUucHJvdG90eXBlLnR5cGUgPSAnUmFuZ2VOb2RlJztcblxuICBSYW5nZU5vZGUucHJvdG90eXBlLmlzUmFuZ2VOb2RlID0gdHJ1ZTtcblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciB0aGUgUmFuZ2VOb2RlIG5lZWRzIHRoZSBgZW5kYCBzeW1ib2wgdG8gYmUgZGVmaW5lZC5cbiAgICogVGhpcyBlbmQgaXMgdGhlIHNpemUgb2YgdGhlIE1hdHJpeCBpbiBjdXJyZW50IGRpbWVuc2lvbi5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIFJhbmdlTm9kZS5wcm90b3R5cGUubmVlZHNFbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gZmluZCBhbGwgYGVuZGAgc3ltYm9scyBpbiB0aGlzIFJhbmdlTm9kZVxuICAgIHZhciBlbmRTeW1ib2xzID0gdGhpcy5maWx0ZXIoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiAobm9kZSAmJiBub2RlLmlzU3ltYm9sTm9kZSkgJiYgKG5vZGUubmFtZSA9PSAnZW5kJyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZW5kU3ltYm9scy5sZW5ndGggPiAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb21waWxlIHRoZSBub2RlIHRvIGphdmFzY3JpcHQgY29kZVxuICAgKlxuICAgKiBXaGVuIHRoZSByYW5nZSBoYXMgYSBzeW1ib2wgYGVuZGAgZGVmaW5lZCwgdGhlIFJhbmdlTm9kZSByZXF1aXJlc1xuICAgKiBhIHZhcmlhYmxlIGBlbmRgIHRvIGJlIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgY2xvc3VyZSwgd2hpY2ggbXVzdCBjb250YWluXG4gICAqIHRoZSBsZW5ndGggb2YgdGhlIG9mIHRoZSBtYXRyaXggdGhhdCdzIGJlaW5nIGhhbmRsZWQgaW4gdGhlIHJhbmdlJ3NcbiAgICogZGltZW5zaW9uLiBUbyBjaGVjayB3aGV0aGVyIHRoZSBgZW5kYCB2YXJpYWJsZSBpcyBuZWVkZWQsIGNhbGxcbiAgICogUmFuZ2VOb2RlLm5lZWRzRW5kKCkuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkZWZzICAgICBPYmplY3Qgd2hpY2ggY2FuIGJlIHVzZWQgdG8gZGVmaW5lIGZ1bmN0aW9uc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgb3IgY29uc3RhbnRzIGdsb2JhbGx5IGF2YWlsYWJsZSBmb3IgdGhlIGNvbXBpbGVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzICAgICBPYmplY3Qgd2l0aCBsb2NhbCBmdW5jdGlvbiBhcmd1bWVudHMsIHRoZSBrZXkgaXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBuYW1lIG9mIHRoZSBhcmd1bWVudCwgYW5kIHRoZSB2YWx1ZSBpcyBgdHJ1ZWAuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgb2JqZWN0IG1heSBub3QgYmUgbXV0YXRlZCwgYnV0IG11c3QgYmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuZGVkIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge3N0cmluZ30ganNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFJhbmdlTm9kZS5wcm90b3R5cGUuX2NvbXBpbGUgPSBmdW5jdGlvbiAoZGVmcywgYXJncykge1xuICAgIHJldHVybiAnbWF0aC5yYW5nZSgnICtcbiAgICAgICAgdGhpcy5zdGFydC5fY29tcGlsZShkZWZzLCBhcmdzKSArICcsICcgK1xuICAgICAgICB0aGlzLmVuZC5fY29tcGlsZShkZWZzLCBhcmdzKSArXG4gICAgICAgICh0aGlzLnN0ZXAgPyAoJywgJyArIHRoaXMuc3RlcC5fY29tcGlsZShkZWZzLCBhcmdzKSkgOiAnJykgK1xuICAgICAgICAnKSc7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZWFjaCBvZiB0aGUgY2hpbGQgbm9kZXMgb2YgdGhpcyBub2RlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oY2hpbGQ6IE5vZGUsIHBhdGg6IHN0cmluZywgcGFyZW50OiBOb2RlKX0gY2FsbGJhY2tcbiAgICovXG4gIFJhbmdlTm9kZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKHRoaXMuc3RhcnQsICdzdGFydCcsIHRoaXMpO1xuICAgIGNhbGxiYWNrKHRoaXMuZW5kLCAnZW5kJywgdGhpcyk7XG4gICAgaWYgKHRoaXMuc3RlcCkge1xuICAgICAgY2FsbGJhY2sodGhpcy5zdGVwLCAnc3RlcCcsIHRoaXMpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFJhbmdlTm9kZSBoYXZpbmcgaXQncyBjaGlsZHMgYmUgdGhlIHJlc3VsdHMgb2YgY2FsbGluZ1xuICAgKiB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIGVhY2ggb2YgdGhlIGNoaWxkcyBvZiB0aGUgb3JpZ2luYWwgbm9kZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihjaGlsZDogTm9kZSwgcGF0aDogc3RyaW5nLCBwYXJlbnQ6IE5vZGUpOiBOb2RlfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7UmFuZ2VOb2RlfSBSZXR1cm5zIGEgdHJhbnNmb3JtZWQgY29weSBvZiB0aGUgbm9kZVxuICAgKi9cbiAgUmFuZ2VOb2RlLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gbmV3IFJhbmdlTm9kZShcbiAgICAgICAgdGhpcy5faWZOb2RlKGNhbGxiYWNrKHRoaXMuc3RhcnQsICdzdGFydCcsIHRoaXMpKSxcbiAgICAgICAgdGhpcy5faWZOb2RlKGNhbGxiYWNrKHRoaXMuZW5kLCAnZW5kJywgdGhpcykpLFxuICAgICAgICB0aGlzLnN0ZXAgJiYgdGhpcy5faWZOb2RlKGNhbGxiYWNrKHRoaXMuc3RlcCwgJ3N0ZXAnLCB0aGlzKSlcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBjbG9uZSBvZiB0aGlzIG5vZGUsIGEgc2hhbGxvdyBjb3B5XG4gICAqIEByZXR1cm4ge1JhbmdlTm9kZX1cbiAgICovXG4gIFJhbmdlTm9kZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBSYW5nZU5vZGUodGhpcy5zdGFydCwgdGhpcy5lbmQsIHRoaXMuc3RlcCAmJiB0aGlzLnN0ZXApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIG5lY2Vzc2FyeSBwYXJlbnRoZXNlc1xuICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmVudGhlc2lzXG4gICAqIEByZXR1cm4ge09iamVjdH0gcGFyZW50aGVzZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGNhbGN1bGF0ZU5lY2Vzc2FyeVBhcmVudGhlc2VzKG5vZGUsIHBhcmVudGhlc2lzKSB7XG4gICAgdmFyIHByZWNlZGVuY2UgPSBvcGVyYXRvcnMuZ2V0UHJlY2VkZW5jZShub2RlLCBwYXJlbnRoZXNpcyk7XG4gICAgdmFyIHBhcmVucyA9IHt9O1xuXG4gICAgdmFyIHN0YXJ0UHJlY2VkZW5jZSA9IG9wZXJhdG9ycy5nZXRQcmVjZWRlbmNlKG5vZGUuc3RhcnQsIHBhcmVudGhlc2lzKTtcbiAgICBwYXJlbnMuc3RhcnQgPSAoKHN0YXJ0UHJlY2VkZW5jZSAhPT0gbnVsbCkgJiYgKHN0YXJ0UHJlY2VkZW5jZSA8PSBwcmVjZWRlbmNlKSlcbiAgICAgIHx8IChwYXJlbnRoZXNpcyA9PT0gJ2FsbCcpO1xuXG4gICAgaWYgKG5vZGUuc3RlcCkge1xuICAgICAgdmFyIHN0ZXBQcmVjZWRlbmNlID0gb3BlcmF0b3JzLmdldFByZWNlZGVuY2Uobm9kZS5zdGVwLCBwYXJlbnRoZXNpcyk7XG4gICAgICBwYXJlbnMuc3RlcCA9ICgoc3RlcFByZWNlZGVuY2UgIT09IG51bGwpICYmIChzdGVwUHJlY2VkZW5jZSA8PSBwcmVjZWRlbmNlKSlcbiAgICAgICAgfHwgKHBhcmVudGhlc2lzID09PSAnYWxsJyk7XG4gICAgfVxuXG4gICAgdmFyIGVuZFByZWNlZGVuY2UgPSBvcGVyYXRvcnMuZ2V0UHJlY2VkZW5jZShub2RlLmVuZCwgcGFyZW50aGVzaXMpO1xuICAgIHBhcmVucy5lbmQgPSAoKGVuZFByZWNlZGVuY2UgIT09IG51bGwpICYmIChlbmRQcmVjZWRlbmNlIDw9IHByZWNlZGVuY2UpKVxuICAgICAgfHwgKHBhcmVudGhlc2lzID09PSAnYWxsJyk7XG5cbiAgICByZXR1cm4gcGFyZW5zO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7c3RyaW5nfSBzdHJcbiAgICovXG4gIFJhbmdlTm9kZS5wcm90b3R5cGUuX3RvU3RyaW5nID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgcGFyZW50aGVzaXMgPSAob3B0aW9ucyAmJiBvcHRpb25zLnBhcmVudGhlc2lzKSA/IG9wdGlvbnMucGFyZW50aGVzaXMgOiAna2VlcCc7XG4gICAgdmFyIHBhcmVucyA9IGNhbGN1bGF0ZU5lY2Vzc2FyeVBhcmVudGhlc2VzKHRoaXMsIHBhcmVudGhlc2lzKTtcblxuICAgIC8vZm9ybWF0IHN0cmluZyBhcyBzdGFydDpzdGVwOnN0b3BcbiAgICB2YXIgc3RyO1xuXG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5zdGFydC50b1N0cmluZyhvcHRpb25zKTtcbiAgICBpZiAocGFyZW5zLnN0YXJ0KSB7XG4gICAgICBzdGFydCA9ICcoJyArIHN0YXJ0ICsgJyknO1xuICAgIH1cbiAgICBzdHIgPSBzdGFydDtcblxuICAgIGlmICh0aGlzLnN0ZXApIHtcbiAgICAgIHZhciBzdGVwID0gdGhpcy5zdGVwLnRvU3RyaW5nKG9wdGlvbnMpO1xuICAgICAgaWYgKHBhcmVucy5zdGVwKSB7XG4gICAgICAgIHN0ZXAgPSAnKCcgKyBzdGVwICsgJyknO1xuICAgICAgfVxuICAgICAgc3RyICs9ICc6JyArIHN0ZXA7XG4gICAgfVxuXG4gICAgdmFyIGVuZCA9IHRoaXMuZW5kLnRvU3RyaW5nKG9wdGlvbnMpO1xuICAgIGlmIChwYXJlbnMuZW5kKSB7XG4gICAgICBlbmQgPSAnKCcgKyBlbmQgKyAnKSc7XG4gICAgfVxuICAgIHN0ciArPSAnOicgKyBlbmQ7XG5cbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgTGFUZVggcmVwcmVzZW50YXRpb25cbiAgICogQHBhcmFtcyB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge3N0cmluZ30gc3RyXG4gICAqL1xuICBSYW5nZU5vZGUucHJvdG90eXBlLl90b1RleCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIHBhcmVudGhlc2lzID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5wYXJlbnRoZXNpcykgPyBvcHRpb25zLnBhcmVudGhlc2lzIDogJ2tlZXAnO1xuICAgIHZhciBwYXJlbnMgPSBjYWxjdWxhdGVOZWNlc3NhcnlQYXJlbnRoZXNlcyh0aGlzLCBwYXJlbnRoZXNpcyk7XG5cbiAgICB2YXIgc3RyID0gdGhpcy5zdGFydC50b1RleChvcHRpb25zKTtcbiAgICBpZiAocGFyZW5zLnN0YXJ0KSB7XG4gICAgICBzdHIgPSAnXFxcXGxlZnQoJyArIHN0ciArICdcXFxccmlnaHQpJztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdGVwKSB7XG4gICAgICB2YXIgc3RlcCA9IHRoaXMuc3RlcC50b1RleChvcHRpb25zKTtcbiAgICAgIGlmIChwYXJlbnMuc3RlcCkge1xuICAgICAgICBzdGVwID0gJ1xcXFxsZWZ0KCcgKyBzdGVwICsgJ1xcXFxyaWdodCknO1xuICAgICAgfVxuICAgICAgc3RyICs9ICc6JyArIHN0ZXA7XG4gICAgfVxuXG4gICAgdmFyIGVuZCA9IHRoaXMuZW5kLnRvVGV4KG9wdGlvbnMpO1xuICAgIGlmIChwYXJlbnMuZW5kKSB7XG4gICAgICBlbmQgPSAnXFxcXGxlZnQoJyArIGVuZCArICdcXFxccmlnaHQpJztcbiAgICB9XG4gICAgc3RyICs9ICc6JyArIGVuZDtcblxuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgcmV0dXJuIFJhbmdlTm9kZTtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ1JhbmdlTm9kZSc7XG5leHBvcnRzLnBhdGggPSAnZXhwcmVzc2lvbi5ub2RlJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBsYXRleCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2xhdGV4Jyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQsIG1hdGgpIHtcbiAgdmFyIE5vZGUgPSBsb2FkKHJlcXVpcmUoJy4vTm9kZScpKTtcblxuICB2YXIgVW5pdCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS91bml0L1VuaXQnKSk7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvciBTeW1ib2xOb2RlXG4gICAqIEBleHRlbmRzIHtOb2RlfVxuICAgKiBBIHN5bWJvbCBub2RlIGNhbiBob2xkIGFuZCByZXNvbHZlIGEgc3ltYm9sXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBleHRlbmRzIHtOb2RlfVxuICAgKi9cbiAgZnVuY3Rpb24gU3ltYm9sTm9kZShuYW1lKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFN5bWJvbE5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0NvbnN0cnVjdG9yIG11c3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBvcGVyYXRvcicpO1xuICAgIH1cblxuICAgIC8vIHZhbGlkYXRlIGlucHV0XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1N0cmluZyBleHBlY3RlZCBmb3IgcGFyYW1ldGVyIFwibmFtZVwiJyk7XG5cbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICB9XG5cbiAgU3ltYm9sTm9kZS5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuXG4gIFN5bWJvbE5vZGUucHJvdG90eXBlLnR5cGUgPSAnU3ltYm9sTm9kZSc7XG5cbiAgU3ltYm9sTm9kZS5wcm90b3R5cGUuaXNTeW1ib2xOb2RlID0gdHJ1ZTtcblxuICAvKipcbiAgICogQ29tcGlsZSB0aGUgbm9kZSB0byBqYXZhc2NyaXB0IGNvZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlZnMgICAgIE9iamVjdCB3aGljaCBjYW4gYmUgdXNlZCB0byBkZWZpbmUgZnVuY3Rpb25zXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBvciBjb25zdGFudHMgZ2xvYmFsbHkgYXZhaWxhYmxlIGZvciB0aGUgY29tcGlsZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgICAgIE9iamVjdCB3aXRoIGxvY2FsIGZ1bmN0aW9uIGFyZ3VtZW50cywgdGhlIGtleSBpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG5hbWUgb2YgdGhlIGFyZ3VtZW50LCBhbmQgdGhlIHZhbHVlIGlzIGB0cnVlYC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBvYmplY3QgbWF5IG5vdCBiZSBtdXRhdGVkLCBidXQgbXVzdCBiZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kZWQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7c3RyaW5nfSBqc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgU3ltYm9sTm9kZS5wcm90b3R5cGUuX2NvbXBpbGUgPSBmdW5jdGlvbiAoZGVmcywgYXJncykge1xuICAgIC8vIGFkZCBhIGZ1bmN0aW9uIHRvIHRoZSBkZWZpbml0aW9uc1xuICAgIGRlZnNbJ3VuZGVmJ10gPSB1bmRlZjtcbiAgICBkZWZzWydVbml0J10gPSBVbml0O1xuXG4gICAgaWYgKGFyZ3NbdGhpcy5uYW1lXSkge1xuICAgICAgLy8gdGhpcyBpcyBhIEZ1bmN0aW9uQXNzaWdubWVudCBhcmd1bWVudFxuICAgICAgLy8gKGxpa2UgYW4geCB3aGVuIGluc2lkZSB0aGUgZXhwcmVzc2lvbiBvZiBhIGZ1bmN0aW9uIGFzc2lnbm1lbnQgYGYoeCkgPSAuLi5gKVxuICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5uYW1lIGluIGRlZnMubWF0aCkge1xuICAgICAgcmV0dXJuICcoXCInICsgdGhpcy5uYW1lICsgJ1wiIGluIHNjb3BlID8gc2NvcGVbXCInICsgdGhpcy5uYW1lICsgJ1wiXSA6IG1hdGhbXCInICsgdGhpcy5uYW1lICsgJ1wiXSknO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiAnKCcgK1xuICAgICAgICAgICdcIicgKyB0aGlzLm5hbWUgKyAnXCIgaW4gc2NvcGUgPyBzY29wZVtcIicgKyB0aGlzLm5hbWUgKyAnXCJdIDogJyArXG4gICAgICAgICAgKFVuaXQuaXNWYWx1ZWxlc3NVbml0KHRoaXMubmFtZSkgP1xuICAgICAgICAgICduZXcgVW5pdChudWxsLCBcIicgKyB0aGlzLm5hbWUgKyAnXCIpJyA6XG4gICAgICAgICAgJ3VuZGVmKFwiJyArIHRoaXMubmFtZSArICdcIiknKSArXG4gICAgICAgICAgJyknO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBlYWNoIG9mIHRoZSBjaGlsZCBub2RlcyBvZiB0aGlzIG5vZGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbihjaGlsZDogTm9kZSwgcGF0aDogc3RyaW5nLCBwYXJlbnQ6IE5vZGUpfSBjYWxsYmFja1xuICAgKi9cbiAgU3ltYm9sTm9kZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIC8vIG5vdGhpbmcgdG8gZG8sIHdlIGRvbid0IGhhdmUgY2hpbGRzXG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBTeW1ib2xOb2RlIGhhdmluZyBpdCdzIGNoaWxkcyBiZSB0aGUgcmVzdWx0cyBvZiBjYWxsaW5nXG4gICAqIHRoZSBwcm92aWRlZCBjYWxsYmFjayBmdW5jdGlvbiBmb3IgZWFjaCBvZiB0aGUgY2hpbGRzIG9mIHRoZSBvcmlnaW5hbCBub2RlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGNoaWxkOiBOb2RlLCBwYXRoOiBzdHJpbmcsIHBhcmVudDogTm9kZSkgOiBOb2RlfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7U3ltYm9sTm9kZX0gUmV0dXJucyBhIGNsb25lIG9mIHRoZSBub2RlXG4gICAqL1xuICBTeW1ib2xOb2RlLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaHJvd3MgYW4gZXJyb3IgJ1VuZGVmaW5lZCBzeW1ib2wge25hbWV9J1xuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKi9cbiAgZnVuY3Rpb24gdW5kZWYgKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZGVmaW5lZCBzeW1ib2wgJyArIG5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGNsb25lIG9mIHRoaXMgbm9kZSwgYSBzaGFsbG93IGNvcHlcbiAgICogQHJldHVybiB7U3ltYm9sTm9kZX1cbiAgICovXG4gIFN5bWJvbE5vZGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBTeW1ib2xOb2RlKHRoaXMubmFtZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7c3RyaW5nfSBzdHJcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBTeW1ib2xOb2RlLnByb3RvdHlwZS5fdG9TdHJpbmcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IExhVGVYIHJlcHJlc2VudGF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge3N0cmluZ30gc3RyXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgU3ltYm9sTm9kZS5wcm90b3R5cGUuX3RvVGV4ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBpc1VuaXQgPSBmYWxzZTtcbiAgICBpZiAoKHR5cGVvZiBtYXRoW3RoaXMubmFtZV0gPT09ICd1bmRlZmluZWQnKSAmJiBVbml0LmlzVmFsdWVsZXNzVW5pdCh0aGlzLm5hbWUpKSB7XG4gICAgICBpc1VuaXQgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgc3ltYm9sID0gbGF0ZXgudG9TeW1ib2wodGhpcy5uYW1lLCBpc1VuaXQpO1xuICAgIGlmIChzeW1ib2xbMF0gPT09ICdcXFxcJykge1xuICAgICAgLy9ubyBzcGFjZSBuZWVkZWQgaWYgdGhlIHN5bWJvbCBzdGFydHMgd2l0aCAnXFwnXG4gICAgICByZXR1cm4gc3ltYm9sO1xuICAgIH1cbiAgICAvL3RoZSBzcGFjZSBwcmV2ZW50cyBzeW1ib2xzIGZyb20gYnJlYWtpbmcgc3R1ZmYgbGlrZSAnXFxjZG90JyBpZiBpdCdzIHdyaXR0ZW4gcmlnaHQgYmVmb3JlIHRoZSBzeW1ib2xcbiAgICByZXR1cm4gJyAnICsgc3ltYm9sO1xuICB9O1xuXG4gIHJldHVybiBTeW1ib2xOb2RlO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnU3ltYm9sTm9kZSc7XG5leHBvcnRzLnBhdGggPSAnZXhwcmVzc2lvbi5ub2RlJztcbmV4cG9ydHMubWF0aCA9IHRydWU7IC8vIHJlcXVlc3QgYWNjZXNzIHRvIHRoZSBtYXRoIG5hbWVzcGFjZSBhcyA1dGggYXJndW1lbnQgb2YgdGhlIGZhY3RvcnkgZnVuY3Rpb25cbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvciBVcGRhdGVOb2RlXG4gICAqL1xuICBmdW5jdGlvbiBVcGRhdGVOb2RlKCkge1xuICAgIC8vIFRPRE86IGRlcHJlY2F0ZWQgc2luY2UgdjMuIENsZWFudXAgc29tZSBkYXlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VwZGF0ZU5vZGUgaXMgZGVwcmVjYXRlZC4gVXNlIEFzc2lnbm1lbnROb2RlIGluc3RlYWQuJyk7XG4gIH1cblxuICByZXR1cm4gVXBkYXRlTm9kZTtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ1VwZGF0ZU5vZGUnO1xuZXhwb3J0cy5wYXRoID0gJ2V4cHJlc3Npb24ubm9kZSc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBbXG4gIHJlcXVpcmUoJy4vQWNjZXNzb3JOb2RlJyksXG4gIHJlcXVpcmUoJy4vQXJyYXlOb2RlJyksXG4gIHJlcXVpcmUoJy4vQXNzaWdubWVudE5vZGUnKSxcbiAgcmVxdWlyZSgnLi9CbG9ja05vZGUnKSxcbiAgcmVxdWlyZSgnLi9Db25kaXRpb25hbE5vZGUnKSxcbiAgcmVxdWlyZSgnLi9Db25zdGFudE5vZGUnKSxcbiAgcmVxdWlyZSgnLi9JbmRleE5vZGUnKSxcbiAgcmVxdWlyZSgnLi9GdW5jdGlvbkFzc2lnbm1lbnROb2RlJyksXG4gIHJlcXVpcmUoJy4vRnVuY3Rpb25Ob2RlJyksXG4gIHJlcXVpcmUoJy4vTm9kZScpLFxuICByZXF1aXJlKCcuL09iamVjdE5vZGUnKSxcbiAgcmVxdWlyZSgnLi9PcGVyYXRvck5vZGUnKSxcbiAgcmVxdWlyZSgnLi9QYXJlbnRoZXNpc05vZGUnKSxcbiAgcmVxdWlyZSgnLi9SYW5nZU5vZGUnKSxcbiAgcmVxdWlyZSgnLi9TeW1ib2xOb2RlJyksXG4gIHJlcXVpcmUoJy4vVXBkYXRlTm9kZScpXG5dO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXJyb3JUcmFuc2Zvcm0gPSByZXF1aXJlKCcuLi8uLi90cmFuc2Zvcm0vZXJyb3IudHJhbnNmb3JtJykudHJhbnNmb3JtO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBzdWJzZXQgPSBsb2FkKHJlcXVpcmUoJy4uLy4uLy4uL2Z1bmN0aW9uL21hdHJpeC9zdWJzZXQnKSk7XG4gIHZhciBtYXRyaXggPSBsb2FkKHJlcXVpcmUoJy4uLy4uLy4uL3R5cGUvbWF0cml4L2Z1bmN0aW9uL21hdHJpeCcpKTtcblxuICAvKipcbiAgICogUmV0cmlldmUgcGFydCBvZiBhbiBvYmplY3Q6XG4gICAqXG4gICAqIC0gUmV0cmlldmUgYSBwcm9wZXJ0eSBmcm9tIGFuIG9iamVjdFxuICAgKiAtIFJldHJpZXZlIGEgcGFydCBvZiBhIHN0cmluZ1xuICAgKiAtIFJldHJpZXZlIGEgbWF0cml4IHN1YnNldFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdCB8IEFycmF5IHwgTWF0cml4IHwgc3RyaW5nfSBvYmplY3RcbiAgICogQHBhcmFtIHtJbmRleH0gaW5kZXhcbiAgICogQHJldHVybiB7T2JqZWN0IHwgQXJyYXkgfCBNYXRyaXggfCBzdHJpbmd9IFJldHVybnMgdGhlIHN1YnNldFxuICAgKi9cbiAgcmV0dXJuIGZ1bmN0aW9uIGFjY2VzcyhvYmplY3QsIGluZGV4KSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG1hdHJpeChvYmplY3QpLnN1YnNldChpbmRleCkudmFsdWVPZigpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob2JqZWN0ICYmIHR5cGVvZiBvYmplY3Quc3Vic2V0ID09PSAnZnVuY3Rpb24nKSB7IC8vIE1hdHJpeFxuICAgICAgICByZXR1cm4gb2JqZWN0LnN1YnNldChpbmRleCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBUT0RPOiBtb3ZlIGdldFN0cmluZ1N1YnNldCBpbnRvIGEgc2VwYXJhdGUgdXRpbCBmaWxlLCB1c2UgdGhhdFxuICAgICAgICByZXR1cm4gc3Vic2V0KG9iamVjdCwgaW5kZXgpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKCFpbmRleC5pc09iamVjdFByb3BlcnR5KCkpIHtcbiAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ0Nhbm5vdCBhcHBseSBhIG51bWVyaWMgaW5kZXggYXMgb2JqZWN0IHByb3BlcnR5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdFtpbmRleC5nZXRPYmplY3RQcm9wZXJ0eSgpXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgYXBwbHkgaW5kZXg6IHVuc3VwcG9ydGVkIHR5cGUgb2Ygb2JqZWN0Jyk7XG4gICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IGVycm9yVHJhbnNmb3JtKGVycik7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBlcnJvclRyYW5zZm9ybSA9IHJlcXVpcmUoJy4uLy4uL3RyYW5zZm9ybS9lcnJvci50cmFuc2Zvcm0nKS50cmFuc2Zvcm07XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIHN1YnNldCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vLi4vZnVuY3Rpb24vbWF0cml4L3N1YnNldCcpKTtcbiAgdmFyIG1hdHJpeCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vLi4vdHlwZS9tYXRyaXgvZnVuY3Rpb24vbWF0cml4JykpO1xuXG4gIC8qKlxuICAgKiBSZXBsYWNlIHBhcnQgb2YgYW4gb2JqZWN0OlxuICAgKlxuICAgKiAtIEFzc2lnbiBhIHByb3BlcnR5IHRvIGFuIG9iamVjdFxuICAgKiAtIFJlcGxhY2UgYSBwYXJ0IG9mIGEgc3RyaW5nXG4gICAqIC0gUmVwbGFjZSBhIG1hdHJpeCBzdWJzZXRcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3QgfCBBcnJheSB8IE1hdHJpeCB8IHN0cmluZ30gb2JqZWN0XG4gICAqIEBwYXJhbSB7SW5kZXh9IGluZGV4XG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHJldHVybiB7T2JqZWN0IHwgQXJyYXkgfCBNYXRyaXggfCBzdHJpbmd9IFJldHVybnMgdGhlIG9yaWdpbmFsIG9iamVjdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhjZXB0IGluIGNhc2Ugb2YgYSBzdHJpbmdcbiAgICovXG4gIHJldHVybiBmdW5jdGlvbiBhc3NpZ24ob2JqZWN0LCBpbmRleCwgdmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gbWF0cml4KG9iamVjdCkuc3Vic2V0KGluZGV4LCB2YWx1ZSkudmFsdWVPZigpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob2JqZWN0ICYmIHR5cGVvZiBvYmplY3Quc3Vic2V0ID09PSAnZnVuY3Rpb24nKSB7IC8vIE1hdHJpeFxuICAgICAgICByZXR1cm4gb2JqZWN0LnN1YnNldChpbmRleCwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gVE9ETzogbW92ZSBzZXRTdHJpbmdTdWJzZXQgaW50byBhIHNlcGFyYXRlIHV0aWwgZmlsZSwgdXNlIHRoYXRcbiAgICAgICAgcmV0dXJuIHN1YnNldChvYmplY3QsIGluZGV4LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoIWluZGV4LmlzT2JqZWN0UHJvcGVydHkoKSkge1xuICAgICAgICAgIHRocm93IFR5cGVFcnJvcignQ2Fubm90IGFwcGx5IGEgbnVtZXJpYyBpbmRleCBhcyBvYmplY3QgcHJvcGVydHknKTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3RbaW5kZXguZ2V0T2JqZWN0UHJvcGVydHkoKV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgYXBwbHkgaW5kZXg6IHVuc3VwcG9ydGVkIHR5cGUgb2Ygb2JqZWN0Jyk7XG4gICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgZXJyb3JUcmFuc2Zvcm0oZXJyKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0J1xuXG4vL2xpc3Qgb2YgaWRlbnRpZmllcnMgb2Ygbm9kZXMgaW4gb3JkZXIgb2YgdGhlaXIgcHJlY2VkZW5jZVxuLy9hbHNvIGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IGxlZnQvcmlnaHQgYXNzb2NpYXRpdml0eVxuLy9hbmQgd2hpY2ggb3RoZXIgb3BlcmF0b3IgdGhlIG9wZXJhdG9yIGlzIGFzc29jaWF0aXZlIHdpdGhcbi8vRXhhbXBsZTpcbi8vIGFkZGl0aW9uIGlzIGFzc29jaWF0aXZlIHdpdGggYWRkaXRpb24gYW5kIHN1YnRyYWN0aW9uLCBiZWNhdXNlOlxuLy8gKGErYikrYz1hKyhiK2MpXG4vLyAoYStiKS1jPWErKGItYylcbi8vXG4vLyBwb3N0Zml4IG9wZXJhdG9ycyBhcmUgbGVmdCBhc3NvY2lhdGl2ZSwgcHJlZml4IG9wZXJhdG9ycyBcbi8vIGFyZSByaWdodCBhc3NvY2lhdGl2ZVxuLy9cbi8vSXQncyBhbHNvIHBvc3NpYmxlIHRvIHNldCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4vLyBsYXRleFBhcmVuczogaWYgc2V0IHRvIGZhbHNlLCB0aGlzIG5vZGUgZG9lc24ndCBuZWVkIHRvIGJlIGVuY2xvc2VkXG4vLyAgICAgICAgICAgICAgaW4gcGFyZW50aGVzZXMgd2hlbiB1c2luZyBMYVRlWFxuLy8gbGF0ZXhMZWZ0UGFyZW5zOiBpZiBzZXQgdG8gZmFsc2UsIHRoaXMgIU9wZXJhdG9yTm9kZSdzISBcbi8vICAgICAgICAgICAgICAgICAgbGVmdCBhcmd1bWVudCBkb2Vzbid0IG5lZWQgdG8gYmUgZW5jbG9zZWRcbi8vICAgICAgICAgICAgICAgICAgaW4gcGFyZW50aGVzZXNcbi8vIGxhdGV4UmlnaHRQYXJlbnM6IHRoZSBzYW1lIGZvciB0aGUgcmlnaHQgYXJndW1lbnRcbnZhciBwcm9wZXJ0aWVzID0gW1xuICB7IC8vYXNzaWdubWVudFxuICAgICdBc3NpZ25tZW50Tm9kZSc6IHt9LFxuICAgICdGdW5jdGlvbkFzc2lnbm1lbnROb2RlJzoge31cbiAgfSxcbiAgeyAvL2NvbmRpdGlvbmFsIGV4cHJlc3Npb25cbiAgICAnQ29uZGl0aW9uYWxOb2RlJzoge1xuICAgICAgbGF0ZXhMZWZ0UGFyZW5zOiBmYWxzZSxcbiAgICAgIGxhdGV4UmlnaHRQYXJlbnM6IGZhbHNlLFxuICAgICAgbGF0ZXhQYXJlbnM6IGZhbHNlXG4gICAgICAvL2NvbmRpdGlvbmFscyBkb24ndCBuZWVkIHBhcmVudGhlc2VzIGluIExhVGVYIGJlY2F1c2VcbiAgICAgIC8vdGhleSBhcmUgMiBkaW1lbnNpb25hbFxuICAgIH1cbiAgfSxcbiAgeyAvL2xvZ2ljYWwgb3JcbiAgICAnT3BlcmF0b3JOb2RlOm9yJzoge1xuICAgICAgYXNzb2NpYXRpdml0eTogJ2xlZnQnLFxuICAgICAgYXNzb2NpYXRpdmVXaXRoOiBbXVxuICAgIH1cblxuICB9LFxuICB7IC8vbG9naWNhbCB4b3JcbiAgICAnT3BlcmF0b3JOb2RlOnhvcic6IHtcbiAgICAgIGFzc29jaWF0aXZpdHk6ICdsZWZ0JyxcbiAgICAgIGFzc29jaWF0aXZlV2l0aDogW11cbiAgICB9XG4gIH0sXG4gIHsgLy9sb2dpY2FsIGFuZFxuICAgICdPcGVyYXRvck5vZGU6YW5kJzoge1xuICAgICAgYXNzb2NpYXRpdml0eTogJ2xlZnQnLFxuICAgICAgYXNzb2NpYXRpdmVXaXRoOiBbXVxuICAgIH1cbiAgfSxcbiAgeyAvL2JpdHdpc2Ugb3JcbiAgICAnT3BlcmF0b3JOb2RlOmJpdE9yJzoge1xuICAgICAgYXNzb2NpYXRpdml0eTogJ2xlZnQnLFxuICAgICAgYXNzb2NpYXRpdmVXaXRoOiBbXVxuICAgIH1cbiAgfSxcbiAgeyAvL2JpdHdpc2UgeG9yXG4gICAgJ09wZXJhdG9yTm9kZTpiaXRYb3InOiB7XG4gICAgICBhc3NvY2lhdGl2aXR5OiAnbGVmdCcsXG4gICAgICBhc3NvY2lhdGl2ZVdpdGg6IFtdXG4gICAgfVxuICB9LFxuICB7IC8vYml0d2lzZSBhbmRcbiAgICAnT3BlcmF0b3JOb2RlOmJpdEFuZCc6IHtcbiAgICAgIGFzc29jaWF0aXZpdHk6ICdsZWZ0JyxcbiAgICAgIGFzc29jaWF0aXZlV2l0aDogW11cbiAgICB9XG4gIH0sXG4gIHsgLy9yZWxhdGlvbmFsIG9wZXJhdG9yc1xuICAgICdPcGVyYXRvck5vZGU6ZXF1YWwnOiB7XG4gICAgICBhc3NvY2lhdGl2aXR5OiAnbGVmdCcsXG4gICAgICBhc3NvY2lhdGl2ZVdpdGg6IFtdXG4gICAgfSxcbiAgICAnT3BlcmF0b3JOb2RlOnVuZXF1YWwnOiB7XG4gICAgICBhc3NvY2lhdGl2aXR5OiAnbGVmdCcsXG4gICAgICBhc3NvY2lhdGl2ZVdpdGg6IFtdXG4gICAgfSxcbiAgICAnT3BlcmF0b3JOb2RlOnNtYWxsZXInOiB7XG4gICAgICBhc3NvY2lhdGl2aXR5OiAnbGVmdCcsXG4gICAgICBhc3NvY2lhdGl2ZVdpdGg6IFtdXG4gICAgfSxcbiAgICAnT3BlcmF0b3JOb2RlOmxhcmdlcic6IHtcbiAgICAgIGFzc29jaWF0aXZpdHk6ICdsZWZ0JyxcbiAgICAgIGFzc29jaWF0aXZlV2l0aDogW11cbiAgICB9LFxuICAgICdPcGVyYXRvck5vZGU6c21hbGxlckVxJzoge1xuICAgICAgYXNzb2NpYXRpdml0eTogJ2xlZnQnLFxuICAgICAgYXNzb2NpYXRpdmVXaXRoOiBbXVxuICAgIH0sXG4gICAgJ09wZXJhdG9yTm9kZTpsYXJnZXJFcSc6IHtcbiAgICAgIGFzc29jaWF0aXZpdHk6ICdsZWZ0JyxcbiAgICAgIGFzc29jaWF0aXZlV2l0aDogW11cbiAgICB9XG4gIH0sXG4gIHsgLy9iaXRzaGlmdCBvcGVyYXRvcnNcbiAgICAnT3BlcmF0b3JOb2RlOmxlZnRTaGlmdCc6IHtcbiAgICAgIGFzc29jaWF0aXZpdHk6ICdsZWZ0JyxcbiAgICAgIGFzc29jaWF0aXZlV2l0aDogW11cbiAgICB9LFxuICAgICdPcGVyYXRvck5vZGU6cmlnaHRBcml0aFNoaWZ0Jzoge1xuICAgICAgYXNzb2NpYXRpdml0eTogJ2xlZnQnLFxuICAgICAgYXNzb2NpYXRpdmVXaXRoOiBbXVxuICAgIH0sXG4gICAgJ09wZXJhdG9yTm9kZTpyaWdodExvZ1NoaWZ0Jzoge1xuICAgICAgYXNzb2NpYXRpdml0eTogJ2xlZnQnLFxuICAgICAgYXNzb2NpYXRpdmVXaXRoOiBbXVxuICAgIH1cbiAgfSxcbiAgeyAvL3VuaXQgY29udmVyc2lvblxuICAgICdPcGVyYXRvck5vZGU6dG8nOiB7XG4gICAgICBhc3NvY2lhdGl2aXR5OiAnbGVmdCcsXG4gICAgICBhc3NvY2lhdGl2ZVdpdGg6IFtdXG4gICAgfVxuICB9LFxuICB7IC8vcmFuZ2VcbiAgICAnUmFuZ2VOb2RlJzoge31cbiAgfSxcbiAgeyAvL2FkZGl0aW9uLCBzdWJ0cmFjdGlvblxuICAgICdPcGVyYXRvck5vZGU6YWRkJzoge1xuICAgICAgYXNzb2NpYXRpdml0eTogJ2xlZnQnLFxuICAgICAgYXNzb2NpYXRpdmVXaXRoOiBbJ09wZXJhdG9yTm9kZTphZGQnLCAnT3BlcmF0b3JOb2RlOnN1YnRyYWN0J11cbiAgICB9LFxuICAgICdPcGVyYXRvck5vZGU6c3VidHJhY3QnOiB7XG4gICAgICBhc3NvY2lhdGl2aXR5OiAnbGVmdCcsXG4gICAgICBhc3NvY2lhdGl2ZVdpdGg6IFtdXG4gICAgfVxuICB9LFxuICB7IC8vbXVsdGlwbHksIGRpdmlkZSwgbW9kdWx1c1xuICAgICdPcGVyYXRvck5vZGU6bXVsdGlwbHknOiB7XG4gICAgICBhc3NvY2lhdGl2aXR5OiAnbGVmdCcsXG4gICAgICBhc3NvY2lhdGl2ZVdpdGg6IFtcbiAgICAgICAgJ09wZXJhdG9yTm9kZTptdWx0aXBseScsXG4gICAgICAgICdPcGVyYXRvck5vZGU6ZGl2aWRlJyxcbiAgICAgICAgJ09wZXJhdG9yOmRvdE11bHRpcGx5JyxcbiAgICAgICAgJ09wZXJhdG9yOmRvdERpdmlkZSdcbiAgICAgIF1cbiAgICB9LFxuICAgICdPcGVyYXRvck5vZGU6ZGl2aWRlJzoge1xuICAgICAgYXNzb2NpYXRpdml0eTogJ2xlZnQnLFxuICAgICAgYXNzb2NpYXRpdmVXaXRoOiBbXSxcbiAgICAgIGxhdGV4TGVmdFBhcmVuczogZmFsc2UsXG4gICAgICBsYXRleFJpZ2h0UGFyZW5zOiBmYWxzZSxcbiAgICAgIGxhdGV4UGFyZW5zOiBmYWxzZVxuICAgICAgLy9mcmFjdGlvbnMgZG9uJ3QgcmVxdWlyZSBwYXJlbnRoZXNlcyBiZWNhdXNlXG4gICAgICAvL3RoZXkncmUgMiBkaW1lbnNpb25hbCwgc28gcGFyZW5zIGFyZW4ndCBuZWVkZWRcbiAgICAgIC8vaW4gTGFUZVhcbiAgICB9LFxuICAgICdPcGVyYXRvck5vZGU6ZG90TXVsdGlwbHknOiB7XG4gICAgICBhc3NvY2lhdGl2aXR5OiAnbGVmdCcsXG4gICAgICBhc3NvY2lhdGl2ZVdpdGg6IFtcbiAgICAgICAgJ09wZXJhdG9yTm9kZTptdWx0aXBseScsXG4gICAgICAgICdPcGVyYXRvck5vZGU6ZGl2aWRlJyxcbiAgICAgICAgJ09wZXJhdG9yTm9kZTpkb3RNdWx0aXBseScsXG4gICAgICAgICdPcGVyYXRvck5vZGU6ZG9EaXZpZGUnXG4gICAgICBdXG4gICAgfSxcbiAgICAnT3BlcmF0b3JOb2RlOmRvdERpdmlkZSc6IHtcbiAgICAgIGFzc29jaWF0aXZpdHk6ICdsZWZ0JyxcbiAgICAgIGFzc29jaWF0aXZlV2l0aDogW11cbiAgICB9LFxuICAgICdPcGVyYXRvck5vZGU6bW9kJzoge1xuICAgICAgYXNzb2NpYXRpdml0eTogJ2xlZnQnLFxuICAgICAgYXNzb2NpYXRpdmVXaXRoOiBbXVxuICAgIH1cbiAgfSxcbiAgeyAvL3VuYXJ5IHByZWZpeCBvcGVyYXRvcnNcbiAgICAnT3BlcmF0b3JOb2RlOnVuYXJ5UGx1cyc6IHtcbiAgICAgIGFzc29jaWF0aXZpdHk6ICdyaWdodCdcbiAgICB9LFxuICAgICdPcGVyYXRvck5vZGU6dW5hcnlNaW51cyc6IHtcbiAgICAgIGFzc29jaWF0aXZpdHk6ICdyaWdodCdcbiAgICB9LFxuICAgICdPcGVyYXRvck5vZGU6Yml0Tm90Jzoge1xuICAgICAgYXNzb2NpYXRpdml0eTogJ3JpZ2h0J1xuICAgIH0sXG4gICAgJ09wZXJhdG9yTm9kZTpub3QnOiB7XG4gICAgICBhc3NvY2lhdGl2aXR5OiAncmlnaHQnXG4gICAgfVxuICB9LFxuICB7IC8vZXhwb25lbnRpYXRpb25cbiAgICAnT3BlcmF0b3JOb2RlOnBvdyc6IHtcbiAgICAgIGFzc29jaWF0aXZpdHk6ICdyaWdodCcsXG4gICAgICBhc3NvY2lhdGl2ZVdpdGg6IFtdLFxuICAgICAgbGF0ZXhSaWdodFBhcmVuczogZmFsc2VcbiAgICAgIC8vdGhlIGV4cG9uZW50IGRvZXNuJ3QgbmVlZCBwYXJlbnRoZXNlcyBpblxuICAgICAgLy9MYVRlWCBiZWNhdXNlIGl0J3MgMiBkaW1lbnNpb25hbFxuICAgICAgLy8oaXQncyBvbiB0b3ApXG4gICAgfSxcbiAgICAnT3BlcmF0b3JOb2RlOmRvdFBvdyc6IHtcbiAgICAgIGFzc29jaWF0aXZpdHk6ICdyaWdodCcsXG4gICAgICBhc3NvY2lhdGl2ZVdpdGg6IFtdXG4gICAgfVxuICB9LFxuICB7IC8vZmFjdG9yaWFsXG4gICAgJ09wZXJhdG9yTm9kZTpmYWN0b3JpYWwnOiB7XG4gICAgICBhc3NvY2lhdGl2aXR5OiAnbGVmdCdcbiAgICB9XG4gIH0sXG4gIHsgLy9tYXRyaXggdHJhbnNwb3NlXG4gICAgJ09wZXJhdG9yTm9kZTp0cmFuc3Bvc2UnOiB7XG4gICAgICBhc3NvY2lhdGl2aXR5OiAnbGVmdCdcbiAgICB9XG4gIH1cbl07XG5cbi8qKlxuICogR2V0IHRoZSBwcmVjZWRlbmNlIG9mIGEgTm9kZS5cbiAqIEhpZ2hlciBudW1iZXIgZm9yIGhpZ2hlciBwcmVjZWRlbmNlLCBzdGFydGluZyB3aXRoIDAuXG4gKiBSZXR1cm5zIG51bGwgaWYgdGhlIHByZWNlZGVuY2UgaXMgdW5kZWZpbmVkLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX1cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRoZXNpc1xuICogQHJldHVybiB7bnVtYmVyfG51bGx9XG4gKi9cbmZ1bmN0aW9uIGdldFByZWNlZGVuY2UgKF9ub2RlLCBwYXJlbnRoZXNpcykge1xuICB2YXIgbm9kZSA9IF9ub2RlO1xuICBpZiAocGFyZW50aGVzaXMgIT09ICdrZWVwJykge1xuICAgIC8vUGFyZW50aGVzaXNOb2RlcyBhcmUgb25seSBpZ25vcmVkIHdoZW4gbm90IGluICdrZWVwJyBtb2RlXG4gICAgbm9kZSA9IF9ub2RlLmdldENvbnRlbnQoKTtcbiAgfVxuICB2YXIgaWRlbnRpZmllciA9IG5vZGUuZ2V0SWRlbnRpZmllcigpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaWRlbnRpZmllciBpbiBwcm9wZXJ0aWVzW2ldKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogR2V0IHRoZSBhc3NvY2lhdGl2aXR5IG9mIGFuIG9wZXJhdG9yIChsZWZ0IG9yIHJpZ2h0KS5cbiAqIFJldHVybnMgYSBzdHJpbmcgY29udGFpbmluZyAnbGVmdCcgb3IgJ3JpZ2h0JyBvciBudWxsIGlmXG4gKiB0aGUgYXNzb2NpYXRpdml0eSBpcyBub3QgZGVmaW5lZC5cbiAqXG4gKiBAcGFyYW0ge05vZGV9XG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyZW50aGVzaXNcbiAqIEByZXR1cm4ge3N0cmluZ3xudWxsfVxuICogQHRocm93cyB7RXJyb3J9XG4gKi9cbmZ1bmN0aW9uIGdldEFzc29jaWF0aXZpdHkgKF9ub2RlLCBwYXJlbnRoZXNpcykge1xuICB2YXIgbm9kZSA9IF9ub2RlO1xuICBpZiAocGFyZW50aGVzaXMgIT09ICdrZWVwJykge1xuICAgIC8vUGFyZW50aGVzaXNOb2RlcyBhcmUgb25seSBpZ25vcmVkIHdoZW4gbm90IGluICdrZWVwJyBtb2RlXG4gICAgbm9kZSA9IF9ub2RlLmdldENvbnRlbnQoKTtcbiAgfVxuICB2YXIgaWRlbnRpZmllciA9IG5vZGUuZ2V0SWRlbnRpZmllcigpO1xuICB2YXIgaW5kZXggPSBnZXRQcmVjZWRlbmNlKG5vZGUsIHBhcmVudGhlc2lzKTtcbiAgaWYgKGluZGV4ID09PSBudWxsKSB7XG4gICAgLy9ub2RlIGlzbid0IGluIHRoZSBsaXN0XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHByb3BlcnR5ID0gcHJvcGVydGllc1tpbmRleF1baWRlbnRpZmllcl07XG5cbiAgaWYgKHByb3BlcnR5Lmhhc093blByb3BlcnR5KCdhc3NvY2lhdGl2aXR5JykpIHtcbiAgICBpZiAocHJvcGVydHkuYXNzb2NpYXRpdml0eSA9PT0gJ2xlZnQnKSB7XG4gICAgICByZXR1cm4gJ2xlZnQnO1xuICAgIH1cbiAgICBpZiAocHJvcGVydHkuYXNzb2NpYXRpdml0eSA9PT0gJ3JpZ2h0Jykge1xuICAgICAgcmV0dXJuICdyaWdodCc7XG4gICAgfVxuICAgIC8vYXNzb2NpYXRpdml0eSBpcyBpbnZhbGlkXG4gICAgdGhyb3cgRXJyb3IoJ1xcJycgKyBpZGVudGlmaWVyICsgJ1xcJyBoYXMgdGhlIGludmFsaWQgYXNzb2NpYXRpdml0eSBcXCcnXG4gICAgICAgICAgICAgICAgKyBwcm9wZXJ0eS5hc3NvY2lhdGl2aXR5ICsgJ1xcJy4nKTtcbiAgfVxuXG4gIC8vYXNzb2NpYXRpdml0eSBpcyB1bmRlZmluZWRcbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gb3BlcmF0b3IgaXMgYXNzb2NpYXRpdmUgd2l0aCBhbm90aGVyIG9wZXJhdG9yLlxuICogUmV0dXJucyBlaXRoZXIgdHJ1ZSBvciBmYWxzZSBvciBudWxsIGlmIG5vdCBkZWZpbmVkLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZUFcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZUJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRoZXNpc1xuICogQHJldHVybiB7Ym9vbHxudWxsfVxuICovXG5mdW5jdGlvbiBpc0Fzc29jaWF0aXZlV2l0aCAobm9kZUEsIG5vZGVCLCBwYXJlbnRoZXNpcykge1xuICB2YXIgYSA9IG5vZGVBO1xuICB2YXIgYiA9IG5vZGVCO1xuICBpZiAocGFyZW50aGVzaXMgIT09ICdrZWVwJykge1xuICAgIC8vUGFyZW50aGVzaXNOb2RlcyBhcmUgb25seSBpZ25vcmVkIHdoZW4gbm90IGluICdrZWVwJyBtb2RlXG4gICAgdmFyIGEgPSBub2RlQS5nZXRDb250ZW50KCk7XG4gICAgdmFyIGIgPSBub2RlQi5nZXRDb250ZW50KCk7XG4gIH1cbiAgdmFyIGlkZW50aWZpZXJBID0gYS5nZXRJZGVudGlmaWVyKCk7XG4gIHZhciBpZGVudGlmaWVyQiA9IGIuZ2V0SWRlbnRpZmllcigpO1xuICB2YXIgaW5kZXggPSBnZXRQcmVjZWRlbmNlKGEsIHBhcmVudGhlc2lzKTtcbiAgaWYgKGluZGV4ID09PSBudWxsKSB7XG4gICAgLy9ub2RlIGlzbid0IGluIHRoZSBsaXN0XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHByb3BlcnR5ID0gcHJvcGVydGllc1tpbmRleF1baWRlbnRpZmllckFdO1xuXG4gIGlmIChwcm9wZXJ0eS5oYXNPd25Qcm9wZXJ0eSgnYXNzb2NpYXRpdmVXaXRoJylcbiAgICAgICYmIChwcm9wZXJ0eS5hc3NvY2lhdGl2ZVdpdGggaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BlcnR5LmFzc29jaWF0aXZlV2l0aC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHByb3BlcnR5LmFzc29jaWF0aXZlV2l0aFtpXSA9PT0gaWRlbnRpZmllckIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vYXNzb2NpYXRpdmVXaXRoIGlzIG5vdCBkZWZpbmVkXG4gIHJldHVybiBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcbm1vZHVsZS5leHBvcnRzLmdldFByZWNlZGVuY2UgPSBnZXRQcmVjZWRlbmNlO1xubW9kdWxlLmV4cG9ydHMuZ2V0QXNzb2NpYXRpdml0eSA9IGdldEFzc29jaWF0aXZpdHk7XG5tb2R1bGUuZXhwb3J0cy5pc0Fzc29jaWF0aXZlV2l0aCA9IGlzQXNzb2NpYXRpdmVXaXRoO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQXJndW1lbnRzRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci9Bcmd1bWVudHNFcnJvcicpO1xudmFyIGRlZXBNYXAgPSByZXF1aXJlKCcuLi91dGlscy9jb2xsZWN0aW9uL2RlZXBNYXAnKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgQWNjZXNzb3JOb2RlICAgICAgICAgICAgPSBsb2FkKHJlcXVpcmUoJy4vbm9kZS9BY2Nlc3Nvck5vZGUnKSk7XG4gIHZhciBBcnJheU5vZGUgICAgICAgICAgICAgICA9IGxvYWQocmVxdWlyZSgnLi9ub2RlL0FycmF5Tm9kZScpKTtcbiAgdmFyIEFzc2lnbm1lbnROb2RlICAgICAgICAgID0gbG9hZChyZXF1aXJlKCcuL25vZGUvQXNzaWdubWVudE5vZGUnKSk7XG4gIHZhciBCbG9ja05vZGUgICAgICAgICAgICAgICA9IGxvYWQocmVxdWlyZSgnLi9ub2RlL0Jsb2NrTm9kZScpKTtcbiAgdmFyIENvbmRpdGlvbmFsTm9kZSAgICAgICAgID0gbG9hZChyZXF1aXJlKCcuL25vZGUvQ29uZGl0aW9uYWxOb2RlJykpO1xuICB2YXIgQ29uc3RhbnROb2RlICAgICAgICAgICAgPSBsb2FkKHJlcXVpcmUoJy4vbm9kZS9Db25zdGFudE5vZGUnKSk7XG4gIHZhciBGdW5jdGlvbkFzc2lnbm1lbnROb2RlICA9IGxvYWQocmVxdWlyZSgnLi9ub2RlL0Z1bmN0aW9uQXNzaWdubWVudE5vZGUnKSk7XG4gIHZhciBJbmRleE5vZGUgICAgICAgICAgICAgICA9IGxvYWQocmVxdWlyZSgnLi9ub2RlL0luZGV4Tm9kZScpKTtcbiAgdmFyIE9iamVjdE5vZGUgICAgICAgICAgICAgID0gbG9hZChyZXF1aXJlKCcuL25vZGUvT2JqZWN0Tm9kZScpKTtcbiAgdmFyIE9wZXJhdG9yTm9kZSAgICAgICAgICAgID0gbG9hZChyZXF1aXJlKCcuL25vZGUvT3BlcmF0b3JOb2RlJykpO1xuICB2YXIgUGFyZW50aGVzaXNOb2RlICAgICAgICAgPSBsb2FkKHJlcXVpcmUoJy4vbm9kZS9QYXJlbnRoZXNpc05vZGUnKSk7XG4gIHZhciBGdW5jdGlvbk5vZGUgICAgICAgICAgICA9IGxvYWQocmVxdWlyZSgnLi9ub2RlL0Z1bmN0aW9uTm9kZScpKTtcbiAgdmFyIFJhbmdlTm9kZSAgICAgICAgICAgICAgID0gbG9hZChyZXF1aXJlKCcuL25vZGUvUmFuZ2VOb2RlJykpO1xuICB2YXIgU3ltYm9sTm9kZSAgICAgICAgICAgICAgPSBsb2FkKHJlcXVpcmUoJy4vbm9kZS9TeW1ib2xOb2RlJykpO1xuXG5cbiAgLyoqXG4gICAqIFBhcnNlIGFuIGV4cHJlc3Npb24uIFJldHVybnMgYSBub2RlIHRyZWUsIHdoaWNoIGNhbiBiZSBldmFsdWF0ZWQgYnlcbiAgICogaW52b2tpbmcgbm9kZS5ldmFsKCk7XG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgIHBhcnNlKGV4cHIpXG4gICAqICAgICBwYXJzZShleHByLCBvcHRpb25zKVxuICAgKiAgICAgcGFyc2UoW2V4cHIxLCBleHByMiwgZXhwcjMsIC4uLl0pXG4gICAqICAgICBwYXJzZShbZXhwcjEsIGV4cHIyLCBleHByMywgLi4uXSwgb3B0aW9ucylcbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICpcbiAgICogICAgIHZhciBub2RlID0gcGFyc2UoJ3NxcnQoM14yICsgNF4yKScpO1xuICAgKiAgICAgbm9kZS5jb21waWxlKG1hdGgpLmV2YWwoKTsgLy8gNVxuICAgKlxuICAgKiAgICAgdmFyIHNjb3BlID0ge2E6MywgYjo0fVxuICAgKiAgICAgdmFyIG5vZGUgPSBwYXJzZSgnYSAqIGInKTsgLy8gMTJcbiAgICogICAgIHZhciBjb2RlID0gbm9kZS5jb21waWxlKG1hdGgpO1xuICAgKiAgICAgY29kZS5ldmFsKHNjb3BlKTsgLy8gMTJcbiAgICogICAgIHNjb3BlLmEgPSA1O1xuICAgKiAgICAgY29kZS5ldmFsKHNjb3BlKTsgLy8gMjBcbiAgICpcbiAgICogICAgIHZhciBub2RlcyA9IG1hdGgucGFyc2UoWydhID0gMycsICdiID0gNCcsICdhICogYiddKTtcbiAgICogICAgIG5vZGVzWzJdLmNvbXBpbGUobWF0aCkuZXZhbCgpOyAvLyAxMlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHN0cmluZ1tdIHwgTWF0cml4fSBleHByXG4gICAqIEBwYXJhbSB7e25vZGVzOiBPYmplY3Q8c3RyaW5nLCBOb2RlPn19IFtvcHRpb25zXSAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBgbm9kZXNgIGEgc2V0IG9mIGN1c3RvbSBub2Rlc1xuICAgKiBAcmV0dXJuIHtOb2RlIHwgTm9kZVtdfSBub2RlXG4gICAqIEB0aHJvd3Mge0Vycm9yfVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2UgKGV4cHIsIG9wdGlvbnMpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAxICYmIGFyZ3VtZW50cy5sZW5ndGggIT0gMikge1xuICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50c0Vycm9yKCdwYXJzZScsIGFyZ3VtZW50cy5sZW5ndGgsIDEsIDIpO1xuICAgIH1cblxuICAgIC8vIHBhc3MgZXh0cmEgbm9kZXNcbiAgICBleHRyYV9ub2RlcyA9IChvcHRpb25zICYmIG9wdGlvbnMubm9kZXMpID8gb3B0aW9ucy5ub2RlcyA6IHt9O1xuXG4gICAgaWYgKHR5cGVvZiBleHByID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gcGFyc2UgYSBzaW5nbGUgZXhwcmVzc2lvblxuICAgICAgZXhwcmVzc2lvbiA9IGV4cHI7XG4gICAgICByZXR1cm4gcGFyc2VTdGFydCgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGV4cHIpIHx8IGV4cHIgaW5zdGFuY2VvZiB0eXBlLk1hdHJpeCkge1xuICAgICAgLy8gcGFyc2UgYW4gYXJyYXkgb3IgbWF0cml4IHdpdGggZXhwcmVzc2lvbnNcbiAgICAgIHJldHVybiBkZWVwTWFwKGV4cHIsIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZWxlbSAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1N0cmluZyBleHBlY3RlZCcpO1xuXG4gICAgICAgIGV4cHJlc3Npb24gPSBlbGVtO1xuICAgICAgICByZXR1cm4gcGFyc2VTdGFydCgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gb29wc1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU3RyaW5nIG9yIG1hdHJpeCBleHBlY3RlZCcpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHRva2VuIHR5cGVzIGVudW1lcmF0aW9uXG4gIHZhciBUT0tFTlRZUEUgPSB7XG4gICAgTlVMTCA6IDAsXG4gICAgREVMSU1JVEVSIDogMSxcbiAgICBOVU1CRVIgOiAyLFxuICAgIFNZTUJPTCA6IDMsXG4gICAgVU5LTk9XTiA6IDRcbiAgfTtcblxuICAvLyBtYXAgd2l0aCBhbGwgZGVsaW1pdGVyc1xuICB2YXIgREVMSU1JVEVSUyA9IHtcbiAgICAnLCc6IHRydWUsXG4gICAgJygnOiB0cnVlLFxuICAgICcpJzogdHJ1ZSxcbiAgICAnWyc6IHRydWUsXG4gICAgJ10nOiB0cnVlLFxuICAgICd7JzogdHJ1ZSxcbiAgICAnfSc6IHRydWUsXG4gICAgJ1xcXCInOiB0cnVlLFxuICAgICc7JzogdHJ1ZSxcblxuICAgICcrJzogdHJ1ZSxcbiAgICAnLSc6IHRydWUsXG4gICAgJyonOiB0cnVlLFxuICAgICcuKic6IHRydWUsXG4gICAgJy8nOiB0cnVlLFxuICAgICcuLyc6IHRydWUsXG4gICAgJyUnOiB0cnVlLFxuICAgICdeJzogdHJ1ZSxcbiAgICAnLl4nOiB0cnVlLFxuICAgICd+JzogdHJ1ZSxcbiAgICAnISc6IHRydWUsXG4gICAgJyYnOiB0cnVlLFxuICAgICd8JzogdHJ1ZSxcbiAgICAnXnwnOiB0cnVlLFxuICAgICdcXCcnOiB0cnVlLFxuICAgICc9JzogdHJ1ZSxcbiAgICAnOic6IHRydWUsXG4gICAgJz8nOiB0cnVlLFxuXG4gICAgJz09JzogdHJ1ZSxcbiAgICAnIT0nOiB0cnVlLFxuICAgICc8JzogdHJ1ZSxcbiAgICAnPic6IHRydWUsXG4gICAgJzw9JzogdHJ1ZSxcbiAgICAnPj0nOiB0cnVlLFxuXG4gICAgJzw8JzogdHJ1ZSxcbiAgICAnPj4nOiB0cnVlLFxuICAgICc+Pj4nOiB0cnVlXG4gIH07XG5cbiAgLy8gbWFwIHdpdGggYWxsIG5hbWVkIGRlbGltaXRlcnNcbiAgdmFyIE5BTUVEX0RFTElNSVRFUlMgPSB7XG4gICAgJ21vZCc6IHRydWUsXG4gICAgJ3RvJzogdHJ1ZSxcbiAgICAnaW4nOiB0cnVlLFxuICAgICdhbmQnOiB0cnVlLFxuICAgICd4b3InOiB0cnVlLFxuICAgICdvcic6IHRydWUsXG4gICAgJ25vdCc6IHRydWVcbiAgfTtcblxuICB2YXIgZXh0cmFfbm9kZXMgPSB7fTsgICAgICAgICAgICAgLy8gY3VycmVudCBleHRyYSBub2Rlc1xuICB2YXIgZXhwcmVzc2lvbiA9ICcnOyAgICAgICAgICAgICAgLy8gY3VycmVudCBleHByZXNzaW9uXG4gIHZhciBpbmRleCA9IDA7ICAgICAgICAgICAgICAgICAgICAvLyBjdXJyZW50IGluZGV4IGluIGV4cHJcbiAgdmFyIGMgPSAnJzsgICAgICAgICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgdG9rZW4gY2hhcmFjdGVyIGluIGV4cHJcbiAgdmFyIHRva2VuID0gJyc7ICAgICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgdG9rZW5cbiAgdmFyIHRva2VuX3R5cGUgPSBUT0tFTlRZUEUuTlVMTDsgIC8vIHR5cGUgb2YgdGhlIHRva2VuXG4gIHZhciBuZXN0aW5nX2xldmVsID0gMDsgICAgICAgICAgICAvLyBsZXZlbCBvZiBuZXN0aW5nIGluc2lkZSBwYXJhbWV0ZXJzLCB1c2VkIHRvIGlnbm9yZSBuZXdsaW5lIGNoYXJhY3RlcnNcbiAgdmFyIGNvbmRpdGlvbmFsX2xldmVsID0gbnVsbDsgICAgIC8vIHdoZW4gYSBjb25kaXRpb25hbCBpcyBiZWluZyBwYXJzZWQsIHRoZSBsZXZlbCBvZiB0aGUgY29uZGl0aW9uYWwgaXMgc3RvcmVkIGhlcmVcblxuICAvKipcbiAgICogR2V0IHRoZSBmaXJzdCBjaGFyYWN0ZXIgZnJvbSB0aGUgZXhwcmVzc2lvbi5cbiAgICogVGhlIGNoYXJhY3RlciBpcyBzdG9yZWQgaW50byB0aGUgY2hhciBjLiBJZiB0aGUgZW5kIG9mIHRoZSBleHByZXNzaW9uIGlzXG4gICAqIHJlYWNoZWQsIHRoZSBmdW5jdGlvbiBwdXRzIGFuIGVtcHR5IHN0cmluZyBpbiBjLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZmlyc3QoKSB7XG4gICAgaW5kZXggPSAwO1xuICAgIGMgPSBleHByZXNzaW9uLmNoYXJBdCgwKTtcbiAgICBuZXN0aW5nX2xldmVsID0gMDtcbiAgICBjb25kaXRpb25hbF9sZXZlbCA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBuZXh0IGNoYXJhY3RlciBmcm9tIHRoZSBleHByZXNzaW9uLlxuICAgKiBUaGUgY2hhcmFjdGVyIGlzIHN0b3JlZCBpbnRvIHRoZSBjaGFyIGMuIElmIHRoZSBlbmQgb2YgdGhlIGV4cHJlc3Npb24gaXNcbiAgICogcmVhY2hlZCwgdGhlIGZ1bmN0aW9uIHB1dHMgYW4gZW1wdHkgc3RyaW5nIGluIGMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBuZXh0KCkge1xuICAgIGluZGV4Kys7XG4gICAgYyA9IGV4cHJlc3Npb24uY2hhckF0KGluZGV4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmV2aWV3IHRoZSBuZXh0IGNoYXJhY3RlciBmcm9tIHRoZSBleHByZXNzaW9uLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IGNOZXh0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBuZXh0UHJldmlldygpIHtcbiAgICByZXR1cm4gZXhwcmVzc2lvbi5jaGFyQXQoaW5kZXggKyAxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmV2aWV3IHRoZSBzZWNvbmQgbmV4dCBjaGFyYWN0ZXIgZnJvbSB0aGUgZXhwcmVzc2lvbi5cbiAgICogQHJldHVybiB7c3RyaW5nfSBjTmV4dFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gbmV4dE5leHRQcmV2aWV3KCkge1xuICAgIHJldHVybiBleHByZXNzaW9uLmNoYXJBdChpbmRleCArIDIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBuZXh0IHRva2VuIGluIHRoZSBjdXJyZW50IHN0cmluZyBleHByLlxuICAgKiBUaGUgdG9rZW4gYW5kIHRva2VuIHR5cGUgYXJlIGF2YWlsYWJsZSBhcyB0b2tlbiBhbmQgdG9rZW5fdHlwZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0VG9rZW4oKSB7XG4gICAgdG9rZW5fdHlwZSA9IFRPS0VOVFlQRS5OVUxMO1xuICAgIHRva2VuID0gJyc7XG5cbiAgICAvLyBza2lwIG92ZXIgd2hpdGVzcGFjZXNcbiAgICAvLyBzcGFjZSwgdGFiLCBhbmQgbmV3bGluZSB3aGVuIGluc2lkZSBwYXJhbWV0ZXJzXG4gICAgd2hpbGUgKGMgPT0gJyAnIHx8IGMgPT0gJ1xcdCcgfHwgKGMgPT0gJ1xcbicgJiYgbmVzdGluZ19sZXZlbCkpIHtcbiAgICAgIC8vIFRPRE86IGFsc28gdGFrZSAnXFxyJyBjYXJyaWFnZSByZXR1cm4gYXMgbmV3bGluZT8gT3IgZG9lcyB0aGF0IGdpdmUgcHJvYmxlbXMgb24gbWFjP1xuICAgICAgbmV4dCgpO1xuICAgIH1cblxuICAgIC8vIHNraXAgY29tbWVudFxuICAgIGlmIChjID09ICcjJykge1xuICAgICAgd2hpbGUgKGMgIT0gJ1xcbicgJiYgYyAhPSAnJykge1xuICAgICAgICBuZXh0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgZm9yIGVuZCBvZiBleHByZXNzaW9uXG4gICAgaWYgKGMgPT0gJycpIHtcbiAgICAgIC8vIHRva2VuIGlzIHN0aWxsIGVtcHR5XG4gICAgICB0b2tlbl90eXBlID0gVE9LRU5UWVBFLkRFTElNSVRFUjtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBmb3IgbmV3IGxpbmUgY2hhcmFjdGVyXG4gICAgaWYgKGMgPT0gJ1xcbicgJiYgIW5lc3RpbmdfbGV2ZWwpIHtcbiAgICAgIHRva2VuX3R5cGUgPSBUT0tFTlRZUEUuREVMSU1JVEVSO1xuICAgICAgdG9rZW4gPSBjO1xuICAgICAgbmV4dCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGZvciBkZWxpbWl0ZXJzIGNvbnNpc3Rpbmcgb2YgMyBjaGFyYWN0ZXJzXG4gICAgdmFyIGMyID0gYyArIG5leHRQcmV2aWV3KCk7XG4gICAgdmFyIGMzID0gYzIgKyBuZXh0TmV4dFByZXZpZXcoKTtcbiAgICBpZiAoYzMubGVuZ3RoID09IDMgJiYgREVMSU1JVEVSU1tjM10pIHtcbiAgICAgIHRva2VuX3R5cGUgPSBUT0tFTlRZUEUuREVMSU1JVEVSO1xuICAgICAgdG9rZW4gPSBjMztcbiAgICAgIG5leHQoKTtcbiAgICAgIG5leHQoKTtcbiAgICAgIG5leHQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBmb3IgZGVsaW1pdGVycyBjb25zaXN0aW5nIG9mIDIgY2hhcmFjdGVyc1xuICAgIGlmIChjMi5sZW5ndGggPT0gMiAmJiBERUxJTUlURVJTW2MyXSkge1xuICAgICAgdG9rZW5fdHlwZSA9IFRPS0VOVFlQRS5ERUxJTUlURVI7XG4gICAgICB0b2tlbiA9IGMyO1xuICAgICAgbmV4dCgpO1xuICAgICAgbmV4dCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGZvciBkZWxpbWl0ZXJzIGNvbnNpc3Rpbmcgb2YgMSBjaGFyYWN0ZXJcbiAgICBpZiAoREVMSU1JVEVSU1tjXSkge1xuICAgICAgdG9rZW5fdHlwZSA9IFRPS0VOVFlQRS5ERUxJTUlURVI7XG4gICAgICB0b2tlbiA9IGM7XG4gICAgICBuZXh0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgZm9yIGEgbnVtYmVyXG4gICAgaWYgKGlzRGlnaXREb3QoYykpIHtcbiAgICAgIHRva2VuX3R5cGUgPSBUT0tFTlRZUEUuTlVNQkVSO1xuXG4gICAgICAvLyBnZXQgbnVtYmVyLCBjYW4gaGF2ZSBhIHNpbmdsZSBkb3RcbiAgICAgIGlmIChjID09ICcuJykge1xuICAgICAgICB0b2tlbiArPSBjO1xuICAgICAgICBuZXh0KCk7XG5cbiAgICAgICAgaWYgKCFpc0RpZ2l0KGMpKSB7XG4gICAgICAgICAgLy8gdGhpcyBpcyBubyBsZWdhbCBudW1iZXIsIGl0IGlzIGp1c3QgYSBkb3RcbiAgICAgICAgICB0b2tlbl90eXBlID0gVE9LRU5UWVBFLlVOS05PV047XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB3aGlsZSAoaXNEaWdpdChjKSkge1xuICAgICAgICAgIHRva2VuICs9IGM7XG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjID09ICcuJykge1xuICAgICAgICAgIHRva2VuICs9IGM7XG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAoaXNEaWdpdChjKSkge1xuICAgICAgICB0b2tlbiArPSBjO1xuICAgICAgICBuZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIGZvciBleHBvbmVudGlhbCBub3RhdGlvbiBsaWtlIFwiMi4zZS00XCIsIFwiMS4yM2U1MFwiIG9yIFwiMmUrNFwiXG4gICAgICBjMiA9IG5leHRQcmV2aWV3KCk7XG4gICAgICBpZiAoKGMgPT0gJ0UnIHx8IGMgPT0gJ2UnKSAmJiAoaXNEaWdpdChjMikgfHwgYzIgPT0gJy0nIHx8IGMyID09ICcrJykpIHtcbiAgICAgICAgdG9rZW4gKz0gYztcbiAgICAgICAgbmV4dCgpO1xuXG4gICAgICAgIGlmIChjID09ICcrJyB8fCBjID09ICctJykge1xuICAgICAgICAgIHRva2VuICs9IGM7XG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2NpZW50aWZpYyBub3RhdGlvbiBNVVNUIGJlIGZvbGxvd2VkIGJ5IGFuIGV4cG9uZW50XG4gICAgICAgIGlmICghaXNEaWdpdChjKSkge1xuICAgICAgICAgIC8vIHRoaXMgaXMgbm8gbGVnYWwgbnVtYmVyLCBleHBvbmVudCBpcyBtaXNzaW5nLlxuICAgICAgICAgIHRva2VuX3R5cGUgPSBUT0tFTlRZUEUuVU5LTk9XTjtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChpc0RpZ2l0KGMpKSB7XG4gICAgICAgICAgdG9rZW4gKz0gYztcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGZvciB2YXJpYWJsZXMsIGZ1bmN0aW9ucywgbmFtZWQgb3BlcmF0b3JzXG4gICAgaWYgKGN1cnJlbnRJc0FscGhhKCkpIHtcbiAgICAgIHdoaWxlIChjdXJyZW50SXNBbHBoYSgpIHx8IGlzRGlnaXQoYykpIHtcbiAgICAgICAgdG9rZW4gKz0gYztcbiAgICAgICAgbmV4dCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoTkFNRURfREVMSU1JVEVSUy5oYXNPd25Qcm9wZXJ0eSh0b2tlbikpIHtcbiAgICAgICAgdG9rZW5fdHlwZSA9IFRPS0VOVFlQRS5ERUxJTUlURVI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdG9rZW5fdHlwZSA9IFRPS0VOVFlQRS5TWU1CT0w7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBzb21ldGhpbmcgdW5rbm93biBpcyBmb3VuZCwgd3JvbmcgY2hhcmFjdGVycyAtPiBhIHN5bnRheCBlcnJvclxuICAgIHRva2VuX3R5cGUgPSBUT0tFTlRZUEUuVU5LTk9XTjtcbiAgICB3aGlsZSAoYyAhPSAnJykge1xuICAgICAgdG9rZW4gKz0gYztcbiAgICAgIG5leHQoKTtcbiAgICB9XG4gICAgdGhyb3cgY3JlYXRlU3ludGF4RXJyb3IoJ1N5bnRheCBlcnJvciBpbiBwYXJ0IFwiJyArIHRva2VuICsgJ1wiJyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IG5leHQgdG9rZW4gYW5kIHNraXAgbmV3bGluZSB0b2tlbnNcbiAgICovXG4gIGZ1bmN0aW9uIGdldFRva2VuU2tpcE5ld2xpbmUgKCkge1xuICAgIGRvIHtcbiAgICAgIGdldFRva2VuKCk7XG4gICAgfVxuICAgIHdoaWxlICh0b2tlbiA9PSAnXFxuJyk7XG4gIH1cblxuICAvKipcbiAgICogT3BlbiBwYXJhbWV0ZXJzLlxuICAgKiBOZXcgbGluZSBjaGFyYWN0ZXJzIHdpbGwgYmUgaWdub3JlZCB1bnRpbCBjbG9zZVBhcmFtcygpIGlzIGNhbGxlZFxuICAgKi9cbiAgZnVuY3Rpb24gb3BlblBhcmFtcygpIHtcbiAgICBuZXN0aW5nX2xldmVsKys7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2UgcGFyYW1ldGVycy5cbiAgICogTmV3IGxpbmUgY2hhcmFjdGVycyB3aWxsIG5vIGxvbmdlciBiZSBpZ25vcmVkXG4gICAqL1xuICBmdW5jdGlvbiBjbG9zZVBhcmFtcygpIHtcbiAgICBuZXN0aW5nX2xldmVsLS07XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGBjYCBpcyBhIHZhbGlkIGFscGhhIGNoYXJhY3RlcjpcbiAgICpcbiAgICogLSBBIGxhdGluIGxldHRlciAodXBwZXIgb3IgbG93ZXIgY2FzZSkgQXNjaWk6IGEteiwgQS1aXG4gICAqIC0gQSB1bmRlcnNjb3JlICAgICAgICAgICAgICAgICAgICAgICAgIEFzY2lpOiBfXG4gICAqIC0gQSBsYXRpbiBsZXR0ZXIgd2l0aCBhY2NlbnRzICAgICAgICAgIFVuaWNvZGU6IFxcdTAwQzAgLSBcXHUwMkFGXG4gICAqIC0gQSBncmVlayBsZXR0ZXIgICAgICAgICAgICAgICAgICAgICAgIFVuaWNvZGU6IFxcdTAzNzAgLSBcXHUwM0ZGXG4gICAqIC0gQSBtYXRoZW1hdGljYWwgYWxwaGFudW1lcmljIHN5bWJvbCAgIFVuaWNvZGU6IFxcdXsxRDQwMH0gLSBcXHV7MUQ3RkZ9IGV4Y2x1ZGluZyBpbnZhbGlkIGNvZGUgcG9pbnRzXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBjdXJyZW50SXNBbHBoYSAoKSB7XG4gICAgLy8gaHR0cDovL3VuaWNvZGUtdGFibGUuY29tL2VuL1xuICAgIC8vIGh0dHA6Ly93d3cud2lraXdhbmQuY29tL2VuL01hdGhlbWF0aWNhbF9vcGVyYXRvcnNfYW5kX3N5bWJvbHNfaW5fVW5pY29kZVxuICAgIC8vXG4gICAgLy8gTm90ZTogSW4gRVM2IHdpbGwgYmUgdW5pY29kZSBhd2FyZTpcbiAgICAvLyAgIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjgwNzEyL2phdmFzY3JpcHQtdW5pY29kZS1yZWdleGVzXG4gICAgLy8gICBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvZXM2LXVuaWNvZGUtcmVnZXhcbiAgICB2YXIgY1ByZXYgPSBleHByZXNzaW9uLmNoYXJBdChpbmRleCAtIDEpO1xuICAgIHZhciBjTmV4dCA9IGV4cHJlc3Npb24uY2hhckF0KGluZGV4ICsgMSk7XG5cbiAgICB2YXIgaXNWYWxpZExhdGluT3JHcmVlayA9IGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gL15bYS16QS1aX1xcdTAwQzAtXFx1MDJBRlxcdTAzNzAtXFx1MDNGRl0kLy50ZXN0KHApO1xuICAgIH07XG5cbiAgICB2YXIgaXNWYWxpZE1hdGhTeW1ib2wgPSBmdW5jdGlvbiAoaGlnaCwgbG93KSB7XG4gICAgICByZXR1cm4gL15bXFx1RDgzNV0kLy50ZXN0KGhpZ2gpICYmXG4gICAgICAgICAgL15bXFx1REMwMC1cXHVERkZGXSQvLnRlc3QobG93KSAmJlxuICAgICAgICAgIC9eW15cXHVEQzU1XFx1REM5RFxcdURDQTBcXHVEQ0ExXFx1RENBM1xcdURDQTRcXHVEQ0E3XFx1RENBOFxcdURDQURcXHVEQ0JBXFx1RENCQ1xcdURDQzRcXHVERDA2XFx1REQwQlxcdUREMENcXHVERDE1XFx1REQxRFxcdUREM0FcXHVERDNGXFx1REQ0NVxcdURENDctXFx1REQ0OVxcdURENTFcXHVERUE2XFx1REVBN1xcdURGQ0NcXHVERkNEXSQvLnRlc3QobG93KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGlzVmFsaWRMYXRpbk9yR3JlZWsoYylcbiAgICAgICAgfHwgaXNWYWxpZE1hdGhTeW1ib2woYywgY05leHQpXG4gICAgICAgIHx8IGlzVmFsaWRNYXRoU3ltYm9sKGNQcmV2LCBjKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBjaGVja3MgaWYgdGhlIGdpdmVuIGNoYXIgYyBpcyBhIGRpZ2l0IG9yIGRvdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gYyAgIGEgc3RyaW5nIHdpdGggb25lIGNoYXJhY3RlclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gaXNEaWdpdERvdCAoYykge1xuICAgIHJldHVybiAoKGMgPj0gJzAnICYmIGMgPD0gJzknKSB8fCBjID09ICcuJyk7XG4gIH1cblxuICAvKipcbiAgICogY2hlY2tzIGlmIHRoZSBnaXZlbiBjaGFyIGMgaXMgYSBkaWdpdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gYyAgIGEgc3RyaW5nIHdpdGggb25lIGNoYXJhY3RlclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gaXNEaWdpdCAoYykge1xuICAgIHJldHVybiAoYyA+PSAnMCcgJiYgYyA8PSAnOScpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IG9mIHRoZSBwYXJzZSBsZXZlbHMgYmVsb3csIGluIG9yZGVyIG9mIHByZWNlZGVuY2VcbiAgICogQHJldHVybiB7Tm9kZX0gbm9kZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VTdGFydCAoKSB7XG4gICAgLy8gZ2V0IHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gZXhwcmVzc2lvblxuICAgIGZpcnN0KCk7XG5cbiAgICBnZXRUb2tlbigpO1xuXG4gICAgdmFyIG5vZGUgPSBwYXJzZUJsb2NrKCk7XG5cbiAgICAvLyBjaGVjayBmb3IgZ2FyYmFnZSBhdCB0aGUgZW5kIG9mIHRoZSBleHByZXNzaW9uXG4gICAgLy8gYW4gZXhwcmVzc2lvbiBlbmRzIHdpdGggYSBlbXB0eSBjaGFyYWN0ZXIgJycgYW5kIHRva2VuX3R5cGUgREVMSU1JVEVSXG4gICAgaWYgKHRva2VuICE9ICcnKSB7XG4gICAgICBpZiAodG9rZW5fdHlwZSA9PSBUT0tFTlRZUEUuREVMSU1JVEVSKSB7XG4gICAgICAgIC8vIHVzZXIgZW50ZXJlZCBhIG5vdCBleGlzdGluZyBvcGVyYXRvciBsaWtlIFwiLy9cIlxuXG4gICAgICAgIC8vIFRPRE86IGdpdmUgaGludHMgZm9yIGFsaWFzZXMsIGZvciBleGFtcGxlIHdpdGggXCI8PlwiIGdpdmUgYXMgaGludCBcIiBkaWQgeW91IG1lYW4gIT0gP1wiXG4gICAgICAgIHRocm93IGNyZWF0ZUVycm9yKCdVbmV4cGVjdGVkIG9wZXJhdG9yICcgKyB0b2tlbik7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlU3ludGF4RXJyb3IoJ1VuZXhwZWN0ZWQgcGFydCBcIicgKyB0b2tlbiArICdcIicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGEgYmxvY2sgd2l0aCBleHByZXNzaW9ucy4gRXhwcmVzc2lvbnMgY2FuIGJlIHNlcGFyYXRlZCBieSBhIG5ld2xpbmVcbiAgICogY2hhcmFjdGVyICdcXG4nLCBvciBieSBhIHNlbWljb2xvbiAnOycuIEluIGNhc2Ugb2YgYSBzZW1pY29sb24sIG5vIG91dHB1dFxuICAgKiBvZiB0aGUgcHJlY2VkaW5nIGxpbmUgaXMgcmV0dXJuZWQuXG4gICAqIEByZXR1cm4ge05vZGV9IG5vZGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlQmxvY2sgKCkge1xuICAgIHZhciBub2RlO1xuICAgIHZhciBibG9ja3MgPSBbXTtcbiAgICB2YXIgdmlzaWJsZTtcblxuICAgIGlmICh0b2tlbiA9PSAnJykge1xuICAgICAgLy8gZW1wdHkgZXhwcmVzc2lvblxuICAgICAgcmV0dXJuIG5ldyBDb25zdGFudE5vZGUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgICB9XG5cbiAgICBpZiAodG9rZW4gIT0gJ1xcbicgJiYgdG9rZW4gIT0gJzsnKSB7XG4gICAgICBub2RlID0gcGFyc2VBc3NpZ25tZW50KCk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogc2ltcGxpZnkgdGhpcyBsb29wXG4gICAgd2hpbGUgKHRva2VuID09ICdcXG4nIHx8IHRva2VuID09ICc7Jykge1xuICAgICAgaWYgKGJsb2Nrcy5sZW5ndGggPT0gMCAmJiBub2RlKSB7XG4gICAgICAgIHZpc2libGUgPSAodG9rZW4gIT0gJzsnKTtcbiAgICAgICAgYmxvY2tzLnB1c2goe1xuICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgdmlzaWJsZTogdmlzaWJsZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZ2V0VG9rZW4oKTtcbiAgICAgIGlmICh0b2tlbiAhPSAnXFxuJyAmJiB0b2tlbiAhPSAnOycgJiYgdG9rZW4gIT0gJycpIHtcbiAgICAgICAgbm9kZSA9IHBhcnNlQXNzaWdubWVudCgpO1xuXG4gICAgICAgIHZpc2libGUgPSAodG9rZW4gIT0gJzsnKTtcbiAgICAgICAgYmxvY2tzLnB1c2goe1xuICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgdmlzaWJsZTogdmlzaWJsZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYmxvY2tzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBuZXcgQmxvY2tOb2RlKGJsb2Nrcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFzc2lnbm1lbnQgb2YgYSBmdW5jdGlvbiBvciB2YXJpYWJsZSxcbiAgICogLSBjYW4gYmUgYSB2YXJpYWJsZSBsaWtlICdhPTIuMydcbiAgICogLSBvciBhIHVwZGF0aW5nIGFuIGV4aXN0aW5nIHZhcmlhYmxlIGxpa2UgJ21hdHJpeCgyLDM6NSk9WzYsNyw4XSdcbiAgICogLSBkZWZpbmluZyBhIGZ1bmN0aW9uIGxpa2UgJ2YoeCkgPSB4XjInXG4gICAqIEByZXR1cm4ge05vZGV9IG5vZGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlQXNzaWdubWVudCAoKSB7XG4gICAgdmFyIG5hbWUsIGFyZ3MsIHZhbHVlLCB2YWxpZDtcblxuICAgIHZhciBub2RlID0gcGFyc2VDb25kaXRpb25hbCgpO1xuXG4gICAgaWYgKHRva2VuID09ICc9Jykge1xuICAgICAgaWYgKG5vZGUgJiYgbm9kZS5pc1N5bWJvbE5vZGUpIHtcbiAgICAgICAgLy8gcGFyc2UgYSB2YXJpYWJsZSBhc3NpZ25tZW50IGxpa2UgJ2EgPSAyLzMnXG4gICAgICAgIG5hbWUgPSBub2RlLm5hbWU7XG4gICAgICAgIGdldFRva2VuU2tpcE5ld2xpbmUoKTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUFzc2lnbm1lbnQoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBc3NpZ25tZW50Tm9kZShuZXcgU3ltYm9sTm9kZShuYW1lKSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobm9kZSAmJiBub2RlLmlzQWNjZXNzb3JOb2RlKSB7XG4gICAgICAgIC8vIHBhcnNlIGEgbWF0cml4IHN1YnNldCBhc3NpZ25tZW50IGxpa2UgJ0FbMSwyXSA9IDQnXG4gICAgICAgIGdldFRva2VuU2tpcE5ld2xpbmUoKTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUFzc2lnbm1lbnQoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBc3NpZ25tZW50Tm9kZShub2RlLm9iamVjdCwgbm9kZS5pbmRleCwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobm9kZSAmJiBub2RlLmlzRnVuY3Rpb25Ob2RlKSB7XG4gICAgICAgIC8vIHBhcnNlIGZ1bmN0aW9uIGFzc2lnbm1lbnQgbGlrZSAnZih4KSA9IHheMidcbiAgICAgICAgdmFsaWQgPSB0cnVlO1xuICAgICAgICBhcmdzID0gW107XG5cbiAgICAgICAgbmFtZSA9IG5vZGUubmFtZTtcbiAgICAgICAgbm9kZS5hcmdzLmZvckVhY2goZnVuY3Rpb24gKGFyZywgaW5kZXgpIHtcbiAgICAgICAgICBpZiAoYXJnICYmIGFyZy5pc1N5bWJvbE5vZGUpIHtcbiAgICAgICAgICAgIGFyZ3NbaW5kZXhdID0gYXJnLm5hbWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh2YWxpZCkge1xuICAgICAgICAgIGdldFRva2VuU2tpcE5ld2xpbmUoKTtcbiAgICAgICAgICB2YWx1ZSA9IHBhcnNlQXNzaWdubWVudCgpO1xuICAgICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25Bc3NpZ25tZW50Tm9kZShuYW1lLCBhcmdzLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgY3JlYXRlU3ludGF4RXJyb3IoJ0ludmFsaWQgbGVmdCBoYW5kIHNpZGUgb2YgYXNzaWdubWVudCBvcGVyYXRvciA9Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICAvKipcbiAgICogY29uZGl0aW9uYWwgb3BlcmF0aW9uXG4gICAqXG4gICAqICAgICBjb25kaXRpb24gPyB0cnVlUGFydCA6IGZhbHNlUGFydFxuICAgKlxuICAgKiBOb3RlOiBjb25kaXRpb25hbCBvcGVyYXRvciBpcyByaWdodC1hc3NvY2lhdGl2ZVxuICAgKlxuICAgKiBAcmV0dXJuIHtOb2RlfSBub2RlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZUNvbmRpdGlvbmFsICgpIHtcbiAgICB2YXIgbm9kZSA9IHBhcnNlTG9naWNhbE9yKCk7XG5cbiAgICB3aGlsZSAodG9rZW4gPT0gJz8nKSB7XG4gICAgICAvLyBzZXQgYSBjb25kaXRpb25hbCBsZXZlbCwgdGhlIHJhbmdlIG9wZXJhdG9yIHdpbGwgYmUgaWdub3JlZCBhcyBsb25nXG4gICAgICAvLyBhcyBjb25kaXRpb25hbF9sZXZlbCA9PSBuZXN0aW5nX2xldmVsLlxuICAgICAgdmFyIHByZXYgPSBjb25kaXRpb25hbF9sZXZlbDtcbiAgICAgIGNvbmRpdGlvbmFsX2xldmVsID0gbmVzdGluZ19sZXZlbDtcbiAgICAgIGdldFRva2VuU2tpcE5ld2xpbmUoKTtcblxuICAgICAgdmFyIGNvbmRpdGlvbiA9IG5vZGU7XG4gICAgICB2YXIgdHJ1ZUV4cHIgPSBwYXJzZUFzc2lnbm1lbnQoKTtcblxuICAgICAgaWYgKHRva2VuICE9ICc6JykgdGhyb3cgY3JlYXRlU3ludGF4RXJyb3IoJ0ZhbHNlIHBhcnQgb2YgY29uZGl0aW9uYWwgZXhwcmVzc2lvbiBleHBlY3RlZCcpO1xuXG4gICAgICBjb25kaXRpb25hbF9sZXZlbCA9IG51bGw7XG4gICAgICBnZXRUb2tlblNraXBOZXdsaW5lKCk7XG5cbiAgICAgIHZhciBmYWxzZUV4cHIgPSBwYXJzZUFzc2lnbm1lbnQoKTsgLy8gTm90ZTogY2hlY2sgZm9yIGNvbmRpdGlvbmFsIG9wZXJhdG9yIGFnYWluLCByaWdodCBhc3NvY2lhdGl2aXR5XG5cbiAgICAgIG5vZGUgPSBuZXcgQ29uZGl0aW9uYWxOb2RlKGNvbmRpdGlvbiwgdHJ1ZUV4cHIsIGZhbHNlRXhwcik7XG5cbiAgICAgIC8vIHJlc3RvcmUgdGhlIHByZXZpb3VzIGNvbmRpdGlvbmFsIGxldmVsXG4gICAgICBjb25kaXRpb25hbF9sZXZlbCA9IHByZXY7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICAvKipcbiAgICogbG9naWNhbCBvciwgJ3ggb3IgeSdcbiAgICogQHJldHVybiB7Tm9kZX0gbm9kZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VMb2dpY2FsT3IoKSB7XG4gICAgdmFyIG5vZGUgPSBwYXJzZUxvZ2ljYWxYb3IoKTtcblxuICAgIHdoaWxlICh0b2tlbiA9PSAnb3InKSB7XG4gICAgICBnZXRUb2tlblNraXBOZXdsaW5lKCk7XG4gICAgICBub2RlID0gbmV3IE9wZXJhdG9yTm9kZSgnb3InLCAnb3InLCBbbm9kZSwgcGFyc2VMb2dpY2FsWG9yKCldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBsb2dpY2FsIGV4Y2x1c2l2ZSBvciwgJ3ggeG9yIHknXG4gICAqIEByZXR1cm4ge05vZGV9IG5vZGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlTG9naWNhbFhvcigpIHtcbiAgICB2YXIgbm9kZSA9IHBhcnNlTG9naWNhbEFuZCgpO1xuXG4gICAgd2hpbGUgKHRva2VuID09ICd4b3InKSB7XG4gICAgICBnZXRUb2tlblNraXBOZXdsaW5lKCk7XG4gICAgICBub2RlID0gbmV3IE9wZXJhdG9yTm9kZSgneG9yJywgJ3hvcicsIFtub2RlLCBwYXJzZUxvZ2ljYWxBbmQoKV0pO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIGxvZ2ljYWwgYW5kLCAneCBhbmQgeSdcbiAgICogQHJldHVybiB7Tm9kZX0gbm9kZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VMb2dpY2FsQW5kKCkge1xuICAgIHZhciBub2RlID0gcGFyc2VCaXR3aXNlT3IoKTtcblxuICAgIHdoaWxlICh0b2tlbiA9PSAnYW5kJykge1xuICAgICAgZ2V0VG9rZW5Ta2lwTmV3bGluZSgpO1xuICAgICAgbm9kZSA9IG5ldyBPcGVyYXRvck5vZGUoJ2FuZCcsICdhbmQnLCBbbm9kZSwgcGFyc2VCaXR3aXNlT3IoKV0pO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIGJpdHdpc2Ugb3IsICd4IHwgeSdcbiAgICogQHJldHVybiB7Tm9kZX0gbm9kZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VCaXR3aXNlT3IoKSB7XG4gICAgdmFyIG5vZGUgPSBwYXJzZUJpdHdpc2VYb3IoKTtcblxuICAgIHdoaWxlICh0b2tlbiA9PSAnfCcpIHtcbiAgICAgIGdldFRva2VuU2tpcE5ld2xpbmUoKTtcbiAgICAgIG5vZGUgPSBuZXcgT3BlcmF0b3JOb2RlKCd8JywgJ2JpdE9yJywgW25vZGUsIHBhcnNlQml0d2lzZVhvcigpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICAvKipcbiAgICogYml0d2lzZSBleGNsdXNpdmUgb3IgKHhvciksICd4IF58IHknXG4gICAqIEByZXR1cm4ge05vZGV9IG5vZGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlQml0d2lzZVhvcigpIHtcbiAgICB2YXIgbm9kZSA9IHBhcnNlQml0d2lzZUFuZCgpO1xuXG4gICAgd2hpbGUgKHRva2VuID09ICdefCcpIHtcbiAgICAgIGdldFRva2VuU2tpcE5ld2xpbmUoKTtcbiAgICAgIG5vZGUgPSBuZXcgT3BlcmF0b3JOb2RlKCdefCcsICdiaXRYb3InLCBbbm9kZSwgcGFyc2VCaXR3aXNlQW5kKCldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBiaXR3aXNlIGFuZCwgJ3ggJiB5J1xuICAgKiBAcmV0dXJuIHtOb2RlfSBub2RlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZUJpdHdpc2VBbmQgKCkge1xuICAgIHZhciBub2RlID0gcGFyc2VSZWxhdGlvbmFsKCk7XG5cbiAgICB3aGlsZSAodG9rZW4gPT0gJyYnKSB7XG4gICAgICBnZXRUb2tlblNraXBOZXdsaW5lKCk7XG4gICAgICBub2RlID0gbmV3IE9wZXJhdG9yTm9kZSgnJicsICdiaXRBbmQnLCBbbm9kZSwgcGFyc2VSZWxhdGlvbmFsKCldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZWxhdGlvbmFsIG9wZXJhdG9yc1xuICAgKiBAcmV0dXJuIHtOb2RlfSBub2RlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZVJlbGF0aW9uYWwgKCkge1xuICAgIHZhciBub2RlLCBvcGVyYXRvcnMsIG5hbWUsIGZuLCBwYXJhbXM7XG5cbiAgICBub2RlID0gcGFyc2VTaGlmdCgpO1xuXG4gICAgb3BlcmF0b3JzID0ge1xuICAgICAgJz09JzogJ2VxdWFsJyxcbiAgICAgICchPSc6ICd1bmVxdWFsJyxcbiAgICAgICc8JzogJ3NtYWxsZXInLFxuICAgICAgJz4nOiAnbGFyZ2VyJyxcbiAgICAgICc8PSc6ICdzbWFsbGVyRXEnLFxuICAgICAgJz49JzogJ2xhcmdlckVxJ1xuICAgIH07XG4gICAgd2hpbGUgKHRva2VuIGluIG9wZXJhdG9ycykge1xuICAgICAgbmFtZSA9IHRva2VuO1xuICAgICAgZm4gPSBvcGVyYXRvcnNbbmFtZV07XG5cbiAgICAgIGdldFRva2VuU2tpcE5ld2xpbmUoKTtcbiAgICAgIHBhcmFtcyA9IFtub2RlLCBwYXJzZVNoaWZ0KCldO1xuICAgICAgbm9kZSA9IG5ldyBPcGVyYXRvck5vZGUobmFtZSwgZm4sIHBhcmFtcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICAvKipcbiAgICogQml0d2lzZSBsZWZ0IHNoaWZ0LCBiaXR3aXNlIHJpZ2h0IGFyaXRobWV0aWMgc2hpZnQsIGJpdHdpc2UgcmlnaHQgbG9naWNhbCBzaGlmdFxuICAgKiBAcmV0dXJuIHtOb2RlfSBub2RlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZVNoaWZ0ICgpIHtcbiAgICB2YXIgbm9kZSwgb3BlcmF0b3JzLCBuYW1lLCBmbiwgcGFyYW1zO1xuXG4gICAgbm9kZSA9IHBhcnNlQ29udmVyc2lvbigpO1xuXG4gICAgb3BlcmF0b3JzID0ge1xuICAgICAgJzw8JyA6ICdsZWZ0U2hpZnQnLFxuICAgICAgJz4+JyA6ICdyaWdodEFyaXRoU2hpZnQnLFxuICAgICAgJz4+PicgOiAncmlnaHRMb2dTaGlmdCdcbiAgICB9O1xuXG4gICAgd2hpbGUgKHRva2VuIGluIG9wZXJhdG9ycykge1xuICAgICAgbmFtZSA9IHRva2VuO1xuICAgICAgZm4gPSBvcGVyYXRvcnNbbmFtZV07XG5cbiAgICAgIGdldFRva2VuU2tpcE5ld2xpbmUoKTtcbiAgICAgIHBhcmFtcyA9IFtub2RlLCBwYXJzZUNvbnZlcnNpb24oKV07XG4gICAgICBub2RlID0gbmV3IE9wZXJhdG9yTm9kZShuYW1lLCBmbiwgcGFyYW1zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBjb252ZXJzaW9uIG9wZXJhdG9ycyAndG8nIGFuZCAnaW4nXG4gICAqIEByZXR1cm4ge05vZGV9IG5vZGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlQ29udmVyc2lvbiAoKSB7XG4gICAgdmFyIG5vZGUsIG9wZXJhdG9ycywgbmFtZSwgZm4sIHBhcmFtcztcblxuICAgIG5vZGUgPSBwYXJzZVJhbmdlKCk7XG5cbiAgICBvcGVyYXRvcnMgPSB7XG4gICAgICAndG8nIDogJ3RvJyxcbiAgICAgICdpbicgOiAndG8nICAgLy8gYWxpYXMgb2YgJ3RvJ1xuICAgIH07XG5cbiAgICB3aGlsZSAodG9rZW4gaW4gb3BlcmF0b3JzKSB7XG4gICAgICBuYW1lID0gdG9rZW47XG4gICAgICBmbiA9IG9wZXJhdG9yc1tuYW1lXTtcblxuICAgICAgZ2V0VG9rZW5Ta2lwTmV3bGluZSgpO1xuICAgICAgcGFyYW1zID0gW25vZGUsIHBhcnNlUmFuZ2UoKV07XG4gICAgICBub2RlID0gbmV3IE9wZXJhdG9yTm9kZShuYW1lLCBmbiwgcGFyYW1zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBwYXJzZSByYW5nZSwgXCJzdGFydDplbmRcIiwgXCJzdGFydDpzdGVwOmVuZFwiLCBcIjpcIiwgXCJzdGFydDpcIiwgXCI6ZW5kXCIsIGV0Y1xuICAgKiBAcmV0dXJuIHtOb2RlfSBub2RlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZVJhbmdlICgpIHtcbiAgICB2YXIgbm9kZSwgcGFyYW1zID0gW107XG5cbiAgICBpZiAodG9rZW4gPT0gJzonKSB7XG4gICAgICAvLyBpbXBsaWNpdCBzdGFydD0xIChvbmUtYmFzZWQpXG4gICAgICBub2RlID0gbmV3IENvbnN0YW50Tm9kZSgnMScsICdudW1iZXInKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBleHBsaWNpdCBzdGFydFxuICAgICAgbm9kZSA9IHBhcnNlQWRkU3VidHJhY3QoKTtcbiAgICB9XG5cbiAgICBpZiAodG9rZW4gPT0gJzonICYmIChjb25kaXRpb25hbF9sZXZlbCAhPT0gbmVzdGluZ19sZXZlbCkpIHtcbiAgICAgIC8vIHdlIGlnbm9yZSB0aGUgcmFuZ2Ugb3BlcmF0b3Igd2hlbiBhIGNvbmRpdGlvbmFsIG9wZXJhdG9yIGlzIGJlaW5nIHByb2Nlc3NlZCBvbiB0aGUgc2FtZSBsZXZlbFxuICAgICAgcGFyYW1zLnB1c2gobm9kZSk7XG5cbiAgICAgIC8vIHBhcnNlIHN0ZXAgYW5kIGVuZFxuICAgICAgd2hpbGUgKHRva2VuID09ICc6JyAmJiBwYXJhbXMubGVuZ3RoIDwgMykge1xuICAgICAgICBnZXRUb2tlblNraXBOZXdsaW5lKCk7XG5cbiAgICAgICAgaWYgKHRva2VuID09ICcpJyB8fCB0b2tlbiA9PSAnXScgfHwgdG9rZW4gPT0gJywnIHx8IHRva2VuID09ICcnKSB7XG4gICAgICAgICAgLy8gaW1wbGljaXQgZW5kXG4gICAgICAgICAgcGFyYW1zLnB1c2gobmV3IFN5bWJvbE5vZGUoJ2VuZCcpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBleHBsaWNpdCBlbmRcbiAgICAgICAgICBwYXJhbXMucHVzaChwYXJzZUFkZFN1YnRyYWN0KCkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMubGVuZ3RoID09IDMpIHtcbiAgICAgICAgLy8gcGFyYW1zID0gW3N0YXJ0LCBzdGVwLCBlbmRdXG4gICAgICAgIG5vZGUgPSBuZXcgUmFuZ2VOb2RlKHBhcmFtc1swXSwgcGFyYW1zWzJdLCBwYXJhbXNbMV0pOyAvLyBzdGFydCwgZW5kLCBzdGVwXG4gICAgICB9XG4gICAgICBlbHNlIHsgLy8gbGVuZ3RoID09IDJcbiAgICAgICAgLy8gcGFyYW1zID0gW3N0YXJ0LCBlbmRdXG4gICAgICAgIG5vZGUgPSBuZXcgUmFuZ2VOb2RlKHBhcmFtc1swXSwgcGFyYW1zWzFdKTsgLy8gc3RhcnQsIGVuZFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIGFkZCBvciBzdWJ0cmFjdFxuICAgKiBAcmV0dXJuIHtOb2RlfSBub2RlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZUFkZFN1YnRyYWN0ICgpICB7XG4gICAgdmFyIG5vZGUsIG9wZXJhdG9ycywgbmFtZSwgZm4sIHBhcmFtcztcblxuICAgIG5vZGUgPSBwYXJzZU11bHRpcGx5RGl2aWRlKCk7XG5cbiAgICBvcGVyYXRvcnMgPSB7XG4gICAgICAnKyc6ICdhZGQnLFxuICAgICAgJy0nOiAnc3VidHJhY3QnXG4gICAgfTtcbiAgICB3aGlsZSAodG9rZW4gaW4gb3BlcmF0b3JzKSB7XG4gICAgICBuYW1lID0gdG9rZW47XG4gICAgICBmbiA9IG9wZXJhdG9yc1tuYW1lXTtcblxuICAgICAgZ2V0VG9rZW5Ta2lwTmV3bGluZSgpO1xuICAgICAgcGFyYW1zID0gW25vZGUsIHBhcnNlTXVsdGlwbHlEaXZpZGUoKV07XG4gICAgICBub2RlID0gbmV3IE9wZXJhdG9yTm9kZShuYW1lLCBmbiwgcGFyYW1zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBtdWx0aXBseSwgZGl2aWRlLCBtb2R1bHVzXG4gICAqIEByZXR1cm4ge05vZGV9IG5vZGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlTXVsdGlwbHlEaXZpZGUgKCkge1xuICAgIHZhciBub2RlLCBsYXN0LCBvcGVyYXRvcnMsIG5hbWUsIGZuO1xuXG4gICAgbm9kZSA9IHBhcnNlVW5hcnkoKTtcbiAgICBsYXN0ID0gbm9kZTtcblxuICAgIG9wZXJhdG9ycyA9IHtcbiAgICAgICcqJzogJ211bHRpcGx5JyxcbiAgICAgICcuKic6ICdkb3RNdWx0aXBseScsXG4gICAgICAnLyc6ICdkaXZpZGUnLFxuICAgICAgJy4vJzogJ2RvdERpdmlkZScsXG4gICAgICAnJSc6ICdtb2QnLFxuICAgICAgJ21vZCc6ICdtb2QnXG4gICAgfTtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAodG9rZW4gaW4gb3BlcmF0b3JzKSB7XG4gICAgICAgIC8vIGV4cGxpY2l0IG9wZXJhdG9yc1xuICAgICAgICBuYW1lID0gdG9rZW47XG4gICAgICAgIGZuID0gb3BlcmF0b3JzW25hbWVdO1xuXG4gICAgICAgIGdldFRva2VuU2tpcE5ld2xpbmUoKTtcblxuICAgICAgICBsYXN0ID0gcGFyc2VVbmFyeSgpO1xuICAgICAgICBub2RlID0gbmV3IE9wZXJhdG9yTm9kZShuYW1lLCBmbiwgW25vZGUsIGxhc3RdKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCh0b2tlbl90eXBlID09IFRPS0VOVFlQRS5TWU1CT0wpIHx8XG4gICAgICAgICAgKHRva2VuID09ICdpbicgJiYgKG5vZGUgJiYgbm9kZS5pc0NvbnN0YW50Tm9kZSkpIHx8XG4gICAgICAgICAgKHRva2VuX3R5cGUgPT0gVE9LRU5UWVBFLk5VTUJFUiAmJiAhbGFzdC5pc0NvbnN0YW50Tm9kZSkgfHxcbiAgICAgICAgICAodG9rZW4gPT0gJygnKSkge1xuICAgICAgICAvLyBwYXJzZSBpbXBsaWNpdCBtdWx0aXBsaWNhdGlvblxuICAgICAgICAvL1xuICAgICAgICAvLyBzeW1ib2w6ICAgICAgaW1wbGljaXQgbXVsdGlwbGljYXRpb24gbGlrZSAnMmEnLCAnKDIrMylhJywgJ2EgYidcbiAgICAgICAgLy8gbnVtYmVyOiAgICAgIGltcGxpY2l0IG11bHRpcGxpY2F0aW9uIGxpa2UgJygyKzMpMidcbiAgICAgICAgLy8gcGFyZW50aGVzaXM6IGltcGxpY2l0IG11bHRpcGxpY2F0aW9uIGxpa2UgJzIoMys0KScsICcoMys0KSgxKzIpJ1xuICAgICAgICBsYXN0ID0gcGFyc2VVbmFyeSgpO1xuICAgICAgICBub2RlID0gbmV3IE9wZXJhdG9yTm9kZSgnKicsICdtdWx0aXBseScsIFtub2RlLCBsYXN0XSwgdHJ1ZSAvKmltcGxpY2l0Ki8pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIFVuYXJ5IHBsdXMgYW5kIG1pbnVzLCBhbmQgbG9naWNhbCBhbmQgYml0d2lzZSBub3RcbiAgICogQHJldHVybiB7Tm9kZX0gbm9kZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VVbmFyeSAoKSB7XG4gICAgdmFyIG5hbWUsIHBhcmFtcztcbiAgICB2YXIgZm4gPSB7XG4gICAgICAnLSc6ICd1bmFyeU1pbnVzJyxcbiAgICAgICcrJzogJ3VuYXJ5UGx1cycsXG4gICAgICAnfic6ICdiaXROb3QnLFxuICAgICAgJ25vdCc6ICdub3QnXG4gICAgfVt0b2tlbl07XG5cbiAgICBpZiAoZm4pIHtcbiAgICAgIG5hbWUgPSB0b2tlbjtcblxuICAgICAgZ2V0VG9rZW5Ta2lwTmV3bGluZSgpO1xuICAgICAgcGFyYW1zID0gW3BhcnNlVW5hcnkoKV07XG5cbiAgICAgIHJldHVybiBuZXcgT3BlcmF0b3JOb2RlKG5hbWUsIGZuLCBwYXJhbXMpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZVBvdygpO1xuICB9XG5cbiAgLyoqXG4gICAqIHBvd2VyXG4gICAqIE5vdGU6IHBvd2VyIG9wZXJhdG9yIGlzIHJpZ2h0IGFzc29jaWF0aXZlXG4gICAqIEByZXR1cm4ge05vZGV9IG5vZGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlUG93ICgpIHtcbiAgICB2YXIgbm9kZSwgbmFtZSwgZm4sIHBhcmFtcztcblxuICAgIG5vZGUgPSBwYXJzZUxlZnRIYW5kT3BlcmF0b3JzKCk7XG5cbiAgICBpZiAodG9rZW4gPT0gJ14nIHx8IHRva2VuID09ICcuXicpIHtcbiAgICAgIG5hbWUgPSB0b2tlbjtcbiAgICAgIGZuID0gKG5hbWUgPT0gJ14nKSA/ICdwb3cnIDogJ2RvdFBvdyc7XG5cbiAgICAgIGdldFRva2VuU2tpcE5ld2xpbmUoKTtcbiAgICAgIHBhcmFtcyA9IFtub2RlLCBwYXJzZVVuYXJ5KCldOyAvLyBHbyBiYWNrIHRvIHVuYXJ5LCB3ZSBjYW4gaGF2ZSAnMl4tMydcbiAgICAgIG5vZGUgPSBuZXcgT3BlcmF0b3JOb2RlKG5hbWUsIGZuLCBwYXJhbXMpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIExlZnQgaGFuZCBvcGVyYXRvcnM6IGZhY3RvcmlhbCB4ISwgdHJhbnNwb3NlIHgnXG4gICAqIEByZXR1cm4ge05vZGV9IG5vZGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlTGVmdEhhbmRPcGVyYXRvcnMgKCkgIHtcbiAgICB2YXIgbm9kZSwgb3BlcmF0b3JzLCBuYW1lLCBmbiwgcGFyYW1zO1xuXG4gICAgbm9kZSA9IHBhcnNlQ3VzdG9tTm9kZXMoKTtcblxuICAgIG9wZXJhdG9ycyA9IHtcbiAgICAgICchJzogJ2ZhY3RvcmlhbCcsXG4gICAgICAnXFwnJzogJ3RyYW5zcG9zZSdcbiAgICB9O1xuXG4gICAgd2hpbGUgKHRva2VuIGluIG9wZXJhdG9ycykge1xuICAgICAgbmFtZSA9IHRva2VuO1xuICAgICAgZm4gPSBvcGVyYXRvcnNbbmFtZV07XG5cbiAgICAgIGdldFRva2VuKCk7XG4gICAgICBwYXJhbXMgPSBbbm9kZV07XG5cbiAgICAgIG5vZGUgPSBuZXcgT3BlcmF0b3JOb2RlKG5hbWUsIGZuLCBwYXJhbXMpO1xuICAgICAgbm9kZSA9IHBhcnNlQWNjZXNzb3JzKG5vZGUpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGEgY3VzdG9tIG5vZGUgaGFuZGxlci4gQSBub2RlIGhhbmRsZXIgY2FuIGJlIHVzZWQgdG8gcHJvY2Vzc1xuICAgKiBub2RlcyBpbiBhIGN1c3RvbSB3YXksIGZvciBleGFtcGxlIGZvciBoYW5kbGluZyBhIHBsb3QuXG4gICAqXG4gICAqIEEgaGFuZGxlciBtdXN0IGJlIHBhc3NlZCBhcyBzZWNvbmQgYXJndW1lbnQgb2YgdGhlIHBhcnNlIGZ1bmN0aW9uLlxuICAgKiAtIG11c3QgZXh0ZW5kIG1hdGguZXhwcmVzc2lvbi5ub2RlLk5vZGVcbiAgICogLSBtdXN0IGNvbnRhaW4gYSBmdW5jdGlvbiBfY29tcGlsZShkZWZzOiBPYmplY3QpIDogc3RyaW5nXG4gICAqIC0gbXVzdCBjb250YWluIGEgZnVuY3Rpb24gZmluZChmaWx0ZXI6IE9iamVjdCkgOiBOb2RlW11cbiAgICogLSBtdXN0IGNvbnRhaW4gYSBmdW5jdGlvbiB0b1N0cmluZygpIDogc3RyaW5nXG4gICAqIC0gdGhlIGNvbnN0cnVjdG9yIGlzIGNhbGxlZCB3aXRoIGEgc2luZ2xlIGFyZ3VtZW50IGNvbnRhaW5pbmcgYWxsIHBhcmFtZXRlcnNcbiAgICpcbiAgICogRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqICAgICBub2RlcyA9IHtcbiAgICogICAgICAgJ3Bsb3QnOiBQbG90SGFuZGxlclxuICAgKiAgICAgfTtcbiAgICpcbiAgICogVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBoYW5kbGVyIGlzIGNhbGxlZCBhczpcbiAgICpcbiAgICogICAgIG5vZGUgPSBuZXcgUGxvdEhhbmRsZXIocGFyYW1zKTtcbiAgICpcbiAgICogVGhlIGhhbmRsZXIgd2lsbCBiZSBpbnZva2VkIHdoZW4gZXZhbHVhdGluZyBhbiBleHByZXNzaW9uIGxpa2U6XG4gICAqXG4gICAqICAgICBub2RlID0gbWF0aC5wYXJzZSgncGxvdChzaW4oeCksIHgpJywgbm9kZXMpO1xuICAgKlxuICAgKiBAcmV0dXJuIHtOb2RlfSBub2RlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZUN1c3RvbU5vZGVzICgpIHtcbiAgICB2YXIgcGFyYW1zID0gW10sIGhhbmRsZXI7XG5cbiAgICBpZiAodG9rZW5fdHlwZSA9PSBUT0tFTlRZUEUuU1lNQk9MICYmIGV4dHJhX25vZGVzW3Rva2VuXSkge1xuICAgICAgaGFuZGxlciA9IGV4dHJhX25vZGVzW3Rva2VuXTtcblxuICAgICAgZ2V0VG9rZW4oKTtcblxuICAgICAgLy8gcGFyc2UgcGFyYW1ldGVyc1xuICAgICAgaWYgKHRva2VuID09ICcoJykge1xuICAgICAgICBwYXJhbXMgPSBbXTtcblxuICAgICAgICBvcGVuUGFyYW1zKCk7XG4gICAgICAgIGdldFRva2VuKCk7XG5cbiAgICAgICAgaWYgKHRva2VuICE9ICcpJykge1xuICAgICAgICAgIHBhcmFtcy5wdXNoKHBhcnNlQXNzaWdubWVudCgpKTtcblxuICAgICAgICAgIC8vIHBhcnNlIGEgbGlzdCB3aXRoIHBhcmFtZXRlcnNcbiAgICAgICAgICB3aGlsZSAodG9rZW4gPT0gJywnKSB7XG4gICAgICAgICAgICBnZXRUb2tlbigpO1xuICAgICAgICAgICAgcGFyYW1zLnB1c2gocGFyc2VBc3NpZ25tZW50KCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b2tlbiAhPSAnKScpIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVTeW50YXhFcnJvcignUGFyZW50aGVzaXMgKSBleHBlY3RlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNsb3NlUGFyYW1zKCk7XG4gICAgICAgIGdldFRva2VuKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGNyZWF0ZSBhIG5ldyBub2RlIGhhbmRsZXJcbiAgICAgIC8vbm9pbnNwZWN0aW9uIEpTVmFsaWRhdGVUeXBlc1xuICAgICAgcmV0dXJuIG5ldyBoYW5kbGVyKHBhcmFtcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlU3ltYm9sKCk7XG4gIH1cblxuICAvKipcbiAgICogcGFyc2Ugc3ltYm9sczogZnVuY3Rpb25zLCB2YXJpYWJsZXMsIGNvbnN0YW50cywgdW5pdHNcbiAgICogQHJldHVybiB7Tm9kZX0gbm9kZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VTeW1ib2wgKCkge1xuICAgIHZhciBub2RlLCBuYW1lO1xuXG4gICAgaWYgKHRva2VuX3R5cGUgPT0gVE9LRU5UWVBFLlNZTUJPTCB8fFxuICAgICAgICAodG9rZW5fdHlwZSA9PSBUT0tFTlRZUEUuREVMSU1JVEVSICYmIHRva2VuIGluIE5BTUVEX0RFTElNSVRFUlMpKSB7XG4gICAgICBuYW1lID0gdG9rZW47XG5cbiAgICAgIGdldFRva2VuKCk7XG5cbiAgICAgIC8vIHBhcnNlIGZ1bmN0aW9uIHBhcmFtZXRlcnMgYW5kIG1hdHJpeCBpbmRleFxuICAgICAgbm9kZSA9IG5ldyBTeW1ib2xOb2RlKG5hbWUpO1xuICAgICAgbm9kZSA9IHBhcnNlQWNjZXNzb3JzKG5vZGUpO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlU3RyaW5nKCk7XG4gIH1cblxuICAvKipcbiAgICogcGFyc2UgYWNjZXNzb3JzOlxuICAgKiAtIGZ1bmN0aW9uIGludm9jYXRpb24gaW4gcm91bmQgYnJhY2tldHMgKC4uLiksIGZvciBleGFtcGxlIHNxcnQoMilcbiAgICogLSBpbmRleCBlbmNsb3NlZCBpbiBzcXVhcmUgYnJhY2tldHMgWy4uLl0sIGZvciBleGFtcGxlIEFbMiwzXVxuICAgKiAtIGRvdCBub3RhdGlvbiBmb3IgcHJvcGVydGllcywgbGlrZSBmb28uYmFyXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAgICBOb2RlIG9uIHdoaWNoIHRvIGFwcGx5IHRoZSBwYXJhbWV0ZXJzLiBJZiB0aGVyZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgYXJlIG5vIHBhcmFtZXRlcnMgaW4gdGhlIGV4cHJlc3Npb24sIHRoZSBub2RlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICBpdHNlbGYgaXMgcmV0dXJuZWRcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gW3R5cGVzXSAgRmlsdGVyIHRoZSB0eXBlcyBvZiBub3RhdGlvbnNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuIGJlIFsnKCcsICdbJywgJy4nXVxuICAgKiBAcmV0dXJuIHtOb2RlfSBub2RlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZUFjY2Vzc29ycyAobm9kZSwgdHlwZXMpIHtcbiAgICB2YXIgcGFyYW1zO1xuXG4gICAgd2hpbGUgKCh0b2tlbiA9PSAnKCcgfHwgdG9rZW4gPT0gJ1snIHx8IHRva2VuID09ICcuJykgJiZcbiAgICAgICAgKCF0eXBlcyB8fCB0eXBlcy5pbmRleE9mKHRva2VuKSAhPT0gLTEpKSB7XG4gICAgICBwYXJhbXMgPSBbXTtcblxuICAgICAgaWYgKHRva2VuID09ICcoJykge1xuICAgICAgICBpZiAobm9kZS5pc1N5bWJvbE5vZGUgfHwgbm9kZS5pc0FjY2Vzc29yTm9kZSkge1xuICAgICAgICAgIC8vIGZ1bmN0aW9uIGludm9jYXRpb24gbGlrZSBmbigyLCAzKVxuICAgICAgICAgIG9wZW5QYXJhbXMoKTtcbiAgICAgICAgICBnZXRUb2tlbigpO1xuXG4gICAgICAgICAgaWYgKHRva2VuICE9ICcpJykge1xuICAgICAgICAgICAgcGFyYW1zLnB1c2gocGFyc2VBc3NpZ25tZW50KCkpO1xuXG4gICAgICAgICAgICAvLyBwYXJzZSBhIGxpc3Qgd2l0aCBwYXJhbWV0ZXJzXG4gICAgICAgICAgICB3aGlsZSAodG9rZW4gPT0gJywnKSB7XG4gICAgICAgICAgICAgIGdldFRva2VuKCk7XG4gICAgICAgICAgICAgIHBhcmFtcy5wdXNoKHBhcnNlQXNzaWdubWVudCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodG9rZW4gIT0gJyknKSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVTeW50YXhFcnJvcignUGFyZW50aGVzaXMgKSBleHBlY3RlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjbG9zZVBhcmFtcygpO1xuICAgICAgICAgIGdldFRva2VuKCk7XG5cbiAgICAgICAgICBub2RlID0gbmV3IEZ1bmN0aW9uTm9kZShub2RlLCBwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIGltcGxpY2l0IG11bHRpcGxpY2F0aW9uIGxpa2UgKDIrMykoNCs1KVxuICAgICAgICAgIC8vIG5leHQgcGFyc2Ugb3BlcmF0aW9uIGlzIHBhcnNlVW5hcnksIHRoZSBvbmUgYWZ0ZXIgcGFyc2VNdWx0aXBseURpdmlkZVxuICAgICAgICAgIG5vZGUgPSBuZXcgT3BlcmF0b3JOb2RlKCcqJywgJ211bHRpcGx5JywgW25vZGUsIHBhcnNlVW5hcnkoKV0sIHRydWUgLyppbXBsaWNpdCovKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAodG9rZW4gPT0gJ1snKSB7XG4gICAgICAgIC8vIGluZGV4IG5vdGF0aW9uIGxpa2UgdmFyaWFibGVbMiwgM11cbiAgICAgICAgb3BlblBhcmFtcygpO1xuICAgICAgICBnZXRUb2tlbigpO1xuXG4gICAgICAgIGlmICh0b2tlbiAhPSAnXScpIHtcbiAgICAgICAgICBwYXJhbXMucHVzaChwYXJzZUFzc2lnbm1lbnQoKSk7XG5cbiAgICAgICAgICAvLyBwYXJzZSBhIGxpc3Qgd2l0aCBwYXJhbWV0ZXJzXG4gICAgICAgICAgd2hpbGUgKHRva2VuID09ICcsJykge1xuICAgICAgICAgICAgZ2V0VG9rZW4oKTtcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKHBhcnNlQXNzaWdubWVudCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9rZW4gIT0gJ10nKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlU3ludGF4RXJyb3IoJ1BhcmVudGhlc2lzIF0gZXhwZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBjbG9zZVBhcmFtcygpO1xuICAgICAgICBnZXRUb2tlbigpO1xuXG4gICAgICAgIG5vZGUgPSBuZXcgQWNjZXNzb3JOb2RlKG5vZGUsIG5ldyBJbmRleE5vZGUocGFyYW1zKSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gZG90IG5vdGF0aW9uIGxpa2UgdmFyaWFibGUucHJvcFxuICAgICAgICBnZXRUb2tlbigpO1xuXG4gICAgICAgIGlmICh0b2tlbl90eXBlICE9IFRPS0VOVFlQRS5TWU1CT0wpIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVTeW50YXhFcnJvcignUHJvcGVydHkgbmFtZSBleHBlY3RlZCBhZnRlciBkb3QnKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMucHVzaChuZXcgQ29uc3RhbnROb2RlKHRva2VuKSk7XG4gICAgICAgIGdldFRva2VuKCk7XG5cbiAgICAgICAgdmFyIGRvdE5vdGF0aW9uID0gdHJ1ZTtcbiAgICAgICAgbm9kZSA9IG5ldyBBY2Nlc3Nvck5vZGUobm9kZSwgbmV3IEluZGV4Tm9kZShwYXJhbXMsIGRvdE5vdGF0aW9uKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICAvKipcbiAgICogcGFyc2UgYSBzdHJpbmcuXG4gICAqIEEgc3RyaW5nIGlzIGVuY2xvc2VkIGJ5IGRvdWJsZSBxdW90ZXNcbiAgICogQHJldHVybiB7Tm9kZX0gbm9kZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VTdHJpbmcgKCkge1xuICAgIHZhciBub2RlLCBzdHI7XG5cbiAgICBpZiAodG9rZW4gPT0gJ1wiJykge1xuICAgICAgc3RyID0gcGFyc2VTdHJpbmdUb2tlbigpO1xuXG4gICAgICAvLyBjcmVhdGUgY29uc3RhbnRcbiAgICAgIG5vZGUgPSBuZXcgQ29uc3RhbnROb2RlKHN0ciwgJ3N0cmluZycpO1xuXG4gICAgICAvLyBwYXJzZSBpbmRleCBwYXJhbWV0ZXJzXG4gICAgICBub2RlID0gcGFyc2VBY2Nlc3NvcnMobm9kZSk7XG5cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZU1hdHJpeCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGEgc3RyaW5nIHN1cnJvdW5kZWQgYnkgZG91YmxlIHF1b3RlcyBcIi4uLlwiXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlU3RyaW5nVG9rZW4gKCkge1xuICAgIHZhciBzdHIgPSAnJztcbiAgICB2YXIgdFByZXYgPSAnJztcblxuICAgIHdoaWxlIChjICE9ICcnICYmIChjICE9ICdcXFwiJyB8fCB0UHJldiA9PSAnXFxcXCcpKSB7IC8vIGFsc28gaGFuZGxlIGVzY2FwZSBjaGFyYWN0ZXJcbiAgICAgIHN0ciArPSBjO1xuICAgICAgdFByZXYgPSBjO1xuICAgICAgbmV4dCgpO1xuICAgIH1cblxuICAgIGdldFRva2VuKCk7XG4gICAgaWYgKHRva2VuICE9ICdcIicpIHtcbiAgICAgIHRocm93IGNyZWF0ZVN5bnRheEVycm9yKCdFbmQgb2Ygc3RyaW5nIFwiIGV4cGVjdGVkJyk7XG4gICAgfVxuICAgIGdldFRva2VuKCk7XG5cbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgLyoqXG4gICAqIHBhcnNlIHRoZSBtYXRyaXhcbiAgICogQHJldHVybiB7Tm9kZX0gbm9kZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VNYXRyaXggKCkge1xuICAgIHZhciBhcnJheSwgcGFyYW1zLCByb3dzLCBjb2xzO1xuXG4gICAgaWYgKHRva2VuID09ICdbJykge1xuICAgICAgLy8gbWF0cml4IFsuLi5dXG4gICAgICBvcGVuUGFyYW1zKCk7XG4gICAgICBnZXRUb2tlbigpO1xuXG4gICAgICBpZiAodG9rZW4gIT0gJ10nKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgYSBub24tZW1wdHkgbWF0cml4XG4gICAgICAgIHZhciByb3cgPSBwYXJzZVJvdygpO1xuXG4gICAgICAgIGlmICh0b2tlbiA9PSAnOycpIHtcbiAgICAgICAgICAvLyAyIGRpbWVuc2lvbmFsIGFycmF5XG4gICAgICAgICAgcm93cyA9IDE7XG4gICAgICAgICAgcGFyYW1zID0gW3Jvd107XG5cbiAgICAgICAgICAvLyB0aGUgcm93cyBvZiB0aGUgbWF0cml4IGFyZSBzZXBhcmF0ZWQgYnkgZG90LWNvbW1hJ3NcbiAgICAgICAgICB3aGlsZSAodG9rZW4gPT0gJzsnKSB7XG4gICAgICAgICAgICBnZXRUb2tlbigpO1xuXG4gICAgICAgICAgICBwYXJhbXNbcm93c10gPSBwYXJzZVJvdygpO1xuICAgICAgICAgICAgcm93cysrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0b2tlbiAhPSAnXScpIHtcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZVN5bnRheEVycm9yKCdFbmQgb2YgbWF0cml4IF0gZXhwZWN0ZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2xvc2VQYXJhbXMoKTtcbiAgICAgICAgICBnZXRUb2tlbigpO1xuXG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIG51bWJlciBvZiBjb2x1bW5zIG1hdGNoZXMgaW4gYWxsIHJvd3NcbiAgICAgICAgICBjb2xzID0gcGFyYW1zWzBdLml0ZW1zLmxlbmd0aDtcbiAgICAgICAgICBmb3IgKHZhciByID0gMTsgciA8IHJvd3M7IHIrKykge1xuICAgICAgICAgICAgaWYgKHBhcmFtc1tyXS5pdGVtcy5sZW5ndGggIT0gY29scykge1xuICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcignQ29sdW1uIGRpbWVuc2lvbnMgbWlzbWF0Y2ggJyArXG4gICAgICAgICAgICAgICAgICAnKCcgKyBwYXJhbXNbcl0uaXRlbXMubGVuZ3RoICsgJyAhPSAnICsgY29scyArICcpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXJyYXkgPSBuZXcgQXJyYXlOb2RlKHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgLy8gMSBkaW1lbnNpb25hbCB2ZWN0b3JcbiAgICAgICAgICBpZiAodG9rZW4gIT0gJ10nKSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVTeW50YXhFcnJvcignRW5kIG9mIG1hdHJpeCBdIGV4cGVjdGVkJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsb3NlUGFyYW1zKCk7XG4gICAgICAgICAgZ2V0VG9rZW4oKTtcblxuICAgICAgICAgIGFycmF5ID0gcm93O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gdGhpcyBpcyBhbiBlbXB0eSBtYXRyaXggXCJbIF1cIlxuICAgICAgICBjbG9zZVBhcmFtcygpO1xuICAgICAgICBnZXRUb2tlbigpO1xuICAgICAgICBhcnJheSA9IG5ldyBBcnJheU5vZGUoW10pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyc2VBY2Nlc3NvcnMoYXJyYXkpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZU9iamVjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGEgc2luZ2xlIGNvbW1hLXNlcGFyYXRlZCByb3cgZnJvbSBhIG1hdHJpeCwgbGlrZSAnYSwgYiwgYydcbiAgICogQHJldHVybiB7QXJyYXlOb2RlfSBub2RlXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZVJvdyAoKSB7XG4gICAgdmFyIHBhcmFtcyA9IFtwYXJzZUFzc2lnbm1lbnQoKV07XG4gICAgdmFyIGxlbiA9IDE7XG5cbiAgICB3aGlsZSAodG9rZW4gPT0gJywnKSB7XG4gICAgICBnZXRUb2tlbigpO1xuXG4gICAgICAvLyBwYXJzZSBleHByZXNzaW9uXG4gICAgICBwYXJhbXNbbGVuXSA9IHBhcnNlQXNzaWdubWVudCgpO1xuICAgICAgbGVuKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBBcnJheU5vZGUocGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBwYXJzZSBhbiBvYmplY3QsIGVuY2xvc2VkIGluIGFuZ2xlIGJyYWNrZXRzey4uLn0sIGZvciBleGFtcGxlIHt2YWx1ZTogMn1cbiAgICogQHJldHVybiB7Tm9kZX0gbm9kZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VPYmplY3QgKCkge1xuICAgIGlmICh0b2tlbiA9PSAneycpIHtcbiAgICAgIHZhciBrZXk7XG5cbiAgICAgIHZhciBwcm9wZXJ0aWVzID0ge307XG4gICAgICBkbyB7XG4gICAgICAgIGdldFRva2VuKCk7XG5cbiAgICAgICAgaWYgKHRva2VuICE9ICd9Jykge1xuICAgICAgICAgIC8vIHBhcnNlIGtleVxuICAgICAgICAgIGlmICh0b2tlbiA9PSAnXCInKSB7XG4gICAgICAgICAgICBrZXkgPSBwYXJzZVN0cmluZ1Rva2VuKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHRva2VuX3R5cGUgPT0gVE9LRU5UWVBFLlNZTUJPTCkge1xuICAgICAgICAgICAga2V5ID0gdG9rZW47XG4gICAgICAgICAgICBnZXRUb2tlbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZVN5bnRheEVycm9yKCdTeW1ib2wgb3Igc3RyaW5nIGV4cGVjdGVkIGFzIG9iamVjdCBrZXknKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBwYXJzZSBrZXkvdmFsdWUgc2VwYXJhdG9yXG4gICAgICAgICAgaWYgKHRva2VuICE9ICc6Jykge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlU3ludGF4RXJyb3IoJ0NvbG9uIDogZXhwZWN0ZWQgYWZ0ZXIgb2JqZWN0IGtleScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBnZXRUb2tlbigpO1xuXG4gICAgICAgICAgLy8gcGFyc2Uga2V5XG4gICAgICAgICAgcHJvcGVydGllc1trZXldID0gcGFyc2VBc3NpZ25tZW50KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlICh0b2tlbiA9PSAnLCcpO1xuXG4gICAgICBpZiAodG9rZW4gIT0gJ30nKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZVN5bnRheEVycm9yKCdDb21tYSAsIG9yIGJyYWNrZXQgfSBleHBlY3RlZCBhZnRlciBvYmplY3QgdmFsdWUnKTtcbiAgICAgIH1cbiAgICAgIGdldFRva2VuKCk7XG5cbiAgICAgIHZhciBub2RlID0gbmV3IE9iamVjdE5vZGUocHJvcGVydGllcyk7XG5cbiAgICAgIC8vIHBhcnNlIGluZGV4IHBhcmFtZXRlcnNcbiAgICAgIG5vZGUgPSBwYXJzZUFjY2Vzc29ycyhub2RlKTtcblxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlTnVtYmVyKCk7XG4gIH1cblxuICAvKipcbiAgICogcGFyc2UgYSBudW1iZXJcbiAgICogQHJldHVybiB7Tm9kZX0gbm9kZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VOdW1iZXIgKCkge1xuICAgIHZhciBudW1iZXI7XG5cbiAgICBpZiAodG9rZW5fdHlwZSA9PSBUT0tFTlRZUEUuTlVNQkVSKSB7XG4gICAgICAvLyB0aGlzIGlzIGEgbnVtYmVyXG4gICAgICBudW1iZXIgPSB0b2tlbjtcbiAgICAgIGdldFRva2VuKCk7XG5cbiAgICAgIHJldHVybiBuZXcgQ29uc3RhbnROb2RlKG51bWJlciwgJ251bWJlcicpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZVBhcmVudGhlc2VzKCk7XG4gIH1cblxuICAvKipcbiAgICogcGFyZW50aGVzZXNcbiAgICogQHJldHVybiB7Tm9kZX0gbm9kZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VQYXJlbnRoZXNlcyAoKSB7XG4gICAgdmFyIG5vZGU7XG5cbiAgICAvLyBjaGVjayBpZiBpdCBpcyBhIHBhcmVudGhlc2l6ZWQgZXhwcmVzc2lvblxuICAgIGlmICh0b2tlbiA9PSAnKCcpIHtcbiAgICAgIC8vIHBhcmVudGhlc2VzICguLi4pXG4gICAgICBvcGVuUGFyYW1zKCk7XG4gICAgICBnZXRUb2tlbigpO1xuXG4gICAgICBub2RlID0gcGFyc2VBc3NpZ25tZW50KCk7IC8vIHN0YXJ0IGFnYWluXG5cbiAgICAgIGlmICh0b2tlbiAhPSAnKScpIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlU3ludGF4RXJyb3IoJ1BhcmVudGhlc2lzICkgZXhwZWN0ZWQnKTtcbiAgICAgIH1cbiAgICAgIGNsb3NlUGFyYW1zKCk7XG4gICAgICBnZXRUb2tlbigpO1xuXG4gICAgICBub2RlID0gbmV3IFBhcmVudGhlc2lzTm9kZShub2RlKTtcbiAgICAgIG5vZGUgPSBwYXJzZUFjY2Vzc29ycyhub2RlKTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZUVuZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV2YWx1YXRlZCB3aGVuIHRoZSBleHByZXNzaW9uIGlzIG5vdCB5ZXQgZW5kZWQgYnV0IGV4cGVjdGVkIHRvIGVuZFxuICAgKiBAcmV0dXJuIHtOb2RlfSByZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlRW5kICgpIHtcbiAgICBpZiAodG9rZW4gPT0gJycpIHtcbiAgICAgIC8vIHN5bnRheCBlcnJvciBvciB1bmV4cGVjdGVkIGVuZCBvZiBleHByZXNzaW9uXG4gICAgICB0aHJvdyBjcmVhdGVTeW50YXhFcnJvcignVW5leHBlY3RlZCBlbmQgb2YgZXhwcmVzc2lvbicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBjcmVhdGVTeW50YXhFcnJvcignVmFsdWUgZXhwZWN0ZWQnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2hvcnRjdXQgZm9yIGdldHRpbmcgdGhlIGN1cnJlbnQgcm93IHZhbHVlIChvbmUgYmFzZWQpXG4gICAqIFJldHVybnMgdGhlIGxpbmUgb2YgdGhlIGN1cnJlbnRseSBoYW5kbGVkIGV4cHJlc3Npb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIC8qIFRPRE86IGltcGxlbWVudCBrZWVwaW5nIHRyYWNrIG9uIHRoZSByb3cgbnVtYmVyXG4gIGZ1bmN0aW9uIHJvdyAoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgKi9cblxuICAvKipcbiAgICogU2hvcnRjdXQgZm9yIGdldHRpbmcgdGhlIGN1cnJlbnQgY29sIHZhbHVlIChvbmUgYmFzZWQpXG4gICAqIFJldHVybnMgdGhlIGNvbHVtbiAocG9zaXRpb24pIHdoZXJlIHRoZSBsYXN0IHRva2VuIHN0YXJ0c1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gY29sICgpIHtcbiAgICByZXR1cm4gaW5kZXggLSB0b2tlbi5sZW5ndGggKyAxO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBlcnJvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuICAgKiBAcmV0dXJuIHtTeW50YXhFcnJvcn0gaW5zdGFudGlhdGVkIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVTeW50YXhFcnJvciAobWVzc2FnZSkge1xuICAgIHZhciBjID0gY29sKCk7XG4gICAgdmFyIGVycm9yID0gbmV3IFN5bnRheEVycm9yKG1lc3NhZ2UgKyAnIChjaGFyICcgKyBjICsgJyknKTtcbiAgICBlcnJvclsnY2hhciddID0gYztcblxuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gZXJyb3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAgICogQHJldHVybiB7RXJyb3J9IGluc3RhbnRpYXRlZCBlcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlRXJyb3IgKG1lc3NhZ2UpIHtcbiAgICB2YXIgYyA9IGNvbCgpO1xuICAgIHZhciBlcnJvciA9IG5ldyBTeW50YXhFcnJvcihtZXNzYWdlICsgJyAoY2hhciAnICsgYyArICcpJyk7XG4gICAgZXJyb3JbJ2NoYXInXSA9IGM7XG5cbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cblxuICByZXR1cm4gcGFyc2U7XG59O1xuXG5leHBvcnRzLm5hbWUgPSAncGFyc2UnO1xuZXhwb3J0cy5wYXRoID0gJ2V4cHJlc3Npb24nO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGVycm9yVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9lcnJvci50cmFuc2Zvcm0nKS50cmFuc2Zvcm07XG5cbi8qKlxuICogQXR0YWNoIGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHRvIG1hdGgucmFuZ2VcbiAqIEFkZHMgYSBwcm9wZXJ0eSB0cmFuc2Zvcm0gY29udGFpbmluZyB0aGUgdHJhbnNmb3JtIGZ1bmN0aW9uLlxuICpcbiAqIFRoaXMgdHJhbnNmb3JtIGNoYW5nZWQgdGhlIGxhc3QgYGRpbWAgcGFyYW1ldGVyIG9mIGZ1bmN0aW9uIGNvbmNhdFxuICogZnJvbSBvbmUtYmFzZWQgdG8gemVybyBiYXNlZFxuICovXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBjb25jYXQgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL2Z1bmN0aW9uL21hdHJpeC9jb25jYXQnKSk7XG5cbiAgLy8gQHNlZTogY29tbWVudCBvZiBjb25jYXQgaXRzZWxmXG4gcmV0dXJuIHR5cGVkKCdjb25jYXQnLCB7XG4gICAgJy4uLmFueSc6IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAvLyBjaGFuZ2UgbGFzdCBhcmd1bWVudCBmcm9tIG9uZS1iYXNlZCB0byB6ZXJvLWJhc2VkXG4gICAgICB2YXIgbGFzdEluZGV4ID0gYXJncy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGxhc3QgPSBhcmdzW2xhc3RJbmRleF07XG4gICAgICBpZiAodHlwZW9mIGxhc3QgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGFyZ3NbbGFzdEluZGV4XSA9IGxhc3QgLSAxO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobGFzdCAmJiBsYXN0LmlzQmlnTnVtYmVyID09PSB0cnVlKSB7XG4gICAgICAgIGFyZ3NbbGFzdEluZGV4XSA9IGxhc3QubWludXMoMSk7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjb25jYXQuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICB9XG4gICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IGVycm9yVHJhbnNmb3JtKGVycik7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2NvbmNhdCc7XG5leHBvcnRzLnBhdGggPSAnZXhwcmVzc2lvbi50cmFuc2Zvcm0nO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsInZhciBJbmRleEVycm9yID0gcmVxdWlyZSgnLi4vLi4vZXJyb3IvSW5kZXhFcnJvcicpO1xuXG4vKipcbiAqIFRyYW5zZm9ybSB6ZXJvLWJhc2VkIGluZGljZXMgdG8gb25lLWJhc2VkIGluZGljZXMgaW4gZXJyb3JzXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcbiAqIEByZXR1cm5zIHtFcnJvcn0gUmV0dXJucyB0aGUgdHJhbnNmb3JtZWQgZXJyb3JcbiAqL1xuZXhwb3J0cy50cmFuc2Zvcm0gPSBmdW5jdGlvbiAoZXJyKSB7XG4gIGlmIChlcnIgJiYgZXJyLmlzSW5kZXhFcnJvcikge1xuICAgIHJldHVybiBuZXcgSW5kZXhFcnJvcihcbiAgICAgICAgZXJyLmluZGV4ICsgMSxcbiAgICAgICAgZXJyLm1pbiArIDEsXG4gICAgICAgIGVyci5tYXggIT09IHVuZGVmaW5lZCA/IGVyci5tYXggKyAxIDogdW5kZWZpbmVkKTtcbiAgfVxuXG4gIHJldHVybiBlcnI7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEF0dGFjaCBhIHRyYW5zZm9ybSBmdW5jdGlvbiB0byBtYXRoLmZpbHRlclxuICogQWRkcyBhIHByb3BlcnR5IHRyYW5zZm9ybSBjb250YWluaW5nIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24uXG4gKlxuICogVGhpcyB0cmFuc2Zvcm0gYWRkcyBzdXBwb3J0IGZvciBlcXVhdGlvbnMgYXMgdGVzdCBmdW5jdGlvbiBmb3IgbWF0aC5maWx0ZXIsXG4gKiBzbyB5b3UgY2FuIGRvIHNvbWV0aGluZyBsaWtlICdmaWx0ZXIoWzMsIC0yLCA1XSwgeCA+IDApJy5cbiAqL1xuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgZmlsdGVyID0gbG9hZChyZXF1aXJlKCcuLi8uLi9mdW5jdGlvbi9tYXRyaXgvZmlsdGVyJykpO1xuICB2YXIgU3ltYm9sTm9kZSA9IGxvYWQocmVxdWlyZSgnLi4vbm9kZS9TeW1ib2xOb2RlJykpO1xuXG4gIGZ1bmN0aW9uIGZpbHRlclRyYW5zZm9ybShhcmdzLCBtYXRoLCBzY29wZSkge1xuICAgIHZhciB4LCB0ZXN0O1xuXG4gICAgaWYgKGFyZ3NbMF0pIHtcbiAgICAgIHggPSBhcmdzWzBdLmNvbXBpbGUoKS5ldmFsKHNjb3BlKTtcbiAgICB9XG5cbiAgICBpZiAoYXJnc1sxXSkge1xuICAgICAgaWYgKGFyZ3NbMV0gJiYgYXJnc1sxXS5pc1N5bWJvbE5vZGUpIHtcbiAgICAgICAgLy8gYSBmdW5jdGlvbiBwb2ludGVyLCBsaWtlIGZpbHRlcihbMywgLTIsIDVdLCBteVRlc3RGdW5jdGlvbik7XG4gICAgICAgIHRlc3QgPSBhcmdzWzFdLmNvbXBpbGUoKS5ldmFsKHNjb3BlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBhbiBlcXVhdGlvbiBsaWtlIGZpbHRlcihbMywgLTIsIDVdLCB4ID4gMClcblxuICAgICAgICAvLyBmaW5kIGFuIHVuZGVmaW5lZCBzeW1ib2xcbiAgICAgICAgdmFyIF9zY29wZSA9IHNjb3BlIHx8IHt9O1xuICAgICAgICB2YXIgc3ltYm9sID0gYXJnc1sxXVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICByZXR1cm4gKG5vZGUgJiYgbm9kZS5pc1N5bWJvbE5vZGUpICYmXG4gICAgICAgICAgICAgICAgICAhKG5vZGUubmFtZSBpbiBtYXRoKSAmJlxuICAgICAgICAgICAgICAgICAgIShub2RlLm5hbWUgaW4gX3Njb3BlKTtcbiAgICAgICAgICAgIH0pWzBdO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBhIHRlc3QgZnVuY3Rpb24gZm9yIHRoaXMgZXF1YXRpb25cbiAgICAgICAgdmFyIHN1YiA9IE9iamVjdC5jcmVhdGUoX3Njb3BlKTtcbiAgICAgICAgdmFyIGVxID0gYXJnc1sxXS5jb21waWxlKCk7XG4gICAgICAgIGlmIChzeW1ib2wpIHtcbiAgICAgICAgICB2YXIgbmFtZSA9IHN5bWJvbC5uYW1lO1xuICAgICAgICAgIHRlc3QgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgc3ViW25hbWVdID0geDtcbiAgICAgICAgICAgIHJldHVybiBlcS5ldmFsKHN1Yik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdW5kZWZpbmVkIHZhcmlhYmxlIGZvdW5kIGluIGZpbHRlciBlcXVhdGlvbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbHRlcih4LCB0ZXN0KTtcbiAgfVxuXG4gIGZpbHRlclRyYW5zZm9ybS5yYXdBcmdzID0gdHJ1ZTtcblxuICByZXR1cm4gZmlsdGVyVHJhbnNmb3JtO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnZmlsdGVyJztcbmV4cG9ydHMucGF0aCA9ICdleHByZXNzaW9uLnRyYW5zZm9ybSc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEF0dGFjaCBhIHRyYW5zZm9ybSBmdW5jdGlvbiB0byBtYXRoLmZvckVhY2hcbiAqIEFkZHMgYSBwcm9wZXJ0eSB0cmFuc2Zvcm0gY29udGFpbmluZyB0aGUgdHJhbnNmb3JtIGZ1bmN0aW9uLlxuICpcbiAqIFRoaXMgdHJhbnNmb3JtIGNyZWF0ZXMgYSBvbmUtYmFzZWQgaW5kZXggaW5zdGVhZCBvZiBhIHplcm8tYmFzZWQgaW5kZXhcbiAqL1xuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgZm9yRWFjaCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vZnVuY3Rpb24vbWF0cml4L2ZvckVhY2gnKSk7XG5cbiAgcmV0dXJuIHR5cGVkKCdmb3JFYWNoJywge1xuICAgICdBcnJheSB8IE1hdHJpeCwgZnVuY3Rpb24nOiBmdW5jdGlvbiAoYXJyYXksIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgcmVjdXJzZSA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQsIGkpIHtcbiAgICAgICAgICAgIC8vIHdlIGNyZWF0ZSBhIGNvcHkgb2YgdGhlIGluZGV4IGFycmF5IGFuZCBhcHBlbmQgdGhlIG5ldyBpbmRleCB2YWx1ZVxuICAgICAgICAgICAgcmVjdXJzZShjaGlsZCwgaW5kZXguY29uY2F0KGkgKyAxKSk7IC8vIG9uZSBiYXNlZCBpbmRleCwgaGVuY2UgaSsxXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2sodmFsdWUsIGluZGV4LCBhcnJheSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZWN1cnNlKGFycmF5LnZhbHVlT2YoKSwgW10pOyAvLyBwYXNzIEFycmF5XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2ZvckVhY2gnO1xuZXhwb3J0cy5wYXRoID0gJ2V4cHJlc3Npb24udHJhbnNmb3JtJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFtcbiAgcmVxdWlyZSgnLi9jb25jYXQudHJhbnNmb3JtJyksXG4gIHJlcXVpcmUoJy4vZmlsdGVyLnRyYW5zZm9ybScpLFxuICByZXF1aXJlKCcuL2ZvckVhY2gudHJhbnNmb3JtJyksXG4gIHJlcXVpcmUoJy4vaW5kZXgudHJhbnNmb3JtJyksXG4gIHJlcXVpcmUoJy4vbWFwLnRyYW5zZm9ybScpLFxuICByZXF1aXJlKCcuL21heC50cmFuc2Zvcm0nKSxcbiAgcmVxdWlyZSgnLi9tZWFuLnRyYW5zZm9ybScpLFxuICByZXF1aXJlKCcuL21pbi50cmFuc2Zvcm0nKSxcbiAgcmVxdWlyZSgnLi9yYW5nZS50cmFuc2Zvcm0nKSxcbiAgcmVxdWlyZSgnLi9zdWJzZXQudHJhbnNmb3JtJylcbl07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiBBdHRhY2ggYSB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gbWF0aC5pbmRleFxuICogQWRkcyBhIHByb3BlcnR5IHRyYW5zZm9ybSBjb250YWluaW5nIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24uXG4gKlxuICogVGhpcyB0cmFuc2Zvcm0gY3JlYXRlcyBhIG9uZS1iYXNlZCBpbmRleCBpbnN0ZWFkIG9mIGEgemVyby1iYXNlZCBpbmRleFxuICovXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQpIHtcbiAgdmFyIGluZGV4RmFjdG9yeSA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvZnVuY3Rpb24vaW5kZXgnKSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGluZGV4VHJhbnNmb3JtKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIC8vIGNoYW5nZSBmcm9tIG9uZS1iYXNlZCB0byB6ZXJvIGJhc2VkLCBhbmQgY29udmVydCBCaWdOdW1iZXIgdG8gbnVtYmVyXG4gICAgICBpZiAoYXJnICYmIGFyZy5pc1JhbmdlID09PSB0cnVlKSB7XG4gICAgICAgIGFyZy5zdGFydC0tO1xuICAgICAgICBhcmcuZW5kIC09IChhcmcuc3RlcCA+IDAgPyAwIDogMik7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhcmcgJiYgYXJnLmlzU2V0ID09PSB0cnVlKSB7XG4gICAgICAgIGFyZyA9IGFyZy5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYgLSAxOyB9KTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGFyZyAmJiAoYXJnLmlzQXJyYXkgPT09IHRydWUgfHwgYXJnLmlzTWF0cml4KSkge1xuICAgICAgICBhcmcgPSBhcmcubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2IC0gMTsgfSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgICAgICBhcmctLTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGFyZyAmJiBhcmcuaXNCaWdOdW1iZXIgPT09IHRydWUpIHtcbiAgICAgICAgYXJnID0gYXJnLnRvTnVtYmVyKCkgLSAxO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gbGVhdmUgYXMgaXNcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdEaW1lbnNpb24gbXVzdCBiZSBhbiBBcnJheSwgTWF0cml4LCBudW1iZXIsIHN0cmluZywgb3IgUmFuZ2UnKTtcbiAgICAgIH1cblxuICAgICAgYXJnc1tpXSA9IGFyZztcbiAgICB9XG5cbiAgICB2YXIgcmVzID0gbmV3IHR5cGUuSW5kZXgoKTtcbiAgICB0eXBlLkluZGV4LmFwcGx5KHJlcywgYXJncyk7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2luZGV4JztcbmV4cG9ydHMucGF0aCA9ICdleHByZXNzaW9uLnRyYW5zZm9ybSc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEF0dGFjaCBhIHRyYW5zZm9ybSBmdW5jdGlvbiB0byBtYXRoLm1hcFxuICogQWRkcyBhIHByb3BlcnR5IHRyYW5zZm9ybSBjb250YWluaW5nIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24uXG4gKlxuICogVGhpcyB0cmFuc2Zvcm0gY3JlYXRlcyBhIG9uZS1iYXNlZCBpbmRleCBpbnN0ZWFkIG9mIGEgemVyby1iYXNlZCBpbmRleFxuICovXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBtYXAgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL2Z1bmN0aW9uL21hdHJpeC9tYXAnKSk7XG4gIHZhciBtYXRyaXggPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L2Z1bmN0aW9uL21hdHJpeCcpKTtcblxuICByZXR1cm4gdHlwZWQoJ21heCcsIHtcbiAgICAnQXJyYXksIGZ1bmN0aW9uJzogZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gX21hcCh4LCBjYWxsYmFjaywgeCk7XG4gICAgfSxcblxuICAgICdNYXRyaXgsIGZ1bmN0aW9uJzogZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gbWF0cml4KF9tYXAoeC52YWx1ZU9mKCksIGNhbGxiYWNrLCB4KSk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBNYXAgZm9yIGEgbXVsdGkgZGltZW5zaW9uYWwgYXJyYXkuIE9uZS1iYXNlZCBpbmRleGVzXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7QXJyYXl9IG9yaWdcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX21hcCAoYXJyYXksIGNhbGxiYWNrLCBvcmlnKSB7XG4gIGZ1bmN0aW9uIHJlY3Vyc2UodmFsdWUsIGluZGV4KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWUubWFwKGZ1bmN0aW9uIChjaGlsZCwgaSkge1xuICAgICAgICAvLyB3ZSBjcmVhdGUgYSBjb3B5IG9mIHRoZSBpbmRleCBhcnJheSBhbmQgYXBwZW5kIHRoZSBuZXcgaW5kZXggdmFsdWVcbiAgICAgICAgcmV0dXJuIHJlY3Vyc2UoY2hpbGQsIGluZGV4LmNvbmNhdChpICsgMSkpOyAvLyBvbmUgYmFzZWQgaW5kZXgsIGhlbmNlIGkgKyAxXG4gICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sodmFsdWUsIGluZGV4LCBvcmlnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVjdXJzZShhcnJheSwgW10pO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnbWFwJztcbmV4cG9ydHMucGF0aCA9ICdleHByZXNzaW9uLnRyYW5zZm9ybSc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXJyb3JUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2Vycm9yLnRyYW5zZm9ybScpLnRyYW5zZm9ybTtcbnZhciBpc0NvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi91dGlscy9jb2xsZWN0aW9uL2lzQ29sbGVjdGlvbicpO1xuXG4vKipcbiAqIEF0dGFjaCBhIHRyYW5zZm9ybSBmdW5jdGlvbiB0byBtYXRoLm1heFxuICogQWRkcyBhIHByb3BlcnR5IHRyYW5zZm9ybSBjb250YWluaW5nIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24uXG4gKlxuICogVGhpcyB0cmFuc2Zvcm0gY2hhbmdlZCB0aGUgbGFzdCBgZGltYCBwYXJhbWV0ZXIgb2YgZnVuY3Rpb24gbWF4XG4gKiBmcm9tIG9uZS1iYXNlZCB0byB6ZXJvIGJhc2VkXG4gKi9cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIG1heCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vZnVuY3Rpb24vc3RhdGlzdGljcy9tYXgnKSk7XG5cbiAgcmV0dXJuIHR5cGVkKCdtYXgnLCB7XG4gICAgJy4uLmFueSc6IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAvLyBjaGFuZ2UgbGFzdCBhcmd1bWVudCBkaW0gZnJvbSBvbmUtYmFzZWQgdG8gemVyby1iYXNlZFxuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09IDIgJiYgaXNDb2xsZWN0aW9uKGFyZ3NbMF0pKSB7XG4gICAgICAgIHZhciBkaW0gPSBhcmdzWzFdO1xuICAgICAgICBpZiAodHlwZW9mIGRpbSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBhcmdzWzFdID0gZGltIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkaW0gJiYgZGltLmlzQmlnTnVtYmVyID09PSB0cnVlKSB7XG4gICAgICAgICAgYXJnc1sxXSA9IGRpbS5taW51cygxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbWF4LmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBlcnJvclRyYW5zZm9ybShlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdtYXgnO1xuZXhwb3J0cy5wYXRoID0gJ2V4cHJlc3Npb24udHJhbnNmb3JtJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBlcnJvclRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vZXJyb3IudHJhbnNmb3JtJykudHJhbnNmb3JtO1xudmFyIGlzQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vaXNDb2xsZWN0aW9uJyk7XG5cbi8qKlxuICogQXR0YWNoIGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHRvIG1hdGgubWVhblxuICogQWRkcyBhIHByb3BlcnR5IHRyYW5zZm9ybSBjb250YWluaW5nIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24uXG4gKlxuICogVGhpcyB0cmFuc2Zvcm0gY2hhbmdlZCB0aGUgbGFzdCBgZGltYCBwYXJhbWV0ZXIgb2YgZnVuY3Rpb24gbWVhblxuICogZnJvbSBvbmUtYmFzZWQgdG8gemVybyBiYXNlZFxuICovXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBtZWFuID0gbG9hZChyZXF1aXJlKCcuLi8uLi9mdW5jdGlvbi9zdGF0aXN0aWNzL21lYW4nKSk7XG5cbiAgcmV0dXJuIHR5cGVkKCdtZWFuJywge1xuICAgICcuLi5hbnknOiBmdW5jdGlvbiAoYXJncykge1xuICAgICAgLy8gY2hhbmdlIGxhc3QgYXJndW1lbnQgZGltIGZyb20gb25lLWJhc2VkIHRvIHplcm8tYmFzZWRcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PSAyICYmIGlzQ29sbGVjdGlvbihhcmdzWzBdKSkge1xuICAgICAgICB2YXIgZGltID0gYXJnc1sxXTtcbiAgICAgICAgaWYgKHR5cGVvZiBkaW0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgYXJnc1sxXSA9IGRpbSAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGltICYmIGRpbS5pc0JpZ051bWJlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGFyZ3NbMV0gPSBkaW0ubWludXMoMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1lYW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICB9XG4gICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IGVycm9yVHJhbnNmb3JtKGVycik7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ21lYW4nO1xuZXhwb3J0cy5wYXRoID0gJ2V4cHJlc3Npb24udHJhbnNmb3JtJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBlcnJvclRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vZXJyb3IudHJhbnNmb3JtJykudHJhbnNmb3JtO1xudmFyIGlzQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vaXNDb2xsZWN0aW9uJyk7XG5cbi8qKlxuICogQXR0YWNoIGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHRvIG1hdGgubWluXG4gKiBBZGRzIGEgcHJvcGVydHkgdHJhbnNmb3JtIGNvbnRhaW5pbmcgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbi5cbiAqXG4gKiBUaGlzIHRyYW5zZm9ybSBjaGFuZ2VkIHRoZSBsYXN0IGBkaW1gIHBhcmFtZXRlciBvZiBmdW5jdGlvbiBtaW5cbiAqIGZyb20gb25lLWJhc2VkIHRvIHplcm8gYmFzZWRcbiAqL1xuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgbWluID0gbG9hZChyZXF1aXJlKCcuLi8uLi9mdW5jdGlvbi9zdGF0aXN0aWNzL21pbicpKTtcblxuICByZXR1cm4gdHlwZWQoJ21pbicsIHtcbiAgICAnLi4uYW55JzogZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgIC8vIGNoYW5nZSBsYXN0IGFyZ3VtZW50IGRpbSBmcm9tIG9uZS1iYXNlZCB0byB6ZXJvLWJhc2VkXG4gICAgICBpZiAoYXJncy5sZW5ndGggPT0gMiAmJiBpc0NvbGxlY3Rpb24oYXJnc1swXSkpIHtcbiAgICAgICAgdmFyIGRpbSA9IGFyZ3NbMV07XG4gICAgICAgIGlmICh0eXBlb2YgZGltID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGFyZ3NbMV0gPSBkaW0gLSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRpbSAmJiBkaW0uaXNCaWdOdW1iZXIgPT09IHRydWUpIHtcbiAgICAgICAgICBhcmdzWzFdID0gZGltLm1pbnVzKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICB9XG4gICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IGVycm9yVHJhbnNmb3JtKGVycik7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ21pbic7XG5leHBvcnRzLnBhdGggPSAnZXhwcmVzc2lvbi50cmFuc2Zvcm0nO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBdHRhY2ggYSB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gbWF0aC5yYW5nZVxuICogQWRkcyBhIHByb3BlcnR5IHRyYW5zZm9ybSBjb250YWluaW5nIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24uXG4gKlxuICogVGhpcyB0cmFuc2Zvcm0gY3JlYXRlcyBhIHJhbmdlIHdoaWNoIGluY2x1ZGVzIHRoZSBlbmQgdmFsdWVcbiAqL1xuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgcmFuZ2UgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL2Z1bmN0aW9uL21hdHJpeC9yYW5nZScpKTtcblxuICByZXR1cm4gdHlwZWQoJ3JhbmdlJywge1xuICAgICcuLi5hbnknOiBmdW5jdGlvbiAoYXJncykge1xuICAgICAgdmFyIGxhc3RJbmRleCA9IGFyZ3MubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBsYXN0ID0gYXJnc1tsYXN0SW5kZXhdO1xuICAgICAgaWYgKHR5cGVvZiBsYXN0ICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgLy8gYXBwZW5kIGEgcGFyYW1ldGVyIGluY2x1ZGVFbmQ9dHJ1ZVxuICAgICAgICBhcmdzLnB1c2godHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByYW5nZS5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnRzLm5hbWUgPSAncmFuZ2UnO1xuZXhwb3J0cy5wYXRoID0gJ2V4cHJlc3Npb24udHJhbnNmb3JtJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBlcnJvclRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vZXJyb3IudHJhbnNmb3JtJykudHJhbnNmb3JtO1xuXG4vKipcbiAqIEF0dGFjaCBhIHRyYW5zZm9ybSBmdW5jdGlvbiB0byBtYXRoLnN1YnNldFxuICogQWRkcyBhIHByb3BlcnR5IHRyYW5zZm9ybSBjb250YWluaW5nIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24uXG4gKlxuICogVGhpcyB0cmFuc2Zvcm0gY3JlYXRlcyBhIHJhbmdlIHdoaWNoIGluY2x1ZGVzIHRoZSBlbmQgdmFsdWVcbiAqL1xuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgc3Vic2V0ID0gbG9hZChyZXF1aXJlKCcuLi8uLi9mdW5jdGlvbi9tYXRyaXgvc3Vic2V0JykpO1xuXG4gIHJldHVybiB0eXBlZCgnc3Vic2V0Jywge1xuICAgICcuLi5hbnknOiBmdW5jdGlvbiAoYXJncykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHN1YnNldC5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgZXJyb3JUcmFuc2Zvcm0oZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnc3Vic2V0JztcbmV4cG9ydHMucGF0aCA9ICdleHByZXNzaW9uLnRyYW5zZm9ybSc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL2luZGV4Jyk7XG5cbnZhciBvYmplY3QgPSB1dGlsLm9iamVjdDtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuXG4gIHZhciBtYXRyaXggPSBsb2FkKHJlcXVpcmUoJy4uLy4uLy4uL3R5cGUvbWF0cml4L2Z1bmN0aW9uL21hdHJpeCcpKTtcbiAgdmFyIGFicyA9IGxvYWQocmVxdWlyZSgnLi4vLi4vYXJpdGhtZXRpYy9hYnMnKSk7XG4gIHZhciBhZGRTY2FsYXIgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL2FyaXRobWV0aWMvYWRkU2NhbGFyJykpO1xuICB2YXIgZGl2aWRlU2NhbGFyID0gbG9hZChyZXF1aXJlKCcuLi8uLi9hcml0aG1ldGljL2RpdmlkZVNjYWxhcicpKTtcbiAgdmFyIG11bHRpcGx5U2NhbGFyID0gbG9hZChyZXF1aXJlKCcuLi8uLi9hcml0aG1ldGljL211bHRpcGx5U2NhbGFyJykpO1xuICB2YXIgc3VidHJhY3QgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL2FyaXRobWV0aWMvc3VidHJhY3QnKSk7XG4gIHZhciBsYXJnZXIgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3JlbGF0aW9uYWwvbGFyZ2VyJykpO1xuICB2YXIgZXF1YWxTY2FsYXIgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3JlbGF0aW9uYWwvZXF1YWxTY2FsYXInKSk7XG4gIHZhciB1bmFyeU1pbnVzID0gbG9hZChyZXF1aXJlKCcuLi8uLi9hcml0aG1ldGljL3VuYXJ5TWludXMnKSk7XG4gIFxuICB2YXIgU3BhcnNlTWF0cml4ID0gdHlwZS5TcGFyc2VNYXRyaXg7XG4gIHZhciBEZW5zZU1hdHJpeCA9IHR5cGUuRGVuc2VNYXRyaXg7XG4gIHZhciBTcGEgPSB0eXBlLlNwYTtcbiAgXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIE1hdHJpeCBMVSBkZWNvbXBvc2l0aW9uIHdpdGggcGFydGlhbCBwaXZvdGluZy4gTWF0cml4IGBBYCBpcyBkZWNvbXBvc2VkIGluIHR3byBtYXRyaWNlcyAoYExgLCBgVWApIGFuZCBhXG4gICAqIHJvdyBwZXJtdXRhdGlvbiB2ZWN0b3IgYHBgIHdoZXJlIGBBW3AsOl0gPSBMICogVWBcbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmx1cChBKTtcbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICpcbiAgICogICAgdmFyIG0gPSBbWzIsIDFdLCBbMSwgNF1dO1xuICAgKiAgICB2YXIgciA9IG1hdGgubHVwKCk7XG4gICAqICAgIC8vIHIgPSB7XG4gICAqICAgIC8vICAgTDogW1sxLCAwXSwgWzAuNSwgMV1dLFxuICAgKiAgICAvLyAgIFU6IFtbMiwgMV0sIFswLCAzLjVdXSxcbiAgICogICAgLy8gICBQOiBbMCwgMV1cbiAgICogICAgLy8gfVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgc2x1LCBsc29sdmUsIGx1c29sdmUsIHVzb2x2ZVxuICAgKlxuICAgKiBAcGFyYW0ge01hdHJpeCB8IEFycmF5fSBBICAgIEEgdHdvIGRpbWVuc2lvbmFsIG1hdHJpeCBvciBhcnJheSBmb3Igd2hpY2ggdG8gZ2V0IHRoZSBMVVAgZGVjb21wb3NpdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXk8TWF0cml4Pn0gICAgICBUaGUgbG93ZXIgdHJpYW5ndWxhciBtYXRyaXgsIHRoZSB1cHBlciB0cmlhbmd1bGFyIG1hdHJpeCBhbmQgdGhlIHBlcm11dGF0aW9uIG1hdHJpeC5cbiAgICovXG4gIHZhciBsdXAgPSB0eXBlZCgnbHVwJywge1xuXG4gICAgJ0RlbnNlTWF0cml4JzogZnVuY3Rpb24gKG0pIHtcbiAgICAgIHJldHVybiBfZGVuc2VMVVAobSk7XG4gICAgfSxcbiAgICBcbiAgICAnU3BhcnNlTWF0cml4JzogZnVuY3Rpb24gKG0pIHtcbiAgICAgIHJldHVybiBfc3BhcnNlTFVQKG0pO1xuICAgIH0sXG5cbiAgICAnQXJyYXknOiBmdW5jdGlvbiAoYSkge1xuICAgICAgLy8gY3JlYXRlIGRlbnNlIG1hdHJpeCBmcm9tIGFycmF5XG4gICAgICB2YXIgbSA9IG1hdHJpeChhKTtcbiAgICAgIC8vIGx1cCwgdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgdmFyIHIgPSBfZGVuc2VMVVAobSk7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHJldHVybiB7XG4gICAgICAgIEw6IHIuTC52YWx1ZU9mKCksXG4gICAgICAgIFU6IHIuVS52YWx1ZU9mKCksXG4gICAgICAgIHA6IHIucFxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBfZGVuc2VMVVAgPSBmdW5jdGlvbiAobSkge1xuICAgIC8vIHJvd3MgJiBjb2x1bW5zXG4gICAgdmFyIHJvd3MgPSBtLl9zaXplWzBdO1xuICAgIHZhciBjb2x1bW5zID0gbS5fc2l6ZVsxXTtcbiAgICAvLyBtaW5pbXVtIHJvd3MgYW5kIGNvbHVtbnNcbiAgICB2YXIgbiA9IE1hdGgubWluKHJvd3MsIGNvbHVtbnMpO1xuICAgIC8vIG1hdHJpeCBhcnJheSwgY2xvbmUgb3JpZ2luYWwgZGF0YVxuICAgIHZhciBkYXRhID0gb2JqZWN0LmNsb25lKG0uX2RhdGEpO1xuICAgIC8vIGwgbWF0cml4IGFycmF5c1xuICAgIHZhciBsZGF0YSA9IFtdO1xuICAgIHZhciBsc2l6ZSA9IFtyb3dzLCBuXTtcbiAgICAvLyB1IG1hdHJpeCBhcnJheXNcbiAgICB2YXIgdWRhdGEgPSBbXTtcbiAgICB2YXIgdXNpemUgPSBbbiwgY29sdW1uc107XG4gICAgLy8gdmFyc1xuICAgIHZhciBpLCBqLCBrO1xuICAgIC8vIHBlcm11dGF0aW9uIHZlY3RvciAgICBcbiAgICB2YXIgcCA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCByb3dzOyBpKyspXG4gICAgICBwW2ldID0gaTsgICAgXG4gICAgLy8gbG9vcCBjb2x1bW5zXG4gICAgZm9yIChqID0gMDsgaiA8IGNvbHVtbnM7IGorKykge1xuICAgICAgLy8gc2tpcCBmaXJzdCBjb2x1bW4gaW4gdXBwZXIgdHJpYW5ndWxhciBtYXRyaXhcbiAgICAgIGlmIChqID4gMCkge1xuICAgICAgICAvLyBsb29wIHJvd3NcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgICAgIC8vIG1pbiBpLGpcbiAgICAgICAgICB2YXIgbWluID0gTWF0aC5taW4oaSwgaik7XG4gICAgICAgICAgLy8gdltpLCBqXVxuICAgICAgICAgIHZhciBzID0gMDtcbiAgICAgICAgICAvLyBsb29wIHVwIHRvIG1pblxuICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBtaW47IGsrKykge1xuICAgICAgICAgICAgLy8gcyA9IGxbaSwga10gLSBkYXRhW2ssIGpdXG4gICAgICAgICAgICBzID0gYWRkU2NhbGFyKHMsIG11bHRpcGx5U2NhbGFyKGRhdGFbaV1ba10sIGRhdGFba11bal0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YVtpXVtqXSA9IHN1YnRyYWN0KGRhdGFbaV1bal0sIHMpO1xuICAgICAgICB9XG4gICAgICB9ICAgICAgXG4gICAgICAvLyByb3cgd2l0aCBsYXJnZXIgdmFsdWUgaW4gY3ZlY3Rvciwgcm93ID49IGpcbiAgICAgIHZhciBwaSA9IGo7XG4gICAgICB2YXIgcGFic3YgPSAwO1xuICAgICAgdmFyIHZqaiA9IDA7XG4gICAgICAvLyBsb29wIHJvd3NcbiAgICAgIGZvciAoaSA9IGo7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgICAgLy8gZGF0YSBAIGksIGpcbiAgICAgICAgdmFyIHYgPSBkYXRhW2ldW2pdO1xuICAgICAgICAvLyBhYnNvbHV0ZSB2YWx1ZVxuICAgICAgICB2YXIgYWJzdiA9IGFicyh2KTtcbiAgICAgICAgLy8gdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHBpdm90ZSB2YWx1ZVxuICAgICAgICBpZiAobGFyZ2VyKGFic3YsIHBhYnN2KSkge1xuICAgICAgICAgIC8vIHN0b3JlIHJvd1xuICAgICAgICAgIHBpID0gaTtcbiAgICAgICAgICAvLyB1cGRhdGUgbWF4IHZhbHVlXG4gICAgICAgICAgcGFic3YgPSBhYnN2O1xuICAgICAgICAgIC8vIHZhbHVlIEAgW2osIGpdXG4gICAgICAgICAgdmpqID0gdjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gc3dhcCByb3dzIChqIDwtPiBwaSlcbiAgICAgIGlmIChqICE9PSBwaSkge1xuICAgICAgICAvLyBzd2FwIHZhbHVlcyBqIDwtPiBwaSBpbiBwXG4gICAgICAgIHBbal0gPSBbcFtwaV0sIHBbcGldID0gcFtqXV1bMF07XG4gICAgICAgIC8vIHN3YXAgaiA8LT4gcGkgaW4gZGF0YVxuICAgICAgICBEZW5zZU1hdHJpeC5fc3dhcFJvd3MoaiwgcGksIGRhdGEpO1xuICAgICAgfVxuICAgICAgLy8gY2hlY2sgY29sdW1uIGlzIGluIGxvd2VyIHRyaWFuZ3VsYXIgbWF0cml4XG4gICAgICBpZiAoaiA8IHJvd3MpIHtcbiAgICAgICAgLy8gbG9vcCByb3dzIChsb3dlciB0cmlhbmd1bGFyIG1hdHJpeClcbiAgICAgICAgZm9yIChpID0gaiArIDE7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgICAgICAvLyB2YWx1ZSBAIGksIGpcbiAgICAgICAgICB2YXIgdmlqID0gZGF0YVtpXVtqXTtcbiAgICAgICAgICBpZiAoIWVxdWFsU2NhbGFyKHZpaiwgMCkpIHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBkYXRhXG4gICAgICAgICAgICBkYXRhW2ldW2pdID0gZGl2aWRlU2NhbGFyKGRhdGFbaV1bal0sIHZqaik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGxvb3AgY29sdW1uc1xuICAgIGZvciAoaiA9IDA7IGogPCBjb2x1bW5zOyBqKyspIHtcbiAgICAgIC8vIGxvb3Agcm93c1xuICAgICAgZm9yIChpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgICAvLyBpbml0aWFsaXplIHJvdyBpbiBhcnJheXNcbiAgICAgICAgaWYgKGogPT09IDApIHtcbiAgICAgICAgICAvLyBjaGVjayByb3cgZXhpc3RzIGluIHVwcGVyIHRyaWFuZ3VsYXIgbWF0cml4XG4gICAgICAgICAgaWYgKGkgPCBjb2x1bW5zKSB7XG4gICAgICAgICAgICAvLyBVXG4gICAgICAgICAgICB1ZGF0YVtpXSA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBMXG4gICAgICAgICAgbGRhdGFbaV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayB3ZSBhcmUgaW4gdGhlIHVwcGVyIHRyaWFuZ3VsYXIgbWF0cml4XG4gICAgICAgIGlmIChpIDwgaikge1xuICAgICAgICAgIC8vIGNoZWNrIHJvdyBleGlzdHMgaW4gdXBwZXIgdHJpYW5ndWxhciBtYXRyaXhcbiAgICAgICAgICBpZiAoaSA8IGNvbHVtbnMpIHtcbiAgICAgICAgICAgIC8vIFVcbiAgICAgICAgICAgIHVkYXRhW2ldW2pdID0gZGF0YVtpXVtqXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gY2hlY2sgY29sdW1uIGV4aXN0cyBpbiBsb3dlciB0cmlhbmd1bGFyIG1hdHJpeFxuICAgICAgICAgIGlmIChqIDwgcm93cykge1xuICAgICAgICAgICAgLy8gTFxuICAgICAgICAgICAgbGRhdGFbaV1bal0gPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkaWFnb25hbCB2YWx1ZVxuICAgICAgICBpZiAoaSA9PT0gaikge1xuICAgICAgICAgIC8vIGNoZWNrIHJvdyBleGlzdHMgaW4gdXBwZXIgdHJpYW5ndWxhciBtYXRyaXhcbiAgICAgICAgICBpZiAoaSA8IGNvbHVtbnMpIHtcbiAgICAgICAgICAgIC8vIFVcbiAgICAgICAgICAgIHVkYXRhW2ldW2pdID0gZGF0YVtpXVtqXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gY2hlY2sgY29sdW1uIGV4aXN0cyBpbiBsb3dlciB0cmlhbmd1bGFyIG1hdHJpeFxuICAgICAgICAgIGlmIChqIDwgcm93cykge1xuICAgICAgICAgICAgLy8gTFxuICAgICAgICAgICAgbGRhdGFbaV1bal0gPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayByb3cgZXhpc3RzIGluIHVwcGVyIHRyaWFuZ3VsYXIgbWF0cml4XG4gICAgICAgIGlmIChpIDwgY29sdW1ucykge1xuICAgICAgICAgIC8vIFVcbiAgICAgICAgICB1ZGF0YVtpXVtqXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgY29sdW1uIGV4aXN0cyBpbiBsb3dlciB0cmlhbmd1bGFyIG1hdHJpeFxuICAgICAgICBpZiAoaiA8IHJvd3MpIHtcbiAgICAgICAgICAvLyBMXG4gICAgICAgICAgbGRhdGFbaV1bal0gPSBkYXRhW2ldW2pdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGwgbWF0cml4XG4gICAgdmFyIGwgPSAgbmV3IERlbnNlTWF0cml4KHtcbiAgICAgIGRhdGE6IGxkYXRhLFxuICAgICAgc2l6ZTogbHNpemVcbiAgICB9KTtcbiAgICAvLyB1IG1hdHJpeFxuICAgIHZhciB1ID0gIG5ldyBEZW5zZU1hdHJpeCh7XG4gICAgICBkYXRhOiB1ZGF0YSxcbiAgICAgIHNpemU6IHVzaXplXG4gICAgfSk7XG4gICAgLy8gcCB2ZWN0b3JcbiAgICB2YXIgcHYgPSBbXTtcbiAgICBmb3IgKGkgPSAwLCBuID0gcC5sZW5ndGg7IGkgPCBuOyBpKyspXG4gICAgICBwdltwW2ldXSA9IGk7XG4gICAgLy8gcmV0dXJuIG1hdHJpY2VzXG4gICAgcmV0dXJuIHsgXG4gICAgICBMOiBsLCBcbiAgICAgIFU6IHUsIFxuICAgICAgcDogcHYsIFxuICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdMOiAnICsgdGhpcy5MLnRvU3RyaW5nKCkgKyAnXFxuVTogJyArIHRoaXMuVS50b1N0cmluZygpICsgJ1xcblA6ICcgKyB0aGlzLnA7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgXG4gIHZhciBfc3BhcnNlTFVQID0gZnVuY3Rpb24gKG0pIHtcbiAgICAvLyByb3dzICYgY29sdW1uc1xuICAgIHZhciByb3dzID0gbS5fc2l6ZVswXTtcbiAgICB2YXIgY29sdW1ucyA9IG0uX3NpemVbMV07XG4gICAgLy8gbWluaW11bSByb3dzIGFuZCBjb2x1bW5zXG4gICAgdmFyIG4gPSBNYXRoLm1pbihyb3dzLCBjb2x1bW5zKTtcbiAgICAvLyBtYXRyaXggYXJyYXlzICh3aWxsIG5vdCBiZSBtb2RpZmllZCwgdGhhbmtzIHRvIHBlcm11dGF0aW9uIHZlY3RvcilcbiAgICB2YXIgdmFsdWVzID0gbS5fdmFsdWVzO1xuICAgIHZhciBpbmRleCA9IG0uX2luZGV4O1xuICAgIHZhciBwdHIgPSBtLl9wdHI7XG4gICAgLy8gbCBtYXRyaXggYXJyYXlzXG4gICAgdmFyIGx2YWx1ZXMgPSBbXTtcbiAgICB2YXIgbGluZGV4ID0gW107XG4gICAgdmFyIGxwdHIgPSBbXTtcbiAgICB2YXIgbHNpemUgPSBbcm93cywgbl07XG4gICAgLy8gdSBtYXRyaXggYXJyYXlzXG4gICAgdmFyIHV2YWx1ZXMgPSBbXTtcbiAgICB2YXIgdWluZGV4ID0gW107XG4gICAgdmFyIHVwdHIgPSBbXTtcbiAgICB2YXIgdXNpemUgPSBbbiwgY29sdW1uc107XG4gICAgLy8gdmFyc1xuICAgIHZhciBpLCBqLCBrO1xuICAgIC8vIHBlcm11dGF0aW9uIHZlY3RvcnMsIChjdXJyZW50IGluZGV4IC0+IG9yaWdpbmFsIGluZGV4KSBhbmQgKG9yaWdpbmFsIGluZGV4IC0+IGN1cnJlbnQgaW5kZXgpXG4gICAgdmFyIHB2X2NvID0gW107XG4gICAgdmFyIHB2X29jID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgcHZfY29baV0gPSBpO1xuICAgICAgcHZfb2NbaV0gPSBpO1xuICAgIH1cbiAgICAvLyBzd2FwIGluZGljZXMgaW4gcGVybXV0YXRpb24gdmVjdG9ycyAoY29uZGl0aW9uIHggPCB5KSFcbiAgICB2YXIgc3dhcEluZGVjZXMgPSBmdW5jdGlvbiAoeCwgeSkgeyAgICAgIFxuICAgICAgLy8gZmluZCBwdiBpbmRlY2VzIGdldHRpbmcgZGF0YSBmcm9tIHggYW5kIHlcbiAgICAgIHZhciBreCA9IHB2X29jW3hdO1xuICAgICAgdmFyIGt5ID0gcHZfb2NbeV07XG4gICAgICAvLyB1cGRhdGUgcGVybXV0YXRpb24gdmVjdG9yIGN1cnJlbnQgLT4gb3JpZ2luYWxcbiAgICAgIHB2X2NvW2t4XSA9IHk7XG4gICAgICBwdl9jb1treV0gPSB4O1xuICAgICAgLy8gdXBkYXRlIHBlcm11dGF0aW9uIHZlY3RvciBvcmlnaW5hbCAtPiBjdXJyZW50XG4gICAgICBwdl9vY1t4XSA9IGt5O1xuICAgICAgcHZfb2NbeV0gPSBreDtcbiAgICB9O1xuICAgIC8vIGxvb3AgY29sdW1uc1xuICAgIGZvciAoaiA9IDA7IGogPCBjb2x1bW5zOyBqKyspIHtcbiAgICAgIC8vIHNwYXJzZSBhY2N1bXVsYXRvclxuICAgICAgdmFyIHNwYSA9IG5ldyBTcGEoKTsgICAgICAgICAgICBcbiAgICAgIC8vIGNoZWNrIGxvd2VyIHRyaWFuZ3VsYXIgbWF0cml4IGhhcyBhIHZhbHVlIEAgY29sdW1uIGpcbiAgICAgIGlmIChqIDwgcm93cykge1xuICAgICAgICAvLyB1cGRhdGUgcHRyXG4gICAgICAgIGxwdHIucHVzaChsdmFsdWVzLmxlbmd0aCk7XG4gICAgICAgIC8vIGZpcnN0IHZhbHVlIGluIGogY29sdW1uIGZvciBsb3dlciB0cmlhbmd1bGFyIG1hdHJpeFxuICAgICAgICBsdmFsdWVzLnB1c2goMSk7XG4gICAgICAgIGxpbmRleC5wdXNoKGopO1xuICAgICAgfVxuICAgICAgLy8gdXBkYXRlIHB0clxuICAgICAgdXB0ci5wdXNoKHV2YWx1ZXMubGVuZ3RoKTtcbiAgICAgIC8vIGswIDw9IGsgPCBrMSB3aGVyZSBrMCA9IF9wdHJbal0gJiYgazEgPSBfcHRyW2orMV1cbiAgICAgIHZhciBrMCA9IHB0cltqXTtcbiAgICAgIHZhciBrMSA9IHB0cltqICsgMV07XG4gICAgICAvLyBjb3B5IGNvbHVtbiBqIGludG8gc3BhcnNlIGFjY3VtdWxhdG9yXG4gICAgICBmb3IgKGsgPSBrMDsgayA8IGsxOyBrKyspIHtcbiAgICAgICAgLy8gcm93XG4gICAgICAgIGkgPSBpbmRleFtrXTtcbiAgICAgICAgLy8gY29weSBjb2x1bW4gdmFsdWVzIGludG8gc3BhcnNlIGFjY3VtdWxhdG9yICh1c2UgcGVybXV0YXRpb24gdmVjdG9yKVxuICAgICAgICBzcGEuc2V0KHB2X2NvW2ldLCB2YWx1ZXNba10pO1xuICAgICAgfVxuICAgICAgLy8gc2tpcCBmaXJzdCBjb2x1bW4gaW4gdXBwZXIgdHJpYW5ndWxhciBtYXRyaXhcbiAgICAgIGlmIChqID4gMCkge1xuICAgICAgICAvLyBsb29wIHJvd3MgaW4gY29sdW1uIGogKGFib3ZlIGRpYWdvbmFsKVxuICAgICAgICBzcGEuZm9yRWFjaCgwLCBqIC0gMSwgZnVuY3Rpb24gKGssIHZraikge1xuICAgICAgICAgIC8vIGxvb3Agcm93cyBpbiBjb2x1bW4gayAoTClcbiAgICAgICAgICBTcGFyc2VNYXRyaXguX2ZvckVhY2hSb3coaywgbHZhbHVlcywgbGluZGV4LCBscHRyLCBmdW5jdGlvbiAoaSwgdmlrKSB7XG4gICAgICAgICAgICAvLyBjaGVjayByb3cgaXMgYmVsb3cga1xuICAgICAgICAgICAgaWYgKGkgPiBrKSB7XG4gICAgICAgICAgICAgIC8vIHVwZGF0ZSBzcGEgdmFsdWVcbiAgICAgICAgICAgICAgc3BhLmFjY3VtdWxhdGUoaSwgdW5hcnlNaW51cyhtdWx0aXBseVNjYWxhcih2aWssIHZraikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7ICAgICAgICBcbiAgICAgIH1cbiAgICAgIC8vIHJvdyB3aXRoIGxhcmdlciB2YWx1ZSBpbiBzcGEsIHJvdyA+PSBqXG4gICAgICB2YXIgcGkgPSBqO1xuICAgICAgdmFyIHZqaiA9IHNwYS5nZXQoaik7XG4gICAgICB2YXIgcGFic3YgPSBhYnModmpqKTsgICAgICBcbiAgICAgIC8vIGxvb3AgdmFsdWVzIGluIHNwYSAob3JkZXIgYnkgcm93LCBiZWxvdyBkaWFnb25hbClcbiAgICAgIHNwYS5mb3JFYWNoKGogKyAxLCByb3dzIC0gMSwgZnVuY3Rpb24gKHgsIHYpIHtcbiAgICAgICAgLy8gYWJzb2x1dGUgdmFsdWVcbiAgICAgICAgdmFyIGFic3YgPSBhYnModik7XG4gICAgICAgIC8vIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBwaXZvdGUgdmFsdWVcbiAgICAgICAgaWYgKGxhcmdlcihhYnN2LCBwYWJzdikpIHtcbiAgICAgICAgICAvLyBzdG9yZSByb3dcbiAgICAgICAgICBwaSA9IHg7XG4gICAgICAgICAgLy8gdXBkYXRlIG1heCB2YWx1ZVxuICAgICAgICAgIHBhYnN2ID0gYWJzdjtcbiAgICAgICAgICAvLyB2YWx1ZSBAIFtqLCBqXVxuICAgICAgICAgIHZqaiA9IHY7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gc3dhcCByb3dzIChqIDwtPiBwaSlcbiAgICAgIGlmIChqICE9PSBwaSkge1xuICAgICAgICAvLyBzd2FwIHZhbHVlcyBqIDwtPiBwaSBpbiBMXG4gICAgICAgIFNwYXJzZU1hdHJpeC5fc3dhcFJvd3MoaiwgcGksIGxzaXplWzFdLCBsdmFsdWVzLCBsaW5kZXgsIGxwdHIpO1xuICAgICAgICAvLyBzd2FwIHZhbHVlcyBqIDwtPiBwaSBpbiBVXG4gICAgICAgIFNwYXJzZU1hdHJpeC5fc3dhcFJvd3MoaiwgcGksIHVzaXplWzFdLCB1dmFsdWVzLCB1aW5kZXgsIHVwdHIpO1xuICAgICAgICAvLyBzd2FwIHZhbHVlcyBpbiBzcGFcbiAgICAgICAgc3BhLnN3YXAoaiwgcGkpO1xuICAgICAgICAvLyB1cGRhdGUgcGVybXV0YXRpb24gdmVjdG9yIChzd2FwIHZhbHVlcyBAIGosIHBpKVxuICAgICAgICBzd2FwSW5kZWNlcyhqLCBwaSk7XG4gICAgICB9XG4gICAgICAvLyBsb29wIHZhbHVlcyBpbiBzcGEgKG9yZGVyIGJ5IHJvdylcbiAgICAgIHNwYS5mb3JFYWNoKDAsIHJvd3MgLSAxLCBmdW5jdGlvbiAoeCwgdikge1xuICAgICAgICAvLyBjaGVjayB3ZSBhcmUgYWJvdmUgZGlhZ29uYWxcbiAgICAgICAgaWYgKHggPD0gaikge1xuICAgICAgICAgIC8vIHVwZGF0ZSB1cHBlciB0cmlhbmd1bGFyIG1hdHJpeFxuICAgICAgICAgIHV2YWx1ZXMucHVzaCh2KTtcbiAgICAgICAgICB1aW5kZXgucHVzaCh4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyB1cGRhdGUgdmFsdWVcbiAgICAgICAgICB2ID0gZGl2aWRlU2NhbGFyKHYsIHZqaik7XG4gICAgICAgICAgLy8gY2hlY2sgdmFsdWUgaXMgbm9uIHplcm9cbiAgICAgICAgICBpZiAoIWVxdWFsU2NhbGFyKHYsIDApKSB7XG4gICAgICAgICAgICAvLyB1cGRhdGUgbG93ZXIgdHJpYW5ndWxhciBtYXRyaXhcbiAgICAgICAgICAgIGx2YWx1ZXMucHVzaCh2KTtcbiAgICAgICAgICAgIGxpbmRleC5wdXNoKHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHVwZGF0ZSBwdHJzXG4gICAgdXB0ci5wdXNoKHV2YWx1ZXMubGVuZ3RoKTtcbiAgICBscHRyLnB1c2gobHZhbHVlcy5sZW5ndGgpO1xuXG4gICAgLy8gcmV0dXJuIG1hdHJpY2VzXG4gICAgcmV0dXJuIHtcbiAgICAgIEw6IG5ldyBTcGFyc2VNYXRyaXgoe1xuICAgICAgICB2YWx1ZXM6IGx2YWx1ZXMsXG4gICAgICAgIGluZGV4OiBsaW5kZXgsXG4gICAgICAgIHB0cjogbHB0cixcbiAgICAgICAgc2l6ZTogbHNpemVcbiAgICAgIH0pLCBcbiAgICAgIFU6IG5ldyBTcGFyc2VNYXRyaXgoe1xuICAgICAgICB2YWx1ZXM6IHV2YWx1ZXMsXG4gICAgICAgIGluZGV4OiB1aW5kZXgsXG4gICAgICAgIHB0cjogdXB0cixcbiAgICAgICAgc2l6ZTogdXNpemVcbiAgICAgIH0pLFxuICAgICAgcDogcHZfY28sXG4gICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0w6ICcgKyB0aGlzLkwudG9TdHJpbmcoKSArICdcXG5VOiAnICsgdGhpcy5VLnRvU3RyaW5nKCkgKyAnXFxuUDogJyArIHRoaXMucDtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICBcbiAgcmV0dXJuIGx1cDtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2x1cCc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL2luZGV4Jyk7XG5cbnZhciBudW1iZXIgPSB1dGlsLm51bWJlcixcbiAgICBcbiAgICBpc0ludGVnZXIgPSBudW1iZXIuaXNJbnRlZ2VyO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG5cbiAgdmFyIGNzX3NxciA9IGxvYWQocmVxdWlyZSgnLi4vLi4vYWxnZWJyYS9zcGFyc2UvY3Nfc3FyJykpO1xuICB2YXIgY3NfbHUgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL2FsZ2VicmEvc3BhcnNlL2NzX2x1JykpO1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIFNwYXJzZSBNYXRyaXggTFUgZGVjb21wb3NpdGlvbiB3aXRoIGZ1bGwgcGl2b3RpbmcuIFNwYXJzZSBNYXRyaXggYEFgIGlzIGRlY29tcG9zZWQgaW4gdHdvIG1hdHJpY2VzIChgTGAsIGBVYCkgYW5kIHR3byBwZXJtdXRhdGlvbiB2ZWN0b3JzIChgcGludmAsIGBxYCkgd2hlcmVcbiAgICpcbiAgICogYFAgKiBBICogUSA9IEwgKiBVYFxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguc2x1KEEsIG9yZGVyLCB0aHJlc2hvbGQpO1xuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgbHVwLCBsc29sdmUsIHVzb2x2ZSwgbHVzb2x2ZVxuICAgKlxuICAgKiBAcGFyYW0ge1NwYXJzZU1hdHJpeH0gQSAgICAgICAgICAgICAgQSB0d28gZGltZW5zaW9uYWwgc3BhcnNlIG1hdHJpeCBmb3Igd2hpY2ggdG8gZ2V0IHRoZSBMVSBkZWNvbXBvc2l0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gICAgICAgb3JkZXIgICAgICAgICAgVGhlIFN5bWJvbGljIE9yZGVyaW5nIGFuZCBBbmFseXNpcyBvcmRlcjpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwIC0gTmF0dXJhbCBvcmRlcmluZywgbm8gcGVybXV0YXRpb24gdmVjdG9yIHEgaXMgcmV0dXJuZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxIC0gTWF0cml4IG11c3QgYmUgc3F1YXJlLCBzeW1ib2xpYyBvcmRlcmluZyBhbmQgYW5hbGlzaXMgaXMgcGVyZm9ybWVkIG9uIE0gPSBBICsgQSdcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyIC0gU3ltYm9saWMgb3JkZXJpbmcgYW5kIGFuYWxpc2lzIGlzIHBlcmZvcm1lZCBvbiBNID0gQScgKiBBLiBEZW5zZSBjb2x1bW5zIGZyb20gQScgYXJlIGRyb3BwZWQsIEEgcmVjcmVhdGVkIGZyb20gQScuIFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGlzIGlzIGFwcHJvcHJpYXRlZm9yIExVIGZhY3Rvcml6YXRpb24gb2YgdW5zeW1tZXRyaWMgbWF0cmljZXMuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMyAtIFN5bWJvbGljIG9yZGVyaW5nIGFuZCBhbmFsaXNpcyBpcyBwZXJmb3JtZWQgb24gTSA9IEEnICogQS4gVGhpcyBpcyBiZXN0IHVzZWQgZm9yIExVIGZhY3Rvcml6YXRpb24gaXMgbWF0cml4IE0gaGFzIG5vIGRlbnNlIHJvd3MuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEEgZGVuc2Ugcm93IGlzIGEgcm93IHdpdGggbW9yZSB0aGFuIDEwKnNxcihjb2x1bW5zKSBlbnRyaWVzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gICAgICAgdGhyZXNob2xkICAgICAgIFBhcnRpYWwgcGl2b3RpbmcgdGhyZXNob2xkICgxIGZvciBwYXJ0aWFsIHBpdm90aW5nKVxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBsb3dlciB0cmlhbmd1bGFyIG1hdHJpeCwgdGhlIHVwcGVyIHRyaWFuZ3VsYXIgbWF0cml4IGFuZCB0aGUgcGVybXV0YXRpb24gdmVjdG9ycy5cbiAgICovXG4gIHZhciBzbHUgPSB0eXBlZCgnc2x1Jywge1xuXG4gICAgJ1NwYXJzZU1hdHJpeCwgbnVtYmVyLCBudW1iZXInOiBmdW5jdGlvbiAoYSwgb3JkZXIsIHRocmVzaG9sZCkge1xuICAgICAgLy8gdmVyaWZ5IG9yZGVyXG4gICAgICBpZiAoIWlzSW50ZWdlcihvcmRlcikgfHwgb3JkZXIgPCAwIHx8IG9yZGVyID4gMylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTeW1ib2xpYyBPcmRlcmluZyBhbmQgQW5hbHlzaXMgb3JkZXIgbXVzdCBiZSBhbiBpbnRlZ2VyIG51bWJlciBpbiB0aGUgaW50ZXJ2YWwgWzAsIDNdJyk7XG4gICAgICAvLyB2ZXJpZnkgdGhyZXNob2xkXG4gICAgICBpZiAodGhyZXNob2xkIDwgMCB8fCB0aHJlc2hvbGQgPiAxKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcnRpYWwgcGl2b3RpbmcgdGhyZXNob2xkIG11c3QgYmUgYSBudW1iZXIgZnJvbSAwIHRvIDEnKTtcbiAgICAgIFxuICAgICAgLy8gcGVyZm9ybSBzeW1ib2xpYyBvcmRlcmluZyBhbmQgYW5hbHlzaXNcbiAgICAgIHZhciBzID0gY3Nfc3FyKG9yZGVyLCBhLCBmYWxzZSk7XG4gICAgICBcbiAgICAgIC8vIHBlcmZvcm0gbHUgZGVjb21wb3NpdGlvblxuICAgICAgdmFyIGYgPSBjc19sdShhLCBzLCB0aHJlc2hvbGQpO1xuICAgICAgXG4gICAgICAvLyByZXR1cm4gZGVjb21wb3NpdGlvblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgTDogZi5MLFxuICAgICAgICBVOiBmLlUsXG4gICAgICAgIHA6IGYucGludixcbiAgICAgICAgcTogcy5xLFxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiAnTDogJyArIHRoaXMuTC50b1N0cmluZygpICsgJ1xcblU6ICcgKyB0aGlzLlUudG9TdHJpbmcoKSArICdcXG5wOiAnICsgdGhpcy5wLnRvU3RyaW5nKCkgKyAodGhpcy5xID8gJ1xcbnE6ICcgKyB0aGlzLnEudG9TdHJpbmcoKSA6ICcnKSArICdcXG4nO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHNsdTtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ3NsdSc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBbXG4gIC8vIGRlY29tcG9zaXRpb25cbiAgcmVxdWlyZSgnLi9kZWNvbXBvc2l0aW9uL2x1cCcpLFxuICByZXF1aXJlKCcuL2RlY29tcG9zaXRpb24vc2x1JyksXG5cbiAgLy8gc29sdmVyXG4gIHJlcXVpcmUoJy4vc29sdmVyL2xzb2x2ZScpLFxuICByZXF1aXJlKCcuL3NvbHZlci9sdXNvbHZlJyksXG4gIHJlcXVpcmUoJy4vc29sdmVyL3Vzb2x2ZScpXG5dO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG5cbiAgdmFyIG1hdHJpeCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vLi4vdHlwZS9tYXRyaXgvZnVuY3Rpb24vbWF0cml4JykpO1xuICB2YXIgZGl2aWRlU2NhbGFyID0gbG9hZChyZXF1aXJlKCcuLi8uLi9hcml0aG1ldGljL2RpdmlkZVNjYWxhcicpKTtcbiAgdmFyIG11bHRpcGx5U2NhbGFyID0gbG9hZChyZXF1aXJlKCcuLi8uLi9hcml0aG1ldGljL211bHRpcGx5U2NhbGFyJykpO1xuICB2YXIgc3VidHJhY3QgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL2FyaXRobWV0aWMvc3VidHJhY3QnKSk7XG4gIHZhciBlcXVhbFNjYWxhciA9IGxvYWQocmVxdWlyZSgnLi4vLi4vcmVsYXRpb25hbC9lcXVhbFNjYWxhcicpKTtcblxuICB2YXIgc29sdmVWYWxpZGF0aW9uID0gbG9hZChyZXF1aXJlKCcuL3V0aWxzL3NvbHZlVmFsaWRhdGlvbicpKTtcblxuICB2YXIgRGVuc2VNYXRyaXggPSB0eXBlLkRlbnNlTWF0cml4O1xuXG4gIC8qKiBcbiAgICogU29sdmVzIHRoZSBsaW5lYXIgZXF1YXRpb24gc3lzdGVtIGJ5IGZvcndhcmRzIHN1YnN0aXR1dGlvbi4gTWF0cml4IG11c3QgYmUgYSBsb3dlciB0cmlhbmd1bGFyIG1hdHJpeC5cbiAgICpcbiAgICogYEwgKiB4ID0gYmBcbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmxzb2x2ZShMLCBiKTtcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIHZhciBhID0gW1stMiwgM10sIFsyLCAxXV07XG4gICAqICAgIHZhciBiID0gWzExLCA5XTtcbiAgICogICAgdmFyIHggPSBsc29sdmUoYSwgYik7ICAvLyBbWy01LjVdLCBbMjBdXVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgbHVwLCBzbHUsIHVzb2x2ZSwgbHVzb2x2ZVxuICAgKlxuICAgKiBAcGFyYW0ge01hdHJpeCwgQXJyYXl9IEwgICAgICAgQSBOIHggTiBtYXRyaXggb3IgYXJyYXkgKEwpXG4gICAqIEBwYXJhbSB7TWF0cml4LCBBcnJheX0gYiAgICAgICBBIGNvbHVtbiB2ZWN0b3Igd2l0aCB0aGUgYiB2YWx1ZXNcbiAgICpcbiAgICogQHJldHVybiB7RGVuc2VNYXRyaXggfCBBcnJheX0gIEEgY29sdW1uIHZlY3RvciB3aXRoIHRoZSBsaW5lYXIgc3lzdGVtIHNvbHV0aW9uICh4KVxuICAgKi9cbiAgdmFyIGxzb2x2ZSA9IHR5cGVkKCdsc29sdmUnLCB7XG5cbiAgICAnU3BhcnNlTWF0cml4LCBBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uIChtLCBiKSB7XG4gICAgICAvLyBwcm9jZXNzIG1hdHJpeFxuICAgICAgcmV0dXJuIF9zcGFyc2VGb3J3YXJkU3Vic3RpdHV0aW9uKG0sIGIpO1xuICAgIH0sXG4gICAgXG4gICAgJ0RlbnNlTWF0cml4LCBBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uIChtLCBiKSB7XG4gICAgICAvLyBwcm9jZXNzIG1hdHJpeFxuICAgICAgcmV0dXJuIF9kZW5zZUZvcndhcmRTdWJzdGl0dXRpb24obSwgYik7XG4gICAgfSxcbiAgICBcbiAgICAnQXJyYXksIEFycmF5IHwgTWF0cml4JzogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIC8vIGNyZWF0ZSBkZW5zZSBtYXRyaXggZnJvbSBhcnJheVxuICAgICAgdmFyIG0gPSBtYXRyaXgoYSk7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICB2YXIgciA9IF9kZW5zZUZvcndhcmRTdWJzdGl0dXRpb24obSwgYik7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHJldHVybiByLnZhbHVlT2YoKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBfZGVuc2VGb3J3YXJkU3Vic3RpdHV0aW9uID0gZnVuY3Rpb24gKG0sIGIpIHtcbiAgICAvLyB2YWxpZGF0ZSBtYXRyaXggYW5kIHZlY3RvciwgcmV0dXJuIGNvcHkgb2YgY29sdW1uIHZlY3RvciBiXG4gICAgYiA9IHNvbHZlVmFsaWRhdGlvbihtLCBiLCB0cnVlKTtcbiAgICAvLyBjb2x1bW4gdmVjdG9yIGRhdGFcbiAgICB2YXIgYmRhdGEgPSBiLl9kYXRhO1xuICAgIC8vIHJvd3MgJiBjb2x1bW5zXG4gICAgdmFyIHJvd3MgPSBtLl9zaXplWzBdO1xuICAgIHZhciBjb2x1bW5zID0gbS5fc2l6ZVsxXTtcbiAgICAvLyByZXN1bHRcbiAgICB2YXIgeCA9IFtdO1xuICAgIC8vIGRhdGFcbiAgICB2YXIgZGF0YSA9IG0uX2RhdGE7XG4gICAgLy8gZm9yd2FyZCBzb2x2ZSBtICogeCA9IGIsIGxvb3AgY29sdW1uc1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29sdW1uczsgaisrKSB7XG4gICAgICAvLyBiW2pdXG4gICAgICB2YXIgYmogPSBiZGF0YVtqXVswXSB8fCAwO1xuICAgICAgLy8geFtqXVxuICAgICAgdmFyIHhqO1xuICAgICAgLy8gZm9yd2FyZCBzdWJzdGl0dXRpb24gKG91dGVyIHByb2R1Y3QpIGF2b2lkcyBpbm5lciBsb29waW5nIHdoZW4gYmogPT0gMFxuICAgICAgaWYgKCFlcXVhbFNjYWxhcihiaiwgMCkpIHtcbiAgICAgICAgLy8gdmFsdWUgQCBbaiwgal1cbiAgICAgICAgdmFyIHZqaiA9IGRhdGFbal1bal07XG4gICAgICAgIC8vIGNoZWNrIHZqalxuICAgICAgICBpZiAoZXF1YWxTY2FsYXIodmpqLCAwKSkge1xuICAgICAgICAgIC8vIHN5c3RlbSBjYW5ub3QgYmUgc29sdmVkXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMaW5lYXIgc3lzdGVtIGNhbm5vdCBiZSBzb2x2ZWQgc2luY2UgbWF0cml4IGlzIHNpbmd1bGFyJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2FsY3VsYXRlIHhqXG4gICAgICAgIHhqID0gZGl2aWRlU2NhbGFyKGJqLCB2amopO1xuICAgICAgICAvLyBsb29wIHJvd3NcbiAgICAgICAgZm9yICh2YXIgaSA9IGogKyAxOyBpIDwgcm93czsgaSsrKSB7XG4gICAgICAgICAgLy8gdXBkYXRlIGNvcHkgb2YgYlxuICAgICAgICAgIGJkYXRhW2ldID0gW3N1YnRyYWN0KGJkYXRhW2ldWzBdIHx8IDAsIG11bHRpcGx5U2NhbGFyKHhqLCBkYXRhW2ldW2pdKSldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gemVybyBAIGpcbiAgICAgICAgeGogPSAwO1xuICAgICAgfVxuICAgICAgLy8gdXBkYXRlIHhcbiAgICAgIHhbal0gPSBbeGpdO1xuICAgIH1cbiAgICAvLyByZXR1cm4gdmVjdG9yXG4gICAgcmV0dXJuIG5ldyBEZW5zZU1hdHJpeCh7XG4gICAgICBkYXRhOiB4LFxuICAgICAgc2l6ZTogW3Jvd3MsIDFdXG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIF9zcGFyc2VGb3J3YXJkU3Vic3RpdHV0aW9uID0gZnVuY3Rpb24gKG0sIGIpIHtcbiAgICAvLyB2YWxpZGF0ZSBtYXRyaXggYW5kIHZlY3RvciwgcmV0dXJuIGNvcHkgb2YgY29sdW1uIHZlY3RvciBiXG4gICAgYiA9IHNvbHZlVmFsaWRhdGlvbihtLCBiLCB0cnVlKTtcbiAgICAvLyBjb2x1bW4gdmVjdG9yIGRhdGFcbiAgICB2YXIgYmRhdGEgPSBiLl9kYXRhO1xuICAgIC8vIHJvd3MgJiBjb2x1bW5zXG4gICAgdmFyIHJvd3MgPSBtLl9zaXplWzBdO1xuICAgIHZhciBjb2x1bW5zID0gbS5fc2l6ZVsxXTtcbiAgICAvLyBtYXRyaXggYXJyYXlzXG4gICAgdmFyIHZhbHVlcyA9IG0uX3ZhbHVlcztcbiAgICB2YXIgaW5kZXggPSBtLl9pbmRleDtcbiAgICB2YXIgcHRyID0gbS5fcHRyO1xuICAgIC8vIHZhcnNcbiAgICB2YXIgaSwgaztcbiAgICAvLyByZXN1bHRcbiAgICB2YXIgeCA9IFtdO1xuICAgIC8vIGZvcndhcmQgc29sdmUgbSAqIHggPSBiLCBsb29wIGNvbHVtbnNcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbHVtbnM7IGorKykge1xuICAgICAgLy8gYltqXVxuICAgICAgdmFyIGJqID0gYmRhdGFbal1bMF0gfHwgMDtcbiAgICAgIC8vIGZvcndhcmQgc3Vic3RpdHV0aW9uIChvdXRlciBwcm9kdWN0KSBhdm9pZHMgaW5uZXIgbG9vcGluZyB3aGVuIGJqID09IDBcbiAgICAgIGlmICghZXF1YWxTY2FsYXIoYmosIDApKSB7XG4gICAgICAgIC8vIHZhbHVlIEAgW2osIGpdXG4gICAgICAgIHZhciB2amogPSAwO1xuICAgICAgICAvLyBsb3dlciB0cmlhbmd1bGFyIG1hdHJpeCB2YWx1ZXMgJiBpbmRleCAoY29sdW1uIGopXG4gICAgICAgIHZhciBqdmFsdWVzID0gW107XG4gICAgICAgIHZhciBqaW5kZXggPSBbXTtcbiAgICAgICAgLy8gbGFzdCBpbmRleCBpbiBjb2x1bW5cbiAgICAgICAgdmFyIGwgPSBwdHJbaiArIDFdO1xuICAgICAgICAvLyB2YWx1ZXMgaW4gY29sdW1uLCBmaW5kIHZhbHVlIEAgW2osIGpdXG4gICAgICAgIGZvciAoayA9IHB0cltqXTsgayA8IGw7IGsrKykge1xuICAgICAgICAgIC8vIHJvd1xuICAgICAgICAgIGkgPSBpbmRleFtrXTtcbiAgICAgICAgICAvLyBjaGVjayByb3cgKHJvd3MgYXJlIG5vdCBzb3J0ZWQhKVxuICAgICAgICAgIGlmIChpID09PSBqKSB7XG4gICAgICAgICAgICAvLyB1cGRhdGUgdmpqXG4gICAgICAgICAgICB2amogPSB2YWx1ZXNba107XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGkgPiBqKSB7XG4gICAgICAgICAgICAvLyBzdG9yZSBsb3dlciB0cmlhbmd1bGFyXG4gICAgICAgICAgICBqdmFsdWVzLnB1c2godmFsdWVzW2tdKTtcbiAgICAgICAgICAgIGppbmRleC5wdXNoKGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBhdCB0aGlzIHBvaW50IHdlIG11c3QgaGF2ZSBhIHZhbHVlIEAgW2osIGpdXG4gICAgICAgIGlmIChlcXVhbFNjYWxhcih2amosIDApKSB7XG4gICAgICAgICAgLy8gc3lzdGVtIGNhbm5vdCBiZSBzb2x2ZWQsIHRoZXJlIGlzIG5vIHZhbHVlIEAgW2osIGpdXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMaW5lYXIgc3lzdGVtIGNhbm5vdCBiZSBzb2x2ZWQgc2luY2UgbWF0cml4IGlzIHNpbmd1bGFyJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2FsY3VsYXRlIHhqXG4gICAgICAgIHZhciB4aiA9IGRpdmlkZVNjYWxhcihiaiwgdmpqKTtcbiAgICAgICAgLy8gbG9vcCBsb3dlciB0cmlhbmd1bGFyXG4gICAgICAgIGZvciAoayA9IDAsIGwgPSBqaW5kZXgubGVuZ3RoOyBrIDwgbDsgaysrKSB7XG4gICAgICAgICAgLy8gcm93XG4gICAgICAgICAgaSA9IGppbmRleFtrXTtcbiAgICAgICAgICAvLyB1cGRhdGUgY29weSBvZiBiXG4gICAgICAgICAgYmRhdGFbaV0gPSBbc3VidHJhY3QoYmRhdGFbaV1bMF0gfHwgMCwgbXVsdGlwbHlTY2FsYXIoeGosIGp2YWx1ZXNba10pKV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXBkYXRlIHhcbiAgICAgICAgeFtqXSA9IFt4al07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gdXBkYXRlIHhcbiAgICAgICAgeFtqXSA9IFswXTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcmV0dXJuIHZlY3RvclxuICAgIHJldHVybiBuZXcgRGVuc2VNYXRyaXgoe1xuICAgICAgZGF0YTogeCxcbiAgICAgIHNpemU6IFtyb3dzLCAxXVxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBsc29sdmU7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdsc29sdmUnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIFxuICB2YXIgbWF0cml4ID0gbG9hZChyZXF1aXJlKCcuLi8uLi8uLi90eXBlL21hdHJpeC9mdW5jdGlvbi9tYXRyaXgnKSk7XG4gIHZhciBsdXAgPSBsb2FkKHJlcXVpcmUoJy4uL2RlY29tcG9zaXRpb24vbHVwJykpO1xuICB2YXIgc2x1ID0gbG9hZChyZXF1aXJlKCcuLi9kZWNvbXBvc2l0aW9uL3NsdScpKTtcbiAgdmFyIGNzX2lwdmVjID0gbG9hZChyZXF1aXJlKCcuLi9zcGFyc2UvY3NfaXB2ZWMnKSk7XG5cbiAgdmFyIHNvbHZlVmFsaWRhdGlvbiA9IGxvYWQocmVxdWlyZSgnLi91dGlscy9zb2x2ZVZhbGlkYXRpb24nKSk7XG5cbiAgdmFyIHVzb2x2ZSA9IGxvYWQocmVxdWlyZSgnLi91c29sdmUnKSk7XG4gIHZhciBsc29sdmUgPSBsb2FkKHJlcXVpcmUoJy4vbHNvbHZlJykpO1xuXG4gIC8qKlxuICAgKiBTb2x2ZXMgdGhlIGxpbmVhciBzeXN0ZW0gYEEgKiB4ID0gYmAgd2hlcmUgYEFgIGlzIGFuIFtuIHggbl0gbWF0cml4IGFuZCBgYmAgaXMgYSBbbl0gY29sdW1uIHZlY3Rvci5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmx1c29sdmUoQSwgYikgICAgIC8vIHJldHVybnMgY29sdW1uIHZlY3RvciB3aXRoIHRoZSBzb2x1dGlvbiB0byB0aGUgbGluZWFyIHN5c3RlbSBBICogeCA9IGJcbiAgICogICAgbWF0aC5sdXNvbHZlKGx1cCwgYikgICAvLyByZXR1cm5zIGNvbHVtbiB2ZWN0b3Igd2l0aCB0aGUgc29sdXRpb24gdG8gdGhlIGxpbmVhciBzeXN0ZW0gQSAqIHggPSBiLCBsdXAgPSBtYXRoLmx1cChBKVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgdmFyIG0gPSBbWzEsIDAsIDAsIDBdLCBbMCwgMiwgMCwgMF0sIFswLCAwLCAzLCAwXSwgWzAsIDAsIDAsIDRdXTtcbiAgICpcbiAgICogICAgdmFyIHggPSBtYXRoLmx1c29sdmUobSwgWy0xLCAtMSwgLTEsIC0xXSk7ICAgICAgICAvLyB4ID0gW1stMV0sIFstMC41XSwgWy0xLzNdLCBbLTAuMjVdXVxuICAgKlxuICAgKiAgICB2YXIgZiA9IG1hdGgubHVwKG0pO1xuICAgKiAgICB2YXIgeDEgPSBtYXRoLmx1c29sdmUoZiwgWy0xLCAtMSwgLTEsIC0xXSk7ICAgICAgIC8vIHgxID0gW1stMV0sIFstMC41XSwgWy0xLzNdLCBbLTAuMjVdXVxuICAgKiAgICB2YXIgeDIgPSBtYXRoLmx1c29sdmUoZiwgWzEsIDIsIDEsIC0xXSk7ICAgICAgICAgIC8vIHgyID0gW1sxXSwgWzFdLCBbMS8zXSwgWy0wLjI1XV1cbiAgICpcbiAgICogICAgdmFyIGEgPSBbWy0yLCAzXSwgWzIsIDFdXTtcbiAgICogICAgdmFyIGIgPSBbMTEsIDldO1xuICAgKiAgICB2YXIgeCA9IGx1c29sdmUoYSwgYik7ICAvLyBbWy01LjVdLCBbMjBdXVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgbHVwLCBzbHUsIGxzb2x2ZSwgdXNvbHZlXG4gICAqXG4gICAqIEBwYXJhbSB7TWF0cml4IHwgQXJyYXkgfCBPYmplY3R9IEEgICAgICBJbnZlcnRpYmxlIE1hdHJpeCBvciB0aGUgTWF0cml4IExVIGRlY29tcG9zaXRpb25cbiAgICogQHBhcmFtIHtNYXRyaXggfCBBcnJheX0gYiAgICAgICAgICAgICAgIENvbHVtbiBWZWN0b3JcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcmRlcl0gICAgICAgICAgICAgICAgIFRoZSBTeW1ib2xpYyBPcmRlcmluZyBhbmQgQW5hbHlzaXMgb3JkZXIsIHNlZSBzbHUgZm9yIGRldGFpbHMuIE1hdHJpeCBtdXN0IGJlIGEgU3BhcnNlTWF0cml4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbdGhyZXNob2xkXSAgICAgICAgICAgICBQYXJ0aWFsIHBpdm90aW5nIHRocmVzaG9sZCAoMSBmb3IgcGFydGlhbCBwaXZvdGluZyksIHNlZSBzbHUgZm9yIGRldGFpbHMuIE1hdHJpeCBtdXN0IGJlIGEgU3BhcnNlTWF0cml4LlxuICAgKlxuICAgKiBAcmV0dXJuIHtEZW5zZU1hdHJpeCB8IEFycmF5fSAgICAgICAgICAgQ29sdW1uIHZlY3RvciB3aXRoIHRoZSBzb2x1dGlvbiB0byB0aGUgbGluZWFyIHN5c3RlbSBBICogeCA9IGJcbiAgICovXG4gIHZhciBsdXNvbHZlID0gdHlwZWQoJ2x1c29sdmUnLCB7XG4gICAgXG4gICAgJ0FycmF5LCBBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAvLyBjb252ZXJ0IGEgdG8gbWF0cml4XG4gICAgICBhID0gbWF0cml4KGEpO1xuICAgICAgLy8gbWF0cml4IGx1cCBkZWNvbXBvc2l0aW9uXG4gICAgICB2YXIgZCA9IGx1cChhKTtcbiAgICAgIC8vIHNvbHZlXG4gICAgICB2YXIgeCA9IF9sdXNvbHZlKGQuTCwgZC5VLCBkLnAsIG51bGwsIGIpO1xuICAgICAgLy8gY29udmVydCByZXN1bHQgdG8gYXJyYXlcbiAgICAgIHJldHVybiB4LnZhbHVlT2YoKTtcbiAgICB9LFxuICAgIFxuICAgICdEZW5zZU1hdHJpeCwgQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgLy8gbWF0cml4IGx1cCBkZWNvbXBvc2l0aW9uXG4gICAgICB2YXIgZCA9IGx1cChhKTtcbiAgICAgIC8vIHNvbHZlXG4gICAgICByZXR1cm4gX2x1c29sdmUoZC5MLCBkLlUsIGQucCwgbnVsbCwgYik7XG4gICAgfSxcbiAgICBcbiAgICAnU3BhcnNlTWF0cml4LCBBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAvLyBtYXRyaXggbHVwIGRlY29tcG9zaXRpb25cbiAgICAgIHZhciBkID0gbHVwKGEpO1xuICAgICAgLy8gc29sdmVcbiAgICAgIHJldHVybiBfbHVzb2x2ZShkLkwsIGQuVSwgZC5wLCBudWxsLCBiKTtcbiAgICB9LFxuICAgIFxuICAgICdTcGFyc2VNYXRyaXgsIEFycmF5IHwgTWF0cml4LCBudW1iZXIsIG51bWJlcic6IGZ1bmN0aW9uIChhLCBiLCBvcmRlciwgdGhyZXNob2xkKSB7XG4gICAgICAvLyBtYXRyaXggbHUgZGVjb21wb3NpdGlvblxuICAgICAgdmFyIGQgPSBzbHUoYSwgb3JkZXIsIHRocmVzaG9sZCk7XG4gICAgICAvLyBzb2x2ZVxuICAgICAgcmV0dXJuIF9sdXNvbHZlKGQuTCwgZC5VLCBkLnAsIGQucSwgYik7XG4gICAgfSxcblxuICAgICdPYmplY3QsIEFycmF5IHwgTWF0cml4JzogZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgIC8vIHNvbHZlXG4gICAgICByZXR1cm4gX2x1c29sdmUoZC5MLCBkLlUsIGQucCwgZC5xLCBiKTtcbiAgICB9XG4gIH0pO1xuICBcbiAgdmFyIF90b01hdHJpeCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgLy8gY2hlY2sgaXQgaXMgYSBtYXRyaXhcbiAgICBpZiAoYSAmJiBhLmlzTWF0cml4ID09PSB0cnVlKVxuICAgICAgcmV0dXJuIGE7XG4gICAgLy8gY2hlY2sgYXJyYXlcbiAgICBpZiAoaXNBcnJheShhKSlcbiAgICAgIHJldHVybiBtYXRyaXgoYSk7XG4gICAgLy8gdGhyb3dcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIE1hdHJpeCBMVSBkZWNvbXBvc2l0aW9uJyk7XG4gIH07XG4gIFxuICB2YXIgX2x1c29sdmUgPSBmdW5jdGlvbiAobCwgdSwgcCwgcSwgYikge1xuICAgIC8vIHZlcmlmeSBMLCBVLCBQXG4gICAgbCA9IF90b01hdHJpeChsKTtcbiAgICB1ID0gX3RvTWF0cml4KHUpO1xuICAgIC8vIHZhbGlkYXRlIG1hdHJpeCBhbmQgdmVjdG9yXG4gICAgYiA9IHNvbHZlVmFsaWRhdGlvbihsLCBiLCBmYWxzZSk7XG4gICAgLy8gYXBwbHkgcm93IHBlcm11dGF0aW9ucyBpZiBuZWVkZWQgKGIgaXMgYSBEZW5zZU1hdHJpeClcbiAgICBpZiAocClcbiAgICAgIGIuX2RhdGEgPSBjc19pcHZlYyhwLCBiLl9kYXRhKTtcbiAgICAvLyB1c2UgZm9yd2FyZCBzdWJzdGl0dXRpb24gdG8gcmVzb2x2ZSBMICogeSA9IGJcbiAgICB2YXIgeSA9IGxzb2x2ZShsLCBiKTtcbiAgICAvLyB1c2UgYmFja3dhcmQgc3Vic3RpdHV0aW9uIHRvIHJlc29sdmUgVSAqIHggPSB5XG4gICAgdmFyIHggPSB1c29sdmUodSwgeSk7XG4gICAgLy8gYXBwbHkgY29sdW1uIHBlcm11dGF0aW9ucyBpZiBuZWVkZWQgKHggaXMgYSBEZW5zZU1hdHJpeClcbiAgICBpZiAocSlcbiAgICAgIHguX2RhdGEgPSBjc19pcHZlYyhxLCB4Ll9kYXRhKTtcbiAgICAvLyByZXR1cm4gc29sdXRpb25cbiAgICByZXR1cm4geDtcbiAgfTtcblxuICByZXR1cm4gbHVzb2x2ZTtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2x1c29sdmUnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuXG4gIHZhciBtYXRyaXggPSBsb2FkKHJlcXVpcmUoJy4uLy4uLy4uL3R5cGUvbWF0cml4L2Z1bmN0aW9uL21hdHJpeCcpKTtcbiAgdmFyIGRpdmlkZVNjYWxhciA9IGxvYWQocmVxdWlyZSgnLi4vLi4vYXJpdGhtZXRpYy9kaXZpZGVTY2FsYXInKSk7XG4gIHZhciBtdWx0aXBseVNjYWxhciA9IGxvYWQocmVxdWlyZSgnLi4vLi4vYXJpdGhtZXRpYy9tdWx0aXBseVNjYWxhcicpKTtcbiAgdmFyIHN1YnRyYWN0ID0gbG9hZChyZXF1aXJlKCcuLi8uLi9hcml0aG1ldGljL3N1YnRyYWN0JykpO1xuICB2YXIgZXF1YWxTY2FsYXIgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3JlbGF0aW9uYWwvZXF1YWxTY2FsYXInKSk7XG5cbiAgdmFyIHNvbHZlVmFsaWRhdGlvbiA9IGxvYWQocmVxdWlyZSgnLi91dGlscy9zb2x2ZVZhbGlkYXRpb24nKSk7XG4gIFxuICB2YXIgRGVuc2VNYXRyaXggPSB0eXBlLkRlbnNlTWF0cml4O1xuXG4gIC8qKlxuICAgKiBTb2x2ZXMgdGhlIGxpbmVhciBlcXVhdGlvbiBzeXN0ZW0gYnkgYmFja3dhcmQgc3Vic3RpdHV0aW9uLiBNYXRyaXggbXVzdCBiZSBhbiB1cHBlciB0cmlhbmd1bGFyIG1hdHJpeC5cbiAgICpcbiAgICogYFUgKiB4ID0gYmBcbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLnVzb2x2ZShVLCBiKTtcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIHZhciBhID0gW1stMiwgM10sIFsyLCAxXV07XG4gICAqICAgIHZhciBiID0gWzExLCA5XTtcbiAgICogICAgdmFyIHggPSB1c29sdmUoYSwgYik7ICAvLyBbWzhdLCBbOV1dXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBsdXAsIHNsdSwgdXNvbHZlLCBsdXNvbHZlXG4gICAqXG4gICAqIEBwYXJhbSB7TWF0cml4LCBBcnJheX0gVSAgICAgICBBIE4geCBOIG1hdHJpeCBvciBhcnJheSAoVSlcbiAgICogQHBhcmFtIHtNYXRyaXgsIEFycmF5fSBiICAgICAgIEEgY29sdW1uIHZlY3RvciB3aXRoIHRoZSBiIHZhbHVlc1xuICAgKlxuICAgKiBAcmV0dXJuIHtEZW5zZU1hdHJpeCB8IEFycmF5fSAgQSBjb2x1bW4gdmVjdG9yIHdpdGggdGhlIGxpbmVhciBzeXN0ZW0gc29sdXRpb24gKHgpXG4gICAqL1xuICB2YXIgdXNvbHZlID0gdHlwZWQoJ3Vzb2x2ZScsIHtcbiAgICBcbiAgICAnU3BhcnNlTWF0cml4LCBBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uIChtLCBiKSB7XG4gICAgICAvLyBwcm9jZXNzIG1hdHJpeFxuICAgICAgcmV0dXJuIF9zcGFyc2VCYWNrd2FyZFN1YnN0aXR1dGlvbihtLCBiKTtcbiAgICB9LFxuXG4gICAgJ0RlbnNlTWF0cml4LCBBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uIChtLCBiKSB7XG4gICAgICAvLyBwcm9jZXNzIG1hdHJpeFxuICAgICAgcmV0dXJuIF9kZW5zZUJhY2t3YXJkU3Vic3RpdHV0aW9uKG0sIGIpO1xuICAgIH0sXG5cbiAgICAnQXJyYXksIEFycmF5IHwgTWF0cml4JzogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIC8vIGNyZWF0ZSBkZW5zZSBtYXRyaXggZnJvbSBhcnJheVxuICAgICAgdmFyIG0gPSBtYXRyaXgoYSk7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICB2YXIgciA9IF9kZW5zZUJhY2t3YXJkU3Vic3RpdHV0aW9uKG0sIGIpO1xuICAgICAgLy8gcmVzdWx0XG4gICAgICByZXR1cm4gci52YWx1ZU9mKCk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgX2RlbnNlQmFja3dhcmRTdWJzdGl0dXRpb24gPSBmdW5jdGlvbiAobSwgYikge1xuICAgIC8vIHZhbGlkYXRlIG1hdHJpeCBhbmQgdmVjdG9yLCByZXR1cm4gY29weSBvZiBjb2x1bW4gdmVjdG9yIGJcbiAgICBiID0gc29sdmVWYWxpZGF0aW9uKG0sIGIsIHRydWUpO1xuICAgIC8vIGNvbHVtbiB2ZWN0b3IgZGF0YVxuICAgIHZhciBiZGF0YSA9IGIuX2RhdGE7XG4gICAgLy8gcm93cyAmIGNvbHVtbnNcbiAgICB2YXIgcm93cyA9IG0uX3NpemVbMF07XG4gICAgdmFyIGNvbHVtbnMgPSBtLl9zaXplWzFdO1xuICAgIC8vIHJlc3VsdFxuICAgIHZhciB4ID0gW107XG4gICAgLy8gYXJyYXlzXG4gICAgdmFyIGRhdGEgPSBtLl9kYXRhO1xuICAgIC8vIGJhY2t3YXJkIHNvbHZlIG0gKiB4ID0gYiwgbG9vcCBjb2x1bW5zIChiYWNrd2FyZHMpXG4gICAgZm9yICh2YXIgaiA9IGNvbHVtbnMgLSAxOyBqID49IDAgOyBqLS0pIHtcbiAgICAgIC8vIGJbal1cbiAgICAgIHZhciBiaiA9IGJkYXRhW2pdWzBdIHx8IDA7XG4gICAgICAvLyB4W2pdXG4gICAgICB2YXIgeGo7XG4gICAgICAvLyBiYWNrd2FyZCBzdWJzdGl0dXRpb24gKG91dGVyIHByb2R1Y3QpIGF2b2lkcyBpbm5lciBsb29waW5nIHdoZW4gYmogPT0gMFxuICAgICAgaWYgKCFlcXVhbFNjYWxhcihiaiwgMCkpIHtcbiAgICAgICAgLy8gdmFsdWUgQCBbaiwgal1cbiAgICAgICAgdmFyIHZqaiA9IGRhdGFbal1bal07XG4gICAgICAgIC8vIGNoZWNrIHZqalxuICAgICAgICBpZiAoZXF1YWxTY2FsYXIodmpqLCAwKSkge1xuICAgICAgICAgIC8vIHN5c3RlbSBjYW5ub3QgYmUgc29sdmVkXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMaW5lYXIgc3lzdGVtIGNhbm5vdCBiZSBzb2x2ZWQgc2luY2UgbWF0cml4IGlzIHNpbmd1bGFyJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2FsY3VsYXRlIHhqXG4gICAgICAgIHhqID0gZGl2aWRlU2NhbGFyKGJqLCB2amopOyAgICAgICAgXG4gICAgICAgIC8vIGxvb3Agcm93c1xuICAgICAgICBmb3IgKHZhciBpID0gaiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgLy8gdXBkYXRlIGNvcHkgb2YgYlxuICAgICAgICAgIGJkYXRhW2ldID0gW3N1YnRyYWN0KGJkYXRhW2ldWzBdIHx8IDAsIG11bHRpcGx5U2NhbGFyKHhqLCBkYXRhW2ldW2pdKSldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gemVybyB2YWx1ZSBAIGpcbiAgICAgICAgeGogPSAwO1xuICAgICAgfVxuICAgICAgLy8gdXBkYXRlIHhcbiAgICAgIHhbal0gPSBbeGpdO1xuICAgIH1cbiAgICAvLyByZXR1cm4gY29sdW1uIHZlY3RvclxuICAgIHJldHVybiBuZXcgRGVuc2VNYXRyaXgoe1xuICAgICAgZGF0YTogeCxcbiAgICAgIHNpemU6IFtyb3dzLCAxXVxuICAgIH0pO1xuICB9O1xuICBcbiAgdmFyIF9zcGFyc2VCYWNrd2FyZFN1YnN0aXR1dGlvbiA9IGZ1bmN0aW9uIChtLCBiKSB7XG4gICAgLy8gdmFsaWRhdGUgbWF0cml4IGFuZCB2ZWN0b3IsIHJldHVybiBjb3B5IG9mIGNvbHVtbiB2ZWN0b3IgYlxuICAgIGIgPSBzb2x2ZVZhbGlkYXRpb24obSwgYiwgdHJ1ZSk7XG4gICAgLy8gY29sdW1uIHZlY3RvciBkYXRhXG4gICAgdmFyIGJkYXRhID0gYi5fZGF0YTtcbiAgICAvLyByb3dzICYgY29sdW1uc1xuICAgIHZhciByb3dzID0gbS5fc2l6ZVswXTtcbiAgICB2YXIgY29sdW1ucyA9IG0uX3NpemVbMV07XG4gICAgLy8gbWF0cml4IGFycmF5c1xuICAgIHZhciB2YWx1ZXMgPSBtLl92YWx1ZXM7XG4gICAgdmFyIGluZGV4ID0gbS5faW5kZXg7XG4gICAgdmFyIHB0ciA9IG0uX3B0cjtcbiAgICAvLyB2YXJzXG4gICAgdmFyIGksIGs7XG4gICAgLy8gcmVzdWx0XG4gICAgdmFyIHggPSBbXTtcbiAgICAvLyBiYWNrd2FyZCBzb2x2ZSBtICogeCA9IGIsIGxvb3AgY29sdW1ucyAoYmFja3dhcmRzKVxuICAgIGZvciAodmFyIGogPSBjb2x1bW5zIC0gMTsgaiA+PSAwIDsgai0tKSB7XG4gICAgICAvLyBiW2pdXG4gICAgICB2YXIgYmogPSBiZGF0YVtqXVswXSB8fCAwO1xuICAgICAgLy8gYmFja3dhcmQgc3Vic3RpdHV0aW9uIChvdXRlciBwcm9kdWN0KSBhdm9pZHMgaW5uZXIgbG9vcGluZyB3aGVuIGJqID09IDBcbiAgICAgIGlmICghZXF1YWxTY2FsYXIoYmosIDApKSB7XG4gICAgICAgIC8vIHZhbHVlIEAgW2osIGpdXG4gICAgICAgIHZhciB2amogPSAwO1xuICAgICAgICAvLyB1cHBlciB0cmlhbmd1bGFyIG1hdHJpeCB2YWx1ZXMgJiBpbmRleCAoY29sdW1uIGopXG4gICAgICAgIHZhciBqdmFsdWVzID0gW107XG4gICAgICAgIHZhciBqaW5kZXggPSBbXTtcbiAgICAgICAgLy8gZmlyc3QgJiBsYXN0IGluZGVjZXMgaW4gY29sdW1uXG4gICAgICAgIHZhciBmID0gcHRyW2pdO1xuICAgICAgICB2YXIgbCA9IHB0cltqICsgMV07XG4gICAgICAgIC8vIHZhbHVlcyBpbiBjb2x1bW4sIGZpbmQgdmFsdWUgQCBbaiwgal0sIGxvb3AgYmFja3dhcmRzXG4gICAgICAgIGZvciAoayA9IGwgLSAxOyBrID49IGY7IGstLSkge1xuICAgICAgICAgIC8vIHJvd1xuICAgICAgICAgIGkgPSBpbmRleFtrXTtcbiAgICAgICAgICAvLyBjaGVjayByb3dcbiAgICAgICAgICBpZiAoaSA9PT0gaikge1xuICAgICAgICAgICAgLy8gdXBkYXRlIHZqalxuICAgICAgICAgICAgdmpqID0gdmFsdWVzW2tdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpIDwgaikge1xuICAgICAgICAgICAgLy8gc3RvcmUgdXBwZXIgdHJpYW5ndWxhclxuICAgICAgICAgICAganZhbHVlcy5wdXNoKHZhbHVlc1trXSk7XG4gICAgICAgICAgICBqaW5kZXgucHVzaChpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXQgdGhpcyBwb2ludCB3ZSBtdXN0IGhhdmUgYSB2YWx1ZSBAIFtqLCBqXVxuICAgICAgICBpZiAoZXF1YWxTY2FsYXIodmpqLCAwKSkge1xuICAgICAgICAgIC8vIHN5c3RlbSBjYW5ub3QgYmUgc29sdmVkLCB0aGVyZSBpcyBubyB2YWx1ZSBAIFtqLCBqXVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTGluZWFyIHN5c3RlbSBjYW5ub3QgYmUgc29sdmVkIHNpbmNlIG1hdHJpeCBpcyBzaW5ndWxhcicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNhbGN1bGF0ZSB4alxuICAgICAgICB2YXIgeGogPSBkaXZpZGVTY2FsYXIoYmosIHZqaik7XG4gICAgICAgIC8vIGxvb3AgdXBwZXIgdHJpYW5ndWxhclxuICAgICAgICBmb3IgKGsgPSAwLCBsID0gamluZGV4Lmxlbmd0aDsgayA8IGw7IGsrKykge1xuICAgICAgICAgIC8vIHJvd1xuICAgICAgICAgIGkgPSBqaW5kZXhba107XG4gICAgICAgICAgLy8gdXBkYXRlIGNvcHkgb2YgYlxuICAgICAgICAgIGJkYXRhW2ldID0gW3N1YnRyYWN0KGJkYXRhW2ldWzBdLCBtdWx0aXBseVNjYWxhcih4aiwganZhbHVlc1trXSkpXTtcbiAgICAgICAgfVxuICAgICAgICAvLyB1cGRhdGUgeFxuICAgICAgICB4W2pdID0gW3hqXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyB1cGRhdGUgeFxuICAgICAgICB4W2pdID0gWzBdO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyByZXR1cm4gdmVjdG9yXG4gICAgcmV0dXJuIG5ldyBEZW5zZU1hdHJpeCh7XG4gICAgICBkYXRhOiB4LFxuICAgICAgc2l6ZTogW3Jvd3MsIDFdXG4gICAgfSk7XG4gIH07XG4gIFxuICByZXR1cm4gdXNvbHZlO1xufVxuXG5leHBvcnRzLm5hbWUgPSAndXNvbHZlJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vdXRpbHMvaW5kZXgnKTtcblxudmFyIHN0cmluZyA9IHV0aWwuc3RyaW5nO1xudmFyIGFycmF5ID0gdXRpbC5hcnJheTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlKSB7XG4gIFxuICB2YXIgRGVuc2VNYXRyaXggPSB0eXBlLkRlbnNlTWF0cml4O1xuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgbWF0cml4IGFuZCBjb2x1bW4gdmVjdG9yIGIgZm9yIGJhY2t3YXJkL2ZvcndhcmQgc3Vic3RpdHV0aW9uIGFsZ29yaXRobXMuXG4gICAqXG4gICAqIEBwYXJhbSB7TWF0cml4fSBtICAgICAgICAgICAgQW4gTiB4IE4gbWF0cml4XG4gICAqIEBwYXJhbSB7QXJyYXkgfCBNYXRyaXh9IGIgICAgQSBjb2x1bW4gdmVjdG9yXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gY29weSAgICAgICAgUmV0dXJuIGEgY29weSBvZiB2ZWN0b3IgYlxuICAgKlxuICAgKiBAcmV0dXJuIHtEZW5zZU1hdHJpeH0gICAgICAgIERlbnNlIGNvbHVtbiB2ZWN0b3IgYlxuICAgKi9cbiAgdmFyIHNvbHZlVmFsaWRhdGlvbiA9IGZ1bmN0aW9uIChtLCBiLCBjb3B5KSB7XG4gICAgLy8gbWF0cml4IHNpemVcbiAgICB2YXIgc2l6ZSA9IG0uc2l6ZSgpO1xuICAgIC8vIHZhbGlkYXRlIG1hdHJpeCBkaW1lbnNpb25zXG4gICAgaWYgKHNpemUubGVuZ3RoICE9PSAyKVxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ01hdHJpeCBtdXN0IGJlIHR3byBkaW1lbnNpb25hbCAoc2l6ZTogJyArIHN0cmluZy5mb3JtYXQoc2l6ZSkgKyAnKScpO1xuICAgIC8vIHJvd3MgJiBjb2x1bW5zXG4gICAgdmFyIHJvd3MgPSBzaXplWzBdO1xuICAgIHZhciBjb2x1bW5zID0gc2l6ZVsxXTsgICAgXG4gICAgLy8gdmFsaWRhdGUgcm93cyAmIGNvbHVtbnNcbiAgICBpZiAocm93cyAhPT0gY29sdW1ucykgXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignTWF0cml4IG11c3QgYmUgc3F1YXJlIChzaXplOiAnICsgc3RyaW5nLmZvcm1hdChzaXplKSArICcpJyk7XG4gICAgLy8gdmFyc1xuICAgIHZhciBkYXRhLCBpLCBiZGF0YTtcbiAgICAvLyBjaGVjayBiIGlzIG1hdHJpeFxuICAgIGlmIChiICYmIGIuaXNNYXRyaXggPT09IHRydWUpIHtcbiAgICAgIC8vIG1hdHJpeCBzaXplXG4gICAgICB2YXIgbXNpemUgPSBiLnNpemUoKTtcbiAgICAgIC8vIHZlY3RvclxuICAgICAgaWYgKG1zaXplLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyBjaGVjayB2ZWN0b3IgbGVuZ3RoXG4gICAgICAgIGlmIChtc2l6ZVswXSAhPT0gcm93cylcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignRGltZW5zaW9uIG1pc21hdGNoLiBNYXRyaXggY29sdW1ucyBtdXN0IG1hdGNoIHZlY3RvciBsZW5ndGguJyk7XG4gICAgICAgIC8vIGNyZWF0ZSBkYXRhIGFycmF5XG4gICAgICAgIGRhdGEgPSBbXTtcbiAgICAgICAgLy8gbWF0cml4IGRhdGEgKERlbnNlTWF0cml4KVxuICAgICAgICBiZGF0YSA9IGIuX2RhdGE7XG4gICAgICAgIC8vIGxvb3AgYiBkYXRhXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgICAgICAvLyByb3cgYXJyYXlcbiAgICAgICAgICBkYXRhW2ldID0gW2JkYXRhW2ldXTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXR1cm4gRGVuc2UgTWF0cml4XG4gICAgICAgIHJldHVybiBuZXcgRGVuc2VNYXRyaXgoe1xuICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgc2l6ZTogW3Jvd3MsIDFdLFxuICAgICAgICAgIGRhdGF0eXBlOiBiLl9kYXRhdHlwZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIHR3byBkaW1lbnNpb25zXG4gICAgICBpZiAobXNpemUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIC8vIGFycmF5IG11c3QgYmUgYSBjb2x1bW4gdmVjdG9yXG4gICAgICAgIGlmIChtc2l6ZVswXSAhPT0gcm93cyB8fCBtc2l6ZVsxXSAhPT0gMSlcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignRGltZW5zaW9uIG1pc21hdGNoLiBNYXRyaXggY29sdW1ucyBtdXN0IG1hdGNoIHZlY3RvciBsZW5ndGguJyk7XG4gICAgICAgIC8vIGNoZWNrIG1hdHJpeCB0eXBlXG4gICAgICAgIGlmIChiLmlzRGVuc2VNYXRyaXggPT09IHRydWUpIHtcbiAgICAgICAgICAvLyBjaGVjayBhIGNvcHkgaXMgbmVlZGVkXG4gICAgICAgICAgaWYgKGNvcHkpIHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBkYXRhIGFycmF5XG4gICAgICAgICAgICBkYXRhID0gW107XG4gICAgICAgICAgICAvLyBtYXRyaXggZGF0YSAoRGVuc2VNYXRyaXgpXG4gICAgICAgICAgICBiZGF0YSA9IGIuX2RhdGE7XG4gICAgICAgICAgICAvLyBsb29wIGIgZGF0YVxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgICAgICAgICAvLyByb3cgYXJyYXlcbiAgICAgICAgICAgICAgZGF0YVtpXSA9IFtiZGF0YVtpXVswXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZXR1cm4gRGVuc2UgTWF0cml4XG4gICAgICAgICAgICByZXR1cm4gbmV3IERlbnNlTWF0cml4KHtcbiAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgc2l6ZTogW3Jvd3MsIDFdLFxuICAgICAgICAgICAgICBkYXRhdHlwZTogYi5fZGF0YXR5cGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBiIGlzIGFscmVhZHkgYSBjb2x1bW4gdmVjdG9yXG4gICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY3JlYXRlIGRhdGEgYXJyYXlcbiAgICAgICAgZGF0YSA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcm93czsgaSsrKVxuICAgICAgICAgIGRhdGFbaV0gPSBbMF07XG4gICAgICAgIC8vIHNwYXJzZSBtYXRyaXggYXJyYXlzXG4gICAgICAgIHZhciB2YWx1ZXMgPSBiLl92YWx1ZXM7XG4gICAgICAgIHZhciBpbmRleCA9IGIuX2luZGV4O1xuICAgICAgICB2YXIgcHRyID0gYi5fcHRyO1xuICAgICAgICAvLyBsb29wIHZhbHVlcyBpbiBjb2x1bW4gMFxuICAgICAgICBmb3IgKHZhciBrMSA9IHB0clsxXSwgayA9IHB0clswXTsgayA8IGsxOyBrKyspIHtcbiAgICAgICAgICAvLyByb3dcbiAgICAgICAgICBpID0gaW5kZXhba107XG4gICAgICAgICAgLy8gYWRkIHRvIGRhdGFcbiAgICAgICAgICBkYXRhW2ldWzBdID0gdmFsdWVzW2tdOyBcbiAgICAgICAgfVxuICAgICAgICAvLyByZXR1cm4gRGVuc2UgTWF0cml4XG4gICAgICAgIHJldHVybiBuZXcgRGVuc2VNYXRyaXgoe1xuICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgc2l6ZTogW3Jvd3MsIDFdLFxuICAgICAgICAgIGRhdGF0eXBlOiBiLl9kYXRhdHlwZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIHRocm93IGVycm9yXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignRGltZW5zaW9uIG1pc21hdGNoLiBNYXRyaXggY29sdW1ucyBtdXN0IG1hdGNoIHZlY3RvciBsZW5ndGguJyk7XG4gICAgfVxuICAgIC8vIGNoZWNrIGIgaXMgYXJyYXlcbiAgICBpZiAoaXNBcnJheShiKSkge1xuICAgICAgLy8gc2l6ZVxuICAgICAgdmFyIGFzaXplID0gYXJyYXkuc2l6ZShiKTtcbiAgICAgIC8vIGNoZWNrIG1hdHJpeCBkaW1lbnNpb25zLCB2ZWN0b3JcbiAgICAgIGlmIChhc2l6ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgLy8gY2hlY2sgdmVjdG9yIGxlbmd0aFxuICAgICAgICBpZiAoYXNpemVbMF0gIT09IHJvd3MpXG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0RpbWVuc2lvbiBtaXNtYXRjaC4gTWF0cml4IGNvbHVtbnMgbXVzdCBtYXRjaCB2ZWN0b3IgbGVuZ3RoLicpOyAgICAgICAgXG4gICAgICAgIC8vIGNyZWF0ZSBkYXRhIGFycmF5XG4gICAgICAgIGRhdGEgPSBbXTtcbiAgICAgICAgLy8gbG9vcCBiXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgICAgICAvLyByb3cgYXJyYXlcbiAgICAgICAgICBkYXRhW2ldID0gW2JbaV1dO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJldHVybiBEZW5zZSBNYXRyaXhcbiAgICAgICAgcmV0dXJuIG5ldyBEZW5zZU1hdHJpeCh7XG4gICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICBzaXplOiBbcm93cywgMV1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoYXNpemUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIC8vIGFycmF5IG11c3QgYmUgYSBjb2x1bW4gdmVjdG9yXG4gICAgICAgIGlmIChhc2l6ZVswXSAhPT0gcm93cyB8fCBhc2l6ZVsxXSAhPT0gMSlcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignRGltZW5zaW9uIG1pc21hdGNoLiBNYXRyaXggY29sdW1ucyBtdXN0IG1hdGNoIHZlY3RvciBsZW5ndGguJyk7XG4gICAgICAgIC8vIGNyZWF0ZSBkYXRhIGFycmF5XG4gICAgICAgIGRhdGEgPSBbXTtcbiAgICAgICAgLy8gbG9vcCBiIGRhdGFcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgICAgIC8vIHJvdyBhcnJheVxuICAgICAgICAgIGRhdGFbaV0gPSBbYltpXVswXV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmV0dXJuIERlbnNlIE1hdHJpeFxuICAgICAgICByZXR1cm4gbmV3IERlbnNlTWF0cml4KHtcbiAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgIHNpemU6IFtyb3dzLCAxXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIHRocm93IGVycm9yXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignRGltZW5zaW9uIG1pc21hdGNoLiBNYXRyaXggY29sdW1ucyBtdXN0IG1hdGNoIHZlY3RvciBsZW5ndGguJyk7ICAgICAgXG4gICAgfVxuICB9O1xuICBcbiAgcmV0dXJuIHNvbHZlVmFsaWRhdGlvbjtcbn1cblxuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTsiLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCkge1xuXG4gIHZhciBjc19mbGlwID0gbG9hZChyZXF1aXJlKCcuL2NzX2ZsaXAnKSk7XG4gIHZhciBjc19ma2VlcCA9IGxvYWQocmVxdWlyZSgnLi9jc19ma2VlcCcpKTtcbiAgdmFyIGNzX3RkZnMgPSBsb2FkKHJlcXVpcmUoJy4vY3NfdGRmcycpKTtcbiAgXG4gIHZhciBhZGQgICAgICAgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL2FyaXRobWV0aWMvYWRkJykpO1xuICB2YXIgbXVsdGlwbHkgID0gbG9hZChyZXF1aXJlKCcuLi8uLi9hcml0aG1ldGljL211bHRpcGx5JykpO1xuICB2YXIgdHJhbnNwb3NlID0gbG9hZChyZXF1aXJlKCcuLi8uLi9tYXRyaXgvdHJhbnNwb3NlJykpO1xuXG4gIC8qKlxuICAgKiBBcHByb3hpbWF0ZSBtaW5pbXVtIGRlZ3JlZSBvcmRlcmluZy4gVGhlIG1pbmltdW0gZGVncmVlIGFsZ29yaXRobSBpcyBhIHdpZGVseSB1c2VkIFxuICAgKiBoZXVyaXN0aWMgZm9yIGZpbmRpbmcgYSBwZXJtdXRhdGlvbiBQIHNvIHRoYXQgUCpBKlAnIGhhcyBmZXdlciBub256ZXJvcyBpbiBpdHMgZmFjdG9yaXphdGlvblxuICAgKiB0aGFuIEEuIEl0IGlzIGEgZ3JlYWR5IG1ldGhvZCB0aGF0IHNlbGVjdHMgdGhlIHNwYXJzZXN0IHBpdm90IHJvdyBhbmQgY29sdW1uIGR1cmluZyB0aGUgY291cnNlXG4gICAqIG9mIGEgcmlnaHQgbG9va2luZyBzcGFyc2UgQ2hvbGVza3kgZmFjdG9yaXphdGlvbi5cbiAgICpcbiAgICogUmVmZXJlbmNlOiBodHRwOi8vZmFjdWx0eS5jc2UudGFtdS5lZHUvZGF2aXMvcHVibGljYXRpb25zLmh0bWxcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9yZGVyICAgIDA6IE5hdHVyYWwsIDE6IENob2xlc2t5LCAyOiBMVSwgMzogUVJcbiAgICogQHBhcmFtIHtNYXRyaXh9IG0gICAgICAgIFNwYXJzZSBNYXRyaXhcbiAgICpcbiAgICogUmVmZXJlbmNlOiBodHRwOi8vZmFjdWx0eS5jc2UudGFtdS5lZHUvZGF2aXMvcHVibGljYXRpb25zLmh0bWxcbiAgICovXG4gIHZhciBjc19hbWQgPSBmdW5jdGlvbiAob3JkZXIsIGEpIHtcbiAgICAvLyBjaGVjayBpbnB1dCBwYXJhbWV0ZXJzXG4gICAgaWYgKCFhIHx8IG9yZGVyIDw9IDAgfHwgb3JkZXIgPiAzKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgLy8gYSBtYXRyaXggYXJyYXlzXG4gICAgdmFyIGFzaXplID0gYS5fc2l6ZTtcbiAgICAvLyByb3dzIGFuZCBjb2x1bW5zXG4gICAgdmFyIG0gPSBhc2l6ZVswXTtcbiAgICB2YXIgbiA9IGFzaXplWzFdOyAgICBcbiAgICAvLyBpbml0aWFsaXplIHZhcnNcbiAgICB2YXIgbGVtYXggPSAwO1xuICAgIC8vIGRlbnNlIHRocmVzaG9sZFxuICAgIHZhciBkZW5zZSA9IE1hdGgubWF4KDE2LCAxMCAqIE1hdGguc3FydChuKSk7XG4gICAgZGVuc2UgPSBNYXRoLm1pbihuIC0gMiwgZGVuc2UpO1xuICAgIC8vIGNyZWF0ZSB0YXJnZXQgbWF0cml4IENcbiAgICB2YXIgY20gPSBfY3JlYXRlVGFyZ2V0TWF0cml4KG9yZGVyLCBhLCBtLCBuLCBkZW5zZSk7XG4gICAgLy8gZHJvcCBkaWFnb25hbCBlbnRyaWVzXG4gICAgY3NfZmtlZXAoY20sIF9kaWFnLCBudWxsKTtcbiAgICAvLyBDIG1hdHJpeCBhcnJheXNcbiAgICB2YXIgY2luZGV4ID0gY20uX2luZGV4O1xuICAgIHZhciBjcHRyID0gY20uX3B0cjtcblxuICAgIC8vIG51bWJlciBvZiBub256ZXJvIGVsZW1lbnRzIGluIENcbiAgICB2YXIgY256ID0gY3B0cltuXTtcbiAgICBcbiAgICAvLyBhbGxvY2F0ZSByZXN1bHQgKG4rMSlcbiAgICB2YXIgUCA9IFtdO1xuICAgIFxuICAgIC8vIGNyZWF0ZSB3b3Jrc3BhY2UgKDggKiAobiArIDEpKVxuICAgIHZhciBXID0gW107XG4gICAgdmFyIGxlbiA9IDA7IC8vIGZpcnN0IG4gKyAxIGVudHJpZXNcbiAgICB2YXIgbnYgPSBuICsgMTsgLy8gbmV4dCBuICsgMSBlbnRyaWVzXG4gICAgdmFyIG5leHQgPSAyICogKG4gKyAxKTsgLy8gbmV4dCBuICsgMSBlbnRyaWVzXG4gICAgdmFyIGhlYWQgPSAzICogKG4gKyAxKTsgIC8vIG5leHQgbiArIDEgZW50cmllc1xuICAgIHZhciBlbGVuID0gNCAqIChuICsgMSk7ICAvLyBuZXh0IG4gKyAxIGVudHJpZXNcbiAgICB2YXIgZGVncmVlID0gNSAqIChuICsgMSk7ICAvLyBuZXh0IG4gKyAxIGVudHJpZXNcbiAgICB2YXIgdyA9IDYgKiAobiArIDEpOyAgLy8gbmV4dCBuICsgMSBlbnRyaWVzXG4gICAgdmFyIGhoZWFkID0gNyAqIChuICsgMSk7ICAvLyBsYXN0IG4gKyAxIGVudHJpZXMgICAgXG5cbiAgICAvLyB1c2UgUCBhcyB3b3Jrc3BhY2UgZm9yIGxhc3RcbiAgICB2YXIgbGFzdCA9IFA7XG4gICAgXG4gICAgLy8gaW5pdGlhbGl6ZSBxdW90aWVudCBncmFwaFxuICAgIHZhciBtYXJrID0gX2luaXRpYWxpemVRdW90aWVudEdyYXBoKG4sIGNwdHIsIFcsIGxlbiwgaGVhZCwgbGFzdCwgbmV4dCwgaGhlYWQsIG52LCB3LCBlbGVuLCBkZWdyZWUpO1xuICAgIFxuICAgIC8vIGluaXRpYWxpemUgZGVncmVlIGxpc3RzXG4gICAgdmFyIG5lbCA9IF9pbml0aWFsaXplRGVncmVlTGlzdHMobiwgY3B0ciwgVywgZGVncmVlLCBlbGVuLCB3LCBkZW5zZSwgbnYsIGhlYWQsIGxhc3QsIG5leHQpO1xuICAgIFxuICAgIC8vIG1pbmltdW0gZGVncmVlIG5vZGVcbiAgICB2YXIgbWluZGVnID0gMDtcbiAgICBcbiAgICAvLyB2YXJzXG4gICAgdmFyIGksIGosIGssIGsxLCBrMiwgZSwgcGosIGxuLCBudmksIHBrLCBlbG4sIHAxLCBwMiwgcG4sIGgsIGQ7XG4gICAgXG4gICAgLy8gd2hpbGUgKHNlbGVjdGluZyBwaXZvdHMpIGRvXG4gICAgd2hpbGUgKG5lbCA8IG4pIHtcbiAgICAgIC8vIHNlbGVjdCBub2RlIG9mIG1pbmltdW0gYXBwcm94aW1hdGUgZGVncmVlLiBhbWQoKSBpcyBub3cgcmVhZHkgdG8gc3RhcnQgZWxpbWluYXRpbmcgdGhlIGdyYXBoLiBJdCBmaXJzdFxuICAgICAgLy8gZmluZHMgYSBub2RlIGsgb2YgbWluaW11bSBkZWdyZWUgYW5kIHJlbW92ZXMgaXQgZnJvbSBpdHMgZGVncmVlIGxpc3QuIFRoZSB2YXJpYWJsZSBuZWwga2VlcHMgdHJhY2sgb2YgdGhvd1xuICAgICAgLy8gbWFueSBub2RlcyBoYXZlIGJlZW4gZWxpbWluYXRlZC5cbiAgICAgIGZvciAoayA9IC0xOyBtaW5kZWcgPCBuICYmIChrID0gV1toZWFkICsgbWluZGVnXSkgPT0gLTE7IG1pbmRlZysrKTsgICAgICBcbiAgICAgIGlmIChXW25leHQgKyBrXSAhPSAtMSkgXG4gICAgICAgIGxhc3RbV1tuZXh0ICsga11dID0gLTE7XG4gICAgICAvLyByZW1vdmUgayBmcm9tIGRlZ3JlZSBsaXN0XG4gICAgICBXW2hlYWQgKyBtaW5kZWddID0gV1tuZXh0ICsga107XG4gICAgICAvLyBlbGVuayA9IHxFa3xcbiAgICAgIHZhciBlbGVuayA9IFdbZWxlbiArIGtdO1xuICAgICAgLy8gIyBvZiBub2RlcyBrIHJlcHJlc2VudHNcbiAgICAgIHZhciBudmsgPSBXW252ICsga107XG4gICAgICAvLyBXW252ICsga10gbm9kZXMgb2YgQSBlbGltaW5hdGVkXG4gICAgICBuZWwgKz0gbnZrO1xuXG4gICAgICAvLyBDb25zdHJ1Y3QgYSBuZXcgZWxlbWVudC4gVGhlIG5ldyBlbGVtZW50IExrIGlzIGNvbnN0cnVjdGVkIGluIHBsYWNlIGlmIHxFa3wgPSAwLiBudltpXSBpcyBcbiAgICAgIC8vIG5lZ2F0ZWQgZm9yIGFsbCBub2RlcyBpIGluIExrIHRvIGZsYWcgdGhlbSBhcyBtZW1iZXJzIG9mIHRoaXMgc2V0LiBFYWNoIG5vZGUgaSBpcyByZW1vdmVkIGZyb20gdGhlXG4gICAgICAvLyBkZWdyZWUgbGlzdHMuIEFsbCBlbGVtZW50cyBlIGluIEVrIGFyZSBhYnNvcnZlZCBpbnRvIGVsZW1lbnQgay5cbiAgICAgIHZhciBkayA9IDA7XG4gICAgICAvLyBmbGFnIGsgYXMgaW4gTGtcbiAgICAgIFdbbnYgKyBrXSA9IC1udms7XG4gICAgICB2YXIgcCA9IGNwdHJba107XG4gICAgICAvLyBkbyBpbiBwbGFjZSBpZiBXW2VsZW4gKyBrXSA9PSAwXG4gICAgICB2YXIgcGsxID0gKGVsZW5rID09PSAwKSA/IHAgOiBjbno7XG4gICAgICB2YXIgcGsyID0gcGsxO1xuICAgICAgZm9yIChrMSA9IDE7IGsxIDw9IGVsZW5rICsgMTsgazErKykge1xuICAgICAgICBpZiAoazEgPiBlbGVuaykge1xuICAgICAgICAgIC8vIHNlYXJjaCB0aGUgbm9kZXMgaW4ga1xuICAgICAgICAgIGUgPSBrO1xuICAgICAgICAgIC8vIGxpc3Qgb2Ygbm9kZXMgc3RhcnRzIGF0IGNpbmRleFtwal1cbiAgICAgICAgICBwaiA9IHA7XG4gICAgICAgICAgLy8gbGVuZ3RoIG9mIGxpc3Qgb2Ygbm9kZXMgaW4ga1xuICAgICAgICAgIGxuID0gV1tsZW4gKyBrXSAtIGVsZW5rO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIHNlYXJjaCB0aGUgbm9kZXMgaW4gZVxuICAgICAgICAgIGUgPSBjaW5kZXhbcCsrXTtcbiAgICAgICAgICBwaiA9IGNwdHJbZV07XG4gICAgICAgICAgLy8gbGVuZ3RoIG9mIGxpc3Qgb2Ygbm9kZXMgaW4gZVxuICAgICAgICAgIGxuID0gV1tsZW4gKyBlXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGsyID0gMTsgazIgPD0gbG47IGsyKyspIHtcbiAgICAgICAgICBpID0gY2luZGV4W3BqKytdO1xuICAgICAgICAgIC8vIGNoZWNrICBub2RlIGkgZGVhZCwgb3Igc2VlblxuICAgICAgICAgIGlmICgobnZpID0gV1tudiArIGldKSA8PSAwKSBcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIC8vIFdbZGVncmVlICsgTGtdICs9IHNpemUgb2Ygbm9kZSBpXG4gICAgICAgICAgZGsgKz0gbnZpO1xuICAgICAgICAgIC8vIG5lZ2F0ZSBXW252ICsgaV0gdG8gZGVub3RlIGkgaW4gTGtcbiAgICAgICAgICBXW252ICsgaV0gPSAtbnZpO1xuICAgICAgICAgIC8vIHBsYWNlIGkgaW4gTGtcbiAgICAgICAgICBjaW5kZXhbcGsyKytdID0gaTtcbiAgICAgICAgICBpZiAoV1tuZXh0ICsgaV0gIT0gLTEpIFxuICAgICAgICAgICAgbGFzdFtXW25leHQgKyBpXV0gPSBsYXN0W2ldO1xuICAgICAgICAgIC8vIGNoZWNrIHdlIG5lZWQgdG8gcmVtb3ZlIGkgZnJvbSBkZWdyZWUgbGlzdFxuICAgICAgICAgIGlmIChsYXN0W2ldICE9IC0xKSBcbiAgICAgICAgICAgIFdbbmV4dCArIGxhc3RbaV1dID0gV1tuZXh0ICsgaV07XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgV1toZWFkICsgV1tkZWdyZWUgKyBpXV0gPSBXW25leHQgKyBpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZSAhPSBrKSB7XG4gICAgICAgICAgLy8gYWJzb3JiIGUgaW50byBrXG4gICAgICAgICAgY3B0cltlXSA9IGNzX2ZsaXAoayk7XG4gICAgICAgICAgLy8gZSBpcyBub3cgYSBkZWFkIGVsZW1lbnRcbiAgICAgICAgICBXW3cgKyBlXSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGNpbmRleFtjbnouLi5uem1heF0gaXMgZnJlZVxuICAgICAgaWYgKGVsZW5rICE9PSAwKSBcbiAgICAgICAgY256ID0gcGsyO1xuICAgICAgLy8gZXh0ZXJuYWwgZGVncmVlIG9mIGsgLSB8TGtcXGl8XG4gICAgICBXW2RlZ3JlZSArIGtdID0gZGs7XG4gICAgICAvLyBlbGVtZW50IGsgaXMgaW4gY2luZGV4W3BrMS4ucGsyLTFdXG4gICAgICBjcHRyW2tdID0gcGsxO1xuICAgICAgV1tsZW4gKyBrXSA9IHBrMiAtIHBrMTtcbiAgICAgIC8vIGsgaXMgbm93IGFuIGVsZW1lbnRcbiAgICAgIFdbZWxlbiArIGtdID0gLTI7XG4gICAgICAgICAgICBcbiAgICAgIC8vIEZpbmQgc2V0IGRpZmZlcmVuY2VzLiBUaGUgc2NhbjEgZnVuY3Rpb24gbm93IGNvbXB1dGVzIHRoZSBzZXQgZGlmZmVyZW5jZXMgfExlIFxcIExrfCBmb3IgYWxsIGVsZW1lbnRzIGUuIEF0IHRoZSBzdGFydCBvZiB0aGVcbiAgICAgIC8vIHNjYW4sIG5vIGVudHJ5IGluIHRoZSB3IGFycmF5IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBtYXJrLlxuICAgICAgXG4gICAgICAvLyBjbGVhciB3IGlmIG5lY2Vzc2FyeVxuICAgICAgbWFyayA9IF93Y2xlYXIobWFyaywgbGVtYXgsIFcsIHcsIG4pO1xuICAgICAgLy8gc2NhbiAxOiBmaW5kIHxMZVxcTGt8XG4gICAgICBmb3IgKHBrID0gcGsxOyBwayA8IHBrMjsgcGsrKykge1xuICAgICAgICBpID0gY2luZGV4W3BrXTtcbiAgICAgICAgLy8gY2hlY2sgaWYgV1tlbGVuICsgaV0gZW1wdHksIHNraXAgaXRcbiAgICAgICAgaWYgKChlbG4gPSBXW2VsZW4gKyBpXSkgPD0gMCkgXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIC8vIFdbbnYgKyBpXSB3YXMgbmVnYXRlZFxuICAgICAgICBudmkgPSAtV1tudiArIGldO1xuICAgICAgICB2YXIgd252aSA9IG1hcmsgLSBudmk7XG4gICAgICAgIC8vIHNjYW4gRWlcbiAgICAgICAgZm9yIChwID0gY3B0cltpXSwgcDEgPSBjcHRyW2ldICsgZWxuIC0gMTsgcCA8PSBwMTsgcCsrKSB7XG4gICAgICAgICAgZSA9IGNpbmRleFtwXTtcbiAgICAgICAgICBpZiAoV1t3ICsgZV0gPj0gbWFyaykge1xuICAgICAgICAgICAgLy8gZGVjcmVtZW50IHxMZVxcTGt8XG4gICAgICAgICAgICBXW3cgKyBlXSAtPSBudmk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKFdbdyArIGVdICE9PSAwKSB7XG4gICAgICAgICAgICAvLyBlbnN1cmUgZSBpcyBhIGxpdmUgZWxlbWVudCwgMXN0IHRpbWUgZSBzZWVuIGluIHNjYW4gMVxuICAgICAgICAgICAgV1t3ICsgZV0gPSBXW2RlZ3JlZSArIGVdICsgd252aTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gZGVncmVlIHVwZGF0ZVxuICAgICAgLy8gVGhlIHNlY29uZCBwYXNzIGNvbXB1dGVzIHRoZSBhcHByb3hpbWF0ZSBkZWdyZWUgZGksIHBydW5lcyB0aGUgc2V0cyBFaSBhbmQgQWksIGFuZCBjb21wdXRlcyBhIGhhc2hcbiAgICAgIC8vIGZ1bmN0aW9uIGgoaSkgZm9yIGFsbCBub2RlcyBpbiBMay5cbiAgICAgIFxuICAgICAgLy8gc2NhbjI6IGRlZ3JlZSB1cGRhdGVcbiAgICAgIGZvciAocGsgPSBwazE7IHBrIDwgcGsyOyBwaysrKSB7XG4gICAgICAgIC8vIGNvbnNpZGVyIG5vZGUgaSBpbiBMa1xuICAgICAgICBpID0gY2luZGV4W3BrXTtcbiAgICAgICAgcDEgPSBjcHRyW2ldO1xuICAgICAgICBwMiA9IHAxICsgV1tlbGVuICsgaV0gLSAxO1xuICAgICAgICBwbiA9IHAxO1xuICAgICAgICAvLyBzY2FuIEVpXG4gICAgICAgIGZvciAoaCA9IDAsIGQgPSAwLCBwID0gcDE7IHAgPD0gcDI7IHArKykge1xuICAgICAgICAgIGUgPSBjaW5kZXhbcF07XG4gICAgICAgICAgLy8gY2hlY2sgZSBpcyBhbiB1bmFic29yYmVkIGVsZW1lbnRcbiAgICAgICAgICBpZiAoV1t3ICsgZV0gIT09IDApIHtcbiAgICAgICAgICAgIC8vIGRleHQgPSB8TGVcXExrfFxuICAgICAgICAgICAgdmFyIGRleHQgPSBXW3cgKyBlXSAtIG1hcms7XG4gICAgICAgICAgICBpZiAoZGV4dCA+IDApIHtcbiAgICAgICAgICAgICAgLy8gc3VtIHVwIHRoZSBzZXQgZGlmZmVyZW5jZXNcbiAgICAgICAgICAgICAgZCArPSBkZXh0O1xuICAgICAgICAgICAgICAvLyBrZWVwIGUgaW4gRWlcbiAgICAgICAgICAgICAgY2luZGV4W3BuKytdID0gZTtcbiAgICAgICAgICAgICAgLy8gY29tcHV0ZSB0aGUgaGFzaCBvZiBub2RlIGlcbiAgICAgICAgICAgICAgaCArPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGFnZ3Jlc3NpdmUgYWJzb3JiLiBlLT5rXG4gICAgICAgICAgICAgIGNwdHJbZV0gPSBjc19mbGlwKGspO1xuICAgICAgICAgICAgICAvLyBlIGlzIGEgZGVhZCBlbGVtZW50XG4gICAgICAgICAgICAgIFdbdyArIGVdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gV1tlbGVuICsgaV0gPSB8RWl8XG4gICAgICAgIFdbZWxlbiArIGldID0gcG4gLSBwMSArIDE7XG4gICAgICAgIHZhciBwMyA9IHBuO1xuICAgICAgICB2YXIgcDQgPSBwMSArIFdbbGVuICsgaV07XG4gICAgICAgIC8vIHBydW5lIGVkZ2VzIGluIEFpXG4gICAgICAgIGZvciAocCA9IHAyICsgMTsgcCA8IHA0OyBwKyspIHtcbiAgICAgICAgICBqID0gY2luZGV4W3BdO1xuICAgICAgICAgIC8vIGNoZWNrIG5vZGUgaiBkZWFkIG9yIGluIExrXG4gICAgICAgICAgdmFyIG52aiA9IFdbbnYgKyBqXTtcbiAgICAgICAgICBpZiAobnZqIDw9IDApIFxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgLy8gZGVncmVlKGkpICs9IHxqfFxuICAgICAgICAgIGQgKz0gbnZqO1xuICAgICAgICAgIC8vIHBsYWNlIGogaW4gbm9kZSBsaXN0IG9mIGlcbiAgICAgICAgICBjaW5kZXhbcG4rK10gPSBqO1xuICAgICAgICAgIC8vIGNvbXB1dGUgaGFzaCBmb3Igbm9kZSBpXG4gICAgICAgICAgaCArPSBqO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGZvciBtYXNzIGVsaW1pbmF0aW9uXG4gICAgICAgIGlmIChkID09PSAwKSB7XG4gICAgICAgICAgLy8gYWJzb3JiIGkgaW50byBrXG4gICAgICAgICAgY3B0cltpXSA9IGNzX2ZsaXAoayk7XG4gICAgICAgICAgbnZpID0gLVdbbnYgKyBpXTtcbiAgICAgICAgICAvLyB8TGt8IC09IHxpfFxuICAgICAgICAgIGRrIC09IG52aTtcbiAgICAgICAgICAvLyB8a3wgKz0gV1tudiArIGldXG4gICAgICAgICAgbnZrICs9IG52aTtcbiAgICAgICAgICBuZWwgKz0gbnZpO1xuICAgICAgICAgIFdbbnYgKyBpXSA9IDA7XG4gICAgICAgICAgLy8gbm9kZSBpIGlzIGRlYWRcbiAgICAgICAgICBXW2VsZW4gKyBpXSA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIHVwZGF0ZSBkZWdyZWUoaSlcbiAgICAgICAgICBXW2RlZ3JlZSArIGldID0gTWF0aC5taW4oV1tkZWdyZWUgKyBpXSwgZCk7XG4gICAgICAgICAgLy8gbW92ZSBmaXJzdCBub2RlIHRvIGVuZFxuICAgICAgICAgIGNpbmRleFtwbl0gPSBjaW5kZXhbcDNdO1xuICAgICAgICAgIC8vIG1vdmUgMXN0IGVsLiB0byBlbmQgb2YgRWlcbiAgICAgICAgICBjaW5kZXhbcDNdID0gY2luZGV4W3AxXTtcbiAgICAgICAgICAvLyBhZGQgayBhcyAxc3QgZWxlbWVudCBpbiBvZiBFaVxuICAgICAgICAgIGNpbmRleFtwMV0gPSBrO1xuICAgICAgICAgIC8vIG5ldyBsZW4gb2YgYWRqLiBsaXN0IG9mIG5vZGUgaVxuICAgICAgICAgIFdbbGVuICsgaV0gPSBwbiAtIHAxICsgMTtcbiAgICAgICAgICAvLyBmaW5hbGl6ZSBoYXNoIG9mIGlcbiAgICAgICAgICBoID0gKGggPCAwID8gLWggOiBoKSAlIG47XG4gICAgICAgICAgLy8gcGxhY2UgaSBpbiBoYXNoIGJ1Y2tldFxuICAgICAgICAgIFdbbmV4dCArIGldID0gV1toaGVhZCArIGhdO1xuICAgICAgICAgIFdbaGhlYWQgKyBoXSA9IGk7XG4gICAgICAgICAgLy8gc2F2ZSBoYXNoIG9mIGkgaW4gbGFzdFtpXVxuICAgICAgICAgIGxhc3RbaV0gPSBoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBmaW5hbGl6ZSB8TGt8XG4gICAgICBXW2RlZ3JlZSArIGtdID0gZGs7XG4gICAgICBsZW1heCA9IE1hdGgubWF4KGxlbWF4LCBkayk7XG4gICAgICAvLyBjbGVhciB3XG4gICAgICBtYXJrID0gX3djbGVhcihtYXJrICsgbGVtYXgsIGxlbWF4LCBXLCB3LCBuKTtcbiAgICAgIFxuICAgICAgLy8gU3VwZXJub2RlIGRldGVjdGlvbi4gU3VwZXJub2RlIGRldGVjdGlvbiByZWxpZXMgb24gdGhlIGhhc2ggZnVuY3Rpb24gaChpKSBjb21wdXRlZCBmb3IgZWFjaCBub2RlIGkuXG4gICAgICAvLyBJZiB0d28gbm9kZXMgaGF2ZSBpZGVudGljYWwgYWRqYWNlbmN5IGxpc3RzLCB0aGVpciBoYXNoIGZ1bmN0aW9ucyB3aWwgYmUgaWRlbnRpY2FsLlxuICAgICAgZm9yIChwayA9IHBrMTsgcGsgPCBwazI7IHBrKyspIHtcbiAgICAgICAgaSA9IGNpbmRleFtwa107XG4gICAgICAgIC8vIGNoZWNrIGkgaXMgZGVhZCwgc2tpcCBpdFxuICAgICAgICBpZiAoV1tudiArIGldID49IDApIFxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAvLyBzY2FuIGhhc2ggYnVja2V0IG9mIG5vZGUgaVxuICAgICAgICBoID0gbGFzdFtpXTtcbiAgICAgICAgaSA9IFdbaGhlYWQgKyBoXTtcbiAgICAgICAgLy8gaGFzaCBidWNrZXQgd2lsbCBiZSBlbXB0eVxuICAgICAgICBXW2hoZWFkICsgaF0gPSAtMTtcbiAgICAgICAgZm9yICg7IGkgIT0gLTEgJiYgV1tuZXh0ICsgaV0gIT0gLTE7IGkgPSBXW25leHQgKyBpXSwgbWFyaysrKSB7XG4gICAgICAgICAgbG4gPSBXW2xlbiArIGldO1xuICAgICAgICAgIGVsbiA9IFdbZWxlbiArIGldO1xuICAgICAgICAgIGZvciAocCA9IGNwdHJbaV0gKyAxOyBwIDw9IGNwdHJbaV0gKyBsbiAtIDE7IHArKykgXG4gICAgICAgICAgICBXW3cgKyBjaW5kZXhbcF1dID0gbWFyaztcbiAgICAgICAgICB2YXIgamxhc3QgPSBpO1xuICAgICAgICAgIC8vIGNvbXBhcmUgaSB3aXRoIGFsbCBqXG4gICAgICAgICAgZm9yIChqID0gV1tuZXh0ICsgaV07IGogIT0gLTE7ICkge1xuICAgICAgICAgICAgdmFyIG9rID0gV1tsZW4gKyBqXSA9PT0gbG4gJiYgV1tlbGVuICsgal0gPT09IGVsbjtcbiAgICAgICAgICAgIGZvciAocCA9IGNwdHJbal0gKyAxOyBvayAmJiBwIDw9IGNwdHJbal0gKyBsbiAtIDE7IHArKykge1xuICAgICAgICAgICAgICAvLyBjb21wYXJlIGkgYW5kIGpcbiAgICAgICAgICAgICAgaWYgKFdbdyArIGNpbmRleFtwXV0gIT0gbWFyaykgXG4gICAgICAgICAgICAgICAgb2sgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2hlY2sgaSBhbmQgaiBhcmUgaWRlbnRpY2FsXG4gICAgICAgICAgICBpZiAob2spIHtcbiAgICAgICAgICAgICAgLy8gYWJzb3JiIGogaW50byBpXG4gICAgICAgICAgICAgIGNwdHJbal0gPSBjc19mbGlwKGkpO1xuICAgICAgICAgICAgICBXW252ICsgaV0gKz0gV1tudiArIGpdO1xuICAgICAgICAgICAgICBXW252ICsgal0gPSAwO1xuICAgICAgICAgICAgICAvLyBub2RlIGogaXMgZGVhZFxuICAgICAgICAgICAgICBXW2VsZW4gKyBqXSA9IC0xO1xuICAgICAgICAgICAgICAvLyBkZWxldGUgaiBmcm9tIGhhc2ggYnVja2V0XG4gICAgICAgICAgICAgIGogPSBXW25leHQgKyBqXTtcbiAgICAgICAgICAgICAgV1tuZXh0ICsgamxhc3RdID0gajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLyBqIGFuZCBpIGFyZSBkaWZmZXJlbnRcbiAgICAgICAgICAgICAgamxhc3QgPSBqO1xuICAgICAgICAgICAgICBqID0gV1tuZXh0ICsgal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEZpbmFsaXplIG5ldyBlbGVtZW50LiBUaGUgZWxpbWluYXRpb24gb2Ygbm9kZSBrIGlzIG5lYXJseSBjb21wbGV0ZS4gQWxsIG5vZGVzIGkgaW4gTGsgYXJlIHNjYW5uZWQgb25lIGxhc3QgdGltZS5cbiAgICAgIC8vIE5vZGUgaSBpcyByZW1vdmVkIGZyb20gTGsgaWYgaXQgaXMgZGVhZC4gVGhlIGZsYWdnZWQgc3RhdHVzIG9mIG52W2ldIGlzIGNsZWFyZWQuXG4gICAgICBmb3IgKHAgPSBwazEsIHBrID0gcGsxOyBwayA8IHBrMjsgcGsrKykge1xuICAgICAgICBpID0gY2luZGV4W3BrXTtcbiAgICAgICAgLy8gY2hlY2sgIGkgaXMgZGVhZCwgc2tpcCBpdFxuICAgICAgICBpZiAoKG52aSA9IC1XW252ICsgaV0pIDw9IDApIFxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAvLyByZXN0b3JlIFdbbnYgKyBpXVxuICAgICAgICBXW252ICsgaV0gPSBudmk7XG4gICAgICAgIC8vIGNvbXB1dGUgZXh0ZXJuYWwgZGVncmVlKGkpXG4gICAgICAgIGQgPSBXW2RlZ3JlZSArIGldICsgZGsgLSBudmk7XG4gICAgICAgIGQgPSBNYXRoLm1pbihkLCBuIC0gbmVsIC0gbnZpKTtcbiAgICAgICAgaWYgKFdbaGVhZCArIGRdICE9IC0xKSBcbiAgICAgICAgICBsYXN0W1dbaGVhZCArIGRdXSA9IGk7XG4gICAgICAgIC8vIHB1dCBpIGJhY2sgaW4gZGVncmVlIGxpc3RcbiAgICAgICAgV1tuZXh0ICsgaV0gPSBXW2hlYWQgKyBkXTtcbiAgICAgICAgbGFzdFtpXSA9IC0xO1xuICAgICAgICBXW2hlYWQgKyBkXSA9IGk7XG4gICAgICAgIC8vIGZpbmQgbmV3IG1pbmltdW0gZGVncmVlXG4gICAgICAgIG1pbmRlZyA9IE1hdGgubWluKG1pbmRlZywgZCk7XG4gICAgICAgIFdbZGVncmVlICsgaV0gPSBkO1xuICAgICAgICAvLyBwbGFjZSBpIGluIExrXG4gICAgICAgIGNpbmRleFtwKytdID0gaTtcbiAgICAgIH1cbiAgICAgIC8vICMgbm9kZXMgYWJzb3JiZWQgaW50byBrXG4gICAgICBXW252ICsga10gPSBudms7XG4gICAgICAvLyBsZW5ndGggb2YgYWRqIGxpc3Qgb2YgZWxlbWVudCBrXG4gICAgICBpZiAoKFdbbGVuICsga10gPSBwIC0gcGsxKSA9PT0gMCkge1xuICAgICAgICAvLyBrIGlzIGEgcm9vdCBvZiB0aGUgdHJlZVxuICAgICAgICBjcHRyW2tdID0gLTE7XG4gICAgICAgIC8vIGsgaXMgbm93IGEgZGVhZCBlbGVtZW50XG4gICAgICAgIFdbdyArIGtdID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChlbGVuayAhPT0gMCkge1xuICAgICAgICAvLyBmcmVlIHVudXNlZCBzcGFjZSBpbiBMa1xuICAgICAgICBjbnogPSBwO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBQb3N0b3JkZXJpbmcuIFRoZSBlbGltaW5hdGlvbiBpcyBjb21wbGV0ZSwgYnV0IG5vIHBlcm11dGF0aW9uIGhhcyBiZWVuIGNvbXB1dGVkLiBBbGwgdGhhdCBpcyBsZWZ0IFxuICAgIC8vIG9mIHRoZSBncmFwaCBpcyB0aGUgYXNzZW1ibHkgdHJlZSAocHRyKSBhbmQgYSBzZXQgb2YgZGVhZCBub2RlcyBhbmQgZWxlbWVudHMgKGkgaXMgYSBkZWFkIG5vZGUgaWZcbiAgICAvLyBudltpXSBpcyB6ZXJvIGFuZCBhIGRlYWQgZWxlbWVudCBpZiBudltpXSA+IDApLiBJdCBpcyBmcm9tIHRoaXMgaW5mb3JtYXRpb24gb25seSB0aGF0IHRoZSBmaW5hbCBwZXJtdXRhdGlvblxuICAgIC8vIGlzIGNvbXB1dGVkLiBUaGUgdHJlZSBpcyByZXN0b3JlZCBieSB1bmZsaXBwaW5nIGFsbCBvZiBwdHIuXG4gICAgXG4gICAgLy8gZml4IGFzc2VtYmx5IHRyZWVcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSBcbiAgICAgIGNwdHJbaV0gPSBjc19mbGlwKGNwdHJbaV0pO1xuICAgIGZvciAoaiA9IDA7IGogPD0gbjsgaisrKSBcbiAgICAgIFdbaGVhZCArIGpdID0gLTE7XG4gICAgLy8gcGxhY2UgdW5vcmRlcmVkIG5vZGVzIGluIGxpc3RzXG4gICAgZm9yIChqID0gbjsgaiA+PSAwOyBqLS0pIHtcbiAgICAgIC8vIHNraXAgaWYgaiBpcyBhbiBlbGVtZW50XG4gICAgICBpZiAoV1tudiArIGpdID4gMClcbiAgICAgICAgY29udGludWU7XG4gICAgICAvLyBwbGFjZSBqIGluIGxpc3Qgb2YgaXRzIHBhcmVudFxuICAgICAgV1tuZXh0ICsgal0gPSBXW2hlYWQgKyBjcHRyW2pdXTtcbiAgICAgIFdbaGVhZCArIGNwdHJbal1dID0gajtcbiAgICB9XG4gICAgLy8gcGxhY2UgZWxlbWVudHMgaW4gbGlzdHNcbiAgICBmb3IgKGUgPSBuOyBlID49IDA7IGUtLSkge1xuICAgICAgLy8gc2tpcCB1bmxlc3MgZSBpcyBhbiBlbGVtZW50XG4gICAgICBpZiAoV1tudiArIGVdIDw9IDApXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKGNwdHJbZV0gIT0gLTEpIHtcbiAgICAgICAgLy8gcGxhY2UgZSBpbiBsaXN0IG9mIGl0cyBwYXJlbnRcbiAgICAgICAgV1tuZXh0ICsgZV0gPSBXW2hlYWQgKyBjcHRyW2VdXTtcbiAgICAgICAgV1toZWFkICsgY3B0cltlXV0gPSBlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBwb3N0b3JkZXIgdGhlIGFzc2VtYmx5IHRyZWVcbiAgICBmb3IgKGsgPSAwLCBpID0gMDsgaSA8PSBuOyBpKyspIHtcbiAgICAgIGlmIChjcHRyW2ldID09IC0xKSBcbiAgICAgICAgayA9IGNzX3RkZnMoaSwgaywgVywgaGVhZCwgbmV4dCwgUCwgdyk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSBsYXN0IGl0ZW0gaW4gYXJyYXlcbiAgICBQLnNwbGljZShQLmxlbmd0aCAtIDEsIDEpO1xuICAgIC8vIHJldHVybiBQXG4gICAgcmV0dXJuIFA7XG4gIH07XG4gIFxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgbWF0cml4IHRoYXQgd2lsbCBiZSB1c2VkIGJ5IHRoZSBhcHByb3hpbWF0ZSBtaW5pbXVtIGRlZ3JlZSBvcmRlcmluZyBhbGdvcml0aG0uIFRoZSBmdW5jdGlvbiBhY2NlcHRzIHRoZSBtYXRyaXggTSBhcyBpbnB1dCBhbmQgcmV0dXJucyBhIHBlcm11dGF0aW9uXG4gICAqIHZlY3RvciBQLiBUaGUgYW1kIGFsZ29yaXRobSBvcGVyYXRlcyBvbiBhIHN5bW1ldHJpeCBtYXRyaXgsIHNvIG9uZSBvZiB0aHJlZSBzeW1tZXRyaWMgbWF0cmljZXMgaXMgZm9ybWVkLlxuICAgKlxuICAgKiBPcmRlcjogMFxuICAgKiAgIEEgbmF0dXJhbCBvcmRlcmluZyBQPW51bGwgbWF0cml4IGlzIHJldHVybmVkLlxuICAgKlxuICAgKiBPcmRlcjogMVxuICAgKiAgIE1hdHJpeCBtdXN0IGJlIHNxdWFyZS4gVGhpcyBpcyBhcHByb3ByaWF0ZSBmb3IgYSBDaG9sZXNreSBvciBMVSBmYWN0b3JpemF0aW9uLlxuICAgKiAgIFAgPSBNICsgTSdcbiAgICpcbiAgICogT3JkZXI6IDJcbiAgICogICBEZW5zZSBjb2x1bW5zIGZyb20gTScgYXJlIGRyb3BwZWQsIE0gcmVjcmVhdGVkIGZyb20gTScuIFRoaXMgaXMgYXBwcm9wcmlhdGVmb3IgTFUgZmFjdG9yaXphdGlvbiBvZiB1bnN5bW1ldHJpYyBtYXRyaWNlcy5cbiAgICogICBQID0gTScgKiBNXG4gICAqIFxuICAgKiBPcmRlcjogM1xuICAgKiAgIFRoaXMgaXMgYmVzdCB1c2VkIGZvciBRUiBmYWN0b3JpemF0aW9uIG9yIExVIGZhY3Rvcml6YXRpb24gaXMgbWF0cml4IE0gaGFzIG5vIGRlbnNlIHJvd3MuIEEgZGVuc2Ugcm93IGlzIGEgcm93IHdpdGggbW9yZSB0aGFuIDEwKnNxcihjb2x1bW5zKSBlbnRyaWVzLlxuICAgKiAgIFAgPSBNJyAqIE1cbiAgICovXG4gIHZhciBfY3JlYXRlVGFyZ2V0TWF0cml4ID0gZnVuY3Rpb24gKG9yZGVyLCBhLCBtLCBuLCBkZW5zZSkge1xuICAgIC8vIGNvbXB1dGUgQSdcbiAgICB2YXIgYXQgPSB0cmFuc3Bvc2UoYSk7XG5cbiAgICAvLyBjaGVjayBvcmRlciA9IDEsIG1hdHJpeCBtdXN0IGJlIHNxdWFyZVxuICAgIGlmIChvcmRlciA9PT0gMSAmJiBuID09PSBtKSB7XG4gICAgICAvLyBDID0gQSArIEEnXG4gICAgICByZXR1cm4gYWRkKGEsIGF0KTtcbiAgICB9XG4gICAgXG4gICAgLy8gY2hlY2sgb3JkZXIgPSAyLCBkcm9wIGRlbnNlIGNvbHVtbnMgZnJvbSBNJ1xuICAgIGlmIChvcmRlciA9PSAyKSB7XG4gICAgICAvLyB0cmFuc3Bvc2UgYXJyYXlzXG4gICAgICB2YXIgdGluZGV4ID0gYXQuX2luZGV4O1xuICAgICAgdmFyIHRwdHIgPSBhdC5fcHRyO1xuICAgICAgLy8gbmV3IGNvbHVtbiBpbmRleFxuICAgICAgdmFyIHAyID0gMDtcbiAgICAgIC8vIGxvb3AgQScgY29sdW1ucyAocm93cylcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbTsgaisrKSB7XG4gICAgICAgIC8vIGNvbHVtbiBqIG9mIEFUIHN0YXJ0cyBoZXJlXG4gICAgICAgIHZhciBwID0gdHB0cltqXTtcbiAgICAgICAgLy8gbmV3IGNvbHVtbiBqIHN0YXJ0cyBoZXJlXG4gICAgICAgIHRwdHJbal0gPSBwMjtcbiAgICAgICAgLy8gc2tpcCBkZW5zZSBjb2wgalxuICAgICAgICBpZiAodHB0cltqICsgMV0gLSBwID4gZGVuc2UpIFxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAvLyBtYXAgcm93cyBpbiBjb2x1bW4gaiBvZiBBXG4gICAgICAgIGZvciAodmFyIHAxID0gdHB0cltqICsgMV07IHAgPCBwMTsgcCsrKSBcbiAgICAgICAgICB0aW5kZXhbcDIrK10gPSB0aW5kZXhbcF07XG4gICAgICB9XG4gICAgICAvLyBmaW5hbGl6ZSBBVFxuICAgICAgdHB0clttXSA9IHAyO1xuICAgICAgLy8gcmVjcmVhdGUgQSBmcm9tIG5ldyB0cmFuc3Bvc2UgbWF0cml4XG4gICAgICBhID0gdHJhbnNwb3NlKGF0KTtcbiAgICAgIC8vIHVzZSBBJyAqIEFcbiAgICAgIHJldHVybiBtdWx0aXBseShhdCwgYSk7XG4gICAgfVxuICAgIFxuICAgIC8vIHVzZSBBJyAqIEEsIHNxdWFyZSBvciByZWN0YW5ndWxhciBtYXRyaXhcbiAgICByZXR1cm4gbXVsdGlwbHkoYXQsIGEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHF1b3RpZW50IGdyYXBoLiBUaGVyZSBhcmUgZm91ciBraW5kIG9mIG5vZGVzIGFuZCBlbGVtZW50cyB0aGF0IG11c3QgYmUgcmVwcmVzZW50ZWQ6XG4gICAqXG4gICAqICAtIEEgbGl2ZSBub2RlIGlzIGEgbm9kZSBpIChvciBhIHN1cGVybm9kZSkgdGhhdCBoYXMgbm90IGJlZW4gc2VsZWN0ZWQgYXMgYSBwaXZvdCBuYWQgaGFzIG5vdCBiZWVuIG1lcmdlZCBpbnRvIGFub3RoZXIgc3VwZXJub2RlLlxuICAgKiAgLSBBIGRlYWQgbm9kZSBpIGlzIG9uZSB0aGF0IGhhcyBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgZ3JhcGgsIGhhdmluZyBiZWVuIGFic29ydmVkIGludG8gciA9IGZsaXAocHRyW2ldKS5cbiAgICogIC0gQSBsaXZlIGVsZW1lbnQgZSBpcyBvbmUgdGhhdCBpcyBpbiB0aGUgZ3JhcGgsIGhhdmluZyBiZWVuIGZvcm1lZCB3aGVuIG5vZGUgZSB3YXMgc2VsZWN0ZWQgYXMgdGhlIHBpdm90LlxuICAgKiAgLSBBIGRlYWQgZWxlbWVudCBlIGlzIG9uZSB0aGF0IGhhcyBiZW5uIGFic29ydmVkIGludG8gYSBzdWJzZXF1ZW50IGVsZW1lbnQgcyA9IGZsaXAocHRyW2VdKS5cbiAgICovXG4gIHZhciBfaW5pdGlhbGl6ZVF1b3RpZW50R3JhcGggPSBmdW5jdGlvbiAobiwgY3B0ciwgVywgbGVuLCBoZWFkLCBsYXN0LCBuZXh0LCBoaGVhZCwgbnYsIHcsIGVsZW4sIGRlZ3JlZSkge1xuICAgIC8vIEluaXRpYWxpemUgcXVvdGllbnQgZ3JhcGhcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IG47IGsrKykgXG4gICAgICBXW2xlbiArIGtdID0gY3B0cltrICsgMV0gLSBjcHRyW2tdO1xuICAgIFdbbGVuICsgbl0gPSAwO1xuICAgIC8vIGluaXRpYWxpemUgd29ya3NwYWNlXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbjsgaSsrKSB7XG4gICAgICAvLyBkZWdyZWUgbGlzdCBpIGlzIGVtcHR5XG4gICAgICBXW2hlYWQgKyBpXSA9IC0xO1xuICAgICAgbGFzdFtpXSA9IC0xO1xuICAgICAgV1tuZXh0ICsgaV0gPSAtMTtcbiAgICAgIC8vIGhhc2ggbGlzdCBpIGlzIGVtcHR5XG4gICAgICBXW2hoZWFkICsgaV0gPSAtMTtcbiAgICAgIC8vIG5vZGUgaSBpcyBqdXN0IG9uZSBub2RlXG4gICAgICBXW252ICsgaV0gPSAxO1xuICAgICAgLy8gbm9kZSBpIGlzIGFsaXZlXG4gICAgICBXW3cgKyBpXSA9IDE7XG4gICAgICAvLyBFayBvZiBub2RlIGkgaXMgZW1wdHlcbiAgICAgIFdbZWxlbiArIGldID0gMDtcbiAgICAgIC8vIGRlZ3JlZSBvZiBub2RlIGlcbiAgICAgIFdbZGVncmVlICsgaV0gPSBXW2xlbiArIGldO1xuICAgIH1cbiAgICAvLyBjbGVhciB3XG4gICAgdmFyIG1hcmsgPSBfd2NsZWFyKDAsIDAsIFcsIHcsIG4pO1xuICAgIC8vIG4gaXMgYSBkZWFkIGVsZW1lbnRcbiAgICBXW2VsZW4gKyBuXSA9IC0yO1xuICAgIC8vIG4gaXMgYSByb290IG9mIGFzc2VtYmx5IHRyZWVcbiAgICBjcHRyW25dID0gLTE7XG4gICAgLy8gbiBpcyBhIGRlYWQgZWxlbWVudFxuICAgIFdbdyArIG5dID0gMDtcbiAgICAvLyByZXR1cm4gbWFya1xuICAgIHJldHVybiBtYXJrO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGRlZ3JlZSBsaXN0cy4gRWFjaCBub2RlIGlzIHBsYWNlZCBpbiBpdHMgZGVncmVlIGxpc3RzLiBOb2RlcyBvZiB6ZXJvIGRlZ3JlZSBhcmUgZWxpbWluYXRlZCBpbW1lZGlhdGVseS4gTm9kZXMgd2l0aCBcbiAgICogZGVncmVlID49IGRlbnNlIGFyZSBhbHNvbCBlbGltaW5hdGVkIGFuZCBtZXJnZWQgaW50byBhIHBsYWNlaG9sZGVyIG5vZGUgbiwgYSBkZWFkIGVsZW1lbnQuIFRoZXMgbm9kZXMgd2lsbCBhcHBlcmEgbGFzdCBpbiB0aGVcbiAgICogb3V0cHV0IHBlcm11dGF0aW9uIHAuXG4gICAqL1xuICB2YXIgX2luaXRpYWxpemVEZWdyZWVMaXN0cyA9IGZ1bmN0aW9uIChuLCBjcHRyLCBXLCBkZWdyZWUsIGVsZW4sIHcsIGRlbnNlLCBudiwgaGVhZCwgbGFzdCwgbmV4dCkge1xuICAgIC8vIHJlc3VsdFxuICAgIHZhciBuZWwgPSAwO1xuICAgIC8vIGxvb3AgY29sdW1uc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAvLyBkZWdyZWUgQCBpXG4gICAgICB2YXIgZCA9IFdbZGVncmVlICsgaV07XG4gICAgICAvLyBjaGVjayBub2RlIGkgaXMgZW1wdHlcbiAgICAgIGlmIChkID09PSAwKSB7XG4gICAgICAgIC8vIGVsZW1lbnQgaSBpcyBkZWFkXG4gICAgICAgIFdbZWxlbiArIGldID0gLTI7XG4gICAgICAgIG5lbCsrO1xuICAgICAgICAvLyBpIGlzIGEgcm9vdCBvZiBhc3NlbWJseSB0cmVlXG4gICAgICAgIGNwdHJbaV0gPSAtMTtcbiAgICAgICAgV1t3ICsgaV0gPSAwO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZCA+IGRlbnNlKSB7XG4gICAgICAgIC8vIGFic29yYiBpIGludG8gZWxlbWVudCBuXG4gICAgICAgIFdbbnYgKyBpXSA9IDA7XG4gICAgICAgIC8vIG5vZGUgaSBpcyBkZWFkXG4gICAgICAgIFdbZWxlbiArIGldID0gLTE7XG4gICAgICAgIG5lbCsrO1xuICAgICAgICBjcHRyW2ldID0gY3NfZmxpcChuKTtcbiAgICAgICAgV1tudiArIG5dKys7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGggPSBXW2hlYWQgKyBkXTtcbiAgICAgICAgaWYgKGggIT0gLTEpXG4gICAgICAgICAgbGFzdFtoXSA9IGk7XG4gICAgICAgIC8vIHB1dCBub2RlIGkgaW4gZGVncmVlIGxpc3QgZFxuICAgICAgICBXW25leHQgKyBpXSA9IFdbaGVhZCArIGRdO1xuICAgICAgICBXW2hlYWQgKyBkXSA9IGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZWw7XG4gIH07XG5cbiAgdmFyIF93Y2xlYXIgPSBmdW5jdGlvbihtYXJrLCBsZW1heCwgVywgdywgbikge1xuICAgIGlmIChtYXJrIDwgMiB8fCAobWFyayArIGxlbWF4IDwgMCkpIHtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbjsgaysrKSB7XG4gICAgICAgIGlmIChXW3cgKyBrXSAhPT0gMClcbiAgICAgICAgICBXW3cgKyBrXSA9IDE7XG4gICAgICB9XG4gICAgICBtYXJrID0gMiA7XG4gICAgfVxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIFcgWzAuLm4tMV0gPCBtYXJrIGhvbGRzXG4gICAgcmV0dXJuIG1hcms7XG4gIH07XG4gIFxuICB2YXIgX2RpYWcgPSBmdW5jdGlvbiAoaSwgaikgeyBcbiAgICByZXR1cm4gaSAhPSBqO1xuICB9O1xuICBcbiAgcmV0dXJuIGNzX2FtZDtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2NzX2FtZCc7XG5leHBvcnRzLnBhdGggPSAnc3BhcnNlJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCkge1xuXG4gIHZhciB0cmFuc3Bvc2UgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL21hdHJpeC90cmFuc3Bvc2UnKSk7XG4gIFxuICB2YXIgY3NfbGVhZiA9IGxvYWQocmVxdWlyZSgnLi9jc19sZWFmJykpO1xuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgY29sdW1uIGNvdW50cyB1c2luZyB0aGUgdXBwZXIgdHJpYW5ndWxhciBwYXJ0IG9mIEEuXG4gICAqIEl0IHRyYW5zcG9zZXMgQSBpbnRlcm5hbGx5LCBub25lIG9mIHRoZSBpbnB1dCBwYXJhbWV0ZXJzIGFyZSBtb2RpZmllZC5cbiAgICpcbiAgICogQHBhcmFtIHtNYXRyaXh9IGEgICAgICAgICAgIFRoZSBzcGFyc2UgbWF0cml4IEFcbiAgICpcbiAgICogQHBhcmFtIHtNYXRyaXh9IGF0YSAgICAgICAgIENvdW50IHRoZSBjb2x1bW5zIG9mIEEnQSBpbnN0ZWFkXG4gICAqXG4gICAqIEByZXR1cm4gICAgICAgICAgICAgICAgICAgICBBbiBhcnJheSBvZiBzaXplIG4gb2YgdGhlIGNvbHVtbiBjb3VudHMgb3IgbnVsbCBvbiBlcnJvclxuICAgKlxuICAgKiBSZWZlcmVuY2U6IGh0dHA6Ly9mYWN1bHR5LmNzZS50YW11LmVkdS9kYXZpcy9wdWJsaWNhdGlvbnMuaHRtbFxuICAgKi9cbiAgdmFyIGNzX2NvdW50cyA9IGZ1bmN0aW9uIChhLCBwYXJlbnQsIHBvc3QsIGF0YSkge1xuICAgIC8vIGNoZWNrIGlucHV0c1xuICAgIGlmICghYSB8fCAhcGFyZW50IHx8ICFwb3N0KSBcbiAgICAgIHJldHVybiBudWxsO1xuICAgIC8vIGEgbWF0cml4IGFycmF5c1xuICAgIHZhciBhc2l6ZSA9IGEuX3NpemU7XG4gICAgLy8gcm93cyBhbmQgY29sdW1uc1xuICAgIHZhciBtID0gYXNpemVbMF07XG4gICAgdmFyIG4gPSBhc2l6ZVsxXTsgICBcbiAgICAvLyB2YXJpYWJsZXNcbiAgICB2YXIgaSwgaiwgaywgIEosICBwLCBwMCwgcDE7XG4gICAgXG4gICAgLy8gd29ya3NwYWNlIHNpemVcbiAgICB2YXIgcyA9IDQgKiBuICsgKGF0YSA/IChuICsgbSArIDEpIDogMCk7XG4gICAgLy8gYWxsb2NhdGUgd29ya3NwYWNlXG4gICAgdmFyIHcgPSBbXTsgLy8gKHMpXG4gICAgdmFyIGFuY2VzdG9yID0gMDsgLy8gZmlyc3QgbiBlbnRyaWVzXG4gICAgdmFyIG1heGZpcnN0ID0gbjsgLy8gbmV4dCBuIGVudHJpZXNcbiAgICB2YXIgcHJldmxlYWYgPSAyICogbjsgLy8gbmV4dCBuIGVudHJpZXNcbiAgICB2YXIgZmlyc3QgPSAzICogbjsgLy8gbmV4dCBuIGVudHJpZXNcbiAgICB2YXIgaGVhZCA9IDQgKiBuOyAvLyBuZXh0IG4gKyAxIGVudHJpZXMgKHVzZWQgd2hlbiBhdGEgaXMgdHJ1ZSlcbiAgICB2YXIgbmV4dCA9IDUgKiBuICsgMTsgLy8gbGFzdCBlbnRyaWVzIGluIHdvcmtzcGFjZVxuICAgIC8vIGNsZWFyIHdvcmtzcGFjZSB3WzAuLnMtMV1cbiAgICBmb3IgKGsgPSAwOyBrIDwgczsgaysrKSBcbiAgICAgIHdba10gPSAtMTtcbiAgICBcbiAgICAvLyBhbGxvY2F0ZSByZXN1bHRcbiAgICB2YXIgY29sY291bnQgPSBbXTsgLy8gKG4pO1xuICAgIFxuICAgIC8vIEFUID0gQSdcbiAgICB2YXIgYXQgPSB0cmFuc3Bvc2UoYSk7XG4gICAgLy8gYXQgYXJyYXlzXG4gICAgdmFyIHRpbmRleCA9IGF0Ll9pbmRleDtcbiAgICB2YXIgdHB0ciA9IGF0Ll9wdHI7XG5cbiAgICAvLyBmaW5kIHdbZmlyc3QgKyBqXVxuICAgIGZvciAoayA9IDA7IGsgPCBuOyBrKyspIHtcbiAgICAgIGogPSBwb3N0W2tdO1xuICAgICAgLy8gY29sY291bnRbal09MSBpZiBqIGlzIGEgbGVhZlxuICAgICAgY29sY291bnRbal0gPSAod1tmaXJzdCArIGpdID09IC0xKSA/IDEgOiAwO1xuICAgICAgZm9yICg7IGogIT0gLTEgJiYgd1tmaXJzdCArIGpdID09IC0xOyBqID0gcGFyZW50W2pdKSBcbiAgICAgICAgd1tmaXJzdCArIGpdID0gaztcbiAgICB9XG5cbiAgICAvLyBpbml0aWFsaXplIGF0YSBpZiBuZWVkZWRcbiAgICBpZiAoYXRhKSB7XG4gICAgICAvLyBpbnZlcnQgcG9zdFxuICAgICAgZm9yIChrID0gMDsgayA8IG47IGsrKykgXG4gICAgICAgIHdbcG9zdFtrXV0gPSBrO1xuICAgICAgLy8gbG9vcCByb3dzIChjb2x1bW5zIGluIEFUKVxuICAgICAgZm9yIChpID0gMDsgaSA8IG07IGkrKykge1xuICAgICAgICAvLyB2YWx1ZXMgaW4gY29sdW1uIGkgb2YgQVRcbiAgICAgICAgZm9yIChrID0gbiwgcDAgPSB0cHRyW2ldLCBwMSA9IHRwdHJbaSArIDFdLCBwID0gcDA7IHAgPCBwMTsgcCsrKSBcbiAgICAgICAgICBrID0gTWF0aC5taW4oaywgd1t0aW5kZXhbcF1dKTtcbiAgICAgICAgLy8gcGxhY2Ugcm93IGkgaW4gbGlua2VkIGxpc3Qga1xuICAgICAgICB3W25leHQgKyBpXSA9IHdbaGVhZCArIGtdO1xuICAgICAgICB3W2hlYWQgKyBrXSA9IGk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIGVhY2ggbm9kZSBpbiBpdHMgb3duIHNldFxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIFxuICAgICAgd1thbmNlc3RvciArIGldID0gaTtcbiAgICBcbiAgICBmb3IgKGsgPSAwOyBrIDwgbjsgaysrKSB7XG4gICAgICAvLyBqIGlzIHRoZSBrdGggbm9kZSBpbiBwb3N0b3JkZXJlZCBldHJlZVxuICAgICAgaiA9IHBvc3Rba107XG4gICAgICAvLyBjaGVjayBqIGlzIG5vdCBhIHJvb3RcbiAgICAgIGlmIChwYXJlbnRbal0gIT0gLTEpIFxuICAgICAgICBjb2xjb3VudFtwYXJlbnRbal1dLS07XG4gICAgICBcbiAgICAgIC8vIEo9aiBmb3IgTEwnPUEgY2FzZVxuICAgICAgZm9yIChKID0gKGF0YSA/IHdbaGVhZCArIGtdIDogaik7IEogIT0gLTE7IEogPSAoYXRhID8gd1tuZXh0ICsgSl0gOiAtMSkpIHtcbiAgICAgICAgZm9yIChwID0gdHB0cltKXTsgcCA8IHRwdHJbSisxXTsgcCsrKSB7XG4gICAgICAgICAgaSA9IHRpbmRleFtwXTtcbiAgICAgICAgICB2YXIgciA9IGNzX2xlYWYoaSwgaiwgdywgZmlyc3QsIG1heGZpcnN0LCBwcmV2bGVhZiwgYW5jZXN0b3IpO1xuICAgICAgICAgIC8vIGNoZWNrIEEoaSxqKSBpcyBpbiBza2VsZXRvblxuICAgICAgICAgIGlmIChyLmpsZWFmID49IDEpIFxuICAgICAgICAgICAgY29sY291bnRbal0rKztcbiAgICAgICAgICAvLyBjaGVjayBhY2NvdW50IGZvciBvdmVybGFwIGluIHFcbiAgICAgICAgICBpZiAoci5qbGVhZiA9PSAyKSBcbiAgICAgICAgICAgIGNvbGNvdW50W3IucV0tLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBhcmVudFtqXSAhPSAtMSkgXG4gICAgICAgIHdbYW5jZXN0b3IgKyBqXSA9IHBhcmVudFtqXTtcbiAgICB9XG4gICAgLy8gc3VtIHVwIGNvbGNvdW50J3Mgb2YgZWFjaCBjaGlsZFxuICAgIGZvciAoaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgIGlmIChwYXJlbnRbal0gIT0gLTEpIFxuICAgICAgICBjb2xjb3VudFtwYXJlbnRbal1dICs9IGNvbGNvdW50W2pdO1xuICAgIH1cbiAgICByZXR1cm4gY29sY291bnQ7XG4gIH07XG5cbiAgcmV0dXJuIGNzX2NvdW50cztcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2NzX2NvdW50cyc7XG5leHBvcnRzLnBhdGggPSAnc3BhcnNlJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCkge1xuXG4gIHZhciBjc19tYXJrZWQgPSBsb2FkKHJlcXVpcmUoJy4vY3NfbWFya2VkJykpO1xuICB2YXIgY3NfbWFyayAgID0gbG9hZChyZXF1aXJlKCcuL2NzX21hcmsnKSk7XG4gIHZhciBjc191bmZsaXAgPSBsb2FkKHJlcXVpcmUoJy4vY3NfdW5mbGlwJykpO1xuXG4gIC8qKlxuICAgKiBEZXB0aC1maXJzdCBzZWFyY2ggY29tcHV0ZXMgdGhlIG5vbnplcm8gcGF0dGVybiB4aSBvZiB0aGUgZGlyZWN0ZWQgZ3JhcGggRyAoTWF0cml4KSBzdGFydGluZ1xuICAgKiBhdCBub2RlcyBpbiBCIChzZWUgY3NfcmVhY2goKSkuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSAgaiAgICAgICAgICAgICAgIFRoZSBzdGFydGluZyBub2RlIGZvciB0aGUgREZTIGFsZ29yaXRobVxuICAgKiBAcGFyYW0ge01hdHJpeH0gIGcgICAgICAgICAgICAgICBUaGUgRyBtYXRyaXggdG8gc2VhcmNoLCBwdHIgYXJyYXkgbW9kaWZpZWQsIHRoZW4gcmVzdG9yZWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9ICB0b3AgICAgICAgICAgICAgU3RhcnQgaW5kZXggaW4gc3RhY2sgeGlbdG9wLi5uLTFdXG4gICAqIEBwYXJhbSB7TnVtYmVyfSAgayAgICAgICAgICAgICAgIFRoZSBrdGggY29sdW1uIGluIEJcbiAgICogQHBhcmFtIHtBcnJheX0gICB4aSAgICAgICAgICAgICAgVGhlIG5vbnplcm8gcGF0dGVybiB4aVt0b3BdIC4uIHhpW24gLSAxXSwgYW4gYXJyYXkgb2Ygc2l6ZSA9IDIgKiBuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBmaXJzdCBuIGVudHJpZXMgaXMgdGhlIG5vbnplcm8gcGF0dGVybiwgdGhlIGxhc3QgbiBlbnRyaWVzIGlzIHRoZSBzdGFja1xuICAgKiBAcGFyYW0ge0FycmF5fSAgIHBpbnYgICAgICAgICAgICBUaGUgaW52ZXJzZSByb3cgcGVybXV0YXRpb24gdmVjdG9yLCBtdXN0IGJlIG51bGwgZm9yIEwgKiB4ID0gYlxuICAgKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgICAgICBOZXcgdmFsdWUgb2YgdG9wXG4gICAqXG4gICAqIFJlZmVyZW5jZTogaHR0cDovL2ZhY3VsdHkuY3NlLnRhbXUuZWR1L2RhdmlzL3B1YmxpY2F0aW9ucy5odG1sXG4gICAqL1xuICB2YXIgY3NfZGZzID0gZnVuY3Rpb24gKGosIGcsIHRvcCwgeGksIHBpbnYpIHtcbiAgICAvLyBnIGFycmF5c1xuICAgIHZhciBpbmRleCA9IGcuX2luZGV4O1xuICAgIHZhciBwdHIgPSBnLl9wdHI7XG4gICAgdmFyIHNpemUgPSBnLl9zaXplO1xuICAgIC8vIGNvbHVtbnNcbiAgICB2YXIgbiA9IHNpemVbMV07XG4gICAgLy8gdmFyc1xuICAgIHZhciBpLCBwLCBwMjtcbiAgICAvLyBpbml0aWFsaXplIGhlYWRcbiAgICB2YXIgaGVhZCA9IDA7XG4gICAgLy8gaW5pdGlhbGl6ZSB0aGUgcmVjdXJzaW9uIHN0YWNrXG4gICAgeGlbMF0gPSBqO1xuICAgIC8vIGxvb3BcbiAgICB3aGlsZSAoaGVhZCA+PSAwKSB7XG4gICAgICAvLyBnZXQgaiBmcm9tIHRoZSB0b3Agb2YgdGhlIHJlY3Vyc2lvbiBzdGFja1xuICAgICAgaiA9IHhpW2hlYWRdO1xuICAgICAgLy8gYXBwbHkgcGVybXV0YXRpb24gdmVjdG9yXG4gICAgICB2YXIgam5ldyA9IHBpbnYgPyBwaW52W2pdIDogajtcbiAgICAgIC8vIGNoZWNrIG5vZGUgaiBpcyBtYXJrZWRcbiAgICAgIGlmICghY3NfbWFya2VkKHB0ciwgaikpIHtcbiAgICAgICAgLy8gbWFyayBub2RlIGogYXMgdmlzaXRlZFxuICAgICAgICBjc19tYXJrKHB0ciwgaik7XG4gICAgICAgIC8vIHVwZGF0ZSBzdGFjayAobGFzdCBuIGVudHJpZXMgaW4geGkpXG4gICAgICAgIHhpW24gKyBoZWFkXSA9IGpuZXcgPCAwID8gMCA6IGNzX3VuZmxpcChwdHJbam5ld10pO1xuICAgICAgfVxuICAgICAgLy8gbm9kZSBqIGRvbmUgaWYgbm8gdW52aXNpdGVkIG5laWdoYm9yc1xuICAgICAgdmFyIGRvbmUgPSAxO1xuICAgICAgLy8gZXhhbWluZSBhbGwgbmVpZ2hib3JzIG9mIGosIHN0YWNrIChsYXN0IG4gZW50cmllcyBpbiB4aSlcbiAgICAgIGZvciAocCA9IHhpW24gKyBoZWFkXSwgcDIgPSBqbmV3IDwgMCA/IDAgOiBjc191bmZsaXAocHRyW2puZXcrMV0pOyBwIDwgcDI7IHArKykge1xuICAgICAgICAvLyBjb25zaWRlciBuZWlnaGJvciBub2RlIGlcbiAgICAgICAgaSA9IGluZGV4W3BdO1xuICAgICAgICAvLyBjaGVjayB3ZSBoYXZlIHZpc2l0ZWQgbm9kZSBpLCBza2lwIGl0XG4gICAgICAgIGlmIChjc19tYXJrZWQocHRyLCBpKSkgXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIC8vIHBhdXNlIGRlcHRoLWZpcnN0IHNlYXJjaCBvZiBub2RlIGosIHVwZGF0ZSBzdGFjayAobGFzdCBuIGVudHJpZXMgaW4geGkpXG4gICAgICAgIHhpW24gKyBoZWFkXSA9IHA7XG4gICAgICAgIC8vIHN0YXJ0IGRmcyBhdCBub2RlIGlcbiAgICAgICAgeGlbKytoZWFkXSA9IGk7XG4gICAgICAgIC8vIG5vZGUgaiBpcyBub3QgZG9uZVxuICAgICAgICBkb25lID0gMDtcbiAgICAgICAgLy8gYnJlYWssIHRvIHN0YXJ0IGRmcyhpKVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIGNoZWNrIGRlcHRoLWZpcnN0IHNlYXJjaCBhdCBub2RlIGogaXMgZG9uZVxuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGogZnJvbSB0aGUgcmVjdXJzaW9uIHN0YWNrXG4gICAgICAgIGhlYWQtLTtcbiAgICAgICAgLy8gYW5kIHBsYWNlIGluIHRoZSBvdXRwdXQgc3RhY2tcbiAgICAgICAgeGlbLS10b3BdID0gajtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvcDsgICAgXG4gIH07XG5cbiAgcmV0dXJuIGNzX2Rmcztcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2NzX2Rmcyc7XG5leHBvcnRzLnBhdGggPSAnc3BhcnNlJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKCkge1xuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgZWxpbWluYXRpb24gdHJlZSBvZiBNYXRyaXggQSAodXNpbmcgdHJpdShBKSkgb3IgdGhlIFxuICAgKiBlbGltaW5hdGlvbiB0cmVlIG9mIEEnQSB3aXRob3V0IGZvcm1pbmcgQSdBLlxuICAgKlxuICAgKiBAcGFyYW0ge01hdHJpeH0gIGEgICAgICAgICAgICAgICBUaGUgQSBNYXRyaXhcbiAgICogQHBhcmFtIHtib29sZWFufSBhdGEgICAgICAgICAgICAgQSB2YWx1ZSBvZiB0cnVlIHRoZSBmdW5jdGlvbiBjb21wdXRlcyB0aGUgZXRyZWUgb2YgQSdBXG4gICAqXG4gICAqIFJlZmVyZW5jZTogaHR0cDovL2ZhY3VsdHkuY3NlLnRhbXUuZWR1L2RhdmlzL3B1YmxpY2F0aW9ucy5odG1sXG4gICAqL1xuICB2YXIgY3NfZXRyZWUgPSBmdW5jdGlvbiAoYSwgYXRhKSB7XG4gICAgLy8gY2hlY2sgaW5wdXRzXG4gICAgaWYgKCFhKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgLy8gYSBhcnJheXNcbiAgICB2YXIgYWluZGV4ID0gYS5faW5kZXg7XG4gICAgdmFyIGFwdHIgPSBhLl9wdHI7XG4gICAgdmFyIGFzaXplID0gYS5fc2l6ZTtcbiAgICAvLyByb3dzICYgY29sdW1uc1xuICAgIHZhciBtID0gYXNpemVbMF07XG4gICAgdmFyIG4gPSBhc2l6ZVsxXTtcbiAgICBcbiAgICAvLyBhbGxvY2F0ZSByZXN1bHRcbiAgICB2YXIgcGFyZW50ID0gW107IC8vIChuKVxuICAgIFxuICAgIC8vIGFsbG9jYXRlIHdvcmtzcGFjZVxuICAgIHZhciB3ID0gW107IC8vIChuICsgKGF0YSA/IG0gOiAwKSlcbiAgICB2YXIgYW5jZXN0b3IgPSAwOyAvLyBmaXJzdCBuIGVudHJpZXMgaW4gd1xuICAgIHZhciBwcmV2ID0gbjsgLy8gbGFzdCBtIGVudHJpZXMgKGF0YSA9IHRydWUpXG4gICAgXG4gICAgdmFyIGksIGluZXh0O1xuICAgIFxuICAgIC8vIGNoZWNrIHdlIGFyZSBjYWxjdWxhdGluZyBBJ0FcbiAgICBpZiAoYXRhKSB7XG4gICAgICAvLyBpbml0aWFsaXplIHdvcmtzcGFjZVxuICAgICAgZm9yIChpID0gMDsgaSA8IG07IGkrKykgXG4gICAgICAgIHdbcHJldiArIGldID0gLTE7XG4gICAgfVxuICAgIC8vIGxvb3AgY29sdW1uc1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbjsgaysrKSB7XG4gICAgICAvLyBub2RlIGsgaGFzIG5vIHBhcmVudCB5ZXRcbiAgICAgIHBhcmVudFtrXSA9IC0xO1xuICAgICAgLy8gbm9yIGRvZXMgayBoYXZlIGFuIGFuY2VzdG9yXG4gICAgICB3W2FuY2VzdG9yICsga10gPSAtMTtcbiAgICAgIC8vIHZhbHVlcyBpbiBjb2x1bW4ga1xuICAgICAgZm9yICh2YXIgcDAgPSBhcHRyW2tdLCBwMSA9IGFwdHJbayArIDFdLCBwID0gcDA7IHAgPCBwMTsgcCsrKSB7XG4gICAgICAgIC8vIHJvd1xuICAgICAgICB2YXIgciA9IGFpbmRleFtwXTtcbiAgICAgICAgLy8gbm9kZVxuICAgICAgICBpID0gYXRhID8gKHdbcHJldiArIHJdKSA6IHI7XG4gICAgICAgIC8vIHRyYXZlcnNlIGZyb20gaSB0byBrIFxuICAgICAgICBmb3IgKDsgaSAhPSAtMSAmJiBpIDwgazsgaSA9IGluZXh0KSB7XG4gICAgICAgICAgLy8gaW5leHQgPSBhbmNlc3RvciBvZiBpXG4gICAgICAgICAgaW5leHQgPSB3W2FuY2VzdG9yICsgaV07XG4gICAgICAgICAgLy8gcGF0aCBjb21wcmVzc2lvblxuICAgICAgICAgIHdbYW5jZXN0b3IgKyBpXSA9IGs7XG4gICAgICAgICAgLy8gY2hlY2sgbm8gYW5jLiwgcGFyZW50IGlzIGtcbiAgICAgICAgICBpZiAoaW5leHQgPT0gLTEpIFxuICAgICAgICAgICAgcGFyZW50W2ldID0gaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXRhKSBcbiAgICAgICAgICB3W3ByZXYgKyByXSA9IGs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJlbnQ7XG4gIH07XG5cbiAgcmV0dXJuIGNzX2V0cmVlO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnY3NfZXRyZWUnO1xuZXhwb3J0cy5wYXRoID0gJ3NwYXJzZSc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICgpIHtcblxuICAvKipcbiAgICogS2VlcHMgZW50cmllcyBpbiB0aGUgbWF0cml4IHdoZW4gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSwgcmVtb3ZlcyB0aGUgZW50cnkgb3RoZXJ3aXNlXG4gICAqXG4gICAqIEBwYXJhbSB7TWF0cml4fSAgIGEgICAgICAgICAgICAgIFRoZSBzcGFyc2UgbWF0cml4XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrICAgICAgIFRoZSBjYWxsYmFjayBmdW5jdGlvbiwgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIHdpdGggdGhlIGZvbGxvd2luZyBhcmdzOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gVGhlIGVudHJ5IHJvd1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gVGhlIGVudHJ5IGNvbHVtblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gVGhlIGVudHJ5IHZhbHVlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBUaGUgc3RhdGUgcGFyYW1ldGVyXG4gICAqIEBwYXJhbSB7YW55fSAgICAgIG90aGVyICAgICAgICAgIFRoZSBzdGF0ZVxuICAgKlxuICAgKiBAcmV0dXJuICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgbnVtYmVyIG9mIG5vbnplcm8gZWxlbWVudHMgaW4gdGhlIG1hdHJpeFxuICAgKlxuICAgKiBSZWZlcmVuY2U6IGh0dHA6Ly9mYWN1bHR5LmNzZS50YW11LmVkdS9kYXZpcy9wdWJsaWNhdGlvbnMuaHRtbFxuICAgKi9cbiAgdmFyIGNzX2ZrZWVwID0gZnVuY3Rpb24gKGEsIGNhbGxiYWNrLCBvdGhlcikge1xuICAgIC8vIGEgYXJyYXlzXG4gICAgdmFyIGF2YWx1ZXMgPSBhLl92YWx1ZXM7XG4gICAgdmFyIGFpbmRleCA9IGEuX2luZGV4O1xuICAgIHZhciBhcHRyID0gYS5fcHRyO1xuICAgIHZhciBhc2l6ZSA9IGEuX3NpemU7XG4gICAgLy8gY29sdW1uc1xuICAgIHZhciBuID0gYXNpemVbMV07XG4gICAgLy8gbm9uemVybyBpdGVtc1xuICAgIHZhciBueiA9IDA7XG4gICAgLy8gbG9vcCBjb2x1bW5zXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgIC8vIGdldCBjdXJyZW50IGxvY2F0aW9uIG9mIGNvbCBqXG4gICAgICB2YXIgcCA9IGFwdHJbal07XG4gICAgICAvLyByZWNvcmQgbmV3IGxvY2F0aW9uIG9mIGNvbCBqXG4gICAgICBhcHRyW2pdID0gbno7XG4gICAgICBmb3IgKDsgcCA8IGFwdHJbaisxXTsgcCsrKSB7XG4gICAgICAgIC8vIGNoZWNrIHdlIG5lZWQgdG8ga2VlcCB0aGlzIGl0ZW1cbiAgICAgICAgaWYgKGNhbGxiYWNrKGFpbmRleFtwXSwgaiwgYXZhbHVlcyA/IGF2YWx1ZXNbcF0gOiAxLCBvdGhlcikpIHtcbiAgICAgICAgICAvLyBrZWVwIEEoaSxqKVxuICAgICAgICAgIGFpbmRleFtuel0gPSBhaW5kZXhbcF07XG4gICAgICAgICAgLy8gY2hlY2sgd2UgbmVlZCB0byBwcm9jZXNzIHZhbHVlcyAocGF0dGVybiBvbmx5KVxuICAgICAgICAgIGlmIChhdmFsdWVzKSBcbiAgICAgICAgICAgIGF2YWx1ZXNbbnpdID0gYXZhbHVlc1twXTtcbiAgICAgICAgICAvLyBpbmNyZW1lbnQgbm9uemVybyBpdGVtc1xuICAgICAgICAgIG56Kys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZmluYWxpemUgQVxuICAgIGFwdHJbbl0gPSBuejtcbiAgICAvLyB0cmltIGFycmF5c1xuICAgIGFpbmRleC5zcGxpY2UobnosIGFpbmRleC5sZW5ndGggLSBueik7XG4gICAgLy8gY2hlY2sgd2UgbmVlZCB0byBwcm9jZXNzIHZhbHVlcyAocGF0dGVybiBvbmx5KVxuICAgIGlmIChhdmFsdWVzKVxuICAgICAgYXZhbHVlcy5zcGxpY2UobnosIGF2YWx1ZXMubGVuZ3RoIC0gbnopOyAgICBcbiAgICAvLyByZXR1cm4gbnVtYmVyIG9mIG5vbnplcm8gaXRlbXNcbiAgICByZXR1cm4gKG56KTtcbiAgfTtcbiAgXG4gIHJldHVybiBjc19ma2VlcDtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2NzX2ZrZWVwJztcbmV4cG9ydHMucGF0aCA9ICdzcGFyc2UnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZmFjdG9yeSAoKSB7XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gXCJmbGlwc1wiIGl0cyBpbnB1dCBhYm91dCB0aGUgaW50ZWdlciAtMS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9ICBpICAgICAgICAgICAgICAgVGhlIHZhbHVlIHRvIGZsaXBcbiAgICpcbiAgICogUmVmZXJlbmNlOiBodHRwOi8vZmFjdWx0eS5jc2UudGFtdS5lZHUvZGF2aXMvcHVibGljYXRpb25zLmh0bWxcbiAgICovXG4gIHZhciBjc19mbGlwID0gZnVuY3Rpb24gKGkpIHtcbiAgICAvLyBmbGlwIHRoZSB2YWx1ZVxuICAgIHJldHVybiAtaSAtIDI7XG4gIH07XG5cbiAgcmV0dXJuIGNzX2ZsaXA7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdjc19mbGlwJztcbmV4cG9ydHMucGF0aCA9ICdzcGFyc2UnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZmFjdG9yeSAoKSB7XG5cbiAgLyoqXG4gICAqIFBlcm11dGVzIGEgdmVjdG9yOyB4ID0gUCdiLiBJbiBNQVRMQUIgbm90YXRpb24sIHgocCk9Yi5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gcCAgICAgICAgICAgVGhlIHBlcm11dGF0aW9uIHZlY3RvciBvZiBsZW5ndGggbi4gbnVsbCB2YWx1ZSBkZW5vdGVzIGlkZW50aXR5XG4gICAqIEBwYXJhbSB7QXJyYXl9IGIgICAgICAgICAgIFRoZSBpbnB1dCB2ZWN0b3JcbiAgICpcbiAgICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgICAgVGhlIG91dHB1dCB2ZWN0b3IgeCA9IFAnYlxuICAgKi9cbiAgdmFyIGNzX2lwdmVjID0gZnVuY3Rpb24gKHAsIGIsIG4pIHtcbiAgICAvLyB2YXJzIFxuICAgIHZhciBrO1xuICAgIHZhciBuID0gYi5sZW5ndGg7XG4gICAgdmFyIHggPSBbXTtcbiAgICAvLyBjaGVjayBwZXJtdXRhdGlvbiB2ZWN0b3Igd2FzIHByb3ZpZGVkLCBwID0gbnVsbCBkZW5vdGVzIGlkZW50aXR5XG4gICAgaWYgKHApIHtcbiAgICAgIC8vIGxvb3AgdmVjdG9yXG4gICAgICBmb3IgKGsgPSAwOyBrIDwgbjsgaysrKSB7XG4gICAgICAgIC8vIGFwcGx5IHBlcm11dGF0aW9uXG4gICAgICAgIHhbcFtrXV0gPSBiW2tdO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGxvb3AgdmVjdG9yXG4gICAgICBmb3IgKGsgPSAwOyBrIDwgbjsgaysrKSB7XG4gICAgICAgIC8vIHhbaV0gPSBiW2ldXG4gICAgICAgIHhba10gPSBiW2tdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geDtcbiAgfTtcblxuICByZXR1cm4gY3NfaXB2ZWM7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdjc19pcHZlYyc7XG5leHBvcnRzLnBhdGggPSAnc3BhcnNlJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKCkge1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGRldGVybWluZXMgaWYgaiBpcyBhIGxlYWYgb2YgdGhlIGl0aCByb3cgc3VidHJlZS5cbiAgICogQ29uc2lkZXIgQShpLGopLCBub2RlIGogaW4gaXRoIHJvdyBzdWJ0cmVlIGFuZCByZXR1cm4gbGNhKGpwcmV2LGopXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSAgaSAgICAgICAgICAgICAgIFRoZSBpdGggcm93IHN1YnRyZWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9ICBqICAgICAgICAgICAgICAgVGhlIG5vZGUgdG8gdGVzdFxuICAgKiBAcGFyYW0ge0FycmF5fSAgIHcgICAgICAgICAgICAgICBUaGUgd29ya3NwYWNlIGFycmF5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSAgZmlyc3QgICAgICAgICAgIFRoZSBpbmRleCBvZmZzZXQgd2l0aGluIHRoZSB3b3Jrc3BhY2UgZm9yIHRoZSBmaXJzdCBhcnJheVxuICAgKiBAcGFyYW0ge051bWJlcn0gIG1heGZpcnN0ICAgICAgICBUaGUgaW5kZXggb2Zmc2V0IHdpdGhpbiB0aGUgd29ya3NwYWNlIGZvciB0aGUgbWF4Zmlyc3QgYXJyYXlcbiAgICogQHBhcmFtIHtOdW1iZXJ9ICBwcmV2bGVhZiAgICAgICAgVGhlIGluZGV4IG9mZnNldCB3aXRoaW4gdGhlIHdvcmtzcGFjZSBmb3IgdGhlIHByZXZsZWFmIGFycmF5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSAgYW5jZXN0b3IgICAgICAgIFRoZSBpbmRleCBvZmZzZXQgd2l0aGluIHRoZSB3b3Jrc3BhY2UgZm9yIHRoZSBhbmNlc3RvciBhcnJheVxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqXG4gICAqIFJlZmVyZW5jZTogaHR0cDovL2ZhY3VsdHkuY3NlLnRhbXUuZWR1L2RhdmlzL3B1YmxpY2F0aW9ucy5odG1sXG4gICAqL1xuICB2YXIgY3NfbGVhZiA9IGZ1bmN0aW9uIChpLCBqLCB3LCBmaXJzdCwgbWF4Zmlyc3QsIHByZXZsZWFmLCBhbmNlc3Rvcikge1xuICAgIFxuICAgIHZhciBzLCBzcGFyZW50LCBqcHJldjtcbiAgICBcbiAgICAvLyBvdXIgcmVzdWx0XG4gICAgdmFyIGpsZWFmID0gMDtcbiAgICB2YXIgcTtcbiAgICBcbiAgICAvLyBjaGVjayBqIGlzIGEgbGVhZlxuICAgIGlmIChpIDw9IGogfHwgd1tmaXJzdCArIGpdIDw9IHdbbWF4Zmlyc3QgKyBpXSkgXG4gICAgICByZXR1cm4gKC0xKTtcbiAgICAvLyB1cGRhdGUgbWF4IGZpcnN0W2pdIHNlZW4gc28gZmFyXG4gICAgd1ttYXhmaXJzdCArIGldID0gd1tmaXJzdCArIGpdO1xuICAgIC8vIGpwcmV2ID0gcHJldmlvdXMgbGVhZiBvZiBpdGggc3VidHJlZVxuICAgIGpwcmV2ID0gd1twcmV2bGVhZiArIGldO1xuICAgIHdbcHJldmxlYWYgKyBpXSA9IGo7XG4gICAgXG4gICAgLy8gY2hlY2sgaiBpcyBmaXJzdCBvciBzdWJzZXF1ZW50IGxlYWZcbiAgICBpZiAoanByZXYgPT09IC0xKSB7XG4gICAgICAvLyAxc3QgbGVhZiwgcSA9IHJvb3Qgb2YgaXRoIHN1YnRyZWVcbiAgICAgIGpsZWFmID0gMTtcbiAgICAgIHEgPSBpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIHVwZGF0ZSBqbGVhZlxuICAgICAgamxlYWYgPSAyO1xuICAgICAgLy8gcSA9IGxlYXN0IGNvbW1vbiBhbmNlc3RlciAoanByZXYsailcbiAgICAgIGZvciAocSA9IGpwcmV2OyBxICE9IHdbYW5jZXN0b3IgKyBxXTsgcSA9IHdbYW5jZXN0b3IgKyBxXSk7XG4gICAgICBmb3IgKHMgPSBqcHJldjsgcyAhPSBxOyBzID0gc3BhcmVudCkge1xuICAgICAgICAvLyBwYXRoIGNvbXByZXNzaW9uXG4gICAgICAgIHNwYXJlbnQgPSB3W2FuY2VzdG9yICsgc107XG4gICAgICAgIHdbYW5jZXN0b3IgKyBzXSA9IHE7XG4gICAgICB9ICAgICAgXG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBqbGVhZjogamxlYWYsXG4gICAgICBxOiBxXG4gICAgfTtcbiAgfTtcblxuICByZXR1cm4gY3NfbGVhZjtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2NzX2xlYWYnO1xuZXhwb3J0cy5wYXRoID0gJ3NwYXJzZSc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQpIHtcblxuICB2YXIgYWJzID0gbG9hZChyZXF1aXJlKCcuLi8uLi9hcml0aG1ldGljL2FicycpKTtcbiAgdmFyIGRpdmlkZVNjYWxhciA9IGxvYWQocmVxdWlyZSgnLi4vLi4vYXJpdGhtZXRpYy9kaXZpZGVTY2FsYXInKSk7XG4gIHZhciBtdWx0aXBseSA9IGxvYWQocmVxdWlyZSgnLi4vLi4vYXJpdGhtZXRpYy9tdWx0aXBseScpKTtcbiAgXG4gIHZhciBsYXJnZXIgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3JlbGF0aW9uYWwvbGFyZ2VyJykpO1xuICB2YXIgbGFyZ2VyRXEgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3JlbGF0aW9uYWwvbGFyZ2VyRXEnKSk7XG4gIFxuICB2YXIgY3Nfc3Bzb2x2ZSA9IGxvYWQocmVxdWlyZSgnLi9jc19zcHNvbHZlJykpO1xuXG4gIHZhciBTcGFyc2VNYXRyaXggPSB0eXBlLlNwYXJzZU1hdHJpeDtcblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIG51bWVyaWMgTFUgZmFjdG9yaXphdGlvbiBvZiB0aGUgc3BhcnNlIG1hdHJpeCBBLiBJbXBsZW1lbnRzIGEgTGVmdC1sb29raW5nIExVIGZhY3Rvcml6YXRpb25cbiAgICogYWxnb3JpdGhtIHRoYXQgY29tcHV0ZXMgTCBhbmQgVSBvbmUgY29sdW1uIGF0IGEgdHVtZS4gQXQgdGhlIGt0aCBzdGVwLCBpdCBhY2Nlc3MgY29sdW1ucyAxIHRvIGstMSBvZiBMIFxuICAgKiBhbmQgY29sdW1uIGsgb2YgQS4gR2l2ZW4gdGhlIGZpbGwtcmVkdWNpbmcgY29sdW1uIG9yZGVyaW5nIHEgKHNlZSBwYXJhbWV0ZXIgcykgY29tcHV0ZXMgTCwgVSBhbmQgcGludiBzb1xuICAgKiBMICogVSA9IEEocCwgcSksIHdoZXJlIHAgaXMgdGhlIGludmVyc2Ugb2YgcGludi5cbiAgICpcbiAgICogQHBhcmFtIHtNYXRyaXh9ICBtICAgICAgICAgICAgICAgVGhlIEEgTWF0cml4IHRvIGZhY3Rvcml6ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gIHMgICAgICAgICAgICAgICBUaGUgc3ltYm9saWMgYW5hbHlzaXMgZnJvbSBjc19zcXIoKS4gUHJvdmlkZXMgdGhlIGZpbGwtcmVkdWNpbmcgXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbiBvcmRlcmluZyBxXG4gICAqIEBwYXJhbSB7TnVtYmVyfSAgdG9sICAgICAgICAgICAgIFBhcnRpYWwgcGl2b3RpbmcgdGhyZXNob2xkICgxIGZvciBwYXJ0aWFsIHBpdm90aW5nKVxuICAgKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgICAgICBUaGUgbnVtZXJpYyBMVSBmYWN0b3JpemF0aW9uIG9mIEEgb3IgbnVsbFxuICAgKlxuICAgKiBSZWZlcmVuY2U6IGh0dHA6Ly9mYWN1bHR5LmNzZS50YW11LmVkdS9kYXZpcy9wdWJsaWNhdGlvbnMuaHRtbFxuICAgKi9cbiAgdmFyIGNzX2x1ID0gZnVuY3Rpb24gKG0sIHMsIHRvbCkge1xuICAgIC8vIHZhbGlkYXRlIGlucHV0XG4gICAgaWYgKCFtKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgLy8gbSBhcnJheXNcbiAgICB2YXIgc2l6ZSA9IG0uX3NpemU7XG4gICAgLy8gY29sdW1uc1xuICAgIHZhciBuID0gc2l6ZVsxXTtcbiAgICAvLyBzeW1ib2xpYyBhbmFseXNpcyByZXN1bHRcbiAgICB2YXIgcTtcbiAgICB2YXIgbG56ID0gMTAwO1xuICAgIHZhciB1bnogPSAxMDA7XG4gICAgLy8gdXBkYXRlIHN5bWJvbGljIGFuYWx5c2lzIHBhcmFtZXRlcnNcbiAgICBpZiAocykge1xuICAgICAgcSA9IHMucTtcbiAgICAgIGxueiA9IHMubG56IHx8IGxuejtcbiAgICAgIHVueiA9IHMudW56IHx8IHVuejtcbiAgICB9XG4gICAgLy8gTCBhcnJheXNcbiAgICB2YXIgbHZhbHVlcyA9IFtdOyAvLyAobG56KVxuICAgIHZhciBsaW5kZXggPSBbXTsgLy8gKGxueik7XG4gICAgdmFyIGxwdHIgPSBbXTsgLy8gKG4gKyAxKTtcbiAgICAvLyBMXG4gICAgdmFyIEwgPSBuZXcgU3BhcnNlTWF0cml4KHtcbiAgICAgIHZhbHVlczogbHZhbHVlcyxcbiAgICAgIGluZGV4OiBsaW5kZXgsXG4gICAgICBwdHI6IGxwdHIsXG4gICAgICBzaXplOiBbbiwgbl1cbiAgICB9KTtcbiAgICAvLyBVIGFycmF5c1xuICAgIHZhciB1dmFsdWVzID0gW107IC8vICh1bnopO1xuICAgIHZhciB1aW5kZXggPSBbXTsgLy8gKHVueik7XG4gICAgdmFyIHVwdHIgPSBbXTsgLy8gKG4gKyAxKTtcbiAgICAvLyBVXG4gICAgdmFyIFUgPSBuZXcgU3BhcnNlTWF0cml4KHtcbiAgICAgIHZhbHVlczogdXZhbHVlcyxcbiAgICAgIGluZGV4OiB1aW5kZXgsXG4gICAgICBwdHI6IHVwdHIsXG4gICAgICBzaXplOiBbbiwgbl1cbiAgICB9KTtcbiAgICAvLyBpbnZlcnNlIG9mIHBlcm11dGF0aW9uIHZlY3RvclxuICAgIHZhciBwaW52ID0gW107IC8vIChuKTtcbiAgICAvLyB2YXJzIFxuICAgIHZhciBpLCBwO1xuICAgIC8vIGFsbG9jYXRlIGFycmF5c1xuICAgIHZhciB4ID0gW107IC8vIChuKTtcbiAgICB2YXIgeGkgPSBbXTsgLy8gKDIgKiBuKTtcbiAgICAvLyBpbml0aWFsaXplIHZhcmlhYmxlc1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIC8vIGNsZWFyIHdvcmtzcGFjZVxuICAgICAgeFtpXSA9IDA7XG4gICAgICAvLyBubyByb3dzIHBpdm90YWwgeWV0XG4gICAgICBwaW52W2ldID0gLTE7XG4gICAgICAvLyBubyBjb2xzIG9mIEwgeWV0XG4gICAgICBscHRyW2kgKyAxXSA9IDA7XG4gICAgfVxuICAgIC8vIHJlc2V0IG51bWJlciBvZiBub256ZXJvIGVsZW1lbnRzIGluIEwgYW5kIFVcbiAgICBsbnogPSAwO1xuICAgIHVueiA9IDA7XG4gICAgLy8gY29tcHV0ZSBMKDosaykgYW5kIFUoOixrKVxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbjsgaysrKSB7XG4gICAgICAvLyB1cGRhdGUgcHRyXG4gICAgICBscHRyW2tdID0gbG56O1xuICAgICAgdXB0cltrXSA9IHVuejtcbiAgICAgIC8vIGFwcGx5IGNvbHVtbiBwZXJtdXRhdGlvbnMgaWYgbmVlZGVkXG4gICAgICB2YXIgY29sID0gcSA/IHFba10gOiBrO1xuICAgICAgLy8gc29sdmUgdHJpYW5ndWxhciBzeXN0ZW0sIHggPSBMXFxBKDosY29sKVxuICAgICAgdmFyIHRvcCA9IGNzX3Nwc29sdmUoTCwgbSwgY29sLCB4aSwgeCwgcGludiwgMSk7XG4gICAgICAvLyBmaW5kIHBpdm90XG4gICAgICB2YXIgaXBpdiA9IC0xO1xuICAgICAgdmFyIGEgPSAtMTtcbiAgICAgIC8vIGxvb3AgeGlbXSBmcm9tIHRvcCAtPiBuXG4gICAgICBmb3IgKHAgPSB0b3A7IHAgPCBuOyBwKyspIHtcbiAgICAgICAgLy8geFtpXSBpcyBub256ZXJvXG4gICAgICAgIGkgPSB4aVtwXTtcbiAgICAgICAgLy8gY2hlY2sgcm93IGkgaXMgbm90IHlldCBwaXZvdGFsXG4gICAgICAgIGlmIChwaW52W2ldIDwgMCkge1xuICAgICAgICAgIC8vIGFic29sdXRlIHZhbHVlIG9mIHhbaV0gICAgICAgICAgXG4gICAgICAgICAgdmFyIHhhYnMgPSBhYnMoeFtpXSk7XG4gICAgICAgICAgLy8gY2hlY2sgYWJzb3VsdGUgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHBpdm90IHZhbHVlXG4gICAgICAgICAgaWYgKGxhcmdlcih4YWJzLCBhKSkge1xuICAgICAgICAgICAgLy8gbGFyZ2VzdCBwaXZvdCBjYW5kaWRhdGUgc28gZmFyXG4gICAgICAgICAgICBhID0geGFicztcbiAgICAgICAgICAgIGlwaXYgPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyB4KGkpIGlzIHRoZSBlbnRyeSBVKHBpbnZbaV0saylcbiAgICAgICAgICB1aW5kZXhbdW56XSA9IHBpbnZbaV07XG4gICAgICAgICAgdXZhbHVlc1t1bnorK10gPSB4W2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyB2YWxpZGF0ZSB3ZSBmb3VuZCBhIHZhbGlkIHBpdm90XG4gICAgICBpZiAoaXBpdiA9PSAtMSB8fCBhIDw9IDApIFxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIC8vIHVwZGF0ZSBhY3R1YWwgcGl2b3QgY29sdW1uLCBnaXZlIHByZWZlcmVuY2UgdG8gZGlhZ29uYWwgdmFsdWVcbiAgICAgIGlmIChwaW52W2NvbF0gPCAwICYmIGxhcmdlckVxKGFicyh4W2NvbF0pLCBtdWx0aXBseShhLCB0b2wpKSlcbiAgICAgICAgaXBpdiA9IGNvbDtcbiAgICAgIC8vIHRoZSBjaG9zZW4gcGl2b3RcbiAgICAgIHZhciBwaXZvdCA9IHhbaXBpdl07XG4gICAgICAvLyBsYXN0IGVudHJ5IGluIFUoOixrKSBpcyBVKGssaylcbiAgICAgIHVpbmRleFt1bnpdID0gaztcbiAgICAgIHV2YWx1ZXNbdW56KytdID0gcGl2b3Q7XG4gICAgICAvLyBpcGl2IGlzIHRoZSBrdGggcGl2b3Qgcm93XG4gICAgICBwaW52W2lwaXZdID0gaztcbiAgICAgIC8vIGZpcnN0IGVudHJ5IGluIEwoOixrKSBpcyBMKGssaykgPSAxXG4gICAgICBsaW5kZXhbbG56XSA9IGlwaXY7XG4gICAgICBsdmFsdWVzW2xueisrXSA9IDE7XG4gICAgICAvLyBMKGsrMTpuLGspID0geCAvIHBpdm90ICAgICAgXG4gICAgICBmb3IgKHAgPSB0b3A7IHAgPCBuOyBwKyspIHtcbiAgICAgICAgLy8gcm93XG4gICAgICAgIGkgPSB4aVtwXTtcbiAgICAgICAgLy8gY2hlY2sgeChpKSBpcyBhbiBlbnRyeSBpbiBMKDosaylcbiAgICAgICAgaWYgKHBpbnZbaV0gPCAwKSB7XG4gICAgICAgICAgLy8gc2F2ZSB1bnBlcm11dGVkIHJvdyBpbiBMXG4gICAgICAgICAgbGluZGV4W2xuel0gPSBpO1xuICAgICAgICAgIC8vIHNjYWxlIHBpdm90IGNvbHVtblxuICAgICAgICAgIGx2YWx1ZXNbbG56KytdID0gZGl2aWRlU2NhbGFyKHhbaV0sIHBpdm90KTtcbiAgICAgICAgfVxuICAgICAgICAvLyB4WzAuLm4tMV0gPSAwIGZvciBuZXh0IGtcbiAgICAgICAgeFtpXSA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVwZGF0ZSBwdHJcbiAgICBscHRyW25dID0gbG56O1xuICAgIHVwdHJbbl0gPSB1bno7XG4gICAgLy8gZml4IHJvdyBpbmRpY2VzIG9mIEwgZm9yIGZpbmFsIHBpbnZcbiAgICBmb3IgKHAgPSAwOyBwIDwgbG56OyBwKyspIFxuICAgICAgbGluZGV4W3BdID0gcGludltsaW5kZXhbcF1dO1xuICAgIC8vIHRyaW0gYXJyYXlzXG4gICAgbHZhbHVlcy5zcGxpY2UobG56LCBsdmFsdWVzLmxlbmd0aCAtIGxueik7XG4gICAgbGluZGV4LnNwbGljZShsbnosIGxpbmRleC5sZW5ndGggLSBsbnopO1xuICAgIHV2YWx1ZXMuc3BsaWNlKHVueiwgdXZhbHVlcy5sZW5ndGggLSB1bnopO1xuICAgIHVpbmRleC5zcGxpY2UodW56LCB1aW5kZXgubGVuZ3RoIC0gdW56KTsgICAgXG4gICAgLy8gcmV0dXJuIExVIGZhY3RvclxuICAgIHJldHVybiB7XG4gICAgICBMOiBMLFxuICAgICAgVTogVSxcbiAgICAgIHBpbnY6IHBpbnZcbiAgICB9O1xuICB9O1xuXG4gIHJldHVybiBjc19sdTtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2NzX2x1JztcbmV4cG9ydHMucGF0aCA9ICdzcGFyc2UnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkKSB7XG5cbiAgdmFyIGNzX2ZsaXAgPSBsb2FkKHJlcXVpcmUoJy4vY3NfZmxpcCcpKTtcblxuICAvKipcbiAgICogTWFya3MgdGhlIG5vZGUgYXQgd1tqXVxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSAgIHcgICAgICAgICAgICAgICBUaGUgYXJyYXlcbiAgICogQHBhcmFtIHtOdW1iZXJ9ICBqICAgICAgICAgICAgICAgVGhlIGFycmF5IGluZGV4XG4gICAqXG4gICAqIFJlZmVyZW5jZTogaHR0cDovL2ZhY3VsdHkuY3NlLnRhbXUuZWR1L2RhdmlzL3B1YmxpY2F0aW9ucy5odG1sXG4gICAqL1xuICB2YXIgY3NfbWFyayA9IGZ1bmN0aW9uICh3LCBqKSB7XG4gICAgLy8gbWFyayB3W2pdXG4gICAgd1tqXSA9IGNzX2ZsaXAodyBbal0pO1xuICB9O1xuXG4gIHJldHVybiBjc19tYXJrO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnY3NfbWFyayc7XG5leHBvcnRzLnBhdGggPSAnc3BhcnNlJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKCkge1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIG5vZGUgYXQgd1tqXSBpcyBtYXJrZWRcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gICB3ICAgICAgICAgICAgICAgVGhlIGFycmF5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSAgaiAgICAgICAgICAgICAgIFRoZSBhcnJheSBpbmRleFxuICAgKlxuICAgKiBSZWZlcmVuY2U6IGh0dHA6Ly9mYWN1bHR5LmNzZS50YW11LmVkdS9kYXZpcy9wdWJsaWNhdGlvbnMuaHRtbFxuICAgKi9cbiAgdmFyIGNzX21hcmtlZCA9IGZ1bmN0aW9uICh3LCBqKSB7XG4gICAgLy8gY2hlY2sgbm9kZSBpcyBtYXJrZWRcbiAgICByZXR1cm4gd1tqXSA8IDA7XG4gIH07XG5cbiAgcmV0dXJuIGNzX21hcmtlZDtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2NzX21hcmtlZCc7XG5leHBvcnRzLnBhdGggPSAnc3BhcnNlJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUpIHtcblxuICB2YXIgU3BhcnNlTWF0cml4ID0gdHlwZS5TcGFyc2VNYXRyaXg7XG5cbiAgLyoqXG4gICAqIFBlcm11dGVzIGEgc3BhcnNlIG1hdHJpeCBDID0gUCAqIEEgKiBRXG4gICAqXG4gICAqIEBwYXJhbSB7TWF0cml4fSAgYSAgICAgICAgICAgICAgIFRoZSBNYXRyaXggQVxuICAgKiBAcGFyYW0ge0FycmF5fSAgIHBpbnYgICAgICAgICAgICBUaGUgcm93IHBlcm11dGF0aW9uIHZlY3RvclxuICAgKiBAcGFyYW0ge0FycmF5fSAgIHEgICAgICAgICAgICAgICBUaGUgY29sdW1uIHBlcm11dGF0aW9uIHZlY3RvclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlcyAgICAgICAgICBDcmVhdGUgYSBwYXR0ZXJuIG1hdHJpeCAoZmFsc2UpLCB2YWx1ZXMgYW5kIHBhdHRlcm4gb3RoZXJ3aXNlXG4gICAqXG4gICAqIEByZXR1cm4ge01hdHJpeH0gICAgICAgICAgICAgICAgIEMgPSBQICogQSAqIFEsIG51bGwgb24gZXJyb3JcbiAgICpcbiAgICogUmVmZXJlbmNlOiBodHRwOi8vZmFjdWx0eS5jc2UudGFtdS5lZHUvZGF2aXMvcHVibGljYXRpb25zLmh0bWxcbiAgICovXG4gIHZhciBjc19wZXJtdXRlID0gZnVuY3Rpb24gKGEsIHBpbnYsIHEsIHZhbHVlcykge1xuICAgIC8vIGEgYXJyYXlzXG4gICAgdmFyIGF2YWx1ZXMgPSBhLl92YWx1ZXM7XG4gICAgdmFyIGFpbmRleCA9IGEuX2luZGV4O1xuICAgIHZhciBhcHRyID0gYS5fcHRyO1xuICAgIHZhciBhc2l6ZSA9IGEuX3NpemU7XG4gICAgdmFyIGFkdCA9IGEuX2RhdGF0eXBlO1xuICAgIC8vIHJvd3MgJiBjb2x1bW5zXG4gICAgdmFyIG0gPSBhc2l6ZVswXTtcbiAgICB2YXIgbiA9IGFzaXplWzFdO1xuICAgIC8vIGMgYXJyYXlzXG4gICAgdmFyIGN2YWx1ZXMgPSB2YWx1ZXMgJiYgYS5fdmFsdWVzID8gW10gOiBudWxsO1xuICAgIHZhciBjaW5kZXggPSBbXTsgLy8gKGFwdHJbbl0pO1xuICAgIHZhciBjcHRyID0gW107IC8vIChuICsgMSk7XG4gICAgLy8gaW5pdGlhbGl6ZSB2YXJzXG4gICAgdmFyIG56ID0gMDtcbiAgICAvLyBsb29wIGNvbHVtbnMgICAgXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBuOyBrKyspIHtcbiAgICAgIC8vIGNvbHVtbiBrIG9mIEMgaXMgY29sdW1uIHFba10gb2YgQVxuICAgICAgY3B0cltrXSA9IG56O1xuICAgICAgLy8gYXBwbHkgY29sdW1uIHBlcm11dGF0aW9uXG4gICAgICB2YXIgaiA9IHEgPyAocVtrXSkgOiBrO1xuICAgICAgLy8gbG9vcCB2YWx1ZXMgaW4gY29sdW1uIGogb2YgQVxuICAgICAgZm9yICh2YXIgdDAgPSBhcHRyW2pdLCB0MSA9IGFwdHJbaiArIDFdLCB0ID0gdDA7IHQgPCB0MTsgdCsrKSB7XG4gICAgICAgIC8vIHJvdyBpIG9mIEEgaXMgcm93IHBpbnZbaV0gb2YgQ1xuICAgICAgICB2YXIgciA9IHBpbnYgPyBwaW52W2FpbmRleFt0XV0gOiBhaW5kZXhbdF07XG4gICAgICAgIC8vIGluZGV4XG4gICAgICAgIGNpbmRleFtuel0gPSByO1xuICAgICAgICAvLyBjaGVjayB3ZSBuZWVkIHRvIHBvcHVsYXRlIHZhbHVlc1xuICAgICAgICBpZiAoY3ZhbHVlcykgXG4gICAgICAgICAgY3ZhbHVlc1tuel0gPSBhdmFsdWVzW3RdO1xuICAgICAgICAvLyBpbmNyZW1lbnQgbnVtYmVyIG9mIG5vbnplcm8gZWxlbWVudHNcbiAgICAgICAgbnorKztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZmluYWxpemUgdGhlIGxhc3QgY29sdW1uIG9mIENcbiAgICBjcHRyW25dID0gbno7XG4gICAgLy8gcmV0dXJuIEMgbWF0cml4XG4gICAgcmV0dXJuIG5ldyBTcGFyc2VNYXRyaXgoe1xuICAgICAgdmFsdWVzOiBjdmFsdWVzLFxuICAgICAgaW5kZXg6IGNpbmRleCxcbiAgICAgIHB0cjogY3B0cixcbiAgICAgIHNpemU6IFttLCBuXSxcbiAgICAgIGRhdGF0eXBlOiBhZHRcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gY3NfcGVybXV0ZTtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2NzX3Blcm11dGUnO1xuZXhwb3J0cy5wYXRoID0gJ3NwYXJzZSc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQpIHtcblxuICB2YXIgY3NfdGRmcyA9IGxvYWQocmVxdWlyZSgnLi9jc190ZGZzJykpO1xuXG4gIC8qKlxuICAgKiBQb3N0IG9yZGVyIGEgdHJlZSBvZiBmb3Jlc3RcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gICBwYXJlbnQgICAgICAgICAgVGhlIHRyZWUgb3IgZm9yZXN0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSAgbiAgICAgICAgICAgICAgIE51bWJlciBvZiBjb2x1bW5zXG4gICAqXG4gICAqIFJlZmVyZW5jZTogaHR0cDovL2ZhY3VsdHkuY3NlLnRhbXUuZWR1L2RhdmlzL3B1YmxpY2F0aW9ucy5odG1sXG4gICAqL1xuICB2YXIgY3NfcG9zdCA9IGZ1bmN0aW9uIChwYXJlbnQsIG4pIHtcbiAgICAvLyBjaGVjayBpbnB1dHNcbiAgICBpZiAoIXBhcmVudCkgXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICAvLyB2YXJzIFxuICAgIHZhciBrID0gMDtcbiAgICB2YXIgajtcbiAgICAvLyBhbGxvY2F0ZSByZXN1bHRcbiAgICB2YXIgcG9zdCA9IFtdOyAvLyAobik7XG4gICAgLy8gd29ya3NwYWNlLCBoZWFkOiBmaXJzdCBuIGVudHJpZXMsIG5leHQ6IG5leHQgbiBlbnRyaWVzLCBzdGFjazogbGFzdCBuIGVudHJpZXNcbiAgICB2YXIgdyA9IFtdOyAvLyAoMyAqIG4pO1xuICAgIHZhciBoZWFkID0gMDsgXG4gICAgdmFyIG5leHQgPSBuOyBcbiAgICB2YXIgc3RhY2sgPSAyICogbjtcbiAgICAvLyBpbml0aWFsaXplIHdvcmtzcGFjZVxuICAgIGZvciAoaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgIC8vIGVtcHR5IGxpbmtlZCBsaXN0c1xuICAgICAgd1toZWFkICsgal0gPSAtMTtcbiAgICB9XG4gICAgLy8gdHJhdmVyc2Ugbm9kZXMgaW4gcmV2ZXJzZSBvcmRlclxuICAgIGZvciAoaiA9IG4tMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgIC8vIGNoZWNrIGogaXMgYSByb290XG4gICAgICBpZiAocGFyZW50W2pdID09IC0xKSBcbiAgICAgICAgY29udGludWU7XG4gICAgICAvLyBhZGQgaiB0byBsaXN0IG9mIGl0cyBwYXJlbnRcbiAgICAgIHdbbmV4dCArIGpdID0gd1toZWFkICsgcGFyZW50W2pdXTtcbiAgICAgIHdbaGVhZCArIHBhcmVudFtqXV0gPSBqO1xuICAgIH1cbiAgICAvLyBsb29wIG5vZGVzXG4gICAgZm9yIChqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgLy8gc2tpcCBqIGlmIGl0IGlzIG5vdCBhIHJvb3RcbiAgICAgIGlmIChwYXJlbnRbal0gIT0gLTEpIFxuICAgICAgICBjb250aW51ZTtcbiAgICAgIC8vIGRlcHRoLWZpcnN0IHNlYXJjaFxuICAgICAgayA9IGNzX3RkZnMoaiwgaywgdywgaGVhZCwgbmV4dCwgcG9zdCwgc3RhY2spO1xuICAgIH1cbiAgICByZXR1cm4gcG9zdDtcbiAgfTtcblxuICByZXR1cm4gY3NfcG9zdDtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2NzX3Bvc3QnO1xuZXhwb3J0cy5wYXRoID0gJ3NwYXJzZSc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQpIHtcblxuICB2YXIgY3NfZGZzID0gbG9hZChyZXF1aXJlKCcuL2NzX2RmcycpKTtcbiAgdmFyIGNzX21hcmtlZCA9IGxvYWQocmVxdWlyZSgnLi9jc19tYXJrZWQnKSk7XG4gIHZhciBjc19tYXJrID0gbG9hZChyZXF1aXJlKCcuL2NzX21hcmsnKSk7XG5cbiAgLyoqXG4gICAqIFRoZSBjc19yZWFjaCBmdW5jdGlvbiBjb21wdXRlcyBYID0gUmVhY2goQiksIHdoZXJlIEIgaXMgdGhlIG5vbnplcm8gcGF0dGVybiBvZiB0aGUgbi1ieS0xIFxuICAgKiBzcGFyc2UgY29sdW1uIG9mIHZlY3RvciBiLiBUaGUgZnVuY3Rpb24gcmV0dXJucyB0aGUgc2V0IG9mIG5vZGVzIHJlYWNoYWJsZSBmcm9tIGFueSBub2RlIGluIEIuIFRoZVxuICAgKiBub256ZXJvIHBhdHRlcm4geGkgb2YgdGhlIHNvbHV0aW9uIHggdG8gdGhlIHNwYXJzZSBsaW5lYXIgc3lzdGVtIEx4PWIgaXMgZ2l2ZW4gYnkgWD1SZWFjaChCKS5cbiAgICpcbiAgICogQHBhcmFtIHtNYXRyaXh9ICBnICAgICAgICAgICAgICAgVGhlIEcgbWF0cml4XG4gICAqIEBwYXJhbSB7TWF0cml4fSAgYiAgICAgICAgICAgICAgIFRoZSBCIG1hdHJpeFxuICAgKiBAcGFyYW0ge051bWJlcn0gIGsgICAgICAgICAgICAgICBUaGUga3RoIGNvbHVtbiBpbiBCXG4gICAqIEBwYXJhbSB7QXJyYXl9ICAgeGkgICAgICAgICAgICAgIFRoZSBub256ZXJvIHBhdHRlcm4geGlbdG9wXSAuLiB4aVtuIC0gMV0sIGFuIGFycmF5IG9mIHNpemUgPSAyICogblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZmlyc3QgbiBlbnRyaWVzIGlzIHRoZSBub256ZXJvIHBhdHRlcm4sIHRoZSBsYXN0IG4gZW50cmllcyBpcyB0aGUgc3RhY2tcbiAgICogQHBhcmFtIHtBcnJheX0gICBwaW52ICAgICAgICAgICAgVGhlIGludmVyc2Ugcm93IHBlcm11dGF0aW9uIHZlY3RvclxuICAgKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgICAgICBUaGUgaW5kZXggZm9yIHRoZSBub256ZXJvIHBhdHRlcm5cbiAgICpcbiAgICogUmVmZXJlbmNlOiBodHRwOi8vZmFjdWx0eS5jc2UudGFtdS5lZHUvZGF2aXMvcHVibGljYXRpb25zLmh0bWxcbiAgICovXG4gIHZhciBjc19yZWFjaCA9IGZ1bmN0aW9uIChnLCBiLCBrLCB4aSwgcGludikge1xuICAgIC8vIGcgYXJyYXlzXG4gICAgdmFyIGdwdHIgPSBnLl9wdHI7XG4gICAgdmFyIGdzaXplID0gZy5fc2l6ZTtcbiAgICAvLyBiIGFycmF5c1xuICAgIHZhciBiaW5kZXggPSBiLl9pbmRleDtcbiAgICB2YXIgYnB0ciA9IGIuX3B0cjtcbiAgICAvLyBjb2x1bW5zXG4gICAgdmFyIG4gPSBnc2l6ZVsxXTtcbiAgICAvLyB2YXJzXG4gICAgdmFyIHAsIHAwLCBwMTtcbiAgICAvLyBpbml0aWFsaXplIHRvcFxuICAgIHZhciB0b3AgPSBuO1xuICAgIC8vIGxvb3AgY29sdW1uIGluZGVjZXMgaW4gQlxuICAgIGZvciAocDAgPSBicHRyW2tdLCBwMSA9IGJwdHJbayArIDFdLCBwID0gcDA7IHAgPCBwMTsgcCsrKSB7XG4gICAgICAvLyBub2RlIGlcbiAgICAgIHZhciBpID0gYmluZGV4W3BdO1xuICAgICAgLy8gY2hlY2sgbm9kZSBpIGlzIG1hcmtlZFxuICAgICAgaWYgKCFjc19tYXJrZWQoZ3B0ciwgaSkpIHtcbiAgICAgICAgLy8gc3RhcnQgYSBkZnMgYXQgdW5tYXJrZWQgbm9kZSBpXG4gICAgICAgIHRvcCA9IGNzX2RmcyhpLCBnLCB0b3AsIHhpLCBwaW52KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gbG9vcCBjb2x1bW5zIGZyb20gdG9wIC0+IG4gLSAxXG4gICAgZm9yIChwID0gdG9wOyBwIDwgbjsgcCsrKSB7XG4gICAgICAvLyByZXN0b3JlIEdcbiAgICAgIGNzX21hcmsoZ3B0ciwgeGlbcF0pO1xuICAgIH1cbiAgICByZXR1cm4gdG9wO1xuICB9O1xuXG4gIHJldHVybiBjc19yZWFjaDtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2NzX3JlYWNoJztcbmV4cG9ydHMucGF0aCA9ICdzcGFyc2UnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkKSB7XG5cbiAgdmFyIGRpdmlkZVNjYWxhciA9IGxvYWQocmVxdWlyZSgnLi4vLi4vYXJpdGhtZXRpYy9kaXZpZGVTY2FsYXInKSk7XG4gIHZhciBtdWx0aXBseSA9IGxvYWQocmVxdWlyZSgnLi4vLi4vYXJpdGhtZXRpYy9tdWx0aXBseScpKTtcbiAgdmFyIHN1YnRyYWN0ID0gbG9hZChyZXF1aXJlKCcuLi8uLi9hcml0aG1ldGljL3N1YnRyYWN0JykpO1xuXG4gIHZhciBjc19yZWFjaCA9IGxvYWQocmVxdWlyZSgnLi9jc19yZWFjaCcpKTtcblxuICAvKipcbiAgICogVGhlIGZ1bmN0aW9uIGNzX3Nwc29sdmUoKSBjb21wdXRlcyB0aGUgc29sdXRpb24gdG8gRyAqIHggPSBiaywgd2hlcmUgYmsgaXMgdGhlXG4gICAqIGt0aCBjb2x1bW4gb2YgQi4gV2hlbiBsbyBpcyB0cnVlLCB0aGUgZnVuY3Rpb24gYXNzdW1lcyBHID0gTCBpcyBsb3dlciB0cmlhbmd1bGFyIHdpdGggdGhlXG4gICAqIGRpYWdvbmFsIGVudHJ5IGFzIHRoZSBmaXJzdCBlbnRyeSBpbiBlYWNoIGNvbHVtbi4gV2hlbiBsbyBpcyB0cnVlLCB0aGUgZnVuY3Rpb24gYXNzdW1lcyBHID0gVSBcbiAgICogaXMgdXBwZXIgdHJpYW5ndWxhciB3aXRoIHRoZSBkaWFnb25hbCBlbnRyeSBhcyB0aGUgbGFzdCBlbnRyeSBpbiBlYWNoIGNvbHVtbi5cbiAgICpcbiAgICogQHBhcmFtIHtNYXRyaXh9ICBnICAgICAgICAgICAgICAgVGhlIEcgbWF0cml4XG4gICAqIEBwYXJhbSB7TWF0cml4fSAgYiAgICAgICAgICAgICAgIFRoZSBCIG1hdHJpeFxuICAgKiBAcGFyYW0ge051bWJlcn0gIGsgICAgICAgICAgICAgICBUaGUga3RoIGNvbHVtbiBpbiBCXG4gICAqIEBwYXJhbSB7QXJyYXl9ICAgeGkgICAgICAgICAgICAgIFRoZSBub256ZXJvIHBhdHRlcm4geGlbdG9wXSAuLiB4aVtuIC0gMV0sIGFuIGFycmF5IG9mIHNpemUgPSAyICogblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZmlyc3QgbiBlbnRyaWVzIGlzIHRoZSBub256ZXJvIHBhdHRlcm4sIHRoZSBsYXN0IG4gZW50cmllcyBpcyB0aGUgc3RhY2tcbiAgICogQHBhcmFtIHtBcnJheX0gICB4ICAgICAgICAgICAgICAgVGhlIHNvbHV0b24gdG8gdGhlIGxpbmVhciBzeXN0ZW0gRyAqIHggPSBiXG4gICAqIEBwYXJhbSB7QXJyYXl9ICAgcGludiAgICAgICAgICAgIFRoZSBpbnZlcnNlIHJvdyBwZXJtdXRhdGlvbiB2ZWN0b3IsIG11c3QgYmUgbnVsbCBmb3IgTCAqIHggPSBiXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gbG8gICAgICAgICAgICAgIFRoZSBsb3dlciAodHJ1ZSkgdXBwZXIgdHJpYW5ndWxhciAoZmFsc2UpIGZsYWdcbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgICAgICAgVGhlIGluZGV4IGZvciB0aGUgbm9uemVybyBwYXR0ZXJuXG4gICAqXG4gICAqIFJlZmVyZW5jZTogaHR0cDovL2ZhY3VsdHkuY3NlLnRhbXUuZWR1L2RhdmlzL3B1YmxpY2F0aW9ucy5odG1sXG4gICAqL1xuICB2YXIgY3Nfc3Bzb2x2ZSA9IGZ1bmN0aW9uIChnLCBiLCBrLCB4aSwgeCwgcGludiwgbG8pIHtcbiAgICAvLyBnIGFycmF5c1xuICAgIHZhciBndmFsdWVzID0gZy5fdmFsdWVzO1xuICAgIHZhciBnaW5kZXggPSBnLl9pbmRleDtcbiAgICB2YXIgZ3B0ciA9IGcuX3B0cjtcbiAgICB2YXIgZ3NpemUgPSBnLl9zaXplO1xuICAgIC8vIGNvbHVtbnNcbiAgICB2YXIgbiA9IGdzaXplWzFdO1xuICAgIC8vIGIgYXJyYXlzXG4gICAgdmFyIGJ2YWx1ZXMgPSBiLl92YWx1ZXM7XG4gICAgdmFyIGJpbmRleCA9IGIuX2luZGV4O1xuICAgIHZhciBicHRyID0gYi5fcHRyO1xuICAgIC8vIHZhcnNcbiAgICB2YXIgcCwgcDAsIHAxLCBxO1xuICAgIC8vIHhpW3RvcC4ubi0xXSA9IGNzX3JlYWNoKEIoOixrKSlcbiAgICB2YXIgdG9wID0gY3NfcmVhY2goZywgYiwgaywgeGksIHBpbnYpO1xuICAgIC8vIGNsZWFyIHhcbiAgICBmb3IgKHAgPSB0b3A7IHAgPCBuOyBwKyspIFxuICAgICAgeFt4aVtwXV0gPSAwO1xuICAgIC8vIHNjYXR0ZXIgYlxuICAgIGZvciAocDAgPSBicHRyW2tdLCBwMSA9IGJwdHJbayArIDFdLCBwID0gcDA7IHAgPCBwMTsgcCsrKSBcbiAgICAgIHhbYmluZGV4W3BdXSA9IGJ2YWx1ZXNbcF07XG4gICAgLy8gbG9vcCBjb2x1bW5zXG4gICAgZm9yICh2YXIgcHggPSB0b3A7IHB4IDwgbjsgcHgrKykge1xuICAgICAgLy8geCBhcnJheSBpbmRleCBmb3IgcHhcbiAgICAgIHZhciBqID0geGlbcHhdO1xuICAgICAgLy8gYXBwbHkgcGVybXV0YXRpb24gdmVjdG9yIChVIHggPSBiKSwgaiBtYXBzIHRvIGNvbHVtbiBKIG9mIEdcbiAgICAgIHZhciBKID0gcGludiA/IHBpbnZbal0gOiBqO1xuICAgICAgLy8gY2hlY2sgY29sdW1uIEogaXMgZW1wdHlcbiAgICAgIGlmIChKIDwgMClcbiAgICAgICAgY29udGludWU7XG4gICAgICAvLyBjb2x1bW4gdmFsdWUgaW5kZWNlcyBpbiBHLCBwMCA8PSBwIDwgcDFcbiAgICAgIHAwID0gZ3B0cltKXTtcbiAgICAgIHAxID0gZ3B0cltKICsgMV07XG4gICAgICAvLyB4KGopIC89IEcoaixqKVxuICAgICAgeFtqXSA9IGRpdmlkZVNjYWxhcih4W2pdLCBndmFsdWVzW2xvID8gcDAgOiAocDEgLSAxKV0pO1xuICAgICAgLy8gZmlyc3QgZW50cnkgTChqLGopXG4gICAgICBwID0gbG8gPyAocDAgKyAxKSA6IHAwO1xuICAgICAgcSA9IGxvID8gKHAxKSA6IChwMSAtIDEpO1xuICAgICAgLy8gbG9vcFxuICAgICAgZm9yICggOyBwIDwgcSA7IHArKykge1xuICAgICAgICAvLyByb3dcbiAgICAgICAgdmFyIGkgPSBnaW5kZXhbcF07XG4gICAgICAgIC8vIHgoaSkgLT0gRyhpLGopICogeChqKVxuICAgICAgICB4W2ldID0gc3VidHJhY3QoeFtpXSwgbXVsdGlwbHkoZ3ZhbHVlc1twXSwgeFtqXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyByZXR1cm4gdG9wIG9mIHN0YWNrXG4gICAgcmV0dXJuIHRvcDtcbiAgfTtcbiAgXG4gIHJldHVybiBjc19zcHNvbHZlO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnY3Nfc3Bzb2x2ZSc7XG5leHBvcnRzLnBhdGggPSAnc3BhcnNlJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCkge1xuXG4gIHZhciBjc19hbWQgPSBsb2FkKHJlcXVpcmUoJy4vY3NfYW1kJykpO1xuICB2YXIgY3NfcGVybXV0ZSA9IGxvYWQocmVxdWlyZSgnLi9jc19wZXJtdXRlJykpO1xuICB2YXIgY3NfZXRyZWUgPSBsb2FkKHJlcXVpcmUoJy4vY3NfZXRyZWUnKSk7XG4gIHZhciBjc19wb3N0ID0gbG9hZChyZXF1aXJlKCcuL2NzX3Bvc3QnKSk7XG4gIHZhciBjc19jb3VudHMgPSBsb2FkKHJlcXVpcmUoJy4vY3NfY291bnRzJykpO1xuXG4gIC8qKlxuICAgKiBTeW1ib2xpYyBvcmRlcmluZyBhbmQgYW5hbHlzaXMgZm9yIFFSIGFuZCBMVSBkZWNvbXBvc2l0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9ICBvcmRlciAgICAgICAgICAgVGhlIG9yZGVyaW5nIHN0cmF0ZWd5IChzZWUgY3NfYW1kIGZvciBtb3JlIGRldGFpbHMpXG4gICAqIEBwYXJhbSB7TWF0cml4fSAgYSAgICAgICAgICAgICAgIFRoZSBBIG1hdHJpeFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHFyICAgICAgICAgICAgICBTeW1ib2xpYyBvcmRlcmluZyBhbmQgYW5hbHlzaXMgZm9yIFFSIGRlY29tcG9zaXRpb24gKHRydWUpIG9yXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbGljIG9yZGVyaW5nIGFuZCBhbmFseXNpcyBmb3IgTFUgZGVjb21wb3NpdGlvbiAoZmFsc2UpXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICAgIFRoZSBTeW1ib2xpYyBvcmRlcmluZyBhbmQgYW5hbHlzaXMgZm9yIG1hdHJpeCBBXG4gICAqXG4gICAqIFJlZmVyZW5jZTogaHR0cDovL2ZhY3VsdHkuY3NlLnRhbXUuZWR1L2RhdmlzL3B1YmxpY2F0aW9ucy5odG1sXG4gICAqL1xuICB2YXIgY3Nfc3FyID0gZnVuY3Rpb24gKG9yZGVyLCBhLCBxcikge1xuICAgIC8vIGEgYXJyYXlzXG4gICAgdmFyIGFwdHIgPSBhLl9wdHI7XG4gICAgdmFyIGFzaXplID0gYS5fc2l6ZTtcbiAgICAvLyBjb2x1bW5zXG4gICAgdmFyIG4gPSBhc2l6ZVsxXTtcbiAgICAvLyB2YXJzXG4gICAgdmFyIGs7XG4gICAgLy8gc3ltYm9saWMgYW5hbHlzaXMgcmVzdWx0XG4gICAgdmFyIHMgPSB7fTsgICAgXG4gICAgLy8gZmlsbC1yZWR1Y2luZyBvcmRlcmluZ1xuICAgIHMucSA9IGNzX2FtZChvcmRlciwgYSk7XG4gICAgLy8gdmFsaWRhdGUgcmVzdWx0c1xuICAgIGlmIChvcmRlciAmJiAhcy5xKSBcbiAgICAgIHJldHVybiBudWxsO1xuICAgIC8vIFFSIHN5bWJvbGljIGFuYWx5c2lzXG4gICAgaWYgKHFyKSB7XG4gICAgICAvLyBhcHBseSBwZXJtdXRhdGlvbnMgaWYgbmVlZGVkXG4gICAgICB2YXIgYyA9IG9yZGVyID8gY3NfcGVybXV0ZShhLCBudWxsLCBzLnEsIDApIDogYTtcbiAgICAgIC8vIGV0cmVlIG9mIEMnKkMsIHdoZXJlIEM9QSg6LHEpXG4gICAgICBzLnBhcmVudCA9IGNzX2V0cmVlKGMsIDEpO1xuICAgICAgLy8gcG9zdCBvcmRlciBlbGltaW5hdGlvbiB0cmVlXG4gICAgICB2YXIgcG9zdCA9IGNzX3Bvc3QgKHMucGFyZW50LCBuKTtcbiAgICAgIC8vIGNvbCBjb3VudHMgY2hvbChDJypDKVxuICAgICAgcy5jcCA9IGNzX2NvdW50cyhjLCBzLnBhcmVudCwgcG9zdCwgMSk7XG4gICAgICAvLyBjaGVjayB3ZSBoYXZlIGV2ZXJ5dGhpbmcgbmVlZGVkIHRvIGNhbGN1bGF0ZSBudW1iZXIgb2Ygbm9uemVybyBlbGVtZW50c1xuICAgICAgaWYgKGMgJiYgcy5wYXJlbnQgJiYgcy5jcCAmJiBfdmNvdW50KGMsIHMpKSB7XG4gICAgICAgIC8vIGNhbGN1bGF0ZSBudW1iZXIgb2Ygbm9uemVybyBlbGVtZW50c1xuICAgICAgICBmb3IgKHMudW56ID0gMCwgayA9IDA7IGsgPCBuOyBrKyspIFxuICAgICAgICAgIHMudW56ICs9IHMuY3Bba107XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gZm9yIExVIGZhY3Rvcml6YXRpb24gb25seSwgZ3Vlc3Mgbm56KEwpIGFuZCBubnooVSlcbiAgICAgIHMudW56ID0gNCAqIChhcHRyW25dKSArIG47XG4gICAgICBzLmxueiA9IHMudW56O1xuICAgIH1cbiAgICAvLyByZXR1cm4gcmVzdWx0IFNcbiAgICByZXR1cm4gcztcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBDb21wdXRlIG5ueihWKSA9IHMubG56LCBzLnBpbnYsIHMubGVmdG1vc3QsIHMubTIgZnJvbSBBIGFuZCBzLnBhcmVudFxuICAgKi9cbiAgdmFyIF92Y291bnQgPSBmdW5jdGlvbiAoYSwgcykge1xuICAgIC8vIGEgYXJyYXlzXG4gICAgdmFyIGFwdHIgPSBhLl9wdHI7XG4gICAgdmFyIGFpbmRleCA9IGEuX2luZGV4O1xuICAgIHZhciBhc2l6ZSA9IGEuX3NpemU7XG4gICAgLy8gcm93cyAmIGNvbHVtbnNcbiAgICB2YXIgbSA9IGFzaXplWzBdO1xuICAgIHZhciBuID0gYXNpemVbMV07XG4gICAgLy8gaW5pdGlhbGl6ZSBzIGFycmF5c1xuICAgIHMucGludiA9IFtdOyAvLyAobSArIG4pO1xuICAgIHMubGVmdG1vc3QgPSBbXTsgLy8gKG0pO1xuICAgIC8vIHZhcnNcbiAgICB2YXIgcGFyZW50ID0gcy5wYXJlbnQ7XG4gICAgdmFyIHBpbnYgPSBzLnBpbnY7XG4gICAgdmFyIGxlZnRtb3N0ID0gcy5sZWZ0bW9zdDtcbiAgICAvLyB3b3Jrc3BhY2UsIG5leHQ6IGZpcnN0IG0gZW50cmllcywgaGVhZDogbmV4dCBuIGVudHJpZXMsIHRhaWw6IG5leHQgbiBlbnRyaWVzLCBucXVlOiBuZXh0IG4gZW50cmllc1xuICAgIHZhciB3ID0gW107IC8vIChtICsgMyAqIG4pO1xuICAgIHZhciBuZXh0ID0gMDtcbiAgICB2YXIgaGVhZCA9IG07XG4gICAgdmFyIHRhaWwgPSBtICsgbjtcbiAgICB2YXIgbnF1ZSA9IG0gKyAyICogbjtcbiAgICAvLyB2YXJzXG4gICAgdmFyIGksIGssIHAsIHAwLCBwMTtcbiAgICAvLyBpbml0aWFsaXplIHdcbiAgICBmb3IgKGsgPSAwOyBrIDwgbjsgaysrKSB7XG4gICAgICAvLyBxdWV1ZSBrIGlzIGVtcHR5XG4gICAgICB3W2hlYWQgKyBrXSA9IC0xO1xuICAgICAgd1t0YWlsICsga10gPSAtMTtcbiAgICAgIHdbbnF1ZSArIGtdID0gMDtcbiAgICB9XG4gICAgLy8gaW5pdGlhbGl6ZSByb3cgYXJyYXlzXG4gICAgZm9yIChpID0gMDsgaSA8IG07IGkrKykgXG4gICAgICBsZWZ0bW9zdFtpXSA9IC0xO1xuICAgIC8vIGxvb3AgY29sdW1ucyBiYWNrd2FyZHMgICAgXG4gICAgZm9yIChrID0gbiAtIDE7IGsgPj0gMDsgay0tKSB7XG4gICAgICAvLyB2YWx1ZXMgJiBpbmRleCBmb3IgY29sdW1uIGtcbiAgICAgIGZvciAocDAgPSBhcHRyW2tdLCBwMSA9IGFwdHJbayArIDFdLCBwID0gcDA7IHAgPCBwMTsgcCsrKSB7XG4gICAgICAgIC8vIGxlZnRtb3N0W2ldID0gbWluKGZpbmQoQShpLDopKSlcbiAgICAgICAgbGVmdG1vc3RbYWluZGV4W3BdXSA9IGs7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHNjYW4gcm93cyBpbiByZXZlcnNlIG9yZGVyXG4gICAgZm9yIChpID0gbSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAvLyByb3cgaSBpcyBub3QgeWV0IG9yZGVyZWRcbiAgICAgIHBpbnZbaV0gPSAtMTtcbiAgICAgIGsgPSBsZWZ0bW9zdFtpXTtcbiAgICAgIC8vIGNoZWNrIHJvdyBpIGlzIGVtcHR5XG4gICAgICBpZiAoayA9PSAtMSkgXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgLy8gZmlyc3Qgcm93IGluIHF1ZXVlIGtcbiAgICAgIGlmICh3W25xdWUgKyBrXSsrID09PSAwKSBcbiAgICAgICAgd1t0YWlsICsga10gPSBpO1xuICAgICAgLy8gcHV0IGkgYXQgaGVhZCBvZiBxdWV1ZSBrXG4gICAgICB3W25leHQgKyBpXSA9IHdbaGVhZCArIGtdO1xuICAgICAgd1toZWFkICsga10gPSBpO1xuICAgIH1cbiAgICBzLmxueiA9IDA7XG4gICAgcy5tMiA9IG07XG4gICAgLy8gZmluZCByb3cgcGVybXV0YXRpb24gYW5kIG5ueihWKVxuICAgIGZvciAoayA9IDA7IGsgPCBuOyBrKyspIHtcbiAgICAgIC8vIHJlbW92ZSByb3cgaSBmcm9tIHF1ZXVlIGtcbiAgICAgIGkgPSB3W2hlYWQgKyBrXTtcbiAgICAgIC8vIGNvdW50IFYoayxrKSBhcyBub256ZXJvXG4gICAgICBzLmxueisrO1xuICAgICAgLy8gYWRkIGEgZmljdGl0aW91cyByb3dcbiAgICAgIGlmIChpIDwgMCkgXG4gICAgICAgIGkgPSBzLm0yKys7XG4gICAgICAvLyBhc3NvY2lhdGUgcm93IGkgd2l0aCBWKDosaylcbiAgICAgIHBpbnZbaV0gPSBrO1xuICAgICAgLy8gc2tpcCBpZiBWKGsrMTptLGspIGlzIGVtcHR5XG4gICAgICBpZiAoLS1ucXVlW2tdIDw9IDApIFxuICAgICAgICBjb250aW51ZTtcbiAgICAgIC8vIG5xdWVba10gaXMgbm56IChWKGsrMTptLGspKVxuICAgICAgcy5sbnogKz0gd1tucXVlICsga107XG4gICAgICAvLyBtb3ZlIGFsbCByb3dzIHRvIHBhcmVudCBvZiBrXG4gICAgICB2YXIgcGEgPSBwYXJlbnRba107XG4gICAgICBpZiAocGEgIT0gLTEpIHtcbiAgICAgICAgaWYgKHdbbnF1ZSArIHBhXSA9PT0gMCkgXG4gICAgICAgICAgd1t0YWlsICsgcGFdID0gd1t0YWlsICsga107XG4gICAgICAgIHdbbmV4dCArIHdbdGFpbCArIGtdXSA9IHdbaGVhZCArIHBhXTtcbiAgICAgICAgd1toZWFkICsgcGFdID0gd1tuZXh0ICsgaV07XG4gICAgICAgIHdbbnF1ZSArIHBhXSArPSB3W25xdWUgKyBrXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IG07IGkrKykge1xuICAgICAgaWYgKHBpbnZbaV0gPCAwKSBcbiAgICAgICAgcGludltpXSA9IGsrKztcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgcmV0dXJuIGNzX3Nxcjtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2NzX3Nxcic7XG5leHBvcnRzLnBhdGggPSAnc3BhcnNlJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKCkge1xuXG4gIC8qKlxuICAgKiBEZXB0aC1maXJzdCBzZWFyY2ggYW5kIHBvc3RvcmRlciBvZiBhIHRyZWUgcm9vdGVkIGF0IG5vZGUgalxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gIGogICAgICAgICAgICAgICBUaGUgdHJlZSBub2RlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSAgayAgICAgICAgICAgICAgIFxuICAgKiBAcGFyYW0ge0FycmF5fSAgIHcgICAgICAgICAgICAgICBUaGUgd29ya3NwYWNlIGFycmF5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSAgaGVhZCAgICAgICAgICAgIFRoZSBpbmRleCBvZmZzZXQgd2l0aGluIHRoZSB3b3Jrc3BhY2UgZm9yIHRoZSBoZWFkIGFycmF5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSAgbmV4dCAgICAgICAgICAgIFRoZSBpbmRleCBvZmZzZXQgd2l0aGluIHRoZSB3b3Jrc3BhY2UgZm9yIHRoZSBuZXh0IGFycmF5XG4gICAqIEBwYXJhbSB7QXJyYXl9ICAgcG9zdCAgICAgICAgICAgIFRoZSBwb3N0IG9yZGVyaW5nIGFycmF5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSAgc3RhY2sgICAgICAgICAgIFRoZSBpbmRleCBvZmZzZXQgd2l0aGluIHRoZSB3b3Jrc3BhY2UgZm9yIHRoZSBzdGFjayBhcnJheVxuICAgKlxuICAgKiBSZWZlcmVuY2U6IGh0dHA6Ly9mYWN1bHR5LmNzZS50YW11LmVkdS9kYXZpcy9wdWJsaWNhdGlvbnMuaHRtbFxuICAgKi9cbiAgdmFyIGNzX3RkZnMgPSBmdW5jdGlvbiAoaiwgaywgdywgaGVhZCwgbmV4dCwgcG9zdCwgc3RhY2spIHtcbiAgICAvLyB2YXJpYWJsZXNcbiAgICB2YXIgdG9wID0gMDtcbiAgICAvLyBwbGFjZSBqIG9uIHRoZSBzdGFja1xuICAgIHdbc3RhY2tdID0gajtcbiAgICAvLyB3aGlsZSAoc3RhY2sgaXMgbm90IGVtcHR5KSBcbiAgICB3aGlsZSAodG9wID49IDApIHtcbiAgICAgIC8vIHAgPSB0b3Agb2Ygc3RhY2tcbiAgICAgIHZhciBwID0gd1tzdGFjayArIHRvcF07XG4gICAgICAvLyBpID0geW91bmdlc3QgY2hpbGQgb2YgcFxuICAgICAgdmFyIGkgPSB3W2hlYWQgKyBwXTtcbiAgICAgIGlmIChpID09IC0xKSB7XG4gICAgICAgIC8vIHAgaGFzIG5vIHVub3JkZXJlZCBjaGlsZHJlbiBsZWZ0XG4gICAgICAgIHRvcC0tO1xuICAgICAgICAvLyBub2RlIHAgaXMgdGhlIGt0aCBwb3N0b3JkZXJlZCBub2RlXG4gICAgICAgIHBvc3RbaysrXSA9IHA7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gcmVtb3ZlIGkgZnJvbSBjaGlsZHJlbiBvZiBwXG4gICAgICAgIHdbaGVhZCArIHBdID0gd1tuZXh0ICsgaV07XG4gICAgICAgIC8vIGluY3JlbWVudCB0b3BcbiAgICAgICAgKyt0b3A7XG4gICAgICAgIC8vIHN0YXJ0IGRmcyBvbiBjaGlsZCBub2RlIGlcbiAgICAgICAgd1tzdGFjayArIHRvcF0gPSBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaztcbiAgfTtcblxuICByZXR1cm4gY3NfdGRmcztcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2NzX3RkZnMnO1xuZXhwb3J0cy5wYXRoID0gJ3NwYXJzZSc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQpIHtcblxuICB2YXIgY3NfZmxpcCA9IGxvYWQocmVxdWlyZSgnLi9jc19mbGlwJykpO1xuICBcbiAgLyoqXG4gICAqIEZsaXBzIHRoZSB2YWx1ZSBpZiBpdCBpcyBuZWdhdGl2ZSBvZiByZXR1cm5zIHRoZSBzYW1lIHZhbHVlIG90aGVyd2lzZS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9ICBpICAgICAgICAgICAgICAgVGhlIHZhbHVlIHRvIGZsaXBcbiAgICpcbiAgICogUmVmZXJlbmNlOiBodHRwOi8vZmFjdWx0eS5jc2UudGFtdS5lZHUvZGF2aXMvcHVibGljYXRpb25zLmh0bWxcbiAgICovXG4gIHZhciBjc191bmZsaXAgPSBmdW5jdGlvbiAoaSkge1xuICAgIC8vIGZsaXAgdGhlIHZhbHVlIGlmIGl0IGlzIG5lZ2F0aXZlXG4gICAgcmV0dXJuIGkgPCAwID8gY3NfZmxpcChpKSA6IGk7XG4gIH07XG5cbiAgcmV0dXJuIGNzX3VuZmxpcDtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2NzX3VuZmxpcCc7XG5leHBvcnRzLnBhdGggPSAnc3BhcnNlJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWVwTWFwID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9kZWVwTWFwJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgYSBudW1iZXIuIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzXG4gICAqIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5hYnMoeClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGguYWJzKDMuNSk7ICAgICAgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIDMuNVxuICAgKiAgICBtYXRoLmFicygtNC4yKTsgICAgICAgICAgICAgICAvLyByZXR1cm5zIG51bWJlciA0LjJcbiAgICpcbiAgICogICAgbWF0aC5hYnMoWzMsIC01LCAtMSwgMCwgMl0pOyAgLy8gcmV0dXJucyBBcnJheSBbMywgNSwgMSwgMCwgMl1cbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIHNpZ25cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb24gfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXggfCBVbml0fSB4XG4gICAqICAgICAgICAgICAgQSBudW1iZXIgb3IgbWF0cml4IGZvciB3aGljaCB0byBnZXQgdGhlIGFic29sdXRlIHZhbHVlXG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4IHwgVW5pdH1cbiAgICogICAgICAgICAgICBBYnNvbHV0ZSB2YWx1ZSBvZiBgeGBcbiAgICovXG4gIHZhciBhYnMgPSB0eXBlZCgnYWJzJywge1xuICAgICdudW1iZXInOiBNYXRoLmFicyxcblxuICAgICdDb21wbGV4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LmFicygpO1xuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LmFicygpO1xuICAgIH0sXG5cbiAgICAnRnJhY3Rpb24nOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHguYWJzKCk7XG4gICAgfSxcblxuICAgICdBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAvLyBkZWVwIG1hcCBjb2xsZWN0aW9uLCBza2lwIHplcm9zIHNpbmNlIGFicygwKSA9IDBcbiAgICAgIHJldHVybiBkZWVwTWFwKHgsIGFicywgdHJ1ZSk7XG4gICAgfSxcblxuICAgICdVbml0JzogZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHguYWJzKCk7XG4gICAgfVxuICB9KTtcblxuICBhYnMudG9UZXggPSAnXFxcXGxlZnR8JHthcmdzWzBdfVxcXFxyaWdodHwnO1xuXG4gIHJldHVybiBhYnM7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdhYnMnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdCcpLmV4dGVuZDtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuXG4gIHZhciBtYXRyaXggPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L2Z1bmN0aW9uL21hdHJpeCcpKTtcbiAgdmFyIGFkZFNjYWxhciA9IGxvYWQocmVxdWlyZSgnLi9hZGRTY2FsYXInKSk7XG4gIHZhciBsYXRleCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2xhdGV4LmpzJyk7XG4gIFxuICB2YXIgYWxnb3JpdGhtMDEgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTAxJykpO1xuICB2YXIgYWxnb3JpdGhtMDQgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTA0JykpO1xuICB2YXIgYWxnb3JpdGhtMTAgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTEwJykpO1xuICB2YXIgYWxnb3JpdGhtMTMgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTEzJykpO1xuICB2YXIgYWxnb3JpdGhtMTQgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTE0JykpO1xuXG4gIC8qKlxuICAgKiBBZGQgdHdvIHZhbHVlcywgYHggKyB5YC5cbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmFkZCh4LCB5KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5hZGQoMiwgMyk7ICAgICAgICAgICAgICAgLy8gcmV0dXJucyBudW1iZXIgNVxuICAgKlxuICAgKiAgICB2YXIgYSA9IG1hdGguY29tcGxleCgyLCAzKTtcbiAgICogICAgdmFyIGIgPSBtYXRoLmNvbXBsZXgoLTQsIDEpO1xuICAgKiAgICBtYXRoLmFkZChhLCBiKTsgICAgICAgICAgICAgICAvLyByZXR1cm5zIENvbXBsZXggLTIgKyA0aVxuICAgKlxuICAgKiAgICBtYXRoLmFkZChbMSwgMiwgM10sIDQpOyAgICAgICAvLyByZXR1cm5zIEFycmF5IFs1LCA2LCA3XVxuICAgKlxuICAgKiAgICB2YXIgYyA9IG1hdGgudW5pdCgnNSBjbScpO1xuICAgKiAgICB2YXIgZCA9IG1hdGgudW5pdCgnMi4xIG1tJyk7XG4gICAqICAgIG1hdGguYWRkKGMsIGQpOyAgICAgICAgICAgICAgIC8vIHJldHVybnMgVW5pdCA1Mi4xIG1tXG4gICAqXG4gICAqICAgIG1hdGguYWRkKFwiMi4zXCIsIFwiNFwiKTsgICAgICAgICAvLyByZXR1cm5zIG51bWJlciA2LjNcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIHN1YnRyYWN0XG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeH0geCBGaXJzdCB2YWx1ZSB0byBhZGRcbiAgICogQHBhcmFtICB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb24gfCBDb21wbGV4IHwgVW5pdCB8IEFycmF5IHwgTWF0cml4fSB5IFNlY29uZCB2YWx1ZSB0byBhZGRcbiAgICogQHJldHVybiB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb24gfCBDb21wbGV4IHwgVW5pdCB8IEFycmF5IHwgTWF0cml4fSBTdW0gb2YgYHhgIGFuZCBgeWBcbiAgICovXG4gIHZhciBhZGQgPSB0eXBlZCgnYWRkJywgZXh0ZW5kKHtcbiAgICAvLyB3ZSBleHRlbmQgdGhlIHNpZ25hdHVyZXMgb2YgYWRkU2NhbGFyIHdpdGggc2lnbmF0dXJlcyBkZWFsaW5nIHdpdGggbWF0cmljZXNcblxuICAgICdNYXRyaXgsIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuICAgICAgXG4gICAgICAvLyBwcm9jZXNzIG1hdHJpeCBzdG9yYWdlXG4gICAgICBzd2l0Y2ggKHguc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgc3dpdGNoICh5LnN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICAgICAgLy8gc3BhcnNlICsgc3BhcnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0wNCh4LCB5LCBhZGRTY2FsYXIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIHNwYXJzZSArIGRlbnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0wMSh5LCB4LCBhZGRTY2FsYXIsIHRydWUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgc3dpdGNoICh5LnN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICAgICAgLy8gZGVuc2UgKyBzcGFyc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTAxKHgsIHksIGFkZFNjYWxhciwgZmFsc2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIGRlbnNlICsgZGVuc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTEzKHgsIHksIGFkZFNjYWxhcik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG4gICAgXG4gICAgJ0FycmF5LCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gYWRkKG1hdHJpeCh4KSwgbWF0cml4KHkpKS52YWx1ZU9mKCk7XG4gICAgfSxcbiAgICBcbiAgICAnQXJyYXksIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gYWRkKG1hdHJpeCh4KSwgeSk7XG4gICAgfSxcbiAgICBcbiAgICAnTWF0cml4LCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gYWRkKHgsIG1hdHJpeCh5KSk7XG4gICAgfSxcbiAgICBcbiAgICAnTWF0cml4LCBhbnknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gcmVzdWx0XG4gICAgICB2YXIgYztcbiAgICAgIC8vIGNoZWNrIHN0b3JhZ2UgZm9ybWF0XG4gICAgICBzd2l0Y2ggKHguc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTEwKHgsIHksIGFkZFNjYWxhciwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xNCh4LCB5LCBhZGRTY2FsYXIsIGZhbHNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG4gICAgXG4gICAgJ2FueSwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHJlc3VsdFxuICAgICAgdmFyIGM7XG4gICAgICAvLyBjaGVjayBzdG9yYWdlIGZvcm1hdFxuICAgICAgc3dpdGNoICh5LnN0b3JhZ2UoKSkge1xuICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xMCh5LCB4LCBhZGRTY2FsYXIsIHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xNCh5LCB4LCBhZGRTY2FsYXIsIHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfSxcbiAgICBcbiAgICAnQXJyYXksIGFueSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gYWxnb3JpdGhtMTQobWF0cml4KHgpLCB5LCBhZGRTY2FsYXIsIGZhbHNlKS52YWx1ZU9mKCk7XG4gICAgfSxcblxuICAgICdhbnksIEFycmF5JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBhbGdvcml0aG0xNChtYXRyaXgoeSksIHgsIGFkZFNjYWxhciwgdHJ1ZSkudmFsdWVPZigpO1xuICAgIH1cbiAgfSwgYWRkU2NhbGFyLnNpZ25hdHVyZXMpKTtcblxuICBhZGQudG9UZXggPSAnXFxcXGxlZnQoJHthcmdzWzBdfScgKyBsYXRleC5vcGVyYXRvcnNbJ2FkZCddICsgJyR7YXJnc1sxXX1cXFxccmlnaHQpJztcbiAgXG4gIHJldHVybiBhZGQ7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdhZGQnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZmFjdG9yeSh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG5cbiAgLyoqXG4gICAqIEFkZCB0d28gc2NhbGFyIHZhbHVlcywgYHggKyB5YC5cbiAgICogVGhpcyBmdW5jdGlvbiBpcyBtZWFudCBmb3IgaW50ZXJuYWwgdXNlOiBpdCBpcyB1c2VkIGJ5IHRoZSBwdWJsaWMgZnVuY3Rpb25cbiAgICogYGFkZGBcbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBzdXBwb3J0IGNvbGxlY3Rpb25zIChBcnJheSBvciBNYXRyaXgpLCBhbmQgZG9lc1xuICAgKiBub3QgdmFsaWRhdGUgdGhlIG51bWJlciBvZiBvZiBpbnB1dHMuXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgQ29tcGxleCB8IFVuaXR9IHggICBGaXJzdCB2YWx1ZSB0byBhZGRcbiAgICogQHBhcmFtICB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb24gfCBDb21wbGV4fSB5ICAgICAgICAgIFNlY29uZCB2YWx1ZSB0byBhZGRcbiAgICogQHJldHVybiB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb24gfCBDb21wbGV4IHwgVW5pdH0gICAgICAgICAgICAgICAgICAgICAgU3VtIG9mIGB4YCBhbmQgYHlgXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB2YXIgYWRkID0gdHlwZWQoJ2FkZCcsIHtcblxuICAgICdudW1iZXIsIG51bWJlcic6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4geCArIHk7XG4gICAgfSxcblxuICAgICdDb21wbGV4LCBDb21wbGV4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHJldHVybiB4LmFkZCh5KTtcbiAgICB9LFxuXG4gICAgJ0JpZ051bWJlciwgQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHJldHVybiB4LnBsdXMoeSk7XG4gICAgfSxcblxuICAgICdGcmFjdGlvbiwgRnJhY3Rpb24nOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIHguYWRkKHkpO1xuICAgIH0sXG5cbiAgICAnVW5pdCwgVW5pdCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICBpZiAoeC52YWx1ZSA9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoJ1BhcmFtZXRlciB4IGNvbnRhaW5zIGEgdW5pdCB3aXRoIHVuZGVmaW5lZCB2YWx1ZScpO1xuICAgICAgaWYgKHkudmFsdWUgPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKCdQYXJhbWV0ZXIgeSBjb250YWlucyBhIHVuaXQgd2l0aCB1bmRlZmluZWQgdmFsdWUnKTtcbiAgICAgIGlmICgheC5lcXVhbEJhc2UoeSkpIHRocm93IG5ldyBFcnJvcignVW5pdHMgZG8gbm90IG1hdGNoJyk7XG5cbiAgICAgIHZhciByZXMgPSB4LmNsb25lKCk7XG4gICAgICByZXMudmFsdWUgPSBhZGQocmVzLnZhbHVlLCB5LnZhbHVlKTtcbiAgICAgIHJlcy5maXhQcmVmaXggPSBmYWxzZTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gYWRkO1xufVxuXG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVlcE1hcCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vZGVlcE1hcCcpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciB1bmFyeU1pbnVzID0gbG9hZChyZXF1aXJlKCcuL3VuYXJ5TWludXMnKSk7XG4gIHZhciBpc05lZ2F0aXZlID0gbG9hZChyZXF1aXJlKCcuLi91dGlscy9pc05lZ2F0aXZlJykpO1xuICB2YXIgbWF0cml4ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC9mdW5jdGlvbi9tYXRyaXgnKSk7XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgY3ViaWMgcm9vdCBvZiBhIHZhbHVlLlxuICAgKlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguY2JydCh4KVxuICAgKiAgICBtYXRoLmNicnQoeCwgYWxsUm9vdHMpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmNicnQoMjcpOyAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgM1xuICAgKiAgICBtYXRoLmN1YmUoMyk7ICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgMjdcbiAgICogICAgbWF0aC5jYnJ0KC02NCk7ICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIC00XG4gICAqICAgIG1hdGguY2JydChtYXRoLnVuaXQoJzI3IG1eMycpKTsgLy8gcmV0dXJucyBVbml0IDMgbVxuICAgKiAgICBtYXRoLmNicnQoWzI3LCA2NCwgMTI1XSk7ICAgICAgIC8vIHJldHVybnMgWzMsIDQsIDVdXG4gICAqXG4gICAqICAgIHZhciB4ID0gbWF0aC5jb21wbGV4KCc4aScpO1xuICAgKiAgICBtYXRoLmNicnQoeCk7ICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgQ29tcGxleCAxLjczMjA1MDgwNzU2ODkgKyBpXG4gICAqICAgIG1hdGguY2JydCh4LCB0cnVlKTsgICAgICAgICAgICAgLy8gcmV0dXJucyBNYXRyaXggW1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIDEuNzMyMDUwODA3NTY4OSArIGlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIC0xLjczMjA1MDgwNzU2ODkgKyBpXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAtMmlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBdXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBzcXVhcmUsIHNxcnQsIGN1YmVcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBDb21wbGV4IHwgVW5pdCB8IEFycmF5IHwgTWF0cml4fSB4XG4gICAqICAgICAgICAgICAgVmFsdWUgZm9yIHdoaWNoIHRvIGNhbGN1bGF0ZSB0aGUgY3ViaWMgcm9vdC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbYWxsUm9vdHNdICBPcHRpb25hbCwgZmFsc2UgYnkgZGVmYXVsdC4gT25seSBhcHBsaWNhYmxlXG4gICAqICAgICAgICAgICAgd2hlbiBgeGAgaXMgYSBudW1iZXIgb3IgY29tcGxleCBudW1iZXIuIElmIHRydWUsIGFsbCBjb21wbGV4XG4gICAqICAgICAgICAgICAgcm9vdHMgYXJlIHJldHVybmVkLCBpZiBmYWxzZSAoZGVmYXVsdCkgdGhlIHByaW5jaXBhbCByb290IGlzXG4gICAqICAgICAgICAgICAgcmV0dXJuZWQuXG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXh9XG4gICAqICAgICAgICAgICAgUmV0dXJucyB0aGUgY3ViaWMgcm9vdCBvZiBgeGBcbiAgICovXG4gIHZhciBjYnJ0ID0gdHlwZWQoJ2NicnQnLCB7XG4gICAgJ251bWJlcic6IF9jYnJ0TnVtYmVyLFxuICAgIC8vIG5vdGU6IHNpZ25hdHVyZSAnbnVtYmVyLCBib29sZWFuJyBpcyBhbHNvIHN1cHBvcnRlZCxcbiAgICAvLyAgICAgICBjcmVhdGVkIGJ5IHR5cGVkIGFzIGl0IGtub3dzIGhvdyB0byBjb252ZXJ0IG51bWJlciB0byBDb21wbGV4XG5cbiAgICAnQ29tcGxleCc6IF9jYnJ0Q29tcGxleCxcblxuICAgICdDb21wbGV4LCBib29sZWFuJzogX2NicnRDb21wbGV4LFxuXG4gICAgJ0JpZ051bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5jYnJ0KCk7XG4gICAgfSxcblxuICAgICdVbml0JzogX2NicnRVbml0LFxuXG4gICAgJ0FycmF5IHwgTWF0cml4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIC8vIGRlZXAgbWFwIGNvbGxlY3Rpb24sIHNraXAgemVyb3Mgc2luY2UgY2JydCgwKSA9IDBcbiAgICAgIHJldHVybiBkZWVwTWFwKHgsIGNicnQsIHRydWUpO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBjYnJ0IGZvciBhIG51bWJlclxuICAgKlxuICAgKiBDb2RlIGZyb20gZXM2LXNoaW0uanM6XG4gICAqICAgaHR0cHM6Ly9naXRodWIuY29tL3BhdWxtaWxsci9lczYtc2hpbS9ibG9iL21hc3Rlci9lczYtc2hpbS5qcyNMMTU2NC1MMTU3N1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgKiBAcmV0dXJucyB7bnVtYmVyIHwgQ29tcGxleH0gUmV0dXJucyB0aGUgY3ViaWMgcm9vdCBvZiB4XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfY2JydE51bWJlcih4KSB7XG4gICAgaWYgKHggPT09IDApIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH1cblxuICAgIHZhciBuZWdhdGUgPSB4IDwgMDtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGlmIChuZWdhdGUpIHtcbiAgICAgIHggPSAteDtcbiAgICB9XG5cbiAgICBpZiAoaXNGaW5pdGUoeCkpIHtcbiAgICAgIHJlc3VsdCA9IE1hdGguZXhwKE1hdGgubG9nKHgpIC8gMyk7XG4gICAgICAvLyBmcm9tIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ3ViZV9yb290I051bWVyaWNhbF9tZXRob2RzXG4gICAgICByZXN1bHQgPSAoeCAvIChyZXN1bHQgKiByZXN1bHQpICsgKDIgKiByZXN1bHQpKSAvIDM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IHg7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5lZ2F0ZSA/IC1yZXN1bHQgOiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBjdWJpYyByb290IGZvciBhIGNvbXBsZXggbnVtYmVyXG4gICAqIEBwYXJhbSB7Q29tcGxleH0geFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthbGxSb290c10gICBJZiB0cnVlLCB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gYW4gYXJyYXlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCBhbGwgdGhyZWUgcm9vdHMuIElmIGZhbHNlIG9yIHVuZGVmaW5lZCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHByaW5jaXBhbCByb290IGlzIHJldHVybmVkLlxuICAgKiBAcmV0dXJucyB7Q29tcGxleCB8IEFycmF5LjxDb21wbGV4PiB8IE1hdHJpeC48Q29tcGxleD59IFJldHVybnMgdGhlIGN1YmljIHJvb3Qocykgb2YgeFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX2NicnRDb21wbGV4KHgsIGFsbFJvb3RzKSB7XG4gICAgLy8gaHR0cHM6Ly93d3cud2lraXdhbmQuY29tL2VuL0N1YmVfcm9vdCMvQ29tcGxleF9udW1iZXJzXG5cbiAgICB2YXIgYXJnXzMgPSB4LmFyZygpIC8gMztcbiAgICB2YXIgYWJzID0geC5hYnMoKTtcblxuICAgIC8vIHByaW5jaXBhbCByb290OlxuICAgIHZhciBwcmluY2lwYWwgPSBuZXcgdHlwZS5Db21wbGV4KF9jYnJ0TnVtYmVyKGFicyksIDApLm11bChcbiAgICAgICAgbmV3IHR5cGUuQ29tcGxleCgwLCBhcmdfMykuZXhwKCkpO1xuXG4gICAgaWYgKGFsbFJvb3RzKSB7XG4gICAgICB2YXIgYWxsID0gW1xuICAgICAgICAgIHByaW5jaXBhbCxcbiAgICAgICAgICBuZXcgdHlwZS5Db21wbGV4KF9jYnJ0TnVtYmVyKGFicyksIDApLm11bChcbiAgICAgICAgICAgIG5ldyB0eXBlLkNvbXBsZXgoMCwgYXJnXzMgKyBNYXRoLlBJICogMiAvIDMpLmV4cCgpKSxcbiAgICAgICAgICBuZXcgdHlwZS5Db21wbGV4KF9jYnJ0TnVtYmVyKGFicyksIDApLm11bChcbiAgICAgICAgICAgIG5ldyB0eXBlLkNvbXBsZXgoMCwgYXJnXzMgLSBNYXRoLlBJICogMiAvIDMpLmV4cCgpKVxuICAgICAgXTtcblxuICAgICAgcmV0dXJuIChjb25maWcubWF0cml4ID09PSAnQXJyYXknKSA/IGFsbCA6IG1hdHJpeChhbGwpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBwcmluY2lwYWw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgY3ViaWMgcm9vdCBmb3IgYSBVbml0XG4gICAqIEBwYXJhbSB7VW5pdH0geFxuICAgKiBAcmV0dXJuIHtVbml0fSBSZXR1cm5zIHRoZSBjdWJpYyByb290IG9mIHhcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9jYnJ0VW5pdCh4KSB7XG4gICAgaWYoeC52YWx1ZSAmJiB4LnZhbHVlLmlzQ29tcGxleCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHguY2xvbmUoKTtcbiAgICAgIHJlc3VsdC52YWx1ZSA9IDEuMDtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5wb3coMS4wLzMpOyAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgdW5pdHNcbiAgICAgIHJlc3VsdC52YWx1ZSA9IF9jYnJ0Q29tcGxleCh4LnZhbHVlKTsgLy8gQ29tcHV0ZSB0aGUgdmFsdWVcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIG5lZ2F0ZSA9IGlzTmVnYXRpdmUoeC52YWx1ZSk7XG4gICAgICBpZiAobmVnYXRlKSB7XG4gICAgICAgIHgudmFsdWUgPSB1bmFyeU1pbnVzKHgudmFsdWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBUT0RPOiBjcmVhdGUgYSBoZWxwZXIgZnVuY3Rpb24gZm9yIHRoaXNcbiAgICAgIHZhciB0aGlyZDtcbiAgICAgIGlmICh4LnZhbHVlICYmIHgudmFsdWUuaXNCaWdOdW1iZXIpIHtcbiAgICAgICAgdGhpcmQgPSBuZXcgdHlwZS5CaWdOdW1iZXIoMSkuZGl2KDMpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoeC52YWx1ZSAmJiB4LnZhbHVlLmlzRnJhY3Rpb24pIHtcbiAgICAgICAgdGhpcmQgPSBuZXcgdHlwZS5GcmFjdGlvbigxLCAzKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlyZCA9IDEvMztcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IHgucG93KHRoaXJkKTtcblxuICAgICAgaWYgKG5lZ2F0ZSkge1xuICAgICAgICByZXN1bHQudmFsdWUgPSB1bmFyeU1pbnVzKHJlc3VsdC52YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgY2JydC50b1RleCA9ICdcXFxcc3FydFszXXske2FyZ3NbMF19fSc7XG5cbiAgcmV0dXJuIGNicnQ7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdjYnJ0JztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWVwTWFwID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9kZWVwTWFwJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgLyoqXG4gICAqIFJvdW5kIGEgdmFsdWUgdG93YXJkcyBwbHVzIGluZmluaXR5XG4gICAqIElmIGB4YCBpcyBjb21wbGV4LCBib3RoIHJlYWwgYW5kIGltYWdpbmFyeSBwYXJ0IGFyZSByb3VuZGVkIHRvd2FyZHMgcGx1cyBpbmZpbml0eS5cbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmNlaWwoeClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGguY2VpbCgzLjIpOyAgICAgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIDRcbiAgICogICAgbWF0aC5jZWlsKDMuOCk7ICAgICAgICAgICAgICAgLy8gcmV0dXJucyBudW1iZXIgNFxuICAgKiAgICBtYXRoLmNlaWwoLTQuMik7ICAgICAgICAgICAgICAvLyByZXR1cm5zIG51bWJlciAtNFxuICAgKiAgICBtYXRoLmNlaWwoLTQuNyk7ICAgICAgICAgICAgICAvLyByZXR1cm5zIG51bWJlciAtNFxuICAgKlxuICAgKiAgICB2YXIgYyA9IG1hdGguY29tcGxleCgzLjIsIC0yLjcpO1xuICAgKiAgICBtYXRoLmNlaWwoYyk7ICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIENvbXBsZXggNCAtIDJpXG4gICAqXG4gICAqICAgIG1hdGguY2VpbChbMy4yLCAzLjgsIC00LjddKTsgIC8vIHJldHVybnMgQXJyYXkgWzQsIDQsIC00XVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgZmxvb3IsIGZpeCwgcm91bmRcbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb24gfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9IHggIE51bWJlciB0byBiZSByb3VuZGVkXG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSBSb3VuZGVkIHZhbHVlXG4gICAqL1xuICB2YXIgY2VpbCA9IHR5cGVkKCdjZWlsJywge1xuICAgICdudW1iZXInOiBNYXRoLmNlaWwsXG5cbiAgICAnQ29tcGxleCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5jZWlsKCk7XG4gICAgfSxcblxuICAgICdCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHguY2VpbCgpO1xuICAgIH0sXG5cbiAgICAnRnJhY3Rpb24nOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHguY2VpbCgpO1xuICAgIH0sXG5cbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgLy8gZGVlcCBtYXAgY29sbGVjdGlvbiwgc2tpcCB6ZXJvcyBzaW5jZSBjZWlsKDApID0gMFxuICAgICAgcmV0dXJuIGRlZXBNYXAoeCwgY2VpbCwgdHJ1ZSk7XG4gICAgfVxuICB9KTtcblxuICBjZWlsLnRvVGV4ID0gJ1xcXFxsZWZ0XFxcXGxjZWlsJHthcmdzWzBdfVxcXFxyaWdodFxcXFxyY2VpbCc7XG5cbiAgcmV0dXJuIGNlaWw7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdjZWlsJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWVwTWFwID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9kZWVwTWFwJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcblxuICAvKipcbiAgICogQ29tcHV0ZSB0aGUgY3ViZSBvZiBhIHZhbHVlLCBgeCAqIHggKiB4YC5cbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmN1YmUoeClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGguY3ViZSgyKTsgICAgICAgICAgICAvLyByZXR1cm5zIG51bWJlciA4XG4gICAqICAgIG1hdGgucG93KDIsIDMpOyAgICAgICAgICAvLyByZXR1cm5zIG51bWJlciA4XG4gICAqICAgIG1hdGguY3ViZSg0KTsgICAgICAgICAgICAvLyByZXR1cm5zIG51bWJlciA2NFxuICAgKiAgICA0ICogNCAqIDQ7ICAgICAgICAgICAgICAgLy8gcmV0dXJucyBudW1iZXIgNjRcbiAgICpcbiAgICogICAgbWF0aC5jdWJlKFsxLCAyLCAzLCA0XSk7IC8vIHJldHVybnMgQXJyYXkgWzEsIDgsIDI3LCA2NF1cbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIG11bHRpcGx5LCBzcXVhcmUsIHBvdywgY2JydFxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeCB8IFVuaXR9IHggIE51bWJlciBmb3Igd2hpY2ggdG8gY2FsY3VsYXRlIHRoZSBjdWJlXG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4IHwgVW5pdH0gQ3ViZSBvZiB4XG4gICAqL1xuICB2YXIgY3ViZSA9IHR5cGVkKCdjdWJlJywge1xuICAgICdudW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHggKiB4ICogeDtcbiAgICB9LFxuXG4gICAgJ0NvbXBsZXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHgubXVsKHgpLm11bCh4KTsgLy8gSXMgZmFzdGVyIHRoYW4gcG93KHgsIDMpXG4gICAgfSxcblxuICAgICdCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHgudGltZXMoeCkudGltZXMoeCk7XG4gICAgfSxcblxuICAgICdGcmFjdGlvbic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5wb3coMyk7IC8vIElzIGZhc3RlciB0aGFuIG11bCgpbXVsKCltdWwoKVxuICAgIH0sXG5cbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgLy8gZGVlcCBtYXAgY29sbGVjdGlvbiwgc2tpcCB6ZXJvcyBzaW5jZSBjdWJlKDApID0gMFxuICAgICAgcmV0dXJuIGRlZXBNYXAoeCwgY3ViZSwgdHJ1ZSk7XG4gICAgfSxcblxuICAgICdVbml0JzogZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHgucG93KDMpO1xuICAgIH1cbiAgfSk7XG5cbiAgY3ViZS50b1RleCA9ICdcXFxcbGVmdCgke2FyZ3NbMF19XFxcXHJpZ2h0KV4zJztcblxuICByZXR1cm4gY3ViZTtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2N1YmUnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdCcpLmV4dGVuZDtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuXG4gIHZhciBkaXZpZGVTY2FsYXIgPSBsb2FkKHJlcXVpcmUoJy4vZGl2aWRlU2NhbGFyJykpO1xuICB2YXIgbXVsdGlwbHkgICAgID0gbG9hZChyZXF1aXJlKCcuL211bHRpcGx5JykpO1xuICB2YXIgaW52ICAgICAgICAgID0gbG9hZChyZXF1aXJlKCcuLi9tYXRyaXgvaW52JykpO1xuICB2YXIgbWF0cml4ICAgICAgID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC9mdW5jdGlvbi9tYXRyaXgnKSk7XG5cbiAgdmFyIGFsZ29yaXRobTExID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xMScpKTtcbiAgdmFyIGFsZ29yaXRobTE0ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xNCcpKTtcbiAgXG4gIC8qKlxuICAgKiBEaXZpZGUgdHdvIHZhbHVlcywgYHggLyB5YC5cbiAgICogVG8gZGl2aWRlIG1hdHJpY2VzLCBgeGAgaXMgbXVsdGlwbGllZCB3aXRoIHRoZSBpbnZlcnNlIG9mIGB5YDogYHggKiBpbnYoeSlgLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguZGl2aWRlKHgsIHkpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmRpdmlkZSgyLCAzKTsgICAgICAgICAgICAvLyByZXR1cm5zIG51bWJlciAwLjY2NjY2NjY2NjY2NjY2NjZcbiAgICpcbiAgICogICAgdmFyIGEgPSBtYXRoLmNvbXBsZXgoNSwgMTQpO1xuICAgKiAgICB2YXIgYiA9IG1hdGguY29tcGxleCg0LCAxKTtcbiAgICogICAgbWF0aC5kaXZpZGUoYSwgYik7ICAgICAgICAgICAgLy8gcmV0dXJucyBDb21wbGV4IDIgKyAzaVxuICAgKlxuICAgKiAgICB2YXIgYyA9IFtbNywgLTZdLCBbMTMsIC00XV07XG4gICAqICAgIHZhciBkID0gW1sxLCAyXSwgWzQsIDNdXTtcbiAgICogICAgbWF0aC5kaXZpZGUoYywgZCk7ICAgICAgICAgICAgLy8gcmV0dXJucyBBcnJheSBbWy05LCA0XSwgWy0xMSwgNl1dXG4gICAqXG4gICAqICAgIHZhciBlID0gbWF0aC51bml0KCcxOCBrbScpO1xuICAgKiAgICBtYXRoLmRpdmlkZShlLCA0LjUpOyAgICAgICAgICAvLyByZXR1cm5zIFVuaXQgNCBrbVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgbXVsdGlwbHlcbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb24gfCBDb21wbGV4IHwgVW5pdCB8IEFycmF5IHwgTWF0cml4fSB4ICAgTnVtZXJhdG9yXG4gICAqIEBwYXJhbSAge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSB5ICAgICAgICAgIERlbm9taW5hdG9yXG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeH0gICAgICAgICAgICAgICAgICAgICAgUXVvdGllbnQsIGB4IC8geWBcbiAgICovXG4gIHZhciBkaXZpZGUgPSB0eXBlZCgnZGl2aWRlJywgZXh0ZW5kKHtcbiAgICAvLyB3ZSBleHRlbmQgdGhlIHNpZ25hdHVyZXMgb2YgZGl2aWRlU2NhbGFyIHdpdGggc2lnbmF0dXJlcyBkZWFsaW5nIHdpdGggbWF0cmljZXNcblxuICAgICdBcnJheSB8IE1hdHJpeCwgQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gVE9ETzogaW1wbGVtZW50IG1hdHJpeCByaWdodCBkaXZpc2lvbiB1c2luZyBwc2V1ZG8gaW52ZXJzZVxuICAgICAgLy8gaHR0cDovL3d3dy5tYXRod29ya3MubmwvaGVscC9tYXRsYWIvcmVmL21yZGl2aWRlLmh0bWxcbiAgICAgIC8vIGh0dHA6Ly93d3cuZ251Lm9yZy9zb2Z0d2FyZS9vY3RhdmUvZG9jL2ludGVycHJldGVyL0FyaXRobWV0aWMtT3BzLmh0bWxcbiAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTIyNjM5MzIvaG93LWRvZXMtZ251LW9jdGF2ZS1tYXRyaXgtZGl2aXNpb24td29yay1nZXR0aW5nLXVuZXhwZWN0ZWQtYmVoYXZpb3VyXG4gICAgICByZXR1cm4gbXVsdGlwbHkoeCwgaW52KHkpKTtcbiAgICB9LFxuXG4gICAgJ01hdHJpeCwgYW55JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHJlc3VsdFxuICAgICAgdmFyIGM7XG5cbiAgICAgIC8vIHByb2Nlc3Mgc3RvcmFnZSBmb3JtYXRcbiAgICAgIHN3aXRjaCAoeC5zdG9yYWdlKCkpIHtcbiAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTEoeCwgeSwgZGl2aWRlU2NhbGFyLCBmYWxzZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2RlbnNlJzpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTQoeCwgeSwgZGl2aWRlU2NhbGFyLCBmYWxzZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuICAgIFxuICAgICdBcnJheSwgYW55JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBhbGdvcml0aG0xNChtYXRyaXgoeCksIHksIGRpdmlkZVNjYWxhciwgZmFsc2UpLnZhbHVlT2YoKTtcbiAgICB9LFxuXG4gICAgJ2FueSwgQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIG11bHRpcGx5KHgsIGludih5KSk7XG4gICAgfVxuICB9LCBkaXZpZGVTY2FsYXIuc2lnbmF0dXJlcykpO1xuXG4gIGRpdmlkZS50b1RleCA9ICdcXFxcZnJhY3ske2FyZ3NbMF19fXske2FyZ3NbMV19fSc7XG5cbiAgcmV0dXJuIGRpdmlkZTtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2RpdmlkZSc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBmYWN0b3J5KHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIG11bHRpcGx5U2NhbGFyID0gbG9hZChyZXF1aXJlKCcuL211bHRpcGx5U2NhbGFyJykpO1xuXG4gIC8qKlxuICAgKiBEaXZpZGUgdHdvIHNjYWxhciB2YWx1ZXMsIGB4IC8geWAuXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgbWVhbnQgZm9yIGludGVybmFsIHVzZTogaXQgaXMgdXNlZCBieSB0aGUgcHVibGljIGZ1bmN0aW9uc1xuICAgKiBgZGl2aWRlYCBhbmQgYGludmAuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3Qgc3VwcG9ydCBjb2xsZWN0aW9ucyAoQXJyYXkgb3IgTWF0cml4KSwgYW5kIGRvZXNcbiAgICogbm90IHZhbGlkYXRlIHRoZSBudW1iZXIgb2Ygb2YgaW5wdXRzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IENvbXBsZXggfCBVbml0fSB4ICAgTnVtZXJhdG9yXG4gICAqIEBwYXJhbSAge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgQ29tcGxleH0geSAgICAgICAgICBEZW5vbWluYXRvclxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IENvbXBsZXggfCBVbml0fSAgICAgICAgICAgICAgICAgICAgICBRdW90aWVudCwgYHggLyB5YFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdmFyIGRpdmlkZVNjYWxhciA9IHR5cGVkKCdkaXZpZGUnLCB7XG4gICAgJ251bWJlciwgbnVtYmVyJzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHJldHVybiB4IC8geTtcbiAgICB9LFxuXG4gICAgJ0NvbXBsZXgsIENvbXBsZXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIHguZGl2KHkpO1xuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyLCBCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIHguZGl2KHkpO1xuICAgIH0sXG5cbiAgICAnRnJhY3Rpb24sIEZyYWN0aW9uJzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHJldHVybiB4LmRpdih5KTtcbiAgICB9LFxuXG4gICAgJ1VuaXQsIG51bWJlciB8IEZyYWN0aW9uIHwgQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHZhciByZXMgPSB4LmNsb25lKCk7XG4gICAgICAvLyBUT0RPOiBtb3ZlIHRoZSBkaXZpZGUgZnVuY3Rpb24gdG8gVW5pdC5qcywgaXQgdXNlcyBpbnRlcm5hbHMgb2YgVW5pdFxuICAgICAgcmVzLnZhbHVlID0gZGl2aWRlU2NhbGFyKCgocmVzLnZhbHVlID09PSBudWxsKSA/IHJlcy5fbm9ybWFsaXplKDEpIDogcmVzLnZhbHVlKSwgeSk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG5cbiAgICAnbnVtYmVyIHwgRnJhY3Rpb24gfCBCaWdOdW1iZXIsIFVuaXQnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgdmFyIHJlcyA9IHkucG93KC0xKTtcbiAgICAgIC8vIFRPRE86IG1vdmUgdGhlIGRpdmlkZSBmdW5jdGlvbiB0byBVbml0LmpzLCBpdCB1c2VzIGludGVybmFscyBvZiBVbml0XG4gICAgICByZXMudmFsdWUgPSBtdWx0aXBseVNjYWxhcigoKHJlcy52YWx1ZSA9PT0gbnVsbCkgPyByZXMuX25vcm1hbGl6ZSgxKSA6IHJlcy52YWx1ZSksIHgpO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuXG4gICAgJ1VuaXQsIFVuaXQnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIHguZGl2aWRlKHkpO1xuICAgIH1cblxuICB9KTtcblxuICByZXR1cm4gZGl2aWRlU2NhbGFyO1xufVxuXG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG5cbiAgdmFyIG1hdHJpeCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvZnVuY3Rpb24vbWF0cml4JykpO1xuICB2YXIgZGl2aWRlU2NhbGFyID0gbG9hZChyZXF1aXJlKCcuL2RpdmlkZVNjYWxhcicpKTtcbiAgdmFyIGxhdGV4ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbGF0ZXgnKTtcbiAgXG4gIHZhciBhbGdvcml0aG0wMiA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMDInKSk7XG4gIHZhciBhbGdvcml0aG0wMyA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMDMnKSk7XG4gIHZhciBhbGdvcml0aG0wNyA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMDcnKSk7XG4gIHZhciBhbGdvcml0aG0xMSA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMTEnKSk7XG4gIHZhciBhbGdvcml0aG0xMiA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMTInKSk7XG4gIHZhciBhbGdvcml0aG0xMyA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMTMnKSk7XG4gIHZhciBhbGdvcml0aG0xNCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMTQnKSk7XG5cbiAgLyoqXG4gICAqIERpdmlkZSB0d28gbWF0cmljZXMgZWxlbWVudCB3aXNlLiBUaGUgZnVuY3Rpb24gYWNjZXB0cyBib3RoIG1hdHJpY2VzIGFuZFxuICAgKiBzY2FsYXIgdmFsdWVzLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguZG90RGl2aWRlKHgsIHkpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmRvdERpdmlkZSgyLCA0KTsgICAvLyByZXR1cm5zIDAuNVxuICAgKlxuICAgKiAgICBhID0gW1s5LCA1XSwgWzYsIDFdXTtcbiAgICogICAgYiA9IFtbMywgMl0sIFs1LCAyXV07XG4gICAqXG4gICAqICAgIG1hdGguZG90RGl2aWRlKGEsIGIpOyAgIC8vIHJldHVybnMgW1szLCAyLjVdLCBbMS4yLCAwLjVdXVxuICAgKiAgICBtYXRoLmRpdmlkZShhLCBiKTsgICAgICAvLyByZXR1cm5zIFtbMS43NSwgMC43NV0sIFstMS43NSwgMi4yNV1dXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBkaXZpZGUsIG11bHRpcGx5LCBkb3RNdWx0aXBseVxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXh9IHggTnVtZXJhdG9yXG4gICAqIEBwYXJhbSAge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeH0geSBEZW5vbWluYXRvclxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXh9ICAgICAgICAgICAgICAgICAgICBRdW90aWVudCwgYHggLi8geWBcbiAgICovXG4gIHZhciBkb3REaXZpZGUgPSB0eXBlZCgnZG90RGl2aWRlJywge1xuICAgIFxuICAgICdhbnksIGFueSc6IGRpdmlkZVNjYWxhcixcbiAgICBcbiAgICAnTWF0cml4LCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gcmVzdWx0XG4gICAgICB2YXIgYztcblxuICAgICAgLy8gcHJvY2VzcyBtYXRyaXggc3RvcmFnZVxuICAgICAgc3dpdGNoICh4LnN0b3JhZ2UoKSkge1xuICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgICAgIC8vIHNwYXJzZSAuLyBzcGFyc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTA3KHgsIHksIGRpdmlkZVNjYWxhciwgZmFsc2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIHNwYXJzZSAuLyBkZW5zZVxuICAgICAgICAgICAgICBjID0gYWxnb3JpdGhtMDIoeSwgeCwgZGl2aWRlU2NhbGFyLCB0cnVlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgICAgIC8vIGRlbnNlIC4vIHNwYXJzZVxuICAgICAgICAgICAgICBjID0gYWxnb3JpdGhtMDMoeCwgeSwgZGl2aWRlU2NhbGFyLCBmYWxzZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgLy8gZGVuc2UgLi8gZGVuc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTEzKHgsIHksIGRpdmlkZVNjYWxhcik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG5cbiAgICAnQXJyYXksIEFycmF5JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBkb3REaXZpZGUobWF0cml4KHgpLCBtYXRyaXgoeSkpLnZhbHVlT2YoKTtcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGRvdERpdmlkZShtYXRyaXgoeCksIHkpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4LCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gZG90RGl2aWRlKHgsIG1hdHJpeCh5KSk7XG4gICAgfSxcblxuICAgICdNYXRyaXgsIGFueSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuICAgICAgLy8gY2hlY2sgc3RvcmFnZSBmb3JtYXRcbiAgICAgIHN3aXRjaCAoeC5zdG9yYWdlKCkpIHtcbiAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTEoeCwgeSwgZGl2aWRlU2NhbGFyLCBmYWxzZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTE0KHgsIHksIGRpdmlkZVNjYWxhciwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfSxcblxuICAgICdhbnksIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuICAgICAgLy8gY2hlY2sgc3RvcmFnZSBmb3JtYXRcbiAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTIoeSwgeCwgZGl2aWRlU2NhbGFyLCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTQoeSwgeCwgZGl2aWRlU2NhbGFyLCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG5cbiAgICAnQXJyYXksIGFueSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gYWxnb3JpdGhtMTQobWF0cml4KHgpLCB5LCBkaXZpZGVTY2FsYXIsIGZhbHNlKS52YWx1ZU9mKCk7XG4gICAgfSxcblxuICAgICdhbnksIEFycmF5JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBhbGdvcml0aG0xNChtYXRyaXgoeSksIHgsIGRpdmlkZVNjYWxhciwgdHJ1ZSkudmFsdWVPZigpO1xuICAgIH1cbiAgfSk7XG5cbiAgZG90RGl2aWRlLnRvVGV4ID0gJ1xcXFxsZWZ0KCR7YXJnc1swXX0nICsgbGF0ZXgub3BlcmF0b3JzWydkb3REaXZpZGUnXSArICcke2FyZ3NbMV19XFxcXHJpZ2h0KSc7XG4gIFxuICByZXR1cm4gZG90RGl2aWRlO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnZG90RGl2aWRlJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcblxuICB2YXIgbWF0cml4ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC9mdW5jdGlvbi9tYXRyaXgnKSk7XG4gIHZhciBtdWx0aXBseVNjYWxhciA9IGxvYWQocmVxdWlyZSgnLi9tdWx0aXBseVNjYWxhcicpKTtcbiAgdmFyIGxhdGV4ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbGF0ZXgnKTtcblxuICB2YXIgYWxnb3JpdGhtMDIgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTAyJykpO1xuICB2YXIgYWxnb3JpdGhtMDkgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTA5JykpO1xuICB2YXIgYWxnb3JpdGhtMTEgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTExJykpO1xuICB2YXIgYWxnb3JpdGhtMTMgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTEzJykpO1xuICB2YXIgYWxnb3JpdGhtMTQgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTE0JykpO1xuXG4gIC8qKlxuICAgKiBNdWx0aXBseSB0d28gbWF0cmljZXMgZWxlbWVudCB3aXNlLiBUaGUgZnVuY3Rpb24gYWNjZXB0cyBib3RoIG1hdHJpY2VzIGFuZFxuICAgKiBzY2FsYXIgdmFsdWVzLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguZG90TXVsdGlwbHkoeCwgeSlcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGguZG90TXVsdGlwbHkoMiwgNCk7IC8vIHJldHVybnMgOFxuICAgKlxuICAgKiAgICBhID0gW1s5LCA1XSwgWzYsIDFdXTtcbiAgICogICAgYiA9IFtbMywgMl0sIFs1LCAyXV07XG4gICAqXG4gICAqICAgIG1hdGguZG90TXVsdGlwbHkoYSwgYik7IC8vIHJldHVybnMgW1syNywgMTBdLCBbMzAsIDJdXVxuICAgKiAgICBtYXRoLm11bHRpcGx5KGEsIGIpOyAgICAvLyByZXR1cm5zIFtbNTIsIDI4XSwgWzIzLCAxNF1dXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBtdWx0aXBseSwgZGl2aWRlLCBkb3REaXZpZGVcbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb24gfCBDb21wbGV4IHwgVW5pdCB8IEFycmF5IHwgTWF0cml4fSB4IExlZnQgaGFuZCB2YWx1ZVxuICAgKiBAcGFyYW0gIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXh9IHkgUmlnaHQgaGFuZCB2YWx1ZVxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXh9ICAgICAgICAgICAgICAgICAgICBNdWx0aXBsaWNhdGlvbiBvZiBgeGAgYW5kIGB5YFxuICAgKi9cbiAgdmFyIGRvdE11bHRpcGx5ID0gdHlwZWQoJ2RvdE11bHRpcGx5Jywge1xuICAgIFxuICAgICdhbnksIGFueSc6IG11bHRpcGx5U2NhbGFyLFxuICAgIFxuICAgICdNYXRyaXgsIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuXG4gICAgICAvLyBwcm9jZXNzIG1hdHJpeCBzdG9yYWdlXG4gICAgICBzd2l0Y2ggKHguc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgc3dpdGNoICh5LnN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICAgICAgLy8gc3BhcnNlIC4qIHNwYXJzZVxuICAgICAgICAgICAgICBjID0gYWxnb3JpdGhtMDkoeCwgeSwgbXVsdGlwbHlTY2FsYXIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAvLyBzcGFyc2UgLiogZGVuc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTAyKHksIHgsIG11bHRpcGx5U2NhbGFyLCB0cnVlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgICAgIC8vIGRlbnNlIC4qIHNwYXJzZVxuICAgICAgICAgICAgICBjID0gYWxnb3JpdGhtMDIoeCwgeSwgbXVsdGlwbHlTY2FsYXIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAvLyBkZW5zZSAuKiBkZW5zZVxuICAgICAgICAgICAgICBjID0gYWxnb3JpdGhtMTMoeCwgeSwgbXVsdGlwbHlTY2FsYXIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuICAgIFxuICAgICdBcnJheSwgQXJyYXknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGRvdE11bHRpcGx5KG1hdHJpeCh4KSwgbWF0cml4KHkpKS52YWx1ZU9mKCk7XG4gICAgfSxcbiAgICBcbiAgICAnQXJyYXksIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gZG90TXVsdGlwbHkobWF0cml4KHgpLCB5KTtcbiAgICB9LFxuXG4gICAgJ01hdHJpeCwgQXJyYXknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGRvdE11bHRpcGx5KHgsIG1hdHJpeCh5KSk7XG4gICAgfSxcblxuICAgICdNYXRyaXgsIGFueSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuICAgICAgLy8gY2hlY2sgc3RvcmFnZSBmb3JtYXRcbiAgICAgIHN3aXRjaCAoeC5zdG9yYWdlKCkpIHtcbiAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTEoeCwgeSwgbXVsdGlwbHlTY2FsYXIsIGZhbHNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTQoeCwgeSwgbXVsdGlwbHlTY2FsYXIsIGZhbHNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG5cbiAgICAnYW55LCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gcmVzdWx0XG4gICAgICB2YXIgYztcbiAgICAgIC8vIGNoZWNrIHN0b3JhZ2UgZm9ybWF0XG4gICAgICBzd2l0Y2ggKHkuc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTExKHksIHgsIG11bHRpcGx5U2NhbGFyLCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTQoeSwgeCwgbXVsdGlwbHlTY2FsYXIsIHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfSxcblxuICAgICdBcnJheSwgYW55JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBhbGdvcml0aG0xNChtYXRyaXgoeCksIHksIG11bHRpcGx5U2NhbGFyLCBmYWxzZSkudmFsdWVPZigpO1xuICAgIH0sXG5cbiAgICAnYW55LCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gYWxnb3JpdGhtMTQobWF0cml4KHkpLCB4LCBtdWx0aXBseVNjYWxhciwgdHJ1ZSkudmFsdWVPZigpO1xuICAgIH1cbiAgfSk7XG5cbiAgZG90TXVsdGlwbHkudG9UZXggPSAnXFxcXGxlZnQoJHthcmdzWzBdfScgKyBsYXRleC5vcGVyYXRvcnNbJ2RvdE11bHRpcGx5J10gKyAnJHthcmdzWzFdfVxcXFxyaWdodCknO1xuICBcbiAgcmV0dXJuIGRvdE11bHRpcGx5O1xufVxuXG5leHBvcnRzLm5hbWUgPSAnZG90TXVsdGlwbHknO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuXG4gIHZhciBtYXRyaXggPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L2Z1bmN0aW9uL21hdHJpeCcpKTtcbiAgdmFyIHBvdyA9IGxvYWQocmVxdWlyZSgnLi9wb3cnKSk7XG4gIHZhciBsYXRleCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2xhdGV4Jyk7XG5cbiAgdmFyIGFsZ29yaXRobTAzID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0wMycpKTtcbiAgdmFyIGFsZ29yaXRobTA3ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0wNycpKTtcbiAgdmFyIGFsZ29yaXRobTExID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xMScpKTtcbiAgdmFyIGFsZ29yaXRobTEyID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xMicpKTtcbiAgdmFyIGFsZ29yaXRobTEzID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xMycpKTtcbiAgdmFyIGFsZ29yaXRobTE0ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xNCcpKTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgcG93ZXIgb2YgeCB0byB5IGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmRvdFBvdyh4LCB5KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5kb3RQb3coMiwgMyk7ICAgICAgICAgICAgLy8gcmV0dXJucyBudW1iZXIgOFxuICAgKlxuICAgKiAgICB2YXIgYSA9IFtbMSwgMl0sIFs0LCAzXV07XG4gICAqICAgIG1hdGguZG90UG93KGEsIDIpOyAgICAgICAgICAgIC8vIHJldHVybnMgQXJyYXkgW1sxLCA0XSwgWzE2LCA5XV1cbiAgICogICAgbWF0aC5wb3coYSwgMik7ICAgICAgICAgICAgICAgLy8gcmV0dXJucyBBcnJheSBbWzksIDhdLCBbMTYsIDE3XV1cbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIHBvdywgc3FydCwgbXVsdGlwbHlcbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeH0geCAgVGhlIGJhc2VcbiAgICogQHBhcmFtICB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeH0geSAgVGhlIGV4cG9uZW50XG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXh9ICAgICAgICAgICAgICAgICAgICAgVGhlIHZhbHVlIG9mIGB4YCB0byB0aGUgcG93ZXIgYHlgXG4gICAqL1xuICB2YXIgZG90UG93ID0gdHlwZWQoJ2RvdFBvdycsIHtcbiAgICBcbiAgICAnYW55LCBhbnknOiBwb3csXG4gICAgXG4gICAgJ01hdHJpeCwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHJlc3VsdFxuICAgICAgdmFyIGM7XG5cbiAgICAgIC8vIHByb2Nlc3MgbWF0cml4IHN0b3JhZ2VcbiAgICAgIHN3aXRjaCAoeC5zdG9yYWdlKCkpIHtcbiAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICBzd2l0Y2ggKHkuc3RvcmFnZSgpKSB7XG4gICAgICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgICAgICAvLyBzcGFyc2UgLl4gc3BhcnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0wNyh4LCB5LCBwb3csIGZhbHNlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAvLyBzcGFyc2UgLl4gZGVuc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTAzKHksIHgsIHBvdywgdHJ1ZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBzd2l0Y2ggKHkuc3RvcmFnZSgpKSB7XG4gICAgICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgICAgICAvLyBkZW5zZSAuXiBzcGFyc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTAzKHgsIHksIHBvdywgZmFsc2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIGRlbnNlIC5eIGRlbnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0xMyh4LCB5LCBwb3cpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gZG90UG93KG1hdHJpeCh4KSwgbWF0cml4KHkpKS52YWx1ZU9mKCk7XG4gICAgfSxcblxuICAgICdBcnJheSwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBkb3RQb3cobWF0cml4KHgpLCB5KTtcbiAgICB9LFxuXG4gICAgJ01hdHJpeCwgQXJyYXknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGRvdFBvdyh4LCBtYXRyaXgoeSkpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4LCBhbnknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gcmVzdWx0XG4gICAgICB2YXIgYztcbiAgICAgIC8vIGNoZWNrIHN0b3JhZ2UgZm9ybWF0XG4gICAgICBzd2l0Y2ggKHguc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTExKHgsIHksIGRvdFBvdywgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xNCh4LCB5LCBkb3RQb3csIGZhbHNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG5cbiAgICAnYW55LCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gcmVzdWx0XG4gICAgICB2YXIgYztcbiAgICAgIC8vIGNoZWNrIHN0b3JhZ2UgZm9ybWF0XG4gICAgICBzd2l0Y2ggKHkuc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTEyKHksIHgsIGRvdFBvdywgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTE0KHksIHgsIGRvdFBvdywgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBhbnknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGFsZ29yaXRobTE0KG1hdHJpeCh4KSwgeSwgZG90UG93LCBmYWxzZSkudmFsdWVPZigpO1xuICAgIH0sXG5cbiAgICAnYW55LCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gYWxnb3JpdGhtMTQobWF0cml4KHkpLCB4LCBkb3RQb3csIHRydWUpLnZhbHVlT2YoKTtcbiAgICB9XG4gIH0pO1xuXG4gIGRvdFBvdy50b1RleCA9ICdcXFxcbGVmdCgke2FyZ3NbMF19JyArIGxhdGV4Lm9wZXJhdG9yc1snZG90UG93J10gKyAnJHthcmdzWzFdfVxcXFxyaWdodCknO1xuICBcbiAgcmV0dXJuIGRvdFBvdztcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2RvdFBvdyc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVlcE1hcCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vZGVlcE1hcCcpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGV4cG9uZW50IG9mIGEgdmFsdWUuXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5leHAoeClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGguZXhwKDIpOyAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIDcuMzg5MDU2MDk4OTMwNjQ5NVxuICAgKiAgICBtYXRoLnBvdyhtYXRoLmUsIDIpOyAgICAgICAgICAvLyByZXR1cm5zIG51bWJlciA3LjM4OTA1NjA5ODkzMDY0OTVcbiAgICogICAgbWF0aC5sb2cobWF0aC5leHAoMikpOyAgICAgICAgLy8gcmV0dXJucyBudW1iZXIgMlxuICAgKlxuICAgKiAgICBtYXRoLmV4cChbMSwgMiwgM10pO1xuICAgKiAgICAvLyByZXR1cm5zIEFycmF5IFtcbiAgICogICAgLy8gICAyLjcxODI4MTgyODQ1OTA0NSxcbiAgICogICAgLy8gICA3LjM4OTA1NjA5ODkzMDY0OTUsXG4gICAqICAgIC8vICAgMjAuMDg1NTM2OTIzMTg3NjY4XG4gICAqICAgIC8vIF1cbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGxvZywgcG93XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSB4ICBBIG51bWJlciBvciBtYXRyaXggdG8gZXhwb25lbnRpYXRlXG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0gRXhwb25lbnQgb2YgYHhgXG4gICAqL1xuICB2YXIgZXhwID0gdHlwZWQoJ2V4cCcsIHtcbiAgICAnbnVtYmVyJzogTWF0aC5leHAsXG5cbiAgICAnQ29tcGxleCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5leHAoKTtcbiAgICB9LFxuXG4gICAgJ0JpZ051bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5leHAoKTtcbiAgICB9LFxuXG4gICAgJ0FycmF5IHwgTWF0cml4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIC8vIFRPRE86IGV4cChzcGFyc2UpIHNob3VsZCByZXR1cm4gYSBkZW5zZSBtYXRyaXggc2luY2UgZXhwKDApPT0xXG4gICAgICByZXR1cm4gZGVlcE1hcCh4LCBleHApO1xuICAgIH1cbiAgfSk7XG5cbiAgZXhwLnRvVGV4ID0gJ1xcXFxleHBcXFxcbGVmdCgke2FyZ3NbMF19XFxcXHJpZ2h0KSc7XG5cbiAgcmV0dXJuIGV4cDtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2V4cCc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVlcE1hcCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vZGVlcE1hcCcpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIC8qKlxuICAgKiBSb3VuZCBhIHZhbHVlIHRvd2FyZHMgemVyby5cbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmZpeCh4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5maXgoMy4yKTsgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBudW1iZXIgM1xuICAgKiAgICBtYXRoLmZpeCgzLjgpOyAgICAgICAgICAgICAgICAvLyByZXR1cm5zIG51bWJlciAzXG4gICAqICAgIG1hdGguZml4KC00LjIpOyAgICAgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIC00XG4gICAqICAgIG1hdGguZml4KC00LjcpOyAgICAgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIC00XG4gICAqXG4gICAqICAgIHZhciBjID0gbWF0aC5jb21wbGV4KDMuMiwgLTIuNyk7XG4gICAqICAgIG1hdGguZml4KGMpOyAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgQ29tcGxleCAzIC0gMmlcbiAgICpcbiAgICogICAgbWF0aC5maXgoWzMuMiwgMy44LCAtNC43XSk7ICAgLy8gcmV0dXJucyBBcnJheSBbMywgMywgLTRdXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBjZWlsLCBmbG9vciwgcm91bmRcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0geCBOdW1iZXIgdG8gYmUgcm91bmRlZFxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0gICAgICAgICAgICBSb3VuZGVkIHZhbHVlXG4gICAqL1xuICB2YXIgZml4ID0gdHlwZWQoJ2ZpeCcsIHtcbiAgICAnbnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiAoeCA+IDApID8gTWF0aC5mbG9vcih4KSA6IE1hdGguY2VpbCh4KTtcbiAgICB9LFxuXG4gICAgJ0NvbXBsZXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIG5ldyB0eXBlLkNvbXBsZXgoXG4gICAgICAgICAgKHgucmUgPiAwKSA/IE1hdGguZmxvb3IoeC5yZSkgOiBNYXRoLmNlaWwoeC5yZSksXG4gICAgICAgICAgKHguaW0gPiAwKSA/IE1hdGguZmxvb3IoeC5pbSkgOiBNYXRoLmNlaWwoeC5pbSlcbiAgICAgICk7XG4gICAgfSxcblxuICAgICdCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHguaXNOZWdhdGl2ZSgpID8geC5jZWlsKCkgOiB4LmZsb29yKCk7XG4gICAgfSxcblxuICAgICdGcmFjdGlvbic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5zIDwgMCA/IHguY2VpbCgpIDogeC5mbG9vcigpO1xuICAgIH0sXG5cbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgLy8gZGVlcCBtYXAgY29sbGVjdGlvbiwgc2tpcCB6ZXJvcyBzaW5jZSBmaXgoMCkgPSAwXG4gICAgICByZXR1cm4gZGVlcE1hcCh4LCBmaXgsIHRydWUpO1xuICAgIH1cbiAgfSk7XG5cbiAgZml4LnRvVGV4ID0gJ1xcXFxtYXRocm17JHtuYW1lfX1cXFxcbGVmdCgke2FyZ3N9XFxcXHJpZ2h0KSc7XG5cbiAgcmV0dXJuIGZpeDtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2ZpeCc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVlcE1hcCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vZGVlcE1hcCcpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIC8qKlxuICAgKiBSb3VuZCBhIHZhbHVlIHRvd2FyZHMgbWludXMgaW5maW5pdHkuXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5mbG9vcih4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5mbG9vcigzLjIpOyAgICAgICAgICAgICAgLy8gcmV0dXJucyBudW1iZXIgM1xuICAgKiAgICBtYXRoLmZsb29yKDMuOCk7ICAgICAgICAgICAgICAvLyByZXR1cm5zIG51bWJlciAzXG4gICAqICAgIG1hdGguZmxvb3IoLTQuMik7ICAgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIC01XG4gICAqICAgIG1hdGguZmxvb3IoLTQuNyk7ICAgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIC01XG4gICAqXG4gICAqICAgIHZhciBjID0gbWF0aC5jb21wbGV4KDMuMiwgLTIuNyk7XG4gICAqICAgIG1hdGguZmxvb3IoYyk7ICAgICAgICAgICAgICAgIC8vIHJldHVybnMgQ29tcGxleCAzIC0gM2lcbiAgICpcbiAgICogICAgbWF0aC5mbG9vcihbMy4yLCAzLjgsIC00LjddKTsgLy8gcmV0dXJucyBBcnJheSBbMywgMywgLTVdXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBjZWlsLCBmaXgsIHJvdW5kXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSB4ICBOdW1iZXIgdG8gYmUgcm91bmRlZFxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0gUm91bmRlZCB2YWx1ZVxuICAgKi9cbiAgdmFyIGZsb29yID0gdHlwZWQoJ2Zsb29yJywge1xuICAgICdudW1iZXInOiBNYXRoLmZsb29yLFxuXG4gICAgJ0NvbXBsZXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHguZmxvb3IoKTtcbiAgICB9LFxuXG4gICAgJ0JpZ051bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5mbG9vcigpO1xuICAgIH0sXG5cbiAgICAnRnJhY3Rpb24nOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHguZmxvb3IoKTtcbiAgICB9LFxuXG4gICAgJ0FycmF5IHwgTWF0cml4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIC8vIGRlZXAgbWFwIGNvbGxlY3Rpb24sIHNraXAgemVyb3Mgc2luY2UgZmxvb3IoMCkgPSAwXG4gICAgICByZXR1cm4gZGVlcE1hcCh4LCBmbG9vciwgdHJ1ZSk7XG4gICAgfVxuICB9KTtcblxuICBmbG9vci50b1RleCA9ICdcXFxcbGVmdFxcXFxsZmxvb3Ike2FyZ3NbMF19XFxcXHJpZ2h0XFxcXHJmbG9vcic7XG5cbiAgcmV0dXJuIGZsb29yO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnZmxvb3InO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzSW50ZWdlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL251bWJlcicpLmlzSW50ZWdlcjtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuXG4gIHZhciBtYXRyaXggPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L2Z1bmN0aW9uL21hdHJpeCcpKTtcblxuICB2YXIgYWxnb3JpdGhtMDEgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTAxJykpO1xuICB2YXIgYWxnb3JpdGhtMDQgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTA0JykpO1xuICB2YXIgYWxnb3JpdGhtMTAgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTEwJykpO1xuICB2YXIgYWxnb3JpdGhtMTMgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTEzJykpO1xuICB2YXIgYWxnb3JpdGhtMTQgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTE0JykpO1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGdyZWF0ZXN0IGNvbW1vbiBkaXZpc29yIGZvciB0d28gb3IgbW9yZSB2YWx1ZXMgb3IgYXJyYXlzLlxuICAgKlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguZ2NkKGEsIGIpXG4gICAqICAgIG1hdGguZ2NkKGEsIGIsIGMsIC4uLilcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGguZ2NkKDgsIDEyKTsgICAgICAgICAgICAgIC8vIHJldHVybnMgNFxuICAgKiAgICBtYXRoLmdjZCgtNCwgNik7ICAgICAgICAgICAgICAvLyByZXR1cm5zIDJcbiAgICogICAgbWF0aC5nY2QoMjUsIDE1LCAtMTApOyAgICAgICAgLy8gcmV0dXJucyA1XG4gICAqXG4gICAqICAgIG1hdGguZ2NkKFs4LCAtNF0sIFsxMiwgNl0pOyAgIC8vIHJldHVybnMgWzQsIDJdXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBsY20sIHhnY2RcbiAgICpcbiAgICogQHBhcmFtIHsuLi4gbnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb24gfCBBcnJheSB8IE1hdHJpeH0gYXJncyAgVHdvIG9yIG1vcmUgaW50ZWdlciBudW1iZXJzXG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgQXJyYXkgfCBNYXRyaXh9ICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGdyZWF0ZXN0IGNvbW1vbiBkaXZpc29yXG4gICAqL1xuICB2YXIgZ2NkID0gdHlwZWQoJ2djZCcsIHtcblxuICAgICdudW1iZXIsIG51bWJlcic6IF9nY2QsXG5cbiAgICAnQmlnTnVtYmVyLCBCaWdOdW1iZXInOiBfZ2NkQmlnTnVtYmVyLFxuXG4gICAgJ0ZyYWN0aW9uLCBGcmFjdGlvbic6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4geC5nY2QoeSk7XG4gICAgfSxcblxuICAgICdNYXRyaXgsIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuXG4gICAgICAvLyBwcm9jZXNzIG1hdHJpeCBzdG9yYWdlXG4gICAgICBzd2l0Y2ggKHguc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgc3dpdGNoICh5LnN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICAgICAgLy8gc3BhcnNlICsgc3BhcnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0wNCh4LCB5LCBnY2QpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIHNwYXJzZSArIGRlbnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0wMSh5LCB4LCBnY2QsIHRydWUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgc3dpdGNoICh5LnN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICAgICAgLy8gZGVuc2UgKyBzcGFyc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTAxKHgsIHksIGdjZCwgZmFsc2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIGRlbnNlICsgZGVuc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTEzKHgsIHksIGdjZCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG5cbiAgICAnQXJyYXksIEFycmF5JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBnY2QobWF0cml4KHgpLCBtYXRyaXgoeSkpLnZhbHVlT2YoKTtcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGdjZChtYXRyaXgoeCksIHkpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4LCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gZ2NkKHgsIG1hdHJpeCh5KSk7XG4gICAgfSxcbiAgICBcbiAgICAnTWF0cml4LCBudW1iZXIgfCBCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gcmVzdWx0XG4gICAgICB2YXIgYztcbiAgICAgIC8vIGNoZWNrIHN0b3JhZ2UgZm9ybWF0XG4gICAgICBzd2l0Y2ggKHguc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTEwKHgsIHksIGdjZCwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xNCh4LCB5LCBnY2QsIGZhbHNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG5cbiAgICAnbnVtYmVyIHwgQmlnTnVtYmVyLCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gcmVzdWx0XG4gICAgICB2YXIgYztcbiAgICAgIC8vIGNoZWNrIHN0b3JhZ2UgZm9ybWF0XG4gICAgICBzd2l0Y2ggKHkuc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTEwKHksIHgsIGdjZCwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTE0KHksIHgsIGdjZCwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBudW1iZXIgfCBCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGFsZ29yaXRobTE0KG1hdHJpeCh4KSwgeSwgZ2NkLCBmYWxzZSkudmFsdWVPZigpO1xuICAgIH0sXG5cbiAgICAnbnVtYmVyIHwgQmlnTnVtYmVyLCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gYWxnb3JpdGhtMTQobWF0cml4KHkpLCB4LCBnY2QsIHRydWUpLnZhbHVlT2YoKTtcbiAgICB9LFxuXG4gICAgLy8gVE9ETzogbmVlZCBhIHNtYXJ0ZXIgbm90YXRpb24gaGVyZVxuICAgICdBcnJheSB8IE1hdHJpeCB8IG51bWJlciB8IEJpZ051bWJlciwgQXJyYXkgfCBNYXRyaXggfCBudW1iZXIgfCBCaWdOdW1iZXIsIC4uLkFycmF5IHwgTWF0cml4IHwgbnVtYmVyIHwgQmlnTnVtYmVyJzogZnVuY3Rpb24gKGEsIGIsIGFyZ3MpIHtcbiAgICAgIHZhciByZXMgPSBnY2QoYSwgYik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzID0gZ2NkKHJlcywgYXJnc1tpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgfSk7XG5cbiAgZ2NkLnRvVGV4ID0gJ1xcXFxnY2RcXFxcbGVmdCgke2FyZ3N9XFxcXHJpZ2h0KSc7XG5cbiAgcmV0dXJuIGdjZDtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIGdjZCBmb3IgQmlnTnVtYmVyc1xuICAgKiBAcGFyYW0ge0JpZ051bWJlcn0gYVxuICAgKiBAcGFyYW0ge0JpZ051bWJlcn0gYlxuICAgKiBAcmV0dXJucyB7QmlnTnVtYmVyfSBSZXR1cm5zIGdyZWF0ZXN0IGNvbW1vbiBkZW5vbWluYXRvciBvZiBhIGFuZCBiXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfZ2NkQmlnTnVtYmVyKGEsIGIpIHtcbiAgICBpZiAoIWEuaXNJbnQoKSB8fCAhYi5pc0ludCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcmFtZXRlcnMgaW4gZnVuY3Rpb24gZ2NkIG11c3QgYmUgaW50ZWdlciBudW1iZXJzJyk7XG4gICAgfVxuXG4gICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FdWNsaWRlYW5fYWxnb3JpdGhtXG4gICAgdmFyIHplcm8gPSBuZXcgdHlwZS5CaWdOdW1iZXIoMCk7XG4gICAgd2hpbGUgKCFiLmlzWmVybygpKSB7XG4gICAgICB2YXIgciA9IGEubW9kKGIpO1xuICAgICAgYSA9IGI7XG4gICAgICBiID0gcjtcbiAgICB9XG4gICAgcmV0dXJuIGEubHQoemVybykgPyBhLm5lZygpIDogYTtcbiAgfVxufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBnY2QgZm9yIG51bWJlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gKiBAcGFyYW0ge251bWJlcn0gYlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgZ3JlYXRlc3QgY29tbW9uIGRlbm9taW5hdG9yIG9mIGEgYW5kIGJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9nY2QoYSwgYikge1xuICBpZiAoIWlzSW50ZWdlcihhKSB8fCAhaXNJbnRlZ2VyKGIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYXJhbWV0ZXJzIGluIGZ1bmN0aW9uIGdjZCBtdXN0IGJlIGludGVnZXIgbnVtYmVycycpO1xuICB9XG5cbiAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FdWNsaWRlYW5fYWxnb3JpdGhtXG4gIHZhciByO1xuICB3aGlsZSAoYiAhPSAwKSB7XG4gICAgciA9IGEgJSBiO1xuICAgIGEgPSBiO1xuICAgIGIgPSByO1xuICB9XG4gIHJldHVybiAoYSA8IDApID8gLWEgOiBhO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnZ2NkJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmbGF0dGVuID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYXJyYXknKS5mbGF0dGVuO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBhYnMgPSBsb2FkKHJlcXVpcmUoJy4vYWJzJykpO1xuICB2YXIgYWRkID0gbG9hZChyZXF1aXJlKCcuL2FkZFNjYWxhcicpKTtcbiAgdmFyIGRpdmlkZSA9IGxvYWQocmVxdWlyZSgnLi9kaXZpZGVTY2FsYXInKSk7XG4gIHZhciBtdWx0aXBseSA9IGxvYWQocmVxdWlyZSgnLi9tdWx0aXBseVNjYWxhcicpKTtcbiAgdmFyIHNxcnQgPSBsb2FkKHJlcXVpcmUoJy4vc3FydCcpKTtcbiAgdmFyIHNtYWxsZXIgPSBsb2FkKHJlcXVpcmUoJy4uL3JlbGF0aW9uYWwvc21hbGxlcicpKTtcbiAgdmFyIGlzUG9zaXRpdmUgPSBsb2FkKHJlcXVpcmUoJy4uL3V0aWxzL2lzUG9zaXRpdmUnKSk7XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgaHlwb3RlbnVzYSBvZiBhIGxpc3Qgd2l0aCB2YWx1ZXMuIFRoZSBoeXBvdGVudXNhIGlzIGRlZmluZWQgYXM6XG4gICAqXG4gICAqICAgICBoeXBvdChhLCBiLCBjLCAuLi4pID0gc3FydChhXjIgKyBiXjIgKyBjXjIgKyAuLi4pXG4gICAqXG4gICAqIEZvciBtYXRyaXggaW5wdXQsIHRoZSBoeXBvdGVudXNhIGlzIGNhbGN1bGF0ZWQgZm9yIGFsbCB2YWx1ZXMgaW4gdGhlIG1hdHJpeC5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICAgbWF0aC5oeXBvdChhLCBiLCAuLi4pXG4gICAqICAgICBtYXRoLmh5cG90KFthLCBiLCBjLCAuLi5dKVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgIG1hdGguaHlwb3QoMywgNCk7ICAgICAgLy8gNVxuICAgKiAgICAgbWF0aC5oeXBvdCgzLCA0LCA1KTsgICAvLyA3LjA3MTA2NzgxMTg2NTQ3NTVcbiAgICogICAgIG1hdGguaHlwb3QoWzMsIDQsIDVdKTsgLy8gNy4wNzEwNjc4MTE4NjU0NzU1XG4gICAqICAgICBtYXRoLmh5cG90KC0yKTsgICAgICAgIC8vIDJcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgICBhYnMsIG5vcm1cbiAgICpcbiAgICogQHBhcmFtIHsuLi4gbnVtYmVyIHwgQmlnTnVtYmVyfSBhcmdzXG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlcn0gUmV0dXJucyB0aGUgaHlwb3RoZW51c2Egb2YgdGhlIGlucHV0IHZhbHVlcy5cbiAgICovXG4gIHZhciBoeXBvdCA9IHR5cGVkKCdoeXBvdCcsIHtcbiAgICAnLi4uIG51bWJlciB8IEJpZ051bWJlcic6IF9oeXBvdCxcblxuICAgICdBcnJheSc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gaHlwb3QuYXBwbHkoaHlwb3QsIGZsYXR0ZW4oeCkpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBoeXBvdC5hcHBseShoeXBvdCwgZmxhdHRlbih4LnRvQXJyYXkoKSkpO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgaHlwb3RlbnVzYSBmb3IgYW4gQXJyYXkgd2l0aCB2YWx1ZXNcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyIHwgQmlnTnVtYmVyPn0gYXJnc1xuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBCaWdOdW1iZXJ9IFJldHVybnMgdGhlIHJlc3VsdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX2h5cG90IChhcmdzKSB7XG4gICAgLy8gY29kZSBiYXNlZCBvbiBgaHlwb3RgIGZyb20gZXM2LXNoaW06XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BhdWxtaWxsci9lczYtc2hpbS9ibG9iL21hc3Rlci9lczYtc2hpbS5qcyNMMTYxOS1MMTYzM1xuICAgIHZhciByZXN1bHQgPSAwO1xuICAgIHZhciBsYXJnZXN0ID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gYWJzKGFyZ3NbaV0pO1xuICAgICAgaWYgKHNtYWxsZXIobGFyZ2VzdCwgdmFsdWUpKSB7XG4gICAgICAgIHJlc3VsdCA9IG11bHRpcGx5KHJlc3VsdCwgbXVsdGlwbHkoZGl2aWRlKGxhcmdlc3QsIHZhbHVlKSwgZGl2aWRlKGxhcmdlc3QsIHZhbHVlKSkpO1xuICAgICAgICByZXN1bHQgPSBhZGQocmVzdWx0LCAxKTtcbiAgICAgICAgbGFyZ2VzdCA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gYWRkKHJlc3VsdCwgaXNQb3NpdGl2ZSh2YWx1ZSkgPyBtdWx0aXBseShkaXZpZGUodmFsdWUsIGxhcmdlc3QpLCBkaXZpZGUodmFsdWUsIGxhcmdlc3QpKSA6IHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbXVsdGlwbHkobGFyZ2VzdCwgc3FydChyZXN1bHQpKTtcbiAgfVxuXG4gIGh5cG90LnRvVGV4ID0gJ1xcXFxoeXBvdFxcXFxsZWZ0KCR7YXJnc31cXFxccmlnaHQpJztcblxuICByZXR1cm4gaHlwb3Q7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdoeXBvdCc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBbXG4gIHJlcXVpcmUoJy4vYWJzJyksXG4gIHJlcXVpcmUoJy4vYWRkJyksXG4gIHJlcXVpcmUoJy4vYWRkU2NhbGFyJyksXG4gIHJlcXVpcmUoJy4vY2JydCcpLFxuICByZXF1aXJlKCcuL2NlaWwnKSxcbiAgcmVxdWlyZSgnLi9jdWJlJyksXG4gIHJlcXVpcmUoJy4vZGl2aWRlJyksXG4gIHJlcXVpcmUoJy4vZG90RGl2aWRlJyksXG4gIHJlcXVpcmUoJy4vZG90TXVsdGlwbHknKSxcbiAgcmVxdWlyZSgnLi9kb3RQb3cnKSxcbiAgcmVxdWlyZSgnLi9leHAnKSxcbiAgcmVxdWlyZSgnLi9maXgnKSxcbiAgcmVxdWlyZSgnLi9mbG9vcicpLFxuICByZXF1aXJlKCcuL2djZCcpLFxuICByZXF1aXJlKCcuL2h5cG90JyksXG4gIHJlcXVpcmUoJy4vbGNtJyksXG4gIHJlcXVpcmUoJy4vbG9nJyksXG4gIHJlcXVpcmUoJy4vbG9nMTAnKSxcbiAgcmVxdWlyZSgnLi9tb2QnKSxcbiAgcmVxdWlyZSgnLi9tdWx0aXBseScpLFxuICByZXF1aXJlKCcuL25vcm0nKSxcbiAgcmVxdWlyZSgnLi9udGhSb290JyksXG4gIHJlcXVpcmUoJy4vcG93JyksXG4gIHJlcXVpcmUoJy4vcm91bmQnKSxcbiAgcmVxdWlyZSgnLi9zaWduJyksXG4gIHJlcXVpcmUoJy4vc3FydCcpLFxuICByZXF1aXJlKCcuL3NxdWFyZScpLFxuICByZXF1aXJlKCcuL3N1YnRyYWN0JyksXG4gIHJlcXVpcmUoJy4vdW5hcnlNaW51cycpLFxuICByZXF1aXJlKCcuL3VuYXJ5UGx1cycpLFxuICByZXF1aXJlKCcuL3hnY2QnKVxuXTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzSW50ZWdlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL251bWJlcicpLmlzSW50ZWdlcjtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICBcbiAgdmFyIG1hdHJpeCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvZnVuY3Rpb24vbWF0cml4JykpO1xuXG4gIHZhciBhbGdvcml0aG0wMiA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMDInKSk7XG4gIHZhciBhbGdvcml0aG0wNiA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMDYnKSk7XG4gIHZhciBhbGdvcml0aG0xMSA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMTEnKSk7XG4gIHZhciBhbGdvcml0aG0xMyA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMTMnKSk7XG4gIHZhciBhbGdvcml0aG0xNCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMTQnKSk7XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgbGVhc3QgY29tbW9uIG11bHRpcGxlIGZvciB0d28gb3IgbW9yZSB2YWx1ZXMgb3IgYXJyYXlzLlxuICAgKlxuICAgKiBsY20gaXMgZGVmaW5lZCBhczpcbiAgICpcbiAgICogICAgIGxjbShhLCBiKSA9IGFicyhhICogYikgLyBnY2QoYSwgYilcbiAgICpcbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmxjbShhLCBiKVxuICAgKiAgICBtYXRoLmxjbShhLCBiLCBjLCAuLi4pXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmxjbSg0LCA2KTsgICAgICAgICAgICAgICAvLyByZXR1cm5zIDEyXG4gICAqICAgIG1hdGgubGNtKDYsIDIxKTsgICAgICAgICAgICAgIC8vIHJldHVybnMgNDJcbiAgICogICAgbWF0aC5sY20oNiwgMjEsIDUpOyAgICAgICAgICAgLy8gcmV0dXJucyAyMTBcbiAgICpcbiAgICogICAgbWF0aC5sY20oWzQsIDZdLCBbNiwgMjFdKTsgICAgLy8gcmV0dXJucyBbMTIsIDQyXVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgZ2NkLCB4Z2NkXG4gICAqXG4gICAqIEBwYXJhbSB7Li4uIG51bWJlciB8IEJpZ051bWJlciB8IEFycmF5IHwgTWF0cml4fSBhcmdzICBUd28gb3IgbW9yZSBpbnRlZ2VyIG51bWJlcnNcbiAgICogQHJldHVybiB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgQXJyYXkgfCBNYXRyaXh9ICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGxlYXN0IGNvbW1vbiBtdWx0aXBsZVxuICAgKi9cbiAgdmFyIGxjbSA9IHR5cGVkKCdsY20nLCB7XG4gICAgJ251bWJlciwgbnVtYmVyJzogX2xjbSxcblxuICAgICdCaWdOdW1iZXIsIEJpZ051bWJlcic6IF9sY21CaWdOdW1iZXIsXG5cbiAgICAnRnJhY3Rpb24sIEZyYWN0aW9uJzogZnVuY3Rpb24gKHgsIHkpIHtcblxuICAgICAgcmV0dXJuIHgubGNtKHkpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4LCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gcmVzdWx0XG4gICAgICB2YXIgYztcblxuICAgICAgLy8gcHJvY2VzcyBtYXRyaXggc3RvcmFnZVxuICAgICAgc3dpdGNoICh4LnN0b3JhZ2UoKSkge1xuICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgICAgIC8vIHNwYXJzZSArIHNwYXJzZVxuICAgICAgICAgICAgICBjID0gYWxnb3JpdGhtMDYoeCwgeSwgbGNtKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAvLyBzcGFyc2UgKyBkZW5zZVxuICAgICAgICAgICAgICBjID0gYWxnb3JpdGhtMDIoeSwgeCwgbGNtLCB0cnVlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgICAgIC8vIGRlbnNlICsgc3BhcnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0wMih4LCB5LCBsY20sIGZhbHNlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAvLyBkZW5zZSArIGRlbnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0xMyh4LCB5LCBsY20pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gbGNtKG1hdHJpeCh4KSwgbWF0cml4KHkpKS52YWx1ZU9mKCk7XG4gICAgfSxcblxuICAgICdBcnJheSwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBsY20obWF0cml4KHgpLCB5KTtcbiAgICB9LFxuXG4gICAgJ01hdHJpeCwgQXJyYXknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGxjbSh4LCBtYXRyaXgoeSkpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4LCBudW1iZXIgfCBCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gcmVzdWx0XG4gICAgICB2YXIgYztcbiAgICAgIC8vIGNoZWNrIHN0b3JhZ2UgZm9ybWF0XG4gICAgICBzd2l0Y2ggKHguc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTExKHgsIHksIGxjbSwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xNCh4LCB5LCBsY20sIGZhbHNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG5cbiAgICAnbnVtYmVyIHwgQmlnTnVtYmVyLCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gcmVzdWx0XG4gICAgICB2YXIgYztcbiAgICAgIC8vIGNoZWNrIHN0b3JhZ2UgZm9ybWF0XG4gICAgICBzd2l0Y2ggKHkuc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTExKHksIHgsIGxjbSwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTE0KHksIHgsIGxjbSwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBudW1iZXIgfCBCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGFsZ29yaXRobTE0KG1hdHJpeCh4KSwgeSwgbGNtLCBmYWxzZSkudmFsdWVPZigpO1xuICAgIH0sXG5cbiAgICAnbnVtYmVyIHwgQmlnTnVtYmVyLCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gYWxnb3JpdGhtMTQobWF0cml4KHkpLCB4LCBsY20sIHRydWUpLnZhbHVlT2YoKTtcbiAgICB9LFxuXG4gICAgLy8gVE9ETzogbmVlZCBhIHNtYXJ0ZXIgbm90YXRpb24gaGVyZVxuICAgICdBcnJheSB8IE1hdHJpeCB8IG51bWJlciB8IEJpZ051bWJlciwgQXJyYXkgfCBNYXRyaXggfCBudW1iZXIgfCBCaWdOdW1iZXIsIC4uLkFycmF5IHwgTWF0cml4IHwgbnVtYmVyIHwgQmlnTnVtYmVyJzogZnVuY3Rpb24gKGEsIGIsIGFyZ3MpIHtcbiAgICAgIHZhciByZXMgPSBsY20oYSwgYik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzID0gbGNtKHJlcywgYXJnc1tpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgfSk7XG5cbiAgbGNtLnRvVGV4ID0gJ1xcXFxtYXRocm17JHtuYW1lfX1cXFxcbGVmdCgke2FyZ3N9XFxcXHJpZ2h0KSc7XG5cbiAgcmV0dXJuIGxjbTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIGxjbSBmb3IgdHdvIEJpZ051bWJlcnNcbiAgICogQHBhcmFtIHtCaWdOdW1iZXJ9IGFcbiAgICogQHBhcmFtIHtCaWdOdW1iZXJ9IGJcbiAgICogQHJldHVybnMge0JpZ051bWJlcn0gUmV0dXJucyB0aGUgbGVhc3QgY29tbW9uIG11bHRpcGxlIG9mIGEgYW5kIGJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9sY21CaWdOdW1iZXIoYSwgYikge1xuICAgIGlmICghYS5pc0ludCgpIHx8ICFiLmlzSW50KCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGFyYW1ldGVycyBpbiBmdW5jdGlvbiBsY20gbXVzdCBiZSBpbnRlZ2VyIG51bWJlcnMnKTtcbiAgICB9XG5cbiAgICBpZiAoYS5pc1plcm8oKSB8fCBiLmlzWmVybygpKSB7XG4gICAgICByZXR1cm4gbmV3IHR5cGUuQmlnTnVtYmVyKDApO1xuICAgIH1cblxuICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXVjbGlkZWFuX2FsZ29yaXRobVxuICAgIC8vIGV2YWx1YXRlIGxjbSBoZXJlIGlubGluZSB0byByZWR1Y2Ugb3ZlcmhlYWRcbiAgICB2YXIgcHJvZCA9IGEudGltZXMoYik7XG4gICAgd2hpbGUgKCFiLmlzWmVybygpKSB7XG4gICAgICB2YXIgdCA9IGI7XG4gICAgICBiID0gYS5tb2QodCk7XG4gICAgICBhID0gdDtcbiAgICB9XG4gICAgcmV0dXJuIHByb2QuZGl2KGEpLmFicygpO1xuICB9XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIGxjbSBmb3IgdHdvIG51bWJlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gKiBAcGFyYW0ge251bWJlcn0gYlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbGVhc3QgY29tbW9uIG11bHRpcGxlIG9mIGEgYW5kIGJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9sY20gKGEsIGIpIHtcbiAgaWYgKCFpc0ludGVnZXIoYSkgfHwgIWlzSW50ZWdlcihiKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGFyYW1ldGVycyBpbiBmdW5jdGlvbiBsY20gbXVzdCBiZSBpbnRlZ2VyIG51bWJlcnMnKTtcbiAgfVxuXG4gIGlmIChhID09IDAgfHwgYiA9PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0V1Y2xpZGVhbl9hbGdvcml0aG1cbiAgLy8gZXZhbHVhdGUgbGNtIGhlcmUgaW5saW5lIHRvIHJlZHVjZSBvdmVyaGVhZFxuICB2YXIgdDtcbiAgdmFyIHByb2QgPSBhICogYjtcbiAgd2hpbGUgKGIgIT0gMCkge1xuICAgIHQgPSBiO1xuICAgIGIgPSBhICUgdDtcbiAgICBhID0gdDtcbiAgfVxuICByZXR1cm4gTWF0aC5hYnMocHJvZCAvIGEpO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnbGNtJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWVwTWFwID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9kZWVwTWFwJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIGRpdmlkZVNjYWxhciA9IGxvYWQocmVxdWlyZSgnLi9kaXZpZGVTY2FsYXInKSk7XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgbG9nYXJpdGhtIG9mIGEgdmFsdWUuXG4gICAqXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5sb2coeClcbiAgICogICAgbWF0aC5sb2coeCwgYmFzZSlcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGgubG9nKDMuNSk7ICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyAxLjI1Mjc2Mjk2ODQ5NTM2OFxuICAgKiAgICBtYXRoLmV4cChtYXRoLmxvZygyLjQpKTsgICAgICAgIC8vIHJldHVybnMgMi40XG4gICAqXG4gICAqICAgIG1hdGgucG93KDEwLCA0KTsgICAgICAgICAgICAgICAgLy8gcmV0dXJucyAxMDAwMFxuICAgKiAgICBtYXRoLmxvZygxMDAwMCwgMTApOyAgICAgICAgICAgIC8vIHJldHVybnMgNFxuICAgKiAgICBtYXRoLmxvZygxMDAwMCkgLyBtYXRoLmxvZygxMCk7IC8vIHJldHVybnMgNFxuICAgKlxuICAgKiAgICBtYXRoLmxvZygxMDI0LCAyKTsgICAgICAgICAgICAgIC8vIHJldHVybnMgMTBcbiAgICogICAgbWF0aC5wb3coMiwgMTApOyAgICAgICAgICAgICAgICAvLyByZXR1cm5zIDEwMjRcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGV4cCwgbG9nMTBcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9IHhcbiAgICogICAgICAgICAgICBWYWx1ZSBmb3Igd2hpY2ggdG8gY2FsY3VsYXRlIHRoZSBsb2dhcml0aG0uXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgQ29tcGxleH0gW2Jhc2U9ZV1cbiAgICogICAgICAgICAgICBPcHRpb25hbCBiYXNlIGZvciB0aGUgbG9nYXJpdGhtLiBJZiBub3QgcHJvdmlkZWQsIHRoZSBuYXR1cmFsXG4gICAqICAgICAgICAgICAgbG9nYXJpdGhtIG9mIGB4YCBpcyBjYWxjdWxhdGVkLlxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9XG4gICAqICAgICAgICAgICAgUmV0dXJucyB0aGUgbG9nYXJpdGhtIG9mIGB4YFxuICAgKi9cbiAgdmFyIGxvZyA9IHR5cGVkKCdsb2cnLCB7XG4gICAgJ251bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAoeCA+PSAwIHx8IGNvbmZpZy5wcmVkaWN0YWJsZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5sb2coeCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gbmVnYXRpdmUgdmFsdWUgLT4gY29tcGxleCB2YWx1ZSBjb21wdXRhdGlvblxuICAgICAgICByZXR1cm4gbmV3IHR5cGUuQ29tcGxleCh4LCAwKS5sb2coKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgJ0NvbXBsZXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHgubG9nKCk7XG4gICAgfSxcblxuICAgICdCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgaWYgKCF4LmlzTmVnYXRpdmUoKSB8fCBjb25maWcucHJlZGljdGFibGUpIHtcbiAgICAgICAgcmV0dXJuIHgubG4oKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBkb3duZ3JhZGUgdG8gbnVtYmVyLCByZXR1cm4gQ29tcGxleCB2YWx1ZWQgcmVzdWx0XG4gICAgICAgIHJldHVybiBuZXcgdHlwZS5Db21wbGV4KHgudG9OdW1iZXIoKSwgMCkubG9nKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgICdBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gZGVlcE1hcCh4LCBsb2cpO1xuICAgIH0sXG5cbiAgICAnYW55LCBhbnknOiBmdW5jdGlvbiAoeCwgYmFzZSkge1xuICAgICAgLy8gY2FsY3VsYXRlIGxvZ2FyaXRobSBmb3IgYSBzcGVjaWZpZWQgYmFzZSwgbG9nKHgsIGJhc2UpXG4gICAgICByZXR1cm4gZGl2aWRlU2NhbGFyKGxvZyh4KSwgbG9nKGJhc2UpKTtcbiAgICB9XG4gIH0pO1xuXG4gIGxvZy50b1RleCA9IHtcbiAgICAxOiAnXFxcXGxuXFxcXGxlZnQoJHthcmdzWzBdfVxcXFxyaWdodCknLFxuICAgIDI6ICdcXFxcbG9nX3ske2FyZ3NbMV19fVxcXFxsZWZ0KCR7YXJnc1swXX1cXFxccmlnaHQpJ1xuICB9O1xuXG4gIHJldHVybiBsb2c7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdsb2cnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZXBNYXAgPSByZXF1aXJlKCcuLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBNYXAnKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSAxMC1iYXNlIG9mIGEgdmFsdWUuIFRoaXMgaXMgdGhlIHNhbWUgYXMgY2FsY3VsYXRpbmcgYGxvZyh4LCAxMClgLlxuICAgKlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGgubG9nMTAoeClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGgubG9nMTAoMC4wMDAwMSk7ICAgICAgICAgICAgLy8gcmV0dXJucyAtNVxuICAgKiAgICBtYXRoLmxvZzEwKDEwMDAwKTsgICAgICAgICAgICAgIC8vIHJldHVybnMgNFxuICAgKiAgICBtYXRoLmxvZygxMDAwMCkgLyBtYXRoLmxvZygxMCk7IC8vIHJldHVybnMgNFxuICAgKiAgICBtYXRoLnBvdygxMCwgNCk7ICAgICAgICAgICAgICAgIC8vIHJldHVybnMgMTAwMDBcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGV4cCwgbG9nXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSB4XG4gICAqICAgICAgICAgICAgVmFsdWUgZm9yIHdoaWNoIHRvIGNhbGN1bGF0ZSB0aGUgbG9nYXJpdGhtLlxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9XG4gICAqICAgICAgICAgICAgUmV0dXJucyB0aGUgMTAtYmFzZSBsb2dhcml0aG0gb2YgYHhgXG4gICAqL1xuICB2YXIgbG9nMTAgPSB0eXBlZCgnbG9nMTAnLCB7XG4gICAgJ251bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAoeCA+PSAwIHx8IGNvbmZpZy5wcmVkaWN0YWJsZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5sb2coeCkgLyBNYXRoLkxOMTA7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gbmVnYXRpdmUgdmFsdWUgLT4gY29tcGxleCB2YWx1ZSBjb21wdXRhdGlvblxuICAgICAgICByZXR1cm4gbmV3IHR5cGUuQ29tcGxleCh4LCAwKS5sb2coKS5kaXYoTWF0aC5MTjEwKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgJ0NvbXBsZXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIG5ldyB0eXBlLkNvbXBsZXgoeCkubG9nKCkuZGl2KE1hdGguTE4xMCk7XG4gICAgfSxcblxuICAgICdCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgaWYgKCF4LmlzTmVnYXRpdmUoKSB8fCBjb25maWcucHJlZGljdGFibGUpIHtcbiAgICAgICAgcmV0dXJuIHgubG9nKCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gZG93bmdyYWRlIHRvIG51bWJlciwgcmV0dXJuIENvbXBsZXggdmFsdWVkIHJlc3VsdFxuICAgICAgICByZXR1cm4gbmV3IHR5cGUuQ29tcGxleCh4LnRvTnVtYmVyKCksIDApLmxvZygpLmRpdihNYXRoLkxOMTApO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIGRlZXBNYXAoeCwgbG9nMTApO1xuICAgIH1cbiAgfSk7XG5cbiAgbG9nMTAudG9UZXggPSAnXFxcXGxvZ197MTB9XFxcXGxlZnQoJHthcmdzWzBdfVxcXFxyaWdodCknO1xuXG4gIHJldHVybiBsb2cxMDtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2xvZzEwJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG5cbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuXG4gIHZhciBtYXRyaXggPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L2Z1bmN0aW9uL21hdHJpeCcpKTtcbiAgdmFyIGxhdGV4ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbGF0ZXgnKTtcblxuICB2YXIgYWxnb3JpdGhtMDIgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTAyJykpO1xuICB2YXIgYWxnb3JpdGhtMDMgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTAzJykpO1xuICB2YXIgYWxnb3JpdGhtMDUgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTA1JykpO1xuICB2YXIgYWxnb3JpdGhtMTEgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTExJykpO1xuICB2YXIgYWxnb3JpdGhtMTIgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTEyJykpO1xuICB2YXIgYWxnb3JpdGhtMTMgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTEzJykpO1xuICB2YXIgYWxnb3JpdGhtMTQgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTE0JykpO1xuICBcbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIG1vZHVsdXMsIHRoZSByZW1haW5kZXIgb2YgYW4gaW50ZWdlciBkaXZpc2lvbi5cbiAgICpcbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogVGhlIG1vZHVsdXMgaXMgZGVmaW5lZCBhczpcbiAgICpcbiAgICogICAgIHggLSB5ICogZmxvb3IoeCAvIHkpXG4gICAqXG4gICAqIFNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01vZHVsb19vcGVyYXRpb24uXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5tb2QoeCwgeSlcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGgubW9kKDgsIDMpOyAgICAgICAgICAgICAgICAvLyByZXR1cm5zIDJcbiAgICogICAgbWF0aC5tb2QoMTEsIDIpOyAgICAgICAgICAgICAgIC8vIHJldHVybnMgMVxuICAgKlxuICAgKiAgICBmdW5jdGlvbiBpc09kZCh4KSB7XG4gICAqICAgICAgcmV0dXJuIG1hdGgubW9kKHgsIDIpICE9IDA7XG4gICAqICAgIH1cbiAgICpcbiAgICogICAgaXNPZGQoMik7ICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgZmFsc2VcbiAgICogICAgaXNPZGQoMyk7ICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgdHJ1ZVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgZGl2aWRlXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgQXJyYXkgfCBNYXRyaXh9IHggRGl2aWRlbmRcbiAgICogQHBhcmFtICB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb24gfCBBcnJheSB8IE1hdHJpeH0geSBEaXZpc29yXG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgQXJyYXkgfCBNYXRyaXh9IFJldHVybnMgdGhlIHJlbWFpbmRlciBvZiBgeGAgZGl2aWRlZCBieSBgeWAuXG4gICAqL1xuICB2YXIgbW9kID0gdHlwZWQoJ21vZCcsIHtcblxuICAgICdudW1iZXIsIG51bWJlcic6IF9tb2QsXG5cbiAgICAnQmlnTnVtYmVyLCBCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIHkuaXNaZXJvKCkgPyB4IDogeC5tb2QoeSk7XG4gICAgfSxcblxuICAgICdGcmFjdGlvbiwgRnJhY3Rpb24nOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIHgubW9kKHkpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4LCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gcmVzdWx0XG4gICAgICB2YXIgYztcblxuICAgICAgLy8gcHJvY2VzcyBtYXRyaXggc3RvcmFnZVxuICAgICAgc3dpdGNoICh4LnN0b3JhZ2UoKSkge1xuICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgICAgIC8vIG1vZChzcGFyc2UsIHNwYXJzZSlcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTA1KHgsIHksIG1vZCwgZmFsc2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIG1vZChzcGFyc2UsIGRlbnNlKVxuICAgICAgICAgICAgICBjID0gYWxnb3JpdGhtMDIoeSwgeCwgbW9kLCB0cnVlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgICAgIC8vIG1vZChkZW5zZSwgc3BhcnNlKVxuICAgICAgICAgICAgICBjID0gYWxnb3JpdGhtMDMoeCwgeSwgbW9kLCBmYWxzZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgLy8gbW9kKGRlbnNlLCBkZW5zZSlcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTEzKHgsIHksIG1vZCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG4gICAgXG4gICAgJ0FycmF5LCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gbW9kKG1hdHJpeCh4KSwgbWF0cml4KHkpKS52YWx1ZU9mKCk7XG4gICAgfSxcblxuICAgICdBcnJheSwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBtb2QobWF0cml4KHgpLCB5KTtcbiAgICB9LFxuXG4gICAgJ01hdHJpeCwgQXJyYXknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIG1vZCh4LCBtYXRyaXgoeSkpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4LCBhbnknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gcmVzdWx0XG4gICAgICB2YXIgYztcbiAgICAgIC8vIGNoZWNrIHN0b3JhZ2UgZm9ybWF0XG4gICAgICBzd2l0Y2ggKHguc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTExKHgsIHksIG1vZCwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xNCh4LCB5LCBtb2QsIGZhbHNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG5cbiAgICAnYW55LCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gcmVzdWx0XG4gICAgICB2YXIgYztcbiAgICAgIC8vIGNoZWNrIHN0b3JhZ2UgZm9ybWF0XG4gICAgICBzd2l0Y2ggKHkuc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTEyKHksIHgsIG1vZCwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTE0KHksIHgsIG1vZCwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBhbnknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGFsZ29yaXRobTE0KG1hdHJpeCh4KSwgeSwgbW9kLCBmYWxzZSkudmFsdWVPZigpO1xuICAgIH0sXG5cbiAgICAnYW55LCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gYWxnb3JpdGhtMTQobWF0cml4KHkpLCB4LCBtb2QsIHRydWUpLnZhbHVlT2YoKTtcbiAgICB9XG4gIH0pO1xuXG4gIG1vZC50b1RleCA9ICdcXFxcbGVmdCgke2FyZ3NbMF19JyArIGxhdGV4Lm9wZXJhdG9yc1snbW9kJ10gKyAnJHthcmdzWzFdfVxcXFxyaWdodCknO1xuXG4gIHJldHVybiBtb2Q7XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgbW9kdWx1cyBvZiB0d28gbnVtYmVyc1xuICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSByZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9tb2QoeCwgeSkge1xuICAgIGlmICh5ID4gMCkge1xuICAgICAgLy8gV2UgZG9uJ3QgdXNlIEphdmFTY3JpcHQncyAlIG9wZXJhdG9yIGhlcmUgYXMgdGhpcyBkb2Vzbid0IHdvcmtcbiAgICAgIC8vIGNvcnJlY3RseSBmb3IgeCA8IDAgYW5kIHggPT0gMFxuICAgICAgLy8gc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9kdWxvX29wZXJhdGlvblxuICAgICAgcmV0dXJuIHggLSB5ICogTWF0aC5mbG9vcih4IC8geSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHkgPT09IDApIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgICBlbHNlIHsgLy8geSA8IDBcbiAgICAgIC8vIFRPRE86IGltcGxlbWVudCBtb2QgZm9yIGEgbmVnYXRpdmUgZGl2aXNvclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY2FsY3VsYXRlIG1vZCBmb3IgYSBuZWdhdGl2ZSBkaXZpc29yJyk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMubmFtZSA9ICdtb2QnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdCcpLmV4dGVuZDtcbnZhciBhcnJheSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2FycmF5Jyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIGxhdGV4ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbGF0ZXgnKTtcblxuICB2YXIgbWF0cml4ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC9mdW5jdGlvbi9tYXRyaXgnKSk7XG4gIHZhciBhZGRTY2FsYXIgPSBsb2FkKHJlcXVpcmUoJy4vYWRkU2NhbGFyJykpO1xuICB2YXIgbXVsdGlwbHlTY2FsYXIgPSBsb2FkKHJlcXVpcmUoJy4vbXVsdGlwbHlTY2FsYXInKSk7XG4gIHZhciBlcXVhbFNjYWxhciA9IGxvYWQocmVxdWlyZSgnLi4vcmVsYXRpb25hbC9lcXVhbFNjYWxhcicpKTtcblxuICB2YXIgYWxnb3JpdGhtMTEgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTExJykpO1xuICB2YXIgYWxnb3JpdGhtMTQgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTE0JykpO1xuICBcbiAgdmFyIERlbnNlTWF0cml4ID0gdHlwZS5EZW5zZU1hdHJpeDtcbiAgdmFyIFNwYXJzZU1hdHJpeCA9IHR5cGUuU3BhcnNlTWF0cml4O1xuXG4gIC8qKlxuICAgKiBNdWx0aXBseSB0d28gdmFsdWVzLCBgeCAqIHlgLlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBtYXRyaXggcHJvZHVjdCBpcyBjYWxjdWxhdGVkLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGgubXVsdGlwbHkoeCwgeSlcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGgubXVsdGlwbHkoNCwgNS4yKTsgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIDIwLjhcbiAgICpcbiAgICogICAgdmFyIGEgPSBtYXRoLmNvbXBsZXgoMiwgMyk7XG4gICAqICAgIHZhciBiID0gbWF0aC5jb21wbGV4KDQsIDEpO1xuICAgKiAgICBtYXRoLm11bHRpcGx5KGEsIGIpOyAgICAgICAgICAvLyByZXR1cm5zIENvbXBsZXggNSArIDE0aVxuICAgKlxuICAgKiAgICB2YXIgYyA9IFtbMSwgMl0sIFs0LCAzXV07XG4gICAqICAgIHZhciBkID0gW1sxLCAyLCAzXSwgWzMsIC00LCA3XV07XG4gICAqICAgIG1hdGgubXVsdGlwbHkoYywgZCk7ICAgICAgICAgIC8vIHJldHVybnMgQXJyYXkgW1s3LCAtNiwgMTddLCBbMTMsIC00LCAzM11dXG4gICAqXG4gICAqICAgIHZhciBlID0gbWF0aC51bml0KCcyLjEga20nKTtcbiAgICogICAgbWF0aC5tdWx0aXBseSgzLCBlKTsgICAgICAgICAgLy8gcmV0dXJucyBVbml0IDYuMyBrbVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgZGl2aWRlXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeH0geCBGaXJzdCB2YWx1ZSB0byBtdWx0aXBseVxuICAgKiBAcGFyYW0gIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXh9IHkgU2Vjb25kIHZhbHVlIHRvIG11bHRpcGx5XG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeH0gTXVsdGlwbGljYXRpb24gb2YgYHhgIGFuZCBgeWBcbiAgICovXG4gIHZhciBtdWx0aXBseSA9IHR5cGVkKCdtdWx0aXBseScsIGV4dGVuZCh7XG4gICAgLy8gd2UgZXh0ZW5kIHRoZSBzaWduYXR1cmVzIG9mIG11bHRpcGx5U2NhbGFyIHdpdGggc2lnbmF0dXJlcyBkZWFsaW5nIHdpdGggbWF0cmljZXNcblxuICAgICdBcnJheSwgQXJyYXknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gY2hlY2sgZGltZW5zaW9uc1xuICAgICAgX3ZhbGlkYXRlTWF0cml4RGltZW5zaW9ucyhhcnJheS5zaXplKHgpLCBhcnJheS5zaXplKHkpKTtcblxuICAgICAgLy8gdXNlIGRlbnNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgdmFyIG0gPSBtdWx0aXBseShtYXRyaXgoeCksIG1hdHJpeCh5KSk7XG4gICAgICAvLyByZXR1cm4gYXJyYXkgb3Igc2NhbGFyXG4gICAgICByZXR1cm4gKG0gJiYgbS5pc01hdHJpeCA9PT0gdHJ1ZSkgPyBtLnZhbHVlT2YoKSA6IG07XG4gICAgfSxcblxuICAgICdNYXRyaXgsIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyBkaW1lbnNpb25zXG4gICAgICB2YXIgeHNpemUgPSB4LnNpemUoKTtcbiAgICAgIHZhciB5c2l6ZSA9IHkuc2l6ZSgpO1xuXG4gICAgICAvLyBjaGVjayBkaW1lbnNpb25zXG4gICAgICBfdmFsaWRhdGVNYXRyaXhEaW1lbnNpb25zKHhzaXplLCB5c2l6ZSk7XG5cbiAgICAgIC8vIHByb2Nlc3MgZGltZW5zaW9uc1xuICAgICAgaWYgKHhzaXplLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyBwcm9jZXNzIHkgZGltZW5zaW9uc1xuICAgICAgICBpZiAoeXNpemUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgLy8gVmVjdG9yICogVmVjdG9yXG4gICAgICAgICAgcmV0dXJuIF9tdWx0aXBseVZlY3RvclZlY3Rvcih4LCB5LCB4c2l6ZVswXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVmVjdG9yICogTWF0cml4XG4gICAgICAgIHJldHVybiBfbXVsdGlwbHlWZWN0b3JNYXRyaXgoeCwgeSk7XG4gICAgICB9XG4gICAgICAvLyBwcm9jZXNzIHkgZGltZW5zaW9uc1xuICAgICAgaWYgKHlzaXplLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyBNYXRyaXggKiBWZWN0b3JcbiAgICAgICAgcmV0dXJuIF9tdWx0aXBseU1hdHJpeFZlY3Rvcih4LCB5KTtcbiAgICAgIH1cbiAgICAgIC8vIE1hdHJpeCAqIE1hdHJpeFxuICAgICAgcmV0dXJuIF9tdWx0aXBseU1hdHJpeE1hdHJpeCh4LCB5KTtcbiAgICB9LFxuXG4gICAgJ01hdHJpeCwgQXJyYXknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIE1hdHJpeCAqIE1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIG11bHRpcGx5KHgsIG1hdHJpeCh5KSk7XG4gICAgfSxcblxuICAgICdBcnJheSwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBNYXRyaXggKiBNYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBtdWx0aXBseShtYXRyaXgoeCwgeS5zdG9yYWdlKCkpLCB5KTtcbiAgICB9LFxuXG4gICAgJ01hdHJpeCwgYW55JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHJlc3VsdFxuICAgICAgdmFyIGM7XG4gICAgICBcbiAgICAgIC8vIHByb2Nlc3Mgc3RvcmFnZSBmb3JtYXRcbiAgICAgIHN3aXRjaCAoeC5zdG9yYWdlKCkpIHtcbiAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTEoeCwgeSwgbXVsdGlwbHlTY2FsYXIsIGZhbHNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZGVuc2UnOlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xNCh4LCB5LCBtdWx0aXBseVNjYWxhciwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfSxcblxuICAgICdhbnksIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuICAgICAgLy8gY2hlY2sgc3RvcmFnZSBmb3JtYXRcbiAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTEoeSwgeCwgbXVsdGlwbHlTY2FsYXIsIHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkZW5zZSc6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTE0KHksIHgsIG11bHRpcGx5U2NhbGFyLCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG5cbiAgICAnQXJyYXksIGFueSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gYWxnb3JpdGhtMTQobWF0cml4KHgpLCB5LCBtdWx0aXBseVNjYWxhciwgZmFsc2UpLnZhbHVlT2YoKTtcbiAgICB9LFxuXG4gICAgJ2FueSwgQXJyYXknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGFsZ29yaXRobTE0KG1hdHJpeCh5KSwgeCwgbXVsdGlwbHlTY2FsYXIsIHRydWUpLnZhbHVlT2YoKTtcbiAgICB9XG4gIH0sIG11bHRpcGx5U2NhbGFyLnNpZ25hdHVyZXMpKTtcblxuICB2YXIgX3ZhbGlkYXRlTWF0cml4RGltZW5zaW9ucyA9IGZ1bmN0aW9uIChzaXplMSwgc2l6ZTIpIHtcbiAgICAvLyBjaGVjayBsZWZ0IG9wZXJhbmQgZGltZW5zaW9uc1xuICAgIHN3aXRjaCAoc2l6ZTEubGVuZ3RoKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIC8vIGNoZWNrIHNpemUyXG4gICAgICAgIHN3aXRjaCAoc2l6ZTIubGVuZ3RoKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgLy8gVmVjdG9yIHggVmVjdG9yXG4gICAgICAgICAgICBpZiAoc2l6ZTFbMF0gIT09IHNpemUyWzBdKSB7XG4gICAgICAgICAgICAgIC8vIHRocm93IGVycm9yXG4gICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdEaW1lbnNpb24gbWlzbWF0Y2ggaW4gbXVsdGlwbGljYXRpb24uIFZlY3RvcnMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgLy8gVmVjdG9yIHggTWF0cml4XG4gICAgICAgICAgICBpZiAoc2l6ZTFbMF0gIT09IHNpemUyWzBdKSB7XG4gICAgICAgICAgICAgIC8vIHRocm93IGVycm9yXG4gICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdEaW1lbnNpb24gbWlzbWF0Y2ggaW4gbXVsdGlwbGljYXRpb24uIFZlY3RvciBsZW5ndGggKCcgKyBzaXplMVswXSArICcpIG11c3QgbWF0Y2ggTWF0cml4IHJvd3MgKCcgKyBzaXplMlswXSArICcpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gb25seSBtdWx0aXBseSBhIDEgb3IgMiBkaW1lbnNpb25hbCBtYXRyaXggKE1hdHJpeCBCIGhhcyAnICsgc2l6ZTIubGVuZ3RoICsgJyBkaW1lbnNpb25zKScpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICAvLyBjaGVjayBzaXplMlxuICAgICAgICBzd2l0Y2ggKHNpemUyLmxlbmd0aCkge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIC8vIE1hdHJpeCB4IFZlY3RvclxuICAgICAgICAgICAgaWYgKHNpemUxWzFdICE9PSBzaXplMlswXSkge1xuICAgICAgICAgICAgICAvLyB0aHJvdyBlcnJvclxuICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignRGltZW5zaW9uIG1pc21hdGNoIGluIG11bHRpcGxpY2F0aW9uLiBNYXRyaXggY29sdW1ucyAoJyArIHNpemUxWzFdICsgJykgbXVzdCBtYXRjaCBWZWN0b3IgbGVuZ3RoICgnICsgc2l6ZTJbMF0gKyAnKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgLy8gTWF0cml4IHggTWF0cml4XG4gICAgICAgICAgICBpZiAoc2l6ZTFbMV0gIT09IHNpemUyWzBdKSB7XG4gICAgICAgICAgICAgIC8vIHRocm93IGVycm9yXG4gICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdEaW1lbnNpb24gbWlzbWF0Y2ggaW4gbXVsdGlwbGljYXRpb24uIE1hdHJpeCBBIGNvbHVtbnMgKCcgKyBzaXplMVsxXSArICcpIG11c3QgbWF0Y2ggTWF0cml4IEIgcm93cyAoJyArIHNpemUyWzBdICsgJyknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBvbmx5IG11bHRpcGx5IGEgMSBvciAyIGRpbWVuc2lvbmFsIG1hdHJpeCAoTWF0cml4IEIgaGFzICcgKyBzaXplMi5sZW5ndGggKyAnIGRpbWVuc2lvbnMpJyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBvbmx5IG11bHRpcGx5IGEgMSBvciAyIGRpbWVuc2lvbmFsIG1hdHJpeCAoTWF0cml4IEEgaGFzICcgKyBzaXplMS5sZW5ndGggKyAnIGRpbWVuc2lvbnMpJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDID0gQSAqIEJcbiAgICpcbiAgICogQHBhcmFtIHtNYXRyaXh9IGEgICAgICAgICAgICBEZW5zZSBWZWN0b3IgICAoTilcbiAgICogQHBhcmFtIHtNYXRyaXh9IGIgICAgICAgICAgICBEZW5zZSBWZWN0b3IgICAoTilcbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfSAgICAgICAgICAgICBTY2FsYXIgdmFsdWVcbiAgICovXG4gIHZhciBfbXVsdGlwbHlWZWN0b3JWZWN0b3IgPSBmdW5jdGlvbiAoYSwgYiwgbikge1xuICAgIC8vIGNoZWNrIGVtcHR5IHZlY3RvclxuICAgIGlmIChuID09PSAwKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgbXVsdGlwbHkgdHdvIGVtcHR5IHZlY3RvcnMnKTtcblxuICAgIC8vIGEgZGVuc2VcbiAgICB2YXIgYWRhdGEgPSBhLl9kYXRhO1xuICAgIHZhciBhZHQgPSBhLl9kYXRhdHlwZTtcbiAgICAvLyBiIGRlbnNlXG4gICAgdmFyIGJkYXRhID0gYi5fZGF0YTtcbiAgICB2YXIgYmR0ID0gYi5fZGF0YXR5cGU7XG5cbiAgICAvLyBkYXRhdHlwZVxuICAgIHZhciBkdDtcbiAgICAvLyBhZGRTY2FsYXIgc2lnbmF0dXJlIHRvIHVzZVxuICAgIHZhciBhZiA9IGFkZFNjYWxhcjtcbiAgICAvLyBtdWx0aXBseVNjYWxhciBzaWduYXR1cmUgdG8gdXNlXG4gICAgdmFyIG1mID0gbXVsdGlwbHlTY2FsYXI7XG5cbiAgICAvLyBwcm9jZXNzIGRhdGEgdHlwZXNcbiAgICBpZiAoYWR0ICYmIGJkdCAmJiBhZHQgPT09IGJkdCAmJiB0eXBlb2YgYWR0ID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gZGF0YXR5cGVcbiAgICAgIGR0ID0gYWR0O1xuICAgICAgLy8gZmluZCBzaWduYXR1cmVzIHRoYXQgbWF0Y2hlcyAoZHQsIGR0KVxuICAgICAgYWYgPSB0eXBlZC5maW5kKGFkZFNjYWxhciwgW2R0LCBkdF0pO1xuICAgICAgbWYgPSB0eXBlZC5maW5kKG11bHRpcGx5U2NhbGFyLCBbZHQsIGR0XSk7XG4gICAgfVxuICAgIFxuICAgIC8vIHJlc3VsdCAoZG8gbm90IGluaXRpYWxpemUgaXQgd2l0aCB6ZXJvKVxuICAgIHZhciBjID0gbWYoYWRhdGFbMF0sIGJkYXRhWzBdKTtcbiAgICAvLyBsb29wIGRhdGFcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IG47IGkrKykge1xuICAgICAgLy8gbXVsdGlwbHkgYW5kIGFjY3VtdWxhdGVcbiAgICAgIGMgPSBhZihjLCBtZihhZGF0YVtpXSwgYmRhdGFbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEMgPSBBICogQlxuICAgKlxuICAgKiBAcGFyYW0ge01hdHJpeH0gYSAgICAgICAgICAgIERlbnNlIFZlY3RvciAgIChNKVxuICAgKiBAcGFyYW0ge01hdHJpeH0gYiAgICAgICAgICAgIE1hdHJpeCAgICAgICAgIChNeE4pXG4gICAqXG4gICAqIEByZXR1cm4ge01hdHJpeH0gICAgICAgICAgICAgRGVuc2UgVmVjdG9yICAgKE4pXG4gICAqL1xuICB2YXIgX211bHRpcGx5VmVjdG9yTWF0cml4ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAvLyBwcm9jZXNzIHN0b3JhZ2VcbiAgICBzd2l0Y2ggKGIuc3RvcmFnZSgpKSB7XG4gICAgICBjYXNlICdkZW5zZSc6XG4gICAgICAgIHJldHVybiBfbXVsdGlwbHlWZWN0b3JEZW5zZU1hdHJpeChhLCBiKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbiAgfTtcblxuICAvKipcbiAgICogQyA9IEEgKiBCXG4gICAqXG4gICAqIEBwYXJhbSB7TWF0cml4fSBhICAgICAgICAgICAgRGVuc2UgVmVjdG9yICAgKE0pXG4gICAqIEBwYXJhbSB7TWF0cml4fSBiICAgICAgICAgICAgRGVuc2UgTWF0cml4ICAgKE14TilcbiAgICpcbiAgICogQHJldHVybiB7TWF0cml4fSAgICAgICAgICAgICBEZW5zZSBWZWN0b3IgICAoTilcbiAgICovXG4gIHZhciBfbXVsdGlwbHlWZWN0b3JEZW5zZU1hdHJpeCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgLy8gYSBkZW5zZVxuICAgIHZhciBhZGF0YSA9IGEuX2RhdGE7XG4gICAgdmFyIGFzaXplID0gYS5fc2l6ZTtcbiAgICB2YXIgYWR0ID0gYS5fZGF0YXR5cGU7XG4gICAgLy8gYiBkZW5zZVxuICAgIHZhciBiZGF0YSA9IGIuX2RhdGE7XG4gICAgdmFyIGJzaXplID0gYi5fc2l6ZTtcbiAgICB2YXIgYmR0ID0gYi5fZGF0YXR5cGU7XG4gICAgLy8gcm93cyAmIGNvbHVtbnNcbiAgICB2YXIgYWxlbmd0aCA9IGFzaXplWzBdO1xuICAgIHZhciBiY29sdW1ucyA9IGJzaXplWzFdO1xuXG4gICAgLy8gZGF0YXR5cGVcbiAgICB2YXIgZHQ7XG4gICAgLy8gYWRkU2NhbGFyIHNpZ25hdHVyZSB0byB1c2VcbiAgICB2YXIgYWYgPSBhZGRTY2FsYXI7XG4gICAgLy8gbXVsdGlwbHlTY2FsYXIgc2lnbmF0dXJlIHRvIHVzZVxuICAgIHZhciBtZiA9IG11bHRpcGx5U2NhbGFyO1xuXG4gICAgLy8gcHJvY2VzcyBkYXRhIHR5cGVzXG4gICAgaWYgKGFkdCAmJiBiZHQgJiYgYWR0ID09PSBiZHQgJiYgdHlwZW9mIGFkdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIGRhdGF0eXBlXG4gICAgICBkdCA9IGFkdDtcbiAgICAgIC8vIGZpbmQgc2lnbmF0dXJlcyB0aGF0IG1hdGNoZXMgKGR0LCBkdClcbiAgICAgIGFmID0gdHlwZWQuZmluZChhZGRTY2FsYXIsIFtkdCwgZHRdKTtcbiAgICAgIG1mID0gdHlwZWQuZmluZChtdWx0aXBseVNjYWxhciwgW2R0LCBkdF0pO1xuICAgIH1cblxuICAgIC8vIHJlc3VsdFxuICAgIHZhciBjID0gW107XG5cbiAgICAvLyBsb29wIG1hdHJpeCBjb2x1bW5zXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBiY29sdW1uczsgaisrKSB7XG4gICAgICAvLyBzdW0gKGRvIG5vdCBpbml0aWFsaXplIGl0IHdpdGggemVybylcbiAgICAgIHZhciBzdW0gPSBtZihhZGF0YVswXSwgYmRhdGFbMF1bal0pOyAgICAgIFxuICAgICAgLy8gbG9vcCB2ZWN0b3JcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYWxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIG11bHRpcGx5ICYgYWNjdW11bGF0ZVxuICAgICAgICBzdW0gPSBhZihzdW0sIG1mKGFkYXRhW2ldLCBiZGF0YVtpXVtqXSkpO1xuICAgICAgfVxuICAgICAgY1tqXSA9IHN1bTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm4gbWF0cml4XG4gICAgcmV0dXJuIG5ldyBEZW5zZU1hdHJpeCh7XG4gICAgICBkYXRhOiBjLFxuICAgICAgc2l6ZTogW2Jjb2x1bW5zXSxcbiAgICAgIGRhdGF0eXBlOiBkdFxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDID0gQSAqIEJcbiAgICpcbiAgICogQHBhcmFtIHtNYXRyaXh9IGEgICAgICAgICAgICBNYXRyaXggICAgICAgICAoTXhOKVxuICAgKiBAcGFyYW0ge01hdHJpeH0gYiAgICAgICAgICAgIERlbnNlIFZlY3RvciAgIChOKVxuICAgKlxuICAgKiBAcmV0dXJuIHtNYXRyaXh9ICAgICAgICAgICAgIERlbnNlIFZlY3RvciAgIChNKVxuICAgKi9cbiAgdmFyIF9tdWx0aXBseU1hdHJpeFZlY3RvciA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgLy8gcHJvY2VzcyBzdG9yYWdlXG4gICAgc3dpdGNoIChhLnN0b3JhZ2UoKSkge1xuICAgICAgY2FzZSAnZGVuc2UnOlxuICAgICAgICByZXR1cm4gX211bHRpcGx5RGVuc2VNYXRyaXhWZWN0b3IoYSwgYik7XG4gICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICByZXR1cm4gX211bHRpcGx5U3BhcnNlTWF0cml4VmVjdG9yKGEsIGIpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQyA9IEEgKiBCXG4gICAqXG4gICAqIEBwYXJhbSB7TWF0cml4fSBhICAgICAgICAgICAgTWF0cml4ICAgICAgICAgKE14TilcbiAgICogQHBhcmFtIHtNYXRyaXh9IGIgICAgICAgICAgICBNYXRyaXggICAgICAgICAoTnhDKVxuICAgKlxuICAgKiBAcmV0dXJuIHtNYXRyaXh9ICAgICAgICAgICAgIE1hdHJpeCAgICAgICAgIChNeEMpXG4gICAqL1xuICB2YXIgX211bHRpcGx5TWF0cml4TWF0cml4ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAvLyBwcm9jZXNzIHN0b3JhZ2VcbiAgICBzd2l0Y2ggKGEuc3RvcmFnZSgpKSB7XG4gICAgICBjYXNlICdkZW5zZSc6XG4gICAgICAgIC8vIHByb2Nlc3Mgc3RvcmFnZVxuICAgICAgICBzd2l0Y2ggKGIuc3RvcmFnZSgpKSB7XG4gICAgICAgICAgY2FzZSAnZGVuc2UnOlxuICAgICAgICAgICAgcmV0dXJuIF9tdWx0aXBseURlbnNlTWF0cml4RGVuc2VNYXRyaXgoYSwgYik7XG4gICAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICAgIHJldHVybiBfbXVsdGlwbHlEZW5zZU1hdHJpeFNwYXJzZU1hdHJpeChhLCBiKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgIC8vIHByb2Nlc3Mgc3RvcmFnZVxuICAgICAgICBzd2l0Y2ggKGIuc3RvcmFnZSgpKSB7XG4gICAgICAgICAgY2FzZSAnZGVuc2UnOlxuICAgICAgICAgICAgcmV0dXJuIF9tdWx0aXBseVNwYXJzZU1hdHJpeERlbnNlTWF0cml4KGEsIGIpO1xuICAgICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgICByZXR1cm4gX211bHRpcGx5U3BhcnNlTWF0cml4U3BhcnNlTWF0cml4KGEsIGIpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQyA9IEEgKiBCXG4gICAqXG4gICAqIEBwYXJhbSB7TWF0cml4fSBhICAgICAgICAgICAgRGVuc2VNYXRyaXggIChNeE4pXG4gICAqIEBwYXJhbSB7TWF0cml4fSBiICAgICAgICAgICAgRGVuc2UgVmVjdG9yIChOKVxuICAgKlxuICAgKiBAcmV0dXJuIHtNYXRyaXh9ICAgICAgICAgICAgIERlbnNlIFZlY3RvciAoTSkgXG4gICAqLyBcbiAgdmFyIF9tdWx0aXBseURlbnNlTWF0cml4VmVjdG9yID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAvLyBhIGRlbnNlXG4gICAgdmFyIGFkYXRhID0gYS5fZGF0YTtcbiAgICB2YXIgYXNpemUgPSBhLl9zaXplO1xuICAgIHZhciBhZHQgPSBhLl9kYXRhdHlwZTtcbiAgICAvLyBiIGRlbnNlXG4gICAgdmFyIGJkYXRhID0gYi5fZGF0YTtcbiAgICB2YXIgYmR0ID0gYi5fZGF0YXR5cGU7XG4gICAgLy8gcm93cyAmIGNvbHVtbnNcbiAgICB2YXIgYXJvd3MgPSBhc2l6ZVswXTtcbiAgICB2YXIgYWNvbHVtbnMgPSBhc2l6ZVsxXTtcblxuICAgIC8vIGRhdGF0eXBlXG4gICAgdmFyIGR0O1xuICAgIC8vIGFkZFNjYWxhciBzaWduYXR1cmUgdG8gdXNlXG4gICAgdmFyIGFmID0gYWRkU2NhbGFyO1xuICAgIC8vIG11bHRpcGx5U2NhbGFyIHNpZ25hdHVyZSB0byB1c2VcbiAgICB2YXIgbWYgPSBtdWx0aXBseVNjYWxhcjtcblxuICAgIC8vIHByb2Nlc3MgZGF0YSB0eXBlc1xuICAgIGlmIChhZHQgJiYgYmR0ICYmIGFkdCA9PT0gYmR0ICYmIHR5cGVvZiBhZHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBkYXRhdHlwZVxuICAgICAgZHQgPSBhZHQ7XG4gICAgICAvLyBmaW5kIHNpZ25hdHVyZXMgdGhhdCBtYXRjaGVzIChkdCwgZHQpXG4gICAgICBhZiA9IHR5cGVkLmZpbmQoYWRkU2NhbGFyLCBbZHQsIGR0XSk7XG4gICAgICBtZiA9IHR5cGVkLmZpbmQobXVsdGlwbHlTY2FsYXIsIFtkdCwgZHRdKTtcbiAgICB9XG5cbiAgICAvLyByZXN1bHRcbiAgICB2YXIgYyA9IFtdO1xuXG4gICAgLy8gbG9vcCBtYXRyaXggYSByb3dzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcm93czsgaSsrKSB7XG4gICAgICAvLyBjdXJyZW50IHJvd1xuICAgICAgdmFyIHJvdyA9IGFkYXRhW2ldO1xuICAgICAgLy8gc3VtIChkbyBub3QgaW5pdGlhbGl6ZSBpdCB3aXRoIHplcm8pXG4gICAgICB2YXIgc3VtID0gbWYocm93WzBdLCBiZGF0YVswXSk7XG4gICAgICAvLyBsb29wIG1hdHJpeCBhIGNvbHVtbnNcbiAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgYWNvbHVtbnM7IGorKykge1xuICAgICAgICAvLyBtdWx0aXBseSAmIGFjY3VtdWxhdGVcbiAgICAgICAgc3VtID0gYWYoc3VtLCBtZihyb3dbal0sIGJkYXRhW2pdKSk7XG4gICAgICB9XG4gICAgICBjW2ldID0gc3VtO1xuICAgIH1cblxuICAgIC8vIHJldHVybiBtYXRyaXhcbiAgICByZXR1cm4gbmV3IERlbnNlTWF0cml4KHtcbiAgICAgIGRhdGE6IGMsXG4gICAgICBzaXplOiBbYXJvd3NdLFxuICAgICAgZGF0YXR5cGU6IGR0XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEMgPSBBICogQlxuICAgKlxuICAgKiBAcGFyYW0ge01hdHJpeH0gYSAgICAgICAgICAgIERlbnNlTWF0cml4ICAgIChNeE4pXG4gICAqIEBwYXJhbSB7TWF0cml4fSBiICAgICAgICAgICAgRGVuc2VNYXRyaXggICAgKE54QylcbiAgICpcbiAgICogQHJldHVybiB7TWF0cml4fSAgICAgICAgICAgICBEZW5zZU1hdHJpeCAgICAoTXhDKVxuICAgKi9cbiAgdmFyIF9tdWx0aXBseURlbnNlTWF0cml4RGVuc2VNYXRyaXggPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIC8vIGEgZGVuc2VcbiAgICB2YXIgYWRhdGEgPSBhLl9kYXRhO1xuICAgIHZhciBhc2l6ZSA9IGEuX3NpemU7XG4gICAgdmFyIGFkdCA9IGEuX2RhdGF0eXBlO1xuICAgIC8vIGIgZGVuc2VcbiAgICB2YXIgYmRhdGEgPSBiLl9kYXRhO1xuICAgIHZhciBic2l6ZSA9IGIuX3NpemU7XG4gICAgdmFyIGJkdCA9IGIuX2RhdGF0eXBlO1xuICAgIC8vIHJvd3MgJiBjb2x1bW5zXG4gICAgdmFyIGFyb3dzID0gYXNpemVbMF07XG4gICAgdmFyIGFjb2x1bW5zID0gYXNpemVbMV07XG4gICAgdmFyIGJjb2x1bW5zID0gYnNpemVbMV07XG5cbiAgICAvLyBkYXRhdHlwZVxuICAgIHZhciBkdDtcbiAgICAvLyBhZGRTY2FsYXIgc2lnbmF0dXJlIHRvIHVzZVxuICAgIHZhciBhZiA9IGFkZFNjYWxhcjtcbiAgICAvLyBtdWx0aXBseVNjYWxhciBzaWduYXR1cmUgdG8gdXNlXG4gICAgdmFyIG1mID0gbXVsdGlwbHlTY2FsYXI7XG5cbiAgICAvLyBwcm9jZXNzIGRhdGEgdHlwZXNcbiAgICBpZiAoYWR0ICYmIGJkdCAmJiBhZHQgPT09IGJkdCAmJiB0eXBlb2YgYWR0ID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gZGF0YXR5cGVcbiAgICAgIGR0ID0gYWR0O1xuICAgICAgLy8gZmluZCBzaWduYXR1cmVzIHRoYXQgbWF0Y2hlcyAoZHQsIGR0KVxuICAgICAgYWYgPSB0eXBlZC5maW5kKGFkZFNjYWxhciwgW2R0LCBkdF0pO1xuICAgICAgbWYgPSB0eXBlZC5maW5kKG11bHRpcGx5U2NhbGFyLCBbZHQsIGR0XSk7XG4gICAgfVxuICAgIFxuICAgIC8vIHJlc3VsdFxuICAgIHZhciBjID0gW107XG5cbiAgICAvLyBsb29wIG1hdHJpeCBhIHJvd3NcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyb3dzOyBpKyspIHtcbiAgICAgIC8vIGN1cnJlbnQgcm93XG4gICAgICB2YXIgcm93ID0gYWRhdGFbaV07XG4gICAgICAvLyBpbml0aWFsaXplIHJvdyBhcnJheVxuICAgICAgY1tpXSA9IFtdO1xuICAgICAgLy8gbG9vcCBtYXRyaXggYiBjb2x1bW5zXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGJjb2x1bW5zOyBqKyspIHtcbiAgICAgICAgLy8gc3VtIChhdm9pZCBpbml0aWFsaXppbmcgc3VtIHRvIHplcm8pXG4gICAgICAgIHZhciBzdW0gPSBtZihyb3dbMF0sIGJkYXRhWzBdW2pdKTtcbiAgICAgICAgLy8gbG9vcCBtYXRyaXggYSBjb2x1bW5zXG4gICAgICAgIGZvciAodmFyIHggPSAxOyB4IDwgYWNvbHVtbnM7IHgrKykge1xuICAgICAgICAgIC8vIG11bHRpcGx5ICYgYWNjdW11bGF0ZVxuICAgICAgICAgIHN1bSA9IGFmKHN1bSwgbWYocm93W3hdLCBiZGF0YVt4XVtqXSkpO1xuICAgICAgICB9XG4gICAgICAgIGNbaV1bal0gPSBzdW07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIG1hdHJpeFxuICAgIHJldHVybiBuZXcgRGVuc2VNYXRyaXgoe1xuICAgICAgZGF0YTogYyxcbiAgICAgIHNpemU6IFthcm93cywgYmNvbHVtbnNdLFxuICAgICAgZGF0YXR5cGU6IGR0XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEMgPSBBICogQlxuICAgKlxuICAgKiBAcGFyYW0ge01hdHJpeH0gYSAgICAgICAgICAgIERlbnNlTWF0cml4ICAgIChNeE4pXG4gICAqIEBwYXJhbSB7TWF0cml4fSBiICAgICAgICAgICAgU3BhcnNlTWF0cml4ICAgKE54QylcbiAgICpcbiAgICogQHJldHVybiB7TWF0cml4fSAgICAgICAgICAgICBTcGFyc2VNYXRyaXggICAoTXhDKVxuICAgKi9cbiAgdmFyIF9tdWx0aXBseURlbnNlTWF0cml4U3BhcnNlTWF0cml4ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAvLyBhIGRlbnNlXG4gICAgdmFyIGFkYXRhID0gYS5fZGF0YTtcbiAgICB2YXIgYXNpemUgPSBhLl9zaXplO1xuICAgIHZhciBhZHQgPSBhLl9kYXRhdHlwZTtcbiAgICAvLyBiIHNwYXJzZVxuICAgIHZhciBidmFsdWVzID0gYi5fdmFsdWVzO1xuICAgIHZhciBiaW5kZXggPSBiLl9pbmRleDtcbiAgICB2YXIgYnB0ciA9IGIuX3B0cjtcbiAgICB2YXIgYnNpemUgPSBiLl9zaXplO1xuICAgIHZhciBiZHQgPSBiLl9kYXRhdHlwZTtcbiAgICAvLyB2YWxpZGF0ZSBiIG1hdHJpeFxuICAgIGlmICghYnZhbHVlcylcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IG11bHRpcGx5IERlbnNlIE1hdHJpeCB0aW1lcyBQYXR0ZXJuIG9ubHkgTWF0cml4Jyk7XG4gICAgLy8gcm93cyAmIGNvbHVtbnNcbiAgICB2YXIgYXJvd3MgPSBhc2l6ZVswXTtcbiAgICB2YXIgYmNvbHVtbnMgPSBic2l6ZVsxXTtcbiAgICBcbiAgICAvLyBkYXRhdHlwZVxuICAgIHZhciBkdDtcbiAgICAvLyBhZGRTY2FsYXIgc2lnbmF0dXJlIHRvIHVzZVxuICAgIHZhciBhZiA9IGFkZFNjYWxhcjtcbiAgICAvLyBtdWx0aXBseVNjYWxhciBzaWduYXR1cmUgdG8gdXNlXG4gICAgdmFyIG1mID0gbXVsdGlwbHlTY2FsYXI7XG4gICAgLy8gZXF1YWxTY2FsYXIgc2lnbmF0dXJlIHRvIHVzZVxuICAgIHZhciBlcSA9IGVxdWFsU2NhbGFyO1xuICAgIC8vIHplcm8gdmFsdWVcbiAgICB2YXIgemVybyA9IDA7XG5cbiAgICAvLyBwcm9jZXNzIGRhdGEgdHlwZXNcbiAgICBpZiAoYWR0ICYmIGJkdCAmJiBhZHQgPT09IGJkdCAmJiB0eXBlb2YgYWR0ID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gZGF0YXR5cGVcbiAgICAgIGR0ID0gYWR0O1xuICAgICAgLy8gZmluZCBzaWduYXR1cmVzIHRoYXQgbWF0Y2hlcyAoZHQsIGR0KVxuICAgICAgYWYgPSB0eXBlZC5maW5kKGFkZFNjYWxhciwgW2R0LCBkdF0pO1xuICAgICAgbWYgPSB0eXBlZC5maW5kKG11bHRpcGx5U2NhbGFyLCBbZHQsIGR0XSk7XG4gICAgICBlcSA9IHR5cGVkLmZpbmQoZXF1YWxTY2FsYXIsIFtkdCwgZHRdKTtcbiAgICAgIC8vIGNvbnZlcnQgMCB0byB0aGUgc2FtZSBkYXRhdHlwZVxuICAgICAgemVybyA9IHR5cGVkLmNvbnZlcnQoMCwgZHQpO1xuICAgIH1cblxuICAgIC8vIHJlc3VsdFxuICAgIHZhciBjdmFsdWVzID0gW107XG4gICAgdmFyIGNpbmRleCA9IFtdO1xuICAgIHZhciBjcHRyID0gW107XG4gICAgLy8gYyBtYXRyaXhcbiAgICB2YXIgYyA9IG5ldyBTcGFyc2VNYXRyaXgoe1xuICAgICAgdmFsdWVzIDogY3ZhbHVlcyxcbiAgICAgIGluZGV4OiBjaW5kZXgsXG4gICAgICBwdHI6IGNwdHIsXG4gICAgICBzaXplOiBbYXJvd3MsIGJjb2x1bW5zXSxcbiAgICAgIGRhdGF0eXBlOiBkdFxuICAgIH0pO1xuXG4gICAgLy8gbG9vcCBiIGNvbHVtbnNcbiAgICBmb3IgKHZhciBqYiA9IDA7IGpiIDwgYmNvbHVtbnM7IGpiKyspIHtcbiAgICAgIC8vIHVwZGF0ZSBwdHJcbiAgICAgIGNwdHJbamJdID0gY2luZGV4Lmxlbmd0aDtcbiAgICAgIC8vIGluZGVjZXMgaW4gY29sdW1uIGpiXG4gICAgICB2YXIga2IwID0gYnB0cltqYl07XG4gICAgICB2YXIga2IxID0gYnB0cltqYiArIDFdO1xuICAgICAgLy8gZG8gbm90IHByb2Nlc3MgY29sdW1uIGpiIGlmIG5vIGRhdGEgZXhpc3RzXG4gICAgICBpZiAoa2IxID4ga2IwKSB7XG4gICAgICAgIC8vIGxhc3Qgcm93IG1hcmsgcHJvY2Vzc2VkXG4gICAgICAgIHZhciBsYXN0ID0gMDtcbiAgICAgICAgLy8gbG9vcCBhIHJvd3NcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcm93czsgaSsrKSB7XG4gICAgICAgICAgLy8gY29sdW1uIG1hcmtcbiAgICAgICAgICB2YXIgbWFyayA9IGkgKyAxO1xuICAgICAgICAgIC8vIENbaSwgamJdXG4gICAgICAgICAgdmFyIGNpajtcbiAgICAgICAgICAvLyB2YWx1ZXMgaW4gYiBjb2x1bW4galxuICAgICAgICAgIGZvciAodmFyIGtiID0ga2IwOyBrYiA8IGtiMTsga2IrKykge1xuICAgICAgICAgICAgLy8gcm93XG4gICAgICAgICAgICB2YXIgaWIgPSBiaW5kZXhba2JdO1xuICAgICAgICAgICAgLy8gY2hlY2sgdmFsdWUgaGFzIGJlZW4gaW5pdGlhbGl6ZWRcbiAgICAgICAgICAgIGlmIChsYXN0ICE9PSBtYXJrKSB7XG4gICAgICAgICAgICAgIC8vIGZpcnN0IHZhbHVlIGluIGNvbHVtbiBqYlxuICAgICAgICAgICAgICBjaWogPSBtZihhZGF0YVtpXVtpYl0sIGJ2YWx1ZXNba2JdKTtcbiAgICAgICAgICAgICAgLy8gdXBkYXRlIG1hcmtcbiAgICAgICAgICAgICAgbGFzdCA9IG1hcms7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gYWNjdW11bGF0ZSB2YWx1ZVxuICAgICAgICAgICAgICBjaWogPSBhZihjaWosIG1mKGFkYXRhW2ldW2liXSwgYnZhbHVlc1trYl0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gY2hlY2sgY29sdW1uIGhhcyBiZWVuIHByb2Nlc3NlZCBhbmQgdmFsdWUgIT0gMFxuICAgICAgICAgIGlmIChsYXN0ID09PSBtYXJrICYmICFlcShjaWosIHplcm8pKSB7XG4gICAgICAgICAgICAvLyBwdXNoIHJvdyAmIHZhbHVlXG4gICAgICAgICAgICBjaW5kZXgucHVzaChpKTtcbiAgICAgICAgICAgIGN2YWx1ZXMucHVzaChjaWopO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyB1cGRhdGUgcHRyXG4gICAgY3B0cltiY29sdW1uc10gPSBjaW5kZXgubGVuZ3RoO1xuXG4gICAgLy8gcmV0dXJuIHNwYXJzZSBtYXRyaXhcbiAgICByZXR1cm4gYztcbiAgfTtcblxuICAvKipcbiAgICogQyA9IEEgKiBCXG4gICAqXG4gICAqIEBwYXJhbSB7TWF0cml4fSBhICAgICAgICAgICAgU3BhcnNlTWF0cml4ICAgIChNeE4pXG4gICAqIEBwYXJhbSB7TWF0cml4fSBiICAgICAgICAgICAgRGVuc2UgVmVjdG9yIChOKVxuICAgKlxuICAgKiBAcmV0dXJuIHtNYXRyaXh9ICAgICAgICAgICAgIFNwYXJzZU1hdHJpeCAgICAoTSwgMSkgXG4gICAqL1xuICB2YXIgX211bHRpcGx5U3BhcnNlTWF0cml4VmVjdG9yID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAvLyBhIHNwYXJzZVxuICAgIHZhciBhdmFsdWVzID0gYS5fdmFsdWVzO1xuICAgIHZhciBhaW5kZXggPSBhLl9pbmRleDtcbiAgICB2YXIgYXB0ciA9IGEuX3B0cjtcbiAgICB2YXIgYWR0ID0gYS5fZGF0YXR5cGU7XG4gICAgLy8gdmFsaWRhdGUgYSBtYXRyaXhcbiAgICBpZiAoIWF2YWx1ZXMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBtdWx0aXBseSBQYXR0ZXJuIG9ubHkgTWF0cml4IHRpbWVzIERlbnNlIE1hdHJpeCcpO1xuICAgIC8vIGIgZGVuc2VcbiAgICB2YXIgYmRhdGEgPSBiLl9kYXRhO1xuICAgIHZhciBiZHQgPSBiLl9kYXRhdHlwZTtcbiAgICAvLyByb3dzICYgY29sdW1uc1xuICAgIHZhciBhcm93cyA9IGEuX3NpemVbMF07XG4gICAgdmFyIGJyb3dzID0gYi5fc2l6ZVswXTtcbiAgICAvLyByZXN1bHRcbiAgICB2YXIgY3ZhbHVlcyA9IFtdO1xuICAgIHZhciBjaW5kZXggPSBbXTtcbiAgICB2YXIgY3B0ciA9IFtdO1xuICAgIFxuICAgIC8vIGRhdGF0eXBlXG4gICAgdmFyIGR0O1xuICAgIC8vIGFkZFNjYWxhciBzaWduYXR1cmUgdG8gdXNlXG4gICAgdmFyIGFmID0gYWRkU2NhbGFyO1xuICAgIC8vIG11bHRpcGx5U2NhbGFyIHNpZ25hdHVyZSB0byB1c2VcbiAgICB2YXIgbWYgPSBtdWx0aXBseVNjYWxhcjtcbiAgICAvLyBlcXVhbFNjYWxhciBzaWduYXR1cmUgdG8gdXNlXG4gICAgdmFyIGVxID0gZXF1YWxTY2FsYXI7XG4gICAgLy8gemVybyB2YWx1ZVxuICAgIHZhciB6ZXJvID0gMDtcblxuICAgIC8vIHByb2Nlc3MgZGF0YSB0eXBlc1xuICAgIGlmIChhZHQgJiYgYmR0ICYmIGFkdCA9PT0gYmR0ICYmIHR5cGVvZiBhZHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBkYXRhdHlwZVxuICAgICAgZHQgPSBhZHQ7XG4gICAgICAvLyBmaW5kIHNpZ25hdHVyZXMgdGhhdCBtYXRjaGVzIChkdCwgZHQpXG4gICAgICBhZiA9IHR5cGVkLmZpbmQoYWRkU2NhbGFyLCBbZHQsIGR0XSk7XG4gICAgICBtZiA9IHR5cGVkLmZpbmQobXVsdGlwbHlTY2FsYXIsIFtkdCwgZHRdKTtcbiAgICAgIGVxID0gdHlwZWQuZmluZChlcXVhbFNjYWxhciwgW2R0LCBkdF0pO1xuICAgICAgLy8gY29udmVydCAwIHRvIHRoZSBzYW1lIGRhdGF0eXBlXG4gICAgICB6ZXJvID0gdHlwZWQuY29udmVydCgwLCBkdCk7XG4gICAgfVxuXG4gICAgLy8gd29ya3NwYWNlXG4gICAgdmFyIHggPSBbXTtcbiAgICAvLyB2ZWN0b3Igd2l0aCBtYXJrcyBpbmRpY2F0aW5nIGEgdmFsdWUgeFtpXSBleGlzdHMgaW4gYSBnaXZlbiBjb2x1bW5cbiAgICB2YXIgdyA9IFtdO1xuXG4gICAgLy8gdXBkYXRlIHB0clxuICAgIGNwdHJbMF0gPSAwO1xuICAgIC8vIHJvd3MgaW4gYlxuICAgIGZvciAodmFyIGliID0gMDsgaWIgPCBicm93czsgaWIrKykge1xuICAgICAgLy8gYltpYl1cbiAgICAgIHZhciB2YmkgPSBiZGF0YVtpYl07XG4gICAgICAvLyBjaGVjayBiW2liXSAhPSAwLCBhdm9pZCBsb29wc1xuICAgICAgaWYgKCFlcSh2YmksIHplcm8pKSB7XG4gICAgICAgIC8vIEEgdmFsdWVzICYgaW5kZXggaW4gaWIgY29sdW1uXG4gICAgICAgIGZvciAodmFyIGthMCA9IGFwdHJbaWJdLCBrYTEgPSBhcHRyW2liICsgMV0sIGthID0ga2EwOyBrYSA8IGthMTsga2ErKykge1xuICAgICAgICAgIC8vIGEgcm93XG4gICAgICAgICAgdmFyIGlhID0gYWluZGV4W2thXTtcbiAgICAgICAgICAvLyBjaGVjayB2YWx1ZSBleGlzdHMgaW4gY3VycmVudCBqXG4gICAgICAgICAgaWYgKCF3W2lhXSkge1xuICAgICAgICAgICAgLy8gaWEgaXMgbmV3IGVudHJ5IGluIGpcbiAgICAgICAgICAgIHdbaWFdID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIGFkZCBpIHRvIHBhdHRlcm4gb2YgQ1xuICAgICAgICAgICAgY2luZGV4LnB1c2goaWEpO1xuICAgICAgICAgICAgLy8geChpYSkgPSBBXG4gICAgICAgICAgICB4W2lhXSA9IG1mKHZiaSwgYXZhbHVlc1trYV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGkgZXhpc3RzIGluIEMgYWxyZWFkeVxuICAgICAgICAgICAgeFtpYV0gPSBhZih4W2lhXSwgbWYodmJpLCBhdmFsdWVzW2thXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBjb3B5IHZhbHVlcyBmcm9tIHggdG8gY29sdW1uIGpiIG9mIGNcbiAgICBmb3IgKHZhciBwMSA9IGNpbmRleC5sZW5ndGgsIHAgPSAwOyBwIDwgcDE7IHArKykge1xuICAgICAgLy8gcm93XG4gICAgICB2YXIgaWMgPSBjaW5kZXhbcF07XG4gICAgICAvLyBjb3B5IHZhbHVlXG4gICAgICBjdmFsdWVzW3BdID0geFtpY107XG4gICAgfVxuICAgIC8vIHVwZGF0ZSBwdHJcbiAgICBjcHRyWzFdID0gY2luZGV4Lmxlbmd0aDtcblxuICAgIC8vIHJldHVybiBzcGFyc2UgbWF0cml4XG4gICAgcmV0dXJuIG5ldyBTcGFyc2VNYXRyaXgoe1xuICAgICAgdmFsdWVzIDogY3ZhbHVlcyxcbiAgICAgIGluZGV4OiBjaW5kZXgsXG4gICAgICBwdHI6IGNwdHIsXG4gICAgICBzaXplOiBbYXJvd3MsIDFdLFxuICAgICAgZGF0YXR5cGU6IGR0XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEMgPSBBICogQlxuICAgKlxuICAgKiBAcGFyYW0ge01hdHJpeH0gYSAgICAgICAgICAgIFNwYXJzZU1hdHJpeCAgICAgIChNeE4pXG4gICAqIEBwYXJhbSB7TWF0cml4fSBiICAgICAgICAgICAgRGVuc2VNYXRyaXggICAgICAgKE54QylcbiAgICpcbiAgICogQHJldHVybiB7TWF0cml4fSAgICAgICAgICAgICBTcGFyc2VNYXRyaXggICAgICAoTXhDKVxuICAgKi9cbiAgdmFyIF9tdWx0aXBseVNwYXJzZU1hdHJpeERlbnNlTWF0cml4ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAvLyBhIHNwYXJzZVxuICAgIHZhciBhdmFsdWVzID0gYS5fdmFsdWVzO1xuICAgIHZhciBhaW5kZXggPSBhLl9pbmRleDtcbiAgICB2YXIgYXB0ciA9IGEuX3B0cjtcbiAgICB2YXIgYWR0ID0gYS5fZGF0YXR5cGU7XG4gICAgLy8gdmFsaWRhdGUgYSBtYXRyaXhcbiAgICBpZiAoIWF2YWx1ZXMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBtdWx0aXBseSBQYXR0ZXJuIG9ubHkgTWF0cml4IHRpbWVzIERlbnNlIE1hdHJpeCcpO1xuICAgIC8vIGIgZGVuc2VcbiAgICB2YXIgYmRhdGEgPSBiLl9kYXRhO1xuICAgIHZhciBiZHQgPSBiLl9kYXRhdHlwZTtcbiAgICAvLyByb3dzICYgY29sdW1uc1xuICAgIHZhciBhcm93cyA9IGEuX3NpemVbMF07XG4gICAgdmFyIGJyb3dzID0gYi5fc2l6ZVswXTtcbiAgICB2YXIgYmNvbHVtbnMgPSBiLl9zaXplWzFdO1xuXG4gICAgLy8gZGF0YXR5cGVcbiAgICB2YXIgZHQ7XG4gICAgLy8gYWRkU2NhbGFyIHNpZ25hdHVyZSB0byB1c2VcbiAgICB2YXIgYWYgPSBhZGRTY2FsYXI7XG4gICAgLy8gbXVsdGlwbHlTY2FsYXIgc2lnbmF0dXJlIHRvIHVzZVxuICAgIHZhciBtZiA9IG11bHRpcGx5U2NhbGFyO1xuICAgIC8vIGVxdWFsU2NhbGFyIHNpZ25hdHVyZSB0byB1c2VcbiAgICB2YXIgZXEgPSBlcXVhbFNjYWxhcjtcbiAgICAvLyB6ZXJvIHZhbHVlXG4gICAgdmFyIHplcm8gPSAwO1xuXG4gICAgLy8gcHJvY2VzcyBkYXRhIHR5cGVzXG4gICAgaWYgKGFkdCAmJiBiZHQgJiYgYWR0ID09PSBiZHQgJiYgdHlwZW9mIGFkdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIGRhdGF0eXBlXG4gICAgICBkdCA9IGFkdDtcbiAgICAgIC8vIGZpbmQgc2lnbmF0dXJlcyB0aGF0IG1hdGNoZXMgKGR0LCBkdClcbiAgICAgIGFmID0gdHlwZWQuZmluZChhZGRTY2FsYXIsIFtkdCwgZHRdKTtcbiAgICAgIG1mID0gdHlwZWQuZmluZChtdWx0aXBseVNjYWxhciwgW2R0LCBkdF0pO1xuICAgICAgZXEgPSB0eXBlZC5maW5kKGVxdWFsU2NhbGFyLCBbZHQsIGR0XSk7XG4gICAgICAvLyBjb252ZXJ0IDAgdG8gdGhlIHNhbWUgZGF0YXR5cGVcbiAgICAgIHplcm8gPSB0eXBlZC5jb252ZXJ0KDAsIGR0KTtcbiAgICB9XG5cbiAgICAvLyByZXN1bHRcbiAgICB2YXIgY3ZhbHVlcyA9IFtdO1xuICAgIHZhciBjaW5kZXggPSBbXTtcbiAgICB2YXIgY3B0ciA9IFtdO1xuICAgIC8vIGMgbWF0cml4XG4gICAgdmFyIGMgPSBuZXcgU3BhcnNlTWF0cml4KHtcbiAgICAgIHZhbHVlcyA6IGN2YWx1ZXMsXG4gICAgICBpbmRleDogY2luZGV4LFxuICAgICAgcHRyOiBjcHRyLFxuICAgICAgc2l6ZTogW2Fyb3dzLCBiY29sdW1uc10sXG4gICAgICBkYXRhdHlwZTogZHRcbiAgICB9KTtcblxuICAgIC8vIHdvcmtzcGFjZVxuICAgIHZhciB4ID0gW107XG4gICAgLy8gdmVjdG9yIHdpdGggbWFya3MgaW5kaWNhdGluZyBhIHZhbHVlIHhbaV0gZXhpc3RzIGluIGEgZ2l2ZW4gY29sdW1uXG4gICAgdmFyIHcgPSBbXTtcblxuICAgIC8vIGxvb3AgYiBjb2x1bW5zXG4gICAgZm9yICh2YXIgamIgPSAwOyBqYiA8IGJjb2x1bW5zOyBqYisrKSB7XG4gICAgICAvLyB1cGRhdGUgcHRyXG4gICAgICBjcHRyW2piXSA9IGNpbmRleC5sZW5ndGg7XG4gICAgICAvLyBtYXJrIGluIHdvcmtzcGFjZSBmb3IgY3VycmVudCBjb2x1bW5cbiAgICAgIHZhciBtYXJrID0gamIgKyAxO1xuICAgICAgLy8gcm93cyBpbiBqYlxuICAgICAgZm9yICh2YXIgaWIgPSAwOyBpYiA8IGJyb3dzOyBpYisrKSB7XG4gICAgICAgIC8vIGJbaWIsIGpiXVxuICAgICAgICB2YXIgdmJpaiA9IGJkYXRhW2liXVtqYl07XG4gICAgICAgIC8vIGNoZWNrIGJbaWIsIGpiXSAhPSAwLCBhdm9pZCBsb29wc1xuICAgICAgICBpZiAoIWVxKHZiaWosIHplcm8pKSB7XG4gICAgICAgICAgLy8gQSB2YWx1ZXMgJiBpbmRleCBpbiBpYiBjb2x1bW5cbiAgICAgICAgICBmb3IgKHZhciBrYTAgPSBhcHRyW2liXSwga2ExID0gYXB0cltpYiArIDFdLCBrYSA9IGthMDsga2EgPCBrYTE7IGthKyspIHtcbiAgICAgICAgICAgIC8vIGEgcm93XG4gICAgICAgICAgICB2YXIgaWEgPSBhaW5kZXhba2FdO1xuICAgICAgICAgICAgLy8gY2hlY2sgdmFsdWUgZXhpc3RzIGluIGN1cnJlbnQgalxuICAgICAgICAgICAgaWYgKHdbaWFdICE9PSBtYXJrKSB7XG4gICAgICAgICAgICAgIC8vIGlhIGlzIG5ldyBlbnRyeSBpbiBqXG4gICAgICAgICAgICAgIHdbaWFdID0gbWFyaztcbiAgICAgICAgICAgICAgLy8gYWRkIGkgdG8gcGF0dGVybiBvZiBDXG4gICAgICAgICAgICAgIGNpbmRleC5wdXNoKGlhKTtcbiAgICAgICAgICAgICAgLy8geChpYSkgPSBBXG4gICAgICAgICAgICAgIHhbaWFdID0gbWYodmJpaiwgYXZhbHVlc1trYV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGkgZXhpc3RzIGluIEMgYWxyZWFkeVxuICAgICAgICAgICAgICB4W2lhXSA9IGFmKHhbaWFdLCBtZih2YmlqLCBhdmFsdWVzW2thXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gY29weSB2YWx1ZXMgZnJvbSB4IHRvIGNvbHVtbiBqYiBvZiBjXG4gICAgICBmb3IgKHZhciBwMCA9IGNwdHJbamJdLCBwMSA9IGNpbmRleC5sZW5ndGgsIHAgPSBwMDsgcCA8IHAxOyBwKyspIHtcbiAgICAgICAgLy8gcm93XG4gICAgICAgIHZhciBpYyA9IGNpbmRleFtwXTtcbiAgICAgICAgLy8gY29weSB2YWx1ZVxuICAgICAgICBjdmFsdWVzW3BdID0geFtpY107XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVwZGF0ZSBwdHJcbiAgICBjcHRyW2Jjb2x1bW5zXSA9IGNpbmRleC5sZW5ndGg7XG5cbiAgICAvLyByZXR1cm4gc3BhcnNlIG1hdHJpeFxuICAgIHJldHVybiBjO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDID0gQSAqIEJcbiAgICpcbiAgICogQHBhcmFtIHtNYXRyaXh9IGEgICAgICAgICAgICBTcGFyc2VNYXRyaXggICAgICAoTXhOKVxuICAgKiBAcGFyYW0ge01hdHJpeH0gYiAgICAgICAgICAgIFNwYXJzZU1hdHJpeCAgICAgIChOeEMpXG4gICAqXG4gICAqIEByZXR1cm4ge01hdHJpeH0gICAgICAgICAgICAgU3BhcnNlTWF0cml4ICAgICAgKE14QylcbiAgICovXG4gIHZhciBfbXVsdGlwbHlTcGFyc2VNYXRyaXhTcGFyc2VNYXRyaXggPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIC8vIGEgc3BhcnNlXG4gICAgdmFyIGF2YWx1ZXMgPSBhLl92YWx1ZXM7XG4gICAgdmFyIGFpbmRleCA9IGEuX2luZGV4O1xuICAgIHZhciBhcHRyID0gYS5fcHRyO1xuICAgIHZhciBhZHQgPSBhLl9kYXRhdHlwZTtcbiAgICAvLyBiIHNwYXJzZVxuICAgIHZhciBidmFsdWVzID0gYi5fdmFsdWVzO1xuICAgIHZhciBiaW5kZXggPSBiLl9pbmRleDtcbiAgICB2YXIgYnB0ciA9IGIuX3B0cjtcbiAgICB2YXIgYmR0ID0gYi5fZGF0YXR5cGU7XG4gICAgXG4gICAgLy8gcm93cyAmIGNvbHVtbnNcbiAgICB2YXIgYXJvd3MgPSBhLl9zaXplWzBdO1xuICAgIHZhciBiY29sdW1ucyA9IGIuX3NpemVbMV07XG4gICAgLy8gZmxhZyBpbmRpY2F0aW5nIGJvdGggbWF0cmljZXMgKGEgJiBiKSBjb250YWluIGRhdGFcbiAgICB2YXIgdmFsdWVzID0gYXZhbHVlcyAmJiBidmFsdWVzO1xuXG4gICAgLy8gZGF0YXR5cGVcbiAgICB2YXIgZHQ7XG4gICAgLy8gYWRkU2NhbGFyIHNpZ25hdHVyZSB0byB1c2VcbiAgICB2YXIgYWYgPSBhZGRTY2FsYXI7XG4gICAgLy8gbXVsdGlwbHlTY2FsYXIgc2lnbmF0dXJlIHRvIHVzZVxuICAgIHZhciBtZiA9IG11bHRpcGx5U2NhbGFyO1xuXG4gICAgLy8gcHJvY2VzcyBkYXRhIHR5cGVzXG4gICAgaWYgKGFkdCAmJiBiZHQgJiYgYWR0ID09PSBiZHQgJiYgdHlwZW9mIGFkdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIGRhdGF0eXBlXG4gICAgICBkdCA9IGFkdDtcbiAgICAgIC8vIGZpbmQgc2lnbmF0dXJlcyB0aGF0IG1hdGNoZXMgKGR0LCBkdClcbiAgICAgIGFmID0gdHlwZWQuZmluZChhZGRTY2FsYXIsIFtkdCwgZHRdKTtcbiAgICAgIG1mID0gdHlwZWQuZmluZChtdWx0aXBseVNjYWxhciwgW2R0LCBkdF0pO1xuICAgIH1cbiAgICBcbiAgICAvLyByZXN1bHRcbiAgICB2YXIgY3ZhbHVlcyA9IHZhbHVlcyA/IFtdIDogdW5kZWZpbmVkO1xuICAgIHZhciBjaW5kZXggPSBbXTtcbiAgICB2YXIgY3B0ciA9IFtdO1xuICAgIC8vIGMgbWF0cml4XG4gICAgdmFyIGMgPSBuZXcgU3BhcnNlTWF0cml4KHtcbiAgICAgIHZhbHVlcyA6IGN2YWx1ZXMsXG4gICAgICBpbmRleDogY2luZGV4LFxuICAgICAgcHRyOiBjcHRyLFxuICAgICAgc2l6ZTogW2Fyb3dzLCBiY29sdW1uc10sXG4gICAgICBkYXRhdHlwZTogZHRcbiAgICB9KTtcblxuICAgIC8vIHdvcmtzcGFjZVxuICAgIHZhciB4ID0gdmFsdWVzID8gW10gOiB1bmRlZmluZWQ7XG4gICAgLy8gdmVjdG9yIHdpdGggbWFya3MgaW5kaWNhdGluZyBhIHZhbHVlIHhbaV0gZXhpc3RzIGluIGEgZ2l2ZW4gY29sdW1uXG4gICAgdmFyIHcgPSBbXTtcbiAgICAvLyB2YXJpYWJsZXNcbiAgICB2YXIga2EsIGthMCwga2ExLCBrYiwga2IwLCBrYjEsIGlhLCBpYjtcbiAgICAvLyBsb29wIGIgY29sdW1uc1xuICAgIGZvciAodmFyIGpiID0gMDsgamIgPCBiY29sdW1uczsgamIrKykge1xuICAgICAgLy8gdXBkYXRlIHB0clxuICAgICAgY3B0cltqYl0gPSBjaW5kZXgubGVuZ3RoO1xuICAgICAgLy8gbWFyayBpbiB3b3Jrc3BhY2UgZm9yIGN1cnJlbnQgY29sdW1uXG4gICAgICB2YXIgbWFyayA9IGpiICsgMTtcbiAgICAgIC8vIEIgdmFsdWVzICYgaW5kZXggaW4galxuICAgICAgZm9yIChrYjAgPSBicHRyW2piXSwga2IxID0gYnB0cltqYiArIDFdLCBrYiA9IGtiMDsga2IgPCBrYjE7IGtiKyspIHtcbiAgICAgICAgLy8gYiByb3dcbiAgICAgICAgaWIgPSBiaW5kZXhba2JdO1xuICAgICAgICAvLyBjaGVjayB3ZSBuZWVkIHRvIHByb2Nlc3MgdmFsdWVzXG4gICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICAvLyBsb29wIHZhbHVlcyBpbiBhWzosaWJdXG4gICAgICAgICAgZm9yIChrYTAgPSBhcHRyW2liXSwga2ExID0gYXB0cltpYiArIDFdLCBrYSA9IGthMDsga2EgPCBrYTE7IGthKyspIHtcbiAgICAgICAgICAgIC8vIHJvd1xuICAgICAgICAgICAgaWEgPSBhaW5kZXhba2FdO1xuICAgICAgICAgICAgLy8gY2hlY2sgdmFsdWUgZXhpc3RzIGluIGN1cnJlbnQgalxuICAgICAgICAgICAgaWYgKHdbaWFdICE9PSBtYXJrKSB7XG4gICAgICAgICAgICAgIC8vIGlhIGlzIG5ldyBlbnRyeSBpbiBqXG4gICAgICAgICAgICAgIHdbaWFdID0gbWFyaztcbiAgICAgICAgICAgICAgLy8gYWRkIGkgdG8gcGF0dGVybiBvZiBDXG4gICAgICAgICAgICAgIGNpbmRleC5wdXNoKGlhKTtcbiAgICAgICAgICAgICAgLy8geChpYSkgPSBBXG4gICAgICAgICAgICAgIHhbaWFdID0gbWYoYnZhbHVlc1trYl0sIGF2YWx1ZXNba2FdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLyBpIGV4aXN0cyBpbiBDIGFscmVhZHlcbiAgICAgICAgICAgICAgeFtpYV0gPSBhZih4W2lhXSwgbWYoYnZhbHVlc1trYl0sIGF2YWx1ZXNba2FdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIGxvb3AgdmFsdWVzIGluIGFbOixpYl1cbiAgICAgICAgICBmb3IgKGthMCA9IGFwdHJbaWJdLCBrYTEgPSBhcHRyW2liICsgMV0sIGthID0ga2EwOyBrYSA8IGthMTsga2ErKykge1xuICAgICAgICAgICAgLy8gcm93XG4gICAgICAgICAgICBpYSA9IGFpbmRleFtrYV07XG4gICAgICAgICAgICAvLyBjaGVjayB2YWx1ZSBleGlzdHMgaW4gY3VycmVudCBqXG4gICAgICAgICAgICBpZiAod1tpYV0gIT09IG1hcmspIHtcbiAgICAgICAgICAgICAgLy8gaWEgaXMgbmV3IGVudHJ5IGluIGpcbiAgICAgICAgICAgICAgd1tpYV0gPSBtYXJrO1xuICAgICAgICAgICAgICAvLyBhZGQgaSB0byBwYXR0ZXJuIG9mIENcbiAgICAgICAgICAgICAgY2luZGV4LnB1c2goaWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gY2hlY2sgd2UgbmVlZCB0byBwcm9jZXNzIG1hdHJpeCB2YWx1ZXMgKHBhdHRlcm4gbWF0cml4KVxuICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICAvLyBjb3B5IHZhbHVlcyBmcm9tIHggdG8gY29sdW1uIGpiIG9mIGNcbiAgICAgICAgZm9yICh2YXIgcDAgPSBjcHRyW2piXSwgcDEgPSBjaW5kZXgubGVuZ3RoLCBwID0gcDA7IHAgPCBwMTsgcCsrKSB7XG4gICAgICAgICAgLy8gcm93XG4gICAgICAgICAgdmFyIGljID0gY2luZGV4W3BdO1xuICAgICAgICAgIC8vIGNvcHkgdmFsdWVcbiAgICAgICAgICBjdmFsdWVzW3BdID0geFtpY107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdXBkYXRlIHB0clxuICAgIGNwdHJbYmNvbHVtbnNdID0gY2luZGV4Lmxlbmd0aDtcblxuICAgIC8vIHJldHVybiBzcGFyc2UgbWF0cml4XG4gICAgcmV0dXJuIGM7XG4gIH07XG5cbiAgbXVsdGlwbHkudG9UZXggPSAnXFxcXGxlZnQoJHthcmdzWzBdfScgKyBsYXRleC5vcGVyYXRvcnNbJ211bHRpcGx5J10gKyAnJHthcmdzWzFdfVxcXFxyaWdodCknO1xuXG4gIHJldHVybiBtdWx0aXBseTtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ211bHRpcGx5JztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGZhY3RvcnkodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICBcbiAgLyoqXG4gICAqIE11bHRpcGx5IHR3byBzY2FsYXIgdmFsdWVzLCBgeCAqIHlgLlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIG1lYW50IGZvciBpbnRlcm5hbCB1c2U6IGl0IGlzIHVzZWQgYnkgdGhlIHB1YmxpYyBmdW5jdGlvblxuICAgKiBgbXVsdGlwbHlgXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3Qgc3VwcG9ydCBjb2xsZWN0aW9ucyAoQXJyYXkgb3IgTWF0cml4KSwgYW5kIGRvZXNcbiAgICogbm90IHZhbGlkYXRlIHRoZSBudW1iZXIgb2Ygb2YgaW5wdXRzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IENvbXBsZXggfCBVbml0fSB4ICAgRmlyc3QgdmFsdWUgdG8gbXVsdGlwbHlcbiAgICogQHBhcmFtICB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb24gfCBDb21wbGV4fSB5ICAgICAgICAgIFNlY29uZCB2YWx1ZSB0byBtdWx0aXBseVxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IENvbXBsZXggfCBVbml0fSAgICAgICAgICAgICAgICAgICAgICBNdWx0aXBsaWNhdGlvbiBvZiBgeGAgYW5kIGB5YFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdmFyIG11bHRpcGx5U2NhbGFyID0gdHlwZWQoJ211bHRpcGx5U2NhbGFyJywge1xuXG4gICAgJ251bWJlciwgbnVtYmVyJzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHJldHVybiB4ICogeTtcbiAgICB9LFxuXG4gICAgJ0NvbXBsZXgsIENvbXBsZXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIHgubXVsKHkpO1xuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyLCBCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIHgudGltZXMoeSk7XG4gICAgfSxcblxuICAgICdGcmFjdGlvbiwgRnJhY3Rpb24nOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIHgubXVsKHkpO1xuICAgIH0sXG5cbiAgICAnbnVtYmVyIHwgRnJhY3Rpb24gfCBCaWdOdW1iZXIgfCBDb21wbGV4LCBVbml0JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHZhciByZXMgPSB5LmNsb25lKCk7XG4gICAgICByZXMudmFsdWUgPSAocmVzLnZhbHVlID09PSBudWxsKSA/IHJlcy5fbm9ybWFsaXplKHgpIDogbXVsdGlwbHlTY2FsYXIocmVzLnZhbHVlLCB4KTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSxcblxuICAgICdVbml0LCBudW1iZXIgfCBGcmFjdGlvbiB8IEJpZ051bWJlciB8IENvbXBsZXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgdmFyIHJlcyA9IHguY2xvbmUoKTtcbiAgICAgIHJlcy52YWx1ZSA9IChyZXMudmFsdWUgPT09IG51bGwpID8gcmVzLl9ub3JtYWxpemUoeSkgOiBtdWx0aXBseVNjYWxhcihyZXMudmFsdWUsIHkpO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuXG4gICAgJ1VuaXQsIFVuaXQnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIHgubXVsdGlwbHkoeSk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIHJldHVybiBtdWx0aXBseVNjYWxhcjtcbn1cblxuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICBcbiAgdmFyIGFicyAgICAgICAgID0gbG9hZChyZXF1aXJlKCcuLi9hcml0aG1ldGljL2FicycpKTtcbiAgdmFyIGFkZCAgICAgICAgID0gbG9hZChyZXF1aXJlKCcuLi9hcml0aG1ldGljL2FkZCcpKTtcbiAgdmFyIHBvdyAgICAgICAgID0gbG9hZChyZXF1aXJlKCcuLi9hcml0aG1ldGljL3BvdycpKTtcbiAgdmFyIHNxcnQgICAgICAgID0gbG9hZChyZXF1aXJlKCcuLi9hcml0aG1ldGljL3NxcnQnKSk7XG4gIHZhciBtdWx0aXBseSAgICA9IGxvYWQocmVxdWlyZSgnLi4vYXJpdGhtZXRpYy9tdWx0aXBseScpKTtcbiAgdmFyIGVxdWFsU2NhbGFyID0gbG9hZChyZXF1aXJlKCcuLi9yZWxhdGlvbmFsL2VxdWFsU2NhbGFyJykpO1xuICB2YXIgbGFyZ2VyICAgICAgPSBsb2FkKHJlcXVpcmUoJy4uL3JlbGF0aW9uYWwvbGFyZ2VyJykpO1xuICB2YXIgc21hbGxlciAgICAgPSBsb2FkKHJlcXVpcmUoJy4uL3JlbGF0aW9uYWwvc21hbGxlcicpKTtcbiAgdmFyIG1hdHJpeCAgICAgID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC9mdW5jdGlvbi9tYXRyaXgnKSk7XG4gIHZhciB0cmFjZSAgICAgICA9IGxvYWQocmVxdWlyZSgnLi4vbWF0cml4L3RyYWNlJykpO1xuICB2YXIgdHJhbnNwb3NlICAgPSBsb2FkKHJlcXVpcmUoJy4uL21hdHJpeC90cmFuc3Bvc2UnKSk7XG5cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBub3JtIG9mIGEgbnVtYmVyLCB2ZWN0b3Igb3IgbWF0cml4LlxuICAgKlxuICAgKiBUaGUgc2Vjb25kIHBhcmFtZXRlciBwIGlzIG9wdGlvbmFsLiBJZiBub3QgcHJvdmlkZWQsIGl0IGRlZmF1bHRzIHRvIDIuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5ub3JtKHgpXG4gICAqICAgIG1hdGgubm9ybSh4LCBwKVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5hYnMoLTMuNSk7ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgMy41XG4gICAqICAgIG1hdGgubm9ybSgtMy41KTsgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIDMuNVxuICAgKlxuICAgKiAgICBtYXRoLm5vcm0obWF0aC5jb21wbGV4KDMsIC00KSk7ICAgICAgICAgLy8gcmV0dXJucyA1XG4gICAqXG4gICAqICAgIG1hdGgubm9ybShbMSwgMiwgLTNdLCBJbmZpbml0eSk7ICAgICAgICAvLyByZXR1cm5zIDNcbiAgICogICAgbWF0aC5ub3JtKFsxLCAyLCAtM10sIC1JbmZpbml0eSk7ICAgICAgIC8vIHJldHVybnMgMVxuICAgKlxuICAgKiAgICBtYXRoLm5vcm0oWzMsIDRdLCAyKTsgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyA1XG4gICAqXG4gICAqICAgIG1hdGgubm9ybShbWzEsIDJdLCBbMywgNF1dLCAxKSAgICAgICAgICAvLyByZXR1cm5zIDZcbiAgICogICAgbWF0aC5ub3JtKFtbMSwgMl0sIFszLCA0XV0sICdpbmYnKTsgICAgIC8vIHJldHVybnMgN1xuICAgKiAgICBtYXRoLm5vcm0oW1sxLCAyXSwgWzMsIDRdXSwgJ2ZybycpOyAgICAgLy8gcmV0dXJucyA1LjQ3NzIyNTU3NTA1MTY2MVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgYWJzLCBoeXBvdFxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9IHhcbiAgICogICAgICAgICAgICBWYWx1ZSBmb3Igd2hpY2ggdG8gY2FsY3VsYXRlIHRoZSBub3JtXG4gICAqIEBwYXJhbSAge251bWJlciB8IEJpZ051bWJlciB8IHN0cmluZ30gW3A9Ml1cbiAgICogICAgICAgICAgICBWZWN0b3Igc3BhY2UuXG4gICAqICAgICAgICAgICAgU3VwcG9ydGVkIG51bWJlcnMgaW5jbHVkZSBJbmZpbml0eSBhbmQgLUluZmluaXR5LlxuICAgKiAgICAgICAgICAgIFN1cHBvcnRlZCBzdHJpbmdzIGFyZTogJ2luZicsICctaW5mJywgYW5kICdmcm8nIChUaGUgRnJvYmVuaXVzIG5vcm0pXG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlcn0gdGhlIHAtbm9ybVxuICAgKi9cbiAgdmFyIG5vcm0gPSB0eXBlZCgnbm9ybScsIHtcbiAgICAnbnVtYmVyJzogTWF0aC5hYnMsXG5cbiAgICAnQ29tcGxleCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5hYnMoKTtcbiAgICB9LFxuXG4gICAgJ0JpZ051bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAvLyBub3JtKHgpID0gYWJzKHgpXG4gICAgICByZXR1cm4geC5hYnMoKTtcbiAgICB9LFxuICAgIFxuICAgICdib29sZWFuIHwgbnVsbCcgOiBmdW5jdGlvbiAoeCkge1xuICAgICAgLy8gbm9ybSh4KSA9IGFicyh4KVxuICAgICAgcmV0dXJuIE1hdGguYWJzKHgpO1xuICAgIH0sXG5cbiAgICAnQXJyYXknOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIF9ub3JtKG1hdHJpeCh4KSwgMik7XG4gICAgfSxcbiAgICBcbiAgICAnTWF0cml4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBfbm9ybSh4LCAyKTtcbiAgICB9LFxuXG4gICAgJ251bWJlciB8IENvbXBsZXggfCBCaWdOdW1iZXIgfCBib29sZWFuIHwgbnVsbCwgbnVtYmVyIHwgQmlnTnVtYmVyIHwgc3RyaW5nJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIC8vIGlnbm9yZSBzZWNvbmQgcGFyYW1ldGVyLCBUT0RPOiByZW1vdmUgdGhlIG9wdGlvbiBvZiBzZWNvbmQgcGFyYW1ldGVyIGZvciB0aGVzZSB0eXBlc1xuICAgICAgcmV0dXJuIG5vcm0oeCk7XG4gICAgfSxcblxuICAgICdBcnJheSwgbnVtYmVyIHwgQmlnTnVtYmVyIHwgc3RyaW5nJzogZnVuY3Rpb24gKHgsIHApIHtcbiAgICAgIHJldHVybiBfbm9ybShtYXRyaXgoeCksIHApO1xuICAgIH0sXG4gICAgXG4gICAgJ01hdHJpeCwgbnVtYmVyIHwgQmlnTnVtYmVyIHwgc3RyaW5nJzogZnVuY3Rpb24gKHgsIHApIHtcbiAgICAgIHJldHVybiBfbm9ybSh4LCBwKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIG5vcm0gZm9yIGFuIGFycmF5XG4gICAqIEBwYXJhbSB7QXJyYXl9IHhcbiAgICogQHBhcmFtIHtudW1iZXIgfCBzdHJpbmd9IHBcbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbm9ybVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX25vcm0gKHgsIHApIHtcbiAgICAvLyBzaXplXG4gICAgdmFyIHNpemVYID0geC5zaXplKCk7XG4gICAgXG4gICAgLy8gY2hlY2sgaWYgaXQgaXMgYSB2ZWN0b3JcbiAgICBpZiAoc2l6ZVgubGVuZ3RoID09IDEpIHtcbiAgICAgIC8vIGNoZWNrIHBcbiAgICAgIGlmIChwID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgfHwgcCA9PT0gJ2luZicpIHtcbiAgICAgICAgLy8gbm9ybSh4LCBJbmZpbml0eSkgPSBtYXgoYWJzKHgpKVxuICAgICAgICB2YXIgcGluZiA9IDA7XG4gICAgICAgIC8vIHNraXAgemVyb3Mgc2luY2UgYWJzKDApID09IDBcbiAgICAgICAgeC5mb3JFYWNoKFxuICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHYgPSBhYnModmFsdWUpO1xuICAgICAgICAgICAgaWYgKGxhcmdlcih2LCBwaW5mKSlcbiAgICAgICAgICAgICAgcGluZiA9IHY7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHBpbmY7XG4gICAgICB9XG4gICAgICBpZiAocCA9PT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZIHx8IHAgPT09ICctaW5mJykge1xuICAgICAgICAvLyBub3JtKHgsIC1JbmZpbml0eSkgPSBtaW4oYWJzKHgpKVxuICAgICAgICB2YXIgbmluZjtcbiAgICAgICAgLy8gc2tpcCB6ZXJvcyBzaW5jZSBhYnMoMCkgPT0gMFxuICAgICAgICB4LmZvckVhY2goXG4gICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgdiA9IGFicyh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoIW5pbmYgfHwgc21hbGxlcih2LCBuaW5mKSlcbiAgICAgICAgICAgICAgbmluZiA9IHY7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0cnVlKTtcbiAgICAgICAgcmV0dXJuIG5pbmYgfHwgMDtcbiAgICAgIH1cbiAgICAgIGlmIChwID09PSAnZnJvJykge1xuICAgICAgICByZXR1cm4gX25vcm0oeCwgMik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHAgPT09ICdudW1iZXInICYmICFpc05hTihwKSkge1xuICAgICAgICAvLyBjaGVjayBwICE9IDBcbiAgICAgICAgaWYgKCFlcXVhbFNjYWxhcihwLCAwKSkge1xuICAgICAgICAgIC8vIG5vcm0oeCwgcCkgPSBzdW0oYWJzKHhpKSBeIHApIF4gMS9wXG4gICAgICAgICAgdmFyIG4gPSAwO1xuICAgICAgICAgIC8vIHNraXAgemVyb3Mgc2luY2UgYWJzKDApID09IDBcbiAgICAgICAgICB4LmZvckVhY2goXG4gICAgICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgbiA9IGFkZChwb3coYWJzKHZhbHVlKSwgcCksIG4pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRydWUpO1xuICAgICAgICAgIHJldHVybiBwb3cobiwgMSAvIHApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICB9XG4gICAgICAvLyBpbnZhbGlkIHBhcmFtZXRlciB2YWx1ZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBwYXJhbWV0ZXIgdmFsdWUnKTtcbiAgICB9XG4gICAgLy8gTXhOIG1hdHJpeFxuICAgIGlmIChzaXplWC5sZW5ndGggPT0gMikge1xuICAgICAgLy8gY2hlY2sgcFxuICAgICAgaWYgKHAgPT09IDEpIHtcbiAgICAgICAgLy8gbm9ybSh4KSA9IHRoZSBsYXJnZXN0IGNvbHVtbiBzdW1cbiAgICAgICAgdmFyIGMgPSBbXTtcbiAgICAgICAgLy8gcmVzdWx0XG4gICAgICAgIHZhciBtYXhjID0gMDtcbiAgICAgICAgLy8gc2tpcCB6ZXJvcyBzaW5jZSBhYnMoMCkgPT0gMFxuICAgICAgICB4LmZvckVhY2goXG4gICAgICAgICAgZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIGogPSBpbmRleFsxXTtcbiAgICAgICAgICAgIHZhciBjaiA9IGFkZChjW2pdIHx8IDAsIGFicyh2YWx1ZSkpO1xuICAgICAgICAgICAgaWYgKGxhcmdlcihjaiwgbWF4YykpXG4gICAgICAgICAgICAgIG1heGMgPSBjajtcbiAgICAgICAgICAgIGNbal0gPSBjajtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRydWUpO1xuICAgICAgICByZXR1cm4gbWF4YztcbiAgICAgIH1cbiAgICAgIGlmIChwID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgfHwgcCA9PT0gJ2luZicpIHtcbiAgICAgICAgLy8gbm9ybSh4KSA9IHRoZSBsYXJnZXN0IHJvdyBzdW1cbiAgICAgICAgdmFyIHIgPSBbXTtcbiAgICAgICAgLy8gcmVzdWx0XG4gICAgICAgIHZhciBtYXhyID0gMDtcbiAgICAgICAgLy8gc2tpcCB6ZXJvcyBzaW5jZSBhYnMoMCkgPT0gMFxuICAgICAgICB4LmZvckVhY2goXG4gICAgICAgICAgZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIGkgPSBpbmRleFswXTtcbiAgICAgICAgICAgIHZhciByaSA9IGFkZChyW2ldIHx8IDAsIGFicyh2YWx1ZSkpO1xuICAgICAgICAgICAgaWYgKGxhcmdlcihyaSwgbWF4cikpXG4gICAgICAgICAgICAgIG1heHIgPSByaTtcbiAgICAgICAgICAgIHJbaV0gPSByaTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRydWUpO1xuICAgICAgICByZXR1cm4gbWF4cjtcbiAgICAgIH1cbiAgICAgIGlmIChwID09PSAnZnJvJykge1xuICAgICAgICAvLyBub3JtKHgpID0gc3FydChzdW0oZGlhZyh4J3gpKSlcbiAgICAgICAgcmV0dXJuIHNxcnQodHJhY2UobXVsdGlwbHkodHJhbnNwb3NlKHgpLCB4KSkpO1xuICAgICAgfVxuICAgICAgaWYgKHAgPT09IDIpIHtcbiAgICAgICAgLy8gbm90IGltcGxlbWVudGVkXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgcGFyYW1ldGVyIHZhbHVlLCBtaXNzaW5nIGltcGxlbWVudGF0aW9uIG9mIG1hdHJpeCBzaW5ndWxhciB2YWx1ZSBkZWNvbXBvc2l0aW9uJyk7XG4gICAgICB9XG4gICAgICAvLyBpbnZhbGlkIHBhcmFtZXRlciB2YWx1ZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBwYXJhbWV0ZXIgdmFsdWUnKTtcbiAgICB9XG4gIH1cblxuICBub3JtLnRvVGV4ID0ge1xuICAgIDE6ICdcXFxcbGVmdFxcXFx8JHthcmdzWzBdfVxcXFxyaWdodFxcXFx8JyxcbiAgICAyOiAnXFxcXG1hdGhybXske25hbWV9fVxcXFxsZWZ0KCR7YXJnc31cXFxccmlnaHQpJ1xuICB9O1xuXG4gIHJldHVybiBub3JtO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnbm9ybSc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG5cbiAgdmFyIG1hdHJpeCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvZnVuY3Rpb24vbWF0cml4JykpO1xuXG4gIHZhciBhbGdvcml0aG0wMSA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMDEnKSk7XG4gIHZhciBhbGdvcml0aG0wMiA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMDInKSk7XG4gIHZhciBhbGdvcml0aG0wNiA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMDYnKSk7XG4gIHZhciBhbGdvcml0aG0xMSA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMTEnKSk7XG4gIHZhciBhbGdvcml0aG0xMyA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMTMnKSk7XG4gIHZhciBhbGdvcml0aG0xNCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMTQnKSk7XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgbnRoIHJvb3Qgb2YgYSB2YWx1ZS5cbiAgICogVGhlIHByaW5jaXBhbCBudGggcm9vdCBvZiBhIHBvc2l0aXZlIHJlYWwgbnVtYmVyIEEsIGlzIHRoZSBwb3NpdGl2ZSByZWFsXG4gICAqIHNvbHV0aW9uIG9mIHRoZSBlcXVhdGlvblxuICAgKlxuICAgKiAgICAgeF5yb290ID0gQVxuICAgKlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgICBtYXRoLm50aFJvb3QoYSlcbiAgICogICAgIG1hdGgubnRoUm9vdChhLCByb290KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgIG1hdGgubnRoUm9vdCg5LCAyKTsgICAgLy8gcmV0dXJucyAzLCBhcyAzXjIgPT0gOVxuICAgKiAgICAgbWF0aC5zcXJ0KDkpOyAgICAgICAgICAvLyByZXR1cm5zIDMsIGFzIDNeMiA9PSA5XG4gICAqICAgICBtYXRoLm50aFJvb3QoNjQsIDMpOyAgIC8vIHJldHVybnMgNCwgYXMgNF4zID09IDY0XG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICAgc3FydCwgcG93XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgQXJyYXkgfCBNYXRyaXggfCBDb21wbGV4fSBhXG4gICAqICAgICAgICAgICAgICBWYWx1ZSBmb3Igd2hpY2ggdG8gY2FsY3VsYXRlIHRoZSBudGggcm9vdFxuICAgKiBAcGFyYW0ge251bWJlciB8IEJpZ051bWJlcn0gW3Jvb3Q9Ml0gICAgVGhlIHJvb3QuXG4gICAqIEByZXR1cm4ge251bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0gUmV0dXJucyB0aGUgbnRoIHJvb3Qgb2YgYGFgXG4gICAqL1xuICB2YXIgbnRoUm9vdCA9IHR5cGVkKCdudGhSb290Jywge1xuICAgIFxuICAgICdudW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIF9udGhSb290KHgsIDIpO1xuICAgIH0sXG4gICAgJ251bWJlciwgbnVtYmVyJzogX250aFJvb3QsXG5cbiAgICAnQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBfYmlnTnRoUm9vdCh4LCBuZXcgdHlwZS5CaWdOdW1iZXIoMikpO1xuICAgIH0sXG4gICAgJ0NvbXBsZXgnIDogZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIF9udGhDb21wbGV4Um9vdCh4LCAyKTtcbiAgICB9LCBcbiAgICAnQ29tcGxleCwgbnVtYmVyJyA6IF9udGhDb21wbGV4Um9vdCxcbiAgICAnQmlnTnVtYmVyLCBCaWdOdW1iZXInOiBfYmlnTnRoUm9vdCxcblxuICAgICdBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gbnRoUm9vdCh4LCAyKTtcbiAgICB9LFxuICAgIFxuICAgICdNYXRyaXgsIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuXG4gICAgICAvLyBwcm9jZXNzIG1hdHJpeCBzdG9yYWdlXG4gICAgICBzd2l0Y2ggKHguc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgc3dpdGNoICh5LnN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICAgICAgLy8gZGVuc2l0eSBtdXN0IGJlIG9uZSAobm8gemVyb3MgaW4gbWF0cml4KVxuICAgICAgICAgICAgICBpZiAoeS5kZW5zaXR5KCkgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBzcGFyc2UgKyBzcGFyc2VcbiAgICAgICAgICAgICAgICBjID0gYWxnb3JpdGhtMDYoeCwgeSwgbnRoUm9vdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdGhyb3cgZXhjZXB0aW9uXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSb290IG11c3QgYmUgbm9uLXplcm8nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIHNwYXJzZSArIGRlbnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0wMih5LCB4LCBudGhSb290LCB0cnVlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgICAgIC8vIGRlbnNpdHkgbXVzdCBiZSBvbmUgKG5vIHplcm9zIGluIG1hdHJpeClcbiAgICAgICAgICAgICAgaWYgKHkuZGVuc2l0eSgpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gZGVuc2UgKyBzcGFyc2VcbiAgICAgICAgICAgICAgICBjID0gYWxnb3JpdGhtMDEoeCwgeSwgbnRoUm9vdCwgZmFsc2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHRocm93IGV4Y2VwdGlvblxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUm9vdCBtdXN0IGJlIG5vbi16ZXJvJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAvLyBkZW5zZSArIGRlbnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0xMyh4LCB5LCBudGhSb290KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfSxcblxuICAgICdBcnJheSwgQXJyYXknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIG50aFJvb3QobWF0cml4KHgpLCBtYXRyaXgoeSkpLnZhbHVlT2YoKTtcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIG50aFJvb3QobWF0cml4KHgpLCB5KTtcbiAgICB9LFxuXG4gICAgJ01hdHJpeCwgQXJyYXknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIG50aFJvb3QoeCwgbWF0cml4KHkpKTtcbiAgICB9LFxuICAgIFxuICAgICdNYXRyaXgsIG51bWJlciB8IEJpZ051bWJlcic6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuICAgICAgLy8gY2hlY2sgc3RvcmFnZSBmb3JtYXRcbiAgICAgIHN3aXRjaCAoeC5zdG9yYWdlKCkpIHtcbiAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTEoeCwgeSwgbnRoUm9vdCwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xNCh4LCB5LCBudGhSb290LCBmYWxzZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuXG4gICAgJ251bWJlciB8IEJpZ051bWJlciwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHJlc3VsdFxuICAgICAgdmFyIGM7XG4gICAgICAvLyBjaGVjayBzdG9yYWdlIGZvcm1hdFxuICAgICAgc3dpdGNoICh5LnN0b3JhZ2UoKSkge1xuICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgIC8vIGRlbnNpdHkgbXVzdCBiZSBvbmUgKG5vIHplcm9zIGluIG1hdHJpeClcbiAgICAgICAgICBpZiAoeS5kZW5zaXR5KCkgPT09IDEpIHtcbiAgICAgICAgICAgIC8vIHNwYXJzZSAtIHNjYWxhclxuICAgICAgICAgICAgYyA9IGFsZ29yaXRobTExKHksIHgsIG50aFJvb3QsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRocm93IGV4Y2VwdGlvblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSb290IG11c3QgYmUgbm9uLXplcm8nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTE0KHksIHgsIG50aFJvb3QsIHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfSxcblxuICAgICdBcnJheSwgbnVtYmVyIHwgQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBudGhSb290KG1hdHJpeCh4KSwgeSkudmFsdWVPZigpO1xuICAgIH0sXG5cbiAgICAnbnVtYmVyIHwgQmlnTnVtYmVyLCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gbnRoUm9vdCh4LCBtYXRyaXgoeSkpLnZhbHVlT2YoKTtcbiAgICB9XG4gIH0pO1xuXG4gIG50aFJvb3QudG9UZXggPSAnXFxcXHNxcnRbJHthcmdzWzFdfV17JHthcmdzWzBdfX0nO1xuXG4gIHJldHVybiBudGhSb290O1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIG50aCByb290IG9mIGEgZm9yIEJpZ051bWJlcnMsIHNvbHZlIHhecm9vdCA9PSBhXG4gICAqIGh0dHA6Ly9yb3NldHRhY29kZS5vcmcvd2lraS9OdGhfcm9vdCNKYXZhU2NyaXB0XG4gICAqIEBwYXJhbSB7QmlnTnVtYmVyfSBhXG4gICAqIEBwYXJhbSB7QmlnTnVtYmVyfSByb290XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfYmlnTnRoUm9vdChhLCByb290KSB7XG4gICAgdmFyIHByZWNpc2lvbiA9IHR5cGUuQmlnTnVtYmVyLnByZWNpc2lvbjtcbiAgICB2YXIgQmlnID0gdHlwZS5CaWdOdW1iZXIuY2xvbmUoe3ByZWNpc2lvbjogcHJlY2lzaW9uICsgMn0pO1xuICAgIHZhciB6ZXJvID0gbmV3IHR5cGUuQmlnTnVtYmVyKDApO1xuXG4gICAgdmFyIG9uZSA9IG5ldyBCaWcoMSk7XG4gICAgdmFyIGludiA9IHJvb3QuaXNOZWdhdGl2ZSgpO1xuICAgIGlmIChpbnYpIHtcbiAgICAgIHJvb3QgPSByb290Lm5lZygpO1xuICAgIH1cblxuICAgIGlmIChyb290LmlzWmVybygpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jvb3QgbXVzdCBiZSBub24temVybycpO1xuICAgIH1cbiAgICBpZiAoYS5pc05lZ2F0aXZlKCkgJiYgIXJvb3QuYWJzKCkubW9kKDIpLmVxdWFscygxKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSb290IG11c3QgYmUgb2RkIHdoZW4gYSBpcyBuZWdhdGl2ZS4nKTtcbiAgICB9XG5cbiAgICAvLyBlZGdlIGNhc2VzIHplcm8gYW5kIGluZmluaXR5XG4gICAgaWYgKGEuaXNaZXJvKCkpIHtcbiAgICAgIHJldHVybiBpbnYgPyBuZXcgQmlnKEluZmluaXR5KSA6IDA7XG4gICAgfVxuICAgIGlmICghYS5pc0Zpbml0ZSgpKSB7XG4gICAgICByZXR1cm4gaW52ID8gemVybyA6IGE7XG4gICAgfVxuXG4gICAgdmFyIHggPSBhLmFicygpLnBvdyhvbmUuZGl2KHJvb3QpKTtcbiAgICAvLyBJZiBhIDwgMCwgd2UgcmVxdWlyZSB0aGF0IHJvb3QgaXMgYW4gb2RkIGludGVnZXIsXG4gICAgLy8gc28gKC0xKSBeICgxL3Jvb3QpID0gLTFcbiAgICB4ID0gYS5pc05lZygpID8geC5uZWcoKSA6IHg7XG4gICAgcmV0dXJuIG5ldyB0eXBlLkJpZ051bWJlcigoaW52ID8gb25lLmRpdih4KSA6IHgpLnRvUHJlY2lzaW9uKHByZWNpc2lvbikpO1xuICB9XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBudGggcm9vdCBvZiBhLCBzb2x2ZSB4XnJvb3QgPT0gYVxuICogaHR0cDovL3Jvc2V0dGFjb2RlLm9yZy93aWtpL050aF9yb290I0phdmFTY3JpcHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gKiBAcGFyYW0ge251bWJlcn0gcm9vdFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX250aFJvb3QoYSwgcm9vdCkge1xuICB2YXIgaW52ID0gcm9vdCA8IDA7XG4gIGlmIChpbnYpIHtcbiAgICByb290ID0gLXJvb3Q7XG4gIH1cblxuICBpZiAocm9vdCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignUm9vdCBtdXN0IGJlIG5vbi16ZXJvJyk7XG4gIH1cbiAgaWYgKGEgPCAwICYmIChNYXRoLmFicyhyb290KSAlIDIgIT0gMSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jvb3QgbXVzdCBiZSBvZGQgd2hlbiBhIGlzIG5lZ2F0aXZlLicpO1xuICB9XG5cbiAgLy8gZWRnZSBjYXNlcyB6ZXJvIGFuZCBpbmZpbml0eVxuICBpZiAoYSA9PSAwKSB7XG4gICAgcmV0dXJuIGludiA/IEluZmluaXR5IDogMDtcbiAgfVxuICBpZiAoIWlzRmluaXRlKGEpKSB7XG4gICAgcmV0dXJuIGludiA/IDAgOiBhO1xuICB9XG5cbiAgdmFyIHggPSBNYXRoLnBvdyhNYXRoLmFicyhhKSwgMS9yb290KTtcbiAgLy8gSWYgYSA8IDAsIHdlIHJlcXVpcmUgdGhhdCByb290IGlzIGFuIG9kZCBpbnRlZ2VyLFxuICAvLyBzbyAoLTEpIF4gKDEvcm9vdCkgPSAtMVxuICB4ID0gYSA8IDAgPyAteCA6IHg7XG4gIHJldHVybiBpbnYgPyAxIC8geCA6IHg7XG5cbiAgLy8gVmVyeSBuaWNlIGFsZ29yaXRobSwgYnV0IGZhaWxzIHdpdGggbnRoUm9vdCgtMiwgMykuXG4gIC8vIE5ld3RvbidzIG1ldGhvZCBoYXMgc29tZSB3ZWxsLWtub3duIHByb2JsZW1zIGF0IHRpbWVzOlxuICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9OZXd0b24lMjdzX21ldGhvZCNGYWlsdXJlX2FuYWx5c2lzXG4gIC8qXG4gIHZhciB4ID0gMTsgLy8gSW5pdGlhbCBndWVzc1xuICB2YXIgeFByZXYgPSAxO1xuICB2YXIgaSA9IDA7XG4gIHZhciBpTWF4ID0gMTAwMDA7XG4gIGRvIHtcbiAgICB2YXIgZGVsdGEgPSAoYSAvIE1hdGgucG93KHgsIHJvb3QgLSAxKSAtIHgpIC8gcm9vdDtcbiAgICB4UHJldiA9IHg7XG4gICAgeCA9IHggKyBkZWx0YTtcbiAgICBpKys7XG4gIH1cbiAgd2hpbGUgKHhQcmV2ICE9PSB4ICYmIGkgPCBpTWF4KTtcblxuICBpZiAoeFByZXYgIT09IHgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uIG50aFJvb3QgZmFpbGVkIHRvIGNvbnZlcmdlJyk7XG4gIH1cblxuICByZXR1cm4gaW52ID8gMSAvIHggOiB4O1xuICAqL1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgbnRoIHJvb3Qgb2YgYSBDb21wbGV4IE51bWJlciBhIHVzaW5nIERlIE1vdmllcnMgVGhlb3JlbS5cbiAqIEBwYXJhbSAge0NvbXBsZXh9IGFcbiAqIEBwYXJhbSAge251bWJlcn0gcm9vdFxuICogQHJldHVybiB7QXJyYXl9IGFycmF5IG9yIG4gQ29tcGxleCBSb290cyBpbiBQb2xhciBGb3JtLlxuICovXG5mdW5jdGlvbiBfbnRoQ29tcGxleFJvb3QoYSwgcm9vdCkge1xuICBpZiAocm9vdCA8IDApIHRocm93IG5ldyBFcnJvcignUm9vdCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB6ZXJvJyk7XG4gIGlmIChyb290ID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ1Jvb3QgbXVzdCBiZSBub24temVybycpO1xuICBpZiAocm9vdCAlIDEgIT09IDApIHRocm93IG5ldyBFcnJvcignUm9vdCBtdXN0IGJlIGFuIGludGVnZXInKTsgIFxuICB2YXIgYXJnID0gYS5hcmcoKTtcbiAgdmFyIGFicyA9IGEuYWJzKCk7XG4gIHZhciByb290cyA9IFtdO1xuICB2YXIgciA9IE1hdGgucG93KGFicywgMS9yb290KTtcbiAgZm9yKHZhciBrID0gMDsgayA8IHJvb3Q7IGsrKykge1xuICAgIHJvb3RzLnB1c2goe3I6IHIsIHBoaTogKGFyZyArIDIgKiBNYXRoLlBJICogaykvcm9vdH0pO1xuICB9XG4gIHJldHVybiByb290cztcbn1cblxuZXhwb3J0cy5uYW1lID0gJ250aFJvb3QnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzSW50ZWdlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL251bWJlcicpLmlzSW50ZWdlcjtcbnZhciBzaXplID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYXJyYXknKS5zaXplO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBsYXRleCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2xhdGV4Jyk7XG4gIHZhciBleWUgPSBsb2FkKHJlcXVpcmUoJy4uL21hdHJpeC9leWUnKSk7XG4gIHZhciBtdWx0aXBseSA9IGxvYWQocmVxdWlyZSgnLi9tdWx0aXBseScpKTtcbiAgdmFyIG1hdHJpeCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvZnVuY3Rpb24vbWF0cml4JykpO1xuICB2YXIgZnJhY3Rpb24gPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvZnJhY3Rpb24vZnVuY3Rpb24vZnJhY3Rpb24nKSk7XG4gIHZhciBudW1iZXIgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbnVtYmVyJykpO1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBwb3dlciBvZiB4IHRvIHksIGB4IF4geWAuXG4gICAqIE1hdHJpeCBleHBvbmVudGlhdGlvbiBpcyBzdXBwb3J0ZWQgZm9yIHNxdWFyZSBtYXRyaWNlcyBgeGAsIGFuZCBwb3NpdGl2ZVxuICAgKiBpbnRlZ2VyIGV4cG9uZW50cyBgeWAuXG4gICAqXG4gICAqIEZvciBjdWJpYyByb290cyBvZiBuZWdhdGl2ZSBudW1iZXJzLCB0aGUgZnVuY3Rpb24gcmV0dXJucyB0aGUgcHJpbmNpcGFsXG4gICAqIHJvb3QgYnkgZGVmYXVsdC4gSW4gb3JkZXIgdG8gbGV0IHRoZSBmdW5jdGlvbiByZXR1cm4gdGhlIHJlYWwgcm9vdCxcbiAgICogbWF0aC5qcyBjYW4gYmUgY29uZmlndXJlZCB3aXRoIGBtYXRoLmNvbmZpZyh7cHJlZGljdGFibGU6IHRydWV9KWAuXG4gICAqIFRvIHJldHJpZXZlIGFsbCBjdWJpYyByb290cyBvZiBhIHZhbHVlLCB1c2UgYG1hdGguY2JydCh4LCB0cnVlKWAuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5wb3coeCwgeSlcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGgucG93KDIsIDMpOyAgICAgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIDhcbiAgICpcbiAgICogICAgdmFyIGEgPSBtYXRoLmNvbXBsZXgoMiwgMyk7XG4gICAqICAgIG1hdGgucG93KGEsIDIpICAgICAgICAgICAgICAgIC8vIHJldHVybnMgQ29tcGxleCAtNSArIDEyaVxuICAgKlxuICAgKiAgICB2YXIgYiA9IFtbMSwgMl0sIFs0LCAzXV07XG4gICAqICAgIG1hdGgucG93KGIsIDIpOyAgICAgICAgICAgICAgIC8vIHJldHVybnMgQXJyYXkgW1s5LCA4XSwgWzE2LCAxN11dXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBtdWx0aXBseSwgc3FydCwgY2JydCwgbnRoUm9vdFxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9IHggIFRoZSBiYXNlXG4gICAqIEBwYXJhbSAge251bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXh9IHkgICAgICAgICAgICAgICAgICAgVGhlIGV4cG9uZW50XG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0gVGhlIHZhbHVlIG9mIGB4YCB0byB0aGUgcG93ZXIgYHlgXG4gICAqL1xuICB2YXIgcG93ID0gdHlwZWQoJ3BvdycsIHtcbiAgICAnbnVtYmVyLCBudW1iZXInOiBfcG93LFxuXG4gICAgJ0NvbXBsZXgsIENvbXBsZXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIHgucG93KHkpO1xuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyLCBCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgaWYgKHkuaXNJbnRlZ2VyKCkgfHwgeCA+PSAwIHx8IGNvbmZpZy5wcmVkaWN0YWJsZSkge1xuICAgICAgICByZXR1cm4geC5wb3coeSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0eXBlLkNvbXBsZXgoeC50b051bWJlcigpLCAwKS5wb3coeS50b051bWJlcigpLCAwKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgJ0ZyYWN0aW9uLCBGcmFjdGlvbic6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICBpZiAoeS5kICE9PSAxKSB7XG4gICAgICAgIGlmIChjb25maWcucHJlZGljdGFibGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uIHBvdyBkb2VzIG5vdCBzdXBwb3J0IG5vbi1pbnRlZ2VyIGV4cG9uZW50cyBmb3IgZnJhY3Rpb25zLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBfcG93KHgudmFsdWVPZigpLCB5LnZhbHVlT2YoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4geC5wb3coeSk7XG4gICAgIH1cbiAgICB9LFxuXG4gICAgJ0FycmF5LCBudW1iZXInOiBfcG93QXJyYXksXG5cbiAgICAnQXJyYXksIEJpZ051bWJlcic6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4gX3Bvd0FycmF5KHgsIHkudG9OdW1iZXIoKSk7XG4gICAgfSxcblxuICAgICdNYXRyaXgsIG51bWJlcic6IF9wb3dNYXRyaXgsXG5cbiAgICAnTWF0cml4LCBCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIF9wb3dNYXRyaXgoeCwgeS50b051bWJlcigpKTtcbiAgICB9LFxuXG4gICAgJ1VuaXQsIG51bWJlcic6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4geC5wb3coeSk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBwb3dlciBvZiB4IHRvIHksIHheeSwgZm9yIHR3byBudW1iZXJzLlxuICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBDb21wbGV4fSByZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9wb3coeCwgeSkge1xuXG4gICAgLy8gQWx0ZXJuYXRpdmVseSBjb3VsZCBkZWZpbmUgYSAncmVhbG1vZGUnIGNvbmZpZyBvcHRpb24gb3Igc29tZXRoaW5nLCBidXRcbiAgICAvLyAncHJlZGljdGFibGUnIHdpbGwgd29yayBmb3Igbm93XG4gICAgaWYgKGNvbmZpZy5wcmVkaWN0YWJsZSAmJiAhaXNJbnRlZ2VyKHkpICYmIHggPCAwKSB7XG4gICAgICAvLyBDaGVjayB0byBzZWUgaWYgeSBjYW4gYmUgcmVwcmVzZW50ZWQgYXMgYSBmcmFjdGlvblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHlGcmFjID0gZnJhY3Rpb24oeSk7XG4gICAgICAgIHZhciB5TnVtID0gbnVtYmVyKHlGcmFjKTtcbiAgICAgICAgaWYoeSA9PT0geU51bSB8fCBNYXRoLmFicygoeSAtIHlOdW0pIC8geSkgPCAxZS0xNCkge1xuICAgICAgICAgIGlmKHlGcmFjLmQgJSAyID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gKHlGcmFjLm4gJSAyID09PSAwID8gMSA6IC0xKSAqIE1hdGgucG93KC14LCB5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAvLyBmcmFjdGlvbigpIHRocm93cyBhbiBlcnJvciBpZiB5IGlzIEluZmluaXR5LCBldGMuXG4gICAgICB9XG5cbiAgICAgIC8vIFVuYWJsZSB0byBleHByZXNzIHkgYXMgYSBmcmFjdGlvbiwgc28gY29udGludWUgb25cbiAgICB9XG5cbiAgICBpZiAoaXNJbnRlZ2VyKHkpIHx8IHggPj0gMCB8fCBjb25maWcucHJlZGljdGFibGUpIHtcbiAgICAgIHJldHVybiBNYXRoLnBvdyh4LCB5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IHR5cGUuQ29tcGxleCh4LCAwKS5wb3coeSwgMCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgcG93ZXIgb2YgYSAyZCBhcnJheVxuICAgKiBAcGFyYW0ge0FycmF5fSB4ICAgICBtdXN0IGJlIGEgMiBkaW1lbnNpb25hbCwgc3F1YXJlIG1hdHJpeFxuICAgKiBAcGFyYW0ge251bWJlcn0geSAgICBhIHBvc2l0aXZlLCBpbnRlZ2VyIHZhbHVlXG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9wb3dBcnJheSh4LCB5KSB7XG4gICAgaWYgKCFpc0ludGVnZXIoeSkgfHwgeSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZvciBBXmIsIGIgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgKHZhbHVlIGlzICcgKyB5ICsgJyknKTtcbiAgICB9XG4gICAgLy8gdmVyaWZ5IHRoYXQgQSBpcyBhIDIgZGltZW5zaW9uYWwgc3F1YXJlIG1hdHJpeFxuICAgIHZhciBzID0gc2l6ZSh4KTtcbiAgICBpZiAocy5sZW5ndGggIT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3IgQV5iLCBBIG11c3QgYmUgMiBkaW1lbnNpb25hbCAoQSBoYXMgJyArIHMubGVuZ3RoICsgJyBkaW1lbnNpb25zKScpO1xuICAgIH1cbiAgICBpZiAoc1swXSAhPSBzWzFdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvciBBXmIsIEEgbXVzdCBiZSBzcXVhcmUgKHNpemUgaXMgJyArIHNbMF0gKyAneCcgKyBzWzFdICsgJyknKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzID0gZXllKHNbMF0pLnZhbHVlT2YoKTtcbiAgICB2YXIgcHggPSB4O1xuICAgIHdoaWxlICh5ID49IDEpIHtcbiAgICAgIGlmICgoeSAmIDEpID09IDEpIHtcbiAgICAgICAgcmVzID0gbXVsdGlwbHkocHgsIHJlcyk7XG4gICAgICB9XG4gICAgICB5ID4+PSAxO1xuICAgICAgcHggPSBtdWx0aXBseShweCwgcHgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgcG93ZXIgb2YgYSAyZCBtYXRyaXhcbiAgICogQHBhcmFtIHtNYXRyaXh9IHggICAgIG11c3QgYmUgYSAyIGRpbWVuc2lvbmFsLCBzcXVhcmUgbWF0cml4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5ICAgIGEgcG9zaXRpdmUsIGludGVnZXIgdmFsdWVcbiAgICogQHJldHVybnMge01hdHJpeH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9wb3dNYXRyaXggKHgsIHkpIHtcbiAgICByZXR1cm4gbWF0cml4KF9wb3dBcnJheSh4LnZhbHVlT2YoKSwgeSkpO1xuICB9XG5cblxuXG4gIHBvdy50b1RleCA9ICdcXFxcbGVmdCgke2FyZ3NbMF19XFxcXHJpZ2h0KScgKyBsYXRleC5vcGVyYXRvcnNbJ3BvdyddICsgJ3ske2FyZ3NbMV19fSc7XG5cbiAgcmV0dXJuIHBvdztcbn1cblxuZXhwb3J0cy5uYW1lID0gJ3Bvdyc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNJbnRlZ2VyID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbnVtYmVyJykuaXNJbnRlZ2VyO1xudmFyIHRvRml4ZWQgPSByZXF1aXJlKCcuLi8uLi91dGlscy9udW1iZXInKS50b0ZpeGVkO1xudmFyIGRlZXBNYXAgPSByZXF1aXJlKCcuLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBNYXAnKTtcblxudmFyIE5PX0lOVCA9ICdOdW1iZXIgb2YgZGVjaW1hbHMgaW4gZnVuY3Rpb24gcm91bmQgbXVzdCBiZSBhbiBpbnRlZ2VyJztcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgbWF0cml4ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC9mdW5jdGlvbi9tYXRyaXgnKSk7XG4gIHZhciBlcXVhbFNjYWxhciA9IGxvYWQocmVxdWlyZSgnLi4vcmVsYXRpb25hbC9lcXVhbFNjYWxhcicpKTtcbiAgdmFyIHplcm9zID0gbG9hZChyZXF1aXJlKCcuLi9tYXRyaXgvemVyb3MnKSk7XG5cbiAgdmFyIGFsZ29yaXRobTExID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xMScpKTtcbiAgdmFyIGFsZ29yaXRobTEyID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xMicpKTtcbiAgdmFyIGFsZ29yaXRobTE0ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xNCcpKTtcbiAgXG4gIC8qKlxuICAgKiBSb3VuZCBhIHZhbHVlIHRvd2FyZHMgdGhlIG5lYXJlc3QgaW50ZWdlci5cbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLnJvdW5kKHgpXG4gICAqICAgIG1hdGgucm91bmQoeCwgbilcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGgucm91bmQoMy4yKTsgICAgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIDNcbiAgICogICAgbWF0aC5yb3VuZCgzLjgpOyAgICAgICAgICAgICAgLy8gcmV0dXJucyBudW1iZXIgNFxuICAgKiAgICBtYXRoLnJvdW5kKC00LjIpOyAgICAgICAgICAgICAvLyByZXR1cm5zIG51bWJlciAtNFxuICAgKiAgICBtYXRoLnJvdW5kKC00LjcpOyAgICAgICAgICAgICAvLyByZXR1cm5zIG51bWJlciAtNVxuICAgKiAgICBtYXRoLnJvdW5kKG1hdGgucGksIDMpOyAgICAgICAvLyByZXR1cm5zIG51bWJlciAzLjE0MlxuICAgKiAgICBtYXRoLnJvdW5kKDEyMy40NTY3OCwgMik7ICAgICAvLyByZXR1cm5zIG51bWJlciAxMjMuNDZcbiAgICpcbiAgICogICAgdmFyIGMgPSBtYXRoLmNvbXBsZXgoMy4yLCAtMi43KTtcbiAgICogICAgbWF0aC5yb3VuZChjKTsgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBDb21wbGV4IDMgLSAzaVxuICAgKlxuICAgKiAgICBtYXRoLnJvdW5kKFszLjIsIDMuOCwgLTQuN10pOyAvLyByZXR1cm5zIEFycmF5IFszLCA0LCAtNV1cbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGNlaWwsIGZpeCwgZmxvb3JcbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb24gfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9IHggIE51bWJlciB0byBiZSByb3VuZGVkXG4gICAqIEBwYXJhbSAge251bWJlciB8IEJpZ051bWJlciB8IEFycmF5fSBbbj0wXSAgICAgICAgICAgICAgICAgICAgICAgICAgICBOdW1iZXIgb2YgZGVjaW1hbHNcbiAgICogQHJldHVybiB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb24gfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9IFJvdW5kZWQgdmFsdWVcbiAgICovXG4gIHZhciByb3VuZCA9IHR5cGVkKCdyb3VuZCcsIHtcblxuICAgICdudW1iZXInOiBNYXRoLnJvdW5kLFxuXG4gICAgJ251bWJlciwgbnVtYmVyJzogZnVuY3Rpb24gKHgsIG4pIHtcbiAgICAgIGlmICghaXNJbnRlZ2VyKG4pKSAgIHt0aHJvdyBuZXcgVHlwZUVycm9yKE5PX0lOVCk7fVxuICAgICAgaWYgKG4gPCAwIHx8IG4gPiAxNSkge3Rocm93IG5ldyBFcnJvcignTnVtYmVyIG9mIGRlY2ltYWxzIGluIGZ1bmN0aW9uIHJvdW5kIG11c3QgYmUgaW4gdGUgcmFuZ2Ugb2YgMC0xNScpO31cblxuICAgICAgcmV0dXJuIF9yb3VuZCh4LCBuKTtcbiAgICB9LFxuXG4gICAgJ0NvbXBsZXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHgucm91bmQoKTtcbiAgICB9LFxuXG4gICAgJ0NvbXBsZXgsIG51bWJlcic6IGZ1bmN0aW9uICh4LCBuKSB7XG4gICAgICBpZiAobiAlIDEpIHt0aHJvdyBuZXcgVHlwZUVycm9yKE5PX0lOVCk7fVxuICAgICAgXG4gICAgICByZXR1cm4geC5yb3VuZChuKTtcbiAgICB9LFxuXG4gICAgJ0NvbXBsZXgsIEJpZ051bWJlcic6IGZ1bmN0aW9uICh4LCBuKSB7XG4gICAgICBpZiAoIW4uaXNJbnRlZ2VyKCkpIHt0aHJvdyBuZXcgVHlwZUVycm9yKE5PX0lOVCk7fVxuXG4gICAgICB2YXIgX24gPSBuLnRvTnVtYmVyKCk7XG4gICAgICByZXR1cm4geC5yb3VuZChfbik7XG4gICAgfSxcblxuICAgICdudW1iZXIsIEJpZ051bWJlcic6IGZ1bmN0aW9uICh4LCBuKSB7XG4gICAgICBpZiAoIW4uaXNJbnRlZ2VyKCkpIHt0aHJvdyBuZXcgVHlwZUVycm9yKE5PX0lOVCk7fVxuXG4gICAgICByZXR1cm4gbmV3IHR5cGUuQmlnTnVtYmVyKHgpLnRvRGVjaW1hbFBsYWNlcyhuLnRvTnVtYmVyKCkpO1xuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LnRvRGVjaW1hbFBsYWNlcygwKTtcbiAgICB9LFxuXG4gICAgJ0JpZ051bWJlciwgQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgsIG4pIHtcbiAgICAgIGlmICghbi5pc0ludGVnZXIoKSkge3Rocm93IG5ldyBUeXBlRXJyb3IoTk9fSU5UKTt9XG5cbiAgICAgIHJldHVybiB4LnRvRGVjaW1hbFBsYWNlcyhuLnRvTnVtYmVyKCkpO1xuICAgIH0sXG5cbiAgICAnRnJhY3Rpb24nOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHgucm91bmQoKTtcbiAgICB9LFxuXG4gICAgJ0ZyYWN0aW9uLCBudW1iZXInOiBmdW5jdGlvbiAoeCwgbikge1xuICAgICAgaWYgKG4gJSAxKSB7dGhyb3cgbmV3IFR5cGVFcnJvcihOT19JTlQpO31cbiAgICAgIHJldHVybiB4LnJvdW5kKG4pO1xuICAgIH0sXG5cbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgLy8gZGVlcCBtYXAgY29sbGVjdGlvbiwgc2tpcCB6ZXJvcyBzaW5jZSByb3VuZCgwKSA9IDBcbiAgICAgIHJldHVybiBkZWVwTWFwKHgsIHJvdW5kLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgJ01hdHJpeCwgbnVtYmVyIHwgQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHJlc3VsdFxuICAgICAgdmFyIGM7XG4gICAgICAvLyBjaGVjayBzdG9yYWdlIGZvcm1hdFxuICAgICAgc3dpdGNoICh4LnN0b3JhZ2UoKSkge1xuICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xMSh4LCB5LCByb3VuZCwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xNCh4LCB5LCByb3VuZCwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfSxcblxuICAgICdudW1iZXIgfCBDb21wbGV4IHwgQmlnTnVtYmVyLCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gY2hlY2sgc2NhbGFyIGlzIHplcm9cbiAgICAgIGlmICghZXF1YWxTY2FsYXIoeCwgMCkpIHtcbiAgICAgICAgLy8gcmVzdWx0XG4gICAgICAgIHZhciBjO1xuICAgICAgICAvLyBjaGVjayBzdG9yYWdlIGZvcm1hdFxuICAgICAgICBzd2l0Y2ggKHkuc3RvcmFnZSgpKSB7XG4gICAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICAgIGMgPSBhbGdvcml0aG0xMih5LCB4LCByb3VuZCwgdHJ1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYyA9IGFsZ29yaXRobTE0KHksIHgsIHJvdW5kLCB0cnVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjO1xuICAgICAgfVxuICAgICAgLy8gZG8gbm90IGV4ZWN1dGUgYWxnb3JpdGhtLCByZXN1bHQgd2lsbCBiZSBhIHplcm8gbWF0cml4XG4gICAgICByZXR1cm4gemVyb3MoeS5zaXplKCksIHkuc3RvcmFnZSgpKTtcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBudW1iZXIgfCBCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGFsZ29yaXRobTE0KG1hdHJpeCh4KSwgeSwgcm91bmQsIGZhbHNlKS52YWx1ZU9mKCk7XG4gICAgfSxcblxuICAgICdudW1iZXIgfCBDb21wbGV4IHwgQmlnTnVtYmVyLCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gYWxnb3JpdGhtMTQobWF0cml4KHkpLCB4LCByb3VuZCwgdHJ1ZSkudmFsdWVPZigpO1xuICAgIH1cbiAgfSk7XG5cbiAgcm91bmQudG9UZXggPSB7XG4gICAgMTogJ1xcXFxsZWZ0XFxcXGxmbG9vciR7YXJnc1swXX1cXFxccmlnaHRcXFxccmNlaWwnLFxuICAgIDI6ICdcXFxcbWF0aHJteyR7bmFtZX19XFxcXGxlZnQoJHthcmdzfVxcXFxyaWdodCknXG4gIH07XG5cbiAgcmV0dXJuIHJvdW5kO1xufVxuXG4vKipcbiAqIHJvdW5kIGEgbnVtYmVyIHRvIHRoZSBnaXZlbiBudW1iZXIgb2YgZGVjaW1hbHMsIG9yIHRvIHplcm8gaWYgZGVjaW1hbHMgaXNcbiAqIG5vdCBwcm92aWRlZFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gZGVjaW1hbHMgICAgICAgbnVtYmVyIG9mIGRlY2ltYWxzLCBiZXR3ZWVuIDAgYW5kIDE1ICgwIGJ5IGRlZmF1bHQpXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHJvdW5kZWRWYWx1ZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX3JvdW5kICh2YWx1ZSwgZGVjaW1hbHMpIHtcbiAgcmV0dXJuIHBhcnNlRmxvYXQodG9GaXhlZCh2YWx1ZSwgZGVjaW1hbHMpKTtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ3JvdW5kJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBudW1iZXIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9udW1iZXInKTtcbnZhciBkZWVwTWFwID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9kZWVwTWFwJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgLyoqXG4gICAqIENvbXB1dGUgdGhlIHNpZ24gb2YgYSB2YWx1ZS4gVGhlIHNpZ24gb2YgYSB2YWx1ZSB4IGlzOlxuICAgKlxuICAgKiAtICAxIHdoZW4geCA+IDFcbiAgICogLSAtMSB3aGVuIHggPCAwXG4gICAqIC0gIDAgd2hlbiB4ID09IDBcbiAgICpcbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLnNpZ24oeClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGguc2lnbigzLjUpOyAgICAgICAgICAgICAgIC8vIHJldHVybnMgMVxuICAgKiAgICBtYXRoLnNpZ24oLTQuMik7ICAgICAgICAgICAgICAvLyByZXR1cm5zIC0xXG4gICAqICAgIG1hdGguc2lnbigwKTsgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgMFxuICAgKlxuICAgKiAgICBtYXRoLnNpZ24oWzMsIDUsIC0yLCAwLCAyXSk7ICAvLyByZXR1cm5zIFsxLCAxLCAtMSwgMCwgMV1cbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGFic1xuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeCB8IFVuaXR9IHhcbiAgICogICAgICAgICAgICBUaGUgbnVtYmVyIGZvciB3aGljaCB0byBkZXRlcm1pbmUgdGhlIHNpZ25cbiAgICogQHJldHVybiB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb24gfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXggfCBVbml0fWVcbiAgICogICAgICAgICAgICBUaGUgc2lnbiBvZiBgeGBcbiAgICovXG4gIHZhciBzaWduID0gdHlwZWQoJ3NpZ24nLCB7XG4gICAgJ251bWJlcic6IG51bWJlci5zaWduLFxuXG4gICAgJ0NvbXBsZXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHguc2lnbigpO1xuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBuZXcgdHlwZS5CaWdOdW1iZXIoeC5jbXAoMCkpO1xuICAgIH0sXG5cbiAgICAnRnJhY3Rpb24nOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIG5ldyB0eXBlLkZyYWN0aW9uKHgucywgMSk7XG4gICAgfSxcblxuICAgICdBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAvLyBkZWVwIG1hcCBjb2xsZWN0aW9uLCBza2lwIHplcm9zIHNpbmNlIHNpZ24oMCkgPSAwXG4gICAgICByZXR1cm4gZGVlcE1hcCh4LCBzaWduLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgJ1VuaXQnOiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gc2lnbih4LnZhbHVlKTtcbiAgICB9XG4gIH0pO1xuXG4gIHNpZ24udG9UZXggPSAnXFxcXG1hdGhybXske25hbWV9fVxcXFxsZWZ0KCR7YXJnc31cXFxccmlnaHQpJztcblxuICByZXR1cm4gc2lnbjtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ3NpZ24nO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVlcE1hcCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vZGVlcE1hcCcpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIHNxdWFyZSByb290IG9mIGEgdmFsdWUuXG4gICAqXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5zcXJ0KHgpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLnNxcnQoMjUpOyAgICAgICAgICAgICAgICAvLyByZXR1cm5zIDVcbiAgICogICAgbWF0aC5zcXVhcmUoNSk7ICAgICAgICAgICAgICAgLy8gcmV0dXJucyAyNVxuICAgKiAgICBtYXRoLnNxcnQoLTQpOyAgICAgICAgICAgICAgICAvLyByZXR1cm5zIENvbXBsZXggMmlcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIHNxdWFyZSwgbXVsdGlwbHksIGN1YmUsIGNicnRcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXggfCBVbml0fSB4XG4gICAqICAgICAgICAgICAgVmFsdWUgZm9yIHdoaWNoIHRvIGNhbGN1bGF0ZSB0aGUgc3F1YXJlIHJvb3QuXG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeCB8IFVuaXR9XG4gICAqICAgICAgICAgICAgUmV0dXJucyB0aGUgc3F1YXJlIHJvb3Qgb2YgYHhgXG4gICAqL1xuICB2YXIgc3FydCA9IHR5cGVkKCdzcXJ0Jywge1xuICAgICdudW1iZXInOiBfc3FydE51bWJlcixcblxuICAgICdDb21wbGV4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHguc3FydCgpO1xuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICgheC5pc05lZ2F0aXZlKCkgfHwgY29uZmlnLnByZWRpY3RhYmxlKSB7XG4gICAgICAgIHJldHVybiB4LnNxcnQoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBuZWdhdGl2ZSB2YWx1ZSAtPiBkb3duZ3JhZGUgdG8gbnVtYmVyIHRvIGRvIGNvbXBsZXggdmFsdWUgY29tcHV0YXRpb25cbiAgICAgICAgcmV0dXJuIF9zcXJ0TnVtYmVyKHgudG9OdW1iZXIoKSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgICdBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAvLyBkZWVwIG1hcCBjb2xsZWN0aW9uLCBza2lwIHplcm9zIHNpbmNlIHNxcnQoMCkgPSAwXG4gICAgICByZXR1cm4gZGVlcE1hcCh4LCBzcXJ0LCB0cnVlKTtcbiAgICB9LFxuXG4gICAgJ1VuaXQnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgLy8gU29tZWRheSB3aWxsIHdvcmsgZm9yIGNvbXBsZXggdW5pdHMgd2hlbiB0aGV5IGFyZSBpbXBsZW1lbnRlZFxuICAgICAgcmV0dXJuIHgucG93KDAuNSk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgc3FydCBmb3IgYSBudW1iZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICogQHJldHVybnMge251bWJlciB8IENvbXBsZXh9IFJldHVybnMgdGhlIHNxdWFyZSByb290IG9mIHhcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9zcXJ0TnVtYmVyKHgpIHtcbiAgICBpZiAoeCA+PSAwIHx8IGNvbmZpZy5wcmVkaWN0YWJsZSkge1xuICAgICAgcmV0dXJuIE1hdGguc3FydCh4KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IHR5cGUuQ29tcGxleCh4LCAwKS5zcXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgc3FydC50b1RleCA9ICdcXFxcc3FydHske2FyZ3NbMF19fSc7XG5cbiAgcmV0dXJuIHNxcnQ7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdzcXJ0JztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWVwTWFwID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9kZWVwTWFwJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgLyoqXG4gICAqIENvbXB1dGUgdGhlIHNxdWFyZSBvZiBhIHZhbHVlLCBgeCAqIHhgLlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguc3F1YXJlKHgpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLnNxdWFyZSgyKTsgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIDRcbiAgICogICAgbWF0aC5zcXVhcmUoMyk7ICAgICAgICAgICAvLyByZXR1cm5zIG51bWJlciA5XG4gICAqICAgIG1hdGgucG93KDMsIDIpOyAgICAgICAgICAgLy8gcmV0dXJucyBudW1iZXIgOVxuICAgKiAgICBtYXRoLm11bHRpcGx5KDMsIDMpOyAgICAgIC8vIHJldHVybnMgbnVtYmVyIDlcbiAgICpcbiAgICogICAgbWF0aC5zcXVhcmUoWzEsIDIsIDMsIDRdKTsgIC8vIHJldHVybnMgQXJyYXkgWzEsIDQsIDksIDE2XVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgbXVsdGlwbHksIGN1YmUsIHNxcnQsIHBvd1xuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeCB8IFVuaXR9IHhcbiAgICogICAgICAgICAgICBOdW1iZXIgZm9yIHdoaWNoIHRvIGNhbGN1bGF0ZSB0aGUgc3F1YXJlXG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4IHwgVW5pdH1cbiAgICogICAgICAgICAgICBTcXVhcmVkIHZhbHVlXG4gICAqL1xuICB2YXIgc3F1YXJlID0gdHlwZWQoJ3NxdWFyZScsIHtcbiAgICAnbnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4ICogeDtcbiAgICB9LFxuXG4gICAgJ0NvbXBsZXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHgubXVsKHgpO1xuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LnRpbWVzKHgpO1xuICAgIH0sXG5cbiAgICAnRnJhY3Rpb24nOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHgubXVsKHgpO1xuICAgIH0sXG5cbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgLy8gZGVlcCBtYXAgY29sbGVjdGlvbiwgc2tpcCB6ZXJvcyBzaW5jZSBzcXVhcmUoMCkgPSAwXG4gICAgICByZXR1cm4gZGVlcE1hcCh4LCBzcXVhcmUsIHRydWUpO1xuICAgIH0sXG5cbiAgICAnVW5pdCc6IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB4LnBvdygyKTtcbiAgICB9XG4gIH0pO1xuXG4gIHNxdWFyZS50b1RleCA9ICdcXFxcbGVmdCgke2FyZ3NbMF19XFxcXHJpZ2h0KV4yJztcblxuICByZXR1cm4gc3F1YXJlO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnc3F1YXJlJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBEaW1lbnNpb25FcnJvciA9IHJlcXVpcmUoJy4uLy4uL2Vycm9yL0RpbWVuc2lvbkVycm9yJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIGxhdGV4ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbGF0ZXgnKTtcblxuICB2YXIgbWF0cml4ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC9mdW5jdGlvbi9tYXRyaXgnKSk7XG4gIHZhciBhZGRTY2FsYXIgPSBsb2FkKHJlcXVpcmUoJy4vYWRkU2NhbGFyJykpO1xuICB2YXIgdW5hcnlNaW51cyA9IGxvYWQocmVxdWlyZSgnLi91bmFyeU1pbnVzJykpO1xuXG4gIHZhciBhbGdvcml0aG0wMSA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMDEnKSk7XG4gIHZhciBhbGdvcml0aG0wMyA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMDMnKSk7XG4gIHZhciBhbGdvcml0aG0wNSA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMDUnKSk7XG4gIHZhciBhbGdvcml0aG0xMCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMTAnKSk7XG4gIHZhciBhbGdvcml0aG0xMyA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMTMnKSk7XG4gIHZhciBhbGdvcml0aG0xNCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMTQnKSk7XG5cbiAgLy8gVE9ETzogc3BsaXQgZnVuY3Rpb24gc3VidHJhY3QgaW4gdHdvOiBzdWJ0cmFjdCBhbmQgc3VidHJhY3RTY2FsYXJcblxuICAvKipcbiAgICogU3VidHJhY3QgdHdvIHZhbHVlcywgYHggLSB5YC5cbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLnN1YnRyYWN0KHgsIHkpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLnN1YnRyYWN0KDUuMywgMik7ICAgICAgICAvLyByZXR1cm5zIG51bWJlciAzLjNcbiAgICpcbiAgICogICAgdmFyIGEgPSBtYXRoLmNvbXBsZXgoMiwgMyk7XG4gICAqICAgIHZhciBiID0gbWF0aC5jb21wbGV4KDQsIDEpO1xuICAgKiAgICBtYXRoLnN1YnRyYWN0KGEsIGIpOyAgICAgICAgICAvLyByZXR1cm5zIENvbXBsZXggLTIgKyAyaVxuICAgKlxuICAgKiAgICBtYXRoLnN1YnRyYWN0KFs1LCA3LCA0XSwgNCk7ICAvLyByZXR1cm5zIEFycmF5IFsxLCAzLCAwXVxuICAgKlxuICAgKiAgICB2YXIgYyA9IG1hdGgudW5pdCgnMi4xIGttJyk7XG4gICAqICAgIHZhciBkID0gbWF0aC51bml0KCc1MDBtJyk7XG4gICAqICAgIG1hdGguc3VidHJhY3QoYywgZCk7ICAgICAgICAgIC8vIHJldHVybnMgVW5pdCAxLjYga21cbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGFkZFxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXh9IHhcbiAgICogICAgICAgICAgICBJbml0aWFsIHZhbHVlXG4gICAqIEBwYXJhbSAge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeH0geVxuICAgKiAgICAgICAgICAgIFZhbHVlIHRvIHN1YnRyYWN0IGZyb20gYHhgXG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeH1cbiAgICogICAgICAgICAgICBTdWJ0cmFjdGlvbiBvZiBgeGAgYW5kIGB5YFxuICAgKi9cbiAgdmFyIHN1YnRyYWN0ID0gdHlwZWQoJ3N1YnRyYWN0Jywge1xuXG4gICAgJ251bWJlciwgbnVtYmVyJzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHJldHVybiB4IC0geTtcbiAgICB9LFxuXG4gICAgJ0NvbXBsZXgsIENvbXBsZXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIHguc3ViKHkpO1xuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyLCBCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIHgubWludXMoeSk7XG4gICAgfSxcblxuICAgICdGcmFjdGlvbiwgRnJhY3Rpb24nOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIHguc3ViKHkpO1xuICAgIH0sXG5cbiAgICAnVW5pdCwgVW5pdCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICBpZiAoeC52YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGFyYW1ldGVyIHggY29udGFpbnMgYSB1bml0IHdpdGggdW5kZWZpbmVkIHZhbHVlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh5LnZhbHVlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJhbWV0ZXIgeSBjb250YWlucyBhIHVuaXQgd2l0aCB1bmRlZmluZWQgdmFsdWUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF4LmVxdWFsQmFzZSh5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuaXRzIGRvIG5vdCBtYXRjaCcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzID0geC5jbG9uZSgpO1xuICAgICAgcmVzLnZhbHVlID0gc3VidHJhY3QocmVzLnZhbHVlLCB5LnZhbHVlKTtcbiAgICAgIHJlcy5maXhQcmVmaXggPSBmYWxzZTtcblxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuICAgIFxuICAgICdNYXRyaXgsIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyBtYXRyaXggc2l6ZXNcbiAgICAgIHZhciB4c2l6ZSA9IHguc2l6ZSgpO1xuICAgICAgdmFyIHlzaXplID0geS5zaXplKCk7XG5cbiAgICAgIC8vIGNoZWNrIGRpbWVuc2lvbnNcbiAgICAgIGlmICh4c2l6ZS5sZW5ndGggIT09IHlzaXplLmxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IERpbWVuc2lvbkVycm9yKHhzaXplLmxlbmd0aCwgeXNpemUubGVuZ3RoKTtcblxuICAgICAgLy8gcmVzdWx0XG4gICAgICB2YXIgYztcblxuICAgICAgLy8gcHJvY2VzcyBtYXRyaXggc3RvcmFnZVxuICAgICAgc3dpdGNoICh4LnN0b3JhZ2UoKSkge1xuICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgICAgIC8vIHNwYXJzZSAtIHNwYXJzZVxuICAgICAgICAgICAgICBjID0gYWxnb3JpdGhtMDUoeCwgeSwgc3VidHJhY3QpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIHNwYXJzZSAtIGRlbnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0wMyh5LCB4LCBzdWJ0cmFjdCwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBzd2l0Y2ggKHkuc3RvcmFnZSgpKSB7XG4gICAgICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgICAgICAvLyBkZW5zZSAtIHNwYXJzZVxuICAgICAgICAgICAgICBjID0gYWxnb3JpdGhtMDEoeCwgeSwgc3VidHJhY3QsIGZhbHNlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAvLyBkZW5zZSAtIGRlbnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0xMyh4LCB5LCBzdWJ0cmFjdCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG4gICAgXG4gICAgJ0FycmF5LCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gc3VidHJhY3QobWF0cml4KHgpLCBtYXRyaXgoeSkpLnZhbHVlT2YoKTtcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIHN1YnRyYWN0KG1hdHJpeCh4KSwgeSk7XG4gICAgfSxcblxuICAgICdNYXRyaXgsIEFycmF5JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBzdWJ0cmFjdCh4LCBtYXRyaXgoeSkpO1xuICAgIH0sXG4gICAgXG4gICAgJ01hdHJpeCwgYW55JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHJlc3VsdFxuICAgICAgdmFyIGM7XG4gICAgICAvLyBjaGVjayBzdG9yYWdlIGZvcm1hdFxuICAgICAgc3dpdGNoICh4LnN0b3JhZ2UoKSkge1xuICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgIC8vIGFsZ29yaXRobSA3IGlzIGZhc3RlciB0aGFuIDkgc2luY2UgaXQgY2FsbHMgZigpIGZvciBub256ZXJvIGl0ZW1zIG9ubHkhXG4gICAgICAgICAgYyA9IGFsZ29yaXRobTEwKHgsIHVuYXJ5TWludXMoeSksIGFkZFNjYWxhcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTE0KHgsIHksIHN1YnRyYWN0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG5cbiAgICAnYW55LCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gcmVzdWx0XG4gICAgICB2YXIgYztcbiAgICAgIC8vIGNoZWNrIHN0b3JhZ2UgZm9ybWF0XG4gICAgICBzd2l0Y2ggKHkuc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTEwKHksIHgsIHN1YnRyYWN0LCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTQoeSwgeCwgc3VidHJhY3QsIHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfSxcblxuICAgICdBcnJheSwgYW55JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBhbGdvcml0aG0xNChtYXRyaXgoeCksIHksIHN1YnRyYWN0LCBmYWxzZSkudmFsdWVPZigpO1xuICAgIH0sXG5cbiAgICAnYW55LCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gYWxnb3JpdGhtMTQobWF0cml4KHkpLCB4LCBzdWJ0cmFjdCwgdHJ1ZSkudmFsdWVPZigpO1xuICAgIH1cbiAgfSk7XG5cbiAgc3VidHJhY3QudG9UZXggPSAnXFxcXGxlZnQoJHthcmdzWzBdfScgKyBsYXRleC5vcGVyYXRvcnNbJ3N1YnRyYWN0J10gKyAnJHthcmdzWzFdfVxcXFxyaWdodCknO1xuXG4gIHJldHVybiBzdWJ0cmFjdDtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ3N1YnRyYWN0JztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWVwTWFwID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9kZWVwTWFwJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIGxhdGV4ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbGF0ZXgnKTtcblxuICAvKipcbiAgICogSW52ZXJzZSB0aGUgc2lnbiBvZiBhIHZhbHVlLCBhcHBseSBhIHVuYXJ5IG1pbnVzIG9wZXJhdGlvbi5cbiAgICpcbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS4gQm9vbGVhbiB2YWx1ZXMgYW5kXG4gICAqIHN0cmluZ3Mgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSBudW1iZXIuIEZvciBjb21wbGV4IG51bWJlcnMsIGJvdGggcmVhbCBhbmRcbiAgICogY29tcGxleCB2YWx1ZSBhcmUgaW52ZXJ0ZWQuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC51bmFyeU1pbnVzKHgpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLnVuYXJ5TWludXMoMy41KTsgICAgICAvLyByZXR1cm5zIC0zLjVcbiAgICogICAgbWF0aC51bmFyeU1pbnVzKC00LjIpOyAgICAgLy8gcmV0dXJucyA0LjJcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGFkZCwgc3VidHJhY3QsIHVuYXJ5UGx1c1xuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXh9IHggTnVtYmVyIHRvIGJlIGludmVydGVkLlxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXh9IFJldHVybnMgdGhlIHZhbHVlIHdpdGggaW52ZXJ0ZWQgc2lnbi5cbiAgICovXG4gIHZhciB1bmFyeU1pbnVzID0gdHlwZWQoJ3VuYXJ5TWludXMnLCB7XG4gICAgJ251bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gLXg7XG4gICAgfSxcblxuICAgICdDb21wbGV4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4Lm5lZygpO1xuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4Lm5lZygpO1xuICAgIH0sXG5cbiAgICAnRnJhY3Rpb24nOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHgubmVnKCk7XG4gICAgfSxcblxuICAgICdVbml0JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHZhciByZXMgPSB4LmNsb25lKCk7XG4gICAgICByZXMudmFsdWUgPSB1bmFyeU1pbnVzKHgudmFsdWUpO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuXG4gICAgJ0FycmF5IHwgTWF0cml4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIC8vIGRlZXAgbWFwIGNvbGxlY3Rpb24sIHNraXAgemVyb3Mgc2luY2UgdW5hcnlNaW51cygwKSA9IDBcbiAgICAgIHJldHVybiBkZWVwTWFwKHgsIHVuYXJ5TWludXMsIHRydWUpO1xuICAgIH1cblxuICAgIC8vIFRPRE86IGFkZCBzdXBwb3J0IGZvciBzdHJpbmdcbiAgfSk7XG5cbiAgdW5hcnlNaW51cy50b1RleCA9IGxhdGV4Lm9wZXJhdG9yc1sndW5hcnlNaW51cyddICsgJ1xcXFxsZWZ0KCR7YXJnc1swXX1cXFxccmlnaHQpJztcblxuICByZXR1cm4gdW5hcnlNaW51cztcbn1cblxuZXhwb3J0cy5uYW1lID0gJ3VuYXJ5TWludXMnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZXBNYXAgPSByZXF1aXJlKCcuLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBNYXAnKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgbGF0ZXggPSByZXF1aXJlKCcuLi8uLi91dGlscy9sYXRleCcpO1xuXG4gIC8qKlxuICAgKiBVbmFyeSBwbHVzIG9wZXJhdGlvbi5cbiAgICogQm9vbGVhbiB2YWx1ZXMgYW5kIHN0cmluZ3Mgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSBudW1iZXIsIG51bWVyaWMgdmFsdWVzIHdpbGwgYmUgcmV0dXJuZWQgYXMgaXMuXG4gICAqXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC51bmFyeVBsdXMoeClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGgudW5hcnlQbHVzKDMuNSk7ICAgICAgLy8gcmV0dXJucyAzLjVcbiAgICogICAgbWF0aC51bmFyeVBsdXMoMSk7ICAgICAvLyByZXR1cm5zIDFcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIHVuYXJ5TWludXMsIGFkZCwgc3VidHJhY3RcbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb24gfCBzdHJpbmcgfCBDb21wbGV4IHwgVW5pdCB8IEFycmF5IHwgTWF0cml4fSB4XG4gICAqICAgICAgICAgICAgSW5wdXQgdmFsdWVcbiAgICogQHJldHVybiB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb24gfCBDb21wbGV4IHwgVW5pdCB8IEFycmF5IHwgTWF0cml4fVxuICAgKiAgICAgICAgICAgIFJldHVybnMgdGhlIGlucHV0IHZhbHVlIHdoZW4gbnVtZXJpYywgY29udmVydHMgdG8gYSBudW1iZXIgd2hlbiBpbnB1dCBpcyBub24tbnVtZXJpYy5cbiAgICovXG4gIHZhciB1bmFyeVBsdXMgPSB0eXBlZCgndW5hcnlQbHVzJywge1xuICAgICdudW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfSxcblxuICAgICdDb21wbGV4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4OyAvLyBjb21wbGV4IG51bWJlcnMgYXJlIGltbXV0YWJsZVxuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4OyAvLyBiaWdudW1iZXJzIGFyZSBpbW11dGFibGVcbiAgICB9LFxuXG4gICAgJ0ZyYWN0aW9uJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4OyAvLyBmcmFjdGlvbnMgYXJlIGltbXV0YWJsZVxuICAgIH0sXG5cbiAgICAnVW5pdCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5jbG9uZSgpO1xuICAgIH0sXG5cbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgLy8gZGVlcCBtYXAgY29sbGVjdGlvbiwgc2tpcCB6ZXJvcyBzaW5jZSB1bmFyeVBsdXMoMCkgPSAwXG4gICAgICByZXR1cm4gZGVlcE1hcCh4LCB1bmFyeVBsdXMsIHRydWUpO1xuICAgIH0sXG5cbiAgICAnYm9vbGVhbiB8IHN0cmluZyB8IG51bGwnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgLy8gY29udmVydCB0byBhIG51bWJlciBvciBiaWdudW1iZXJcbiAgICAgIHJldHVybiAoY29uZmlnLm51bWJlciA9PSAnQmlnTnVtYmVyJykgPyBuZXcgdHlwZS5CaWdOdW1iZXIoK3gpOiAreDtcbiAgICB9XG4gIH0pO1xuXG4gIHVuYXJ5UGx1cy50b1RleCA9IGxhdGV4Lm9wZXJhdG9yc1sndW5hcnlQbHVzJ10gKyAnXFxcXGxlZnQoJHthcmdzWzBdfVxcXFxyaWdodCknXG5cbiAgcmV0dXJuIHVuYXJ5UGx1cztcbn1cblxuZXhwb3J0cy5uYW1lID0gJ3VuYXJ5UGx1cyc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNJbnRlZ2VyID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbnVtYmVyJykuaXNJbnRlZ2VyO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBtYXRyaXggPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L2Z1bmN0aW9uL21hdHJpeCcpKTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBleHRlbmRlZCBncmVhdGVzdCBjb21tb24gZGl2aXNvciBmb3IgdHdvIHZhbHVlcy5cbiAgICogU2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXh0ZW5kZWRfRXVjbGlkZWFuX2FsZ29yaXRobS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLnhnY2QoYSwgYilcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGgueGdjZCg4LCAxMik7ICAgICAgICAgICAgIC8vIHJldHVybnMgWzQsIC0xLCAxXVxuICAgKiAgICBtYXRoLmdjZCg4LCAxMik7ICAgICAgICAgICAgICAvLyByZXR1cm5zIDRcbiAgICogICAgbWF0aC54Z2NkKDM2MTYzLCAyMTE5OSk7ICAgICAgLy8gcmV0dXJucyBbMTI0NywgLTcsIDEyXVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgZ2NkLCBsY21cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXIgfCBCaWdOdW1iZXJ9IGEgIEFuIGludGVnZXIgbnVtYmVyXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgQmlnTnVtYmVyfSBiICBBbiBpbnRlZ2VyIG51bWJlclxuICAgKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgICAgIFJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyAzIGludGVnZXJzIGBbZGl2LCBtLCBuXWBcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGVyZSBgZGl2ID0gZ2NkKGEsIGIpYCBhbmQgYGEqbSArIGIqbiA9IGRpdmBcbiAgICovXG4gIHZhciB4Z2NkID0gdHlwZWQoJ3hnY2QnLCB7XG4gICAgJ251bWJlciwgbnVtYmVyJzogX3hnY2QsXG4gICAgJ0JpZ051bWJlciwgQmlnTnVtYmVyJzogX3hnY2RCaWdOdW1iZXJcbiAgICAvLyBUT0RPOiBpbXBsZW1lbnQgc3VwcG9ydCBmb3IgRnJhY3Rpb25cbiAgfSk7XG5cbiAgeGdjZC50b1RleCA9ICdcXFxcbWF0aHJteyR7bmFtZX19XFxcXGxlZnQoJHthcmdzfVxcXFxyaWdodCknO1xuXG4gIHJldHVybiB4Z2NkO1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgeGdjZCBmb3IgdHdvIG51bWJlcnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IGFcbiAgICogQHBhcmFtIHtudW1iZXJ9IGJcbiAgICogQHJldHVybiB7bnVtYmVyfSByZXN1bHRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF94Z2NkIChhLCBiKSB7XG4gICAgLy8gc291cmNlOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0V4dGVuZGVkX0V1Y2xpZGVhbl9hbGdvcml0aG1cbiAgICB2YXIgdCwgLy8gdXNlZCB0byBzd2FwIHR3byB2YXJpYWJsZXNcbiAgICAgICAgcSwgLy8gcXVvdGllbnRcbiAgICAgICAgciwgLy8gcmVtYWluZGVyXG4gICAgICAgIHggPSAwLCBsYXN0eCA9IDEsXG4gICAgICAgIHkgPSAxLCBsYXN0eSA9IDA7XG5cbiAgICBpZiAoIWlzSW50ZWdlcihhKSB8fCAhaXNJbnRlZ2VyKGIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcmFtZXRlcnMgaW4gZnVuY3Rpb24geGdjZCBtdXN0IGJlIGludGVnZXIgbnVtYmVycycpO1xuICAgIH1cblxuICAgIHdoaWxlIChiKSB7XG4gICAgICBxID0gTWF0aC5mbG9vcihhIC8gYik7XG4gICAgICByID0gYSAlIGI7XG5cbiAgICAgIHQgPSB4O1xuICAgICAgeCA9IGxhc3R4IC0gcSAqIHg7XG4gICAgICBsYXN0eCA9IHQ7XG5cbiAgICAgIHQgPSB5O1xuICAgICAgeSA9IGxhc3R5IC0gcSAqIHk7XG4gICAgICBsYXN0eSA9IHQ7XG5cbiAgICAgIGEgPSBiO1xuICAgICAgYiA9IHI7XG4gICAgfVxuXG4gICAgdmFyIHJlcztcbiAgICBpZiAoYSA8IDApIHtcbiAgICAgIHJlcyA9IFstYSwgLWxhc3R4LCAtbGFzdHldO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJlcyA9IFthLCBhID8gbGFzdHggOiAwLCBsYXN0eV07XG4gICAgfVxuICAgIHJldHVybiAoY29uZmlnLm1hdHJpeCA9PT0gJ0FycmF5JykgPyByZXMgOiBtYXRyaXgocmVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgeGdjZCBmb3IgdHdvIEJpZ051bWJlcnNcbiAgICogQHBhcmFtIHtCaWdOdW1iZXJ9IGFcbiAgICogQHBhcmFtIHtCaWdOdW1iZXJ9IGJcbiAgICogQHJldHVybiB7QmlnTnVtYmVyW119IHJlc3VsdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX3hnY2RCaWdOdW1iZXIoYSwgYikge1xuICAgIC8vIHNvdXJjZTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FeHRlbmRlZF9FdWNsaWRlYW5fYWxnb3JpdGhtXG4gICAgdmFyIHQsIC8vIHVzZWQgdG8gc3dhcCB0d28gdmFyaWFibGVzXG4gICAgICAgIHEsIC8vIHF1b3RpZW50XG4gICAgICAgIHIsIC8vIHJlbWFpbmRlclxuICAgICAgICB6ZXJvID0gbmV3IHR5cGUuQmlnTnVtYmVyKDApLFxuICAgICAgICBvbmUgPSBuZXcgdHlwZS5CaWdOdW1iZXIoMSksXG4gICAgICAgIHggPSB6ZXJvLFxuICAgICAgICBsYXN0eCA9IG9uZSxcbiAgICAgICAgeSA9IG9uZSxcbiAgICAgICAgbGFzdHkgPSB6ZXJvO1xuXG4gICAgaWYgKCFhLmlzSW50KCkgfHwgIWIuaXNJbnQoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJhbWV0ZXJzIGluIGZ1bmN0aW9uIHhnY2QgbXVzdCBiZSBpbnRlZ2VyIG51bWJlcnMnKTtcbiAgICB9XG5cbiAgICAvL2NvbnNvbGUubG9nKCdzdGFydCcsIFthLCBiXS50b1N0cmluZygpKVxuXG4gICAgd2hpbGUgKCFiLmlzWmVybygpKSB7XG4gICAgICAvL2NvbnNvbGUubG9nKCdpbm5lcicsIFthLCBiLCB0LCBxLCByLCB4LCB5LCBsYXN0eCwgbGFzdHldLnRvU3RyaW5nKCkpO1xuICAgICAgcSA9IGEuZGl2KGIpLmZsb29yKCk7XG4gICAgICByID0gYS5tb2QoYik7XG4gICAgICAvL2NvbnNvbGUubG9nKCdNT0QnLCBbYSwgYiwgYS5tb2QoYiksIHJdLnRvU3RyaW5nKCkpXG5cbiAgICAgIHQgPSB4O1xuICAgICAgeCA9IGxhc3R4Lm1pbnVzKHEudGltZXMoeCkpO1xuICAgICAgbGFzdHggPSB0O1xuXG4gICAgICB0ID0geTtcbiAgICAgIHkgPSBsYXN0eS5taW51cyhxLnRpbWVzKHkpKTtcbiAgICAgIGxhc3R5ID0gdDtcblxuICAgICAgYSA9IGI7XG4gICAgICBiID0gcjtcblxuICAgICAgLy9jb25zb2xlLmxvZygnaW5uZXIgZW5kJywgW2EsIGIsIHQsIHEsIHIsIHgsIHksIGxhc3R4LCBsYXN0eV0udG9TdHJpbmcoKSk7XG4gICAgfVxuXG4gICAgLy9jb25zb2xlLmxvZygnZW5kJywgW2EsIGxhc3R4LCBsYXN0eV0udG9TdHJpbmcoKSlcblxuICAgIHZhciByZXM7XG4gICAgaWYgKGEubHQoemVybykpIHtcbiAgICAgIHJlcyA9IFthLm5lZygpLCBsYXN0eC5uZWcoKSwgbGFzdHkubmVnKCldO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJlcyA9IFthLCAhYS5pc1plcm8oKSA/IGxhc3R4IDogMCwgbGFzdHldO1xuICAgIH1cbiAgICByZXR1cm4gKGNvbmZpZy5tYXRyaXggPT09ICdBcnJheScpID8gcmVzIDogbWF0cml4KHJlcyk7XG4gIH1cbn1cblxuZXhwb3J0cy5uYW1lID0gJ3hnY2QnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzSW50ZWdlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL251bWJlcicpLmlzSW50ZWdlcjtcbnZhciBiaWdCaXRBbmQgPSByZXF1aXJlKCcuLi8uLi91dGlscy9iaWdudW1iZXIvYml0QW5kJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIGxhdGV4ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbGF0ZXgnKTtcblxuICB2YXIgbWF0cml4ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC9mdW5jdGlvbi9tYXRyaXgnKSk7XG5cbiAgdmFyIGFsZ29yaXRobTAyID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0wMicpKTtcbiAgdmFyIGFsZ29yaXRobTA2ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0wNicpKTtcbiAgdmFyIGFsZ29yaXRobTExID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xMScpKTtcbiAgdmFyIGFsZ29yaXRobTEzID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xMycpKTtcbiAgdmFyIGFsZ29yaXRobTE0ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xNCcpKTtcbiAgXG4gIC8qKlxuICAgKiBCaXR3aXNlIEFORCB0d28gdmFsdWVzLCBgeCAmIHlgLlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguYml0QW5kKHgsIHkpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmJpdEFuZCg1MywgMTMxKTsgICAgICAgICAgICAgICAvLyByZXR1cm5zIG51bWJlciAxXG4gICAqXG4gICAqICAgIG1hdGguYml0QW5kKFsxLCAxMiwgMzFdLCA0Mik7ICAgICAgIC8vIHJldHVybnMgQXJyYXkgWzAsIDgsIDEwXVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgYml0Tm90LCBiaXRPciwgYml0WG9yLCBsZWZ0U2hpZnQsIHJpZ2h0QXJpdGhTaGlmdCwgcmlnaHRMb2dTaGlmdFxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBBcnJheSB8IE1hdHJpeH0geCBGaXJzdCB2YWx1ZSB0byBhbmRcbiAgICogQHBhcmFtICB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgQXJyYXkgfCBNYXRyaXh9IHkgU2Vjb25kIHZhbHVlIHRvIGFuZFxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBBcnJheSB8IE1hdHJpeH0gQU5EIG9mIGB4YCBhbmQgYHlgXG4gICAqL1xuICB2YXIgYml0QW5kID0gdHlwZWQoJ2JpdEFuZCcsIHtcblxuICAgICdudW1iZXIsIG51bWJlcic6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICBpZiAoIWlzSW50ZWdlcih4KSB8fCAhaXNJbnRlZ2VyKHkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW50ZWdlcnMgZXhwZWN0ZWQgaW4gZnVuY3Rpb24gYml0QW5kJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB4ICYgeTtcbiAgICB9LFxuXG4gICAgJ0JpZ051bWJlciwgQmlnTnVtYmVyJzogYmlnQml0QW5kLFxuXG4gICAgJ01hdHJpeCwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHJlc3VsdFxuICAgICAgdmFyIGM7XG5cbiAgICAgIC8vIHByb2Nlc3MgbWF0cml4IHN0b3JhZ2VcbiAgICAgIHN3aXRjaCAoeC5zdG9yYWdlKCkpIHtcbiAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICBzd2l0Y2ggKHkuc3RvcmFnZSgpKSB7XG4gICAgICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgICAgICAvLyBzcGFyc2UgJiBzcGFyc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTA2KHgsIHksIGJpdEFuZCwgZmFsc2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIHNwYXJzZSAmIGRlbnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0wMih5LCB4LCBiaXRBbmQsIHRydWUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgc3dpdGNoICh5LnN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICAgICAgLy8gZGVuc2UgJiBzcGFyc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTAyKHgsIHksIGJpdEFuZCwgZmFsc2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIGRlbnNlICYgZGVuc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTEzKHgsIHksIGJpdEFuZCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG4gICAgXG4gICAgJ0FycmF5LCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gYml0QW5kKG1hdHJpeCh4KSwgbWF0cml4KHkpKS52YWx1ZU9mKCk7XG4gICAgfSxcblxuICAgICdBcnJheSwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBiaXRBbmQobWF0cml4KHgpLCB5KTtcbiAgICB9LFxuXG4gICAgJ01hdHJpeCwgQXJyYXknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGJpdEFuZCh4LCBtYXRyaXgoeSkpO1xuICAgIH0sXG4gICAgXG4gICAgJ01hdHJpeCwgYW55JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHJlc3VsdFxuICAgICAgdmFyIGM7XG4gICAgICAvLyBjaGVjayBzdG9yYWdlIGZvcm1hdFxuICAgICAgc3dpdGNoICh4LnN0b3JhZ2UoKSkge1xuICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xMSh4LCB5LCBiaXRBbmQsIGZhbHNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTQoeCwgeSwgYml0QW5kLCBmYWxzZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuXG4gICAgJ2FueSwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHJlc3VsdFxuICAgICAgdmFyIGM7XG4gICAgICAvLyBjaGVjayBzdG9yYWdlIGZvcm1hdFxuICAgICAgc3dpdGNoICh5LnN0b3JhZ2UoKSkge1xuICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xMSh5LCB4LCBiaXRBbmQsIHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xNCh5LCB4LCBiaXRBbmQsIHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfSxcblxuICAgICdBcnJheSwgYW55JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBhbGdvcml0aG0xNChtYXRyaXgoeCksIHksIGJpdEFuZCwgZmFsc2UpLnZhbHVlT2YoKTtcbiAgICB9LFxuXG4gICAgJ2FueSwgQXJyYXknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGFsZ29yaXRobTE0KG1hdHJpeCh5KSwgeCwgYml0QW5kLCB0cnVlKS52YWx1ZU9mKCk7XG4gICAgfVxuICB9KTtcblxuICBiaXRBbmQudG9UZXggPSAnXFxcXGxlZnQoJHthcmdzWzBdfScgKyBsYXRleC5vcGVyYXRvcnNbJ2JpdEFuZCddICsgJyR7YXJnc1sxXX1cXFxccmlnaHQpJztcblxuICByZXR1cm4gYml0QW5kO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnYml0QW5kJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWVwTWFwID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9kZWVwTWFwJyk7XG52YXIgYmlnQml0Tm90ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYmlnbnVtYmVyL2JpdE5vdCcpO1xudmFyIGlzSW50ZWdlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL251bWJlcicpLmlzSW50ZWdlcjtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgbGF0ZXggPSByZXF1aXJlKCcuLi8uLi91dGlscy9sYXRleCcpO1xuXG4gIC8qKlxuICAgKiBCaXR3aXNlIE5PVCB2YWx1ZSwgYH54YC5cbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICogRm9yIHVuaXRzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIG9uIHRoZSBiZXN0IHByZWZpeCBiYXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguYml0Tm90KHgpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmJpdE5vdCgxKTsgICAgICAgICAgICAgICAvLyByZXR1cm5zIG51bWJlciAtMlxuICAgKlxuICAgKiAgICBtYXRoLmJpdE5vdChbMiwgLTMsIDRdKTsgICAgICAvLyByZXR1cm5zIEFycmF5IFstMywgMiwgNV1cbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGJpdEFuZCwgYml0T3IsIGJpdFhvciwgbGVmdFNoaWZ0LCByaWdodEFyaXRoU2hpZnQsIHJpZ2h0TG9nU2hpZnRcbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgQXJyYXkgfCBNYXRyaXh9IHggVmFsdWUgdG8gbm90XG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlciB8IEFycmF5IHwgTWF0cml4fSBOT1Qgb2YgYHhgXG4gICAqL1xuICB2YXIgYml0Tm90ID0gdHlwZWQoJ2JpdE5vdCcsIHtcbiAgICAnbnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICghaXNJbnRlZ2VyKHgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW50ZWdlciBleHBlY3RlZCBpbiBmdW5jdGlvbiBiaXROb3QnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIH54O1xuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyJzogYmlnQml0Tm90LFxuXG4gICAgJ0FycmF5IHwgTWF0cml4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBkZWVwTWFwKHgsIGJpdE5vdCk7XG4gICAgfVxuICB9KTtcblxuICBiaXROb3QudG9UZXggPSBsYXRleC5vcGVyYXRvcnNbJ2JpdE5vdCddICsgJ1xcXFxsZWZ0KCR7YXJnc1swXX1cXFxccmlnaHQpJztcblxuICByZXR1cm4gYml0Tm90O1xufVxuXG5leHBvcnRzLm5hbWUgPSAnYml0Tm90JztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0ludGVnZXIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9udW1iZXInKS5pc0ludGVnZXI7XG52YXIgYmlnQml0T3IgPSByZXF1aXJlKCcuLi8uLi91dGlscy9iaWdudW1iZXIvYml0T3InKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgbGF0ZXggPSByZXF1aXJlKCcuLi8uLi91dGlscy9sYXRleCcpO1xuXG4gIHZhciBtYXRyaXggPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L2Z1bmN0aW9uL21hdHJpeCcpKTtcblxuICB2YXIgYWxnb3JpdGhtMDEgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTAxJykpO1xuICB2YXIgYWxnb3JpdGhtMDQgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTA0JykpO1xuICB2YXIgYWxnb3JpdGhtMTAgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTEwJykpO1xuICB2YXIgYWxnb3JpdGhtMTMgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTEzJykpO1xuICB2YXIgYWxnb3JpdGhtMTQgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTE0JykpO1xuICBcbiAgLyoqXG4gICAqIEJpdHdpc2UgT1IgdHdvIHZhbHVlcywgYHggfCB5YC5cbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICogRm9yIHVuaXRzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIG9uIHRoZSBsb3dlc3QgcHJpbnQgYmFzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmJpdE9yKHgsIHkpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmJpdE9yKDEsIDIpOyAgICAgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIDNcbiAgICpcbiAgICogICAgbWF0aC5iaXRPcihbMSwgMiwgM10sIDQpOyAgICAgICAvLyByZXR1cm5zIEFycmF5IFs1LCA2LCA3XVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgYml0QW5kLCBiaXROb3QsIGJpdFhvciwgbGVmdFNoaWZ0LCByaWdodEFyaXRoU2hpZnQsIHJpZ2h0TG9nU2hpZnRcbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgQXJyYXkgfCBNYXRyaXh9IHggRmlyc3QgdmFsdWUgdG8gb3JcbiAgICogQHBhcmFtICB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgQXJyYXkgfCBNYXRyaXh9IHkgU2Vjb25kIHZhbHVlIHRvIG9yXG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlciB8IEFycmF5IHwgTWF0cml4fSBPUiBvZiBgeGAgYW5kIGB5YFxuICAgKi9cbiAgdmFyIGJpdE9yID0gdHlwZWQoJ2JpdE9yJywge1xuXG4gICAgJ251bWJlciwgbnVtYmVyJzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIGlmICghaXNJbnRlZ2VyKHgpIHx8ICFpc0ludGVnZXIoeSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnRlZ2VycyBleHBlY3RlZCBpbiBmdW5jdGlvbiBiaXRPcicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4geCB8IHk7XG4gICAgfSxcblxuICAgICdCaWdOdW1iZXIsIEJpZ051bWJlcic6IGJpZ0JpdE9yLFxuXG4gICAgJ01hdHJpeCwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHJlc3VsdFxuICAgICAgdmFyIGM7XG5cbiAgICAgIC8vIHByb2Nlc3MgbWF0cml4IHN0b3JhZ2VcbiAgICAgIHN3aXRjaCAoeC5zdG9yYWdlKCkpIHtcbiAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICBzd2l0Y2ggKHkuc3RvcmFnZSgpKSB7XG4gICAgICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgICAgICAvLyBzcGFyc2UgKyBzcGFyc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTA0KHgsIHksIGJpdE9yKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAvLyBzcGFyc2UgKyBkZW5zZVxuICAgICAgICAgICAgICBjID0gYWxnb3JpdGhtMDEoeSwgeCwgYml0T3IsIHRydWUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgc3dpdGNoICh5LnN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICAgICAgLy8gZGVuc2UgKyBzcGFyc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTAxKHgsIHksIGJpdE9yLCBmYWxzZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTEzKHgsIHksIGJpdE9yKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfSxcblxuICAgICdBcnJheSwgQXJyYXknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGJpdE9yKG1hdHJpeCh4KSwgbWF0cml4KHkpKS52YWx1ZU9mKCk7XG4gICAgfSxcblxuICAgICdBcnJheSwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBiaXRPcihtYXRyaXgoeCksIHkpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4LCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gYml0T3IoeCwgbWF0cml4KHkpKTtcbiAgICB9LFxuXG4gICAgJ01hdHJpeCwgYW55JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHJlc3VsdFxuICAgICAgdmFyIGM7XG4gICAgICAvLyBjaGVjayBzdG9yYWdlIGZvcm1hdFxuICAgICAgc3dpdGNoICh4LnN0b3JhZ2UoKSkge1xuICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xMCh4LCB5LCBiaXRPciwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xNCh4LCB5LCBiaXRPciwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfSxcblxuICAgICdhbnksIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuICAgICAgLy8gY2hlY2sgc3RvcmFnZSBmb3JtYXRcbiAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTAoeSwgeCwgYml0T3IsIHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xNCh5LCB4LCBiaXRPciwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBhbnknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGFsZ29yaXRobTE0KG1hdHJpeCh4KSwgeSwgYml0T3IsIGZhbHNlKS52YWx1ZU9mKCk7XG4gICAgfSxcblxuICAgICdhbnksIEFycmF5JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBhbGdvcml0aG0xNChtYXRyaXgoeSksIHgsIGJpdE9yLCB0cnVlKS52YWx1ZU9mKCk7XG4gICAgfVxuICB9KTtcblxuICBiaXRPci50b1RleCA9ICdcXFxcbGVmdCgke2FyZ3NbMF19JyArIGxhdGV4Lm9wZXJhdG9yc1snYml0T3InXSArICcke2FyZ3NbMV19XFxcXHJpZ2h0KSc7XG5cbiAgcmV0dXJuIGJpdE9yO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnYml0T3InO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzSW50ZWdlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL251bWJlcicpLmlzSW50ZWdlcjtcbnZhciBiaWdCaXRYb3IgPSByZXF1aXJlKCcuLi8uLi91dGlscy9iaWdudW1iZXIvYml0WG9yJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIGxhdGV4ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbGF0ZXgnKTtcblxuICB2YXIgbWF0cml4ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC9mdW5jdGlvbi9tYXRyaXgnKSk7XG5cbiAgdmFyIGFsZ29yaXRobTAzID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0wMycpKTtcbiAgdmFyIGFsZ29yaXRobTA3ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0wNycpKTtcbiAgdmFyIGFsZ29yaXRobTEyID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xMicpKTtcbiAgdmFyIGFsZ29yaXRobTEzID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xMycpKTtcbiAgdmFyIGFsZ29yaXRobTE0ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xNCcpKTtcblxuICAvKipcbiAgICogQml0d2lzZSBYT1IgdHdvIHZhbHVlcywgYHggXiB5YC5cbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmJpdFhvcih4LCB5KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5iaXRYb3IoMSwgMik7ICAgICAgICAgICAgICAgLy8gcmV0dXJucyBudW1iZXIgM1xuICAgKlxuICAgKiAgICBtYXRoLmJpdFhvcihbMiwgMywgNF0sIDQpOyAgICAgICAvLyByZXR1cm5zIEFycmF5IFs2LCA3LCAwXVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgYml0QW5kLCBiaXROb3QsIGJpdE9yLCBsZWZ0U2hpZnQsIHJpZ2h0QXJpdGhTaGlmdCwgcmlnaHRMb2dTaGlmdFxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBBcnJheSB8IE1hdHJpeH0geCBGaXJzdCB2YWx1ZSB0byB4b3JcbiAgICogQHBhcmFtICB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgQXJyYXkgfCBNYXRyaXh9IHkgU2Vjb25kIHZhbHVlIHRvIHhvclxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBBcnJheSB8IE1hdHJpeH0gWE9SIG9mIGB4YCBhbmQgYHlgXG4gICAqL1xuICB2YXIgYml0WG9yID0gdHlwZWQoJ2JpdFhvcicsIHtcblxuICAgICdudW1iZXIsIG51bWJlcic6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICBpZiAoIWlzSW50ZWdlcih4KSB8fCAhaXNJbnRlZ2VyKHkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW50ZWdlcnMgZXhwZWN0ZWQgaW4gZnVuY3Rpb24gYml0WG9yJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB4IF4geTtcbiAgICB9LFxuXG4gICAgJ0JpZ051bWJlciwgQmlnTnVtYmVyJzogYmlnQml0WG9yLFxuXG4gICAgJ01hdHJpeCwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHJlc3VsdFxuICAgICAgdmFyIGM7XG5cbiAgICAgIC8vIHByb2Nlc3MgbWF0cml4IHN0b3JhZ2VcbiAgICAgIHN3aXRjaCAoeC5zdG9yYWdlKCkpIHtcbiAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICBzd2l0Y2ggKHkuc3RvcmFnZSgpKSB7XG4gICAgICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgICAgICAvLyBzcGFyc2UgKyBzcGFyc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTA3KHgsIHksIGJpdFhvcik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgLy8gc3BhcnNlICsgZGVuc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTAzKHksIHgsIGJpdFhvciwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBzd2l0Y2ggKHkuc3RvcmFnZSgpKSB7XG4gICAgICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgICAgICAvLyBkZW5zZSArIHNwYXJzZVxuICAgICAgICAgICAgICBjID0gYWxnb3JpdGhtMDMoeCwgeSwgYml0WG9yLCBmYWxzZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgLy8gZGVuc2UgKyBkZW5zZVxuICAgICAgICAgICAgICBjID0gYWxnb3JpdGhtMTMoeCwgeSwgYml0WG9yKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfSxcblxuICAgICdBcnJheSwgQXJyYXknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGJpdFhvcihtYXRyaXgoeCksIG1hdHJpeCh5KSkudmFsdWVPZigpO1xuICAgIH0sXG5cbiAgICAnQXJyYXksIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gYml0WG9yKG1hdHJpeCh4KSwgeSk7XG4gICAgfSxcblxuICAgICdNYXRyaXgsIEFycmF5JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBiaXRYb3IoeCwgbWF0cml4KHkpKTtcbiAgICB9LFxuXG4gICAgJ01hdHJpeCwgYW55JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHJlc3VsdFxuICAgICAgdmFyIGM7XG4gICAgICAvLyBjaGVjayBzdG9yYWdlIGZvcm1hdFxuICAgICAgc3dpdGNoICh4LnN0b3JhZ2UoKSkge1xuICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xMih4LCB5LCBiaXRYb3IsIGZhbHNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTQoeCwgeSwgYml0WG9yLCBmYWxzZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuXG4gICAgJ2FueSwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHJlc3VsdFxuICAgICAgdmFyIGM7XG4gICAgICAvLyBjaGVjayBzdG9yYWdlIGZvcm1hdFxuICAgICAgc3dpdGNoICh5LnN0b3JhZ2UoKSkge1xuICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xMih5LCB4LCBiaXRYb3IsIHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xNCh5LCB4LCBiaXRYb3IsIHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfSxcblxuICAgICdBcnJheSwgYW55JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBhbGdvcml0aG0xNChtYXRyaXgoeCksIHksIGJpdFhvciwgZmFsc2UpLnZhbHVlT2YoKTtcbiAgICB9LFxuXG4gICAgJ2FueSwgQXJyYXknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGFsZ29yaXRobTE0KG1hdHJpeCh5KSwgeCwgYml0WG9yLCB0cnVlKS52YWx1ZU9mKCk7XG4gICAgfVxuICB9KTtcblxuICBiaXRYb3IudG9UZXggPSAnXFxcXGxlZnQoJHthcmdzWzBdfScgKyBsYXRleC5vcGVyYXRvcnNbJ2JpdFhvciddICsgJyR7YXJnc1sxXX1cXFxccmlnaHQpJztcblxuICByZXR1cm4gYml0WG9yO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnYml0WG9yJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFtcbiAgcmVxdWlyZSgnLi9iaXRBbmQnKSxcbiAgcmVxdWlyZSgnLi9iaXROb3QnKSxcbiAgcmVxdWlyZSgnLi9iaXRPcicpLFxuICByZXF1aXJlKCcuL2JpdFhvcicpLFxuICByZXF1aXJlKCcuL2xlZnRTaGlmdCcpLFxuICByZXF1aXJlKCcuL3JpZ2h0QXJpdGhTaGlmdCcpLFxuICByZXF1aXJlKCcuL3JpZ2h0TG9nU2hpZnQnKVxuXTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzSW50ZWdlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL251bWJlcicpLmlzSW50ZWdlcjtcbnZhciBiaWdMZWZ0U2hpZnQgPSByZXF1aXJlKCcuLi8uLi91dGlscy9iaWdudW1iZXIvbGVmdFNoaWZ0Jyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIGxhdGV4ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbGF0ZXgnKTtcblxuICB2YXIgbWF0cml4ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC9mdW5jdGlvbi9tYXRyaXgnKSk7XG4gIHZhciBlcXVhbFNjYWxhciA9IGxvYWQocmVxdWlyZSgnLi4vcmVsYXRpb25hbC9lcXVhbFNjYWxhcicpKTtcbiAgdmFyIHplcm9zID0gbG9hZChyZXF1aXJlKCcuLi9tYXRyaXgvemVyb3MnKSk7XG5cbiAgdmFyIGFsZ29yaXRobTAxID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0wMScpKTtcbiAgdmFyIGFsZ29yaXRobTAyID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0wMicpKTtcbiAgdmFyIGFsZ29yaXRobTA4ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0wOCcpKTtcbiAgdmFyIGFsZ29yaXRobTEwID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xMCcpKTtcbiAgdmFyIGFsZ29yaXRobTExID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xMScpKTtcbiAgdmFyIGFsZ29yaXRobTEzID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xMycpKTtcbiAgdmFyIGFsZ29yaXRobTE0ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xNCcpKTtcblxuICAvKipcbiAgICogQml0d2lzZSBsZWZ0IGxvZ2ljYWwgc2hpZnQgb2YgYSB2YWx1ZSB4IGJ5IHkgbnVtYmVyIG9mIGJpdHMsIGB4IDw8IHlgLlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKiBGb3IgdW5pdHMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgb24gdGhlIGJlc3QgcHJlZml4IGJhc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5sZWZ0U2hpZnQoeCwgeSlcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGgubGVmdFNoaWZ0KDEsIDIpOyAgICAgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIDRcbiAgICpcbiAgICogICAgbWF0aC5sZWZ0U2hpZnQoWzEsIDIsIDNdLCA0KTsgICAgICAgLy8gcmV0dXJucyBBcnJheSBbMTYsIDMyLCA2NF1cbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGxlZnRTaGlmdCwgYml0Tm90LCBiaXRPciwgYml0WG9yLCByaWdodEFyaXRoU2hpZnQsIHJpZ2h0TG9nU2hpZnRcbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgQXJyYXkgfCBNYXRyaXh9IHggVmFsdWUgdG8gYmUgc2hpZnRlZFxuICAgKiBAcGFyYW0gIHtudW1iZXIgfCBCaWdOdW1iZXJ9IHkgQW1vdW50IG9mIHNoaWZ0c1xuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBBcnJheSB8IE1hdHJpeH0gYHhgIHNoaWZ0ZWQgbGVmdCBgeWAgdGltZXNcbiAgICovXG4gIHZhciBsZWZ0U2hpZnQgPSB0eXBlZCgnbGVmdFNoaWZ0Jywge1xuICAgIFxuICAgICdudW1iZXIsIG51bWJlcic6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICBpZiAoIWlzSW50ZWdlcih4KSB8fCAhaXNJbnRlZ2VyKHkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW50ZWdlcnMgZXhwZWN0ZWQgaW4gZnVuY3Rpb24gbGVmdFNoaWZ0Jyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB4IDw8IHk7XG4gICAgfSxcblxuICAgICdCaWdOdW1iZXIsIEJpZ051bWJlcic6IGJpZ0xlZnRTaGlmdCxcblxuICAgICdNYXRyaXgsIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuXG4gICAgICAvLyBwcm9jZXNzIG1hdHJpeCBzdG9yYWdlXG4gICAgICBzd2l0Y2ggKHguc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgc3dpdGNoICh5LnN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICAgICAgLy8gc3BhcnNlICYgc3BhcnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0wOCh4LCB5LCBsZWZ0U2hpZnQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAvLyBzcGFyc2UgJiBkZW5zZVxuICAgICAgICAgICAgICBjID0gYWxnb3JpdGhtMDIoeSwgeCwgbGVmdFNoaWZ0LCB0cnVlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgICAgIC8vIGRlbnNlICYgc3BhcnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0wMSh4LCB5LCBsZWZ0U2hpZnQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAvLyBkZW5zZSAmIGRlbnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0xMyh4LCB5LCBsZWZ0U2hpZnQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gbGVmdFNoaWZ0KG1hdHJpeCh4KSwgbWF0cml4KHkpKS52YWx1ZU9mKCk7XG4gICAgfSxcblxuICAgICdBcnJheSwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBsZWZ0U2hpZnQobWF0cml4KHgpLCB5KTtcbiAgICB9LFxuXG4gICAgJ01hdHJpeCwgQXJyYXknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGxlZnRTaGlmdCh4LCBtYXRyaXgoeSkpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4LCBudW1iZXIgfCBCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gY2hlY2sgc2NhbGFyXG4gICAgICBpZiAoIWVxdWFsU2NhbGFyKHksIDApKSB7XG4gICAgICAgIC8vIHJlc3VsdFxuICAgICAgICB2YXIgYztcbiAgICAgICAgLy8gY2hlY2sgc3RvcmFnZSBmb3JtYXRcbiAgICAgICAgc3dpdGNoICh4LnN0b3JhZ2UoKSkge1xuICAgICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgICBjID0gYWxnb3JpdGhtMTEoeCwgeSwgbGVmdFNoaWZ0LCBmYWxzZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYyA9IGFsZ29yaXRobTE0KHgsIHksIGxlZnRTaGlmdCwgZmFsc2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGM7XG4gICAgICB9XG4gICAgICByZXR1cm4geC5jbG9uZSgpO1xuICAgIH0sXG5cbiAgICAnbnVtYmVyIHwgQmlnTnVtYmVyLCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gY2hlY2sgc2NhbGFyXG4gICAgICBpZiAoIWVxdWFsU2NhbGFyKHgsIDApKSB7XG4gICAgICAgIC8vIHJlc3VsdFxuICAgICAgICB2YXIgYztcbiAgICAgICAgLy8gY2hlY2sgc3RvcmFnZSBmb3JtYXRcbiAgICAgICAgc3dpdGNoICh5LnN0b3JhZ2UoKSkge1xuICAgICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgICBjID0gYWxnb3JpdGhtMTAoeSwgeCwgbGVmdFNoaWZ0LCB0cnVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjID0gYWxnb3JpdGhtMTQoeSwgeCwgbGVmdFNoaWZ0LCB0cnVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHplcm9zKHkuc2l6ZSgpLCB5LnN0b3JhZ2UoKSk7XG4gICAgfSxcblxuICAgICdBcnJheSwgbnVtYmVyIHwgQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBsZWZ0U2hpZnQobWF0cml4KHgpLCB5KS52YWx1ZU9mKCk7XG4gICAgfSxcblxuICAgICdudW1iZXIgfCBCaWdOdW1iZXIsIEFycmF5JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBsZWZ0U2hpZnQoeCwgbWF0cml4KHkpKS52YWx1ZU9mKCk7XG4gICAgfVxuICB9KTtcblxuICBsZWZ0U2hpZnQudG9UZXggPSAnXFxcXGxlZnQoJHthcmdzWzBdfScgKyBsYXRleC5vcGVyYXRvcnNbJ2xlZnRTaGlmdCddICsgJyR7YXJnc1sxXX1cXFxccmlnaHQpJztcblxuICByZXR1cm4gbGVmdFNoaWZ0O1xufVxuXG5leHBvcnRzLm5hbWUgPSAnbGVmdFNoaWZ0JztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0ludGVnZXIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9udW1iZXInKS5pc0ludGVnZXI7XG52YXIgYmlnUmlnaHRBcml0aFNoaWZ0ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYmlnbnVtYmVyL3JpZ2h0QXJpdGhTaGlmdCcpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBsYXRleCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2xhdGV4Jyk7XG4gIFxuICB2YXIgbWF0cml4ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC9mdW5jdGlvbi9tYXRyaXgnKSk7XG4gIHZhciBlcXVhbFNjYWxhciA9IGxvYWQocmVxdWlyZSgnLi4vcmVsYXRpb25hbC9lcXVhbFNjYWxhcicpKTtcbiAgdmFyIHplcm9zID0gbG9hZChyZXF1aXJlKCcuLi9tYXRyaXgvemVyb3MnKSk7XG5cbiAgdmFyIGFsZ29yaXRobTAxID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0wMScpKTtcbiAgdmFyIGFsZ29yaXRobTAyID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0wMicpKTtcbiAgdmFyIGFsZ29yaXRobTA4ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0wOCcpKTtcbiAgdmFyIGFsZ29yaXRobTEwID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xMCcpKTtcbiAgdmFyIGFsZ29yaXRobTExID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xMScpKTtcbiAgdmFyIGFsZ29yaXRobTEzID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xMycpKTtcbiAgdmFyIGFsZ29yaXRobTE0ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xNCcpKTtcblxuICAvKipcbiAgICogQml0d2lzZSByaWdodCBhcml0aG1ldGljIHNoaWZ0IG9mIGEgdmFsdWUgeCBieSB5IG51bWJlciBvZiBiaXRzLCBgeCA+PiB5YC5cbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICogRm9yIHVuaXRzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIG9uIHRoZSBiZXN0IHByZWZpeCBiYXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGgucmlnaHRBcml0aFNoaWZ0KHgsIHkpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLnJpZ2h0QXJpdGhTaGlmdCg0LCAyKTsgICAgICAgICAgICAgICAvLyByZXR1cm5zIG51bWJlciAxXG4gICAqXG4gICAqICAgIG1hdGgucmlnaHRBcml0aFNoaWZ0KFsxNiwgLTMyLCA2NF0sIDQpOyAgIC8vIHJldHVybnMgQXJyYXkgWzEsIC0yLCAzXVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgYml0QW5kLCBiaXROb3QsIGJpdE9yLCBiaXRYb3IsIHJpZ2h0QXJpdGhTaGlmdCwgcmlnaHRMb2dTaGlmdFxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBBcnJheSB8IE1hdHJpeH0geCBWYWx1ZSB0byBiZSBzaGlmdGVkXG4gICAqIEBwYXJhbSAge251bWJlciB8IEJpZ051bWJlcn0geSBBbW91bnQgb2Ygc2hpZnRzXG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlciB8IEFycmF5IHwgTWF0cml4fSBgeGAgc2lnbi1maWxsZWQgc2hpZnRlZCByaWdodCBgeWAgdGltZXNcbiAgICovXG4gIHZhciByaWdodEFyaXRoU2hpZnQgPSB0eXBlZCgncmlnaHRBcml0aFNoaWZ0Jywge1xuXG4gICAgJ251bWJlciwgbnVtYmVyJzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIGlmICghaXNJbnRlZ2VyKHgpIHx8ICFpc0ludGVnZXIoeSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnRlZ2VycyBleHBlY3RlZCBpbiBmdW5jdGlvbiByaWdodEFyaXRoU2hpZnQnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHggPj4geTtcbiAgICB9LFxuXG4gICAgJ0JpZ051bWJlciwgQmlnTnVtYmVyJzogYmlnUmlnaHRBcml0aFNoaWZ0LFxuXG4gICAgJ01hdHJpeCwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHJlc3VsdFxuICAgICAgdmFyIGM7XG5cbiAgICAgIC8vIHByb2Nlc3MgbWF0cml4IHN0b3JhZ2VcbiAgICAgIHN3aXRjaCAoeC5zdG9yYWdlKCkpIHtcbiAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICBzd2l0Y2ggKHkuc3RvcmFnZSgpKSB7XG4gICAgICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgICAgICAvLyBzcGFyc2UgJiBzcGFyc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTA4KHgsIHksIHJpZ2h0QXJpdGhTaGlmdCwgZmFsc2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIHNwYXJzZSAmIGRlbnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0wMih5LCB4LCByaWdodEFyaXRoU2hpZnQsIHRydWUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgc3dpdGNoICh5LnN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICAgICAgLy8gZGVuc2UgJiBzcGFyc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTAxKHgsIHksIHJpZ2h0QXJpdGhTaGlmdCwgZmFsc2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIGRlbnNlICYgZGVuc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTEzKHgsIHksIHJpZ2h0QXJpdGhTaGlmdCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG5cbiAgICAnQXJyYXksIEFycmF5JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiByaWdodEFyaXRoU2hpZnQobWF0cml4KHgpLCBtYXRyaXgoeSkpLnZhbHVlT2YoKTtcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIHJpZ2h0QXJpdGhTaGlmdChtYXRyaXgoeCksIHkpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4LCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gcmlnaHRBcml0aFNoaWZ0KHgsIG1hdHJpeCh5KSk7XG4gICAgfSxcblxuICAgICdNYXRyaXgsIG51bWJlciB8IEJpZ051bWJlcic6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyBjaGVjayBzY2FsYXJcbiAgICAgIGlmICghZXF1YWxTY2FsYXIoeSwgMCkpIHtcbiAgICAgICAgLy8gcmVzdWx0XG4gICAgICAgIHZhciBjO1xuICAgICAgICAvLyBjaGVjayBzdG9yYWdlIGZvcm1hdFxuICAgICAgICBzd2l0Y2ggKHguc3RvcmFnZSgpKSB7XG4gICAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICAgIGMgPSBhbGdvcml0aG0xMSh4LCB5LCByaWdodEFyaXRoU2hpZnQsIGZhbHNlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjID0gYWxnb3JpdGhtMTQoeCwgeSwgcmlnaHRBcml0aFNoaWZ0LCBmYWxzZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYztcbiAgICAgIH1cbiAgICAgIHJldHVybiB4LmNsb25lKCk7XG4gICAgfSxcblxuICAgICdudW1iZXIgfCBCaWdOdW1iZXIsIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyBjaGVjayBzY2FsYXJcbiAgICAgIGlmICghZXF1YWxTY2FsYXIoeCwgMCkpIHtcbiAgICAgICAgLy8gcmVzdWx0XG4gICAgICAgIHZhciBjO1xuICAgICAgICAvLyBjaGVjayBzdG9yYWdlIGZvcm1hdFxuICAgICAgICBzd2l0Y2ggKHkuc3RvcmFnZSgpKSB7XG4gICAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICAgIGMgPSBhbGdvcml0aG0xMCh5LCB4LCByaWdodEFyaXRoU2hpZnQsIHRydWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGMgPSBhbGdvcml0aG0xNCh5LCB4LCByaWdodEFyaXRoU2hpZnQsIHRydWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGM7XG4gICAgICB9XG4gICAgICByZXR1cm4gemVyb3MoeS5zaXplKCksIHkuc3RvcmFnZSgpKTtcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBudW1iZXIgfCBCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIHJpZ2h0QXJpdGhTaGlmdChtYXRyaXgoeCksIHkpLnZhbHVlT2YoKTtcbiAgICB9LFxuXG4gICAgJ251bWJlciB8IEJpZ051bWJlciwgQXJyYXknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIHJpZ2h0QXJpdGhTaGlmdCh4LCBtYXRyaXgoeSkpLnZhbHVlT2YoKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJpZ2h0QXJpdGhTaGlmdC50b1RleCA9ICdcXFxcbGVmdCgke2FyZ3NbMF19JyArIGxhdGV4Lm9wZXJhdG9yc1sncmlnaHRBcml0aFNoaWZ0J10gKyAnJHthcmdzWzFdfVxcXFxyaWdodCknO1xuXG4gIHJldHVybiByaWdodEFyaXRoU2hpZnQ7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdyaWdodEFyaXRoU2hpZnQnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzSW50ZWdlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL251bWJlcicpLmlzSW50ZWdlcjtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgbGF0ZXggPSByZXF1aXJlKCcuLi8uLi91dGlscy9sYXRleCcpO1xuXG4gIHZhciBtYXRyaXggPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L2Z1bmN0aW9uL21hdHJpeCcpKTtcbiAgdmFyIGVxdWFsU2NhbGFyID0gbG9hZChyZXF1aXJlKCcuLi9yZWxhdGlvbmFsL2VxdWFsU2NhbGFyJykpO1xuICB2YXIgemVyb3MgPSBsb2FkKHJlcXVpcmUoJy4uL21hdHJpeC96ZXJvcycpKTtcblxuICB2YXIgYWxnb3JpdGhtMDEgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTAxJykpO1xuICB2YXIgYWxnb3JpdGhtMDIgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTAyJykpO1xuICB2YXIgYWxnb3JpdGhtMDggPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTA4JykpO1xuICB2YXIgYWxnb3JpdGhtMTAgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTEwJykpO1xuICB2YXIgYWxnb3JpdGhtMTEgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTExJykpO1xuICB2YXIgYWxnb3JpdGhtMTMgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTEzJykpO1xuICB2YXIgYWxnb3JpdGhtMTQgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTE0JykpO1xuICBcbiAgLyoqXG4gICAqIEJpdHdpc2UgcmlnaHQgbG9naWNhbCBzaGlmdCBvZiB2YWx1ZSB4IGJ5IHkgbnVtYmVyIG9mIGJpdHMsIGB4ID4+PiB5YC5cbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICogRm9yIHVuaXRzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIG9uIHRoZSBiZXN0IHByZWZpeCBiYXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGgucmlnaHRMb2dTaGlmdCh4LCB5KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5yaWdodExvZ1NoaWZ0KDQsIDIpOyAgICAgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIDFcbiAgICpcbiAgICogICAgbWF0aC5yaWdodExvZ1NoaWZ0KFsxNiwgLTMyLCA2NF0sIDQpOyAgIC8vIHJldHVybnMgQXJyYXkgWzEsIDIsIDNdXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBiaXRBbmQsIGJpdE5vdCwgYml0T3IsIGJpdFhvciwgbGVmdFNoaWZ0LCByaWdodExvZ1NoaWZ0XG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlciB8IEFycmF5IHwgTWF0cml4fSB4IFZhbHVlIHRvIGJlIHNoaWZ0ZWRcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5IEFtb3VudCBvZiBzaGlmdHNcbiAgICogQHJldHVybiB7bnVtYmVyIHwgQXJyYXkgfCBNYXRyaXh9IGB4YCB6ZXJvLWZpbGxlZCBzaGlmdGVkIHJpZ2h0IGB5YCB0aW1lc1xuICAgKi9cblxuICB2YXIgcmlnaHRMb2dTaGlmdCA9IHR5cGVkKCdyaWdodExvZ1NoaWZ0Jywge1xuXG4gICAgJ251bWJlciwgbnVtYmVyJzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIGlmICghaXNJbnRlZ2VyKHgpIHx8ICFpc0ludGVnZXIoeSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnRlZ2VycyBleHBlY3RlZCBpbiBmdW5jdGlvbiByaWdodExvZ1NoaWZ0Jyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB4ID4+PiB5O1xuICAgIH0sXG5cbiAgICAvLyAnQmlnTnVtYmVyLCBCaWdOdW1iZXInOiAuLi4sIC8vIFRPRE86IGltcGxlbWVudCBCaWdOdW1iZXIgc3VwcG9ydCBmb3IgcmlnaHRMb2dTaGlmdFxuXG4gICAgJ01hdHJpeCwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHJlc3VsdFxuICAgICAgdmFyIGM7XG5cbiAgICAgIC8vIHByb2Nlc3MgbWF0cml4IHN0b3JhZ2VcbiAgICAgIHN3aXRjaCAoeC5zdG9yYWdlKCkpIHtcbiAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICBzd2l0Y2ggKHkuc3RvcmFnZSgpKSB7XG4gICAgICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgICAgICAvLyBzcGFyc2UgJiBzcGFyc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTA4KHgsIHksIHJpZ2h0TG9nU2hpZnQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAvLyBzcGFyc2UgJiBkZW5zZVxuICAgICAgICAgICAgICBjID0gYWxnb3JpdGhtMDIoeSwgeCwgcmlnaHRMb2dTaGlmdCwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBzd2l0Y2ggKHkuc3RvcmFnZSgpKSB7XG4gICAgICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgICAgICAvLyBkZW5zZSAmIHNwYXJzZVxuICAgICAgICAgICAgICBjID0gYWxnb3JpdGhtMDEoeCwgeSwgcmlnaHRMb2dTaGlmdCwgZmFsc2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIGRlbnNlICYgZGVuc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTEzKHgsIHksIHJpZ2h0TG9nU2hpZnQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gcmlnaHRMb2dTaGlmdChtYXRyaXgoeCksIG1hdHJpeCh5KSkudmFsdWVPZigpO1xuICAgIH0sXG5cbiAgICAnQXJyYXksIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gcmlnaHRMb2dTaGlmdChtYXRyaXgoeCksIHkpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4LCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gcmlnaHRMb2dTaGlmdCh4LCBtYXRyaXgoeSkpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4LCBudW1iZXIgfCBCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gY2hlY2sgc2NhbGFyXG4gICAgICBpZiAoIWVxdWFsU2NhbGFyKHksIDApKSB7XG4gICAgICAgIC8vIHJlc3VsdFxuICAgICAgICB2YXIgYztcbiAgICAgICAgLy8gY2hlY2sgc3RvcmFnZSBmb3JtYXRcbiAgICAgICAgc3dpdGNoICh4LnN0b3JhZ2UoKSkge1xuICAgICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgICBjID0gYWxnb3JpdGhtMTEoeCwgeSwgcmlnaHRMb2dTaGlmdCwgZmFsc2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGMgPSBhbGdvcml0aG0xNCh4LCB5LCByaWdodExvZ1NoaWZ0LCBmYWxzZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYztcbiAgICAgIH1cbiAgICAgIHJldHVybiB4LmNsb25lKCk7XG4gICAgfSxcblxuICAgICdudW1iZXIgfCBCaWdOdW1iZXIsIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyBjaGVjayBzY2FsYXJcbiAgICAgIGlmICghZXF1YWxTY2FsYXIoeCwgMCkpIHtcbiAgICAgICAgLy8gcmVzdWx0XG4gICAgICAgIHZhciBjO1xuICAgICAgICAvLyBjaGVjayBzdG9yYWdlIGZvcm1hdFxuICAgICAgICBzd2l0Y2ggKHkuc3RvcmFnZSgpKSB7XG4gICAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICAgIGMgPSBhbGdvcml0aG0xMCh5LCB4LCByaWdodExvZ1NoaWZ0LCB0cnVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjID0gYWxnb3JpdGhtMTQoeSwgeCwgcmlnaHRMb2dTaGlmdCwgdHJ1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYztcbiAgICAgIH1cbiAgICAgIHJldHVybiB6ZXJvcyh5LnNpemUoKSwgeS5zdG9yYWdlKCkpO1xuICAgIH0sXG5cbiAgICAnQXJyYXksIG51bWJlciB8IEJpZ051bWJlcic6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gcmlnaHRMb2dTaGlmdChtYXRyaXgoeCksIHkpLnZhbHVlT2YoKTtcbiAgICB9LFxuXG4gICAgJ251bWJlciB8IEJpZ051bWJlciwgQXJyYXknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIHJpZ2h0TG9nU2hpZnQoeCwgbWF0cml4KHkpKS52YWx1ZU9mKCk7XG4gICAgfVxuICB9KTtcblxuICByaWdodExvZ1NoaWZ0LnRvVGV4ID0gJ1xcXFxsZWZ0KCR7YXJnc1swXX0nICsgbGF0ZXgub3BlcmF0b3JzWydyaWdodExvZ1NoaWZ0J10gKyAnJHthcmdzWzFdfVxcXFxyaWdodCknO1xuXG4gIHJldHVybiByaWdodExvZ1NoaWZ0O1xufVxuXG5leHBvcnRzLm5hbWUgPSAncmlnaHRMb2dTaGlmdCc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBhZGQgPSBsb2FkKHJlcXVpcmUoJy4uL2FyaXRobWV0aWMvYWRkJykpO1xuICB2YXIgc3RpcmxpbmdTMiA9IGxvYWQocmVxdWlyZSgnLi9zdGlybGluZ1MyJykpO1xuICB2YXIgaXNOZWdhdGl2ZSA9IGxvYWQocmVxdWlyZSgnLi4vdXRpbHMvaXNOZWdhdGl2ZScpKTtcbiAgdmFyIGlzSW50ZWdlciA9IGxvYWQocmVxdWlyZSgnLi4vdXRpbHMvaXNJbnRlZ2VyJykpO1xuXG4gIC8qKlxuICAgKiBUaGUgQmVsbCBOdW1iZXJzIGNvdW50IHRoZSBudW1iZXIgb2YgcGFydGl0aW9ucyBvZiBhIHNldC4gQSBwYXJ0aXRpb24gaXMgYSBwYWlyd2lzZSBkaXNqb2ludCBzdWJzZXQgb2YgUyB3aG9zZSB1bmlvbiBpcyBTLlxuICAgKiBiZWxsTnVtYmVycyBvbmx5IHRha2VzIGludGVnZXIgYXJndW1lbnRzLlxuICAgKiBUaGUgZm9sbG93aW5nIGNvbmRpdGlvbiBtdXN0IGJlIGVuZm9yY2VkOiBuID49IDBcbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgIG1hdGguYmVsbE51bWJlcnMobilcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGguYmVsbE51bWJlcnMoMyk7IC8vIHJldHVybnMgNTtcbiAgICogICAgbWF0aC5iZWxsTnVtYmVycyg4KTsgLy8gcmV0dXJucyA0MTQwO1xuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgc3RpcmxpbmdTMlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlciB8IEJpZ051bWJlcn0gbiAgICBUb3RhbCBudW1iZXIgb2Ygb2JqZWN0cyBpbiB0aGUgc2V0XG4gICAqIEByZXR1cm4ge051bWJlciB8IEJpZ051bWJlcn0gICAgIEIobilcbiAgICovXG4gIHZhciBiZWxsTnVtYmVycyA9IHR5cGVkKCdiZWxsTnVtYmVycycsIHtcbiAgICAnbnVtYmVyIHwgQmlnTnVtYmVyJzogZnVuY3Rpb24gKG4pIHtcblxuICAgICAgaWYgKCFpc0ludGVnZXIobikgfHwgaXNOZWdhdGl2ZShuKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb24tbmVnYXRpdmUgaW50ZWdlciB2YWx1ZSBleHBlY3RlZCBpbiBmdW5jdGlvbiBiZWxsTnVtYmVycycpO1xuICAgICAgfVxuXG4gICAgICAvLyBTdW0gKGs9MCwgbikgUyhuLGspLlxuICAgICAgdmFyIHJlc3VsdCA9IDA7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDw9IG47IGkrKykge1xuICAgICAgICByZXN1bHQgPSBhZGQocmVzdWx0LCBzdGlybGluZ1MyKG4sIGkpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH0pO1xuXG4gIGJlbGxOdW1iZXJzLnRvVGV4ID0gJ1xcXFxtYXRocm17Qn1feyR7YXJnc1swXX19JztcblxuICByZXR1cm4gYmVsbE51bWJlcnM7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdiZWxsTnVtYmVycyc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBhZGQgPSBsb2FkKHJlcXVpcmUoJy4uL2FyaXRobWV0aWMvYWRkJykpO1xuICB2YXIgZGl2aWRlID0gbG9hZChyZXF1aXJlKCcuLi9hcml0aG1ldGljL2RpdmlkZScpKTtcbiAgdmFyIG11bHRpcGx5ID0gbG9hZChyZXF1aXJlKCcuLi9hcml0aG1ldGljL211bHRpcGx5JykpO1xuICB2YXIgY29tYmluYXRpb25zID0gbG9hZChyZXF1aXJlKCcuLi9wcm9iYWJpbGl0eS9jb21iaW5hdGlvbnMnKSk7XG4gIHZhciBpc05lZ2F0aXZlID0gbG9hZChyZXF1aXJlKCcuLi91dGlscy9pc05lZ2F0aXZlJykpO1xuICB2YXIgaXNJbnRlZ2VyID0gbG9hZChyZXF1aXJlKCcuLi91dGlscy9pc0ludGVnZXInKSk7XG5cblxuICAvKipcbiAgICogVGhlIENhdGFsYW4gTnVtYmVycyBlbnVtZXJhdGUgY29tYmluYXRvcmlhbCBzdHJ1Y3R1cmVzIG9mIG1hbnkgZGlmZmVyZW50IHR5cGVzLlxuICAgKiBjYXRhbGFuIG9ubHkgdGFrZXMgaW50ZWdlciBhcmd1bWVudHMuXG4gICAqIFRoZSBmb2xsb3dpbmcgY29uZGl0aW9uIG11c3QgYmUgZW5mb3JjZWQ6IG4gPj0gMFxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgbWF0aC5jYXRhbGFuKG4pXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmNhdGFsYW4oMyk7IC8vIHJldHVybnMgNTtcbiAgICogICAgbWF0aC5jYXRhbGFuKDgpOyAvLyByZXR1cm5zIDE0MzA7XG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBiZWxsTnVtYmVyc1xuICAgKlxuICAgKiBAcGFyYW0ge051bWJlciB8IEJpZ051bWJlcn0gbiAgICBudGggQ2F0YWxhbiBudW1iZXJcbiAgICogQHJldHVybiB7TnVtYmVyIHwgQmlnTnVtYmVyfSAgICAgQ24obilcbiAgICovXG4gIHZhciBjYXRhbGFuID0gdHlwZWQoJ2NhdGFsYW4nLCB7XG4gICAgJ251bWJlciB8IEJpZ051bWJlcic6IGZ1bmN0aW9uIChuKSB7XG5cbiAgICAgIGlmICghaXNJbnRlZ2VyKG4pIHx8IGlzTmVnYXRpdmUobikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm9uLW5lZ2F0aXZlIGludGVnZXIgdmFsdWUgZXhwZWN0ZWQgaW4gZnVuY3Rpb24gY2F0YWxhbicpO1xuICAgICAgfVxuICAgICAgIFxuICAgICAgcmV0dXJuIGRpdmlkZShjb21iaW5hdGlvbnMobXVsdGlwbHkobiwyKSwgbiksIGFkZChuLDEpKTtcblxuICAgIH1cbiAgfSk7XG5cbiAgY2F0YWxhbi50b1RleCA9ICdcXFxcbWF0aHJte0N9X3ske2FyZ3NbMF19fSc7XG5cbiAgcmV0dXJuIGNhdGFsYW47XG59XG5cbmV4cG9ydHMubmFtZSA9ICdjYXRhbGFuJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIGNvbWJpbmF0aW9ucyA9IGxvYWQocmVxdWlyZSgnLi4vcHJvYmFiaWxpdHkvY29tYmluYXRpb25zJykpO1xuICB2YXIgYWRkID0gbG9hZChyZXF1aXJlKCcuLi9hcml0aG1ldGljL2FkZFNjYWxhcicpKTtcbiAgdmFyIGlzUG9zaXRpdmUgPSBsb2FkKHJlcXVpcmUoJy4uL3V0aWxzL2lzUG9zaXRpdmUnKSk7XG4gIHZhciBpc0ludGVnZXIgPSBsb2FkKHJlcXVpcmUoJy4uL3V0aWxzL2lzSW50ZWdlcicpKTtcbiAgdmFyIGxhcmdlciA9IGxvYWQocmVxdWlyZSgnLi4vcmVsYXRpb25hbC9sYXJnZXInKSk7XG5cbiAgLyoqXG4gICAqIFRoZSBjb21wb3NpdGlvbiBjb3VudHMgb2YgbiBpbnRvIGsgcGFydHMuXG4gICAqXG4gICAqIGNvbXBvc2l0aW9uIG9ubHkgdGFrZXMgaW50ZWdlciBhcmd1bWVudHMuXG4gICAqIFRoZSBmb2xsb3dpbmcgY29uZGl0aW9uIG11c3QgYmUgZW5mb3JjZWQ6IGsgPD0gbi5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgIG1hdGguY29tcG9zaXRpb24obiwgaylcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGguY29tcG9zaXRpb24oNSwgMyk7IC8vIHJldHVybnMgNlxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgY29tYmluYXRpb25zXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyIHwgQmlnTnVtYmVyfSBuICAgIFRvdGFsIG51bWJlciBvZiBvYmplY3RzIGluIHRoZSBzZXRcbiAgICogQHBhcmFtIHtOdW1iZXIgfCBCaWdOdW1iZXJ9IGsgICAgTnVtYmVyIG9mIG9iamVjdHMgaW4gdGhlIHN1YnNldFxuICAgKiBAcmV0dXJuIHtOdW1iZXIgfCBCaWdOdW1iZXJ9ICAgICBSZXR1cm5zIHRoZSBjb21wb3NpdGlvbiBjb3VudHMgb2YgbiBpbnRvIGsgcGFydHMuXG4gICAqL1xuICB2YXIgY29tcG9zaXRpb24gPSAgdHlwZWQoJ2NvbXBvc2l0aW9uJywge1xuICAgICdudW1iZXIgfCBCaWdOdW1iZXIsIG51bWJlciB8IEJpZ051bWJlcic6IGZ1bmN0aW9uIChuLCBrKSB7XG4gICAgICBpZiAoIWlzSW50ZWdlcihuKSB8fCAhaXNQb3NpdGl2ZShuKSB8fCAhaXNJbnRlZ2VyKGspIHx8ICFpc1Bvc2l0aXZlKGspKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Bvc2l0aXZlIGludGVnZXIgdmFsdWUgZXhwZWN0ZWQgaW4gZnVuY3Rpb24gY29tcG9zaXRpb24nKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGxhcmdlcihrLCBuKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdrIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIG4gaW4gZnVuY3Rpb24gY29tcG9zaXRpb24nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbWJpbmF0aW9ucyhhZGQobiwgLTEpLCBhZGQoaywgLTEpKTtcbiAgICB9XG4gIH0pO1xuXG4gIGNvbXBvc2l0aW9uLnRvVGV4ID0gJ1xcXFxtYXRocm17JHtuYW1lfX1cXFxcbGVmdCgke2FyZ3N9XFxcXHJpZ2h0KSc7XG5cbiAgcmV0dXJuIGNvbXBvc2l0aW9uO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnY29tcG9zaXRpb24nO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIm1vZHVsZS5leHBvcnRzID0gW1xuICByZXF1aXJlKCcuL2JlbGxOdW1iZXJzJyksXG4gIHJlcXVpcmUoJy4vY29tcG9zaXRpb24nKSxcbiAgcmVxdWlyZSgnLi9zdGlybGluZ1MyJyksXG4gIHJlcXVpcmUoJy4vY2F0YWxhbicpXG5dO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBhZGQgPSBsb2FkKHJlcXVpcmUoJy4uL2FyaXRobWV0aWMvYWRkJykpO1xuICB2YXIgc3VidHJhY3QgPSBsb2FkKHJlcXVpcmUoJy4uL2FyaXRobWV0aWMvc3VidHJhY3QnKSk7XG4gIHZhciBtdWx0aXBseSA9IGxvYWQocmVxdWlyZSgnLi4vYXJpdGhtZXRpYy9tdWx0aXBseScpKTtcbiAgdmFyIGRpdmlkZSA9IGxvYWQocmVxdWlyZSgnLi4vYXJpdGhtZXRpYy9kaXZpZGUnKSk7XG4gIHZhciBwb3cgPSBsb2FkKHJlcXVpcmUoJy4uL2FyaXRobWV0aWMvcG93JykpO1xuICB2YXIgZmFjdG9yaWFsID0gbG9hZChyZXF1aXJlKCcuLi9wcm9iYWJpbGl0eS9mYWN0b3JpYWwnKSk7XG4gIHZhciBjb21iaW5hdGlvbnMgPSBsb2FkKHJlcXVpcmUoJy4uL3Byb2JhYmlsaXR5L2NvbWJpbmF0aW9ucycpKTtcbiAgdmFyIGlzTmVnYXRpdmUgPSBsb2FkKHJlcXVpcmUoJy4uL3V0aWxzL2lzTmVnYXRpdmUnKSk7XG4gIHZhciBpc0ludGVnZXIgPSBsb2FkKHJlcXVpcmUoJy4uL3V0aWxzL2lzSW50ZWdlcicpKTtcbiAgdmFyIGxhcmdlciA9IGxvYWQocmVxdWlyZSgnLi4vcmVsYXRpb25hbC9sYXJnZXInKSk7XG5cbiAgLyoqXG4gICAqIFRoZSBTdGlybGluZyBudW1iZXJzIG9mIHRoZSBzZWNvbmQga2luZCwgY291bnRzIHRoZSBudW1iZXIgb2Ygd2F5cyB0byBwYXJ0aXRpb25cbiAgICogYSBzZXQgb2YgbiBsYWJlbGxlZCBvYmplY3RzIGludG8gayBub25lbXB0eSB1bmxhYmVsbGVkIHN1YnNldHMuXG4gICAqIHN0aXJsaW5nUzIgb25seSB0YWtlcyBpbnRlZ2VyIGFyZ3VtZW50cy5cbiAgICogVGhlIGZvbGxvd2luZyBjb25kaXRpb24gbXVzdCBiZSBlbmZvcmNlZDogayA8PSBuLlxuICAgKlxuICAgKiAgSWYgbiA9IGsgb3IgayA9IDEsIHRoZW4gcyhuLGspID0gMVxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgbWF0aC5zdGlybGluZ1MyKG4sIGspXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLnN0aXJsaW5nUzIoNSwgMyk7IC8vcmV0dXJucyAyNVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgQmVsbCBudW1iZXJzXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyIHwgQmlnTnVtYmVyfSBuICAgIFRvdGFsIG51bWJlciBvZiBvYmplY3RzIGluIHRoZSBzZXRcbiAgICogQHBhcmFtIHtOdW1iZXIgfCBCaWdOdW1iZXJ9IGsgICAgTnVtYmVyIG9mIG9iamVjdHMgaW4gdGhlIHN1YnNldFxuICAgKiBAcmV0dXJuIHtOdW1iZXIgfCBCaWdOdW1iZXJ9ICAgICBTKG4saylcbiAgICovXG4gIHZhciBzdGlybGluZ1MyID0gdHlwZWQoJ3N0aXJsaW5nUzInLCB7XG4gICAgJ251bWJlciB8IEJpZ051bWJlciwgbnVtYmVyIHwgQmlnTnVtYmVyJzogZnVuY3Rpb24gKG4sIGspIHtcbiAgICAgIGlmICghaXNJbnRlZ2VyKG4pIHx8IGlzTmVnYXRpdmUobikgfHwgIWlzSW50ZWdlcihrKSB8fCBpc05lZ2F0aXZlKGspKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vbi1uZWdhdGl2ZSBpbnRlZ2VyIHZhbHVlIGV4cGVjdGVkIGluIGZ1bmN0aW9uIHN0aXJsaW5nUzInKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGxhcmdlcihrLCBuKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdrIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIG4gaW4gZnVuY3Rpb24gc3RpcmxpbmdTMicpO1xuICAgICAgfVxuXG4gICAgICAvLyAxL2shIFN1bShpPTAgLT4gaykgWygtMSleKGstaSkqQyhrLGopKiBpXm5dXG4gICAgICB2YXIga0ZhY3RvcmlhbCA9IGZhY3RvcmlhbChrKTtcbiAgICAgIHZhciByZXN1bHQgPSAwO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8PSBrOyBpKyspIHtcbiAgICAgICAgdmFyIG5lZ2F0aXZlT25lID0gcG93KC0xLCBzdWJ0cmFjdChrLGkpKTtcbiAgICAgICAgdmFyIGtDaG9vc2VJID0gY29tYmluYXRpb25zKGssaSk7XG4gICAgICAgIHZhciBpUG93ZXIgPSBwb3coaSxuKTtcblxuICAgICAgICByZXN1bHQgPSBhZGQocmVzdWx0LCBtdWx0aXBseShtdWx0aXBseShrQ2hvb3NlSSwgaVBvd2VyKSwgbmVnYXRpdmVPbmUpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRpdmlkZShyZXN1bHQsIGtGYWN0b3JpYWwpO1xuICAgIH1cbiAgfSk7XG5cbiAgc3RpcmxpbmdTMi50b1RleCA9ICdcXFxcbWF0aHJte1N9XFxcXGxlZnQoJHthcmdzWzBdfSwke2FyZ3NbMV19XFxcXHJpZ2h0KSc7XG5cbiAgcmV0dXJuIHN0aXJsaW5nUzI7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdzdGlybGluZ1MyJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWVwTWFwID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9kZWVwTWFwJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgLyoqXG4gICAqIENvbXB1dGUgdGhlIGFyZ3VtZW50IG9mIGEgY29tcGxleCB2YWx1ZS5cbiAgICogRm9yIGEgY29tcGxleCBudW1iZXIgYGEgKyBiaWAsIHRoZSBhcmd1bWVudCBpcyBjb21wdXRlZCBhcyBgYXRhbjIoYiwgYSlgLlxuICAgKlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguYXJnKHgpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICB2YXIgYSA9IG1hdGguY29tcGxleCgyLCAyKTtcbiAgICogICAgbWF0aC5hcmcoYSkgLyBtYXRoLnBpOyAgICAgICAgICAvLyByZXR1cm5zIG51bWJlciAwLjI1XG4gICAqXG4gICAqICAgIHZhciBiID0gbWF0aC5jb21wbGV4KCcyICsgM2knKTtcbiAgICogICAgbWF0aC5hcmcoYik7ICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIG51bWJlciAwLjk4Mjc5MzcyMzI0NzMyOVxuICAgKiAgICBtYXRoLmF0YW4yKDMsIDIpOyAgICAgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIDAuOTgyNzkzNzIzMjQ3MzI5XG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICByZSwgaW0sIGNvbmosIGFic1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0geFxuICAgKiAgICAgICAgICAgIEEgY29tcGxleCBudW1iZXIgb3IgYXJyYXkgd2l0aCBjb21wbGV4IG51bWJlcnNcbiAgICogQHJldHVybiB7bnVtYmVyIHwgQXJyYXkgfCBNYXRyaXh9IFRoZSBhcmd1bWVudCBvZiB4XG4gICAqL1xuICB2YXIgYXJnID0gdHlwZWQoJ2FyZycsIHtcbiAgICAnbnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBNYXRoLmF0YW4yKDAsIHgpO1xuICAgIH0sXG5cbiAgICAnQ29tcGxleCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5hcmcoKTtcbiAgICB9LFxuXG4gICAgLy8gVE9ETzogaW1wbGVtZW50IEJpZ051bWJlciBzdXBwb3J0IGZvciBmdW5jdGlvbiBhcmdcblxuICAgICdBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gZGVlcE1hcCh4LCBhcmcpO1xuICAgIH1cbiAgfSk7XG5cbiAgYXJnLnRvVGV4ID0gJ1xcXFxhcmdcXFxcbGVmdCgke2FyZ3NbMF19XFxcXHJpZ2h0KSc7XG5cbiAgcmV0dXJuIGFyZztcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2FyZyc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVlcE1hcCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vZGVlcE1hcCcpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIC8qKlxuICAgKiBDb21wdXRlIHRoZSBjb21wbGV4IGNvbmp1Z2F0ZSBvZiBhIGNvbXBsZXggdmFsdWUuXG4gICAqIElmIGB4ID0gYStiaWAsIHRoZSBjb21wbGV4IGNvbmp1Z2F0ZSBvZiBgeGAgaXMgYGEgLSBiaWAuXG4gICAqXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5jb25qKHgpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmNvbmoobWF0aC5jb21wbGV4KCcyICsgM2knKSk7ICAvLyByZXR1cm5zIENvbXBsZXggMiAtIDNpXG4gICAqICAgIG1hdGguY29uaihtYXRoLmNvbXBsZXgoJzIgLSAzaScpKTsgIC8vIHJldHVybnMgQ29tcGxleCAyICsgM2lcbiAgICogICAgbWF0aC5jb25qKG1hdGguY29tcGxleCgnLTUuMmknKSk7ICAvLyByZXR1cm5zIENvbXBsZXggNS4yaVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgcmUsIGltLCBhcmcsIGFic1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0geFxuICAgKiAgICAgICAgICAgIEEgY29tcGxleCBudW1iZXIgb3IgYXJyYXkgd2l0aCBjb21wbGV4IG51bWJlcnNcbiAgICogQHJldHVybiB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fVxuICAgKiAgICAgICAgICAgIFRoZSBjb21wbGV4IGNvbmp1Z2F0ZSBvZiB4XG4gICAqL1xuICB2YXIgY29uaiA9IHR5cGVkKCdjb25qJywge1xuICAgICdudW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfSxcblxuICAgICdCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfSxcblxuICAgICdDb21wbGV4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LmNvbmp1Z2F0ZSgpO1xuICAgIH0sXG5cbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIGRlZXBNYXAoeCwgY29uaik7XG4gICAgfVxuICB9KTtcblxuICBjb25qLnRvVGV4ID0gJ1xcXFxsZWZ0KCR7YXJnc1swXX1cXFxccmlnaHQpXionO1xuXG4gIHJldHVybiBjb25qO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnY29uaic7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVlcE1hcCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vZGVlcE1hcCcpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIC8qKlxuICAgKiBHZXQgdGhlIGltYWdpbmFyeSBwYXJ0IG9mIGEgY29tcGxleCBudW1iZXIuXG4gICAqIEZvciBhIGNvbXBsZXggbnVtYmVyIGBhICsgYmlgLCB0aGUgZnVuY3Rpb24gcmV0dXJucyBgYmAuXG4gICAqXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5pbSh4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgdmFyIGEgPSBtYXRoLmNvbXBsZXgoMiwgMyk7XG4gICAqICAgIG1hdGgucmUoYSk7ICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBudW1iZXIgMlxuICAgKiAgICBtYXRoLmltKGEpOyAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIDNcbiAgICpcbiAgICogICAgbWF0aC5yZShtYXRoLmNvbXBsZXgoJy01LjJpJykpOyAvLyByZXR1cm5zIG51bWJlciAtNS4yXG4gICAqICAgIG1hdGgucmUobWF0aC5jb21wbGV4KDIuNCkpOyAgICAgLy8gcmV0dXJucyBudW1iZXIgMFxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgcmUsIGNvbmosIGFicywgYXJnXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSB4XG4gICAqICAgICAgICAgICAgQSBjb21wbGV4IG51bWJlciBvciBhcnJheSB3aXRoIGNvbXBsZXggbnVtYmVyc1xuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBBcnJheSB8IE1hdHJpeH0gVGhlIGltYWdpbmFyeSBwYXJ0IG9mIHhcbiAgICovXG4gIHZhciBpbSA9IHR5cGVkKCdpbScsIHtcbiAgICAnbnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBuZXcgdHlwZS5CaWdOdW1iZXIoMCk7XG4gICAgfSxcblxuICAgICdDb21wbGV4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LmltO1xuICAgIH0sXG5cbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIGRlZXBNYXAoeCwgaW0pO1xuICAgIH1cbiAgfSk7XG5cbiAgaW0udG9UZXggPSAnXFxcXEltXFxcXGxlZnRcXFxcbGJyYWNlJHthcmdzWzBdfVxcXFxyaWdodFxcXFxyYnJhY2UnO1xuXG4gIHJldHVybiBpbTtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2ltJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFtcbiAgcmVxdWlyZSgnLi9hcmcnKSxcbiAgcmVxdWlyZSgnLi9jb25qJyksXG4gIHJlcXVpcmUoJy4vaW0nKSxcbiAgcmVxdWlyZSgnLi9yZScpXG5dO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVlcE1hcCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vZGVlcE1hcCcpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIC8qKlxuICAgKiBHZXQgdGhlIHJlYWwgcGFydCBvZiBhIGNvbXBsZXggbnVtYmVyLlxuICAgKiBGb3IgYSBjb21wbGV4IG51bWJlciBgYSArIGJpYCwgdGhlIGZ1bmN0aW9uIHJldHVybnMgYGFgLlxuICAgKlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGgucmUoeClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIHZhciBhID0gbWF0aC5jb21wbGV4KDIsIDMpO1xuICAgKiAgICBtYXRoLnJlKGEpOyAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIDJcbiAgICogICAgbWF0aC5pbShhKTsgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIG51bWJlciAzXG4gICAqXG4gICAqICAgIG1hdGgucmUobWF0aC5jb21wbGV4KCctNS4yaScpKTsgLy8gcmV0dXJucyBudW1iZXIgMFxuICAgKiAgICBtYXRoLnJlKG1hdGguY29tcGxleCgyLjQpKTsgICAgIC8vIHJldHVybnMgbnVtYmVyIDIuNFxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgaW0sIGNvbmosIGFicywgYXJnXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSB4XG4gICAqICAgICAgICAgICAgQSBjb21wbGV4IG51bWJlciBvciBhcnJheSB3aXRoIGNvbXBsZXggbnVtYmVyc1xuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBBcnJheSB8IE1hdHJpeH0gVGhlIHJlYWwgcGFydCBvZiB4XG4gICAqL1xuICB2YXIgcmUgPSB0eXBlZCgncmUnLCB7XG4gICAgJ251bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9LFxuXG4gICAgJ0JpZ051bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9LFxuXG4gICAgJ0NvbXBsZXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHgucmU7XG4gICAgfSxcblxuICAgICdBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gZGVlcE1hcCh4LCByZSk7XG4gICAgfVxuICB9KTtcblxuICByZS50b1RleCA9ICdcXFxcUmVcXFxcbGVmdFxcXFxsYnJhY2Uke2FyZ3NbMF19XFxcXHJpZ2h0XFxcXHJicmFjZSc7XG5cbiAgcmV0dXJuIHJlO1xufVxuXG5leHBvcnRzLm5hbWUgPSAncmUnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgbWF0cml4ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC9mdW5jdGlvbi9tYXRyaXgnKSk7XG5cbiAgLyoqXG4gICAgKiBDYWxjdWxhdGVzOlxuICAgICogICAgVGhlIGV1Y2xlZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMgaW4gMiBhbmQgMyBkaW1lbnNpb25hbCBzcGFjZXMuXG4gICAgKiAgICBEaXN0YW5jZSBiZXR3ZWVuIHBvaW50IGFuZCBhIGxpbmUgaW4gMiBhbmQgMyBkaW1lbnNpb25hbCBzcGFjZXMuXG4gICAgKiAgICBQYWlyd2lzZSBkaXN0YW5jZSBiZXR3ZWVuIGEgc2V0IG9mIDJEIG9yIDNEIHBvaW50c1xuICAgICogTk9URTpcbiAgICAqICAgIFdoZW4gc3Vic3RpdHV0aW5nIGNvZWZmaWNpZW50cyBvZiBhIGxpbmUoYSwgYiBhbmQgYyksIHVzZSBheCArIGJ5ICsgYyA9IDAgaW5zdGVhZCBvZiBheCArIGJ5ID0gY1xuICAgICogICAgRm9yIHBhcmFtZXRyaWMgZXF1YXRpb24gb2YgYSAzRCBsaW5lLCB4MCwgeTAsIHowLCBhLCBiLCBjIGFyZSBmcm9tOiAoeOKIkngwLCB54oiSeTAsIHriiJJ6MCkgPSB0KGEsIGIsIGMpXG4gICAgKlxuICAgICogU3ludGF4OlxuICAgICogICAgbWF0aC5kaXN0YW5jZShbeDEsIHkxXSwgW3gyLCB5Ml0pXG4gICAgKi0gICBtYXRoLmRpc3RhbmNlKHtwb2ludE9uZVg6IDQsIHBvaW50T25lWTogNX0sIHtwb2ludFR3b1g6IDIsIHBvaW50VHdvWTogN30pXG4gICAgKiAgICBtYXRoLmRpc3RhbmNlKFt4MSwgeTEsIHoxXSwgW3gyLCB5MiwgejJdKVxuICAgICogICAgbWF0aC5kaXN0YW5jZSh7cG9pbnRPbmVYOiA0LCBwb2ludE9uZVk6IDUsIHBvaW50T25lWjogOH0sIHtwb2ludFR3b1g6IDIsIHBvaW50VHdvWTogNywgcG9pbnRUd29aOiA5fSlcbiAgICAqICAgIG1hdGguZGlzdGFuY2UoW1tBXSwgW0JdLCBbQ10uLi5dKVxuICAgICogICAgbWF0aC5kaXN0YW5jZShbeDEsIHkxXSwgW0xpbmVQdFgxLCBMaW5lUHRZMV0sIFtMaW5lUHRYMiwgTGluZVB0WTJdKVxuICAgICogICAgbWF0aC5kaXN0YW5jZSh7cG9pbnRYOiAxLCBwb2ludFk6IDR9LCB7bGluZU9uZVB0WDogNiwgbGluZU9uZVB0WTogM30sIHtsaW5lVHdvUHRYOiAyLCBsaW5lVHdvUHRZOiA4fSlcbiAgICAqICAgIG1hdGguZGlzdGFuY2UoW3gxLCB5MSwgejFdLCBbTGluZVB0WDEsIExpbmVQdFkxLCBMaW5lUHRaMV0sIFtMaW5lUHRYMiwgTGluZVB0WTIsIExpbmVQdFoyXSlcbiAgICAqICAgIG1hdGguZGlzdGFuY2Uoe3BvaW50WDogMSwgcG9pbnRZOiA0LCBwb2ludFo6IDd9LCB7bGluZU9uZVB0WDogNiwgbGluZU9uZVB0WTogMywgbGluZU9uZVB0WjogNH0sIHtsaW5lVHdvUHRYOiAyLCBsaW5lVHdvUHRZOiA4LCBsaW5lVHdvUHRaOiA1fSlcbiAgICAqICAgIG1hdGguZGlzdGFuY2UoW3gxLCB5MV0sIFt4Q29lZmZMaW5lLCB5Q29lZmZMaW5lLCBjb25zdGFudF0pXG4gICAgKiAgICBtYXRoLmRpc3RhbmNlKHtwb2ludFg6IDEwLCBwb2ludFk6IDEwfSwge3hDb2VmZkxpbmU6IDgsIHlDb2VmZkxpbmU6IDEsIGNvbnN0YW50OiAzfSlcbiAgICAqICAgIG1hdGguZGlzdGFuY2UoW3gxLCB5MSwgejFdLCBbeDAsIHkwLCB6MCwgYS10Q29lZmYsIGItdENvZWZmLCBjLXRDb2VmZl0pIHBvaW50IGFuZCBwYXJhbWV0cmljIGVxdWF0aW9uIG9mIDNEIGxpbmVcbiAgICAqICAgIG1hdGguZGlzdGFuY2UoW3gsIHksIHpdLCBbeDAsIHkwLCB6MCwgYSwgYiwgY10pXG4gICAgKiAgICBtYXRoLmRpc3RhbmNlKHtwb2ludFg6IDIsIHBvaW50WTogNSwgcG9pbnRaOiA5fSwge3gwOiA0LCB5MDogNiwgejA6IDMsIGE6IDQsIGI6IDIsIGM6IDB9KVxuICAgICpcbiAgICAqIEV4YW1wbGVzOlxuICAgICogICAgbWF0aC5kaXN0YW5jZShbMCwwXSwgWzQsNF0pICAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJucyA1LjY1NjlcbiAgICAqICAgIG1hdGguZGlzdGFuY2UoXG4gICAgKiAgICAge3BvaW50T25lWDogMCwgcG9pbnRPbmVZOiAwfSxcbiAgICAqICAgICB7cG9pbnRUd29YOiAxMCwgcG9pbnRUd29ZOiAxMH0pICAgICAgICAgICAgICAgIC8vIFJldHVybnMgMTQuMTQyMTM1NjIzNzMwOTUxXG4gICAgKiAgICBtYXRoLmRpc3RhbmNlKFsxLCAwLCAxXSwgWzQsIC0yLCAyXSkgICAgICAgICAgICAvLyBSZXR1cm5zIDMuNzQxNjZcbiAgICAqICAgIG1hdGguZGlzdGFuY2UoXG4gICAgKiAgICAge3BvaW50T25lWDogNCwgcG9pbnRPbmVZOiA1LCBwb2ludE9uZVo6IDh9LFxuICAgICogICAgIHtwb2ludFR3b1g6IDIsIHBvaW50VHdvWTogNywgcG9pbnRUd29aOiA5fSkgICAgLy8gUmV0dXJucyAzXG4gICAgKiAgICBtYXRoLmRpc3RhbmNlKFtbMSwgMl0sIFsxLCAyXSwgWzEsIDNdXSkgICAgICAgICAvLyBSZXR1cm5zIFswLCAxLCAxXVxuICAgICogICAgbWF0aC5kaXN0YW5jZShbWzEsMiw0XSwgWzEsMiw2XSwgWzgsMSwzXV0pICAgICAgLy8gUmV0dXJucyBbMiwgNy4xNDE0Mjg0Mjg1NDI4NSwgNy42ODExNDU3NDc4Njg2MDhdXG4gICAgKiAgICBtYXRoLmRpc3RhbmNlKFsxMCwgMTBdLCBbOCwgMSwgM10pICAgICAgICAgICAgICAvLyBSZXR1cm5zIDExLjUzNTIzMDMxNjc5NjM4N1xuICAgICogICAgbWF0aC5kaXN0YW5jZShbMTAsIDEwXSwgWzIsIDNdLCBbLTgsIDBdKSAgICAgICAgLy8gUmV0dXJucyA4Ljc1OTk1MzEzMDM2Mjg0N1xuICAgICogICAgbWF0aC5kaXN0YW5jZShcbiAgICAqICAgICB7cG9pbnRYOiAxLCBwb2ludFk6IDR9LFxuICAgICogICAgIHtsaW5lT25lUHRYOiA2LCBsaW5lT25lUHRZOiAzfSxcbiAgICAqICAgICB7bGluZVR3b1B0WDogMiwgbGluZVR3b1B0WTogOH0pICAgICAgICAgICAgICAgIC8vIFJldHVybnMgMi43MjA1NDkzNzI2MjQ3NDRcbiAgICAqICAgIG1hdGguZGlzdGFuY2UoWzIsIDMsIDFdLCBbMSwgMSwgMiwgNSwgMCwgMV0pICAgIC8vIFJldHVybnMgMi4zMjA0Nzc0MDQ0NjEyODU3XG4gICAgKiAgICBtYXRoLmRpc3RhbmNlKFxuICAgICogICAgIHtwb2ludFg6IDIsIHBvaW50WTogMywgcG9pbnRaOiAxfSxcbiAgICAqICAgICB7eDA6IDEsIHkwOiAxLCB6MDogMiwgYTogNSwgYjogMCwgYzogMX0gICAgICAgIC8vIFJldHVybnMgMi4zMjA0Nzc0MDQ0NjEyODU3XG4gICAgKlxuICAgICogQHBhcmFtIHtBcnJheSB8IE1hdHJpeCB8IE9iamVjdH0geCAgICBDby1vcmRpbmF0ZXMgb2YgZmlyc3QgcG9pbnRcbiAgICAqIEBwYXJhbSB7QXJyYXkgfCBNYXRyaXggfCBPYmplY3R9IHkgICAgQ28tb3JkaW5hdGVzIG9mIHNlY29uZCBwb2ludFxuICAgICogQHJldHVybiB7TnVtYmVyIHwgQmlnTnVtYmVyfSBSZXR1cm5zIHRoZSBkaXN0YW5jZSBmcm9tIHR3by90aHJlZSBwb2ludHNcbiAgKi9cblxuICB2YXIgZGlzdGFuY2UgPSB0eXBlZCgnZGlzdGFuY2UnLCB7XG4gICAgJ0FycmF5LCBBcnJheSwgQXJyYXknOiBmdW5jdGlvbih4LCB5LCB6KXtcbiAgICAgIC8vIFBvaW50IHRvIExpbmUgMkQ7ICh4PVBvaW50LCB5PUxpbmVQb2ludDEsIHo9TGluZVBvaW50MilcbiAgICAgIGlmICh4Lmxlbmd0aCA9PSAyICYmIHkubGVuZ3RoID09IDIgJiYgei5sZW5ndGggPT0gMil7XG4gICAgICAgIGlmICghXzJkKHgpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5IHdpdGggMiBudW1iZXJzIGV4cGVjdGVkIGZvciBmaXJzdCBhcmd1bWVudCcpOyB9XG4gICAgICAgIGlmICghXzJkKHkpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5IHdpdGggMiBudW1iZXJzIGV4cGVjdGVkIGZvciBzZWNvbmQgYXJndW1lbnQnKTsgfVxuICAgICAgICBpZiAoIV8yZCh6KSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheSB3aXRoIDIgbnVtYmVycyBleHBlY3RlZCBmb3IgdGhpcmQgYXJndW1lbnQnKTsgfVxuICAgICAgICB2YXIgbSA9ICh6WzFdLXpbMF0pLyh5WzFdLXlbMF0pO1xuICAgICAgICB2YXIgeENvZWZmID0gbSptKnlbMF07XG4gICAgICAgIHZhciB5Q29lZmYgPSAtMSoobSp5WzBdKTtcbiAgICAgICAgdmFyIGNvbnN0YW50ID0geFsxXTtcblxuICAgICAgICByZXR1cm4gX2Rpc3RhbmNlUG9pbnRMaW5lMkQoeFswXSwgeFsxXSwgeENvZWZmLCB5Q29lZmYsIGNvbnN0YW50KTtcbiAgICAgIH1cbiAgICAgIGVsc2V7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgQXJndW1lbnRzOiBUcnkgYWdhaW4nKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICdPYmplY3QsIE9iamVjdCwgT2JqZWN0JzogZnVuY3Rpb24oeCwgeSwgeil7XG4gICAgICBpZiAoT2JqZWN0LmtleXMoeCkubGVuZ3RoID09IDIgJiYgT2JqZWN0LmtleXMoeSkubGVuZ3RoID09IDIgJiYgT2JqZWN0LmtleXMoeikubGVuZ3RoID09IDIpe1xuICAgICAgICBpZiAoIV8yZCh4KSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdWYWx1ZXMgb2YgcG9pbnRYIGFuZCBwb2ludFkgc2hvdWxkIGJlIG51bWJlcnMnKTsgfVxuICAgICAgICBpZiAoIV8yZCh5KSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdWYWx1ZXMgb2YgbGluZU9uZVB0WCBhbmQgbGluZU9uZVB0WSBzaG91bGQgYmUgbnVtYmVycycpOyB9XG4gICAgICAgIGlmICghXzJkKHopKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1ZhbHVlcyBvZiBsaW5lVHdvUHRYIGFuZCBsaW5lVHdvUHRZIHNob3VsZCBiZSBudW1iZXJzJyk7IH1cbiAgICAgICAgaWYgKHguaGFzT3duUHJvcGVydHkoJ3BvaW50WCcpICYmIHguaGFzT3duUHJvcGVydHkoJ3BvaW50WScpICYmIHkuaGFzT3duUHJvcGVydHkoJ2xpbmVPbmVQdFgnKSAmJlxuICAgICAgICAgIHkuaGFzT3duUHJvcGVydHkoJ2xpbmVPbmVQdFknKSAmJiB6Lmhhc093blByb3BlcnR5KCdsaW5lVHdvUHRYJykgJiYgei5oYXNPd25Qcm9wZXJ0eSgnbGluZVR3b1B0WScpKXtcbiAgICAgICAgICB2YXIgbSA9ICh6LmxpbmVUd29QdFktei5saW5lVHdvUHRYKS8oeS5saW5lT25lUHRZLXkubGluZU9uZVB0WCk7XG4gICAgICAgICAgdmFyIHhDb2VmZiA9IG0qbSp5LmxpbmVPbmVQdFg7XG4gICAgICAgICAgdmFyIHlDb2VmZiA9IC0xKihtKnkubGluZU9uZVB0WCk7XG4gICAgICAgICAgdmFyIGNvbnN0YW50ID0geC5wb2ludFg7XG5cbiAgICAgICAgICByZXR1cm4gX2Rpc3RhbmNlUG9pbnRMaW5lMkQoeC5wb2ludFgsIHgucG9pbnRZLCB4Q29lZmYsIHlDb2VmZiwgY29uc3RhbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignS2V5IG5hbWVzIGRvIG5vdCBtYXRjaCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNle1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIEFyZ3VtZW50czogVHJ5IGFnYWluJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICAnQXJyYXksIEFycmF5JzogZnVuY3Rpb24oeCwgeSl7XG4gICAgICAvLyBQb2ludCB0byBMaW5lIDJEOyAoeD1bcG9pbnRYLCBwb2ludFldLCB5PVt4LWNvZWZmLCB5LWNvZWZmLCBjb25zdF0pXG4gICAgICBpZiAoeC5sZW5ndGggPT0gMiAmJiB5Lmxlbmd0aCA9PSAzKXtcbiAgICAgICAgaWYgKCFfMmQoeCkpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkgd2l0aCAyIG51bWJlcnMgZXhwZWN0ZWQgZm9yIGZpcnN0IGFyZ3VtZW50Jyk7IH1cbiAgICAgICAgaWYgKCFfM2QoeSkpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkgd2l0aCAzIG51bWJlcnMgZXhwZWN0ZWQgZm9yIHNlY29uZCBhcmd1bWVudCcpOyB9XG5cbiAgICAgICAgcmV0dXJuIF9kaXN0YW5jZVBvaW50TGluZTJEKHhbMF0sIHhbMV0sIHlbMF0sIHlbMV0sIHlbMl0pO1xuICAgICAgfVxuICAgICAgLy8gUG9pbnQgdG8gTGluZSAzRFxuICAgICAgZWxzZSBpZiAoeC5sZW5ndGggPT0gMyAmJiB5Lmxlbmd0aCA9PSA2KXtcbiAgICAgICAgaWYgKCFfM2QoeCkpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkgd2l0aCAzIG51bWJlcnMgZXhwZWN0ZWQgZm9yIGZpcnN0IGFyZ3VtZW50Jyk7IH1cbiAgICAgICAgaWYgKCFfcGFyYW1ldHJpY0xpbmUoeSkpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkgd2l0aCA2IG51bWJlcnMgZXhwZWN0ZWQgZm9yIHNlY29uZCBhcmd1bWVudCcpOyB9XG5cbiAgICAgICAgcmV0dXJuIF9kaXN0YW5jZVBvaW50TGluZTNEKHhbMF0sIHhbMV0sIHhbMl0sIHlbMF0sIHlbMV0sIHlbMl0sIHlbM10sIHlbNF0sIHlbNV0pO1xuICAgICAgfVxuICAgICAgLy8gUG9pbnQgdG8gUG9pbnQgMkRcbiAgICAgIGVsc2UgaWYgKHgubGVuZ3RoID09IDIgJiYgeS5sZW5ndGggPT0gMil7XG4gICAgICAgIGlmICghXzJkKHgpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5IHdpdGggMiBudW1iZXJzIGV4cGVjdGVkIGZvciBmaXJzdCBhcmd1bWVudCcpOyB9XG4gICAgICAgIGlmICghXzJkKHkpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5IHdpdGggMiBudW1iZXJzIGV4cGVjdGVkIGZvciBzZWNvbmQgYXJndW1lbnQnKTsgfVxuXG4gICAgICAgIHJldHVybiBfZGlzdGFuY2UyZCh4WzBdLCB4WzFdLCB5WzBdLCB5WzFdKTtcbiAgICAgIH1cbiAgICAgIC8vIFBvaW50IHRvIFBvaW50IDNEXG4gICAgICBlbHNlIGlmKHgubGVuZ3RoID09IDMgJiYgeS5sZW5ndGggPT0gMyl7XG4gICAgICAgIGlmICghXzNkKHgpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5IHdpdGggMyBudW1iZXJzIGV4cGVjdGVkIGZvciBmaXJzdCBhcmd1bWVudCcpOyB9XG4gICAgICAgIGlmICghXzNkKHkpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5IHdpdGggMyBudW1iZXJzIGV4cGVjdGVkIGZvciBzZWNvbmQgYXJndW1lbnQnKTsgfVxuXG4gICAgICAgIHJldHVybiBfZGlzdGFuY2UzZCh4WzBdLCB4WzFdLCB4WzJdLCB5WzBdLCB5WzFdLCB5WzJdKTtcbiAgICAgIH1cbiAgICAgIGVsc2V7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgQXJndW1lbnRzOiBUcnkgYWdhaW4nKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICdPYmplY3QsIE9iamVjdCc6IGZ1bmN0aW9uKHgsIHkpe1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHgpLmxlbmd0aCA9PSAyICYmIE9iamVjdC5rZXlzKHkpLmxlbmd0aCA9PSAzKXtcbiAgICAgICAgaWYgKCFfMmQoeCkpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignVmFsdWVzIG9mIHBvaW50WCBhbmQgcG9pbnRZIHNob3VsZCBiZSBudW1iZXJzJyk7IH1cbiAgICAgICAgaWYgKCFfM2QoeSkpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignVmFsdWVzIG9mIHhDb2VmZkxpbmUsIHlDb2VmZkxpbmUgYW5kIGNvbnN0YW50IHNob3VsZCBiZSBudW1iZXJzJyk7IH1cbiAgICAgICAgaWYgKHguaGFzT3duUHJvcGVydHkoJ3BvaW50WCcpICYmIHguaGFzT3duUHJvcGVydHkoJ3BvaW50WScpICYmIHkuaGFzT3duUHJvcGVydHkoJ3hDb2VmZkxpbmUnKSAmJlxuICAgICAgICAgIHkuaGFzT3duUHJvcGVydHkoJ3lDb2VmZkxpbmUnKSAmJiB5Lmhhc093blByb3BlcnR5KCd5Q29lZmZMaW5lJykpe1xuXG4gICAgICAgICAgcmV0dXJuIF9kaXN0YW5jZVBvaW50TGluZTJEKHgucG9pbnRYLCB4LnBvaW50WSwgeS54Q29lZmZMaW5lLCB5LnlDb2VmZkxpbmUsIHkuY29uc3RhbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignS2V5IG5hbWVzIGRvIG5vdCBtYXRjaCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBQb2ludCB0byBMaW5lIDNEXG4gICAgICBlbHNlIGlmIChPYmplY3Qua2V5cyh4KS5sZW5ndGggPT0gMyAmJiBPYmplY3Qua2V5cyh5KS5sZW5ndGggPT0gNil7XG4gICAgICAgIGlmICghXzNkKHgpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1ZhbHVlcyBvZiBwb2ludFgsIHBvaW50WSBhbmQgcG9pbnRaIHNob3VsZCBiZSBudW1iZXJzJyk7IH1cbiAgICAgICAgaWYgKCFfcGFyYW1ldHJpY0xpbmUoeSkpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignVmFsdWVzIG9mIHgwLCB5MCwgejAsIGEsIGIgYW5kIGMgc2hvdWxkIGJlIG51bWJlcnMnKTsgfVxuICAgICAgICBpZiAoeC5oYXNPd25Qcm9wZXJ0eSgncG9pbnRYJykgJiYgeC5oYXNPd25Qcm9wZXJ0eSgncG9pbnRZJykgJiYgeS5oYXNPd25Qcm9wZXJ0eSgneDAnKSAmJlxuICAgICAgICAgIHkuaGFzT3duUHJvcGVydHkoJ3kwJykgJiYgeS5oYXNPd25Qcm9wZXJ0eSgnejAnKSAmJiB5Lmhhc093blByb3BlcnR5KCdhJykgJiZcbiAgICAgICAgICB5Lmhhc093blByb3BlcnR5KCdiJykgJiYgeS5oYXNPd25Qcm9wZXJ0eSgnYycpKXtcblxuICAgICAgICAgIHJldHVybiBfZGlzdGFuY2VQb2ludExpbmUzRCh4LnBvaW50WCwgeC5wb2ludFksIHgucG9pbnRaLCB5LngwLCB5LnkwLCB5LnowLCB5LmEsIHkuYiwgeS5jKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNle1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0tleSBuYW1lcyBkbyBub3QgbWF0Y2gnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gUG9pbnQgdG8gUG9pbnQgMkRcbiAgICAgIGVsc2UgaWYgKE9iamVjdC5rZXlzKHgpLmxlbmd0aCA9PSAyICYmIE9iamVjdC5rZXlzKHkpLmxlbmd0aCA9PSAyKXtcbiAgICAgICAgaWYgKCFfMmQoeCkpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignVmFsdWVzIG9mIHBvaW50T25lWCBhbmQgcG9pbnRPbmVZIHNob3VsZCBiZSBudW1iZXJzJyk7IH1cbiAgICAgICAgaWYgKCFfMmQoeSkpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignVmFsdWVzIG9mIHBvaW50VHdvWCBhbmQgcG9pbnRUd29ZIHNob3VsZCBiZSBudW1iZXJzJyk7IH1cbiAgICAgICAgaWYgKHguaGFzT3duUHJvcGVydHkoJ3BvaW50T25lWCcpICYmIHguaGFzT3duUHJvcGVydHkoJ3BvaW50T25lWScpICYmXG4gICAgICAgICAgeS5oYXNPd25Qcm9wZXJ0eSgncG9pbnRUd29YJykgJiYgeS5oYXNPd25Qcm9wZXJ0eSgncG9pbnRUd29ZJykpe1xuXG4gICAgICAgICAgcmV0dXJuIF9kaXN0YW5jZTJkKHgucG9pbnRPbmVYLCB4LnBvaW50T25lWSwgeS5wb2ludFR3b1gsIHkucG9pbnRUd29ZKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNle1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0tleSBuYW1lcyBkbyBub3QgbWF0Y2gnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gUG9pbnQgdG8gUG9pbnQgM0RcbiAgICAgIGVsc2UgaWYoT2JqZWN0LmtleXMoeCkubGVuZ3RoID09IDMgJiYgT2JqZWN0LmtleXMoeSkubGVuZ3RoID09IDMpe1xuICAgICAgICBpZiAoIV8zZCh4KSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdWYWx1ZXMgb2YgcG9pbnRPbmVYLCBwb2ludE9uZVkgYW5kIHBvaW50T25lWiBzaG91bGQgYmUgbnVtYmVycycpOyB9XG4gICAgICAgIGlmICghXzNkKHkpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1ZhbHVlcyBvZiBwb2ludFR3b1gsIHBvaW50VHdvWSBhbmQgcG9pbnRUd29aIHNob3VsZCBiZSBudW1iZXJzJyk7IH1cbiAgICAgICAgaWYgKHguaGFzT3duUHJvcGVydHkoJ3BvaW50T25lWCcpICYmIHguaGFzT3duUHJvcGVydHkoJ3BvaW50T25lWScpICYmIHguaGFzT3duUHJvcGVydHkoJ3BvaW50T25lWicpICYmXG4gICAgICAgICAgeS5oYXNPd25Qcm9wZXJ0eSgncG9pbnRUd29YJykgJiYgeS5oYXNPd25Qcm9wZXJ0eSgncG9pbnRUd29ZJykgJiYgeS5oYXNPd25Qcm9wZXJ0eSgncG9pbnRUd29aJykpe1xuXG4gICAgICAgICAgcmV0dXJuIF9kaXN0YW5jZTNkKHgucG9pbnRPbmVYLCB4LnBvaW50T25lWSwgeC5wb2ludE9uZVosIHkucG9pbnRUd29YLCB5LnBvaW50VHdvWSwgeS5wb2ludFR3b1opO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0tleSBuYW1lcyBkbyBub3QgbWF0Y2gnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZXtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBBcmd1bWVudHM6IFRyeSBhZ2FpbicpO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ0FycmF5JzogZnVuY3Rpb24oYXJyKXtcbiAgICAgIGlmICghX3BhaXJ3aXNlKGFycikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignSW5jb3JyZWN0IGFycmF5IGZvcm1hdCBlbnRlcmVkIGZvciBwYWlyd2lzZSBkaXN0YW5jZSBjYWxjdWxhdGlvbicpOyB9XG5cbiAgICAgIHJldHVybiBfZGlzdGFuY2VQYWlyd2lzZShhcnIpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkaXN0YW5jZTtcbn1cblxuZnVuY3Rpb24gXzJkKGEpe1xuICAvLyBjaGVja3MgaWYgdGhlIG51bWJlciBvZiBhcmd1bWVudHMgYXJlIGNvcnJlY3QgaW4gY291bnQgYW5kIGFyZSB2YWxpZCAoc2hvdWxkIGJlIG51bWJlcnMpXG4gIGlmIChhLmNvbnN0cnVjdG9yICE9PSBBcnJheSl7XG4gICAgYSA9IF9vYmplY3RUb0FycmF5KGEpO1xuICB9XG4gIHJldHVybiB0eXBlb2YgYVswXSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGFbMV0gPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBfM2QoYSl7XG4gIC8vIGNoZWNrcyBpZiB0aGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBhcmUgY29ycmVjdCBpbiBjb3VudCBhbmQgYXJlIHZhbGlkIChzaG91bGQgYmUgbnVtYmVycylcbiAgaWYgKGEuY29uc3RydWN0b3IgIT09IEFycmF5KXtcbiAgICBhID0gX29iamVjdFRvQXJyYXkoYSk7XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiBhWzBdID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYVsxXSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGFbMl0gPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBfcGFyYW1ldHJpY0xpbmUoYSl7XG4gIGlmIChhLmNvbnN0cnVjdG9yICE9PSBBcnJheSl7XG4gICAgYSA9IF9vYmplY3RUb0FycmF5KGEpO1xuICB9XG4gIHJldHVybiB0eXBlb2YgYVswXSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGFbMV0gPT09ICdudW1iZXInICYmIHR5cGVvZiBhWzJdID09PSAnbnVtYmVyJyAmJlxuICAgIHR5cGVvZiBhWzNdID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYVs0XSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGFbNV0gPT09ICdudW1iZXInO1xuXG59XG5cbmZ1bmN0aW9uIF9vYmplY3RUb0FycmF5KG8pe1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG8pO1xuICB2YXIgYSA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBhLnB1c2gob1trZXlzW2ldXSk7XG4gIH1cbiAgcmV0dXJuIGE7XG59XG5cbmZ1bmN0aW9uIF9wYWlyd2lzZShhKXtcbiAgLy9jaGVja3MgZm9yIHZhbGlkIGFyZ3VtZW50cyBwYXNzZWQgdG8gX2Rpc3RhbmNlUGFpcndpc2UoQXJyYXkpXG4gIGlmIChhWzBdLmxlbmd0aCA9PSAyICYmIHR5cGVvZiBhWzBdWzBdID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYVswXVsxXSA9PT0gJ251bWJlcicpe1xuICAgIGZvcih2YXIgaSBpbiBhKXtcbiAgICAgIGlmIChhW2ldLmxlbmd0aCAhPSAyIHx8IHR5cGVvZiBhW2ldWzBdICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgYVtpXVsxXSAhPT0gJ251bWJlcicpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKGFbMF0ubGVuZ3RoID09IDMgJiYgdHlwZW9mIGFbMF1bMF0gPT09ICdudW1iZXInICYmIHR5cGVvZiBhWzBdWzFdID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYVswXVsyXSA9PT0gJ251bWJlcicpe1xuICAgIGZvcih2YXIgaSBpbiBhKXtcbiAgICAgIGlmIChhW2ldLmxlbmd0aCAhPSAzIHx8IHR5cGVvZiBhW2ldWzBdICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgYVtpXVsxXSAhPT0gJ251bWJlcicgfHwgdHlwZW9mIGFbaV1bMl0gIT09ICdudW1iZXInKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbHNle1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gX2Rpc3RhbmNlUG9pbnRMaW5lMkQoeCwgeSwgYSwgYiwgYyl7XG4gIHZhciBudW0gPSAgTWF0aC5hYnMoYSp4ICsgYip5ICsgYyk7XG4gIHZhciBkZW4gPSBNYXRoLnBvdygoYSphICsgYipiKSwgMC41KTtcbiAgdmFyIHJlc3VsdCA9IChudW0vZGVuKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gX2Rpc3RhbmNlUG9pbnRMaW5lM0QoeCwgeSwgeiwgeDAsIHkwLCB6MCwgYSwgYiwgYyl7XG4gIHZhciBudW0gPSBbKCh5MC15KSooYykpLSgoejAteikqKGIpKSwgKCh6MC16KSooYSkpLSgoeDAteCkqKGMpKSwgKCh4MC14KSooYikpLSgoeTAteSkqKGEpKV1cbiAgbnVtID0gTWF0aC5wb3cobnVtWzBdKm51bVswXSArIG51bVsxXSpudW1bMV0gKyBudW1bMl0qbnVtWzJdLCAwLjUpO1xuICB2YXIgZGVuID0gTWF0aC5wb3coYSphICsgYipiICsgYypjLCAwLjUpO1xuICB2YXIgcmVzdWx0ID0gbnVtL2RlbjtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gX2Rpc3RhbmNlMmQoeDEsIHkxLCB4MiwgeTIpe1xuICB2YXIgeURpZmYgPSB5MiAtIHkxO1xuICB2YXIgeERpZmYgPSB4MiAtIHgxO1xuICB2YXIgcmFkaWNhbnQgPSB5RGlmZiAqIHlEaWZmICsgeERpZmYgKiB4RGlmZjtcbiAgdmFyIHJlc3VsdCA9IE1hdGgucG93KHJhZGljYW50LCAwLjUpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBfZGlzdGFuY2UzZCh4MSwgeTEsIHoxLCB4MiwgeTIsIHoyKXtcbiAgdmFyIHpEaWZmID0gejIgLSB6MTtcbiAgdmFyIHlEaWZmID0geTIgLSB5MTtcbiAgdmFyIHhEaWZmID0geDIgLSB4MTtcbiAgdmFyIHJhZGljYW50ID0gekRpZmYgKiB6RGlmZiArIHlEaWZmICogeURpZmYgKyB4RGlmZiAqIHhEaWZmO1xuICB2YXIgcmVzdWx0ID0gTWF0aC5wb3cocmFkaWNhbnQsIDAuNSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIF9kaXN0YW5jZVBhaXJ3aXNlKGEpe1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aC0xOyBpKyspe1xuICAgIGZvcih2YXIgaiA9IGkrMTsgaiA8IGEubGVuZ3RoOyBqKyspe1xuICAgICAgaWYgKGFbMF0ubGVuZ3RoID09IDIpe1xuICAgICAgICByZXN1bHQucHVzaChfZGlzdGFuY2UyZChhW2ldWzBdLCBhW2ldWzFdLCBhW2pdWzBdLCBhW2pdWzFdKSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhWzBdLmxlbmd0aCA9PSAzKXtcbiAgICAgICAgcmVzdWx0LnB1c2goX2Rpc3RhbmNlM2QoYVtpXVswXSwgYVtpXVsxXSwgYVtpXVsyXSwgYVtqXVswXSwgYVtqXVsxXSwgYVtqXVsyXSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnRzLm5hbWUgPSAnZGlzdGFuY2UnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIm1vZHVsZS5leHBvcnRzID0gW1xuICByZXF1aXJlKCcuL2ludGVyc2VjdCcpLFxuICByZXF1aXJlKCcuL2Rpc3RhbmNlJylcbl07XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcblxuICB2YXIgYWJzID0gbG9hZChyZXF1aXJlKCcuLi9hcml0aG1ldGljL2FicycpKTtcbiAgdmFyIGFkZCA9IGxvYWQocmVxdWlyZSgnLi4vYXJpdGhtZXRpYy9hZGQnKSk7XG4gIHZhciBtYXRyaXggPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L2Z1bmN0aW9uL21hdHJpeCcpKTtcbiAgdmFyIG11bHRpcGx5ID0gbG9hZChyZXF1aXJlKCcuLi9hcml0aG1ldGljL211bHRpcGx5JykpO1xuICB2YXIgc3VidHJhY3QgPSBsb2FkKHJlcXVpcmUoJy4uL2FyaXRobWV0aWMvc3VidHJhY3QnKSk7XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIHBvaW50IG9mIGludGVyc2VjdGlvbiBvZiB0d28gbGluZXMgaW4gdHdvIG9yIHRocmVlIGRpbWVuc2lvbnNcbiAgICogYW5kIG9mIGEgbGluZSBhbmQgYSBwbGFuZSBpbiB0aHJlZSBkaW1lbnNpb25zLiBUaGUgaW5wdXRzIGFyZSBpbiB0aGUgZm9ybSBvZlxuICAgKiBhcnJheXMgb3IgMSBkaW1lbnNpb25hbCBtYXRyaWNlcy4gVGhlIGxpbmUgaW50ZXJzZWN0aW9uIGZ1bmN0aW9ucyByZXR1cm4gbnVsbFxuICAgKiBpZiB0aGUgbGluZXMgZG8gbm90IG1lZXQuXG4gICAqXG4gICAqIE5vdGU6IEZpbGwgdGhlIHBsYW5lIGNvZWZmaWNpZW50cyBhcyBgeCArIHkgKyB6ID0gY2AgYW5kIG5vdCBhcyBgeCArIHkgKyB6ICsgYyA9IDBgLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguaW50ZXJzZWN0KGVuZFBvaW50MUxpbmUxLCBlbmRQb2ludDJMaW5lMSwgZW5kUG9pbnQxTGluZTIsIGVuZFBvaW50MkxpbmUyKVxuICAgKiAgICBtYXRoLmludGVyc2VjdChlbmRQb2ludDEsIGVuZFBvaW50MiwgcGxhbmVDb2VmZmljaWVudHMpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmludGVyc2VjdChbMCwgMF0sIFsxMCwgMTBdLCBbMTAsIDBdLCBbMCwgMTBdKTsgICAgICAgICAgICAgIC8vIFJldHVybnMgWzUsIDVdXG4gICAqICAgIG1hdGguaW50ZXJzZWN0KFswLCAwLCAwXSwgWzEwLCAxMCwgMF0sIFsxMCwgMCwgMF0sIFswLCAxMCwgMF0pOyAgLy8gUmV0dXJucyBbNSwgNSwgMF1cbiAgICogICAgbWF0aC5pbnRlcnNlY3QoWzEsIDAsIDFdLCAgWzQsIC0yLCAyXSwgWzEsIDEsIDEsIDZdKTsgICAgICAgICAgICAvLyBSZXR1cm5zIFs3LCAtNCwgM11cbiAgICpcbiAgICogQHBhcmFtICB7QXJyYXkgfCBNYXRyaXh9IHcgICBDby1vcmRpbmF0ZXMgb2YgZmlyc3QgZW5kLXBvaW50IG9mIGZpcnN0IGxpbmVcbiAgICogQHBhcmFtICB7QXJyYXkgfCBNYXRyaXh9IHggICBDby1vcmRpbmF0ZXMgb2Ygc2Vjb25kIGVuZC1wb2ludCBvZiBmaXJzdCBsaW5lXG4gICAqIEBwYXJhbSAge0FycmF5IHwgTWF0cml4fSB5ICAgQ28tb3JkaW5hdGVzIG9mIGZpcnN0IGVuZC1wb2ludCBvZiBzZWNvbmQgbGluZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9SIENvLWVmZmljaWVudHMgb2YgdGhlIHBsYW5lJ3MgZXF1YXRpb25cbiAgICogQHBhcmFtICB7QXJyYXkgfCBNYXRyaXh9IHogICBDby1vcmRpbmF0ZXMgb2Ygc2Vjb25kIGVuZC1wb2ludCBvZiBzZWNvbmQgbGluZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9SIG51bGwgaWYgdGhlIGNhbGN1bGF0aW9uIGlzIGZvciBsaW5lIGFuZCBwbGFuZVxuICAgKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgICAgIFJldHVybnMgdGhlIHBvaW50IG9mIGludGVyc2VjdGlvbiBvZiBsaW5lcy9saW5lcy1wbGFuZXNcbiAgICovXG4gIHZhciBpbnRlcnNlY3QgPSB0eXBlZCgnaW50ZXJzZWN0Jywge1xuICAgICdBcnJheSwgQXJyYXksIEFycmF5JzogZnVuY3Rpb24gKHgsIHksIHBsYW5lKSB7XG4gICAgICBpZiAoIV8zZCh4KSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheSB3aXRoIDMgbnVtYmVycyBleHBlY3RlZCBmb3IgZmlyc3QgYXJndW1lbnQnKTsgfVxuICAgICAgaWYgKCFfM2QoeSkpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkgd2l0aCAzIG51bWJlcnMgZXhwZWN0ZWQgZm9yIHNlY29uZCBhcmd1bWVudCcpOyB9XG4gICAgICBpZiAoIV80ZChwbGFuZSkpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkgd2l0aCA0IG51bWJlcnMgZXhwZWN0ZWQgYXMgdGhpcmQgYXJndW1lbnQnKTsgfVxuXG4gICAgICByZXR1cm4gX2ludGVyc2VjdExpbmVQbGFuZSh4WzBdLCB4WzFdLCB4WzJdLCB5WzBdLCB5WzFdLCB5WzJdLCBwbGFuZVswXSwgcGxhbmVbMV0sIHBsYW5lWzJdLCBwbGFuZVszXSk7XG4gICAgfSxcblxuICAgICdBcnJheSwgQXJyYXksIEFycmF5LCBBcnJheSc6IGZ1bmN0aW9uICh3LCB4LCB5LCB6KSB7XG4gICAgICBpZiAody5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgaWYgKCFfMmQodykpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkgd2l0aCAyIG51bWJlcnMgZXhwZWN0ZWQgZm9yIGZpcnN0IGFyZ3VtZW50Jyk7IH1cbiAgICAgICAgaWYgKCFfMmQoeCkpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkgd2l0aCAyIG51bWJlcnMgZXhwZWN0ZWQgZm9yIHNlY29uZCBhcmd1bWVudCcpOyB9XG4gICAgICAgIGlmICghXzJkKHkpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5IHdpdGggMiBudW1iZXJzIGV4cGVjdGVkIGZvciB0aGlyZCBhcmd1bWVudCcpOyB9XG4gICAgICAgIGlmICghXzJkKHopKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5IHdpdGggMiBudW1iZXJzIGV4cGVjdGVkIGZvciBmb3VydGggYXJndW1lbnQnKTsgfVxuXG4gICAgICAgIHJldHVybiBfaW50ZXJzZWN0MmQodywgeCwgeSwgeik7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh3Lmxlbmd0aCA9PT0gMykge1xuICAgICAgICBpZiAoIV8zZCh3KSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheSB3aXRoIDMgbnVtYmVycyBleHBlY3RlZCBmb3IgZmlyc3QgYXJndW1lbnQnKTsgfVxuICAgICAgICBpZiAoIV8zZCh4KSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheSB3aXRoIDMgbnVtYmVycyBleHBlY3RlZCBmb3Igc2Vjb25kIGFyZ3VtZW50Jyk7IH1cbiAgICAgICAgaWYgKCFfM2QoeSkpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkgd2l0aCAzIG51bWJlcnMgZXhwZWN0ZWQgZm9yIHRoaXJkIGFyZ3VtZW50Jyk7IH1cbiAgICAgICAgaWYgKCFfM2QoeikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkgd2l0aCAzIG51bWJlcnMgZXhwZWN0ZWQgZm9yIGZvdXJ0aCBhcmd1bWVudCcpOyB9XG5cbiAgICAgICAgcmV0dXJuIF9pbnRlcnNlY3QzZCh3WzBdLCB3WzFdLCB3WzJdLCB4WzBdLCB4WzFdLCB4WzJdLCB5WzBdLCB5WzFdLCB5WzJdLCB6WzBdLCB6WzFdLCB6WzJdKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheXMgd2l0aCB0d28gb3IgdGhlZSBkaW1lbnNpb25hbCBwb2ludHMgZXhwZWN0ZWQnKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgJ01hdHJpeCwgTWF0cml4LCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSwgcGxhbmUpIHtcbiAgICAgIHJldHVybiBtYXRyaXgoaW50ZXJzZWN0KHgudmFsdWVPZigpLCB5LnZhbHVlT2YoKSwgcGxhbmUudmFsdWVPZigpKSk7XG4gICAgfSxcblxuICAgICdNYXRyaXgsIE1hdHJpeCwgTWF0cml4LCBNYXRyaXgnOiBmdW5jdGlvbiAodywgeCwgeSwgeikge1xuICAgICAgLy8gVE9ETzogb3V0cHV0IG1hdHJpeCB0eXBlIHNob3VsZCBtYXRjaCBpbnB1dCBtYXRyaXggdHlwZVxuICAgICAgcmV0dXJuIG1hdHJpeChpbnRlcnNlY3Qody52YWx1ZU9mKCksIHgudmFsdWVPZigpLCB5LnZhbHVlT2YoKSwgei52YWx1ZU9mKCkpKTtcbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIF8yZCh4KSB7XG4gICAgcmV0dXJuIHgubGVuZ3RoID09PSAyICYmIHR5cGVvZiB4WzBdID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgeFsxXSA9PT0gJ251bWJlcic7XG4gIH1cblxuICBmdW5jdGlvbiBfM2QoeCkge1xuICAgIHJldHVybiB4Lmxlbmd0aCA9PT0gMyAmJiB0eXBlb2YgeFswXSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHhbMV0gPT09ICdudW1iZXInICYmIHR5cGVvZiB4WzJdID09PSAnbnVtYmVyJztcbiAgfVxuXG4gIGZ1bmN0aW9uIF80ZCh4KSB7XG4gICAgcmV0dXJuIHgubGVuZ3RoID09PSA0ICYmIHR5cGVvZiB4WzBdID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgeFsxXSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHhbMl0gPT09ICdudW1iZXInICYmIHR5cGVvZiB4WzNdID09PSAnbnVtYmVyJztcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pbnRlcnNlY3QyZChwMWEsIHAxYiwgcDJhLCBwMmIpe1xuICAgIHZhciBvMSA9IHAxYTtcbiAgICB2YXIgbzIgPSBwMmE7XG4gICAgdmFyIGQxID0gc3VidHJhY3QobzEsIHAxYik7XG4gICAgdmFyIGQyID0gc3VidHJhY3QobzIsIHAyYik7XG4gICAgdmFyIGRldCA9IGQxWzBdKmQyWzFdIC0gZDJbMF0qZDFbMV07XG4gICAgaWYgKGFicyhkZXQpIDwgY29uZmlnLmVwc2lsb24pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgdCA9IChkMlswXSpvMVsxXSAtIGQyWzFdKm8xWzBdIC0gZDJbMF0qbzJbMV0gKyBkMlsxXSpvMlswXSkgLyBkZXQ7XG4gICAgcmV0dXJuIGFkZChtdWx0aXBseShkMSwgdCksIG8xKTsgXG4gIH1cblxuICBmdW5jdGlvbiBfaW50ZXJzZWN0M2QoeDEsIHkxLCB6MSwgeDIsIHkyLCB6MiwgeDMsIHkzLCB6MywgeDQsIHk0LCB6NCl7XG4gICAgdmFyIGQxMzQzID0gKHgxIC0geDMpKih4NCAtIHgzKSArICh5MSAtIHkzKSooeTQgLSB5MykgKyAoejEgLSB6MykqKHo0IC0gejMpO1xuICAgIHZhciBkNDMyMSA9ICh4NCAtIHgzKSooeDIgLSB4MSkgKyAoeTQgLSB5MykqKHkyIC0geTEpICsgKHo0IC0gejMpKih6MiAtIHoxKTtcbiAgICB2YXIgZDEzMjEgPSAoeDEgLSB4MykqKHgyIC0geDEpICsgKHkxIC0geTMpKih5MiAtIHkxKSArICh6MSAtIHozKSooejIgLSB6MSk7XG4gICAgdmFyIGQ0MzQzID0gKHg0IC0geDMpKih4NCAtIHgzKSArICh5NCAtIHkzKSooeTQgLSB5MykgKyAoejQgLSB6MykqKHo0IC0gejMpO1xuICAgIHZhciBkMjEyMSA9ICh4MiAtIHgxKSooeDIgLSB4MSkgKyAoeTIgLSB5MSkqKHkyIC0geTEpICsgKHoyIC0gejEpKih6MiAtIHoxKTtcbiAgICB2YXIgdGEgPSAoIGQxMzQzKmQ0MzIxIC0gZDEzMjEqZDQzNDMgKSAvICggZDIxMjEqZDQzNDMgLSBkNDMyMSpkNDMyMSApO1xuICAgIHZhciB0YiA9ICggZDEzNDMgKyB0YSAqIGQ0MzIxICkgLyAoZDQzNDMpO1xuXG4gICAgdmFyIHBheCA9IHgxICsgdGEgKiAoeDIgLSB4MSk7XG4gICAgdmFyIHBheSA9IHkxICsgdGEgKiAoeTIgLSB5MSk7XG4gICAgdmFyIHBheiA9IHoxICsgdGEgKiAoejIgLSB6MSk7XG4gICAgdmFyIHBieCA9IHgzICsgdGIgKiAoeDQgLSB4Myk7XG4gICAgdmFyIHBieSA9IHkzICsgdGIgKiAoeTQgLSB5Myk7XG4gICAgdmFyIHBieiA9IHozICsgdGIgKiAoejQgLSB6Myk7XG4gICAgaWYgKHBheCA9PT0gcGJ4ICYmIHBheSA9PT0gcGJ5ICYmIHBheiA9PT0gcGJ6KXtcbiAgICAgIHJldHVybiBbcGF4LCBwYXksIHBhel07XG4gICAgfVxuICAgIGVsc2V7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfaW50ZXJzZWN0TGluZVBsYW5lKHgxLCB5MSwgejEsIHgyLCB5MiwgejIsIHgsIHksIHosIGMpe1xuICAgIHZhciB0ID0gKGMgLSB4MSp4IC0geTEqeSAtIHoxKnopLyh4Mip4ICsgeTIqeSArIHoyKnogLSB4MSAtIHkxIC0gejEpO1xuICAgIHZhciBweCA9IHgxICsgdCAqICh4MiAtIHgxKTtcbiAgICB2YXIgcHkgPSB5MSArIHQgKiAoeTIgLSB5MSk7XG4gICAgdmFyIHB6ID0gejEgKyB0ICogKHoyIC0gejEpO1xuICAgIHJldHVybiBbcHgsIHB5LCBwel07XG4gICAgLy8gVE9ETzogQWRkIGNhc2VzIHdoZW4gbGluZSBpcyBwYXJhbGxlbCB0byB0aGUgcGxhbmU6XG4gICAgLy8gICAgICAgKGEpIG5vIGludGVyc2VjdGlvbixcbiAgICAvLyAgICAgICAoYikgbGluZSBjb250YWluZWQgaW4gcGxhbmVcbiAgfVxuXG4gIHJldHVybiBpbnRlcnNlY3Q7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdpbnRlcnNlY3QnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIm1vZHVsZS5leHBvcnRzID0gW1xuICByZXF1aXJlKCcuL2FsZ2VicmEnKSxcbiAgcmVxdWlyZSgnLi9hcml0aG1ldGljJyksXG4gIHJlcXVpcmUoJy4vYml0d2lzZScpLFxuICByZXF1aXJlKCcuL2NvbWJpbmF0b3JpY3MnKSxcbiAgcmVxdWlyZSgnLi9jb21wbGV4JyksXG4gIHJlcXVpcmUoJy4vZ2VvbWV0cnknKSxcbiAgcmVxdWlyZSgnLi9sb2dpY2FsJyksXG4gIHJlcXVpcmUoJy4vbWF0cml4JyksXG4gIHJlcXVpcmUoJy4vcHJvYmFiaWxpdHknKSxcbiAgcmVxdWlyZSgnLi9yZWxhdGlvbmFsJyksXG4gIHJlcXVpcmUoJy4vc3RhdGlzdGljcycpLFxuICByZXF1aXJlKCcuL3N0cmluZycpLFxuICByZXF1aXJlKCcuL3RyaWdvbm9tZXRyeScpLFxuICByZXF1aXJlKCcuL3VuaXQnKSxcbiAgcmVxdWlyZSgnLi91dGlscycpXG5dO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBsYXRleCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2xhdGV4Jyk7XG5cbiAgdmFyIG1hdHJpeCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvZnVuY3Rpb24vbWF0cml4JykpO1xuICB2YXIgemVyb3MgPSBsb2FkKHJlcXVpcmUoJy4uL21hdHJpeC96ZXJvcycpKTtcbiAgdmFyIG5vdCA9IGxvYWQocmVxdWlyZSgnLi9ub3QnKSk7XG4gIHZhciBpc1plcm8gPSBsb2FkKHJlcXVpcmUoJy4uL3V0aWxzL2lzWmVybycpKTtcblxuICB2YXIgYWxnb3JpdGhtMDIgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTAyJykpO1xuICB2YXIgYWxnb3JpdGhtMDYgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTA2JykpO1xuICB2YXIgYWxnb3JpdGhtMTEgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTExJykpO1xuICB2YXIgYWxnb3JpdGhtMTMgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTEzJykpO1xuICB2YXIgYWxnb3JpdGhtMTQgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTE0JykpO1xuXG4gIC8qKlxuICAgKiBMb2dpY2FsIGBhbmRgLiBUZXN0IHdoZXRoZXIgdHdvIHZhbHVlcyBhcmUgYm90aCBkZWZpbmVkIHdpdGggYSBub256ZXJvL25vbmVtcHR5IHZhbHVlLlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguYW5kKHgsIHkpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmFuZCgyLCA0KTsgICAvLyByZXR1cm5zIHRydWVcbiAgICpcbiAgICogICAgYSA9IFsyLCAwLCAwXTtcbiAgICogICAgYiA9IFszLCA3LCAwXTtcbiAgICogICAgYyA9IDA7XG4gICAqXG4gICAqICAgIG1hdGguYW5kKGEsIGIpOyAgIC8vIHJldHVybnMgW3RydWUsIGZhbHNlLCBmYWxzZV1cbiAgICogICAgbWF0aC5hbmQoYSwgYyk7ICAgLy8gcmV0dXJucyBbZmFsc2UsIGZhbHNlLCBmYWxzZV1cbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIG5vdCwgb3IsIHhvclxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBDb21wbGV4IHwgVW5pdCB8IEFycmF5IHwgTWF0cml4fSB4IEZpcnN0IHZhbHVlIHRvIGNoZWNrXG4gICAqIEBwYXJhbSAge251bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXh9IHkgU2Vjb25kIHZhbHVlIHRvIGNoZWNrXG4gICAqIEByZXR1cm4ge2Jvb2xlYW4gfCBBcnJheSB8IE1hdHJpeH1cbiAgICogICAgICAgICAgICBSZXR1cm5zIHRydWUgd2hlbiBib3RoIGlucHV0cyBhcmUgZGVmaW5lZCB3aXRoIGEgbm9uemVyby9ub25lbXB0eSB2YWx1ZS5cbiAgICovXG4gIHZhciBhbmQgPSB0eXBlZCgnYW5kJywge1xuXG4gICAgJ251bWJlciwgbnVtYmVyJzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHJldHVybiAhISh4ICYmIHkpO1xuICAgIH0sXG5cbiAgICAnQ29tcGxleCwgQ29tcGxleCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4gKHgucmUgIT09IDAgfHwgeC5pbSAhPT0gMCkgJiYgKHkucmUgIT09IDAgfHwgeS5pbSAhPT0gMCk7XG4gICAgfSxcblxuICAgICdCaWdOdW1iZXIsIEJpZ051bWJlcic6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4gIXguaXNaZXJvKCkgJiYgIXkuaXNaZXJvKCkgJiYgIXguaXNOYU4oKSAmJiAheS5pc05hTigpO1xuICAgIH0sXG5cbiAgICAnVW5pdCwgVW5pdCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4gYW5kKHgudmFsdWUsIHkudmFsdWUpO1xuICAgIH0sXG4gICAgXG4gICAgJ01hdHJpeCwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHJlc3VsdFxuICAgICAgdmFyIGM7XG5cbiAgICAgIC8vIHByb2Nlc3MgbWF0cml4IHN0b3JhZ2VcbiAgICAgIHN3aXRjaCAoeC5zdG9yYWdlKCkpIHtcbiAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICBzd2l0Y2ggKHkuc3RvcmFnZSgpKSB7XG4gICAgICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgICAgICAvLyBzcGFyc2UgJiBzcGFyc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTA2KHgsIHksIGFuZCwgZmFsc2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIHNwYXJzZSAmIGRlbnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0wMih5LCB4LCBhbmQsIHRydWUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgc3dpdGNoICh5LnN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICAgICAgLy8gZGVuc2UgJiBzcGFyc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTAyKHgsIHksIGFuZCwgZmFsc2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIGRlbnNlICYgZGVuc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTEzKHgsIHksIGFuZCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG5cbiAgICAnQXJyYXksIEFycmF5JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBhbmQobWF0cml4KHgpLCBtYXRyaXgoeSkpLnZhbHVlT2YoKTtcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGFuZChtYXRyaXgoeCksIHkpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4LCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gYW5kKHgsIG1hdHJpeCh5KSk7XG4gICAgfSxcblxuICAgICdNYXRyaXgsIGFueSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyBjaGVjayBzY2FsYXJcbiAgICAgIGlmIChub3QoeSkpIHtcbiAgICAgICAgLy8gcmV0dXJuIHplcm8gbWF0cml4XG4gICAgICAgIHJldHVybiB6ZXJvcyh4LnNpemUoKSwgeC5zdG9yYWdlKCkpO1xuICAgICAgfVxuICAgICAgLy8gcmVzdWx0XG4gICAgICB2YXIgYztcbiAgICAgIC8vIGNoZWNrIHN0b3JhZ2UgZm9ybWF0XG4gICAgICBzd2l0Y2ggKHguc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTExKHgsIHksIGFuZCwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xNCh4LCB5LCBhbmQsIGZhbHNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG5cbiAgICAnYW55LCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gY2hlY2sgc2NhbGFyXG4gICAgICBpZiAobm90KHgpKSB7XG4gICAgICAgIC8vIHJldHVybiB6ZXJvIG1hdHJpeFxuICAgICAgICByZXR1cm4gemVyb3MoeC5zaXplKCksIHguc3RvcmFnZSgpKTtcbiAgICAgIH1cbiAgICAgIC8vIHJlc3VsdFxuICAgICAgdmFyIGM7XG4gICAgICAvLyBjaGVjayBzdG9yYWdlIGZvcm1hdFxuICAgICAgc3dpdGNoICh5LnN0b3JhZ2UoKSkge1xuICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xMSh5LCB4LCBhbmQsIHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xNCh5LCB4LCBhbmQsIHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfSxcblxuICAgICdBcnJheSwgYW55JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBhbmQobWF0cml4KHgpLCB5KS52YWx1ZU9mKCk7XG4gICAgfSxcblxuICAgICdhbnksIEFycmF5JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBhbmQoeCwgbWF0cml4KHkpKS52YWx1ZU9mKCk7XG4gICAgfVxuICB9KTtcblxuICBhbmQudG9UZXggPSAnXFxcXGxlZnQoJHthcmdzWzBdfScgKyBsYXRleC5vcGVyYXRvcnNbJ2FuZCddICsgJyR7YXJnc1sxXX1cXFxccmlnaHQpJztcblxuICByZXR1cm4gYW5kO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnYW5kJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFtcbiAgcmVxdWlyZSgnLi9hbmQnKSxcbiAgcmVxdWlyZSgnLi9ub3QnKSxcbiAgcmVxdWlyZSgnLi9vcicpLFxuICByZXF1aXJlKCcuL3hvcicpXG5dO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVlcE1hcCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vZGVlcE1hcCcpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBsYXRleCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2xhdGV4Jyk7XG5cbiAgLyoqXG4gICAqIExvZ2ljYWwgYG5vdGAuIEZsaXBzIGJvb2xlYW4gdmFsdWUgb2YgYSBnaXZlbiBwYXJhbWV0ZXIuXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5ub3QoeClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGgubm90KDIpOyAgICAgIC8vIHJldHVybnMgZmFsc2VcbiAgICogICAgbWF0aC5ub3QoMCk7ICAgICAgLy8gcmV0dXJucyB0cnVlXG4gICAqICAgIG1hdGgubm90KHRydWUpOyAgIC8vIHJldHVybnMgZmFsc2VcbiAgICpcbiAgICogICAgYSA9IFsyLCAtNywgMF07XG4gICAqICAgIG1hdGgubm90KGEpOyAgICAgIC8vIHJldHVybnMgW2ZhbHNlLCBmYWxzZSwgdHJ1ZV1cbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGFuZCwgb3IsIHhvclxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBDb21wbGV4IHwgVW5pdCB8IEFycmF5IHwgTWF0cml4fSB4IEZpcnN0IHZhbHVlIHRvIGNoZWNrXG4gICAqIEByZXR1cm4ge2Jvb2xlYW4gfCBBcnJheSB8IE1hdHJpeH1cbiAgICogICAgICAgICAgICBSZXR1cm5zIHRydWUgd2hlbiBpbnB1dCBpcyBhIHplcm8gb3IgZW1wdHkgdmFsdWUuXG4gICAqL1xuICB2YXIgbm90ID0gdHlwZWQoJ25vdCcsIHtcbiAgICAnbnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiAheDtcbiAgICB9LFxuXG4gICAgJ0NvbXBsZXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHgucmUgPT09IDAgJiYgeC5pbSA9PT0gMDtcbiAgICB9LFxuXG4gICAgJ0JpZ051bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5pc1plcm8oKSB8fCB4LmlzTmFOKCk7XG4gICAgfSxcblxuICAgICdVbml0JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBub3QoeC52YWx1ZSk7XG4gICAgfSxcblxuICAgICdBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gZGVlcE1hcCh4LCBub3QpO1xuICAgIH1cbiAgfSk7XG5cbiAgbm90LnRvVGV4ID0gbGF0ZXgub3BlcmF0b3JzWydub3QnXSArICdcXFxcbGVmdCgke2FyZ3NbMF19XFxcXHJpZ2h0KSc7XG5cbiAgcmV0dXJuIG5vdDtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ25vdCc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBsYXRleCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2xhdGV4Jyk7XG5cbiAgdmFyIG1hdHJpeCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvZnVuY3Rpb24vbWF0cml4JykpO1xuXG4gIHZhciBhbGdvcml0aG0wMyA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMDMnKSk7XG4gIHZhciBhbGdvcml0aG0wNSA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMDUnKSk7XG4gIHZhciBhbGdvcml0aG0xMiA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMTInKSk7XG4gIHZhciBhbGdvcml0aG0xMyA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMTMnKSk7XG4gIHZhciBhbGdvcml0aG0xNCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMTQnKSk7XG4gIFxuICAvKipcbiAgICogTG9naWNhbCBgb3JgLiBUZXN0IGlmIGF0IGxlYXN0IG9uZSB2YWx1ZSBpcyBkZWZpbmVkIHdpdGggYSBub256ZXJvL25vbmVtcHR5IHZhbHVlLlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGgub3IoeCwgeSlcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGgub3IoMiwgNCk7ICAgLy8gcmV0dXJucyB0cnVlXG4gICAqXG4gICAqICAgIGEgPSBbMiwgNSwgMF07XG4gICAqICAgIGIgPSBbMCwgMjIsIDBdO1xuICAgKiAgICBjID0gMDtcbiAgICpcbiAgICogICAgbWF0aC5vcihhLCBiKTsgICAvLyByZXR1cm5zIFt0cnVlLCB0cnVlLCBmYWxzZV1cbiAgICogICAgbWF0aC5vcihiLCBjKTsgICAvLyByZXR1cm5zIFtmYWxzZSwgdHJ1ZSwgZmFsc2VdXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBhbmQsIG5vdCwgeG9yXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXh9IHggRmlyc3QgdmFsdWUgdG8gY2hlY2tcbiAgICogQHBhcmFtICB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeH0geSBTZWNvbmQgdmFsdWUgdG8gY2hlY2tcbiAgICogQHJldHVybiB7Ym9vbGVhbiB8IEFycmF5IHwgTWF0cml4fVxuICAgKiAgICAgICAgICAgIFJldHVybnMgdHJ1ZSB3aGVuIG9uZSBvZiB0aGUgaW5wdXRzIGlzIGRlZmluZWQgd2l0aCBhIG5vbnplcm8vbm9uZW1wdHkgdmFsdWUuXG4gICAqL1xuICB2YXIgb3IgPSB0eXBlZCgnb3InLCB7XG5cbiAgICAnbnVtYmVyLCBudW1iZXInOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuICEhKHggfHwgeSk7XG4gICAgfSxcblxuICAgICdDb21wbGV4LCBDb21wbGV4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHJldHVybiAoeC5yZSAhPT0gMCB8fCB4LmltICE9PSAwKSB8fCAoeS5yZSAhPT0gMCB8fCB5LmltICE9PSAwKTtcbiAgICB9LFxuXG4gICAgJ0JpZ051bWJlciwgQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHJldHVybiAoIXguaXNaZXJvKCkgJiYgIXguaXNOYU4oKSkgfHwgKCF5LmlzWmVybygpICYmICF5LmlzTmFOKCkpO1xuICAgIH0sXG5cbiAgICAnVW5pdCwgVW5pdCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4gb3IoeC52YWx1ZSwgeS52YWx1ZSk7XG4gICAgfSxcblxuICAgICdNYXRyaXgsIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuXG4gICAgICAvLyBwcm9jZXNzIG1hdHJpeCBzdG9yYWdlXG4gICAgICBzd2l0Y2ggKHguc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgc3dpdGNoICh5LnN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICAgICAgLy8gc3BhcnNlICsgc3BhcnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0wNSh4LCB5LCBvcik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgLy8gc3BhcnNlICsgZGVuc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTAzKHksIHgsIG9yLCB0cnVlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgICAgIC8vIGRlbnNlICsgc3BhcnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0wMyh4LCB5LCBvciwgZmFsc2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIGRlbnNlICsgZGVuc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTEzKHgsIHksIG9yKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfSxcblxuICAgICdBcnJheSwgQXJyYXknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIG9yKG1hdHJpeCh4KSwgbWF0cml4KHkpKS52YWx1ZU9mKCk7XG4gICAgfSxcblxuICAgICdBcnJheSwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBvcihtYXRyaXgoeCksIHkpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4LCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gb3IoeCwgbWF0cml4KHkpKTtcbiAgICB9LFxuXG4gICAgJ01hdHJpeCwgYW55JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHJlc3VsdFxuICAgICAgdmFyIGM7XG4gICAgICAvLyBjaGVjayBzdG9yYWdlIGZvcm1hdFxuICAgICAgc3dpdGNoICh4LnN0b3JhZ2UoKSkge1xuICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xMih4LCB5LCBvciwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xNCh4LCB5LCBvciwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfSxcblxuICAgICdhbnksIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuICAgICAgLy8gY2hlY2sgc3RvcmFnZSBmb3JtYXRcbiAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTIoeSwgeCwgb3IsIHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xNCh5LCB4LCBvciwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBhbnknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGFsZ29yaXRobTE0KG1hdHJpeCh4KSwgeSwgb3IsIGZhbHNlKS52YWx1ZU9mKCk7XG4gICAgfSxcblxuICAgICdhbnksIEFycmF5JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBhbGdvcml0aG0xNChtYXRyaXgoeSksIHgsIG9yLCB0cnVlKS52YWx1ZU9mKCk7XG4gICAgfVxuICB9KTtcblxuICBvci50b1RleCA9ICdcXFxcbGVmdCgke2FyZ3NbMF19JyArIGxhdGV4Lm9wZXJhdG9yc1snb3InXSArICcke2FyZ3NbMV19XFxcXHJpZ2h0KSc7XG5cbiAgcmV0dXJuIG9yO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnb3InO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgbGF0ZXggPSByZXF1aXJlKCcuLi8uLi91dGlscy9sYXRleCcpO1xuXG4gIHZhciBtYXRyaXggPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L2Z1bmN0aW9uL21hdHJpeCcpKTtcblxuICB2YXIgYWxnb3JpdGhtMDMgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTAzJykpO1xuICB2YXIgYWxnb3JpdGhtMDcgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTA3JykpO1xuICB2YXIgYWxnb3JpdGhtMTIgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTEyJykpO1xuICB2YXIgYWxnb3JpdGhtMTMgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTEzJykpO1xuICB2YXIgYWxnb3JpdGhtMTQgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTE0JykpO1xuICBcbiAgLyoqXG4gICAqIExvZ2ljYWwgYHhvcmAuIFRlc3Qgd2hldGhlciBvbmUgYW5kIG9ubHkgb25lIHZhbHVlIGlzIGRlZmluZWQgd2l0aCBhIG5vbnplcm8vbm9uZW1wdHkgdmFsdWUuXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC54b3IoeCwgeSlcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGgueG9yKDIsIDQpOyAgIC8vIHJldHVybnMgZmFsc2VcbiAgICpcbiAgICogICAgYSA9IFsyLCAwLCAwXTtcbiAgICogICAgYiA9IFsyLCA3LCAwXTtcbiAgICogICAgYyA9IDA7XG4gICAqXG4gICAqICAgIG1hdGgueG9yKGEsIGIpOyAgIC8vIHJldHVybnMgW2ZhbHNlLCB0cnVlLCBmYWxzZV1cbiAgICogICAgbWF0aC54b3IoYSwgYyk7ICAgLy8gcmV0dXJucyBbdHJ1ZSwgZmFsc2UsIGZhbHNlXVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgYW5kLCBub3QsIG9yXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXh9IHggRmlyc3QgdmFsdWUgdG8gY2hlY2tcbiAgICogQHBhcmFtICB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeH0geSBTZWNvbmQgdmFsdWUgdG8gY2hlY2tcbiAgICogQHJldHVybiB7Ym9vbGVhbiB8IEFycmF5IHwgTWF0cml4fVxuICAgKiAgICAgICAgICAgIFJldHVybnMgdHJ1ZSB3aGVuIG9uZSBhbmQgb25seSBvbmUgaW5wdXQgaXMgZGVmaW5lZCB3aXRoIGEgbm9uemVyby9ub25lbXB0eSB2YWx1ZS5cbiAgICovXG4gIHZhciB4b3IgPSB0eXBlZCgneG9yJywge1xuIFxuICAgICdudW1iZXIsIG51bWJlcic6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4gISEoISF4IF4gISF5KTtcbiAgICB9LFxuXG4gICAgJ0NvbXBsZXgsIENvbXBsZXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuICgoeC5yZSAhPT0gMCB8fCB4LmltICE9PSAwKSAhPT0gKHkucmUgIT09IDAgfHwgeS5pbSAhPT0gMCkpO1xuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyLCBCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuICgoIXguaXNaZXJvKCkgJiYgIXguaXNOYU4oKSkgIT09ICgheS5pc1plcm8oKSAmJiAheS5pc05hTigpKSk7XG4gICAgfSxcblxuICAgICdVbml0LCBVbml0JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHJldHVybiB4b3IoeC52YWx1ZSwgeS52YWx1ZSk7XG4gICAgfSxcblxuICAgICdNYXRyaXgsIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuXG4gICAgICAvLyBwcm9jZXNzIG1hdHJpeCBzdG9yYWdlXG4gICAgICBzd2l0Y2ggKHguc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgc3dpdGNoICh5LnN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICAgICAgLy8gc3BhcnNlICsgc3BhcnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0wNyh4LCB5LCB4b3IpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIHNwYXJzZSArIGRlbnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0wMyh5LCB4LCB4b3IsIHRydWUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgc3dpdGNoICh5LnN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICAgICAgLy8gZGVuc2UgKyBzcGFyc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTAzKHgsIHksIHhvciwgZmFsc2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIGRlbnNlICsgZGVuc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTEzKHgsIHksIHhvcik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG5cbiAgICAnQXJyYXksIEFycmF5JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiB4b3IobWF0cml4KHgpLCBtYXRyaXgoeSkpLnZhbHVlT2YoKTtcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIHhvcihtYXRyaXgoeCksIHkpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4LCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4geG9yKHgsIG1hdHJpeCh5KSk7XG4gICAgfSxcblxuICAgICdNYXRyaXgsIGFueSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuICAgICAgLy8gY2hlY2sgc3RvcmFnZSBmb3JtYXRcbiAgICAgIHN3aXRjaCAoeC5zdG9yYWdlKCkpIHtcbiAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTIoeCwgeSwgeG9yLCBmYWxzZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTE0KHgsIHksIHhvciwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfSxcblxuICAgICdhbnksIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuICAgICAgLy8gY2hlY2sgc3RvcmFnZSBmb3JtYXRcbiAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTIoeSwgeCwgeG9yLCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTQoeSwgeCwgeG9yLCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG5cbiAgICAnQXJyYXksIGFueSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gYWxnb3JpdGhtMTQobWF0cml4KHgpLCB5LCB4b3IsIGZhbHNlKS52YWx1ZU9mKCk7XG4gICAgfSxcblxuICAgICdhbnksIEFycmF5JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBhbGdvcml0aG0xNChtYXRyaXgoeSksIHgsIHhvciwgdHJ1ZSkudmFsdWVPZigpO1xuICAgIH1cbiAgfSk7XG5cbiAgeG9yLnRvVGV4ID0gJ1xcXFxsZWZ0KCR7YXJnc1swXX0nICsgbGF0ZXgub3BlcmF0b3JzWyd4b3InXSArICcke2FyZ3NbMV19XFxcXHJpZ2h0KSc7XG5cbiAgcmV0dXJuIHhvcjtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ3hvcic7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2xvbmUgPSByZXF1aXJlKCcuLi8uLi91dGlscy9vYmplY3QnKS5jbG9uZTtcbnZhciBpc0ludGVnZXIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9udW1iZXInKS5pc0ludGVnZXI7XG52YXIgYXJyYXkgPSByZXF1aXJlKCcuLi8uLi91dGlscy9hcnJheScpO1xudmFyIEluZGV4RXJyb3IgPSByZXF1aXJlKCcuLi8uLi9lcnJvci9JbmRleEVycm9yJyk7XG52YXIgRGltZW5zaW9uRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9lcnJvci9EaW1lbnNpb25FcnJvcicpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBtYXRyaXggPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L2Z1bmN0aW9uL21hdHJpeCcpKTtcblxuICAvKipcbiAgICogQ29uY2F0ZW5hdGUgdHdvIG9yIG1vcmUgbWF0cmljZXMuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgIG1hdGguY29uY2F0KEEsIEIsIEMsIC4uLilcbiAgICogICAgIG1hdGguY29uY2F0KEEsIEIsIEMsIC4uLiwgZGltKVxuICAgKlxuICAgKiBXaGVyZTpcbiAgICpcbiAgICogLSBgZGltOiBudW1iZXJgIGlzIGEgemVyby1iYXNlZCBkaW1lbnNpb24gb3ZlciB3aGljaCB0byBjb25jYXRlbmF0ZSB0aGUgbWF0cmljZXMuXG4gICAqICAgQnkgZGVmYXVsdCB0aGUgbGFzdCBkaW1lbnNpb24gb2YgdGhlIG1hdHJpY2VzLlxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgdmFyIEEgPSBbWzEsIDJdLCBbNSwgNl1dO1xuICAgKiAgICB2YXIgQiA9IFtbMywgNF0sIFs3LCA4XV07XG4gICAqXG4gICAqICAgIG1hdGguY29uY2F0KEEsIEIpOyAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgW1sxLCAyLCAzLCA0XSwgWzUsIDYsIDcsIDhdXVxuICAgKiAgICBtYXRoLmNvbmNhdChBLCBCLCAwKTsgICAgICAgICAgICAgICAvLyByZXR1cm5zIFtbMSwgMl0sIFs1LCA2XSwgWzMsIDRdLCBbNywgOF1dXG4gICAqICAgIG1hdGguY29uY2F0KCdoZWxsbycsICcgJywgJ3dvcmxkJyk7IC8vIHJldHVybnMgJ2hlbGxvIHdvcmxkJ1xuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgc2l6ZSwgc3F1ZWV6ZSwgc3Vic2V0LCB0cmFuc3Bvc2VcbiAgICpcbiAgICogQHBhcmFtIHsuLi4gQXJyYXkgfCBNYXRyaXh9IGFyZ3MgICAgIFR3byBvciBtb3JlIG1hdHJpY2VzXG4gICAqIEByZXR1cm4ge0FycmF5IHwgTWF0cml4fSBDb25jYXRlbmF0ZWQgbWF0cml4XG4gICAqL1xuICB2YXIgY29uY2F0ID0gdHlwZWQoJ2NvbmNhdCcsIHtcbiAgICAvLyBUT0RPOiBjaGFuZ2Ugc2lnbmF0dXJlIHRvICcuLi5BcnJheSB8IE1hdHJpeCwgZGltPycgd2hlbiBzdXBwb3J0ZWRcbiAgICAnLi4uQXJyYXkgfCBNYXRyaXggfCBudW1iZXIgfCBCaWdOdW1iZXInOiBmdW5jdGlvbiAoYXJncykge1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gICAgICB2YXIgZGltID0gLTE7ICAvLyB6ZXJvLWJhc2VkIGRpbWVuc2lvblxuICAgICAgdmFyIHByZXZEaW07XG4gICAgICB2YXIgYXNNYXRyaXggPSBmYWxzZTtcbiAgICAgIHZhciBtYXRyaWNlcyA9IFtdOyAgLy8gY29udGFpbnMgbXVsdGkgZGltZW5zaW9uYWwgYXJyYXlzXG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgYXJnID0gYXJnc1tpXTtcblxuICAgICAgICAvLyB0ZXN0IHdoZXRoZXIgd2UgbmVlZCB0byByZXR1cm4gYSBNYXRyaXggKGlmIG5vdCB3ZSByZXR1cm4gYW4gQXJyYXkpXG4gICAgICAgIGlmIChhcmcgJiYgYXJnLmlzTWF0cml4ID09PSB0cnVlKSB7XG4gICAgICAgICAgYXNNYXRyaXggPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8IChhcmcgJiYgYXJnLmlzQmlnTnVtYmVyID09PSB0cnVlKSkge1xuICAgICAgICAgIGlmIChpICE9PSBsZW4gLSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpbWVuc2lvbiBtdXN0IGJlIHNwZWNpZmllZCBhcyBsYXN0IGFyZ3VtZW50Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gbGFzdCBhcmd1bWVudCBjb250YWlucyB0aGUgZGltZW5zaW9uIG9uIHdoaWNoIHRvIGNvbmNhdGVuYXRlXG4gICAgICAgICAgcHJldkRpbSA9IGRpbTtcbiAgICAgICAgICBkaW0gPSBhcmcudmFsdWVPZigpOyAvLyBjaGFuZ2UgQmlnTnVtYmVyIHRvIG51bWJlclxuXG4gICAgICAgICAgaWYgKCFpc0ludGVnZXIoZGltKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW50ZWdlciBudW1iZXIgZXhwZWN0ZWQgZm9yIGRpbWVuc2lvbicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChkaW0gPCAwIHx8IChpID4gMCAmJiBkaW0gPiBwcmV2RGltKSkge1xuICAgICAgICAgICAgLy8gVE9ETzogd291bGQgYmUgbW9yZSBjbGVhciB3aGVuIHRocm93aW5nIGEgRGltZW5zaW9uRXJyb3IgaGVyZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEluZGV4RXJyb3IoZGltLCBwcmV2RGltICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIHRoaXMgaXMgYSBtYXRyaXggb3IgYXJyYXlcbiAgICAgICAgICB2YXIgbSA9IGNsb25lKGFyZykudmFsdWVPZigpO1xuICAgICAgICAgIHZhciBzaXplID0gYXJyYXkuc2l6ZShtKTtcbiAgICAgICAgICBtYXRyaWNlc1tpXSA9IG07XG4gICAgICAgICAgcHJldkRpbSA9IGRpbTtcbiAgICAgICAgICBkaW0gPSBzaXplLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgICAvLyB2ZXJpZnkgd2hldGhlciBlYWNoIG9mIHRoZSBtYXRyaWNlcyBoYXMgdGhlIHNhbWUgbnVtYmVyIG9mIGRpbWVuc2lvbnNcbiAgICAgICAgICBpZiAoaSA+IDAgJiYgZGltICE9IHByZXZEaW0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBEaW1lbnNpb25FcnJvcihwcmV2RGltICsgMSwgZGltICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRyaWNlcy5sZW5ndGggPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0F0IGxlYXN0IG9uZSBtYXRyaXggZXhwZWN0ZWQnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlcyA9IG1hdHJpY2VzLnNoaWZ0KCk7XG4gICAgICB3aGlsZSAobWF0cmljZXMubGVuZ3RoKSB7XG4gICAgICAgIHJlcyA9IF9jb25jYXQocmVzLCBtYXRyaWNlcy5zaGlmdCgpLCBkaW0sIDApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXNNYXRyaXggPyBtYXRyaXgocmVzKSA6IHJlcztcbiAgICB9LFxuXG4gICAgJy4uLnN0cmluZyc6IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICByZXR1cm4gYXJncy5qb2luKCcnKTtcbiAgICB9XG4gIH0pO1xuXG4gIGNvbmNhdC50b1RleCA9ICdcXFxcbWF0aHJteyR7bmFtZX19XFxcXGxlZnQoJHthcmdzfVxcXFxyaWdodCknO1xuXG4gIHJldHVybiBjb25jYXQ7XG59XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgY29uY2F0ZW5hdGUgdHdvIG1hdHJpY2VzLlxuICogVGhlIGNvbnRlbnRzIG9mIHRoZSBtYXRyaWNlcyBpcyBub3QgY2xvbmVkLlxuICogQHBhcmFtIHtBcnJheX0gYSAgICAgICAgICAgICBNdWx0aSBkaW1lbnNpb25hbCBhcnJheVxuICogQHBhcmFtIHtBcnJheX0gYiAgICAgICAgICAgICBNdWx0aSBkaW1lbnNpb25hbCBhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IGNvbmNhdERpbSAgICBUaGUgZGltZW5zaW9uIG9uIHdoaWNoIHRvIGNvbmNhdGVuYXRlICh6ZXJvLWJhc2VkKVxuICogQHBhcmFtIHtudW1iZXJ9IGRpbSAgICAgICAgICBUaGUgY3VycmVudCBkaW0gKHplcm8tYmFzZWQpXG4gKiBAcmV0dXJuIHtBcnJheX0gYyAgICAgICAgICAgIFRoZSBjb25jYXRlbmF0ZWQgbWF0cml4XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfY29uY2F0KGEsIGIsIGNvbmNhdERpbSwgZGltKSB7XG4gIGlmIChkaW0gPCBjb25jYXREaW0pIHtcbiAgICAvLyByZWN1cnNlIGludG8gbmV4dCBkaW1lbnNpb25cbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBEaW1lbnNpb25FcnJvcihhLmxlbmd0aCwgYi5sZW5ndGgpO1xuICAgIH1cblxuICAgIHZhciBjID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjW2ldID0gX2NvbmNhdChhW2ldLCBiW2ldLCBjb25jYXREaW0sIGRpbSArIDEpO1xuICAgIH1cbiAgICByZXR1cm4gYztcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBjb25jYXRlbmF0ZSB0aGlzIGRpbWVuc2lvblxuICAgIHJldHVybiBhLmNvbmNhdChiKTtcbiAgfVxufVxuXG5leHBvcnRzLm5hbWUgPSAnY29uY2F0JztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzaXplID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYXJyYXknKS5zaXplO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBtYXRyaXggICA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvZnVuY3Rpb24vbWF0cml4JykpO1xuICB2YXIgc3VidHJhY3QgPSBsb2FkKHJlcXVpcmUoJy4uL2FyaXRobWV0aWMvc3VidHJhY3QnKSk7XG4gIHZhciBtdWx0aXBseSA9IGxvYWQocmVxdWlyZSgnLi4vYXJpdGhtZXRpYy9tdWx0aXBseScpKTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBjcm9zcyBwcm9kdWN0IGZvciB0d28gdmVjdG9ycyBpbiB0aHJlZSBkaW1lbnNpb25hbCBzcGFjZS5cbiAgICogVGhlIGNyb3NzIHByb2R1Y3Qgb2YgYEEgPSBbYTEsIGEyLCBhM11gIGFuZCBgQiA9W2IxLCBiMiwgYjNdYCBpcyBkZWZpbmVkXG4gICAqIGFzOlxuICAgKlxuICAgKiAgICBjcm9zcyhBLCBCKSA9IFtcbiAgICogICAgICBhMiAqIGIzIC0gYTMgKiBiMixcbiAgICogICAgICBhMyAqIGIxIC0gYTEgKiBiMyxcbiAgICogICAgICBhMSAqIGIyIC0gYTIgKiBiMVxuICAgKiAgICBdXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5jcm9zcyh4LCB5KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5jcm9zcyhbMSwgMSwgMF0sICBbMCwgMSwgMV0pOyAgLy8gUmV0dXJucyBbMSwgLTEsIDFdXG4gICAqICAgIG1hdGguY3Jvc3MoWzMsIC0zLCAxXSwgWzQsIDksIDJdKTsgIC8vIFJldHVybnMgWy0xNSwgLTIsIDM5XVxuICAgKiAgICBtYXRoLmNyb3NzKFsyLCAzLCA0XSwgIFs1LCA2LCA3XSk7ICAvLyBSZXR1cm5zIFstMywgNiwgLTNdXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBkb3QsIG11bHRpcGx5XG4gICAqXG4gICAqIEBwYXJhbSAge0FycmF5IHwgTWF0cml4fSB4ICAgRmlyc3QgdmVjdG9yXG4gICAqIEBwYXJhbSAge0FycmF5IHwgTWF0cml4fSB5ICAgU2Vjb25kIHZlY3RvclxuICAgKiBAcmV0dXJuIHtBcnJheSB8IE1hdHJpeH0gICAgIFJldHVybnMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgYHhgIGFuZCBgeWBcbiAgICovXG4gIHZhciBjcm9zcyA9IHR5cGVkKCdjcm9zcycsIHtcbiAgICAnTWF0cml4LCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIG1hdHJpeChfY3Jvc3MoeC50b0FycmF5KCksIHkudG9BcnJheSgpKSk7XG4gICAgfSxcblxuICAgICdNYXRyaXgsIEFycmF5JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHJldHVybiBtYXRyaXgoX2Nyb3NzKHgudG9BcnJheSgpLCB5KSk7XG4gICAgfSxcblxuICAgICdBcnJheSwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHJldHVybiBtYXRyaXgoX2Nyb3NzKHgsIHkudG9BcnJheSgpKSk7XG4gICAgfSxcblxuICAgICdBcnJheSwgQXJyYXknOiBfY3Jvc3NcbiAgfSk7XG5cbiAgY3Jvc3MudG9UZXggPSAnXFxcXGxlZnQoJHthcmdzWzBdfVxcXFxyaWdodClcXFxcdGltZXNcXFxcbGVmdCgke2FyZ3NbMV19XFxcXHJpZ2h0KSc7XG5cbiAgcmV0dXJuIGNyb3NzO1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGNyb3NzIHByb2R1Y3QgZm9yIHR3byBhcnJheXNcbiAgICogQHBhcmFtIHtBcnJheX0geCAgRmlyc3QgdmVjdG9yXG4gICAqIEBwYXJhbSB7QXJyYXl9IHkgIFNlY29uZCB2ZWN0b3JcbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHggYW5kIHlcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9jcm9zcyh4LCB5KSB7XG4gICAgdmFyIHhTaXplPSBzaXplKHgpO1xuICAgIHZhciB5U2l6ZSA9IHNpemUoeSk7XG5cbiAgICBpZiAoeFNpemUubGVuZ3RoICE9IDEgfHwgeVNpemUubGVuZ3RoICE9IDEgfHwgeFNpemVbMF0gIT0gMyB8fCB5U2l6ZVswXSAhPSAzKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVmVjdG9ycyB3aXRoIGxlbmd0aCAzIGV4cGVjdGVkICcgK1xuICAgICAgJyhTaXplIEEgPSBbJyArIHhTaXplLmpvaW4oJywgJykgKyAnXSwgQiA9IFsnICsgeVNpemUuam9pbignLCAnKSArICddKScpO1xuICAgIH1cblxuICAgIHJldHVybiBbXG4gICAgICBzdWJ0cmFjdChtdWx0aXBseSh4WzFdLCB5WzJdKSwgbXVsdGlwbHkoeFsyXSwgeVsxXSkpLFxuICAgICAgc3VidHJhY3QobXVsdGlwbHkoeFsyXSwgeVswXSksIG11bHRpcGx5KHhbMF0sIHlbMl0pKSxcbiAgICAgIHN1YnRyYWN0KG11bHRpcGx5KHhbMF0sIHlbMV0pLCBtdWx0aXBseSh4WzFdLCB5WzBdKSlcbiAgICBdO1xuICB9XG59XG5cbmV4cG9ydHMubmFtZSA9ICdjcm9zcyc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2luZGV4Jyk7XG52YXIgb2JqZWN0ID0gdXRpbC5vYmplY3Q7XG52YXIgc3RyaW5nID0gdXRpbC5zdHJpbmc7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIG1hdHJpeCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvZnVuY3Rpb24vbWF0cml4JykpO1xuICB2YXIgYWRkID0gbG9hZChyZXF1aXJlKCcuLi9hcml0aG1ldGljL2FkZCcpKTtcbiAgdmFyIHN1YnRyYWN0ID0gbG9hZChyZXF1aXJlKCcuLi9hcml0aG1ldGljL3N1YnRyYWN0JykpO1xuICB2YXIgbXVsdGlwbHkgPSBsb2FkKHJlcXVpcmUoJy4uL2FyaXRobWV0aWMvbXVsdGlwbHknKSk7XG4gIHZhciB1bmFyeU1pbnVzID0gbG9hZChyZXF1aXJlKCcuLi9hcml0aG1ldGljL3VuYXJ5TWludXMnKSk7XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXRyaXguXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5kZXQoeClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGguZGV0KFtbMSwgMl0sIFszLCA0XV0pOyAvLyByZXR1cm5zIC0yXG4gICAqXG4gICAqICAgIHZhciBBID0gW1xuICAgKiAgICAgIFstMiwgMiwgM10sXG4gICAqICAgICAgWy0xLCAxLCAzXSxcbiAgICogICAgICBbMiwgMCwgLTFdXG4gICAqICAgIF1cbiAgICogICAgbWF0aC5kZXQoQSk7IC8vIHJldHVybnMgNlxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgaW52XG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXkgfCBNYXRyaXh9IHggIEEgbWF0cml4XG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGRldGVybWluYW50IG9mIGB4YFxuICAgKi9cbiAgdmFyIGRldCA9IHR5cGVkKCdkZXQnLCB7XG4gICAgJ2FueSc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gb2JqZWN0LmNsb25lKHgpO1xuICAgIH0sXG5cbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiBkZXQgKHgpIHtcbiAgICAgIHZhciBzaXplO1xuICAgICAgaWYgKHggJiYgeC5pc01hdHJpeCA9PT0gdHJ1ZSkge1xuICAgICAgICBzaXplID0geC5zaXplKCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHgpKSB7XG4gICAgICAgIHggPSBtYXRyaXgoeCk7XG4gICAgICAgIHNpemUgPSB4LnNpemUoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBhIHNjYWxhclxuICAgICAgICBzaXplID0gW107XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoc2l6ZS5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIC8vIHNjYWxhclxuICAgICAgICAgIHJldHVybiBvYmplY3QuY2xvbmUoeCk7XG5cbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIC8vIHZlY3RvclxuICAgICAgICAgIGlmIChzaXplWzBdID09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3QuY2xvbmUoeC52YWx1ZU9mKClbMF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdNYXRyaXggbXVzdCBiZSBzcXVhcmUgJyArXG4gICAgICAgICAgICAnKHNpemU6ICcgKyBzdHJpbmcuZm9ybWF0KHNpemUpICsgJyknKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIC8vIHR3byBkaW1lbnNpb25hbCBhcnJheVxuICAgICAgICAgIHZhciByb3dzID0gc2l6ZVswXTtcbiAgICAgICAgICB2YXIgY29scyA9IHNpemVbMV07XG4gICAgICAgICAgaWYgKHJvd3MgPT0gY29scykge1xuICAgICAgICAgICAgcmV0dXJuIF9kZXQoeC5jbG9uZSgpLnZhbHVlT2YoKSwgcm93cywgY29scyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ01hdHJpeCBtdXN0IGJlIHNxdWFyZSAnICtcbiAgICAgICAgICAgICcoc2l6ZTogJyArIHN0cmluZy5mb3JtYXQoc2l6ZSkgKyAnKScpO1xuICAgICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIG11bHRpIGRpbWVuc2lvbmFsIGFycmF5XG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ01hdHJpeCBtdXN0IGJlIHR3byBkaW1lbnNpb25hbCAnICtcbiAgICAgICAgICAnKHNpemU6ICcgKyBzdHJpbmcuZm9ybWF0KHNpemUpICsgJyknKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGRldC50b1RleCA9ICdcXFxcZGV0XFxcXGxlZnQoJHthcmdzWzBdfVxcXFxyaWdodCknO1xuXG4gIHJldHVybiBkZXQ7XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXRyaXhcbiAgICogQHBhcmFtIHtBcnJheVtdfSBtYXRyaXggIEEgc3F1YXJlLCB0d28gZGltZW5zaW9uYWwgbWF0cml4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSByb3dzICAgICBOdW1iZXIgb2Ygcm93cyBvZiB0aGUgbWF0cml4ICh6ZXJvLWJhc2VkKVxuICAgKiBAcGFyYW0ge251bWJlcn0gY29scyAgICAgTnVtYmVyIG9mIGNvbHVtbnMgb2YgdGhlIG1hdHJpeCAoemVyby1iYXNlZClcbiAgICogQHJldHVybnMge251bWJlcn0gZGV0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfZGV0IChtYXRyaXgsIHJvd3MsIGNvbHMpIHtcbiAgICBpZiAocm93cyA9PSAxKSB7XG4gICAgICAvLyB0aGlzIGlzIGEgMSB4IDEgbWF0cml4XG4gICAgICByZXR1cm4gb2JqZWN0LmNsb25lKG1hdHJpeFswXVswXSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJvd3MgPT0gMikge1xuICAgICAgLy8gdGhpcyBpcyBhIDIgeCAyIG1hdHJpeFxuICAgICAgLy8gdGhlIGRldGVybWluYW50IG9mIFthMTEsYTEyO2EyMSxhMjJdIGlzIGRldCA9IGExMSphMjItYTIxKmExMlxuICAgICAgcmV0dXJuIHN1YnRyYWN0KFxuICAgICAgICAgIG11bHRpcGx5KG1hdHJpeFswXVswXSwgbWF0cml4WzFdWzFdKSxcbiAgICAgICAgICBtdWx0aXBseShtYXRyaXhbMV1bMF0sIG1hdHJpeFswXVsxXSlcbiAgICAgICk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gdGhpcyBpcyBhbiBuIHggbiBtYXRyaXhcbiAgICAgIHZhciBjb21wdXRlX211ID0gZnVuY3Rpb24gKG1hdHJpeCkge1xuICAgICAgICB2YXIgaSwgajtcblxuICAgICAgICAvLyBDb21wdXRlIHRoZSBtYXRyaXggd2l0aCB6ZXJvIGxvd2VyIHRyaWFuZ2xlLCBzYW1lIHVwcGVyIHRyaWFuZ2xlLFxuICAgICAgICAvLyBhbmQgZGlhZ29uYWxzIGdpdmVuIGJ5IHRoZSBuZWdhdGVkIHN1bSBvZiB0aGUgYmVsb3cgZGlhZ29uYWxcbiAgICAgICAgLy8gZWxlbWVudHMuXG4gICAgICAgIHZhciBtdSA9IG5ldyBBcnJheShtYXRyaXgubGVuZ3RoKTtcbiAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBtYXRyaXgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzdW0gPSBhZGQoc3VtLCBtYXRyaXhbaV1baV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG1hdHJpeC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG11W2ldID0gbmV3IEFycmF5KG1hdHJpeC5sZW5ndGgpO1xuICAgICAgICAgIG11W2ldW2ldID0gdW5hcnlNaW51cyhzdW0pO1xuXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGk7IGorKykge1xuICAgICAgICAgICAgbXVbaV1bal0gPSAwOyAvLyBUT0RPOiBtYWtlIGJpZ251bWJlciAwIGluIGNhc2Ugb2YgYmlnbnVtYmVyIGNvbXB1dGF0aW9uXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCBtYXRyaXgubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIG11W2ldW2pdID0gbWF0cml4W2ldW2pdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpKzEgPCBtYXRyaXgubGVuZ3RoKSB7XG4gICAgICAgICAgICBzdW0gPSBzdWJ0cmFjdChzdW0sIG1hdHJpeFtpICsgMV1baSArIDFdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbXU7XG4gICAgICB9O1xuXG4gICAgICB2YXIgZmEgPSBtYXRyaXg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd3MgLSAxOyBpKyspIHtcbiAgICAgICAgZmEgPSBtdWx0aXBseShjb21wdXRlX211KGZhKSwgbWF0cml4KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJvd3MgJSAyID09IDApIHtcbiAgICAgICAgcmV0dXJuIHVuYXJ5TWludXMoZmFbMF1bMF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhWzBdWzBdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnRzLm5hbWUgPSAnZGV0JztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG5cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFycmF5ICAgICA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2FycmF5Jyk7XG52YXIgY2xvbmUgICAgID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0JykuY2xvbmU7XG52YXIgaXNJbnRlZ2VyID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbnVtYmVyJykuaXNJbnRlZ2VyO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG5cbiAgdmFyIG1hdHJpeCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvZnVuY3Rpb24vbWF0cml4JykpO1xuICBcbiAgLyoqXG4gICAqIENyZWF0ZSBhIGRpYWdvbmFsIG1hdHJpeCBvciByZXRyaWV2ZSB0aGUgZGlhZ29uYWwgb2YgYSBtYXRyaXhcbiAgICpcbiAgICogV2hlbiBgeGAgaXMgYSB2ZWN0b3IsIGEgbWF0cml4IHdpdGggdmVjdG9yIGB4YCBvbiB0aGUgZGlhZ29uYWwgd2lsbCBiZSByZXR1cm5lZC5cbiAgICogV2hlbiBgeGAgaXMgYSB0d28gZGltZW5zaW9uYWwgbWF0cml4LCB0aGUgbWF0cml4ZXMgYGtgdGggZGlhZ29uYWwgd2lsbCBiZSByZXR1cm5lZCBhcyB2ZWN0b3IuXG4gICAqIFdoZW4gayBpcyBwb3NpdGl2ZSwgdGhlIHZhbHVlcyBhcmUgcGxhY2VkIG9uIHRoZSBzdXBlciBkaWFnb25hbC5cbiAgICogV2hlbiBrIGlzIG5lZ2F0aXZlLCB0aGUgdmFsdWVzIGFyZSBwbGFjZWQgb24gdGhlIHN1YiBkaWFnb25hbC5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICAgbWF0aC5kaWFnKFgpXG4gICAqICAgICBtYXRoLmRpYWcoWCwgZm9ybWF0KVxuICAgKiAgICAgbWF0aC5kaWFnKFgsIGspXG4gICAqICAgICBtYXRoLmRpYWcoWCwgaywgZm9ybWF0KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgIC8vIGNyZWF0ZSBhIGRpYWdvbmFsIG1hdHJpeFxuICAgKiAgICAgbWF0aC5kaWFnKFsxLCAyLCAzXSk7ICAgICAgLy8gcmV0dXJucyBbWzEsIDAsIDBdLCBbMCwgMiwgMF0sIFswLCAwLCAzXV1cbiAgICogICAgIG1hdGguZGlhZyhbMSwgMiwgM10sIDEpOyAgIC8vIHJldHVybnMgW1swLCAxLCAwLCAwXSwgWzAsIDAsIDIsIDBdLCBbMCwgMCwgMCwgM11dXG4gICAqICAgICBtYXRoLmRpYWcoWzEsIDIsIDNdLCAtMSk7ICAvLyByZXR1cm5zIFtbMCwgMCwgMF0sIFsxLCAwLCAwXSwgWzAsIDIsIDBdLCBbMCwgMCwgM11dXG4gICAqXG4gICAqICAgIC8vIHJldHJpZXZlIHRoZSBkaWFnb25hbCBmcm9tIGEgbWF0cml4XG4gICAqICAgIHZhciBhID0gW1sxLCAyLCAzXSwgWzQsIDUsIDZdLCBbNywgOCwgOV1dO1xuICAgKiAgICBtYXRoLmRpYWcoYSk7ICAgLy8gcmV0dXJucyBbMSwgNSwgOV1cbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgICBvbmVzLCB6ZXJvcywgZXllXG4gICAqXG4gICAqIEBwYXJhbSB7TWF0cml4IHwgQXJyYXl9IHggICAgICAgICAgQSB0d28gZGltZW5zaW9uYWwgbWF0cml4IG9yIGEgdmVjdG9yXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgQmlnTnVtYmVyfSBbaz0wXSAgVGhlIGRpYWdvbmFsIHdoZXJlIHRoZSB2ZWN0b3Igd2lsbCBiZSBmaWxsZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiBvciByZXRyaWV2ZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZm9ybWF0PSdkZW5zZSddICAgVGhlIG1hdHJpeCBzdG9yYWdlIGZvcm1hdC5cbiAgICpcbiAgICogQHJldHVybnMge01hdHJpeCB8IEFycmF5fSBEaWFnb25hbCBtYXRyaXggZnJvbSBpbnB1dCB2ZWN0b3IsIG9yIGRpYWdvbmFsIGZyb20gaW5wdXQgbWF0cml4LlxuICAgKi9cbiAgdmFyIGRpYWcgPSB0eXBlZCgnZGlhZycsIHtcbiAgICAvLyBGSVhNRTogc2ltcGxpZnkgdGhpcyBodWdlIGFtb3VudCBvZiBzaWduYXR1cmVzIGFzIHNvb24gYXMgdHlwZWQtZnVuY3Rpb24gc3VwcG9ydHMgb3B0aW9uYWwgYXJndW1lbnRzXG5cbiAgICAnQXJyYXknOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIF9kaWFnKHgsIDAsIGFycmF5LnNpemUoeCksIG51bGwpO1xuICAgIH0sXG5cbiAgICAnQXJyYXksIG51bWJlcic6IGZ1bmN0aW9uICh4LCBrKSB7XG4gICAgICByZXR1cm4gX2RpYWcoeCwgaywgYXJyYXkuc2l6ZSh4KSwgbnVsbCk7XG4gICAgfSxcbiAgICBcbiAgICAnQXJyYXksIEJpZ051bWJlcic6IGZ1bmN0aW9uICh4LCBrKSB7XG4gICAgICByZXR1cm4gX2RpYWcoeCwgay50b051bWJlcigpLCBhcnJheS5zaXplKHgpLCBudWxsKTtcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBzdHJpbmcnOiBmdW5jdGlvbiAoeCwgZm9ybWF0KSB7XG4gICAgICByZXR1cm4gX2RpYWcoeCwgMCwgYXJyYXkuc2l6ZSh4KSwgZm9ybWF0KTtcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBudW1iZXIsIHN0cmluZyc6IGZ1bmN0aW9uICh4LCBrLCBmb3JtYXQpIHtcbiAgICAgIHJldHVybiBfZGlhZyh4LCBrLCBhcnJheS5zaXplKHgpLCBmb3JtYXQpO1xuICAgIH0sXG5cbiAgICAnQXJyYXksIEJpZ051bWJlciwgc3RyaW5nJzogZnVuY3Rpb24gKHgsIGssIGZvcm1hdCkge1xuICAgICAgcmV0dXJuIF9kaWFnKHgsIGsudG9OdW1iZXIoKSwgYXJyYXkuc2l6ZSh4KSwgZm9ybWF0KTtcbiAgICB9LFxuXG4gICAgJ01hdHJpeCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gX2RpYWcoeCwgMCwgeC5zaXplKCksIHguc3RvcmFnZSgpKTtcbiAgICB9LFxuXG4gICAgJ01hdHJpeCwgbnVtYmVyJzogZnVuY3Rpb24gKHgsIGspIHtcbiAgICAgIHJldHVybiBfZGlhZyh4LCBrLCB4LnNpemUoKSwgeC5zdG9yYWdlKCkpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4LCBCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCwgaykge1xuICAgICAgcmV0dXJuIF9kaWFnKHgsIGsudG9OdW1iZXIoKSwgeC5zaXplKCksIHguc3RvcmFnZSgpKTtcbiAgICB9LFxuXG4gICAgJ01hdHJpeCwgc3RyaW5nJzogZnVuY3Rpb24gKHgsIGZvcm1hdCkge1xuICAgICAgcmV0dXJuIF9kaWFnKHgsIDAsIHguc2l6ZSgpLCBmb3JtYXQpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4LCBudW1iZXIsIHN0cmluZyc6IGZ1bmN0aW9uICh4LCBrLCBmb3JtYXQpIHtcbiAgICAgIHJldHVybiBfZGlhZyh4LCBrLCB4LnNpemUoKSwgZm9ybWF0KTtcbiAgICB9LFxuXG4gICAgJ01hdHJpeCwgQmlnTnVtYmVyLCBzdHJpbmcnOiBmdW5jdGlvbiAoeCwgaywgZm9ybWF0KSB7XG4gICAgICByZXR1cm4gX2RpYWcoeCwgay50b051bWJlcigpLCB4LnNpemUoKSwgZm9ybWF0KTtcbiAgICB9XG4gIH0pO1xuXG4gIGRpYWcudG9UZXggPSAnXFxcXG1hdGhybXske25hbWV9fVxcXFxsZWZ0KCR7YXJnc31cXFxccmlnaHQpJztcblxuICByZXR1cm4gZGlhZztcblxuICAvKipcbiAgICogQ3JlZWF0ZSBkaWFnb25hbCBtYXRyaXggZnJvbSBhIHZlY3RvciBvciB2aWNlIHZlcnNhXG4gICAqIEBwYXJhbSB7QXJyYXkgfCBNYXRyaXh9IHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdCBTdG9yYWdlIGZvcm1hdCBmb3IgbWF0cml4LiBJZiBudWxsLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgYW4gQXJyYXkgaXMgcmV0dXJuZWRcbiAgICogQHJldHVybnMge0FycmF5IHwgTWF0cml4fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX2RpYWcgKHgsIGssIHNpemUsIGZvcm1hdCkge1xuICAgIGlmICghaXNJbnRlZ2VyKGspKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yICgnU2Vjb25kIHBhcmFtZXRlciBpbiBmdW5jdGlvbiBkaWFnIG11c3QgYmUgYW4gaW50ZWdlcicpO1xuICAgIH1cbiAgICBcbiAgICB2YXIga1N1cGVyID0gayA+IDAgPyBrIDogMDtcbiAgICB2YXIga1N1YiA9IGsgPCAwID8gLWsgOiAwO1xuXG4gICAgLy8gY2hlY2sgZGltZW5zaW9uc1xuICAgIHN3aXRjaCAoc2l6ZS5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVEaWFnb25hbE1hdHJpeCh4LCBrLCBmb3JtYXQsIHNpemVbMF0sIGtTdWIsIGtTdXBlcik7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiBfZ2V0RGlhZ29uYWwoeCwgaywgZm9ybWF0LCBzaXplLCBrU3ViLCBrU3VwZXIpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignTWF0cml4IGZvciBmdW5jdGlvbiBkaWFnIG11c3QgYmUgMiBkaW1lbnNpb25hbCcpO1xuICB9XG4gIFxuICBmdW5jdGlvbiBfY3JlYXRlRGlhZ29uYWxNYXRyaXgoeCwgaywgZm9ybWF0LCBsLCBrU3ViLCBrU3VwZXIpIHtcbiAgICAvLyBtYXRyaXggc2l6ZVxuICAgIHZhciBtcyA9IFtsICsga1N1YiwgbCArIGtTdXBlcl07XG4gICAgLy8gZ2V0IG1hdHJpeCBjb25zdHJ1Y3RvclxuICAgIHZhciBGID0gdHlwZS5NYXRyaXguc3RvcmFnZShmb3JtYXQgfHwgJ2RlbnNlJyk7XG4gICAgLy8gY3JlYXRlIGRpYWdvbmFsIG1hdHJpeFxuICAgIHZhciBtID0gRi5kaWFnb25hbChtcywgeCwgayk7XG4gICAgLy8gY2hlY2sgd2UgbmVlZCB0byByZXR1cm4gYSBtYXRyaXhcbiAgICByZXR1cm4gZm9ybWF0ICE9PSBudWxsID8gbSA6IG0udmFsdWVPZigpO1xuICB9XG4gIFxuICBmdW5jdGlvbiBfZ2V0RGlhZ29uYWwoeCwgaywgZm9ybWF0LCBzLCBrU3ViLCBrU3VwZXIpIHtcbiAgICAvLyBjaGVjayB4IGlzIGEgTWF0cml4XG4gICAgaWYgKHggJiYgeC5pc01hdHJpeCA9PT0gdHJ1ZSkge1xuICAgICAgLy8gZ2V0IGRpYWdvbmFsIG1hdHJpeFxuICAgICAgdmFyIGRtID0geC5kaWFnb25hbChrKTtcbiAgICAgIC8vIGNoZWNrIHdlIG5lZWQgdG8gcmV0dXJuIGEgbWF0cml4XG4gICAgICBpZiAoZm9ybWF0ICE9PSBudWxsKSB7XG4gICAgICAgIC8vIGNoZWNrIHdlIG5lZWQgdG8gY2hhbmdlIG1hdHJpeCBmb3JtYXRcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gZG0uc3RvcmFnZSgpKVxuICAgICAgICAgIHJldHVybiBtYXRyaXgoZG0sIGZvcm1hdCk7XG4gICAgICAgIHJldHVybiBkbTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkbS52YWx1ZU9mKCk7XG4gICAgfVxuICAgIC8vIHZlY3RvciBzaXplXG4gICAgdmFyIG4gPSBNYXRoLm1pbihzWzBdIC0ga1N1Yiwgc1sxXSAtIGtTdXBlcik7XG4gICAgLy8gZGlhZ29uYWwgdmFsdWVzXG4gICAgdmFyIHZlY3RvciA9IFtdO1xuICAgIC8vIGxvb3AgZGlhZ29uYWxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgdmVjdG9yW2ldID0geFtpICsga1N1Yl1baSArIGtTdXBlcl07XG4gICAgfVxuICAgIC8vIGNoZWNrIHdlIG5lZWQgdG8gcmV0dXJuIGEgbWF0cml4XG4gICAgcmV0dXJuIGZvcm1hdCAhPT0gbnVsbCA/IG1hdHJpeCh2ZWN0b3IpIDogdmVjdG9yO1xuICB9XG59XG5cbmV4cG9ydHMubmFtZSA9ICdkaWFnJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzaXplID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYXJyYXknKS5zaXplO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBhZGQgICAgICA9IGxvYWQocmVxdWlyZSgnLi4vYXJpdGhtZXRpYy9hZGQnKSk7XG4gIHZhciBtdWx0aXBseSA9IGxvYWQocmVxdWlyZSgnLi4vYXJpdGhtZXRpYy9tdWx0aXBseScpKTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjdG9ycy4gVGhlIGRvdCBwcm9kdWN0IG9mXG4gICAqIGBBID0gW2ExLCBhMiwgYTMsIC4uLiwgYW5dYCBhbmQgYEIgPSBbYjEsIGIyLCBiMywgLi4uLCBibl1gIGlzIGRlZmluZWQgYXM6XG4gICAqXG4gICAqICAgIGRvdChBLCBCKSA9IGExICogYjEgKyBhMiAqIGIyICsgYTMgKiBiMyArIC4uLiArIGFuICogYm5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmRvdCh4LCB5KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5kb3QoWzIsIDQsIDFdLCBbMiwgMiwgM10pOyAgICAgICAvLyByZXR1cm5zIG51bWJlciAxNVxuICAgKiAgICBtYXRoLm11bHRpcGx5KFsyLCA0LCAxXSwgWzIsIDIsIDNdKTsgIC8vIHJldHVybnMgbnVtYmVyIDE1XG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBtdWx0aXBseSwgY3Jvc3NcbiAgICpcbiAgICogQHBhcmFtICB7QXJyYXkgfCBNYXRyaXh9IHggICAgIEZpcnN0IHZlY3RvclxuICAgKiBAcGFyYW0gIHtBcnJheSB8IE1hdHJpeH0geSAgICAgU2Vjb25kIHZlY3RvclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgICAgICAgICAgUmV0dXJucyB0aGUgZG90IHByb2R1Y3Qgb2YgYHhgIGFuZCBgeWBcbiAgICovXG4gIHZhciBkb3QgPSB0eXBlZCgnZG90Jywge1xuICAgICdNYXRyaXgsIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4gX2RvdCh4LnRvQXJyYXkoKSwgeS50b0FycmF5KCkpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4LCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4gX2RvdCh4LnRvQXJyYXkoKSwgeSk7XG4gICAgfSxcblxuICAgICdBcnJheSwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHJldHVybiBfZG90KHgsIHkudG9BcnJheSgpKTtcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBBcnJheSc6IF9kb3RcbiAgfSk7XG4gIFxuICBkb3QudG9UZXggPSAnXFxcXGxlZnQoJHthcmdzWzBdfVxcXFxjZG90JHthcmdzWzFdfVxcXFxyaWdodCknO1xuXG4gIHJldHVybiBkb3Q7XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgZG90IHByb2R1Y3QgZm9yIHR3byBhcnJheXNcbiAgICogQHBhcmFtIHtBcnJheX0geCAgRmlyc3QgdmVjdG9yXG4gICAqIEBwYXJhbSB7QXJyYXl9IHkgIFNlY29uZCB2ZWN0b3JcbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgZG90IHByb2R1Y3Qgb2YgeCBhbmQgeVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgLy8gVE9ETzogZG91YmxlIGNvZGUgd2l0aCBtYXRoLm11bHRpcGx5XG4gIGZ1bmN0aW9uIF9kb3QoeCwgeSkge1xuICAgIHZhciB4U2l6ZT0gc2l6ZSh4KTtcbiAgICB2YXIgeVNpemUgPSBzaXplKHkpO1xuICAgIHZhciBsZW4gPSB4U2l6ZVswXTtcblxuICAgIGlmICh4U2l6ZS5sZW5ndGggIT09IDEgfHwgeVNpemUubGVuZ3RoICE9PSAxKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVmVjdG9yIGV4cGVjdGVkJyk7IC8vIFRPRE86IGJldHRlciBlcnJvciBtZXNzYWdlXG4gICAgaWYgKHhTaXplWzBdICE9IHlTaXplWzBdKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVmVjdG9ycyBtdXN0IGhhdmUgZXF1YWwgbGVuZ3RoICgnICsgeFNpemVbMF0gKyAnICE9ICcgKyB5U2l6ZVswXSArICcpJyk7XG4gICAgaWYgKGxlbiA9PSAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQ2Fubm90IGNhbGN1bGF0ZSB0aGUgZG90IHByb2R1Y3Qgb2YgZW1wdHkgdmVjdG9ycycpO1xuXG4gICAgdmFyIHByb2QgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHByb2QgPSBhZGQocHJvZCwgbXVsdGlwbHkoeFtpXSwgeVtpXSkpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9kO1xuICB9XG59XG5cbmV4cG9ydHMubmFtZSA9ICdkb3QnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFycmF5ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYXJyYXknKTtcbnZhciBpc0ludGVnZXIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9udW1iZXInKS5pc0ludGVnZXI7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgXG4gIHZhciBtYXRyaXggPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L2Z1bmN0aW9uL21hdHJpeCcpKTtcbiAgXG4gIC8qKlxuICAgKiBDcmVhdGUgYSAyLWRpbWVuc2lvbmFsIGlkZW50aXR5IG1hdHJpeCB3aXRoIHNpemUgbSB4IG4gb3IgbiB4IG4uXG4gICAqIFRoZSBtYXRyaXggaGFzIG9uZXMgb24gdGhlIGRpYWdvbmFsIGFuZCB6ZXJvcyBlbHNld2hlcmUuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5leWUobilcbiAgICogICAgbWF0aC5leWUobiwgZm9ybWF0KVxuICAgKiAgICBtYXRoLmV5ZShtLCBuKVxuICAgKiAgICBtYXRoLmV5ZShtLCBuLCBmb3JtYXQpXG4gICAqICAgIG1hdGguZXllKFttLCBuXSlcbiAgICogICAgbWF0aC5leWUoW20sIG5dLCBmb3JtYXQpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmV5ZSgzKTsgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgW1sxLCAwLCAwXSwgWzAsIDEsIDBdLCBbMCwgMCwgMV1dXG4gICAqICAgIG1hdGguZXllKDMsIDIpOyAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBbWzEsIDBdLCBbMCwgMV0sIFswLCAwXV1cbiAgICpcbiAgICogICAgdmFyIEEgPSBbWzEsIDIsIDNdLCBbNCwgNSwgNl1dO1xuICAgKiAgICBtYXRoLmV5ZShtYXRoLnNpemUoQSkpOyAgICAgICAgIC8vIHJldHVybnMgW1sxLCAwLCAwXSwgWzAsIDEsIDBdXVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgZGlhZywgb25lcywgemVyb3MsIHNpemUsIHJhbmdlXG4gICAqXG4gICAqIEBwYXJhbSB7Li4ubnVtYmVyIHwgTWF0cml4IHwgQXJyYXl9IHNpemUgICBUaGUgc2l6ZSBmb3IgdGhlIG1hdHJpeFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2Zvcm1hdF0gICAgICAgICAgICAgICAgICAgVGhlIE1hdHJpeCBzdG9yYWdlIGZvcm1hdFxuICAgKlxuICAgKiBAcmV0dXJuIHtNYXRyaXggfCBBcnJheSB8IG51bWJlcn0gQSBtYXRyaXggd2l0aCBvbmVzIG9uIHRoZSBkaWFnb25hbC5cbiAgICovXG4gIHZhciBleWUgPSB0eXBlZCgnZXllJywge1xuICAgICcnOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKGNvbmZpZy5tYXRyaXggPT09ICdNYXRyaXgnKSA/IG1hdHJpeChbXSkgOiBbXTtcbiAgICB9LFxuXG4gICAgJ3N0cmluZyc6IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgIHJldHVybiBtYXRyaXgoZm9ybWF0KTtcbiAgICB9LFxuXG4gICAgJ251bWJlciB8IEJpZ051bWJlcic6IGZ1bmN0aW9uIChyb3dzKSB7XG4gICAgICByZXR1cm4gX2V5ZShyb3dzLCByb3dzLCBjb25maWcubWF0cml4ID09PSAnTWF0cml4JyA/ICdkZWZhdWx0JyA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBcbiAgICAnbnVtYmVyIHwgQmlnTnVtYmVyLCBzdHJpbmcnOiBmdW5jdGlvbiAocm93cywgZm9ybWF0KSB7XG4gICAgICByZXR1cm4gX2V5ZShyb3dzLCByb3dzLCBmb3JtYXQpO1xuICAgIH0sXG5cbiAgICAnbnVtYmVyIHwgQmlnTnVtYmVyLCBudW1iZXIgfCBCaWdOdW1iZXInOiBmdW5jdGlvbiAocm93cywgY29scykge1xuICAgICAgcmV0dXJuIF9leWUocm93cywgY29scywgY29uZmlnLm1hdHJpeCA9PT0gJ01hdHJpeCcgPyAnZGVmYXVsdCcgOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgXG4gICAgJ251bWJlciB8IEJpZ051bWJlciwgbnVtYmVyIHwgQmlnTnVtYmVyLCBzdHJpbmcnOiBmdW5jdGlvbiAocm93cywgY29scywgZm9ybWF0KSB7XG4gICAgICByZXR1cm4gX2V5ZShyb3dzLCBjb2xzLCBmb3JtYXQpO1xuICAgIH0sXG5cbiAgICAnQXJyYXknOiAgZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgIHJldHVybiBfZXllVmVjdG9yKHNpemUpO1xuICAgIH0sXG4gICAgXG4gICAgJ0FycmF5LCBzdHJpbmcnOiAgZnVuY3Rpb24gKHNpemUsIGZvcm1hdCkge1xuICAgICAgcmV0dXJuIF9leWVWZWN0b3Ioc2l6ZSwgZm9ybWF0KTtcbiAgICB9LFxuXG4gICAgJ01hdHJpeCc6IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICByZXR1cm4gX2V5ZVZlY3RvcihzaXplLnZhbHVlT2YoKSwgc2l6ZS5zdG9yYWdlKCkpO1xuICAgIH0sXG4gICAgXG4gICAgJ01hdHJpeCwgc3RyaW5nJzogZnVuY3Rpb24gKHNpemUsIGZvcm1hdCkge1xuICAgICAgcmV0dXJuIF9leWVWZWN0b3Ioc2l6ZS52YWx1ZU9mKCksIGZvcm1hdCk7XG4gICAgfVxuICB9KTtcblxuICBleWUudG9UZXggPSAnXFxcXG1hdGhybXske25hbWV9fVxcXFxsZWZ0KCR7YXJnc31cXFxccmlnaHQpJztcblxuICByZXR1cm4gZXllO1xuXG4gIGZ1bmN0aW9uIF9leWVWZWN0b3IgKHNpemUsIGZvcm1hdCkge1xuICAgIHN3aXRjaCAoc2l6ZS5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDogcmV0dXJuIGZvcm1hdCA/IG1hdHJpeChmb3JtYXQpIDogW107XG4gICAgICBjYXNlIDE6IHJldHVybiBfZXllKHNpemVbMF0sIHNpemVbMF0sIGZvcm1hdCk7XG4gICAgICBjYXNlIDI6IHJldHVybiBfZXllKHNpemVbMF0sIHNpemVbMV0sIGZvcm1hdCk7XG4gICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ1ZlY3RvciBjb250YWluaW5nIHR3byB2YWx1ZXMgZXhwZWN0ZWQnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGlkZW50aXR5IG1hdHJpeFxuICAgKiBAcGFyYW0ge251bWJlciB8IEJpZ051bWJlcn0gcm93c1xuICAgKiBAcGFyYW0ge251bWJlciB8IEJpZ051bWJlcn0gY29sc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW2Zvcm1hdF1cbiAgICogQHJldHVybnMge01hdHJpeH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9leWUgKHJvd3MsIGNvbHMsIGZvcm1hdCkge1xuICAgIC8vIEJpZ051bWJlciBjb25zdHJ1Y3RvciB3aXRoIHRoZSByaWdodCBwcmVjaXNpb25cbiAgICB2YXIgQmlnID0gKHJvd3MgJiYgcm93cy5pc0JpZ051bWJlciA9PT0gdHJ1ZSlcbiAgICAgICAgPyB0eXBlLkJpZ051bWJlclxuICAgICAgICA6IChjb2xzICYmIGNvbHMuaXNCaWdOdW1iZXIgPT09IHRydWUpXG4gICAgICAgICAgICA/IHR5cGUuQmlnTnVtYmVyXG4gICAgICAgICAgICA6IG51bGw7XG5cbiAgICBpZiAocm93cyAmJiByb3dzLmlzQmlnTnVtYmVyID09PSB0cnVlKSByb3dzID0gcm93cy50b051bWJlcigpO1xuICAgIGlmIChjb2xzICYmIGNvbHMuaXNCaWdOdW1iZXIgPT09IHRydWUpIGNvbHMgPSBjb2xzLnRvTnVtYmVyKCk7XG5cbiAgICBpZiAoIWlzSW50ZWdlcihyb3dzKSB8fCByb3dzIDwgMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJhbWV0ZXJzIGluIGZ1bmN0aW9uIGV5ZSBtdXN0IGJlIHBvc2l0aXZlIGludGVnZXJzJyk7XG4gICAgfVxuICAgIGlmICghaXNJbnRlZ2VyKGNvbHMpIHx8IGNvbHMgPCAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcmFtZXRlcnMgaW4gZnVuY3Rpb24gZXllIG11c3QgYmUgcG9zaXRpdmUgaW50ZWdlcnMnKTtcbiAgICB9XG4gICAgXG4gICAgdmFyIG9uZSA9IEJpZyA/IG5ldyB0eXBlLkJpZ051bWJlcigxKSA6IDE7XG4gICAgdmFyIGRlZmF1bHRWYWx1ZSA9IEJpZyA/IG5ldyBCaWcoMCkgOiAwO1xuICAgIHZhciBzaXplID0gW3Jvd3MsIGNvbHNdO1xuICAgIFxuICAgIC8vIGNoZWNrIHdlIG5lZWQgdG8gcmV0dXJuIGEgbWF0cml4XG4gICAgaWYgKGZvcm1hdCkge1xuICAgICAgLy8gZ2V0IG1hdHJpeCBzdG9yYWdlIGNvbnN0cnVjdG9yXG4gICAgICB2YXIgRiA9IHR5cGUuTWF0cml4LnN0b3JhZ2UoZm9ybWF0KTtcbiAgICAgIC8vIGNyZWF0ZSBkaWFnb25hbCBtYXRyaXggKHVzZSBvcHRpbWl6ZWQgaW1wbGVtZW50YXRpb24gZm9yIHN0b3JhZ2UgZm9ybWF0KVxuICAgICAgcmV0dXJuIEYuZGlhZ29uYWwoc2l6ZSwgb25lLCAwLCBkZWZhdWx0VmFsdWUpO1xuICAgIH1cbiAgICBcbiAgICAvLyBjcmVhdGUgYW5kIHJlc2l6ZSBhcnJheVxuICAgIHZhciByZXMgPSBhcnJheS5yZXNpemUoW10sIHNpemUsIGRlZmF1bHRWYWx1ZSk7XG4gICAgLy8gZmlsbCBpbiBvbmVzIG9uIHRoZSBkaWFnb25hbFxuICAgIHZhciBtaW5pbXVtID0gcm93cyA8IGNvbHMgPyByb3dzIDogY29scztcbiAgICAvLyBmaWxsIGRpYWdvbmFsXG4gICAgZm9yICh2YXIgZCA9IDA7IGQgPCBtaW5pbXVtOyBkKyspIHtcbiAgICAgIHJlc1tkXVtkXSA9IG9uZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxufVxuXG5leHBvcnRzLm5hbWUgPSAnZXllJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzaXplID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYXJyYXknKS5zaXplO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBtYXRyaXggPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L2Z1bmN0aW9uL21hdHJpeCcpKTtcbiAgXG4gIC8qKlxuICAgKiBGaWx0ZXIgdGhlIGl0ZW1zIGluIGFuIGFycmF5IG9yIG9uZSBkaW1lbnNpb25hbCBtYXRyaXguXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5maWx0ZXIoeCwgdGVzdClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIGZ1bmN0aW9uIGlzUG9zaXRpdmUgKHgpIHtcbiAgICogICAgICByZXR1cm4geCA+IDA7XG4gICAqICAgIH1cbiAgICogICAgbWF0aC5maWx0ZXIoWzYsIC0yLCAtMSwgNCwgM10sIGlzUG9zaXRpdmUpOyAvLyByZXR1cm5zIFs2LCA0LCAzXVxuICAgKlxuICAgKiAgICBtYXRoLmZpbHRlcihbXCIyM1wiLCBcImZvb1wiLCBcIjEwMFwiLCBcIjU1XCIsIFwiYmFyXCJdLCAvWzAtOV0rLyk7IC8vIHJldHVybnMgW1wiMjNcIiwgXCIxMDBcIiwgXCI1NVwiXVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgZm9yRWFjaCwgbWFwLCBzb3J0XG4gICAqXG4gICAqIEBwYXJhbSB7TWF0cml4IHwgQXJyYXl9IHggICAgQSBvbmUgZGltZW5zaW9uYWwgbWF0cml4IG9yIGFycmF5IHRvIGZpbHRlclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uIHwgUmVnRXhwfSB0ZXN0XG4gICAqICAgICAgICBBIGZ1bmN0aW9uIG9yIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byB0ZXN0IGl0ZW1zLlxuICAgKiAgICAgICAgV2hlbiBgdGVzdGAgaXMgYSBmdW5jdGlvbiwgaXQgbXVzdCByZXR1cm4gYSBib29sZWFuLlxuICAgKiAgICAgICAgQWxsIGVudHJpZXMgZm9yIHdoaWNoIGB0ZXN0YCByZXR1cm5zIHRydWUgYXJlIHJldHVybmVkLlxuICAgKiBAcmV0dXJuIHtNYXRyaXggfCBBcnJheX0gUmV0dXJucyB0aGUgZmlsdGVyZWQgbWF0cml4LlxuICAgKi9cbiAgdmFyIGZpbHRlciA9IHR5cGVkKCdmaWx0ZXInLCB7XG4gICAgJ0FycmF5LCBmdW5jdGlvbic6IF9maWx0ZXJDYWxsYmFjayxcblxuICAgICdBcnJheSwgUmVnRXhwJzogX2ZpbHRlclJlZ0V4cCxcblxuICAgICdNYXRyaXgsIGZ1bmN0aW9uJzogZnVuY3Rpb24gKHgsIHRlc3QpIHtcbiAgICAgIHJldHVybiBtYXRyaXgoX2ZpbHRlckNhbGxiYWNrKHgudG9BcnJheSgpLCB0ZXN0KSk7XG4gICAgfSxcblxuICAgICdNYXRyaXgsIFJlZ0V4cCc6IGZ1bmN0aW9uICh4LCB0ZXN0KSB7XG4gICAgICByZXR1cm4gbWF0cml4KF9maWx0ZXJSZWdFeHAoeC50b0FycmF5KCksIHRlc3QpKTtcbiAgICB9XG4gIH0pO1xuXG4gIGZpbHRlci50b1RleCA9ICdcXFxcbWF0aHJteyR7bmFtZX19XFxcXGxlZnQoJHthcmdzfVxcXFxyaWdodCknO1xuXG4gIHJldHVybiBmaWx0ZXI7XG59XG5cbi8qKlxuICogRmlsdGVyIHZhbHVlcyBpbiBhIGNhbGxiYWNrIGdpdmVuIGEgY2FsbGJhY2sgZnVuY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl9IHhcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyB0aGUgZmlsdGVyZWQgYXJyYXlcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9maWx0ZXJDYWxsYmFjayAoeCwgY2FsbGJhY2spIHtcbiAgaWYgKHNpemUoeCkubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IG9uZSBkaW1lbnNpb25hbCBtYXRyaWNlcyBzdXBwb3J0ZWQnKTtcbiAgfVxuXG4gIHJldHVybiB4LmZpbHRlcihmdW5jdGlvbiAoZW50cnkpIHtcbiAgICByZXR1cm4gY2FsbGJhY2soZW50cnkpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBGaWx0ZXIgdmFsdWVzIGluIGEgY2FsbGJhY2sgZ2l2ZW4gYSByZWd1bGFyIGV4cHJlc3Npb25cbiAqIEBwYXJhbSB7QXJyYXl9IHhcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlZ2V4cFxuICogQHJldHVybiB7QXJyYXl9IFJldHVybnMgdGhlIGZpbHRlcmVkIGFycmF5XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfZmlsdGVyUmVnRXhwICh4LCByZWdleHApIHtcbiAgaWYgKHNpemUoeCkubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IG9uZSBkaW1lbnNpb25hbCBtYXRyaWNlcyBzdXBwb3J0ZWQnKTtcbiAgfVxuXG4gIHJldHVybiB4LmZpbHRlcihmdW5jdGlvbiAoZW50cnkpIHtcbiAgICByZXR1cm4gcmVnZXhwLnRlc3QoZW50cnkpO1xuICB9KTtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2ZpbHRlcic7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2xvbmUgPSByZXF1aXJlKCcuLi8uLi91dGlscy9vYmplY3QnKS5jbG9uZTtcbnZhciBfZmxhdHRlbiA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2FycmF5JykuZmxhdHRlbjtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgbWF0cml4ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC9mdW5jdGlvbi9tYXRyaXgnKSk7XG5cbiAgLyoqXG4gICAqIEZsYXR0ZW4gYSBtdWx0aSBkaW1lbnNpb25hbCBtYXRyaXggaW50byBhIHNpbmdsZSBkaW1lbnNpb25hbCBtYXRyaXguXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5mbGF0dGVuKHgpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmZsYXR0ZW4oW1sxLDJdLCBbMyw0XV0pOyAgIC8vIHJldHVybnMgWzEsIDIsIDMsIDRdXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBjb25jYXQsIHJlc2l6ZSwgc2l6ZSwgc3F1ZWV6ZVxuICAgKlxuICAgKiBAcGFyYW0ge01hdHJpeCB8IEFycmF5fSB4ICAgTWF0cml4IHRvIGJlIGZsYXR0ZW5lZFxuICAgKiBAcmV0dXJuIHtNYXRyaXggfCBBcnJheX0gUmV0dXJucyB0aGUgZmxhdHRlbmVkIG1hdHJpeFxuICAgKi9cbiAgdmFyIGZsYXR0ZW4gPSB0eXBlZCgnZmxhdHRlbicsIHtcbiAgICAnQXJyYXknOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIF9mbGF0dGVuKGNsb25lKHgpKTtcbiAgICB9LFxuXG4gICAgJ01hdHJpeCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICB2YXIgZmxhdCA9IF9mbGF0dGVuKGNsb25lKHgudG9BcnJheSgpKSk7XG4gICAgICAvLyBUT0RPOiByZXR1cm4gdGhlIHNhbWUgbWF0cml4IHR5cGUgYXMgeFxuICAgICAgcmV0dXJuIG1hdHJpeChmbGF0KTtcbiAgICB9XG4gIH0pO1xuXG4gIGZsYXR0ZW4udG9UZXggPSAnXFxcXG1hdGhybXske25hbWV9fVxcXFxsZWZ0KCR7YXJnc31cXFxccmlnaHQpJztcblxuICByZXR1cm4gZmxhdHRlbjtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2ZsYXR0ZW4nO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICAvKipcbiAgICogSXRlcmF0ZSBvdmVyIGFsbCBlbGVtZW50cyBvZiBhIG1hdHJpeC9hcnJheSwgYW5kIGV4ZWN1dGVzIHRoZSBnaXZlbiBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmZvckVhY2goeCwgY2FsbGJhY2spXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmZvckVhY2goWzEsIDIsIDNdLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgKiAgICAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbiAgICogICAgfSk7XG4gICAqICAgIC8vIG91dHB1dHMgMSwgMiwgM1xuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgZmlsdGVyLCBtYXAsIHNvcnRcbiAgICpcbiAgICogQHBhcmFtIHtNYXRyaXggfCBBcnJheX0geCAgICBUaGUgbWF0cml4IHRvIGl0ZXJhdGUgb24uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrICAgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudCwgdGhlIGluZGV4XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgdGhlIGVsZW1lbnQsIGFuZCB0aGUgTWF0cml4L2FycmF5IGJlaW5nIHRyYXZlcnNlZC5cbiAgICovXG4gIHZhciBmb3JFYWNoID0gdHlwZWQoJ2ZvckVhY2gnLCB7XG4gICAgJ0FycmF5LCBmdW5jdGlvbic6IF9mb3JFYWNoLFxuXG4gICAgJ01hdHJpeCwgZnVuY3Rpb24nOiBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiB4LmZvckVhY2goY2FsbGJhY2spO1xuICAgIH1cbiAgfSk7XG5cbiAgZm9yRWFjaC50b1RleCA9ICdcXFxcbWF0aHJteyR7bmFtZX19XFxcXGxlZnQoJHthcmdzfVxcXFxyaWdodCknO1xuXG4gIHJldHVybiBmb3JFYWNoO1xufVxuXG4vKipcbiAqIGZvckVhY2ggZm9yIGEgbXVsdGkgZGltZW5zaW9uYWwgYXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2ZvckVhY2ggKGFycmF5LCBjYWxsYmFjaykge1xuICB2YXIgcmVjdXJzZSA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkLCBpKSB7XG4gICAgICAgIC8vIHdlIGNyZWF0ZSBhIGNvcHkgb2YgdGhlIGluZGV4IGFycmF5IGFuZCBhcHBlbmQgdGhlIG5ldyBpbmRleCB2YWx1ZVxuICAgICAgICByZWN1cnNlKGNoaWxkLCBpbmRleC5jb25jYXQoaSkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2FsbGJhY2sodmFsdWUsIGluZGV4LCBhcnJheSk7XG4gICAgfVxuICB9O1xuICByZWN1cnNlKGFycmF5LCBbXSk7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdmb3JFYWNoJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFtcbiAgcmVxdWlyZSgnLi9jb25jYXQnKSxcbiAgcmVxdWlyZSgnLi9jcm9zcycpLFxuICByZXF1aXJlKCcuL2RldCcpLFxuICByZXF1aXJlKCcuL2RpYWcnKSxcbiAgcmVxdWlyZSgnLi9kb3QnKSxcbiAgcmVxdWlyZSgnLi9leWUnKSxcbiAgcmVxdWlyZSgnLi9maWx0ZXInKSxcbiAgcmVxdWlyZSgnLi9mbGF0dGVuJyksXG4gIHJlcXVpcmUoJy4vZm9yRWFjaCcpLFxuICByZXF1aXJlKCcuL2ludicpLFxuICByZXF1aXJlKCcuL21hcCcpLFxuICByZXF1aXJlKCcuL29uZXMnKSxcbiAgcmVxdWlyZSgnLi9wYXJ0aXRpb25TZWxlY3QnKSxcbiAgcmVxdWlyZSgnLi9yYW5nZScpLFxuICByZXF1aXJlKCcuL3Jlc2l6ZScpLFxuICByZXF1aXJlKCcuL3NpemUnKSxcbiAgcmVxdWlyZSgnLi9zb3J0JyksXG4gIHJlcXVpcmUoJy4vc3F1ZWV6ZScpLFxuICByZXF1aXJlKCcuL3N1YnNldCcpLFxuICByZXF1aXJlKCcuL3RyYWNlJyksXG4gIHJlcXVpcmUoJy4vdHJhbnNwb3NlJyksXG4gIHJlcXVpcmUoJy4vemVyb3MnKVxuXTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlscy9pbmRleCcpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBtYXRyaXggICAgICAgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L2Z1bmN0aW9uL21hdHJpeCcpKTtcbiAgdmFyIGRpdmlkZVNjYWxhciA9IGxvYWQocmVxdWlyZSgnLi4vYXJpdGhtZXRpYy9kaXZpZGVTY2FsYXInKSk7XG4gIHZhciBhZGRTY2FsYXIgICAgPSBsb2FkKHJlcXVpcmUoJy4uL2FyaXRobWV0aWMvYWRkU2NhbGFyJykpO1xuICB2YXIgbXVsdGlwbHkgICAgID0gbG9hZChyZXF1aXJlKCcuLi9hcml0aG1ldGljL211bHRpcGx5JykpO1xuICB2YXIgdW5hcnlNaW51cyAgID0gbG9hZChyZXF1aXJlKCcuLi9hcml0aG1ldGljL3VuYXJ5TWludXMnKSk7XG4gIHZhciBkZXQgICAgICAgICAgPSBsb2FkKHJlcXVpcmUoJy4uL21hdHJpeC9kZXQnKSk7XG4gIHZhciBleWUgICAgICAgICAgPSBsb2FkKHJlcXVpcmUoJy4vZXllJykpO1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGludmVyc2Ugb2YgYSBzcXVhcmUgbWF0cml4LlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgICBtYXRoLmludih4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgIG1hdGguaW52KFtbMSwgMl0sIFszLCA0XV0pOyAgLy8gcmV0dXJucyBbWy0yLCAxXSwgWzEuNSwgLTAuNV1dXG4gICAqICAgICBtYXRoLmludig0KTsgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgMC4yNVxuICAgKiAgICAgMSAvIDQ7ICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIDAuMjVcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgICBkZXQsIHRyYW5zcG9zZVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0geCAgICAgTWF0cml4IHRvIGJlIGludmVyc2VkXG4gICAqIEByZXR1cm4ge251bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0gVGhlIGludmVyc2Ugb2YgYHhgLlxuICAgKi9cbiAgdmFyIGludiA9IHR5cGVkKCdpbnYnLCB7XG4gICAgJ0FycmF5IHwgTWF0cml4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHZhciBzaXplID0gKHguaXNNYXRyaXggPT09IHRydWUpID8geC5zaXplKCkgOiB1dGlsLmFycmF5LnNpemUoeCk7XG4gICAgICBzd2l0Y2ggKHNpemUubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAvLyB2ZWN0b3JcbiAgICAgICAgICBpZiAoc2l6ZVswXSA9PSAxKSB7XG4gICAgICAgICAgICBpZiAoeC5pc01hdHJpeCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gbWF0cml4KFtcbiAgICAgICAgICAgICAgICBkaXZpZGVTY2FsYXIoMSwgeC52YWx1ZU9mKClbMF0pXG4gICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgZGl2aWRlU2NhbGFyKDEsIHhbMF0pXG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ01hdHJpeCBtdXN0IGJlIHNxdWFyZSAnICtcbiAgICAgICAgICAgICcoc2l6ZTogJyArIHV0aWwuc3RyaW5nLmZvcm1hdChzaXplKSArICcpJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAvLyB0d28gZGltZW5zaW9uYWwgYXJyYXlcbiAgICAgICAgICB2YXIgcm93cyA9IHNpemVbMF07XG4gICAgICAgICAgdmFyIGNvbHMgPSBzaXplWzFdO1xuICAgICAgICAgIGlmIChyb3dzID09IGNvbHMpIHtcbiAgICAgICAgICAgIGlmICh4LmlzTWF0cml4ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBtYXRyaXgoXG4gICAgICAgICAgICAgICAgICBfaW52KHgudmFsdWVPZigpLCByb3dzLCBjb2xzKSxcbiAgICAgICAgICAgICAgICAgIHguc3RvcmFnZSgpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gcmV0dXJuIGFuIEFycmF5XG4gICAgICAgICAgICAgIHJldHVybiBfaW52KHgsIHJvd3MsIGNvbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdNYXRyaXggbXVzdCBiZSBzcXVhcmUgJyArXG4gICAgICAgICAgICAnKHNpemU6ICcgKyB1dGlsLnN0cmluZy5mb3JtYXQoc2l6ZSkgKyAnKScpO1xuICAgICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIG11bHRpIGRpbWVuc2lvbmFsIGFycmF5XG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ01hdHJpeCBtdXN0IGJlIHR3byBkaW1lbnNpb25hbCAnICtcbiAgICAgICAgICAnKHNpemU6ICcgKyB1dGlsLnN0cmluZy5mb3JtYXQoc2l6ZSkgKyAnKScpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAnYW55JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIC8vIHNjYWxhclxuICAgICAgcmV0dXJuIGRpdmlkZVNjYWxhcigxLCB4KTsgLy8gRklYTUU6IGNyZWF0ZSBhIEJpZ051bWJlciBvbmUgd2hlbiBjb25maWd1cmVkIGZvciBiaWdudW1iZXJzXG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBpbnZlcnNlIG9mIGEgc3F1YXJlIG1hdHJpeFxuICAgKiBAcGFyYW0ge0FycmF5W119IG1hdCAgICAgQSBzcXVhcmUgbWF0cml4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSByb3dzICAgICBOdW1iZXIgb2Ygcm93c1xuICAgKiBAcGFyYW0ge251bWJlcn0gY29scyAgICAgTnVtYmVyIG9mIGNvbHVtbnMsIG11c3QgZXF1YWwgcm93c1xuICAgKiBAcmV0dXJuIHtBcnJheVtdfSBpbnYgICAgSW52ZXJzZSBtYXRyaXhcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9pbnYgKG1hdCwgcm93cywgY29scyl7XG4gICAgdmFyIHIsIHMsIGYsIHZhbHVlLCB0ZW1wO1xuXG4gICAgaWYgKHJvd3MgPT0gMSkge1xuICAgICAgLy8gdGhpcyBpcyBhIDEgeCAxIG1hdHJpeFxuICAgICAgdmFsdWUgPSBtYXRbMF1bMF07XG4gICAgICBpZiAodmFsdWUgPT0gMCkge1xuICAgICAgICB0aHJvdyBFcnJvcignQ2Fubm90IGNhbGN1bGF0ZSBpbnZlcnNlLCBkZXRlcm1pbmFudCBpcyB6ZXJvJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW1tcbiAgICAgICAgZGl2aWRlU2NhbGFyKDEsIHZhbHVlKVxuICAgICAgXV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHJvd3MgPT0gMikge1xuICAgICAgLy8gdGhpcyBpcyBhIDIgeCAyIG1hdHJpeFxuICAgICAgdmFyIGQgPSBkZXQobWF0KTtcbiAgICAgIGlmIChkID09IDApIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0Nhbm5vdCBjYWxjdWxhdGUgaW52ZXJzZSwgZGV0ZXJtaW5hbnQgaXMgemVybycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgW1xuICAgICAgICAgIGRpdmlkZVNjYWxhcihtYXRbMV1bMV0sIGQpLFxuICAgICAgICAgIGRpdmlkZVNjYWxhcih1bmFyeU1pbnVzKG1hdFswXVsxXSksIGQpXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBkaXZpZGVTY2FsYXIodW5hcnlNaW51cyhtYXRbMV1bMF0pLCBkKSxcbiAgICAgICAgICBkaXZpZGVTY2FsYXIobWF0WzBdWzBdLCBkKVxuICAgICAgICBdXG4gICAgICBdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIHRoaXMgaXMgYSBtYXRyaXggb2YgMyB4IDMgb3IgbGFyZ2VyXG4gICAgICAvLyBjYWxjdWxhdGUgaW52ZXJzZSB1c2luZyBnYXVzcy1qb3JkYW4gZWxpbWluYXRpb25cbiAgICAgIC8vICAgICAgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HYXVzc2lhbl9lbGltaW5hdGlvblxuICAgICAgLy8gICAgICBodHRwOi8vbWF0aHdvcmxkLndvbGZyYW0uY29tL01hdHJpeEludmVyc2UuaHRtbFxuICAgICAgLy8gICAgICBodHRwOi8vbWF0aC51d3cuZWR1L35tY2ZhcmxhdC9pbnZlcnNlLmh0bVxuXG4gICAgICAvLyBtYWtlIGEgY29weSBvZiB0aGUgbWF0cml4IChvbmx5IHRoZSBhcnJheXMsIG5vdCBvZiB0aGUgZWxlbWVudHMpXG4gICAgICB2YXIgQSA9IG1hdC5jb25jYXQoKTtcbiAgICAgIGZvciAociA9IDA7IHIgPCByb3dzOyByKyspIHtcbiAgICAgICAgQVtyXSA9IEFbcl0uY29uY2F0KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGNyZWF0ZSBhbiBpZGVudGl0eSBtYXRyaXggd2hpY2ggaW4gdGhlIGVuZCB3aWxsIGNvbnRhaW4gdGhlXG4gICAgICAvLyBtYXRyaXggaW52ZXJzZVxuICAgICAgdmFyIEIgPSBleWUocm93cykudmFsdWVPZigpO1xuXG4gICAgICAvLyBsb29wIG92ZXIgYWxsIGNvbHVtbnMsIGFuZCBwZXJmb3JtIHJvdyByZWR1Y3Rpb25zXG4gICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNvbHM7IGMrKykge1xuICAgICAgICAvLyBlbGVtZW50IEFjYyBzaG91bGQgYmUgbm9uIHplcm8uIGlmIG5vdCwgc3dhcCBjb250ZW50XG4gICAgICAgIC8vIHdpdGggb25lIG9mIHRoZSBsb3dlciByb3dzXG4gICAgICAgIHIgPSBjO1xuICAgICAgICB3aGlsZSAociA8IHJvd3MgJiYgQVtyXVtjXSA9PSAwKSB7XG4gICAgICAgICAgcisrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyID09IHJvd3MgfHwgQVtyXVtjXSA9PSAwKSB7XG4gICAgICAgICAgLy8gVE9ETzogaW4gY2FzZSBvZiB6ZXJvIGRldCwganVzdCByZXR1cm4gYSBtYXRyaXggd2loIEluZmluaXR5IHZhbHVlcz8gKGxpa2Ugb2N0YXZlKVxuICAgICAgICAgIHRocm93IEVycm9yKCdDYW5ub3QgY2FsY3VsYXRlIGludmVyc2UsIGRldGVybWluYW50IGlzIHplcm8nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAociAhPSBjKSB7XG4gICAgICAgICAgdGVtcCA9IEFbY107IEFbY10gPSBBW3JdOyBBW3JdID0gdGVtcDtcbiAgICAgICAgICB0ZW1wID0gQltjXTsgQltjXSA9IEJbcl07IEJbcl0gPSB0ZW1wO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZWxpbWluYXRlIG5vbi16ZXJvIHZhbHVlcyBvbiB0aGUgb3RoZXIgcm93cyBhdCBjb2x1bW4gY1xuICAgICAgICB2YXIgQWMgPSBBW2NdLFxuICAgICAgICAgICAgQmMgPSBCW2NdO1xuICAgICAgICBmb3IgKHIgPSAwOyByIDwgcm93czsgcisrKSB7XG4gICAgICAgICAgdmFyIEFyID0gQVtyXSxcbiAgICAgICAgICAgICAgQnIgPSBCW3JdO1xuICAgICAgICAgIGlmKHIgIT0gYykge1xuICAgICAgICAgICAgLy8gZWxpbWluYXRlIHZhbHVlIGF0IGNvbHVtbiBjIGFuZCByb3cgclxuICAgICAgICAgICAgaWYgKEFyW2NdICE9IDApIHtcbiAgICAgICAgICAgICAgZiA9IGRpdmlkZVNjYWxhcih1bmFyeU1pbnVzKEFyW2NdKSwgQWNbY10pO1xuXG4gICAgICAgICAgICAgIC8vIGFkZCAoZiAqIHJvdyBjKSB0byByb3cgciB0byBlbGltaW5hdGUgdGhlIHZhbHVlXG4gICAgICAgICAgICAgIC8vIGF0IGNvbHVtbiBjXG4gICAgICAgICAgICAgIGZvciAocyA9IGM7IHMgPCBjb2xzOyBzKyspIHtcbiAgICAgICAgICAgICAgICBBcltzXSA9IGFkZFNjYWxhcihBcltzXSwgbXVsdGlwbHkoZiwgQWNbc10pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKHMgPSAwOyBzIDwgY29sczsgcysrKSB7XG4gICAgICAgICAgICAgICAgQnJbc10gPSBhZGRTY2FsYXIoQnJbc10sICBtdWx0aXBseShmLCBCY1tzXSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gbm9ybWFsaXplIHZhbHVlIGF0IEFjYyB0byAxLFxuICAgICAgICAgICAgLy8gZGl2aWRlIGVhY2ggdmFsdWUgb24gcm93IHIgd2l0aCB0aGUgdmFsdWUgYXQgQWNjXG4gICAgICAgICAgICBmID0gQWNbY107XG4gICAgICAgICAgICBmb3IgKHMgPSBjOyBzIDwgY29sczsgcysrKSB7XG4gICAgICAgICAgICAgIEFyW3NdID0gZGl2aWRlU2NhbGFyKEFyW3NdLCBmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAocyA9IDA7IHMgPCBjb2xzOyBzKyspIHtcbiAgICAgICAgICAgICAgQnJbc10gPSBkaXZpZGVTY2FsYXIoQnJbc10sIGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIEI7XG4gICAgfVxuICB9XG5cbiAgaW52LnRvVGV4ID0gJ1xcXFxsZWZ0KCR7YXJnc1swXX1cXFxccmlnaHQpXnstMX0nO1xuXG4gIHJldHVybiBpbnY7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdpbnYnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IG1hdHJpeCBvciBhcnJheSB3aXRoIHRoZSByZXN1bHRzIG9mIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBleGVjdXRlZCBvblxuICAgKiBlYWNoIGVudHJ5IG9mIHRoZSBtYXRyaXgvYXJyYXkuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5tYXAoeCwgY2FsbGJhY2spXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLm1hcChbMSwgMiwgM10sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAqICAgICAgcmV0dXJuIHZhbHVlICogdmFsdWU7XG4gICAqICAgIH0pOyAgLy8gcmV0dXJucyBbMSwgNCwgOV1cbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGZpbHRlciwgZm9yRWFjaCwgc29ydFxuICAgKlxuICAgKiBAcGFyYW0ge01hdHJpeCB8IEFycmF5fSB4ICAgIFRoZSBtYXRyaXggdG8gaXRlcmF0ZSBvbi5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgICBUaGUgY2FsbGJhY2sgbWV0aG9kIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudCwgdGhlIGluZGV4XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgdGhlIGVsZW1lbnQsIGFuZCB0aGUgbWF0cml4IGJlaW5nIHRyYXZlcnNlZC5cbiAgICogQHJldHVybiB7TWF0cml4IHwgYXJyYXl9ICAgICBUcmFuc2Zvcm1lZCBtYXAgb2YgeFxuICAgKi9cbiAgdmFyIG1hcCA9IHR5cGVkKCdtYXAnLCB7XG4gICAgJ0FycmF5LCBmdW5jdGlvbic6IF9tYXAsXG5cbiAgICAnTWF0cml4LCBmdW5jdGlvbic6IGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHgubWFwKGNhbGxiYWNrKTtcbiAgICB9XG4gIH0pO1xuXG4gIG1hcC50b1RleCA9ICdcXFxcbWF0aHJteyR7bmFtZX19XFxcXGxlZnQoJHthcmdzfVxcXFxyaWdodCknO1xuXG4gIHJldHVybiBtYXA7XG59XG5cbi8qKlxuICogTWFwIGZvciBhIG11bHRpIGRpbWVuc2lvbmFsIGFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX21hcCAoYXJyYXksIGNhbGxiYWNrKSB7XG4gIHZhciByZWN1cnNlID0gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlLm1hcChmdW5jdGlvbiAoY2hpbGQsIGkpIHtcbiAgICAgICAgLy8gd2UgY3JlYXRlIGEgY29weSBvZiB0aGUgaW5kZXggYXJyYXkgYW5kIGFwcGVuZCB0aGUgbmV3IGluZGV4IHZhbHVlXG4gICAgICAgIHJldHVybiByZWN1cnNlKGNoaWxkLCBpbmRleC5jb25jYXQoaSkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgYXJyYXkpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gcmVjdXJzZShhcnJheSwgW10pO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnbWFwJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0ludGVnZXIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9udW1iZXInKS5pc0ludGVnZXI7XG52YXIgcmVzaXplID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYXJyYXknKS5yZXNpemU7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIG1hdHJpeCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvZnVuY3Rpb24vbWF0cml4JykpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBtYXRyaXggZmlsbGVkIHdpdGggb25lcy4gVGhlIGNyZWF0ZWQgbWF0cml4IGNhbiBoYXZlIG9uZSBvclxuICAgKiBtdWx0aXBsZSBkaW1lbnNpb25zLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGgub25lcyhtKVxuICAgKiAgICBtYXRoLm9uZXMobSwgZm9ybWF0KVxuICAgKiAgICBtYXRoLm9uZXMobSwgbilcbiAgICogICAgbWF0aC5vbmVzKG0sIG4sIGZvcm1hdClcbiAgICogICAgbWF0aC5vbmVzKFttLCBuXSlcbiAgICogICAgbWF0aC5vbmVzKFttLCBuXSwgZm9ybWF0KVxuICAgKiAgICBtYXRoLm9uZXMoW20sIG4sIHAsIC4uLl0pXG4gICAqICAgIG1hdGgub25lcyhbbSwgbiwgcCwgLi4uXSwgZm9ybWF0KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5vbmVzKDMpOyAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIFsxLCAxLCAxXVxuICAgKiAgICBtYXRoLm9uZXMoMywgMik7ICAgICAgICAgICAgICAgIC8vIHJldHVybnMgW1sxLCAxXSwgWzEsIDFdLCBbMSwgMV1dXG4gICAqICAgIG1hdGgub25lcygzLCAyLCAnZGVuc2UnKTsgICAgICAgLy8gcmV0dXJucyBEZW5zZSBNYXRyaXggW1sxLCAxXSwgWzEsIDFdLCBbMSwgMV1dXG4gICAqXG4gICAqICAgIHZhciBBID0gW1sxLCAyLCAzXSwgWzQsIDUsIDZdXTtcbiAgICogICAgbWF0aC5vbmVzKG1hdGguc2l6ZShBKSk7ICAgICAgIC8vIHJldHVybnMgW1sxLCAxLCAxXSwgWzEsIDEsIDFdXVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgemVyb3MsIGV5ZSwgc2l6ZSwgcmFuZ2VcbiAgICpcbiAgICogQHBhcmFtIHsuLi5udW1iZXIgfCBBcnJheX0gc2l6ZSAgICBUaGUgc2l6ZSBvZiBlYWNoIGRpbWVuc2lvbiBvZiB0aGUgbWF0cml4XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZm9ybWF0XSAgICAgICAgICAgVGhlIE1hdHJpeCBzdG9yYWdlIGZvcm1hdFxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheSB8IE1hdHJpeCB8IG51bWJlcn0gIEEgbWF0cml4IGZpbGxlZCB3aXRoIG9uZXNcbiAgICovXG4gIHZhciBvbmVzID0gdHlwZWQoJ29uZXMnLCB7XG4gICAgJyc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoY29uZmlnLm1hdHJpeCA9PT0gJ0FycmF5JylcbiAgICAgICAgICA/IF9vbmVzKFtdKVxuICAgICAgICAgIDogX29uZXMoW10sICdkZWZhdWx0Jyk7XG4gICAgfSxcblxuICAgIC8vIG1hdGgub25lcyhtLCBuLCBwLCAuLi4sIGZvcm1hdClcbiAgICAvLyBUT0RPOiBtb3JlIGFjY3VyYXRlIHNpZ25hdHVyZSAnLi4ubnVtYmVyIHwgQmlnTnVtYmVyLCBzdHJpbmcnIGFzIHNvb24gYXMgdHlwZWQtZnVuY3Rpb24gc3VwcG9ydHMgdGhpc1xuICAgICcuLi5udW1iZXIgfCBCaWdOdW1iZXIgfCBzdHJpbmcnOiBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgdmFyIGxhc3QgPSBzaXplW3NpemUubGVuZ3RoIC0gMV07XG4gICAgICBpZiAodHlwZW9mIGxhc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciBmb3JtYXQgPSBzaXplLnBvcCgpO1xuICAgICAgICByZXR1cm4gX29uZXMoc2l6ZSwgZm9ybWF0KTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGNvbmZpZy5tYXRyaXggPT09ICdBcnJheScpIHtcbiAgICAgICAgcmV0dXJuIF9vbmVzKHNpemUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBfb25lcyhzaXplLCAnZGVmYXVsdCcpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAnQXJyYXknOiBfb25lcyxcblxuICAgICdNYXRyaXgnOiBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgdmFyIGZvcm1hdCA9IHNpemUuc3RvcmFnZSgpO1xuICAgICAgcmV0dXJuIF9vbmVzKHNpemUudmFsdWVPZigpLCBmb3JtYXQpO1xuICAgIH0sXG5cbiAgICAnQXJyYXkgfCBNYXRyaXgsIHN0cmluZyc6IGZ1bmN0aW9uIChzaXplLCBmb3JtYXQpIHtcbiAgICAgIHJldHVybiBfb25lcyAoc2l6ZS52YWx1ZU9mKCksIGZvcm1hdCk7XG4gICAgfVxuICB9KTtcblxuICBvbmVzLnRvVGV4ID0gJ1xcXFxtYXRocm17JHtuYW1lfX1cXFxcbGVmdCgke2FyZ3N9XFxcXHJpZ2h0KSc7XG5cbiAgcmV0dXJuIG9uZXM7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBBcnJheSBvciBNYXRyaXggd2l0aCBvbmVzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNpemVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtmb3JtYXQ9J2RlZmF1bHQnXVxuICAgKiBAcmV0dXJuIHtBcnJheSB8IE1hdHJpeH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9vbmVzKHNpemUsIGZvcm1hdCkge1xuICAgIHZhciBoYXNCaWdOdW1iZXJzID0gX25vcm1hbGl6ZShzaXplKTtcbiAgICB2YXIgZGVmYXVsdFZhbHVlID0gaGFzQmlnTnVtYmVycyA/IG5ldyB0eXBlLkJpZ051bWJlcigxKSA6IDE7XG4gICAgX3ZhbGlkYXRlKHNpemUpO1xuXG4gICAgaWYgKGZvcm1hdCkge1xuICAgICAgLy8gcmV0dXJuIGEgbWF0cml4XG4gICAgICB2YXIgbSA9IG1hdHJpeChmb3JtYXQpO1xuICAgICAgaWYgKHNpemUubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gbS5yZXNpemUoc2l6ZSwgZGVmYXVsdFZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIHJldHVybiBhbiBBcnJheVxuICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgaWYgKHNpemUubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gcmVzaXplKGFyciwgc2l6ZSwgZGVmYXVsdFZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuICB9XG5cbiAgLy8gcmVwbGFjZSBCaWdOdW1iZXJzIHdpdGggbnVtYmVycywgcmV0dXJucyB0cnVlIGlmIHNpemUgY29udGFpbmVkIEJpZ051bWJlcnNcbiAgZnVuY3Rpb24gX25vcm1hbGl6ZShzaXplKSB7XG4gICAgdmFyIGhhc0JpZ051bWJlcnMgPSBmYWxzZTtcbiAgICBzaXplLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgYXJyKSB7XG4gICAgICBpZiAodmFsdWUgJiYgdmFsdWUuaXNCaWdOdW1iZXIgPT09IHRydWUpIHtcbiAgICAgICAgaGFzQmlnTnVtYmVycyA9IHRydWU7XG4gICAgICAgIGFycltpbmRleF0gPSB2YWx1ZS50b051bWJlcigpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBoYXNCaWdOdW1iZXJzO1xuICB9XG5cbiAgLy8gdmFsaWRhdGUgYXJndW1lbnRzXG4gIGZ1bmN0aW9uIF92YWxpZGF0ZSAoc2l6ZSkge1xuICAgIHNpemUuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8ICFpc0ludGVnZXIodmFsdWUpIHx8IHZhbHVlIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcmFtZXRlcnMgaW4gZnVuY3Rpb24gb25lcyBtdXN0IGJlIHBvc2l0aXZlIGludGVnZXJzJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0cy5uYW1lID0gJ29uZXMnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzSW50ZWdlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL251bWJlcicpLmlzSW50ZWdlcjtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgYXNjID0gbG9hZChyZXF1aXJlKCcuLi9yZWxhdGlvbmFsL2NvbXBhcmUnKSk7XG4gIGZ1bmN0aW9uIGRlc2MoYSwgYikge1xuICAgIHJldHVybiAtYXNjKGEsIGIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnRpdGlvbi1iYXNlZCBzZWxlY3Rpb24gb2YgYW4gYXJyYXkgb3IgMUQgbWF0cml4LlxuICAgKiBXaWxsIGZpbmQgdGhlIGt0aCBzbWFsbGVzdCB2YWx1ZSwgYW5kIG11dGF0ZXMgdGhlIGlucHV0IGFycmF5LlxuICAgKiBVc2VzIFF1aWNrc2VsZWN0LlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGgucGFydGl0aW9uU2VsZWN0KHgsIGspXG4gICAqICAgIG1hdGgucGFydGl0aW9uU2VsZWN0KHgsIGssIGNvbXBhcmUpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLnBhcnRpdGlvblNlbGVjdChbNSwgMTAsIDFdLCAyKTsgICAgICAgICAgIC8vIHJldHVybnMgMTBcbiAgICogICAgbWF0aC5wYXJ0aXRpb25TZWxlY3QoWydDJywgJ0InLCAnQScsICdEJ10sIDEpOyAvLyByZXR1cm5zICdCJ1xuICAgKlxuICAgKiAgICBmdW5jdGlvbiBzb3J0QnlMZW5ndGggKGEsIGIpIHtcbiAgICogICAgICByZXR1cm4gYS5sZW5ndGggLSBiLmxlbmd0aDtcbiAgICogICAgfVxuICAgKiAgICBtYXRoLnBhcnRpdGlvblNlbGVjdChbJ0xhbmdkb24nLCAnVG9tJywgJ1NhcmEnXSwgMiwgc29ydEJ5TGVuZ3RoKTsgLy8gcmV0dXJucyAnTGFuZ2RvbidcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIHNvcnRcbiAgICpcbiAgICogQHBhcmFtIHtNYXRyaXggfCBBcnJheX0geCAgICBBIG9uZSBkaW1lbnNpb25hbCBtYXRyaXggb3IgYXJyYXkgdG8gc29ydFxuICAgKiBAcGFyYW0ge051bWJlcn0gayAgICAgICAgICAgIFRoZSBrdGggc21hbGxlc3QgdmFsdWUgdG8gYmUgcmV0cmlldmVkOyB6ZXJvLWJhc2VkIGluZGV4XG4gICAqIEBwYXJhbSB7RnVuY3Rpb24gfCAnYXNjJyB8ICdkZXNjJ30gW2NvbXBhcmU9J2FzYyddXG4gICAqICAgICAgICBBbiBvcHRpb25hbCBjb21wYXJhdG9yIGZ1bmN0aW9uLiBUaGUgZnVuY3Rpb24gaXMgY2FsbGVkIGFzXG4gICAqICAgICAgICBgY29tcGFyZShhLCBiKWAsIGFuZCBtdXN0IHJldHVybiAxIHdoZW4gYSA+IGIsIC0xIHdoZW4gYSA8IGIsXG4gICAqICAgICAgICBhbmQgMCB3aGVuIGEgPT0gYi5cbiAgICogQHJldHVybiB7Kn0gUmV0dXJucyB0aGUga3RoIGxvd2VzdCB2YWx1ZS5cbiAgICovXG4gIHJldHVybiB0eXBlZCgncGFydGl0aW9uU2VsZWN0Jywge1xuICAgICdBcnJheSB8IE1hdHJpeCwgbnVtYmVyJzogZnVuY3Rpb24gKHgsIGspIHtcbiAgICAgIHJldHVybiBfcGFydGl0aW9uU2VsZWN0KHgsIGssIGFzYyk7XG4gICAgfSxcblxuICAgICdBcnJheSB8IE1hdHJpeCwgbnVtYmVyLCBzdHJpbmcnOiBmdW5jdGlvbiAoeCwgaywgY29tcGFyZSkge1xuICAgICAgaWYgKGNvbXBhcmUgPT09ICdhc2MnKSB7XG4gICAgICAgIHJldHVybiBfcGFydGl0aW9uU2VsZWN0KHgsIGssIGFzYyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChjb21wYXJlID09PSAnZGVzYycpIHtcbiAgICAgICAgcmV0dXJuIF9wYXJ0aXRpb25TZWxlY3QoeCwgaywgZGVzYyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb21wYXJlIHN0cmluZyBtdXN0IGJlIFwiYXNjXCIgb3IgXCJkZXNjXCInKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgJ0FycmF5IHwgTWF0cml4LCBudW1iZXIsIGZ1bmN0aW9uJzogX3BhcnRpdGlvblNlbGVjdFxuICB9KTtcblxuICBmdW5jdGlvbiBfcGFydGl0aW9uU2VsZWN0KHgsIGssIGNvbXBhcmUpIHtcbiAgICBpZiAoIWlzSW50ZWdlcihrKSB8fCBrIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdrIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlcicpO1xuICAgIH1cblxuICAgIGlmICh4ICYmIHguaXNNYXRyaXgpIHtcbiAgICAgIHZhciBzaXplID0geC5zaXplKCk7XG4gICAgICBpZiAoc2l6ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBvbmUgZGltZW5zaW9uYWwgbWF0cmljZXMgc3VwcG9ydGVkJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcXVpY2tTZWxlY3QoeC52YWx1ZU9mKCksIGssIGNvbXBhcmUpO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHgpKSB7XG4gICAgICByZXR1cm4gcXVpY2tTZWxlY3QoeCwgaywgY29tcGFyZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFF1aWNrc2VsZWN0IGFsZ29yaXRobS5cbiAgICogQ29kZSBhZGFwdGVkIGZyb206XG4gICAqIGh0dHA6Ly9ibG9nLnRlYW1sZWFkbmV0LmNvbS8yMDEyLzA3L3F1aWNrLXNlbGVjdC1hbGdvcml0aG0tZmluZC1rdGgtZWxlbWVudC5odG1sXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICAgKiBAcGFyYW0ge051bWJlcn0ga1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBxdWlja1NlbGVjdChhcnIsIGssIGNvbXBhcmUpIHtcbiAgICBpZiAoayA+PSBhcnIubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2sgb3V0IG9mIGJvdW5kcycpO1xuICAgIH1cblxuICAgIHZhciBmcm9tID0gMDtcbiAgICB2YXIgdG8gPSBhcnIubGVuZ3RoIC0gMTtcblxuICAgIC8vIGlmIGZyb20gPT0gdG8gd2UgcmVhY2hlZCB0aGUga3RoIGVsZW1lbnRcbiAgICB3aGlsZSAoZnJvbSA8IHRvKSB7XG4gICAgICB2YXIgciA9IGZyb207XG4gICAgICB2YXIgdyA9IHRvO1xuICAgICAgdmFyIHBpdm90ID0gYXJyW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqICh0byAtIGZyb20gKyAxKSkgKyBmcm9tXTtcblxuICAgICAgLy8gc3RvcCBpZiB0aGUgcmVhZGVyIGFuZCB3cml0ZXIgbWVldHNcbiAgICAgIHdoaWxlIChyIDwgdykge1xuICAgICAgICAvLyBhcnJbcl0gPj0gcGl2b3RcbiAgICAgICAgaWYgKGNvbXBhcmUoYXJyW3JdLCBwaXZvdCkgPj0gMCkgeyAvLyBwdXQgdGhlIGxhcmdlIHZhbHVlcyBhdCB0aGUgZW5kXG4gICAgICAgICAgdmFyIHRtcCA9IGFyclt3XTtcbiAgICAgICAgICBhcnJbd10gPSBhcnJbcl07XG4gICAgICAgICAgYXJyW3JdID0gdG1wO1xuICAgICAgICAgIC0tdztcbiAgICAgICAgfSBlbHNlIHsgLy8gdGhlIHZhbHVlIGlzIHNtYWxsZXIgdGhhbiB0aGUgcGl2b3QsIHNraXBcbiAgICAgICAgICArK3I7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gaWYgd2Ugc3RlcHBlZCB1cCAocisrKSB3ZSBuZWVkIHRvIHN0ZXAgb25lIGRvd24gKGFycltyXSA+IHBpdm90KVxuICAgICAgaWYgKGNvbXBhcmUoYXJyW3JdLCBwaXZvdCkgPiAwKSB7XG4gICAgICAgIC0tcjtcbiAgICAgIH1cblxuICAgICAgLy8gdGhlIHIgcG9pbnRlciBpcyBvbiB0aGUgZW5kIG9mIHRoZSBmaXJzdCBrIGVsZW1lbnRzXG4gICAgICBpZiAoayA8PSByKSB7XG4gICAgICAgIHRvID0gcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyb20gPSByICsgMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYXJyW2tdO1xuICB9XG59XG5cbmV4cG9ydHMubmFtZSA9ICdwYXJ0aXRpb25TZWxlY3QnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgbWF0cml4ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC9mdW5jdGlvbi9tYXRyaXgnKSk7XG5cbiAgdmFyIFpFUk8gPSBuZXcgdHlwZS5CaWdOdW1iZXIoMCk7XG4gIHZhciBPTkUgPSBuZXcgdHlwZS5CaWdOdW1iZXIoMSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBhcnJheSBmcm9tIGEgcmFuZ2UuXG4gICAqIEJ5IGRlZmF1bHQsIHRoZSByYW5nZSBlbmQgaXMgZXhjbHVkZWQuIFRoaXMgY2FuIGJlIGN1c3RvbWl6ZWQgYnkgcHJvdmlkaW5nXG4gICAqIGFuIGV4dHJhIHBhcmFtZXRlciBgaW5jbHVkZUVuZGAuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgIG1hdGgucmFuZ2Uoc3RyIFssIGluY2x1ZGVFbmRdKSAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIHJhbmdlIGZyb20gYSBzdHJpbmcsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGVyZSB0aGUgc3RyaW5nIGNvbnRhaW5zIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RhcnQsIG9wdGlvbmFsIHN0ZXAsIGFuZCBlbmQsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXBhcmF0ZWQgYnkgYSBjb2xvbi5cbiAgICogICAgIG1hdGgucmFuZ2Uoc3RhcnQsIGVuZCBbLCBpbmNsdWRlRW5kXSkgICAgICAgIC8vIENyZWF0ZSBhIHJhbmdlIHdpdGggc3RhcnQgYW5kXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbmQgYW5kIGEgc3RlcCBzaXplIG9mIDEuXG4gICAqICAgICBtYXRoLnJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXAgWywgaW5jbHVkZUVuZF0pICAvLyBDcmVhdGUgYSByYW5nZSB3aXRoIHN0YXJ0LCBzdGVwLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGVuZC5cbiAgICpcbiAgICogV2hlcmU6XG4gICAqXG4gICAqIC0gYHN0cjogc3RyaW5nYFxuICAgKiAgIEEgc3RyaW5nICdzdGFydDplbmQnIG9yICdzdGFydDpzdGVwOmVuZCdcbiAgICogLSBgc3RhcnQ6IHtudW1iZXIgfCBCaWdOdW1iZXJ9YFxuICAgKiAgIFN0YXJ0IG9mIHRoZSByYW5nZVxuICAgKiAtIGBlbmQ6IG51bWJlciB8IEJpZ051bWJlcmBcbiAgICogICBFbmQgb2YgdGhlIHJhbmdlLCBleGNsdWRlZCBieSBkZWZhdWx0LCBpbmNsdWRlZCB3aGVuIHBhcmFtZXRlciBpbmNsdWRlRW5kPXRydWVcbiAgICogLSBgc3RlcDogbnVtYmVyIHwgQmlnTnVtYmVyYFxuICAgKiAgIFN0ZXAgc2l6ZS4gRGVmYXVsdCB2YWx1ZSBpcyAxLlxuICAgKiAtIGBpbmNsdWRlRW5kOiBib29sZWFuYFxuICAgKiAgIE9wdGlvbiB0byBzcGVjaWZ5IHdoZXRoZXIgdG8gaW5jbHVkZSB0aGUgZW5kIG9yIG5vdC4gRmFsc2UgYnkgZGVmYXVsdC5cbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgICBtYXRoLnJhbmdlKDIsIDYpOyAgICAgICAgLy8gWzIsIDMsIDQsIDVdXG4gICAqICAgICBtYXRoLnJhbmdlKDIsIC0zLCAtMSk7ICAgLy8gWzIsIDEsIDAsIC0xLCAtMl1cbiAgICogICAgIG1hdGgucmFuZ2UoJzI6MTo2Jyk7ICAgICAvLyBbMiwgMywgNCwgNV1cbiAgICogICAgIG1hdGgucmFuZ2UoMiwgNiwgdHJ1ZSk7ICAvLyBbMiwgMywgNCwgNSwgNl1cbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgICBvbmVzLCB6ZXJvcywgc2l6ZSwgc3Vic2V0XG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gYXJncyAgIFBhcmFtZXRlcnMgZGVzY3JpYmluZyB0aGUgcmFuZ2VzIGBzdGFydGAsIGBlbmRgLCBhbmQgb3B0aW9uYWwgYHN0ZXBgLlxuICAgKiBAcmV0dXJuIHtBcnJheSB8IE1hdHJpeH0gcmFuZ2VcbiAgICovXG4gIHZhciByYW5nZSA9IHR5cGVkKCdyYW5nZScsIHtcbiAgICAvLyBUT0RPOiBzaW1wbGlmeSBzaWduYXR1cmVzIHdoZW4gdHlwZWQtZnVuY3Rpb24gc3VwcG9ydHMgZGVmYXVsdCB2YWx1ZXMgYW5kIG9wdGlvbmFsIGFyZ3VtZW50c1xuXG4gICAgLy8gVE9ETzogYSBudW1iZXIgb3IgYm9vbGVhbiBzaG91bGQgbm90IGJlIGNvbnZlcnRlZCB0byBzdHJpbmcgaGVyZVxuICAgICdzdHJpbmcnOiBfc3RyUmFuZ2UsXG4gICAgJ3N0cmluZywgYm9vbGVhbic6IF9zdHJSYW5nZSxcblxuICAgICdudW1iZXIsIG51bWJlcic6ICBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgcmV0dXJuIF9vdXQoX3JhbmdlRXgoc3RhcnQsIGVuZCwgMSkpO1xuICAgIH0sXG4gICAgJ251bWJlciwgbnVtYmVyLCBudW1iZXInOiBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgc3RlcCkge1xuICAgICAgcmV0dXJuIF9vdXQoX3JhbmdlRXgoc3RhcnQsIGVuZCwgc3RlcCkpO1xuICAgIH0sXG4gICAgJ251bWJlciwgbnVtYmVyLCBib29sZWFuJzogZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIGluY2x1ZGVFbmQpIHtcbiAgICAgIHJldHVybiBpbmNsdWRlRW5kXG4gICAgICAgICAgPyBfb3V0KF9yYW5nZUluYyhzdGFydCwgZW5kLCAxKSlcbiAgICAgICAgICA6IF9vdXQoX3JhbmdlRXgoc3RhcnQsIGVuZCwgMSkpO1xuICAgIH0sXG4gICAgJ251bWJlciwgbnVtYmVyLCBudW1iZXIsIGJvb2xlYW4nOiBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgc3RlcCwgaW5jbHVkZUVuZCkge1xuICAgICAgcmV0dXJuIGluY2x1ZGVFbmRcbiAgICAgICAgICA/IF9vdXQoX3JhbmdlSW5jKHN0YXJ0LCBlbmQsIHN0ZXApKVxuICAgICAgICAgIDogX291dChfcmFuZ2VFeChzdGFydCwgZW5kLCBzdGVwKSk7XG4gICAgfSxcblxuICAgICdCaWdOdW1iZXIsIEJpZ051bWJlcic6ICBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgcmV0dXJuIF9vdXQoX2JpZ1JhbmdlRXgoc3RhcnQsIGVuZCwgT05FKSk7XG4gICAgfSxcbiAgICAnQmlnTnVtYmVyLCBCaWdOdW1iZXIsIEJpZ051bWJlcic6IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBzdGVwKSB7XG4gICAgICByZXR1cm4gX291dChfYmlnUmFuZ2VFeChzdGFydCwgZW5kLCBzdGVwKSk7XG4gICAgfSxcbiAgICAnQmlnTnVtYmVyLCBCaWdOdW1iZXIsIGJvb2xlYW4nOiBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgaW5jbHVkZUVuZCkge1xuICAgICAgcmV0dXJuIGluY2x1ZGVFbmRcbiAgICAgICAgICA/IF9vdXQoX2JpZ1JhbmdlSW5jKHN0YXJ0LCBlbmQsIE9ORSkpXG4gICAgICAgICAgOiBfb3V0KF9iaWdSYW5nZUV4KHN0YXJ0LCBlbmQsIE9ORSkpO1xuICAgIH0sXG4gICAgJ0JpZ051bWJlciwgQmlnTnVtYmVyLCBCaWdOdW1iZXIsIGJvb2xlYW4nOiBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgc3RlcCwgaW5jbHVkZUVuZCkge1xuICAgICAgcmV0dXJuIGluY2x1ZGVFbmRcbiAgICAgICAgICA/IF9vdXQoX2JpZ1JhbmdlSW5jKHN0YXJ0LCBlbmQsIHN0ZXApKVxuICAgICAgICAgIDogX291dChfYmlnUmFuZ2VFeChzdGFydCwgZW5kLCBzdGVwKSk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIHJhbmdlLnRvVGV4ID0gJ1xcXFxtYXRocm17JHtuYW1lfX1cXFxcbGVmdCgke2FyZ3N9XFxcXHJpZ2h0KSc7XG5cbiAgcmV0dXJuIHJhbmdlO1xuXG4gIGZ1bmN0aW9uIF9vdXQoYXJyKSB7XG4gICAgcmV0dXJuIGNvbmZpZy5tYXRyaXggPT09ICdBcnJheScgPyBhcnIgOiBtYXRyaXgoYXJyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9zdHJSYW5nZSAoc3RyLCBpbmNsdWRlRW5kKSB7XG4gICAgdmFyIHIgPSBfcGFyc2Uoc3RyKTtcbiAgICBpZiAoIXIpe1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdTdHJpbmcgXCInICsgc3RyICsgJ1wiIGlzIG5vIHZhbGlkIHJhbmdlJyk7XG4gICAgfVxuXG4gICAgdmFyIGZuO1xuICAgIGlmIChjb25maWcubnVtYmVyID09PSAnQmlnTnVtYmVyJykge1xuICAgICAgZm4gPSBpbmNsdWRlRW5kID8gX2JpZ1JhbmdlSW5jIDogX2JpZ1JhbmdlRXg7XG4gICAgICByZXR1cm4gX291dChmbihcbiAgICAgICAgICBuZXcgdHlwZS5CaWdOdW1iZXIoci5zdGFydCksXG4gICAgICAgICAgbmV3IHR5cGUuQmlnTnVtYmVyKHIuZW5kKSxcbiAgICAgICAgICBuZXcgdHlwZS5CaWdOdW1iZXIoci5zdGVwKSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZuID0gaW5jbHVkZUVuZCA/IF9yYW5nZUluYyA6IF9yYW5nZUV4O1xuICAgICAgcmV0dXJuIF9vdXQoZm4oci5zdGFydCwgci5lbmQsIHIuc3RlcCkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSByYW5nZSB3aXRoIG51bWJlcnMuIEVuZCBpcyBleGNsdWRlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuZFxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RlcFxuICAgKiBAcmV0dXJucyB7QXJyYXl9IHJhbmdlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfcmFuZ2VFeCAoc3RhcnQsIGVuZCwgc3RlcCkge1xuICAgIHZhciBhcnJheSA9IFtdLFxuICAgICAgICB4ID0gc3RhcnQ7XG4gICAgaWYgKHN0ZXAgPiAwKSB7XG4gICAgICB3aGlsZSAoeCA8IGVuZCkge1xuICAgICAgICBhcnJheS5wdXNoKHgpO1xuICAgICAgICB4ICs9IHN0ZXA7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0ZXAgPCAwKSB7XG4gICAgICB3aGlsZSAoeCA+IGVuZCkge1xuICAgICAgICBhcnJheS5wdXNoKHgpO1xuICAgICAgICB4ICs9IHN0ZXA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHJhbmdlIHdpdGggbnVtYmVycy4gRW5kIGlzIGluY2x1ZGVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFxuICAgKiBAcGFyYW0ge251bWJlcn0gZW5kXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwXG4gICAqIEByZXR1cm5zIHtBcnJheX0gcmFuZ2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9yYW5nZUluYyAoc3RhcnQsIGVuZCwgc3RlcCkge1xuICAgIHZhciBhcnJheSA9IFtdLFxuICAgICAgICB4ID0gc3RhcnQ7XG4gICAgaWYgKHN0ZXAgPiAwKSB7XG4gICAgICB3aGlsZSAoeCA8PSBlbmQpIHtcbiAgICAgICAgYXJyYXkucHVzaCh4KTtcbiAgICAgICAgeCArPSBzdGVwO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzdGVwIDwgMCkge1xuICAgICAgd2hpbGUgKHggPj0gZW5kKSB7XG4gICAgICAgIGFycmF5LnB1c2goeCk7XG4gICAgICAgIHggKz0gc3RlcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgcmFuZ2Ugd2l0aCBiaWcgbnVtYmVycy4gRW5kIGlzIGV4Y2x1ZGVkXG4gICAqIEBwYXJhbSB7QmlnTnVtYmVyfSBzdGFydFxuICAgKiBAcGFyYW0ge0JpZ051bWJlcn0gZW5kXG4gICAqIEBwYXJhbSB7QmlnTnVtYmVyfSBzdGVwXG4gICAqIEByZXR1cm5zIHtBcnJheX0gcmFuZ2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9iaWdSYW5nZUV4IChzdGFydCwgZW5kLCBzdGVwKSB7XG4gICAgdmFyIGFycmF5ID0gW10sXG4gICAgICAgIHggPSBzdGFydDtcbiAgICBpZiAoc3RlcC5ndChaRVJPKSkge1xuICAgICAgd2hpbGUgKHgubHQoZW5kKSkge1xuICAgICAgICBhcnJheS5wdXNoKHgpO1xuICAgICAgICB4ID0geC5wbHVzKHN0ZXApO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzdGVwLmx0KFpFUk8pKSB7XG4gICAgICB3aGlsZSAoeC5ndChlbmQpKSB7XG4gICAgICAgIGFycmF5LnB1c2goeCk7XG4gICAgICAgIHggPSB4LnBsdXMoc3RlcCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHJhbmdlIHdpdGggYmlnIG51bWJlcnMuIEVuZCBpcyBpbmNsdWRlZFxuICAgKiBAcGFyYW0ge0JpZ051bWJlcn0gc3RhcnRcbiAgICogQHBhcmFtIHtCaWdOdW1iZXJ9IGVuZFxuICAgKiBAcGFyYW0ge0JpZ051bWJlcn0gc3RlcFxuICAgKiBAcmV0dXJucyB7QXJyYXl9IHJhbmdlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfYmlnUmFuZ2VJbmMgKHN0YXJ0LCBlbmQsIHN0ZXApIHtcbiAgICB2YXIgYXJyYXkgPSBbXSxcbiAgICAgICAgeCA9IHN0YXJ0O1xuICAgIGlmIChzdGVwLmd0KFpFUk8pKSB7XG4gICAgICB3aGlsZSAoeC5sdGUoZW5kKSkge1xuICAgICAgICBhcnJheS5wdXNoKHgpO1xuICAgICAgICB4ID0geC5wbHVzKHN0ZXApO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzdGVwLmx0KFpFUk8pKSB7XG4gICAgICB3aGlsZSAoeC5ndGUoZW5kKSkge1xuICAgICAgICBhcnJheS5wdXNoKHgpO1xuICAgICAgICB4ID0geC5wbHVzKHN0ZXApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBhIHN0cmluZyBpbnRvIGEgcmFuZ2UsXG4gICAqIFRoZSBzdHJpbmcgY29udGFpbnMgdGhlIHN0YXJ0LCBvcHRpb25hbCBzdGVwLCBhbmQgZW5kLCBzZXBhcmF0ZWQgYnkgYSBjb2xvbi5cbiAgICogSWYgdGhlIHN0cmluZyBkb2VzIG5vdCBjb250YWluIGEgdmFsaWQgcmFuZ2UsIG51bGwgaXMgcmV0dXJuZWQuXG4gICAqIEZvciBleGFtcGxlIHN0cj0nMDoyOjExJy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgKiBAcmV0dXJuIHt7c3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIsIHN0ZXA6IG51bWJlcn0gfCBudWxsfSByYW5nZSBPYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIHN0YXJ0LCBlbmQsIHN0ZXBcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9wYXJzZSAoc3RyKSB7XG4gICAgdmFyIGFyZ3MgPSBzdHIuc3BsaXQoJzonKTtcblxuICAgIC8vIG51bWJlclxuICAgIHZhciBudW1zID0gYXJncy5tYXAoZnVuY3Rpb24gKGFyZykge1xuICAgICAgLy8gdXNlIE51bWJlciBhbmQgbm90IHBhcnNlRmxvYXQgYXMgTnVtYmVyIHJldHVybnMgTmFOIG9uIGludmFsaWQgZ2FyYmFnZSBpbiB0aGUgc3RyaW5nXG4gICAgICByZXR1cm4gTnVtYmVyKGFyZyk7XG4gICAgfSk7XG5cbiAgICB2YXIgaW52YWxpZCA9IG51bXMuc29tZShmdW5jdGlvbiAobnVtKSB7XG4gICAgICByZXR1cm4gaXNOYU4obnVtKTtcbiAgICB9KTtcbiAgICBpZihpbnZhbGlkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKG51bXMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhcnQ6IG51bXNbMF0sXG4gICAgICAgICAgZW5kOiBudW1zWzFdLFxuICAgICAgICAgIHN0ZXA6IDFcbiAgICAgICAgfTtcblxuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXJ0OiBudW1zWzBdLFxuICAgICAgICAgIGVuZDogbnVtc1syXSxcbiAgICAgICAgICBzdGVwOiBudW1zWzFdXG4gICAgICAgIH07XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG59XG5cbmV4cG9ydHMubmFtZSA9ICdyYW5nZSc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRGltZW5zaW9uRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9lcnJvci9EaW1lbnNpb25FcnJvcicpO1xudmFyIEFyZ3VtZW50c0Vycm9yID0gcmVxdWlyZSgnLi4vLi4vZXJyb3IvQXJndW1lbnRzRXJyb3InKTtcblxudmFyIGlzSW50ZWdlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL251bWJlcicpLmlzSW50ZWdlcjtcbnZhciBmb3JtYXQgPSByZXF1aXJlKCcuLi8uLi91dGlscy9zdHJpbmcnKS5mb3JtYXQ7XG52YXIgY2xvbmUgPSByZXF1aXJlKCcuLi8uLi91dGlscy9vYmplY3QnKS5jbG9uZTtcbnZhciBhcnJheSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2FycmF5Jyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIG1hdHJpeCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvZnVuY3Rpb24vbWF0cml4JykpO1xuXG4gIC8qKlxuICAgKiBSZXNpemUgYSBtYXRyaXhcbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICAgbWF0aC5yZXNpemUoeCwgc2l6ZSlcbiAgICogICAgIG1hdGgucmVzaXplKHgsIHNpemUsIGRlZmF1bHRWYWx1ZSlcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgICBtYXRoLnJlc2l6ZShbMSwgMiwgMywgNCwgNV0sIFszXSk7IC8vIHJldHVybnMgQXJyYXkgIFsxLCAyLCAzXVxuICAgKiAgICAgbWF0aC5yZXNpemUoWzEsIDIsIDNdLCBbNV0sIDApOyAgICAvLyByZXR1cm5zIEFycmF5ICBbMSwgMiwgMywgMCwgMF1cbiAgICogICAgIG1hdGgucmVzaXplKDIsIFsyLCAzXSwgMCk7ICAgICAgICAgLy8gcmV0dXJucyBNYXRyaXggW1syLCAwLCAwXSwgWzAsIDAsIDBdXVxuICAgKiAgICAgbWF0aC5yZXNpemUoXCJoZWxsb1wiLCBbOF0sIFwiIVwiKTsgICAgLy8gcmV0dXJucyBzdHJpbmcgJ2hlbGxvISEhJ1xuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgIHNpemUsIHNxdWVlemUsIHN1YnNldFxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5IHwgTWF0cml4IHwgKn0geCAgICAgICAgICAgICBNYXRyaXggdG8gYmUgcmVzaXplZFxuICAgKiBAcGFyYW0ge0FycmF5IHwgTWF0cml4fSBzaXplICAgICAgICAgICAgICBPbmUgZGltZW5zaW9uYWwgYXJyYXkgd2l0aCBudW1iZXJzXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgc3RyaW5nfSBbZGVmYXVsdFZhbHVlPTBdIFplcm8gYnkgZGVmYXVsdCwgZXhjZXB0IGluXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2Ugb2YgYSBzdHJpbmcsIGluIHRoYXQgY2FzZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWUgPSAnICdcbiAgICogQHJldHVybiB7KiB8IEFycmF5IHwgTWF0cml4fSBBIHJlc2l6ZWQgY2xvbmUgb2YgbWF0cml4IGB4YFxuICAgKi9cbiAgLy8gVE9ETzogcmV3b3JrIHJlc2l6ZSB0byBhIHR5cGVkLWZ1bmN0aW9uXG4gIHZhciByZXNpemUgPSBmdW5jdGlvbiByZXNpemUgKHgsIHNpemUsIGRlZmF1bHRWYWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDIgJiYgYXJndW1lbnRzLmxlbmd0aCAhPSAzKSB7XG4gICAgICB0aHJvdyBuZXcgQXJndW1lbnRzRXJyb3IoJ3Jlc2l6ZScsIGFyZ3VtZW50cy5sZW5ndGgsIDIsIDMpO1xuICAgIH1cblxuICAgIGlmIChzaXplICYmIHNpemUuaXNNYXRyaXggPT09IHRydWUpIHtcbiAgICAgIHNpemUgPSBzaXplLnZhbHVlT2YoKTsgLy8gZ2V0IEFycmF5XG4gICAgfVxuXG4gICAgaWYgKHNpemUubGVuZ3RoICYmIHNpemVbMF0gJiYgc2l6ZVswXS5pc0JpZ051bWJlciA9PT0gdHJ1ZSkge1xuICAgICAgLy8gY29udmVydCBiaWdudW1iZXJzIHRvIG51bWJlcnNcbiAgICAgIHNpemUgPSBzaXplLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZS5pc0JpZ051bWJlciA9PT0gdHJ1ZSkgPyB2YWx1ZS50b051bWJlcigpIDogdmFsdWU7XG4gICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgLy8gY2hlY2sgeCBpcyBhIE1hdHJpeFxuICAgIGlmICh4ICYmIHguaXNNYXRyaXggPT09IHRydWUpIHtcbiAgICAgIC8vIHVzZSBvcHRpbWl6ZWQgbWF0cml4IGltcGxlbWVudGF0aW9uLCByZXR1cm4gY29weVxuICAgICAgcmV0dXJuIHgucmVzaXplKHNpemUsIGRlZmF1bHRWYWx1ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIFxuICAgIGlmICh0eXBlb2YgeCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIHJlc2l6ZSBzdHJpbmdcbiAgICAgIHJldHVybiBfcmVzaXplU3RyaW5nKHgsIHNpemUsIGRlZmF1bHRWYWx1ZSk7XG4gICAgfVxuICAgIFxuICAgIC8vIGNoZWNrIHJlc3VsdCBzaG91bGQgYmUgYSBtYXRyaXhcbiAgICB2YXIgYXNNYXRyaXggPSBBcnJheS5pc0FycmF5KHgpID8gZmFsc2UgOiAoY29uZmlnLm1hdHJpeCAhPT0gJ0FycmF5Jyk7XG5cbiAgICBpZiAoc2l6ZS5sZW5ndGggPT0gMCkge1xuICAgICAgLy8gb3V0cHV0IGEgc2NhbGFyXG4gICAgICB3aGlsZSAoQXJyYXkuaXNBcnJheSh4KSkge1xuICAgICAgICB4ID0geFswXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNsb25lKHgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIG91dHB1dCBhbiBhcnJheS9tYXRyaXhcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh4KSkge1xuICAgICAgICB4ID0gW3hdO1xuICAgICAgfVxuICAgICAgeCA9IGNsb25lKHgpO1xuXG4gICAgICB2YXIgcmVzID0gYXJyYXkucmVzaXplKHgsIHNpemUsIGRlZmF1bHRWYWx1ZSk7XG4gICAgICByZXR1cm4gYXNNYXRyaXggPyBtYXRyaXgocmVzKSA6IHJlcztcbiAgICB9XG4gIH07XG5cbiAgcmVzaXplLnRvVGV4ID0gJ1xcXFxtYXRocm17JHtuYW1lfX1cXFxcbGVmdCgke2FyZ3N9XFxcXHJpZ2h0KSc7XG5cbiAgcmV0dXJuIHJlc2l6ZTtcblxuICAvKipcbiAgICogUmVzaXplIGEgc3RyaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAgICogQHBhcmFtIHtudW1iZXJbXX0gc2l6ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2RlZmF1bHRDaGFyPScgJ11cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9yZXNpemVTdHJpbmcoc3RyLCBzaXplLCBkZWZhdWx0Q2hhcikge1xuICAgIGlmIChkZWZhdWx0Q2hhciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIGRlZmF1bHRDaGFyICE9PSAnc3RyaW5nJyB8fCBkZWZhdWx0Q2hhci5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU2luZ2xlIGNoYXJhY3RlciBleHBlY3RlZCBhcyBkZWZhdWx0VmFsdWUnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBkZWZhdWx0Q2hhciA9ICcgJztcbiAgICB9XG5cbiAgICBpZiAoc2l6ZS5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBEaW1lbnNpb25FcnJvcihzaXplLmxlbmd0aCwgMSk7XG4gICAgfVxuICAgIHZhciBsZW4gPSBzaXplWzBdO1xuICAgIGlmICh0eXBlb2YgbGVuICE9PSAnbnVtYmVyJyB8fCAhaXNJbnRlZ2VyKGxlbikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc2l6ZSwgbXVzdCBjb250YWluIHBvc2l0aXZlIGludGVnZXJzICcgK1xuICAgICAgICAgICcoc2l6ZTogJyArIGZvcm1hdChzaXplKSArICcpJyk7XG4gICAgfVxuXG4gICAgaWYgKHN0ci5sZW5ndGggPiBsZW4pIHtcbiAgICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIGxlbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0ci5sZW5ndGggPCBsZW4pIHtcbiAgICAgIHZhciByZXMgPSBzdHI7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBsZW4gLSBzdHIubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICByZXMgKz0gZGVmYXVsdENoYXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMubmFtZSA9ICdyZXNpemUnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFycmF5ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYXJyYXknKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgbWF0cml4ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC9mdW5jdGlvbi9tYXRyaXgnKSk7XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgc2l6ZSBvZiBhIG1hdHJpeCBvciBzY2FsYXIuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgIG1hdGguc2l6ZSh4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgIG1hdGguc2l6ZSgyLjMpOyAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgW11cbiAgICogICAgIG1hdGguc2l6ZSgnaGVsbG8gd29ybGQnKTsgICAgICAgIC8vIHJldHVybnMgWzExXVxuICAgKlxuICAgKiAgICAgdmFyIEEgPSBbWzEsIDIsIDNdLCBbNCwgNSwgNl1dO1xuICAgKiAgICAgbWF0aC5zaXplKEEpOyAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBbMiwgM11cbiAgICogICAgIG1hdGguc2l6ZShtYXRoLnJhbmdlKDEsNikpOyAgICAgIC8vIHJldHVybnMgWzVdXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICAgcmVzaXplLCBzcXVlZXplLCBzdWJzZXRcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFuIHwgbnVtYmVyIHwgQ29tcGxleCB8IFVuaXQgfCBzdHJpbmcgfCBBcnJheSB8IE1hdHJpeH0geCAgQSBtYXRyaXhcbiAgICogQHJldHVybiB7QXJyYXkgfCBNYXRyaXh9IEEgdmVjdG9yIHdpdGggc2l6ZSBvZiBgeGAuXG4gICAqL1xuICB2YXIgc2l6ZSA9IHR5cGVkKCdzaXplJywge1xuICAgICdNYXRyaXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgLy8gVE9ETzogcmV0dXJuIHRoZSBzYW1lIG1hdHJpeCB0eXBlIGFzIHRoZSBpbnB1dFxuICAgICAgcmV0dXJuIG1hdHJpeCh4LnNpemUoKSk7XG4gICAgfSxcblxuICAgICdBcnJheSc6IGFycmF5LnNpemUsXG5cbiAgICAnc3RyaW5nJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiAoY29uZmlnLm1hdHJpeCA9PT0gJ0FycmF5JykgPyBbeC5sZW5ndGhdIDogbWF0cml4KFt4Lmxlbmd0aF0pO1xuICAgIH0sXG5cbiAgICAnbnVtYmVyIHwgQ29tcGxleCB8IEJpZ051bWJlciB8IFVuaXQgfCBib29sZWFuIHwgbnVsbCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAvLyBzY2FsYXJcbiAgICAgIHJldHVybiAoY29uZmlnLm1hdHJpeCA9PT0gJ0FycmF5JykgPyBbXSA6IG1hdHJpeChbXSk7XG4gICAgfVxuICB9KTtcblxuICBzaXplLnRvVGV4ID0gJ1xcXFxtYXRocm17JHtuYW1lfX1cXFxcbGVmdCgke2FyZ3N9XFxcXHJpZ2h0KSc7XG5cbiAgcmV0dXJuIHNpemU7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdzaXplJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzaXplID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYXJyYXknKS5zaXplO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBtYXRyaXggPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L2Z1bmN0aW9uL21hdHJpeCcpKTtcbiAgdmFyIGFzYyA9IGxvYWQocmVxdWlyZSgnLi4vcmVsYXRpb25hbC9jb21wYXJlJykpO1xuICB2YXIgZGVzYyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIC1hc2MoYSwgYik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNvcnQgdGhlIGl0ZW1zIGluIGEgbWF0cml4LlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguc29ydCh4KVxuICAgKiAgICBtYXRoLnNvcnQoeCwgY29tcGFyZSlcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGguc29ydChbNSwgMTAsIDFdKTsgLy8gcmV0dXJucyBbMSwgNSwgMTBdXG4gICAqICAgIG1hdGguc29ydChbJ0MnLCAnQicsICdBJywgJ0QnXSk7IC8vIHJldHVybnMgWydBJywgJ0InLCAnQycsICdEJ11cbiAgICpcbiAgICogICAgZnVuY3Rpb24gc29ydEJ5TGVuZ3RoIChhLCBiKSB7XG4gICAqICAgICAgcmV0dXJuIGEubGVuZ3RoIC0gYi5sZW5ndGg7XG4gICAqICAgIH1cbiAgICogICAgbWF0aC5zb3J0KFsnTGFuZ2RvbicsICdUb20nLCAnU2FyYSddLCBzb3J0QnlMZW5ndGgpOyAvLyByZXR1cm5zIFsnVG9tJywgJ1NhcmEnLCAnTGFuZ2RvbiddXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBmaWx0ZXIsIGZvckVhY2gsIG1hcFxuICAgKlxuICAgKiBAcGFyYW0ge01hdHJpeCB8IEFycmF5fSB4ICAgIEEgb25lIGRpbWVuc2lvbmFsIG1hdHJpeCBvciBhcnJheSB0byBzb3J0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb24gfCAnYXNjJyB8ICdkZXNjJ30gW2NvbXBhcmU9J2FzYyddXG4gICAqICAgICAgICBBbiBvcHRpb25hbCBfY29tcGFyYXRvciBmdW5jdGlvbi4gVGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCBhc1xuICAgKiAgICAgICAgYGNvbXBhcmUoYSwgYilgLCBhbmQgbXVzdCByZXR1cm4gMSB3aGVuIGEgPiBiLCAtMSB3aGVuIGEgPCBiLFxuICAgKiAgICAgICAgYW5kIDAgd2hlbiBhID09IGIuXG4gICAqIEByZXR1cm4ge01hdHJpeCB8IEFycmF5fSBSZXR1cm5zIHRoZSBzb3J0ZWQgbWF0cml4LlxuICAgKi9cbiAgdmFyIHNvcnQgPSB0eXBlZCgnc29ydCcsIHtcbiAgICAnQXJyYXknOiBmdW5jdGlvbiAoeCkge1xuICAgICAgX2FycmF5SXNWZWN0b3IoeCk7XG4gICAgICByZXR1cm4geC5zb3J0KGFzYyk7XG4gICAgfSxcblxuICAgICdNYXRyaXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgX21hdHJpeElzVmVjdG9yKHgpO1xuICAgICAgcmV0dXJuIG1hdHJpeCh4LnRvQXJyYXkoKS5zb3J0KGFzYyksIHguc3RvcmFnZSgpKTtcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBmdW5jdGlvbic6IGZ1bmN0aW9uICh4LCBfY29tcGFyYXRvcikge1xuICAgICAgX2FycmF5SXNWZWN0b3IoeCk7XG4gICAgICByZXR1cm4geC5zb3J0KF9jb21wYXJhdG9yKTtcbiAgICB9LFxuXG4gICAgJ01hdHJpeCwgZnVuY3Rpb24nOiBmdW5jdGlvbiAoeCwgX2NvbXBhcmF0b3IpIHtcbiAgICAgIF9tYXRyaXhJc1ZlY3Rvcih4KTtcbiAgICAgIHJldHVybiBtYXRyaXgoeC50b0FycmF5KCkuc29ydChfY29tcGFyYXRvciksIHguc3RvcmFnZSgpKTtcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBzdHJpbmcnOiBmdW5jdGlvbiAoeCwgb3JkZXIpIHtcbiAgICAgIF9hcnJheUlzVmVjdG9yKHgpO1xuICAgICAgcmV0dXJuIHguc29ydChfY29tcGFyYXRvcihvcmRlcikpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4LCBzdHJpbmcnOiBmdW5jdGlvbiAoeCwgb3JkZXIpIHtcbiAgICAgIF9tYXRyaXhJc1ZlY3Rvcih4KTtcbiAgICAgIHJldHVybiBtYXRyaXgoeC50b0FycmF5KCkuc29ydChfY29tcGFyYXRvcihvcmRlcikpLCB4LnN0b3JhZ2UoKSk7XG4gICAgfVxuICB9KTtcblxuICBzb3J0LnRvVGV4ID0gJ1xcXFxtYXRocm17JHtuYW1lfX1cXFxcbGVmdCgke2FyZ3N9XFxcXHJpZ2h0KSc7XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY29tcGFyYXRvciBmb3IgZ2l2ZW4gb3JkZXIgKCdhc2MnIG9yICdkZXNjJylcbiAgICogQHBhcmFtIHsnYXNjJyB8ICdkZXNjJ30gb3JkZXJcbiAgICogQHJldHVybiB7RnVuY3Rpb259IFJldHVybnMgYSBfY29tcGFyYXRvciBmdW5jdGlvblxuICAgKi9cbiAgZnVuY3Rpb24gX2NvbXBhcmF0b3IgKG9yZGVyKSB7XG4gICAgaWYgKG9yZGVyID09PSAnYXNjJykge1xuICAgICAgcmV0dXJuIGFzYztcbiAgICB9XG4gICAgZWxzZSBpZiAob3JkZXIgPT09ICdkZXNjJykge1xuICAgICAgcmV0dXJuIGRlc2M7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdHJpbmcgXCJhc2NcIiBvciBcImRlc2NcIiBleHBlY3RlZCcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSB3aGV0aGVyIGFuIGFycmF5IGlzIG9uZSBkaW1lbnNpb25hbFxuICAgKiBUaHJvd3MgYW4gZXJyb3Igd2hlbiB0aGlzIGlzIG5vdCB0aGUgY2FzZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX2FycmF5SXNWZWN0b3IgKGFycmF5KSB7XG4gICAgaWYgKHNpemUoYXJyYXkpLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmUgZGltZW5zaW9uYWwgYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgd2hldGhlciBhIG1hdHJpeCBpcyBvbmUgZGltZW5zaW9uYWxcbiAgICogVGhyb3dzIGFuIGVycm9yIHdoZW4gdGhpcyBpcyBub3QgdGhlIGNhc2VcbiAgICogQHBhcmFtIHtNYXRyaXh9IG1hdHJpeFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX21hdHJpeElzVmVjdG9yIChtYXRyaXgpIHtcbiAgICBpZiAobWF0cml4LnNpemUoKS5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT25lIGRpbWVuc2lvbmFsIG1hdHJpeCBleHBlY3RlZCcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzb3J0O1xufVxuXG5leHBvcnRzLm5hbWUgPSAnc29ydCc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgb2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0Jyk7XG52YXIgYXJyYXkgPSByZXF1aXJlKCcuLi8uLi91dGlscy9hcnJheScpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBtYXRyaXggPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L2Z1bmN0aW9uL21hdHJpeCcpKTtcblxuICAvKipcbiAgICogU3F1ZWV6ZSBhIG1hdHJpeCwgcmVtb3ZlIGlubmVyIGFuZCBvdXRlciBzaW5nbGV0b24gZGltZW5zaW9ucyBmcm9tIGEgbWF0cml4LlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgICBtYXRoLnNxdWVlemUoeClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgICBtYXRoLnNxdWVlemUoWzNdKTsgICAgICAgICAgIC8vIHJldHVybnMgM1xuICAgKiAgICAgbWF0aC5zcXVlZXplKFtbM11dKTsgICAgICAgICAvLyByZXR1cm5zIDNcbiAgICpcbiAgICogICAgIHZhciBBID0gbWF0aC56ZXJvcygzLCAxKTsgICAgLy8gcmV0dXJucyBbWzBdLCBbMF0sIFswXV0gKHNpemUgM3gxKVxuICAgKiAgICAgbWF0aC5zcXVlZXplKEEpOyAgICAgICAgICAgICAvLyByZXR1cm5zIFswLCAwLCAwXSAoc2l6ZSAzKVxuICAgKlxuICAgKiAgICAgdmFyIEIgPSBtYXRoLnplcm9zKDEsIDMpOyAgICAvLyByZXR1cm5zIFtbMCwgMCwgMF1dIChzaXplIDF4MylcbiAgICogICAgIG1hdGguc3F1ZWV6ZShCKTsgICAgICAgICAgICAgLy8gcmV0dXJucyBbMCwgMCwgMF0gKHNpemUgMylcbiAgICpcbiAgICogICAgIC8vIG9ubHkgaW5uZXIgYW5kIG91dGVyIGRpbWVuc2lvbnMgYXJlIHJlbW92ZWRcbiAgICogICAgIHZhciBDID0gbWF0aC56ZXJvcygyLCAxLCAzKTsgLy8gcmV0dXJucyBbW1swLCAwLCAwXV0sIFtbMCwgMCwgMF1dXSAoc2l6ZSAyeDF4MylcbiAgICogICAgIG1hdGguc3F1ZWV6ZShDKTsgICAgICAgICAgICAgLy8gcmV0dXJucyBbW1swLCAwLCAwXV0sIFtbMCwgMCwgMF1dXSAoc2l6ZSAyeDF4MylcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgICBzdWJzZXRcbiAgICpcbiAgICogQHBhcmFtIHtNYXRyaXggfCBBcnJheX0geCAgICAgIE1hdHJpeCB0byBiZSBzcXVlZXplZFxuICAgKiBAcmV0dXJuIHtNYXRyaXggfCBBcnJheX0gU3F1ZWV6ZWQgbWF0cml4XG4gICAqL1xuICB2YXIgc3F1ZWV6ZSA9IHR5cGVkKCdzcXVlZXplJywge1xuICAgICdBcnJheSc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gYXJyYXkuc3F1ZWV6ZShvYmplY3QuY2xvbmUoeCkpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHZhciByZXMgPSBhcnJheS5zcXVlZXplKHgudG9BcnJheSgpKTtcbiAgICAgIC8vIEZJWE1FOiByZXR1cm4gdGhlIHNhbWUgdHlwZSBvZiBtYXRyaXggYXMgdGhlIGlucHV0XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShyZXMpID8gbWF0cml4KHJlcykgOiByZXM7XG4gICAgfSxcblxuICAgICdhbnknOiBmdW5jdGlvbiAoeCkge1xuICAgICAgLy8gc2NhbGFyXG4gICAgICByZXR1cm4gb2JqZWN0LmNsb25lKHgpO1xuICAgIH1cbiAgfSk7XG5cbiAgc3F1ZWV6ZS50b1RleCA9ICdcXFxcbWF0aHJteyR7bmFtZX19XFxcXGxlZnQoJHthcmdzfVxcXFxyaWdodCknO1xuXG4gIHJldHVybiBzcXVlZXplO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnc3F1ZWV6ZSc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2xvbmUgPSByZXF1aXJlKCcuLi8uLi91dGlscy9vYmplY3QnKS5jbG9uZTtcbnZhciB2YWxpZGF0ZUluZGV4ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYXJyYXknKS52YWxpZGF0ZUluZGV4O1xudmFyIERpbWVuc2lvbkVycm9yID0gcmVxdWlyZSgnLi4vLi4vZXJyb3IvRGltZW5zaW9uRXJyb3InKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgbWF0cml4ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC9mdW5jdGlvbi9tYXRyaXgnKSk7XG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgYSBzdWJzZXQgb2YgYSBtYXRyaXggb3Igc3RyaW5nLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqICAgICBtYXRoLnN1YnNldCh2YWx1ZSwgaW5kZXgpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXRyaWV2ZSBhIHN1YnNldFxuICAgKiAgICAgbWF0aC5zdWJzZXQodmFsdWUsIGluZGV4LCByZXBsYWNlbWVudCBbLCBkZWZhdWx0VmFsdWVdKSAgLy8gcmVwbGFjZSBhIHN1YnNldFxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgIC8vIGdldCBhIHN1YnNldFxuICAgKiAgICAgdmFyIGQgPSBbWzEsIDJdLCBbMywgNF1dO1xuICAgKiAgICAgbWF0aC5zdWJzZXQoZCwgbWF0aC5pbmRleCgxLCAwKSk7ICAgICAgICAvLyByZXR1cm5zIDNcbiAgICogICAgIG1hdGguc3Vic2V0KGQsIG1hdGguaW5kZXgoWzAsIDJdLCAxKSk7ICAgLy8gcmV0dXJucyBbWzJdLCBbNF1dXG4gICAqXG4gICAqICAgICAvLyByZXBsYWNlIGEgc3Vic2V0XG4gICAqICAgICB2YXIgZSA9IFtdO1xuICAgKiAgICAgdmFyIGYgPSBtYXRoLnN1YnNldChlLCBtYXRoLmluZGV4KDAsIFswLCAyXSksIFs1LCA2XSk7ICAvLyBmID0gW1s1LCA2XV1cbiAgICogICAgIHZhciBnID0gbWF0aC5zdWJzZXQoZiwgbWF0aC5pbmRleCgxLCAxKSwgNywgMCk7ICAgICAgICAgLy8gZyA9IFtbNSwgNl0sIFswLCA3XV1cbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgICBzaXplLCByZXNpemUsIHNxdWVlemUsIGluZGV4XG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXkgfCBNYXRyaXggfCBzdHJpbmd9IG1hdHJpeCAgQW4gYXJyYXksIG1hdHJpeCwgb3Igc3RyaW5nXG4gICAqIEBwYXJhbSB7SW5kZXh9IGluZGV4ICAgICAgICAgICAgICAgICAgICAgQW4gaW5kZXggY29udGFpbmluZyByYW5nZXMgZm9yIGVhY2hcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25cbiAgICogQHBhcmFtIHsqfSBbcmVwbGFjZW1lbnRdICAgICAgICAgICAgICAgICBBbiBhcnJheSwgbWF0cml4LCBvciBzY2FsYXIuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgcHJvdmlkZWQsIHRoZSBzdWJzZXQgaXMgcmVwbGFjZWQgd2l0aCByZXBsYWNlbWVudC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBub3QgcHJvdmlkZWQsIHRoZSBzdWJzZXQgaXMgcmV0dXJuZWRcbiAgICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlPXVuZGVmaW5lZF0gICAgICBEZWZhdWx0IHZhbHVlLCBmaWxsZWQgaW4gb24gbmV3IGVudHJpZXMgd2hlblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBtYXRyaXggaXMgcmVzaXplZC4gSWYgbm90IHByb3ZpZGVkLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGgubWF0cml4IGVsZW1lbnRzIHdpbGwgYmUgbGVmdCB1bmRlZmluZWQuXG4gICAqIEByZXR1cm4ge0FycmF5IHwgTWF0cml4IHwgc3RyaW5nfSBFaXRoZXIgdGhlIHJldHJpZXZlZCBzdWJzZXQgb3IgdGhlIHVwZGF0ZWQgbWF0cml4LlxuICAgKi9cbiAgdmFyIHN1YnNldCA9IHR5cGVkKCdzdWJzZXQnLCB7XG4gICAgLy8gZ2V0IHN1YnNldFxuICAgICdBcnJheSwgSW5kZXgnOiBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICB2YXIgbSA9IG1hdHJpeCh2YWx1ZSk7XG4gICAgICB2YXIgc3Vic2V0ID0gbS5zdWJzZXQoaW5kZXgpOyAgICAgICAvLyByZXR1cm5zIGEgTWF0cml4XG4gICAgICByZXR1cm4gc3Vic2V0ICYmIHN1YnNldC52YWx1ZU9mKCk7ICAvLyByZXR1cm4gYW4gQXJyYXkgKGxpa2UgdGhlIGlucHV0KVxuICAgIH0sXG5cbiAgICAnTWF0cml4LCBJbmRleCc6IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5zdWJzZXQoaW5kZXgpO1xuICAgIH0sXG5cbiAgICAnT2JqZWN0LCBJbmRleCc6IF9nZXRPYmplY3RQcm9wZXJ0eSxcblxuICAgICdzdHJpbmcsIEluZGV4JzogX2dldFN1YnN0cmluZyxcblxuICAgIC8vIHNldCBzdWJzZXRcbiAgICAnQXJyYXksIEluZGV4LCBhbnknOiBmdW5jdGlvbiAodmFsdWUsIGluZGV4LCByZXBsYWNlbWVudCkge1xuICAgICAgcmV0dXJuIG1hdHJpeChjbG9uZSh2YWx1ZSkpXG4gICAgICAgICAgLnN1YnNldChpbmRleCwgcmVwbGFjZW1lbnQsIHVuZGVmaW5lZClcbiAgICAgICAgICAudmFsdWVPZigpO1xuICAgIH0sXG5cbiAgICAnQXJyYXksIEluZGV4LCBhbnksIGFueSc6IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIHJlcGxhY2VtZW50LCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHJldHVybiBtYXRyaXgoY2xvbmUodmFsdWUpKVxuICAgICAgICAgIC5zdWJzZXQoaW5kZXgsIHJlcGxhY2VtZW50LCBkZWZhdWx0VmFsdWUpXG4gICAgICAgICAgLnZhbHVlT2YoKTtcbiAgICB9LFxuXG4gICAgJ01hdHJpeCwgSW5kZXgsIGFueSc6IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIHJlcGxhY2VtZW50KSB7XG4gICAgICByZXR1cm4gdmFsdWUuY2xvbmUoKS5zdWJzZXQoaW5kZXgsIHJlcGxhY2VtZW50KTtcbiAgICB9LFxuXG4gICAgJ01hdHJpeCwgSW5kZXgsIGFueSwgYW55JzogZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgcmVwbGFjZW1lbnQsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlLmNsb25lKCkuc3Vic2V0KGluZGV4LCByZXBsYWNlbWVudCwgZGVmYXVsdFZhbHVlKTtcbiAgICB9LFxuXG4gICAgJ3N0cmluZywgSW5kZXgsIHN0cmluZyc6IF9zZXRTdWJzdHJpbmcsXG4gICAgJ3N0cmluZywgSW5kZXgsIHN0cmluZywgc3RyaW5nJzogX3NldFN1YnN0cmluZyxcbiAgICAnT2JqZWN0LCBJbmRleCwgYW55JzogX3NldE9iamVjdFByb3BlcnR5XG4gIH0pO1xuXG4gIHN1YnNldC50b1RleCA9ICdcXFxcbWF0aHJteyR7bmFtZX19XFxcXGxlZnQoJHthcmdzfVxcXFxyaWdodCknO1xuXG4gIHJldHVybiBzdWJzZXQ7XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIGEgc3Vic2V0IG9mIGEgc3RyaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgICAgICAgICAgICBzdHJpbmcgZnJvbSB3aGljaCB0byBnZXQgYSBzdWJzdHJpbmdcbiAgICogQHBhcmFtIHtJbmRleH0gaW5kZXggICAgICAgICAgIEFuIGluZGV4IGNvbnRhaW5pbmcgcmFuZ2VzIGZvciBlYWNoIGRpbWVuc2lvblxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBzdWJzdHJpbmdcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9nZXRTdWJzdHJpbmcoc3RyLCBpbmRleCkge1xuICAgIGlmICghaW5kZXggfHwgaW5kZXguaXNJbmRleCAhPT0gdHJ1ZSkge1xuICAgICAgLy8gVE9ETzogYmV0dGVyIGVycm9yIG1lc3NhZ2VcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0luZGV4IGV4cGVjdGVkJyk7XG4gICAgfVxuICAgIGlmIChpbmRleC5zaXplKCkubGVuZ3RoICE9IDEpIHtcbiAgICAgIHRocm93IG5ldyBEaW1lbnNpb25FcnJvcihpbmRleC5zaXplKCkubGVuZ3RoLCAxKTtcbiAgICB9XG5cbiAgICAvLyB2YWxpZGF0ZSB3aGV0aGVyIHRoZSByYW5nZSBpcyBvdXQgb2YgcmFuZ2VcbiAgICB2YXIgc3RyTGVuID0gc3RyLmxlbmd0aDtcbiAgICB2YWxpZGF0ZUluZGV4KGluZGV4Lm1pbigpWzBdLCBzdHJMZW4pO1xuICAgIHZhbGlkYXRlSW5kZXgoaW5kZXgubWF4KClbMF0sIHN0ckxlbik7XG5cbiAgICB2YXIgcmFuZ2UgPSBpbmRleC5kaW1lbnNpb24oMCk7XG5cbiAgICB2YXIgc3Vic3RyID0gJyc7XG4gICAgcmFuZ2UuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgc3Vic3RyICs9IHN0ci5jaGFyQXQodik7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc3Vic3RyO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2UgYSBzdWJzdHJpbmcgaW4gYSBzdHJpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciAgICAgICAgICAgIHN0cmluZyB0byBiZSByZXBsYWNlZFxuICAgKiBAcGFyYW0ge0luZGV4fSBpbmRleCAgICAgICAgICAgQW4gaW5kZXggY29udGFpbmluZyByYW5nZXMgZm9yIGVhY2ggZGltZW5zaW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZXBsYWNlbWVudCAgICBSZXBsYWNlbWVudCBzdHJpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtkZWZhdWx0VmFsdWVdIERlZmF1bHQgdmFsdWUgdG8gYmUgdXNlcyB3aGVuIHJlc2l6aW5nXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgc3RyaW5nLiBpcyAnICcgYnkgZGVmYXVsdFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSByZXN1bHRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9zZXRTdWJzdHJpbmcoc3RyLCBpbmRleCwgcmVwbGFjZW1lbnQsIGRlZmF1bHRWYWx1ZSkge1xuICAgIGlmICghaW5kZXggfHwgaW5kZXguaXNJbmRleCAhPT0gdHJ1ZSkge1xuICAgICAgLy8gVE9ETzogYmV0dGVyIGVycm9yIG1lc3NhZ2VcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0luZGV4IGV4cGVjdGVkJyk7XG4gICAgfVxuICAgIGlmIChpbmRleC5zaXplKCkubGVuZ3RoICE9IDEpIHtcbiAgICAgIHRocm93IG5ldyBEaW1lbnNpb25FcnJvcihpbmRleC5zaXplKCkubGVuZ3RoLCAxKTtcbiAgICB9XG4gICAgaWYgKGRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIGRlZmF1bHRWYWx1ZSAhPT0gJ3N0cmluZycgfHwgZGVmYXVsdFZhbHVlLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTaW5nbGUgY2hhcmFjdGVyIGV4cGVjdGVkIGFzIGRlZmF1bHRWYWx1ZScpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGRlZmF1bHRWYWx1ZSA9ICcgJztcbiAgICB9XG5cbiAgICB2YXIgcmFuZ2UgPSBpbmRleC5kaW1lbnNpb24oMCk7XG4gICAgdmFyIGxlbiA9IHJhbmdlLnNpemUoKVswXTtcblxuICAgIGlmIChsZW4gIT0gcmVwbGFjZW1lbnQubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRGltZW5zaW9uRXJyb3IocmFuZ2Uuc2l6ZSgpWzBdLCByZXBsYWNlbWVudC5sZW5ndGgpO1xuICAgIH1cblxuICAgIC8vIHZhbGlkYXRlIHdoZXRoZXIgdGhlIHJhbmdlIGlzIG91dCBvZiByYW5nZVxuICAgIHZhciBzdHJMZW4gPSBzdHIubGVuZ3RoO1xuICAgIHZhbGlkYXRlSW5kZXgoaW5kZXgubWluKClbMF0pO1xuICAgIHZhbGlkYXRlSW5kZXgoaW5kZXgubWF4KClbMF0pO1xuXG4gICAgLy8gY29weSB0aGUgc3RyaW5nIGludG8gYW4gYXJyYXkgd2l0aCBjaGFyYWN0ZXJzXG4gICAgdmFyIGNoYXJzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJMZW47IGkrKykge1xuICAgICAgY2hhcnNbaV0gPSBzdHIuY2hhckF0KGkpO1xuICAgIH1cblxuICAgIHJhbmdlLmZvckVhY2goZnVuY3Rpb24gKHYsIGkpIHtcbiAgICAgIGNoYXJzW3ZdID0gcmVwbGFjZW1lbnQuY2hhckF0KGlbMF0pO1xuICAgIH0pO1xuXG4gICAgLy8gaW5pdGlhbGl6ZSB1bmRlZmluZWQgY2hhcmFjdGVycyB3aXRoIGEgc3BhY2VcbiAgICBpZiAoY2hhcnMubGVuZ3RoID4gc3RyTGVuKSB7XG4gICAgICBmb3IgKGkgPSBzdHJMZW4gLSAxLCBsZW4gPSBjaGFycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoIWNoYXJzW2ldKSB7XG4gICAgICAgICAgY2hhcnNbaV0gPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2hhcnMuam9pbignJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXRyaWV2ZSBhIHByb3BlcnR5IGZyb20gYW4gb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiBAcGFyYW0ge0luZGV4fSBpbmRleFxuICogQHJldHVybiB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfZ2V0T2JqZWN0UHJvcGVydHkgKG9iamVjdCwgaW5kZXgpIHtcbiAgaWYgKGluZGV4LnNpemUoKS5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRGltZW5zaW9uRXJyb3IoaW5kZXguc2l6ZSgpLCAxKTtcbiAgfVxuXG4gIHZhciBrZXkgPSBpbmRleC5kaW1lbnNpb24oMCk7XG4gIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1N0cmluZyBleHBlY3RlZCBhcyBpbmRleCB0byByZXRyaWV2ZSBhbiBvYmplY3QgcHJvcGVydHknKTtcbiAgfVxuXG4gIHJldHVybiBvYmplY3Rba2V5XTtcbn1cblxuLyoqXG4gKiBTZXQgYSBwcm9wZXJ0eSBvbiBhbiBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEBwYXJhbSB7SW5kZXh9IGluZGV4XG4gKiBAcGFyYW0geyp9IHJlcGxhY2VtZW50XG4gKiBAcmV0dXJuIHsqfSBSZXR1cm5zIHRoZSB1cGRhdGVkIG9iamVjdFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX3NldE9iamVjdFByb3BlcnR5IChvYmplY3QsIGluZGV4LCByZXBsYWNlbWVudCkge1xuICBpZiAoaW5kZXguc2l6ZSgpLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBEaW1lbnNpb25FcnJvcihpbmRleC5zaXplKCksIDEpO1xuICB9XG5cbiAgdmFyIGtleSA9IGluZGV4LmRpbWVuc2lvbigwKTtcbiAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU3RyaW5nIGV4cGVjdGVkIGFzIGluZGV4IHRvIHJldHJpZXZlIGFuIG9iamVjdCBwcm9wZXJ0eScpO1xuICB9XG5cbiAgLy8gY2xvbmUgdGhlIG9iamVjdCwgYW5kIGFwcGx5IHRoZSBwcm9wZXJ0eSB0byB0aGUgY2xvbmVcbiAgdmFyIHVwZGF0ZWQgPSBjbG9uZShvYmplY3QpO1xuICB1cGRhdGVkW2tleV0gPSByZXBsYWNlbWVudDtcblxuICByZXR1cm4gdXBkYXRlZDtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ3N1YnNldCc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2xvbmUgPSByZXF1aXJlKCcuLi8uLi91dGlscy9vYmplY3QnKS5jbG9uZTtcbnZhciBmb3JtYXQgPSByZXF1aXJlKCcuLi8uLi91dGlscy9zdHJpbmcnKS5mb3JtYXQ7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgXG4gIHZhciBtYXRyaXggPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L2Z1bmN0aW9uL21hdHJpeCcpKTtcbiAgdmFyIGFkZCA9IGxvYWQocmVxdWlyZSgnLi4vYXJpdGhtZXRpYy9hZGQnKSk7XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgdHJhY2Ugb2YgYSBtYXRyaXg6IHRoZSBzdW0gb2YgdGhlIGVsZW1lbnRzIG9uIHRoZSBtYWluXG4gICAqIGRpYWdvbmFsIG9mIGEgc3F1YXJlIG1hdHJpeC5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLnRyYWNlKHgpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLnRyYWNlKFtbMSwgMl0sIFszLCA0XV0pOyAvLyByZXR1cm5zIDVcbiAgICpcbiAgICogICAgdmFyIEEgPSBbXG4gICAqICAgICAgWzEsIDIsIDNdLFxuICAgKiAgICAgIFstMSwgMiwgM10sXG4gICAqICAgICAgWzIsIDAsIDNdXG4gICAqICAgIF1cbiAgICogICAgbWF0aC50cmFjZShBKTsgLy8gcmV0dXJucyA2XG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBkaWFnXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXkgfCBNYXRyaXh9IHggIEEgbWF0cml4XG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHRyYWNlIG9mIGB4YFxuICAgKi9cbiAgdmFyIHRyYWNlID0gdHlwZWQoJ3RyYWNlJywge1xuICAgIFxuICAgICdBcnJheSc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAvLyB1c2UgZGVuc2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gdHJhY2UobWF0cml4KHgpKTtcbiAgICB9LFxuXG4gICAgJ01hdHJpeCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuICAgICAgLy8gcHJvY2VzcyBzdG9yYWdlIGZvcm1hdFxuICAgICAgc3dpdGNoICh4LnN0b3JhZ2UoKSkge1xuICAgICAgICBjYXNlICdkZW5zZSc6XG4gICAgICAgICAgYyA9IF9kZW5zZVRyYWNlKHgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgIGMgPSBfc3BhcnNlVHJhY2UoeCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuICAgIFxuICAgICdhbnknOiBjbG9uZVxuICB9KTtcbiAgXG4gIHZhciBfZGVuc2VUcmFjZSA9IGZ1bmN0aW9uIChtKSB7XG4gICAgLy8gbWF0cml4IHNpemUgJiBkYXRhXG4gICAgdmFyIHNpemUgPSBtLl9zaXplO1xuICAgIHZhciBkYXRhID0gbS5fZGF0YTtcbiAgICBcbiAgICAvLyBwcm9jZXNzIGRpbWVuc2lvbnNcbiAgICBzd2l0Y2ggKHNpemUubGVuZ3RoKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIC8vIHZlY3RvclxuICAgICAgICBpZiAoc2l6ZVswXSA9PSAxKSB7XG4gICAgICAgICAgLy8gcmV0dXJuIGRhdGFbMF1cbiAgICAgICAgICByZXR1cm4gY2xvbmUoZGF0YVswXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ01hdHJpeCBtdXN0IGJlIHNxdWFyZSAoc2l6ZTogJyArIGZvcm1hdChzaXplKSArICcpJyk7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIC8vIHR3byBkaW1lbnNpb25hbFxuICAgICAgICB2YXIgcm93cyA9IHNpemVbMF07XG4gICAgICAgIHZhciBjb2xzID0gc2l6ZVsxXTtcbiAgICAgICAgaWYgKHJvd3MgPT09IGNvbHMpIHtcbiAgICAgICAgICAvLyBjYWx1bGF0ZSBzdW1cbiAgICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgICAvLyBsb29wIGRpYWdvbmFsXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dzOyBpKyspXG4gICAgICAgICAgICBzdW0gPSBhZGQoc3VtLCBkYXRhW2ldW2ldKTtcbiAgICAgICAgICAvLyByZXR1cm4gdHJhY2VcbiAgICAgICAgICByZXR1cm4gc3VtO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdNYXRyaXggbXVzdCBiZSBzcXVhcmUgKHNpemU6ICcgKyBmb3JtYXQoc2l6ZSkgKyAnKScpOyAgICAgICAgXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBtdWx0aSBkaW1lbnNpb25hbFxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignTWF0cml4IG11c3QgYmUgdHdvIGRpbWVuc2lvbmFsIChzaXplOiAnICsgZm9ybWF0KHNpemUpICsgJyknKTtcbiAgICB9XG4gIH07XG4gIFxuICB2YXIgX3NwYXJzZVRyYWNlID0gZnVuY3Rpb24gKG0pIHtcbiAgICAvLyBtYXRyaXggYXJyYXlzXG4gICAgdmFyIHZhbHVlcyA9IG0uX3ZhbHVlcztcbiAgICB2YXIgaW5kZXggPSBtLl9pbmRleDtcbiAgICB2YXIgcHRyID0gbS5fcHRyO1xuICAgIHZhciBzaXplID0gbS5fc2l6ZTtcbiAgICAvLyBjaGVjayBkaW1lbnNpb25zXG4gICAgdmFyIHJvd3MgPSBzaXplWzBdO1xuICAgIHZhciBjb2x1bW5zID0gc2l6ZVsxXTtcbiAgICAvLyBtYXRyaXggbXVzdCBiZSBzcXVhcmVcbiAgICBpZiAocm93cyA9PT0gY29sdW1ucykge1xuICAgICAgLy8gY2FsdWxhdGUgc3VtXG4gICAgICB2YXIgc3VtID0gMDtcbiAgICAgIC8vIGNoZWNrIHdlIGhhdmUgZGF0YSAoYXZvaWQgbG9vcGluZyBjb2x1bW5zKVxuICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIGxvb3AgY29sdW1uc1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbHVtbnM7IGorKykge1xuICAgICAgICAgIC8vIGswIDw9IGsgPCBrMSB3aGVyZSBrMCA9IF9wdHJbal0gJiYgazEgPSBfcHRyW2orMV1cbiAgICAgICAgICB2YXIgazAgPSBwdHJbal07XG4gICAgICAgICAgdmFyIGsxID0gcHRyW2ogKyAxXTtcbiAgICAgICAgICAvLyBsb29wIGsgd2l0aGluIFtrMCwgazFbXG4gICAgICAgICAgZm9yICh2YXIgayA9IGswOyBrIDwgazE7IGsrKykge1xuICAgICAgICAgICAgLy8gcm93IGluZGV4XG4gICAgICAgICAgICB2YXIgaSA9IGluZGV4W2tdO1xuICAgICAgICAgICAgLy8gY2hlY2sgcm93XG4gICAgICAgICAgICBpZiAoaSA9PT0gaikge1xuICAgICAgICAgICAgICAvLyBhY2N1bXVsYXRlIHZhbHVlXG4gICAgICAgICAgICAgIHN1bSA9IGFkZChzdW0sIHZhbHVlc1trXSk7XG4gICAgICAgICAgICAgIC8vIGV4aXQgbG9vcFxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID4gaikge1xuICAgICAgICAgICAgICAvLyBleGl0IGxvb3AsIG5vIHZhbHVlIG9uIHRoZSBkaWFnb25hbCBmb3IgY29sdW1uIGpcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyByZXR1cm4gdHJhY2VcbiAgICAgIHJldHVybiBzdW07XG4gICAgfVxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdNYXRyaXggbXVzdCBiZSBzcXVhcmUgKHNpemU6ICcgKyBmb3JtYXQoc2l6ZSkgKyAnKScpOyAgIFxuICB9O1xuXG4gIHRyYWNlLnRvVGV4ID0gJ1xcXFxtYXRocm17dHJ9XFxcXGxlZnQoJHthcmdzWzBdfVxcXFxyaWdodCknO1xuICBcbiAgcmV0dXJuIHRyYWNlO1xufVxuXG5leHBvcnRzLm5hbWUgPSAndHJhY2UnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNsb25lID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0JykuY2xvbmU7XG52YXIgZm9ybWF0ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvc3RyaW5nJykuZm9ybWF0O1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBsYXRleCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2xhdGV4Jyk7XG5cbiAgdmFyIG1hdHJpeCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvZnVuY3Rpb24vbWF0cml4JykpO1xuXG4gIHZhciBEZW5zZU1hdHJpeCA9IHR5cGUuRGVuc2VNYXRyaXgsXG4gICAgICBTcGFyc2VNYXRyaXggPSB0eXBlLlNwYXJzZU1hdHJpeDtcblxuICAvKipcbiAgICogVHJhbnNwb3NlIGEgbWF0cml4LiBBbGwgdmFsdWVzIG9mIHRoZSBtYXRyaXggYXJlIHJlZmxlY3RlZCBvdmVyIGl0c1xuICAgKiBtYWluIGRpYWdvbmFsLiBPbmx5IHR3byBkaW1lbnNpb25hbCBtYXRyaWNlcyBhcmUgc3VwcG9ydGVkLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgICBtYXRoLnRyYW5zcG9zZSh4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgIHZhciBBID0gW1sxLCAyLCAzXSwgWzQsIDUsIDZdXTtcbiAgICogICAgIG1hdGgudHJhbnNwb3NlKEEpOyAgICAgICAgICAgICAgIC8vIHJldHVybnMgW1sxLCA0XSwgWzIsIDVdLCBbMywgNl1dXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICAgZGlhZywgaW52LCBzdWJzZXQsIHNxdWVlemVcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheSB8IE1hdHJpeH0geCAgTWF0cml4IHRvIGJlIHRyYW5zcG9zZWRcbiAgICogQHJldHVybiB7QXJyYXkgfCBNYXRyaXh9ICAgVGhlIHRyYW5zcG9zZWQgbWF0cml4XG4gICAqL1xuICB2YXIgdHJhbnNwb3NlID0gdHlwZWQoJ3RyYW5zcG9zZScsIHtcblxuICAgICdBcnJheSc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAvLyB1c2UgZGVuc2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gdHJhbnNwb3NlKG1hdHJpeCh4KSkudmFsdWVPZigpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIC8vIG1hdHJpeCBzaXplXG4gICAgICB2YXIgc2l6ZSA9IHguc2l6ZSgpO1xuXG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuICAgICAgXG4gICAgICAvLyBwcm9jZXNzIGRpbWVuc2lvbnNcbiAgICAgIHN3aXRjaCAoc2l6ZS5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIC8vIHZlY3RvclxuICAgICAgICAgIGMgPSB4LmNsb25lKCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIC8vIHJvd3MgYW5kIGNvbHVtbnNcbiAgICAgICAgICB2YXIgcm93cyA9IHNpemVbMF07XG4gICAgICAgICAgdmFyIGNvbHVtbnMgPSBzaXplWzFdO1xuXG4gICAgICAgICAgLy8gY2hlY2sgY29sdW1uc1xuICAgICAgICAgIGlmIChjb2x1bW5zID09PSAwKSB7XG4gICAgICAgICAgICAvLyB0aHJvdyBleGNlcHRpb25cbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdDYW5ub3QgdHJhbnNwb3NlIGEgMkQgbWF0cml4IHdpdGggbm8gY29sdW1ucyAoc2l6ZTogJyArIGZvcm1hdChzaXplKSArICcpJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gcHJvY2VzcyBzdG9yYWdlIGZvcm1hdFxuICAgICAgICAgIHN3aXRjaCAoeC5zdG9yYWdlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ2RlbnNlJzpcbiAgICAgICAgICAgICAgYyA9IF9kZW5zZVRyYW5zcG9zZSh4LCByb3dzLCBjb2x1bW5zKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgICAgICBjID0gX3NwYXJzZVRyYW5zcG9zZSh4LCByb3dzLCBjb2x1bW5zKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIFxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIG11bHRpIGRpbWVuc2lvbmFsXG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ01hdHJpeCBtdXN0IGJlIGEgdmVjdG9yIG9yIHR3byBkaW1lbnNpb25hbCAoc2l6ZTogJyArIGZvcm1hdCh0aGlzLl9zaXplKSArICcpJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuXG4gICAgLy8gc2NhbGFyc1xuICAgICdhbnknOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIGNsb25lKHgpO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIF9kZW5zZVRyYW5zcG9zZSA9IGZ1bmN0aW9uIChtLCByb3dzLCBjb2x1bW5zKSB7XG4gICAgLy8gbWF0cml4IGFycmF5XG4gICAgdmFyIGRhdGEgPSBtLl9kYXRhO1xuICAgIC8vIHRyYW5zcG9zZWQgbWF0cml4IGRhdGFcbiAgICB2YXIgdHJhbnNwb3NlZCA9IFtdO1xuICAgIHZhciB0cmFuc3Bvc2VkUm93O1xuICAgIC8vIGxvb3AgY29sdW1uc1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29sdW1uczsgaisrKSB7XG4gICAgICAvLyBpbml0aWFsaXplIHJvd1xuICAgICAgdHJhbnNwb3NlZFJvdyA9IHRyYW5zcG9zZWRbal0gPSBbXTtcbiAgICAgIC8vIGxvb3Agcm93c1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgICAgLy8gc2V0IGRhdGFcbiAgICAgICAgdHJhbnNwb3NlZFJvd1tpXSA9IGNsb25lKGRhdGFbaV1bal0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyByZXR1cm4gbWF0cml4XG4gICAgcmV0dXJuIG5ldyBEZW5zZU1hdHJpeCh7XG4gICAgICBkYXRhOiB0cmFuc3Bvc2VkLFxuICAgICAgc2l6ZTogW2NvbHVtbnMsIHJvd3NdLFxuICAgICAgZGF0YXR5cGU6IG0uX2RhdGF0eXBlXG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIF9zcGFyc2VUcmFuc3Bvc2UgPSBmdW5jdGlvbiAobSwgcm93cywgY29sdW1ucykge1xuICAgIC8vIG1hdHJpeCBhcnJheXNcbiAgICB2YXIgdmFsdWVzID0gbS5fdmFsdWVzO1xuICAgIHZhciBpbmRleCA9IG0uX2luZGV4O1xuICAgIHZhciBwdHIgPSBtLl9wdHI7XG4gICAgLy8gcmVzdWx0IG1hdHJpY2VzXG4gICAgdmFyIGN2YWx1ZXMgPSB2YWx1ZXMgPyBbXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgY2luZGV4ID0gW107XG4gICAgdmFyIGNwdHIgPSBbXTtcbiAgICAvLyByb3cgY291bnRzXG4gICAgdmFyIHcgPSBbXTtcbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHJvd3M7IHgrKylcbiAgICAgIHdbeF0gPSAwO1xuICAgIC8vIHZhcnNcbiAgICB2YXIgcCwgbCwgajtcbiAgICAvLyBsb29wIHZhbHVlcyBpbiBtYXRyaXhcbiAgICBmb3IgKHAgPSAwLCBsID0gaW5kZXgubGVuZ3RoOyBwIDwgbDsgcCsrKSB7XG4gICAgICAvLyBudW1iZXIgb2YgdmFsdWVzIGluIHJvd1xuICAgICAgd1tpbmRleFtwXV0rKztcbiAgICB9XG4gICAgLy8gY3VtdWxhdGl2ZSBzdW1cbiAgICB2YXIgc3VtID0gMDtcbiAgICAvLyBpbml0aWFsaXplIGNwdHIgd2l0aCB0aGUgY3VtbXVsYXRpdmUgc3VtIG9mIHJvdyBjb3VudHNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgLy8gdXBkYXRlIGNwdHJcbiAgICAgIGNwdHIucHVzaChzdW0pO1xuICAgICAgLy8gdXBkYXRlIHN1bVxuICAgICAgc3VtICs9IHdbaV07XG4gICAgICAvLyB1cGRhdGUgd1xuICAgICAgd1tpXSA9IGNwdHJbaV07XG4gICAgfVxuICAgIC8vIHVwZGF0ZSBjcHRyXG4gICAgY3B0ci5wdXNoKHN1bSk7XG4gICAgLy8gbG9vcCBjb2x1bW5zXG4gICAgZm9yIChqID0gMDsgaiA8IGNvbHVtbnM7IGorKykge1xuICAgICAgLy8gdmFsdWVzICYgaW5kZXggaW4gY29sdW1uXG4gICAgICBmb3IgKHZhciBrMCA9IHB0cltqXSwgazEgPSBwdHJbaiArIDFdLCBrID0gazA7IGsgPCBrMTsgaysrKSB7XG4gICAgICAgIC8vIEMgdmFsdWVzICYgaW5kZXhcbiAgICAgICAgdmFyIHEgPSB3W2luZGV4W2tdXSsrO1xuICAgICAgICAvLyBDW2osIGldID0gQVtpLCBqXVxuICAgICAgICBjaW5kZXhbcV0gPSBqO1xuICAgICAgICAvLyBjaGVjayB3ZSBuZWVkIHRvIHByb2Nlc3MgdmFsdWVzIChwYXR0ZXJuIG1hdHJpeClcbiAgICAgICAgaWYgKHZhbHVlcylcbiAgICAgICAgICBjdmFsdWVzW3FdID0gY2xvbmUodmFsdWVzW2tdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcmV0dXJuIG1hdHJpeFxuICAgIHJldHVybiBuZXcgU3BhcnNlTWF0cml4KHtcbiAgICAgIHZhbHVlczogY3ZhbHVlcyxcbiAgICAgIGluZGV4OiBjaW5kZXgsXG4gICAgICBwdHI6IGNwdHIsXG4gICAgICBzaXplOiBbY29sdW1ucywgcm93c10sXG4gICAgICBkYXRhdHlwZTogbS5fZGF0YXR5cGVcbiAgICB9KTtcbiAgfTtcblxuICB0cmFuc3Bvc2UudG9UZXggPSAnXFxcXGxlZnQoJHthcmdzWzBdfVxcXFxyaWdodCknICsgbGF0ZXgub3BlcmF0b3JzWyd0cmFuc3Bvc2UnXTtcblxuICByZXR1cm4gdHJhbnNwb3NlO1xufVxuXG5leHBvcnRzLm5hbWUgPSAndHJhbnNwb3NlJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0ludGVnZXIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9udW1iZXInKS5pc0ludGVnZXI7XG52YXIgcmVzaXplID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYXJyYXknKS5yZXNpemU7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIG1hdHJpeCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvZnVuY3Rpb24vbWF0cml4JykpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBtYXRyaXggZmlsbGVkIHdpdGggemVyb3MuIFRoZSBjcmVhdGVkIG1hdHJpeCBjYW4gaGF2ZSBvbmUgb3JcbiAgICogbXVsdGlwbGUgZGltZW5zaW9ucy5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLnplcm9zKG0pXG4gICAqICAgIG1hdGguemVyb3MobSwgZm9ybWF0KVxuICAgKiAgICBtYXRoLnplcm9zKG0sIG4pXG4gICAqICAgIG1hdGguemVyb3MobSwgbiwgZm9ybWF0KVxuICAgKiAgICBtYXRoLnplcm9zKFttLCBuXSlcbiAgICogICAgbWF0aC56ZXJvcyhbbSwgbl0sIGZvcm1hdClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGguemVyb3MoMyk7ICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBbMCwgMCwgMF1cbiAgICogICAgbWF0aC56ZXJvcygzLCAyKTsgICAgICAgICAgICAgICAvLyByZXR1cm5zIFtbMCwgMF0sIFswLCAwXSwgWzAsIDBdXVxuICAgKiAgICBtYXRoLnplcm9zKDMsICdkZW5zZScpOyAgICAgICAgIC8vIHJldHVybnMgWzAsIDAsIDBdXG4gICAqXG4gICAqICAgIHZhciBBID0gW1sxLCAyLCAzXSwgWzQsIDUsIDZdXTtcbiAgICogICAgbWF0aC56ZXJvcyhtYXRoLnNpemUoQSkpOyAgICAgICAvLyByZXR1cm5zIFtbMCwgMCwgMF0sIFswLCAwLCAwXV1cbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIG9uZXMsIGV5ZSwgc2l6ZSwgcmFuZ2VcbiAgICpcbiAgICogQHBhcmFtIHsuLi5udW1iZXIgfCBBcnJheX0gc2l6ZSAgICBUaGUgc2l6ZSBvZiBlYWNoIGRpbWVuc2lvbiBvZiB0aGUgbWF0cml4XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZm9ybWF0XSAgICAgICAgICAgVGhlIE1hdHJpeCBzdG9yYWdlIGZvcm1hdFxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheSB8IE1hdHJpeH0gICAgICAgICAgIEEgbWF0cml4IGZpbGxlZCB3aXRoIHplcm9zXG4gICAqL1xuICB2YXIgemVyb3MgPSB0eXBlZCgnemVyb3MnLCB7XG4gICAgJyc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoY29uZmlnLm1hdHJpeCA9PT0gJ0FycmF5JylcbiAgICAgICAgICA/IF96ZXJvcyhbXSlcbiAgICAgICAgICA6IF96ZXJvcyhbXSwgJ2RlZmF1bHQnKTtcbiAgICB9LFxuXG4gICAgLy8gbWF0aC56ZXJvcyhtLCBuLCBwLCAuLi4sIGZvcm1hdClcbiAgICAvLyBUT0RPOiBtb3JlIGFjY3VyYXRlIHNpZ25hdHVyZSAnLi4ubnVtYmVyIHwgQmlnTnVtYmVyLCBzdHJpbmcnIGFzIHNvb24gYXMgdHlwZWQtZnVuY3Rpb24gc3VwcG9ydHMgdGhpc1xuICAgICcuLi5udW1iZXIgfCBCaWdOdW1iZXIgfCBzdHJpbmcnOiBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgdmFyIGxhc3QgPSBzaXplW3NpemUubGVuZ3RoIC0gMV07XG4gICAgICBpZiAodHlwZW9mIGxhc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciBmb3JtYXQgPSBzaXplLnBvcCgpO1xuICAgICAgICByZXR1cm4gX3plcm9zKHNpemUsIGZvcm1hdCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChjb25maWcubWF0cml4ID09PSAnQXJyYXknKSB7XG4gICAgICAgIHJldHVybiBfemVyb3Moc2l6ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIF96ZXJvcyhzaXplLCAnZGVmYXVsdCcpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAnQXJyYXknOiBfemVyb3MsXG5cbiAgICAnTWF0cml4JzogZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgIHZhciBmb3JtYXQgPSBzaXplLnN0b3JhZ2UoKTtcbiAgICAgIHJldHVybiBfemVyb3Moc2l6ZS52YWx1ZU9mKCksIGZvcm1hdCk7XG4gICAgfSxcblxuICAgICdBcnJheSB8IE1hdHJpeCwgc3RyaW5nJzogZnVuY3Rpb24gKHNpemUsIGZvcm1hdCkge1xuICAgICAgcmV0dXJuIF96ZXJvcyAoc2l6ZS52YWx1ZU9mKCksIGZvcm1hdCk7XG4gICAgfVxuICB9KTtcblxuICB6ZXJvcy50b1RleCA9ICdcXFxcbWF0aHJteyR7bmFtZX19XFxcXGxlZnQoJHthcmdzfVxcXFxyaWdodCknO1xuXG4gIHJldHVybiB6ZXJvcztcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIEFycmF5IG9yIE1hdHJpeCB3aXRoIHplcm9zXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNpemVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtmb3JtYXQ9J2RlZmF1bHQnXVxuICAgKiBAcmV0dXJuIHtBcnJheSB8IE1hdHJpeH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF96ZXJvcyhzaXplLCBmb3JtYXQpIHtcbiAgICB2YXIgaGFzQmlnTnVtYmVycyA9IF9ub3JtYWxpemUoc2l6ZSk7XG4gICAgdmFyIGRlZmF1bHRWYWx1ZSA9IGhhc0JpZ051bWJlcnMgPyBuZXcgdHlwZS5CaWdOdW1iZXIoMCkgOiAwO1xuICAgIF92YWxpZGF0ZShzaXplKTtcblxuICAgIGlmIChmb3JtYXQpIHtcbiAgICAgIC8vIHJldHVybiBhIG1hdHJpeFxuICAgICAgdmFyIG0gPSBtYXRyaXgoZm9ybWF0KTtcbiAgICAgIGlmIChzaXplLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIG0ucmVzaXplKHNpemUsIGRlZmF1bHRWYWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyByZXR1cm4gYW4gQXJyYXlcbiAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgIGlmIChzaXplLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc2l6ZShhcnIsIHNpemUsIGRlZmF1bHRWYWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyO1xuICAgIH1cbiAgfVxuXG4gIC8vIHJlcGxhY2UgQmlnTnVtYmVycyB3aXRoIG51bWJlcnMsIHJldHVybnMgdHJ1ZSBpZiBzaXplIGNvbnRhaW5lZCBCaWdOdW1iZXJzXG4gIGZ1bmN0aW9uIF9ub3JtYWxpemUoc2l6ZSkge1xuICAgIHZhciBoYXNCaWdOdW1iZXJzID0gZmFsc2U7XG4gICAgc2l6ZS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIGFycikge1xuICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLmlzQmlnTnVtYmVyID09PSB0cnVlKSB7XG4gICAgICAgIGhhc0JpZ051bWJlcnMgPSB0cnVlO1xuICAgICAgICBhcnJbaW5kZXhdID0gdmFsdWUudG9OdW1iZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaGFzQmlnTnVtYmVycztcbiAgfVxuXG4gIC8vIHZhbGlkYXRlIGFyZ3VtZW50c1xuICBmdW5jdGlvbiBfdmFsaWRhdGUgKHNpemUpIHtcbiAgICBzaXplLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCAhaXNJbnRlZ2VyKHZhbHVlKSB8fCB2YWx1ZSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJhbWV0ZXJzIGluIGZ1bmN0aW9uIHplcm9zIG11c3QgYmUgcG9zaXRpdmUgaW50ZWdlcnMnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG4vLyBUT0RPOiB6ZXJvcyBjb250YWlucyBhbG1vc3QgdGhlIHNhbWUgY29kZSBhcyBvbmVzLiBSZXVzZSB0aGlzP1xuXG5leHBvcnRzLm5hbWUgPSAnemVyb3MnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzSW50ZWdlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL251bWJlcicpLmlzSW50ZWdlcjtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICAvKipcbiAgICogQ29tcHV0ZSB0aGUgbnVtYmVyIG9mIHdheXMgb2YgcGlja2luZyBga2AgdW5vcmRlcmVkIG91dGNvbWVzIGZyb20gYG5gXG4gICAqIHBvc3NpYmlsaXRpZXMuXG4gICAqXG4gICAqIENvbWJpbmF0aW9ucyBvbmx5IHRha2VzIGludGVnZXIgYXJndW1lbnRzLlxuICAgKiBUaGUgZm9sbG93aW5nIGNvbmRpdGlvbiBtdXN0IGJlIGVuZm9yY2VkOiBrIDw9IG4uXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgIG1hdGguY29tYmluYXRpb25zKG4sIGspXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmNvbWJpbmF0aW9ucyg3LCA1KTsgLy8gcmV0dXJucyAyMVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgcGVybXV0YXRpb25zLCBmYWN0b3JpYWxcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXIgfCBCaWdOdW1iZXJ9IG4gICAgVG90YWwgbnVtYmVyIG9mIG9iamVjdHMgaW4gdGhlIHNldFxuICAgKiBAcGFyYW0ge251bWJlciB8IEJpZ051bWJlcn0gayAgICBOdW1iZXIgb2Ygb2JqZWN0cyBpbiB0aGUgc3Vic2V0XG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlcn0gICAgIE51bWJlciBvZiBwb3NzaWJsZSBjb21iaW5hdGlvbnMuXG4gICAqL1xuICB2YXIgY29tYmluYXRpb25zID0gdHlwZWQoJ2NvbWJpbmF0aW9ucycsIHtcbiAgICAnbnVtYmVyLCBudW1iZXInOiBmdW5jdGlvbiAobiwgaykge1xuICAgICAgdmFyIG1heCwgcmVzdWx0LCBpO1xuXG4gICAgICBpZiAoIWlzSW50ZWdlcihuKSB8fCBuIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQb3NpdGl2ZSBpbnRlZ2VyIHZhbHVlIGV4cGVjdGVkIGluIGZ1bmN0aW9uIGNvbWJpbmF0aW9ucycpO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0ludGVnZXIoaykgfHwgayA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUG9zaXRpdmUgaW50ZWdlciB2YWx1ZSBleHBlY3RlZCBpbiBmdW5jdGlvbiBjb21iaW5hdGlvbnMnKTtcbiAgICAgIH1cbiAgICAgIGlmIChrID4gbikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdrIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIG4nKTtcbiAgICAgIH1cblxuICAgICAgbWF4ID0gTWF0aC5tYXgoaywgbiAtIGspO1xuICAgICAgcmVzdWx0ID0gMTtcbiAgICAgIGZvciAoaSA9IDE7IGkgPD0gbiAtIG1heDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCAqIChtYXggKyBpKSAvIGk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgICdCaWdOdW1iZXIsIEJpZ051bWJlcic6IGZ1bmN0aW9uIChuLCBrKSB7XG4gICAgICB2YXIgbWF4LCByZXN1bHQsIGksIGlpO1xuICAgICAgdmFyIG9uZSA9IG5ldyB0eXBlLkJpZ051bWJlcigxKTtcblxuICAgICAgaWYgKCFpc1Bvc2l0aXZlSW50ZWdlcihuKSB8fCAhaXNQb3NpdGl2ZUludGVnZXIoaykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUG9zaXRpdmUgaW50ZWdlciB2YWx1ZSBleHBlY3RlZCBpbiBmdW5jdGlvbiBjb21iaW5hdGlvbnMnKTtcbiAgICAgIH1cbiAgICAgIGlmIChrLmd0KG4pKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2sgbXVzdCBiZSBsZXNzIHRoYW4gbiBpbiBmdW5jdGlvbiBjb21iaW5hdGlvbnMnKTtcbiAgICAgIH1cblxuICAgICAgbWF4ID0gbi5taW51cyhrKTtcbiAgICAgIGlmIChrLmx0KG1heCkpIG1heCA9IGs7XG4gICAgICByZXN1bHQgPSBvbmU7XG4gICAgICBmb3IgKGkgPSBvbmUsIGlpID0gbi5taW51cyhtYXgpOyBpLmx0ZShpaSk7IGkgPSBpLnBsdXMoMSkpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnRpbWVzKG1heC5wbHVzKGkpKS5kaXZpZGVkQnkoaSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogaW1wbGVtZW50IHN1cHBvcnQgZm9yIGNvbGxlY3Rpb24gaW4gY29tYmluYXRpb25zXG4gIH0pO1xuXG4gIGNvbWJpbmF0aW9ucy50b1RleCA9ICdcXFxcYmlub217JHthcmdzWzBdfX17JHthcmdzWzFdfX0nO1xuXG4gIHJldHVybiBjb21iaW5hdGlvbnM7XG59XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIEJpZ051bWJlciBuIGlzIGEgcG9zaXRpdmUgaW50ZWdlclxuICogQHBhcmFtIHtCaWdOdW1iZXJ9IG5cbiAqIEByZXR1cm5zIHtib29sZWFufSBpc1Bvc2l0aXZlSW50ZWdlclxuICovXG5mdW5jdGlvbiBpc1Bvc2l0aXZlSW50ZWdlcihuKSB7XG4gIHJldHVybiBuLmlzSW50ZWdlcigpICYmIG4uZ3RlKDApO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnY29tYmluYXRpb25zJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBBcmd1bWVudHNFcnJvciA9IHJlcXVpcmUoJy4uLy4uL2Vycm9yL0FyZ3VtZW50c0Vycm9yJyk7XG52YXIgaXNDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9pc0NvbGxlY3Rpb24nKTtcblxuLy8gVE9ETzogcmV0aGluayBtYXRoLmRpc3RyaWJ1dGlvblxuLy8gVE9ETzogcmV3b3JrIHRvIGEgdHlwZWQgZnVuY3Rpb25cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIG1hdHJpeCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvZnVuY3Rpb24vbWF0cml4JykpO1xuICB2YXIgYXJyYXkgPSByZXF1aXJlKCcuLi8uLi91dGlscy9hcnJheScpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBkaXN0cmlidXRpb24gb2JqZWN0IHdpdGggYSBzZXQgb2YgcmFuZG9tIGZ1bmN0aW9ucyBmb3IgZ2l2ZW5cbiAgICogcmFuZG9tIGRpc3RyaWJ1dGlvbi5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICAgbWF0aC5kaXN0cmlidXRpb24obmFtZSlcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgICB2YXIgbm9ybWFsRGlzdCA9IG1hdGguZGlzdHJpYnV0aW9uKCdub3JtYWwnKTsgLy8gY3JlYXRlIGEgbm9ybWFsIGRpc3RyaWJ1dGlvblxuICAgKiAgICAgbm9ybWFsRGlzdC5yYW5kb20oMCwgMTApOyAgICAgICAgICAgICAgICAgICAgIC8vIGdldCBhIHJhbmRvbSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEwXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICAgcmFuZG9tLCByYW5kb21JbnQsIHBpY2tSYW5kb21cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgICBOYW1lIG9mIGEgZGlzdHJpYnV0aW9uLiBDaG9vc2UgZnJvbSAndW5pZm9ybScsICdub3JtYWwnLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgIFJldHVybnMgYSBkaXN0cmlidXRpb24gb2JqZWN0IGNvbnRhaW5pbmcgZnVuY3Rpb25zOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIGByYW5kb20oW3NpemVdIFssIG1pbl0gWywgbWF4XSlgLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIGByYW5kb21JbnQoW21pbl0gWywgbWF4XSlgLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIGBwaWNrUmFuZG9tKGFycmF5KWBcbiAgICovXG4gIGZ1bmN0aW9uIGRpc3RyaWJ1dGlvbihuYW1lKSB7XG4gICAgaWYgKCFkaXN0cmlidXRpb25zLmhhc093blByb3BlcnR5KG5hbWUpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGRpc3RyaWJ1dGlvbiAnICsgbmFtZSk7XG5cbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXG4gICAgICAgIGRpc3RyaWJ1dGlvbiA9IGRpc3RyaWJ1dGlvbnNbbmFtZV0uYXBwbHkodGhpcywgYXJncyk7XG5cbiAgICByZXR1cm4gKGZ1bmN0aW9uKGRpc3RyaWJ1dGlvbikge1xuXG4gICAgICAvLyBUaGlzIGlzIHRoZSBwdWJsaWMgQVBJIGZvciBhbGwgZGlzdHJpYnV0aW9uc1xuICAgICAgdmFyIHJhbmRGdW5jdGlvbnMgPSB7XG5cbiAgICAgICAgcmFuZG9tOiBmdW5jdGlvbihhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICAgICAgdmFyIHNpemUsIG1pbiwgbWF4O1xuICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50c0Vycm9yKCdyYW5kb20nLCBhcmd1bWVudHMubGVuZ3RoLCAwLCAzKTtcblxuICAgICAgICAgIC8vIGByYW5kb20obWF4KWAgb3IgYHJhbmRvbShzaXplKWBcbiAgICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGlmIChpc0NvbGxlY3Rpb24oYXJnMSkpIHtcbiAgICAgICAgICAgICAgc2l6ZSA9IGFyZzE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgbWF4ID0gYXJnMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAvLyBgcmFuZG9tKG1pbiwgbWF4KWAgb3IgYHJhbmRvbShzaXplLCBtYXgpYFxuICAgICAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgaWYgKGlzQ29sbGVjdGlvbihhcmcxKSkge1xuICAgICAgICAgICAgICBzaXplID0gYXJnMTtcbiAgICAgICAgICAgICAgbWF4ID0gYXJnMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBtaW4gPSBhcmcxO1xuICAgICAgICAgICAgICBtYXggPSBhcmcyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIC8vIGByYW5kb20oc2l6ZSwgbWluLCBtYXgpYFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaXplID0gYXJnMTtcbiAgICAgICAgICAgIG1pbiA9IGFyZzI7XG4gICAgICAgICAgICBtYXggPSBhcmczO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRPRE86IHZhbGlkYXRlIHR5cGUgb2YgbWluLCBtYXgsIGFuZCBzaXplXG5cbiAgICAgICAgICBpZiAobWF4ID09PSB1bmRlZmluZWQpIG1heCA9IDE7XG4gICAgICAgICAgaWYgKG1pbiA9PT0gdW5kZWZpbmVkKSBtaW4gPSAwO1xuICAgICAgICAgIGlmIChzaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciByZXMgPSBfcmFuZG9tRGF0YUZvck1hdHJpeChzaXplLnZhbHVlT2YoKSwgbWluLCBtYXgsIF9yYW5kb20pO1xuICAgICAgICAgICAgcmV0dXJuIChzaXplICYmIHNpemUuaXNNYXRyaXggPT09IHRydWUpID8gbWF0cml4KHJlcykgOiByZXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgcmV0dXJuIF9yYW5kb20obWluLCBtYXgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJhbmRvbUludDogZnVuY3Rpb24oYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgICAgIHZhciBzaXplLCBtaW4sIG1heDtcbiAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDMgfHwgYXJndW1lbnRzLmxlbmd0aCA8IDEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRzRXJyb3IoJ3JhbmRvbUludCcsIGFyZ3VtZW50cy5sZW5ndGgsIDEsIDMpO1xuXG4gICAgICAgICAgLy8gYHJhbmRvbShtYXgpYCBvciBgcmFuZG9tKHNpemUpYFxuICAgICAgICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICBpZiAoaXNDb2xsZWN0aW9uKGFyZzEpKSB7XG4gICAgICAgICAgICAgIHNpemUgPSBhcmcxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIG1heCA9IGFyZzE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgLy8gYHJhbmRvbUludChtaW4sIG1heClgIG9yIGByYW5kb21JbnQoc2l6ZSwgbWF4KWBcbiAgICAgICAgICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBpZiAoaXNDb2xsZWN0aW9uKGFyZzEpKSB7XG4gICAgICAgICAgICAgIHNpemUgPSBhcmcxO1xuICAgICAgICAgICAgICBtYXggPSBhcmcyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIG1pbiA9IGFyZzE7XG4gICAgICAgICAgICAgIG1heCA9IGFyZzI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgLy8gYHJhbmRvbUludChzaXplLCBtaW4sIG1heClgXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpemUgPSBhcmcxO1xuICAgICAgICAgICAgbWluID0gYXJnMjtcbiAgICAgICAgICAgIG1heCA9IGFyZzM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVE9ETzogdmFsaWRhdGUgdHlwZSBvZiBtaW4sIG1heCwgYW5kIHNpemVcblxuICAgICAgICAgIGlmIChtaW4gPT09IHVuZGVmaW5lZCkgbWluID0gMDtcbiAgICAgICAgICBpZiAoc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gX3JhbmRvbURhdGFGb3JNYXRyaXgoc2l6ZS52YWx1ZU9mKCksIG1pbiwgbWF4LCBfcmFuZG9tSW50KTtcbiAgICAgICAgICAgIHJldHVybiAoc2l6ZSAmJiBzaXplLmlzTWF0cml4ID09PSB0cnVlKSA/IG1hdHJpeChyZXMpIDogcmVzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHJldHVybiBfcmFuZG9tSW50KG1pbiwgbWF4KTtcbiAgICAgICAgfSxcblxuICAgICAgICBwaWNrUmFuZG9tOiBmdW5jdGlvbihwb3NzaWJsZXMpIHtcbiAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50c0Vycm9yKCdwaWNrUmFuZG9tJywgYXJndW1lbnRzLmxlbmd0aCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwb3NzaWJsZXMgJiYgcG9zc2libGVzLmlzTWF0cml4ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBwb3NzaWJsZXMgPSBwb3NzaWJsZXMudmFsdWVPZigpOyAvLyBnZXQgQXJyYXlcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkocG9zc2libGVzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5zdXBwb3J0ZWQgdHlwZSBvZiB2YWx1ZSBpbiBmdW5jdGlvbiBwaWNrUmFuZG9tJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFycmF5LnNpemUocG9zc2libGVzKS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgb25lIGRpbWVuc2lvbmFsIHZlY3RvcnMgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVE9ETzogYWRkIHN1cHBvcnQgZm9yIG11bHRpIGRpbWVuc2lvbmFsIG1hdHJpY2VzXG4gICAgICAgICAgcmV0dXJuIHBvc3NpYmxlc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBwb3NzaWJsZXMubGVuZ3RoKV07XG4gICAgICAgIH1cblxuICAgICAgfTtcblxuICAgICAgdmFyIF9yYW5kb20gPSBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgICAgICByZXR1cm4gbWluICsgZGlzdHJpYnV0aW9uKCkgKiAobWF4IC0gbWluKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBfcmFuZG9tSW50ID0gZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobWluICsgZGlzdHJpYnV0aW9uKCkgKiAobWF4IC0gbWluKSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBUaGlzIGlzIGEgZnVuY3Rpb24gZm9yIGdlbmVyYXRpbmcgYSByYW5kb20gbWF0cml4IHJlY3Vyc2l2ZWx5LlxuICAgICAgdmFyIF9yYW5kb21EYXRhRm9yTWF0cml4ID0gZnVuY3Rpb24oc2l6ZSwgbWluLCBtYXgsIHJhbmRGdW5jKSB7XG4gICAgICAgIHZhciBkYXRhID0gW10sIGxlbmd0aCwgaTtcbiAgICAgICAgc2l6ZSA9IHNpemUuc2xpY2UoMCk7XG5cbiAgICAgICAgaWYgKHNpemUubGVuZ3RoID4gMSkge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNpemUuc2hpZnQoKTsgaSA8IGxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgZGF0YS5wdXNoKF9yYW5kb21EYXRhRm9yTWF0cml4KHNpemUsIG1pbiwgbWF4LCByYW5kRnVuYykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNpemUuc2hpZnQoKTsgaSA8IGxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgZGF0YS5wdXNoKHJhbmRGdW5jKG1pbiwgbWF4KSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiByYW5kRnVuY3Rpb25zO1xuXG4gICAgfSkoZGlzdHJpYnV0aW9uKTtcbiAgfVxuXG4gIC8vIEVhY2ggZGlzdHJpYnV0aW9uIGlzIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBubyBhcmd1bWVudCBhbmQgd2hlbiBjYWxsZWQgcmV0dXJuc1xuICAvLyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEuXG4gIHZhciBkaXN0cmlidXRpb25zID0ge1xuXG4gICAgdW5pZm9ybTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gTWF0aC5yYW5kb207XG4gICAgfSxcblxuICAgIC8vIEltcGxlbWVudGF0aW9uIG9mIG5vcm1hbCBkaXN0cmlidXRpb24gdXNpbmcgQm94LU11bGxlciB0cmFuc2Zvcm1cbiAgICAvLyByZWYgOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0JveCVFMiU4MCU5M011bGxlcl90cmFuc2Zvcm1cbiAgICAvLyBXZSB0YWtlIDogbWVhbiA9IDAuNSwgc3RhbmRhcmQgZGV2aWF0aW9uID0gMS82XG4gICAgLy8gc28gdGhhdCA5OS43JSB2YWx1ZXMgYXJlIGluIFswLCAxXS5cbiAgICBub3JtYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdTEsIHUyLFxuICAgICAgICAgICAgcGlja2VkID0gLTE7XG4gICAgICAgIC8vIFdlIHJlamVjdCB2YWx1ZXMgb3V0c2lkZSBvZiB0aGUgaW50ZXJ2YWwgWzAsIDFdXG4gICAgICAgIC8vIFRPRE86IGNoZWNrIGlmIGl0IGlzIG9rIHRvIGRvIHRoYXQ/XG4gICAgICAgIHdoaWxlIChwaWNrZWQgPCAwIHx8IHBpY2tlZCA+IDEpIHtcbiAgICAgICAgICB1MSA9IE1hdGgucmFuZG9tKCk7XG4gICAgICAgICAgdTIgPSBNYXRoLnJhbmRvbSgpO1xuICAgICAgICAgIHBpY2tlZCA9IDEvNiAqIE1hdGgucG93KC0yICogTWF0aC5sb2codTEpLCAwLjUpICogTWF0aC5jb3MoMiAqIE1hdGguUEkgKiB1MikgKyAwLjU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBpY2tlZDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZGlzdHJpYnV0aW9uLnRvVGV4ID0gJ1xcXFxtYXRocm17JHtuYW1lfX1cXFxcbGVmdCgke2FyZ3N9XFxcXHJpZ2h0KSc7XG5cbiAgcmV0dXJuIGRpc3RyaWJ1dGlvbjtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2Rpc3RyaWJ1dGlvbic7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVlcE1hcCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vZGVlcE1hcCcpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBnYW1tYSA9IGxvYWQocmVxdWlyZSgnLi9nYW1tYScpKTtcbiAgdmFyIGxhdGV4ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbGF0ZXgnKTtcblxuICAvKipcbiAgICogQ29tcHV0ZSB0aGUgZmFjdG9yaWFsIG9mIGEgdmFsdWVcbiAgICpcbiAgICogRmFjdG9yaWFsIG9ubHkgc3VwcG9ydHMgYW4gaW50ZWdlciB2YWx1ZSBhcyBhcmd1bWVudC5cbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmZhY3RvcmlhbChuKVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5mYWN0b3JpYWwoNSk7ICAgIC8vIHJldHVybnMgMTIwXG4gICAqICAgIG1hdGguZmFjdG9yaWFsKDMpOyAgICAvLyByZXR1cm5zIDZcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGNvbWJpbmF0aW9ucywgZ2FtbWEsIHBlcm11dGF0aW9uc1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlciB8IEJpZ051bWJlciB8IEFycmF5IHwgTWF0cml4fSBuICAgQW4gaW50ZWdlciBudW1iZXJcbiAgICogQHJldHVybiB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgQXJyYXkgfCBNYXRyaXh9ICAgIFRoZSBmYWN0b3JpYWwgb2YgYG5gXG4gICAqL1xuICB2YXIgZmFjdG9yaWFsID0gdHlwZWQoJ2ZhY3RvcmlhbCcsIHtcbiAgICAnbnVtYmVyJzogZnVuY3Rpb24gKG4pIHtcbiAgICAgIGlmIChuIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIG11c3QgYmUgbm9uLW5lZ2F0aXZlJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnYW1tYShuICsgMSk7XG4gICAgfSxcblxuICAgICdCaWdOdW1iZXInOiBmdW5jdGlvbiAobikge1xuICAgICAgaWYgKG4uaXNOZWdhdGl2ZSgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVmFsdWUgbXVzdCBiZSBub24tbmVnYXRpdmUnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdhbW1hKG4ucGx1cygxKSk7XG4gICAgfSxcblxuICAgICdBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uIChuKSB7XG4gICAgICByZXR1cm4gZGVlcE1hcChuLCBmYWN0b3JpYWwpO1xuICAgIH1cbiAgfSk7XG5cbiAgZmFjdG9yaWFsLnRvVGV4ID0gJ1xcXFxsZWZ0KCR7YXJnc1swXX1cXFxccmlnaHQpJyArIGxhdGV4Lm9wZXJhdG9yc1snZmFjdG9yaWFsJ107XG5cbiAgcmV0dXJuIGZhY3RvcmlhbDtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2ZhY3RvcmlhbCc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVlcE1hcCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vZGVlcE1hcCcpO1xudmFyIGlzSW50ZWdlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL251bWJlcicpLmlzSW50ZWdlcjtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgbXVsdGlwbHkgPSBsb2FkKHJlcXVpcmUoJy4uL2FyaXRobWV0aWMvbXVsdGlwbHknKSk7XG4gIHZhciBwb3cgPSBsb2FkKHJlcXVpcmUoJy4uL2FyaXRobWV0aWMvcG93JykpO1xuXG4gIC8qKlxuICAgKiBDb21wdXRlIHRoZSBnYW1tYSBmdW5jdGlvbiBvZiBhIHZhbHVlIHVzaW5nIExhbmN6b3MgYXBwcm94aW1hdGlvbiBmb3JcbiAgICogc21hbGwgdmFsdWVzLCBhbmQgYW4gZXh0ZW5kZWQgU3RpcmxpbmcgYXBwcm94aW1hdGlvbiBmb3IgbGFyZ2UgdmFsdWVzLlxuICAgKlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguZ2FtbWEobilcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGguZ2FtbWEoNSk7ICAgICAgIC8vIHJldHVybnMgMjRcbiAgICogICAgbWF0aC5nYW1tYSgtMC41KTsgICAgLy8gcmV0dXJucyAtMy41NDQ5MDc3MDE4MTEwMzM1XG4gICAqICAgIG1hdGguZ2FtbWEobWF0aC5pKTsgIC8vIHJldHVybnMgLTAuMTU0OTQ5ODI4MzAxODA5NzMgLSAwLjQ5ODAxNTY2ODExODM1NTk2aVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgY29tYmluYXRpb25zLCBmYWN0b3JpYWwsIHBlcm11dGF0aW9uc1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlciB8IEFycmF5IHwgTWF0cml4fSBuICAgQSByZWFsIG9yIGNvbXBsZXggbnVtYmVyXG4gICAqIEByZXR1cm4ge251bWJlciB8IEFycmF5IHwgTWF0cml4fSAgICBUaGUgZ2FtbWEgb2YgYG5gXG4gICAqL1xuICB2YXIgZ2FtbWEgPSB0eXBlZCgnZ2FtbWEnLCB7XG4gICAgJ251bWJlcic6IGZ1bmN0aW9uIChuKSB7XG4gICAgICB2YXIgdCwgeDtcblxuICAgICAgaWYgKGlzSW50ZWdlcihuKSkge1xuICAgICAgICBpZiAobiA8PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGlzRmluaXRlKG4pID8gSW5maW5pdHkgOiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobiA+IDE3MSkge1xuICAgICAgICAgIHJldHVybiBJbmZpbml0eTsgICAgICAgICAgICAgICAgICAvLyBXaWxsIG92ZXJmbG93XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmFsdWUgPSBuIC0gMjtcbiAgICAgICAgdmFyIHJlcyA9IG4gLSAxO1xuICAgICAgICB3aGlsZSAodmFsdWUgPiAxKSB7XG4gICAgICAgICAgcmVzICo9IHZhbHVlO1xuICAgICAgICAgIHZhbHVlLS07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzID09IDApIHtcbiAgICAgICAgICByZXMgPSAxOyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCEgaXMgcGVyIGRlZmluaXRpb24gMVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cblxuICAgICAgaWYgKG4gPCAwLjUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguUEkgLyAoTWF0aC5zaW4oTWF0aC5QSSAqIG4pICogZ2FtbWEoMS1uKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuID49IDE3MS4zNSkge1xuICAgICAgICByZXR1cm4gSW5maW5pdHk7ICAgICAgICAgICAgICAgICAgICAvLyB3aWxsIG92ZXJmbG93XG4gICAgICB9XG5cbiAgICAgIGlmIChuID4gODUuMCkgeyAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0ZW5kZWQgU3RpcmxpbmcgQXBwcm94XG4gICAgICAgIHZhciB0d29OID0gbipuO1xuICAgICAgICB2YXIgdGhyZWVOID0gdHdvTipuO1xuICAgICAgICB2YXIgZm91ck4gPSB0aHJlZU4qbjtcbiAgICAgICAgdmFyIGZpdmVOID0gZm91ck4qbjtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCgyKk1hdGguUEkvbikgKiBNYXRoLnBvdygobi9NYXRoLkUpLCBuKSAqXG4gICAgICAgICAgICAoMSArIDEvKDEyKm4pICsgMS8oMjg4KnR3b04pIC0gMTM5Lyg1MTg0MCp0aHJlZU4pIC1cbiAgICAgICAgICAgIDU3MS8oMjQ4ODMyMCpmb3VyTikgKyAxNjM4NzkvKDIwOTAxODg4MCpmaXZlTikgK1xuICAgICAgICAgICAgNTI0NjgxOS8oNzUyNDY3OTY4MDAqZml2ZU4qbikpO1xuICAgICAgfVxuXG4gICAgICAtLW47XG4gICAgICB4ID0gcFswXTtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcC5sZW5ndGg7ICsraSkge1xuICAgICAgICB4ICs9IHBbaV0gLyAobitpKTtcbiAgICAgIH1cblxuICAgICAgdCA9IG4gKyBnICsgMC41O1xuICAgICAgcmV0dXJuIE1hdGguc3FydCgyKk1hdGguUEkpICogTWF0aC5wb3codCwgbiswLjUpICogTWF0aC5leHAoLXQpICogeDtcbiAgICB9LFxuXG4gICAgJ0NvbXBsZXgnOiBmdW5jdGlvbiAobikge1xuICAgICAgdmFyIHQsIHg7XG5cbiAgICAgIGlmIChuLmltID09IDApIHtcbiAgICAgICAgcmV0dXJuIGdhbW1hKG4ucmUpO1xuICAgICAgfVxuXG4gICAgICBuID0gbmV3IHR5cGUuQ29tcGxleChuLnJlIC0gMSwgbi5pbSk7XG4gICAgICB4ID0gbmV3IHR5cGUuQ29tcGxleChwWzBdLCAwKTtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcC5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcmVhbCA9IG4ucmUgKyBpOyAgICAgICAgICAgICAgICAvLyB4ICs9IHBbaV0vKG4raSlcbiAgICAgICAgdmFyIGRlbiA9IHJlYWwqcmVhbCArIG4uaW0qbi5pbTtcbiAgICAgICAgaWYgKGRlbiAhPSAwKSB7XG4gICAgICAgICAgeC5yZSArPSBwW2ldICogcmVhbCAvIGRlbjtcbiAgICAgICAgICB4LmltICs9IC0ocFtpXSAqIG4uaW0pIC8gZGVuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHgucmUgPSBwW2ldIDwgMFxuICAgICAgICAgICAgICA/IC1JbmZpbml0eVxuICAgICAgICAgICAgICA6ICBJbmZpbml0eTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0ID0gbmV3IHR5cGUuQ29tcGxleChuLnJlICsgZyArIDAuNSwgbi5pbSk7XG4gICAgICB2YXIgdHdvUGlTcXJ0ID0gTWF0aC5zcXJ0KDIqTWF0aC5QSSk7XG5cbiAgICAgIG4ucmUgKz0gMC41O1xuICAgICAgdmFyIHJlc3VsdCA9IHBvdyh0LCBuKTtcbiAgICAgIGlmIChyZXN1bHQuaW0gPT0gMCkgeyAgICAgICAgICAgICAgICAgLy8gc3FydCgyKlBJKSpyZXN1bHRcbiAgICAgICAgcmVzdWx0LnJlICo9IHR3b1BpU3FydDtcbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0LnJlID09IDApIHtcbiAgICAgICAgcmVzdWx0LmltICo9IHR3b1BpU3FydDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5yZSAqPSB0d29QaVNxcnQ7XG4gICAgICAgIHJlc3VsdC5pbSAqPSB0d29QaVNxcnQ7XG4gICAgICB9XG5cbiAgICAgIHZhciByID0gTWF0aC5leHAoLXQucmUpOyAgICAgICAgICAgICAgLy8gZXhwKC10KVxuICAgICAgdC5yZSA9IHIgKiBNYXRoLmNvcygtdC5pbSk7XG4gICAgICB0LmltID0gciAqIE1hdGguc2luKC10LmltKTtcblxuICAgICAgcmV0dXJuIG11bHRpcGx5KG11bHRpcGx5KHJlc3VsdCwgdCksIHgpO1xuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyJzogZnVuY3Rpb24gKG4pIHtcbiAgICAgIGlmIChuLmlzSW50ZWdlcigpKSB7XG4gICAgICAgIHJldHVybiAobi5pc05lZ2F0aXZlKCkgfHwgbi5pc1plcm8oKSlcbiAgICAgICAgICAgID8gbmV3IHR5cGUuQmlnTnVtYmVyKEluZmluaXR5KVxuICAgICAgICAgICAgOiBiaWdGYWN0b3JpYWwobi5taW51cygxKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghbi5pc0Zpbml0ZSgpKSB7XG4gICAgICAgIHJldHVybiBuZXcgdHlwZS5CaWdOdW1iZXIobi5pc05lZ2F0aXZlKCkgPyBOYU4gOiBJbmZpbml0eSk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcignSW50ZWdlciBCaWdOdW1iZXIgZXhwZWN0ZWQnKTtcbiAgICB9LFxuXG4gICAgJ0FycmF5IHwgTWF0cml4JzogZnVuY3Rpb24gKG4pIHtcbiAgICAgIHJldHVybiBkZWVwTWFwKG4sIGdhbW1hKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgZmFjdG9yaWFsIGZvciBhIEJpZ051bWJlclxuICAgKiBAcGFyYW0ge0JpZ051bWJlcn0gblxuICAgKiBAcmV0dXJucyB7QmlnTnVtYmVyfSBSZXR1cm5zIHRoZSBmYWN0b3JpYWwgb2YgblxuICAgKi9cbiAgZnVuY3Rpb24gYmlnRmFjdG9yaWFsKG4pIHtcbiAgICBpZiAobi5pc1plcm8oKSkge1xuICAgICAgcmV0dXJuIG5ldyB0eXBlLkJpZ051bWJlcigxKTsgLy8gMCEgaXMgcGVyIGRlZmluaXRpb24gMVxuICAgIH1cblxuICAgIHZhciBwcmVjaXNpb24gPSBjb25maWcucHJlY2lzaW9uICsgKE1hdGgubG9nKG4udG9OdW1iZXIoKSkgfCAwKTtcbiAgICB2YXIgQmlnID0gdHlwZS5CaWdOdW1iZXIuY2xvbmUoe3ByZWNpc2lvbjogcHJlY2lzaW9ufSk7XG5cbiAgICB2YXIgcmVzID0gbmV3IEJpZyhuKTtcbiAgICB2YXIgdmFsdWUgPSBuLnRvTnVtYmVyKCkgLSAxOyAvLyBudW1iZXJcbiAgICB3aGlsZSAodmFsdWUgPiAxKSB7XG4gICAgICByZXMgPSByZXMudGltZXModmFsdWUpO1xuICAgICAgdmFsdWUtLTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IHR5cGUuQmlnTnVtYmVyKHJlcy50b1ByZWNpc2lvbih0eXBlLkJpZ051bWJlci5wcmVjaXNpb24pKTtcbiAgfVxuXG4gIGdhbW1hLnRvVGV4ID0gJ1xcXFxHYW1tYVxcXFxsZWZ0KCR7YXJnc1swXX1cXFxccmlnaHQpJztcblxuICByZXR1cm4gZ2FtbWE7XG59XG5cbi8vIFRPRE86IGNvbW1lbnQgb24gdGhlIHZhcmlhYmxlcyBnIGFuZCBwXG5cbnZhciBnID0gNC43NDIxODc1O1xuXG52YXIgcCA9IFtcbiAgMC45OTk5OTk5OTk5OTk5OTcwOTE4MixcbiAgNTcuMTU2MjM1NjY1ODYyOTIzNTE3LFxuICAtNTkuNTk3OTYwMzU1NDc1NDkxMjQ4LFxuICAxNC4xMzYwOTc5NzQ3NDE3NDcxNzQsXG4gIC0wLjQ5MTkxMzgxNjA5NzYyMDE5OTc4LFxuICAwLjMzOTk0NjQ5OTg0ODExODg4Njk5ZS00LFxuICAwLjQ2NTIzNjI4OTI3MDQ4NTc1NjY1ZS00LFxuICAtMC45ODM3NDQ3NTMwNDg3OTU2NDY3N2UtNCxcbiAgMC4xNTgwODg3MDMyMjQ5MTI0ODg4NGUtMyxcbiAgLTAuMjEwMjY0NDQxNzI0MTA0ODgzMTllLTMsXG4gIDAuMjE3NDM5NjE4MTE1MjEyNjQzMjBlLTMsXG4gIC0wLjE2NDMxODEwNjUzNjc2Mzg5MDIyZS0zLFxuICAwLjg0NDE4MjIzOTgzODUyNzQzMjkzZS00LFxuICAtMC4yNjE5MDgzODQwMTU4MTQwODY3MGUtNCxcbiAgMC4zNjg5OTE4MjY1OTUzMTYyMjcwNGUtNVxuXTtcblxuZXhwb3J0cy5uYW1lID0gJ2dhbW1hJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFtcbiAgLy9yZXF1aXJlKCcuL2Rpc3RyaWJ1dGlvbicpLCAvLyBUT0RPOiByZXRoaW5rIG1hdGguZGlzdHJpYnV0aW9uXG4gIHJlcXVpcmUoJy4vY29tYmluYXRpb25zJyksXG4gIHJlcXVpcmUoJy4vZmFjdG9yaWFsJyksXG4gIHJlcXVpcmUoJy4vZ2FtbWEnKSxcbiAgcmVxdWlyZSgnLi9rbGRpdmVyZ2VuY2UnKSxcbiAgcmVxdWlyZSgnLi9tdWx0aW5vbWlhbCcpLFxuICByZXF1aXJlKCcuL3Blcm11dGF0aW9ucycpLFxuICByZXF1aXJlKCcuL3BpY2tSYW5kb20nKSxcbiAgcmVxdWlyZSgnLi9yYW5kb20nKSxcbiAgcmVxdWlyZSgnLi9yYW5kb21JbnQnKVxuXTtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG5mdW5jdGlvbiBmYWN0b3J5KHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgICB2YXIgbWF0cml4ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC9mdW5jdGlvbi9tYXRyaXgnKSk7XG4gICAgdmFyIGRpdmlkZSA9IGxvYWQocmVxdWlyZSgnLi4vYXJpdGhtZXRpYy9kaXZpZGUnKSk7XG4gICAgdmFyIHN1bSA9IGxvYWQocmVxdWlyZSgnLi4vc3RhdGlzdGljcy9zdW0nKSk7XG4gICAgdmFyIG11bHRpcGx5ID0gbG9hZChyZXF1aXJlKCcuLi9hcml0aG1ldGljL211bHRpcGx5JykpO1xuICAgIHZhciBkb3REaXZpZGUgPSBsb2FkKHJlcXVpcmUoJy4uL2FyaXRobWV0aWMvZG90RGl2aWRlJykpO1xuICAgIHZhciBsb2cgPSBsb2FkKHJlcXVpcmUoJy4uL2FyaXRobWV0aWMvbG9nJykpO1xuICAgIHZhciBpc051bWVyaWMgPSBsb2FkKHJlcXVpcmUoJy4uL3V0aWxzL2lzTnVtZXJpYycpKTtcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgS3VsbGJhY2stTGVpYmxlciAoS0wpIGRpdmVyZ2VuY2UgIGJldHdlZW4gdHdvIGRpc3RyaWJ1dGlvbnNcbiAgICAgKlxuICAgICAqIFN5bnRheDpcbiAgICAgKlxuICAgICAqICAgICBtYXRoLmtsZGl2ZXJnZW5jZSh4LCB5KVxuICAgICAqXG4gICAgICogRXhhbXBsZXM6XG4gICAgICpcbiAgICAgKiAgICAgbWF0aC5rbGRpdmVyZ2VuY2UoWzAuNywwLjUsMC40XSwgWzAuMiwwLjksMC41XSk7ICAgLy9yZXR1cm5zIDAuMjQzNzY2OTg3NzMxMjExNTNcbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtICB7QXJyYXkgfCBNYXRyaXh9IHEgICAgRmlyc3QgdmVjdG9yXG4gICAgICogQHBhcmFtICB7QXJyYXkgfCBNYXRyaXh9IHAgICAgU2Vjb25kIHZlY3RvclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgICAgICAgIFJldHVybnMgZGlzdGFuY2UgYmV0d2VlbiBxIGFuZCBwXG4gICAgICovXG4gICAgdmFyIGtsZGl2ZXJnZW5jZSA9IHR5cGVkKCdrbGRpdmVyZ2VuY2UnLCB7XG4gICAgICAgICdBcnJheSwgQXJyYXknOiBmdW5jdGlvbihxLCBwKSB7XG4gICAgICAgICAgICByZXR1cm4gX2tsZGl2KG1hdHJpeChxKSwgbWF0cml4KHApKTtcbiAgICAgICAgfSxcblxuICAgICAgICAnTWF0cml4LCBBcnJheSc6IGZ1bmN0aW9uKHEsIHApIHtcbiAgICAgICAgICAgIHJldHVybiBfa2xkaXYocSwgbWF0cml4KHApKTtcbiAgICAgICAgfSxcblxuICAgICAgICAnQXJyYXksIE1hdHJpeCc6IGZ1bmN0aW9uKHEsIHApe1xuICAgICAgICAgICAgcmV0dXJuIF9rbGRpdihtYXRyaXgocSksIHApO1xuICAgICAgICB9LFxuXG4gICAgICAgICdNYXRyaXgsIE1hdHJpeCc6IGZ1bmN0aW9uKHEsIHApe1xuICAgICAgICAgICAgcmV0dXJuIF9rbGRpdihxLCBwKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBfa2xkaXYocSwgcCkge1xuICAgICAgICB2YXIgcGxlbmd0aCA9IHAuc2l6ZSgpLmxlbmd0aDtcbiAgICAgICAgdmFyIHFsZW5ndGggPSBxLnNpemUoKS5sZW5ndGg7XG4gICAgICAgIGlmIChwbGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaXJzdCBvYmplY3QgbXVzdCBiZSBvbmUgZGltZW5zaW9uYWwnKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKHFsZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlY29uZCBvYmplY3QgbXVzdCBiZSBvbmUgZGltZW5zaW9uYWwnKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYocGxlbmd0aCAhPT0gcWxlbmd0aCl7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMZW5ndGggb2YgdHdvIHZlY3RvcnMgbXVzdCBiZSBlcXVhbFwiKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy9CZWZvcmUgY2FsY3VsYXRpb24sIGFwcGx5IG5vcm1hbGl6YXRpb25cbiAgICAgICAgdmFyIHN1bXEgPSBzdW0ocSk7XG4gICAgICAgIGlmIChzdW1xID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdW0gb2YgZWxlbWVudHMgaW4gZmlyc3Qgb2JqZWN0IG11c3QgYmUgbm9uIHplcm9cIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3VtcCA9IHN1bShwKTtcbiAgICAgICAgaWYgKHN1bXAgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN1bSBvZiBlbGVtZW50cyBpbiBzZWNvbmQgb2JqZWN0IG11c3QgYmUgbm9uIHplcm9cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHFub3JtID0gZGl2aWRlKHEsIHN1bShxKSk7XG4gICAgICAgIHZhciBwbm9ybSA9IGRpdmlkZShwLCBzdW0ocCkpO1xuXG4gICAgICAgIHZhciByZXN1bHQgPSBzdW0obXVsdGlwbHkocW5vcm0sIGxvZyhkb3REaXZpZGUocW5vcm0sIHBub3JtKSkpKTtcbiAgICAgICAgaWYgKGlzTnVtZXJpYyhyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlci5OYU47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ga2xkaXZlcmdlbmNlO1xufVxuXG5cbmV4cG9ydHMubmFtZSA9ICdrbGRpdmVyZ2VuY2UnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiBcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZXBGb3JFYWNoID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9kZWVwRm9yRWFjaCcpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBhZGQgPSBsb2FkKHJlcXVpcmUoJy4uL2FyaXRobWV0aWMvYWRkJykpO1xuICB2YXIgbXVsdGlwbHkgPSBsb2FkKHJlcXVpcmUoJy4uL2FyaXRobWV0aWMvbXVsdGlwbHknKSk7XG4gIHZhciBkaXZpZGUgPSBsb2FkKHJlcXVpcmUoJy4uL2FyaXRobWV0aWMvZGl2aWRlJykpO1xuICB2YXIgZmFjdG9yaWFsID0gbG9hZChyZXF1aXJlKCcuLi9wcm9iYWJpbGl0eS9mYWN0b3JpYWwnKSk7XG4gIHZhciBpc0ludGVnZXIgPSBsb2FkKHJlcXVpcmUoJy4uL3V0aWxzL2lzSW50ZWdlcicpKTtcbiAgdmFyIGlzUG9zaXRpdmUgPSBsb2FkKHJlcXVpcmUoJy4uL3V0aWxzL2lzUG9zaXRpdmUnKSk7XG5cbiAgLyoqXG4gICAqIE11bHRpbm9taWFsIENvZWZmaWNpZW50cyBjb21wdXRlIHRoZSBudW1iZXIgb2Ygd2F5cyBvZiBwaWNraW5nIGExLCBhMiwgLi4uLCBhaSB1bm9yZGVyZWQgb3V0Y29tZXMgZnJvbSBgbmAgcG9zc2liaWxpdGllcy5cbiAgICpcbiAgICogbXVsdGlub21pYWwgdGFrZXMgb25lIGFycmF5IG9mIGludGVnZXJzIGFzIGFuIGFyZ3VtZW50LlxuICAgKiBUaGUgZm9sbG93aW5nIGNvbmRpdGlvbiBtdXN0IGJlIGVuZm9yY2VkOiBldmVyeSBhaSA8PSAwXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgIG1hdGgubXVsdGlub21pYWwoYSkgLy8gYSBpcyBhbiBhcnJheSB0eXBlXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLm11bHRpbm9taWFsKFsxLDIsMV0pOyAvLyByZXR1cm5zIDEyXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBjb21iaW5hdGlvbnMsIGZhY3RvcmlhbFxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcltdIHwgQmlnTnVtYmVyW119IGEgICAgSW50ZWdlciBudW1iZXJzIG9mIG9iamVjdHMgaW4gdGhlIHN1YnNldFxuICAgKiBAcmV0dXJuIHtOdW1iZXIgfCBCaWdOdW1iZXJ9ICAgICAgICAgTXVsdGlub21pYWwgY29lZmZpY2llbnQuXG4gICAqL1xuICByZXR1cm4gdHlwZWQoJ211bHRpbm9taWFsJywge1xuICAgICdBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uIChhKSB7XG4gICAgICB2YXIgc3VtID0gMDtcbiAgICAgIHZhciBkZW5vbSA9IDE7XG5cbiAgICAgIGRlZXBGb3JFYWNoKGEsIGZ1bmN0aW9uKGFpKSB7XG4gICAgICAgIGlmKCFpc0ludGVnZXIoYWkpIHx8ICFpc1Bvc2l0aXZlKGFpKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Bvc2l0aXZlIGludGVnZXIgdmFsdWUgZXhwZWN0ZWQgaW4gZnVuY3Rpb24gbXVsdGlub21pYWwnKTtcbiAgICAgICAgfVxuICAgICAgICBzdW0gPSBhZGQoc3VtLCBhaSk7XG4gICAgICAgIGRlbm9tID0gbXVsdGlwbHkoZGVub20sIGZhY3RvcmlhbChhaSkpO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBkaXZpZGUoZmFjdG9yaWFsKHN1bSksIGRlbm9tKTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnbXVsdGlub21pYWwnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzSW50ZWdlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL251bWJlcicpLmlzSW50ZWdlcjtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgZmFjdG9yaWFsID0gbG9hZChyZXF1aXJlKCcuL2ZhY3RvcmlhbCcpKTtcblxuICAvKipcbiAgICogQ29tcHV0ZSB0aGUgbnVtYmVyIG9mIHdheXMgb2Ygb2J0YWluaW5nIGFuIG9yZGVyZWQgc3Vic2V0IG9mIGBrYCBlbGVtZW50c1xuICAgKiBmcm9tIGEgc2V0IG9mIGBuYCBlbGVtZW50cy5cbiAgICpcbiAgICogUGVybXV0YXRpb25zIG9ubHkgdGFrZXMgaW50ZWdlciBhcmd1bWVudHMuXG4gICAqIFRoZSBmb2xsb3dpbmcgY29uZGl0aW9uIG11c3QgYmUgZW5mb3JjZWQ6IGsgPD0gbi5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICAgbWF0aC5wZXJtdXRhdGlvbnMobilcbiAgICogICAgIG1hdGgucGVybXV0YXRpb25zKG4sIGspXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLnBlcm11dGF0aW9ucyg1KTsgICAgIC8vIDEyMFxuICAgKiAgICBtYXRoLnBlcm11dGF0aW9ucyg1LCAzKTsgIC8vIDYwXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBjb21iaW5hdGlvbnMsIGZhY3RvcmlhbFxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlciB8IEJpZ051bWJlcn0gbiAgIFRoZSBudW1iZXIgb2Ygb2JqZWN0cyBpbiB0b3RhbFxuICAgKiBAcGFyYW0ge251bWJlciB8IEJpZ051bWJlcn0gW2tdIFRoZSBudW1iZXIgb2Ygb2JqZWN0cyBpbiB0aGUgc3Vic2V0XG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlcn0gICAgVGhlIG51bWJlciBvZiBwZXJtdXRhdGlvbnNcbiAgICovXG4gIHZhciBwZXJtdXRhdGlvbnMgPSB0eXBlZCgncGVybXV0YXRpb25zJywge1xuICAgICdudW1iZXIgfCBCaWdOdW1iZXInOiBmYWN0b3JpYWwsXG5cbiAgICAnbnVtYmVyLCBudW1iZXInOiBmdW5jdGlvbiAobiwgaykge1xuICAgICAgdmFyIHJlc3VsdCwgaTtcblxuICAgICAgaWYgKCFpc0ludGVnZXIobikgfHwgbiA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUG9zaXRpdmUgaW50ZWdlciB2YWx1ZSBleHBlY3RlZCBpbiBmdW5jdGlvbiBwZXJtdXRhdGlvbnMnKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNJbnRlZ2VyKGspIHx8IGsgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Bvc2l0aXZlIGludGVnZXIgdmFsdWUgZXhwZWN0ZWQgaW4gZnVuY3Rpb24gcGVybXV0YXRpb25zJyk7XG4gICAgICB9XG4gICAgICBpZiAoayA+IG4pIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2Vjb25kIGFyZ3VtZW50IGsgbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gZmlyc3QgYXJndW1lbnQgbicpO1xuICAgICAgfVxuXG4gICAgICAvLyBQZXJtdXRlIG4gb2JqZWN0cywgayBhdCBhIHRpbWVcbiAgICAgIHJlc3VsdCA9IDE7XG4gICAgICBmb3IgKGkgPSBuIC0gayArIDE7IGkgPD0gbjsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCAqIGk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgICdCaWdOdW1iZXIsIEJpZ051bWJlcic6IGZ1bmN0aW9uIChuLCBrKSB7XG4gICAgICB2YXIgcmVzdWx0LCBpO1xuXG4gICAgICBpZiAoIWlzUG9zaXRpdmVJbnRlZ2VyKG4pIHx8ICFpc1Bvc2l0aXZlSW50ZWdlcihrKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQb3NpdGl2ZSBpbnRlZ2VyIHZhbHVlIGV4cGVjdGVkIGluIGZ1bmN0aW9uIHBlcm11dGF0aW9ucycpO1xuICAgICAgfVxuICAgICAgaWYgKGsuZ3QobikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2Vjb25kIGFyZ3VtZW50IGsgbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gZmlyc3QgYXJndW1lbnQgbicpO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQgPSBuZXcgdHlwZS5CaWdOdW1iZXIoMSk7XG4gICAgICBmb3IgKGkgPSBuLm1pbnVzKGspLnBsdXMoMSk7IGkubHRlKG4pOyBpID0gaS5wbHVzKDEpKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC50aW1lcyhpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBpbXBsZW1lbnQgc3VwcG9ydCBmb3IgY29sbGVjdGlvbiBpbiBwZXJtdXRhdGlvbnNcbiAgfSk7XG5cbiAgcGVybXV0YXRpb25zLnRvVGV4ID0gJ1xcXFxtYXRocm17JHtuYW1lfX1cXFxcbGVmdCgke2FyZ3N9XFxcXHJpZ2h0KSc7XG5cbiAgcmV0dXJuIHBlcm11dGF0aW9ucztcbn1cblxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgQmlnTnVtYmVyIG4gaXMgYSBwb3NpdGl2ZSBpbnRlZ2VyXG4gKiBAcGFyYW0ge0JpZ051bWJlcn0gblxuICogQHJldHVybnMge2Jvb2xlYW59IGlzUG9zaXRpdmVJbnRlZ2VyXG4gKi9cbmZ1bmN0aW9uIGlzUG9zaXRpdmVJbnRlZ2VyKG4pIHtcbiAgcmV0dXJuIG4uaXNJbnRlZ2VyKCkgJiYgbi5ndGUoMCk7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdwZXJtdXRhdGlvbnMnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgZGlzdHJpYnV0aW9uID0gbG9hZChyZXF1aXJlKCcuL2Rpc3RyaWJ1dGlvbicpKTtcblxuICAvKipcbiAgICogUmFuZG9tIHBpY2sgYSB2YWx1ZSBmcm9tIGEgb25lIGRpbWVuc2lvbmFsIGFycmF5LlxuICAgKiBBcnJheSBlbGVtZW50IGlzIHBpY2tlZCB1c2luZyBhIHJhbmRvbSBmdW5jdGlvbiB3aXRoIHVuaWZvcm0gZGlzdHJpYnV0aW9uLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgICBtYXRoLnBpY2tSYW5kb20oYXJyYXkpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICAgbWF0aC5waWNrUmFuZG9tKFszLCA2LCAxMiwgMl0pOyAgICAgICAvLyByZXR1cm5zIG9uZSBvZiB0aGUgdmFsdWVzIGluIHRoZSBhcnJheVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgIHJhbmRvbSwgcmFuZG9tSW50XG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5ICAgICBBIG9uZSBkaW1lbnNpb25hbCBhcnJheVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE9uZSBvZiB0aGUgZWxlbWVudHMgb2YgdGhlIHByb3ZpZGVkIGlucHV0IGFycmF5XG4gICAqL1xuICAvLyBUT0RPOiByZXdvcmsgcGlja1JhbmRvbSB0byBhIHR5cGVkLWZ1bmN0aW9uXG4gIHZhciBwaWNrUmFuZG9tID0gIGRpc3RyaWJ1dGlvbigndW5pZm9ybScpLnBpY2tSYW5kb207XG5cbiAgcGlja1JhbmRvbS50b1RleCA9ICdcXFxcbWF0aHJteyR7bmFtZX19XFxcXGxlZnQoJHthcmdzfVxcXFxyaWdodCknO1xuXG4gIHJldHVybiBwaWNrUmFuZG9tO1xufVxuXG5leHBvcnRzLm5hbWUgPSAncGlja1JhbmRvbSc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBkaXN0cmlidXRpb24gPSBsb2FkKHJlcXVpcmUoJy4vZGlzdHJpYnV0aW9uJykpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSByYW5kb20gbnVtYmVyIGxhcmdlciBvciBlcXVhbCB0byBgbWluYCBhbmQgc21hbGxlciB0aGFuIGBtYXhgXG4gICAqIHVzaW5nIGEgdW5pZm9ybSBkaXN0cmlidXRpb24uXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgIG1hdGgucmFuZG9tKCkgICAgICAgICAgICAgICAgLy8gZ2VuZXJhdGUgYSByYW5kb20gbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgKiAgICAgbWF0aC5yYW5kb20obWF4KSAgICAgICAgICAgICAvLyBnZW5lcmF0ZSBhIHJhbmRvbSBudW1iZXIgYmV0d2VlbiAwIGFuZCBtYXhcbiAgICogICAgIG1hdGgucmFuZG9tKG1pbiwgbWF4KSAgICAgICAgLy8gZ2VuZXJhdGUgYSByYW5kb20gbnVtYmVyIGJldHdlZW4gbWluIGFuZCBtYXhcbiAgICogICAgIG1hdGgucmFuZG9tKHNpemUpICAgICAgICAgICAgLy8gZ2VuZXJhdGUgYSBtYXRyaXggd2l0aCByYW5kb20gbnVtYmVycyBiZXR3ZWVuIDAgYW5kIDFcbiAgICogICAgIG1hdGgucmFuZG9tKHNpemUsIG1heCkgICAgICAgLy8gZ2VuZXJhdGUgYSBtYXRyaXggd2l0aCByYW5kb20gbnVtYmVycyBiZXR3ZWVuIDAgYW5kIG1heFxuICAgKiAgICAgbWF0aC5yYW5kb20oc2l6ZSwgbWluLCBtYXgpICAvLyBnZW5lcmF0ZSBhIG1hdHJpeCB3aXRoIHJhbmRvbSBudW1iZXJzIGJldHdlZW4gbWluIGFuZCBtYXhcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgICBtYXRoLnJhbmRvbSgpOyAgICAgICAvLyByZXR1cm5zIGEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICogICAgIG1hdGgucmFuZG9tKDEwMCk7ICAgIC8vIHJldHVybnMgYSByYW5kb20gbnVtYmVyIGJldHdlZW4gMCBhbmQgMTAwXG4gICAqICAgICBtYXRoLnJhbmRvbSgzMCwgNDApOyAvLyByZXR1cm5zIGEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIDMwIGFuZCA0MFxuICAgKiAgICAgbWF0aC5yYW5kb20oWzIsIDNdKTsgLy8gcmV0dXJucyBhIDJ4MyBtYXRyaXggd2l0aCByYW5kb20gbnVtYmVycyBiZXR3ZWVuIDAgYW5kIDFcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgICByYW5kb21JbnQsIHBpY2tSYW5kb21cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheSB8IE1hdHJpeH0gW3NpemVdIElmIHByb3ZpZGVkLCBhbiBhcnJheSBvciBtYXRyaXggd2l0aCBnaXZlblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZSBhbmQgZmlsbGVkIHdpdGggcmFuZG9tIHZhbHVlcyBpcyByZXR1cm5lZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW21pbl0gIE1pbmltdW0gYm91bmRhcnkgZm9yIHRoZSByYW5kb20gdmFsdWUsIGluY2x1ZGVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4XSAgTWF4aW11bSBib3VuZGFyeSBmb3IgdGhlIHJhbmRvbSB2YWx1ZSwgZXhjbHVkZWRcbiAgICogQHJldHVybiB7bnVtYmVyIHwgQXJyYXkgfCBNYXRyaXh9IEEgcmFuZG9tIG51bWJlclxuICAgKi9cbiAgLy8gVE9ETzogcmV3b3JrIHJhbmRvbSB0byBhIHR5cGVkLWZ1bmN0aW9uXG4gIHZhciByYW5kb20gPSBkaXN0cmlidXRpb24oJ3VuaWZvcm0nKS5yYW5kb207XG5cbiAgcmFuZG9tLnRvVGV4ID0gJ1xcXFxtYXRocm17JHtuYW1lfX1cXFxcbGVmdCgke2FyZ3N9XFxcXHJpZ2h0KSc7XG5cbiAgcmV0dXJuIHJhbmRvbTtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ3JhbmRvbSc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBkaXN0cmlidXRpb24gPSBsb2FkKHJlcXVpcmUoJy4vZGlzdHJpYnV0aW9uJykpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSByYW5kb20gaW50ZWdlciBudW1iZXIgbGFyZ2VyIG9yIGVxdWFsIHRvIGBtaW5gIGFuZCBzbWFsbGVyIHRoYW4gYG1heGBcbiAgICogdXNpbmcgYSB1bmlmb3JtIGRpc3RyaWJ1dGlvbi5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICAgbWF0aC5yYW5kb21JbnQobWF4KSAgICAgICAgICAgICAvLyBnZW5lcmF0ZSBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgbWF4XG4gICAqICAgICBtYXRoLnJhbmRvbUludChtaW4sIG1heCkgICAgICAgIC8vIGdlbmVyYXRlIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiBtaW4gYW5kIG1heFxuICAgKiAgICAgbWF0aC5yYW5kb21JbnQoc2l6ZSkgICAgICAgICAgICAvLyBnZW5lcmF0ZSBhIG1hdHJpeCB3aXRoIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgMVxuICAgKiAgICAgbWF0aC5yYW5kb21JbnQoc2l6ZSwgbWF4KSAgICAgICAvLyBnZW5lcmF0ZSBhIG1hdHJpeCB3aXRoIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgbWF4XG4gICAqICAgICBtYXRoLnJhbmRvbUludChzaXplLCBtaW4sIG1heCkgIC8vIGdlbmVyYXRlIGEgbWF0cml4IHdpdGggcmFuZG9tIGludGVnZXIgYmV0d2VlbiBtaW4gYW5kIG1heFxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgIG1hdGgucmFuZG9tSW50KDEwMCk7ICAgIC8vIHJldHVybnMgYSByYW5kb20gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDEwMFxuICAgKiAgICAgbWF0aC5yYW5kb21JbnQoMzAsIDQwKTsgLy8gcmV0dXJucyBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gMzAgYW5kIDQwXG4gICAqICAgICBtYXRoLnJhbmRvbUludChbMiwgM10pOyAvLyByZXR1cm5zIGEgMngzIG1hdHJpeCB3aXRoIHJhbmRvbSBpbnRlZ2VycyBiZXR3ZWVuIDAgYW5kIDFcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgICByYW5kb20sIHBpY2tSYW5kb21cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheSB8IE1hdHJpeH0gW3NpemVdIElmIHByb3ZpZGVkLCBhbiBhcnJheSBvciBtYXRyaXggd2l0aCBnaXZlblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZSBhbmQgZmlsbGVkIHdpdGggcmFuZG9tIHZhbHVlcyBpcyByZXR1cm5lZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW21pbl0gIE1pbmltdW0gYm91bmRhcnkgZm9yIHRoZSByYW5kb20gdmFsdWUsIGluY2x1ZGVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4XSAgTWF4aW11bSBib3VuZGFyeSBmb3IgdGhlIHJhbmRvbSB2YWx1ZSwgZXhjbHVkZWRcbiAgICogQHJldHVybiB7bnVtYmVyIHwgQXJyYXkgfCBNYXRyaXh9IEEgcmFuZG9tIGludGVnZXIgdmFsdWVcbiAgICovXG4gIC8vIFRPRE86IHJld29yayByYW5kb21JbnQgdG8gYSB0eXBlZC1mdW5jdGlvblxuICB2YXIgcmFuZG9tSW50ID0gZGlzdHJpYnV0aW9uKCd1bmlmb3JtJykucmFuZG9tSW50O1xuXG4gIHJhbmRvbUludC50b1RleCA9ICdcXFxcbWF0aHJteyR7bmFtZX19XFxcXGxlZnQoJHthcmdzfVxcXFxyaWdodCknO1xuXG4gIHJldHVybiByYW5kb21JbnQ7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdyYW5kb21JbnQnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG5lYXJseUVxdWFsID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbnVtYmVyJykubmVhcmx5RXF1YWw7XG52YXIgYmlnTmVhcmx5RXF1YWwgPSByZXF1aXJlKCcuLi8uLi91dGlscy9iaWdudW1iZXIvbmVhcmx5RXF1YWwnKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuXG4gIHZhciBtYXRyaXggPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L2Z1bmN0aW9uL21hdHJpeCcpKTtcblxuICB2YXIgYWxnb3JpdGhtMDMgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTAzJykpO1xuICB2YXIgYWxnb3JpdGhtMDUgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTA1JykpO1xuICB2YXIgYWxnb3JpdGhtMTIgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTEyJykpO1xuICB2YXIgYWxnb3JpdGhtMTMgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTEzJykpO1xuICB2YXIgYWxnb3JpdGhtMTQgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTE0JykpO1xuICBcbiAgLyoqXG4gICAqIENvbXBhcmUgdHdvIHZhbHVlcy4gUmV0dXJucyAxIHdoZW4geCA+IHksIC0xIHdoZW4geCA8IHksIGFuZCAwIHdoZW4geCA9PSB5LlxuICAgKlxuICAgKiB4IGFuZCB5IGFyZSBjb25zaWRlcmVkIGVxdWFsIHdoZW4gdGhlIHJlbGF0aXZlIGRpZmZlcmVuY2UgYmV0d2VlbiB4IGFuZCB5XG4gICAqIGlzIHNtYWxsZXIgdGhhbiB0aGUgY29uZmlndXJlZCBlcHNpbG9uLiBUaGUgZnVuY3Rpb24gY2Fubm90IGJlIHVzZWQgdG9cbiAgICogY29tcGFyZSB2YWx1ZXMgc21hbGxlciB0aGFuIGFwcHJveGltYXRlbHkgMi4yMmUtMTYuXG4gICAqXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5jb21wYXJlKHgsIHkpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmNvbXBhcmUoNiwgMSk7ICAgICAgICAgICAvLyByZXR1cm5zIDFcbiAgICogICAgbWF0aC5jb21wYXJlKDIsIDMpOyAgICAgICAgICAgLy8gcmV0dXJucyAtMVxuICAgKiAgICBtYXRoLmNvbXBhcmUoNywgNyk7ICAgICAgICAgICAvLyByZXR1cm5zIDBcbiAgICpcbiAgICogICAgdmFyIGEgPSBtYXRoLnVuaXQoJzUgY20nKTtcbiAgICogICAgdmFyIGIgPSBtYXRoLnVuaXQoJzQwIG1tJyk7XG4gICAqICAgIG1hdGguY29tcGFyZShhLCBiKTsgICAgICAgICAgIC8vIHJldHVybnMgMVxuICAgKlxuICAgKiAgICBtYXRoLmNvbXBhcmUoMiwgWzEsIDIsIDNdKTsgICAvLyByZXR1cm5zIFsxLCAwLCAtMV1cbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGVxdWFsLCB1bmVxdWFsLCBzbWFsbGVyLCBzbWFsbGVyRXEsIGxhcmdlciwgbGFyZ2VyRXFcbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb24gfCBVbml0IHwgc3RyaW5nIHwgQXJyYXkgfCBNYXRyaXh9IHggRmlyc3QgdmFsdWUgdG8gY29tcGFyZVxuICAgKiBAcGFyYW0gIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IFVuaXQgfCBzdHJpbmcgfCBBcnJheSB8IE1hdHJpeH0geSBTZWNvbmQgdmFsdWUgdG8gY29tcGFyZVxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IEFycmF5IHwgTWF0cml4fSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIGNvbXBhcmlzb246IDEsIDAgb3IgLTEuXG4gICAqL1xuICB2YXIgY29tcGFyZSA9IHR5cGVkKCdjb21wYXJlJywge1xuXG4gICAgJ2Jvb2xlYW4sIGJvb2xlYW4nOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIHggPT09IHkgPyAwIDogKHggPiB5ID8gMSA6IC0xKTtcbiAgICB9LFxuXG4gICAgJ251bWJlciwgbnVtYmVyJzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHJldHVybiAoeCA9PT0geSB8fCBuZWFybHlFcXVhbCh4LCB5LCBjb25maWcuZXBzaWxvbikpXG4gICAgICAgICAgPyAwXG4gICAgICAgICAgOiAoeCA+IHkgPyAxIDogLTEpO1xuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyLCBCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuICh4LmVxKHkpIHx8IGJpZ05lYXJseUVxdWFsKHgsIHksIGNvbmZpZy5lcHNpbG9uKSlcbiAgICAgICAgICA/IG5ldyB0eXBlLkJpZ051bWJlcigwKVxuICAgICAgICAgIDogbmV3IHR5cGUuQmlnTnVtYmVyKHguY21wKHkpKTtcbiAgICB9LFxuXG4gICAgJ0ZyYWN0aW9uLCBGcmFjdGlvbic6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4gbmV3IHR5cGUuRnJhY3Rpb24oeC5jb21wYXJlKHkpKTtcbiAgICB9LFxuXG4gICAgJ0NvbXBsZXgsIENvbXBsZXgnOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdObyBvcmRlcmluZyByZWxhdGlvbiBpcyBkZWZpbmVkIGZvciBjb21wbGV4IG51bWJlcnMnKTtcbiAgICB9LFxuXG4gICAgJ1VuaXQsIFVuaXQnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgaWYgKCF4LmVxdWFsQmFzZSh5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb21wYXJlIHVuaXRzIHdpdGggZGlmZmVyZW50IGJhc2UnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21wYXJlKHgudmFsdWUsIHkudmFsdWUpO1xuICAgIH0sXG5cbiAgICAnc3RyaW5nLCBzdHJpbmcnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIHggPT09IHkgPyAwIDogKHggPiB5ID8gMSA6IC0xKTtcbiAgICB9LFxuXG4gICAgJ01hdHJpeCwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHJlc3VsdFxuICAgICAgdmFyIGM7XG5cbiAgICAgIC8vIHByb2Nlc3MgbWF0cml4IHN0b3JhZ2VcbiAgICAgIHN3aXRjaCAoeC5zdG9yYWdlKCkpIHtcbiAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICBzd2l0Y2ggKHkuc3RvcmFnZSgpKSB7XG4gICAgICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgICAgICAvLyBzcGFyc2UgKyBzcGFyc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTA1KHgsIHksIGNvbXBhcmUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIHNwYXJzZSArIGRlbnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0wMyh5LCB4LCBjb21wYXJlLCB0cnVlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgICAgIC8vIGRlbnNlICsgc3BhcnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0wMyh4LCB5LCBjb21wYXJlLCBmYWxzZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgLy8gZGVuc2UgKyBkZW5zZVxuICAgICAgICAgICAgICBjID0gYWxnb3JpdGhtMTMoeCwgeSwgY29tcGFyZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG5cbiAgICAnQXJyYXksIEFycmF5JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBjb21wYXJlKG1hdHJpeCh4KSwgbWF0cml4KHkpKS52YWx1ZU9mKCk7XG4gICAgfSxcblxuICAgICdBcnJheSwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBjb21wYXJlKG1hdHJpeCh4KSwgeSk7XG4gICAgfSxcblxuICAgICdNYXRyaXgsIEFycmF5JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBjb21wYXJlKHgsIG1hdHJpeCh5KSk7XG4gICAgfSxcblxuICAgICdNYXRyaXgsIGFueSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuICAgICAgLy8gY2hlY2sgc3RvcmFnZSBmb3JtYXRcbiAgICAgIHN3aXRjaCAoeC5zdG9yYWdlKCkpIHtcbiAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTIoeCwgeSwgY29tcGFyZSwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xNCh4LCB5LCBjb21wYXJlLCBmYWxzZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuXG4gICAgJ2FueSwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHJlc3VsdFxuICAgICAgdmFyIGM7XG4gICAgICAvLyBjaGVjayBzdG9yYWdlIGZvcm1hdFxuICAgICAgc3dpdGNoICh5LnN0b3JhZ2UoKSkge1xuICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xMih5LCB4LCBjb21wYXJlLCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTQoeSwgeCwgY29tcGFyZSwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBhbnknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGFsZ29yaXRobTE0KG1hdHJpeCh4KSwgeSwgY29tcGFyZSwgZmFsc2UpLnZhbHVlT2YoKTtcbiAgICB9LFxuXG4gICAgJ2FueSwgQXJyYXknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGFsZ29yaXRobTE0KG1hdHJpeCh5KSwgeCwgY29tcGFyZSwgdHJ1ZSkudmFsdWVPZigpO1xuICAgIH1cbiAgfSk7XG5cbiAgY29tcGFyZS50b1RleCA9ICdcXFxcbWF0aHJteyR7bmFtZX19XFxcXGxlZnQoJHthcmdzfVxcXFxyaWdodCknO1xuXG4gIHJldHVybiBjb21wYXJlO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnY29tcGFyZSc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBlcXVhbCA9IGxvYWQocmVxdWlyZSgnLi9lcXVhbCcpKTtcblxuICAvKipcbiAgICogVGVzdCBlbGVtZW50IHdpc2Ugd2hldGhlciB0d28gbWF0cmljZXMgYXJlIGVxdWFsLlxuICAgKiBUaGUgZnVuY3Rpb24gYWNjZXB0cyBib3RoIG1hdHJpY2VzIGFuZCBzY2FsYXIgdmFsdWVzLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguZGVlcEVxdWFsKHgsIHkpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmRlZXBFcXVhbCgyLCA0KTsgICAvLyByZXR1cm5zIGZhbHNlXG4gICAqXG4gICAqICAgIGEgPSBbMiwgNSwgMV07XG4gICAqICAgIGIgPSBbMiwgNywgMV07XG4gICAqXG4gICAqICAgIG1hdGguZGVlcEVxdWFsKGEsIGIpOyAgIC8vIHJldHVybnMgZmFsc2VcbiAgICogICAgbWF0aC5lcXVhbChhLCBiKTsgICAgICAgLy8gcmV0dXJucyBbdHJ1ZSwgZmFsc2UsIHRydWVdXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBlcXVhbCwgdW5lcXVhbFxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXh9IHggRmlyc3QgbWF0cml4IHRvIGNvbXBhcmVcbiAgICogQHBhcmFtICB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb24gfCBDb21wbGV4IHwgVW5pdCB8IEFycmF5IHwgTWF0cml4fSB5IFNlY29uZCBtYXRyaXggdG8gY29tcGFyZVxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXh9XG4gICAqICAgICAgICAgICAgUmV0dXJucyB0cnVlIHdoZW4gdGhlIGlucHV0IG1hdHJpY2VzIGhhdmUgdGhlIHNhbWUgc2l6ZSBhbmQgZWFjaCBvZiB0aGVpciBlbGVtZW50cyBpcyBlcXVhbC5cbiAgICovXG4gIHZhciBkZWVwRXF1YWwgPSB0eXBlZCgnZGVlcEVxdWFsJywge1xuICAgICdhbnksIGFueSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4gX2RlZXBFcXVhbCh4LnZhbHVlT2YoKSwgeS52YWx1ZU9mKCkpO1xuICAgIH1cbiAgfSk7XG5cbiAgZGVlcEVxdWFsLnRvVGV4ID0gJ1xcXFxtYXRocm17JHtuYW1lfX1cXFxcbGVmdCgke2FyZ3N9XFxcXHJpZ2h0KSc7XG5cbiAgcmV0dXJuIGRlZXBFcXVhbDtcblxuICAvKipcbiAgICogVGVzdCB3aGV0aGVyIHR3byBhcnJheXMgaGF2ZSB0aGUgc2FtZSBzaXplIGFuZCBhbGwgZWxlbWVudHMgYXJlIGVxdWFsXG4gICAqIEBwYXJhbSB7QXJyYXkgfCAqfSB4XG4gICAqIEBwYXJhbSB7QXJyYXkgfCAqfSB5XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBib3RoIGFycmF5cyBhcmUgZGVlcCBlcXVhbFxuICAgKi9cbiAgZnVuY3Rpb24gX2RlZXBFcXVhbCh4LCB5KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoeCkpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHkpKSB7XG4gICAgICAgIHZhciBsZW4gPSB4Lmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiAhPT0geS5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKCFfZGVlcEVxdWFsKHhbaV0sIHlbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZXF1YWwoeCwgeSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMubmFtZSA9ICdkZWVwRXF1YWwnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICBcbiAgdmFyIG1hdHJpeCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvZnVuY3Rpb24vbWF0cml4JykpO1xuICB2YXIgZXF1YWxTY2FsYXIgPSBsb2FkKHJlcXVpcmUoJy4vZXF1YWxTY2FsYXInKSk7XG5cbiAgdmFyIGFsZ29yaXRobTAzID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0wMycpKTtcbiAgdmFyIGFsZ29yaXRobTA3ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0wNycpKTtcbiAgdmFyIGFsZ29yaXRobTEyID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xMicpKTtcbiAgdmFyIGFsZ29yaXRobTEzID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xMycpKTtcbiAgdmFyIGFsZ29yaXRobTE0ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xNCcpKTtcblxuICB2YXIgbGF0ZXggPSByZXF1aXJlKCcuLi8uLi91dGlscy9sYXRleCcpO1xuXG4gIC8qKlxuICAgKiBUZXN0IHdoZXRoZXIgdHdvIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAqXG4gICAqIFRoZSBmdW5jdGlvbiB0ZXN0cyB3aGV0aGVyIHRoZSByZWxhdGl2ZSBkaWZmZXJlbmNlIGJldHdlZW4geCBhbmQgeSBpc1xuICAgKiBzbWFsbGVyIHRoYW4gdGhlIGNvbmZpZ3VyZWQgZXBzaWxvbi4gVGhlIGZ1bmN0aW9uIGNhbm5vdCBiZSB1c2VkIHRvXG4gICAqIGNvbXBhcmUgdmFsdWVzIHNtYWxsZXIgdGhhbiBhcHByb3hpbWF0ZWx5IDIuMjJlLTE2LlxuICAgKlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKiBJbiBjYXNlIG9mIGNvbXBsZXggbnVtYmVycywgeC5yZSBtdXN0IGVxdWFsIHkucmUsIGFuZCB4LmltIG11c3QgZXF1YWwgeS5pbS5cbiAgICpcbiAgICogVmFsdWVzIGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgYXJlIGNvbXBhcmVkIHN0cmljdGx5LCB0aHVzIGBudWxsYCBpcyBvbmx5XG4gICAqIGVxdWFsIHRvIGBudWxsYCBhbmQgbm90aGluZyBlbHNlLCBhbmQgYHVuZGVmaW5lZGAgaXMgb25seSBlcXVhbCB0b1xuICAgKiBgdW5kZWZpbmVkYCBhbmQgbm90aGluZyBlbHNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguZXF1YWwoeCwgeSlcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGguZXF1YWwoMiArIDIsIDMpOyAgICAgICAgIC8vIHJldHVybnMgZmFsc2VcbiAgICogICAgbWF0aC5lcXVhbCgyICsgMiwgNCk7ICAgICAgICAgLy8gcmV0dXJucyB0cnVlXG4gICAqXG4gICAqICAgIHZhciBhID0gbWF0aC51bml0KCc1MCBjbScpO1xuICAgKiAgICB2YXIgYiA9IG1hdGgudW5pdCgnNSBtJyk7XG4gICAqICAgIG1hdGguZXF1YWwoYSwgYik7ICAgICAgICAgICAgIC8vIHJldHVybnMgdHJ1ZVxuICAgKlxuICAgKiAgICB2YXIgYyA9IFsyLCA1LCAxXTtcbiAgICogICAgdmFyIGQgPSBbMiwgNywgMV07XG4gICAqXG4gICAqICAgIG1hdGguZXF1YWwoYywgZCk7ICAgICAgICAgICAgIC8vIHJldHVybnMgW3RydWUsIGZhbHNlLCB0cnVlXVxuICAgKiAgICBtYXRoLmRlZXBFcXVhbChjLCBkKTsgICAgICAgICAvLyByZXR1cm5zIGZhbHNlXG4gICAqXG4gICAqICAgIG1hdGguZXF1YWwoMCwgbnVsbCk7ICAgICAgICAgIC8vIHJldHVybnMgZmFsc2VcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIHVuZXF1YWwsIHNtYWxsZXIsIHNtYWxsZXJFcSwgbGFyZ2VyLCBsYXJnZXJFcSwgY29tcGFyZSwgZGVlcEVxdWFsXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlciB8IEJpZ051bWJlciB8IGJvb2xlYW4gfCBDb21wbGV4IHwgVW5pdCB8IHN0cmluZyB8IEFycmF5IHwgTWF0cml4fSB4IEZpcnN0IHZhbHVlIHRvIGNvbXBhcmVcbiAgICogQHBhcmFtICB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgYm9vbGVhbiB8IENvbXBsZXggfCBVbml0IHwgc3RyaW5nIHwgQXJyYXkgfCBNYXRyaXh9IHkgU2Vjb25kIHZhbHVlIHRvIGNvbXBhcmVcbiAgICogQHJldHVybiB7Ym9vbGVhbiB8IEFycmF5IHwgTWF0cml4fSBSZXR1cm5zIHRydWUgd2hlbiB0aGUgY29tcGFyZWQgdmFsdWVzIGFyZSBlcXVhbCwgZWxzZSByZXR1cm5zIGZhbHNlXG4gICAqL1xuICB2YXIgZXF1YWwgPSB0eXBlZCgnZXF1YWwnLCB7XG4gICAgXG4gICAgJ2FueSwgYW55JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHN0cmljdCBlcXVhbGl0eSBmb3IgbnVsbCBhbmQgdW5kZWZpbmVkP1xuICAgICAgaWYgKHggPT09IG51bGwpIHsgcmV0dXJuIHkgPT09IG51bGw7IH1cbiAgICAgIGlmICh5ID09PSBudWxsKSB7IHJldHVybiB4ID09PSBudWxsOyB9XG4gICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB5ID09PSB1bmRlZmluZWQ7IH1cbiAgICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHggPT09IHVuZGVmaW5lZDsgfVxuXG4gICAgICByZXR1cm4gZXF1YWxTY2FsYXIoeCwgeSk7XG4gICAgfSxcblxuICAgICdNYXRyaXgsIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuXG4gICAgICAvLyBwcm9jZXNzIG1hdHJpeCBzdG9yYWdlXG4gICAgICBzd2l0Y2ggKHguc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgc3dpdGNoICh5LnN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICAgICAgLy8gc3BhcnNlICsgc3BhcnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0wNyh4LCB5LCBlcXVhbFNjYWxhcik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgLy8gc3BhcnNlICsgZGVuc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTAzKHksIHgsIGVxdWFsU2NhbGFyLCB0cnVlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgICAgIC8vIGRlbnNlICsgc3BhcnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0wMyh4LCB5LCBlcXVhbFNjYWxhciwgZmFsc2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIGRlbnNlICsgZGVuc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTEzKHgsIHksIGVxdWFsU2NhbGFyKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfSxcbiAgICBcbiAgICAnQXJyYXksIEFycmF5JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBlcXVhbChtYXRyaXgoeCksIG1hdHJpeCh5KSkudmFsdWVPZigpO1xuICAgIH0sXG5cbiAgICAnQXJyYXksIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gZXF1YWwobWF0cml4KHgpLCB5KTtcbiAgICB9LFxuXG4gICAgJ01hdHJpeCwgQXJyYXknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGVxdWFsKHgsIG1hdHJpeCh5KSk7XG4gICAgfSxcbiAgICBcbiAgICAnTWF0cml4LCBhbnknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gcmVzdWx0XG4gICAgICB2YXIgYztcbiAgICAgIC8vIGNoZWNrIHN0b3JhZ2UgZm9ybWF0XG4gICAgICBzd2l0Y2ggKHguc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTEyKHgsIHksIGVxdWFsU2NhbGFyLCBmYWxzZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTE0KHgsIHksIGVxdWFsU2NhbGFyLCBmYWxzZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuXG4gICAgJ2FueSwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHJlc3VsdFxuICAgICAgdmFyIGM7XG4gICAgICAvLyBjaGVjayBzdG9yYWdlIGZvcm1hdFxuICAgICAgc3dpdGNoICh5LnN0b3JhZ2UoKSkge1xuICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xMih5LCB4LCBlcXVhbFNjYWxhciwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTE0KHksIHgsIGVxdWFsU2NhbGFyLCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG5cbiAgICAnQXJyYXksIGFueSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gYWxnb3JpdGhtMTQobWF0cml4KHgpLCB5LCBlcXVhbFNjYWxhciwgZmFsc2UpLnZhbHVlT2YoKTtcbiAgICB9LFxuXG4gICAgJ2FueSwgQXJyYXknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGFsZ29yaXRobTE0KG1hdHJpeCh5KSwgeCwgZXF1YWxTY2FsYXIsIHRydWUpLnZhbHVlT2YoKTtcbiAgICB9XG4gIH0pO1xuXG4gIGVxdWFsLnRvVGV4ID0gJ1xcXFxsZWZ0KCR7YXJnc1swXX0nICsgbGF0ZXgub3BlcmF0b3JzWydlcXVhbCddICsgJyR7YXJnc1sxXX1cXFxccmlnaHQpJztcblxuICByZXR1cm4gZXF1YWw7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdlcXVhbCc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbmVhcmx5RXF1YWwgPSByZXF1aXJlKCcuLi8uLi91dGlscy9udW1iZXInKS5uZWFybHlFcXVhbDtcbnZhciBiaWdOZWFybHlFcXVhbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2JpZ251bWJlci9uZWFybHlFcXVhbCcpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIFxuICAvKipcbiAgICogVGVzdCB3aGV0aGVyIHR3byB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IGJvb2xlYW4gfCBDb21wbGV4IHwgVW5pdH0geCAgIEZpcnN0IHZhbHVlIHRvIGNvbXBhcmVcbiAgICogQHBhcmFtICB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb24gfCBib29sZWFuIHwgQ29tcGxleH0geSAgICAgICAgICBTZWNvbmQgdmFsdWUgdG8gY29tcGFyZVxuICAgKiBAcmV0dXJuIHtib29sZWFufSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmV0dXJucyB0cnVlIHdoZW4gdGhlIGNvbXBhcmVkIHZhbHVlcyBhcmUgZXF1YWwsIGVsc2UgcmV0dXJucyBmYWxzZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdmFyIGVxdWFsU2NhbGFyID0gdHlwZWQoJ2VxdWFsU2NhbGFyJywge1xuXG4gICAgJ2Jvb2xlYW4sIGJvb2xlYW4nOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIHggPT09IHk7XG4gICAgfSxcblxuICAgICdudW1iZXIsIG51bWJlcic6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4geCA9PT0geSB8fCBuZWFybHlFcXVhbCh4LCB5LCBjb25maWcuZXBzaWxvbik7XG4gICAgfSxcblxuICAgICdCaWdOdW1iZXIsIEJpZ051bWJlcic6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4geC5lcSh5KSB8fCBiaWdOZWFybHlFcXVhbCh4LCB5LCBjb25maWcuZXBzaWxvbik7XG4gICAgfSxcblxuICAgICdGcmFjdGlvbiwgRnJhY3Rpb24nOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIHguZXF1YWxzKHkpO1xuICAgIH0sXG5cbiAgICAnQ29tcGxleCwgQ29tcGxleCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4geC5lcXVhbHMoeSk7XG4gICAgfSxcblxuICAgICdVbml0LCBVbml0JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIGlmICgheC5lcXVhbEJhc2UoeSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29tcGFyZSB1bml0cyB3aXRoIGRpZmZlcmVudCBiYXNlJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXF1YWxTY2FsYXIoeC52YWx1ZSwgeS52YWx1ZSk7XG4gICAgfSxcblxuICAgICdzdHJpbmcsIHN0cmluZyc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4geCA9PT0geTtcbiAgICB9XG4gIH0pO1xuICBcbiAgcmV0dXJuIGVxdWFsU2NhbGFyO1xufVxuXG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBbXG4gIHJlcXVpcmUoJy4vY29tcGFyZScpLFxuICByZXF1aXJlKCcuL2RlZXBFcXVhbCcpLFxuICByZXF1aXJlKCcuL2VxdWFsJyksXG4gIHJlcXVpcmUoJy4vbGFyZ2VyJyksXG4gIHJlcXVpcmUoJy4vbGFyZ2VyRXEnKSxcbiAgcmVxdWlyZSgnLi9zbWFsbGVyJyksXG4gIHJlcXVpcmUoJy4vc21hbGxlckVxJyksXG4gIHJlcXVpcmUoJy4vdW5lcXVhbCcpXG5dO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbmVhcmx5RXF1YWwgPSByZXF1aXJlKCcuLi8uLi91dGlscy9udW1iZXInKS5uZWFybHlFcXVhbDtcbnZhciBiaWdOZWFybHlFcXVhbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2JpZ251bWJlci9uZWFybHlFcXVhbCcpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIFxuICB2YXIgbWF0cml4ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC9mdW5jdGlvbi9tYXRyaXgnKSk7XG5cbiAgdmFyIGFsZ29yaXRobTAzID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0wMycpKTtcbiAgdmFyIGFsZ29yaXRobTA3ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0wNycpKTtcbiAgdmFyIGFsZ29yaXRobTEyID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xMicpKTtcbiAgdmFyIGFsZ29yaXRobTEzID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xMycpKTtcbiAgdmFyIGFsZ29yaXRobTE0ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xNCcpKTtcblxuICB2YXIgbGF0ZXggPSByZXF1aXJlKCcuLi8uLi91dGlscy9sYXRleCcpO1xuXG4gIC8qKlxuICAgKiBUZXN0IHdoZXRoZXIgdmFsdWUgeCBpcyBsYXJnZXIgdGhhbiB5LlxuICAgKlxuICAgKiBUaGUgZnVuY3Rpb24gcmV0dXJucyB0cnVlIHdoZW4geCBpcyBsYXJnZXIgdGhhbiB5IGFuZCB0aGUgcmVsYXRpdmVcbiAgICogZGlmZmVyZW5jZSBiZXR3ZWVuIHggYW5kIHkgaXMgbGFyZ2VyIHRoYW4gdGhlIGNvbmZpZ3VyZWQgZXBzaWxvbi4gVGhlXG4gICAqIGZ1bmN0aW9uIGNhbm5vdCBiZSB1c2VkIHRvIGNvbXBhcmUgdmFsdWVzIHNtYWxsZXIgdGhhbiBhcHByb3hpbWF0ZWx5IDIuMjJlLTE2LlxuICAgKlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGgubGFyZ2VyKHgsIHkpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmxhcmdlcigyLCAzKTsgICAgICAgICAgICAgLy8gcmV0dXJucyBmYWxzZVxuICAgKiAgICBtYXRoLmxhcmdlcig1LCAyICsgMik7ICAgICAgICAgLy8gcmV0dXJucyB0cnVlXG4gICAqXG4gICAqICAgIHZhciBhID0gbWF0aC51bml0KCc1IGNtJyk7XG4gICAqICAgIHZhciBiID0gbWF0aC51bml0KCcyIGluY2gnKTtcbiAgICogICAgbWF0aC5sYXJnZXIoYSwgYik7ICAgICAgICAgICAgIC8vIHJldHVybnMgZmFsc2VcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGVxdWFsLCB1bmVxdWFsLCBzbWFsbGVyLCBzbWFsbGVyRXEsIGxhcmdlckVxLCBjb21wYXJlXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgYm9vbGVhbiB8IFVuaXQgfCBzdHJpbmcgfCBBcnJheSB8IE1hdHJpeH0geCBGaXJzdCB2YWx1ZSB0byBjb21wYXJlXG4gICAqIEBwYXJhbSAge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgYm9vbGVhbiB8IFVuaXQgfCBzdHJpbmcgfCBBcnJheSB8IE1hdHJpeH0geSBTZWNvbmQgdmFsdWUgdG8gY29tcGFyZVxuICAgKiBAcmV0dXJuIHtib29sZWFuIHwgQXJyYXkgfCBNYXRyaXh9IFJldHVybnMgdHJ1ZSB3aGVuIHRoZSB4IGlzIGxhcmdlciB0aGFuIHksIGVsc2UgcmV0dXJucyBmYWxzZVxuICAgKi9cbiAgdmFyIGxhcmdlciA9IHR5cGVkKCdsYXJnZXInLCB7XG5cbiAgICAnYm9vbGVhbiwgYm9vbGVhbic6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4geCA+IHk7XG4gICAgfSxcblxuICAgICdudW1iZXIsIG51bWJlcic6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4geCA+IHkgJiYgIW5lYXJseUVxdWFsKHgsIHksIGNvbmZpZy5lcHNpbG9uKTtcbiAgICB9LFxuXG4gICAgJ0JpZ051bWJlciwgQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHJldHVybiB4Lmd0KHkpICYmICFiaWdOZWFybHlFcXVhbCh4LCB5LCBjb25maWcuZXBzaWxvbik7XG4gICAgfSxcblxuICAgICdGcmFjdGlvbiwgRnJhY3Rpb24nOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIHguY29tcGFyZSh5KSA9PT0gMTtcbiAgICB9LFxuXG4gICAgJ0NvbXBsZXgsIENvbXBsZXgnOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdObyBvcmRlcmluZyByZWxhdGlvbiBpcyBkZWZpbmVkIGZvciBjb21wbGV4IG51bWJlcnMnKTtcbiAgICB9LFxuXG4gICAgJ1VuaXQsIFVuaXQnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgaWYgKCF4LmVxdWFsQmFzZSh5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb21wYXJlIHVuaXRzIHdpdGggZGlmZmVyZW50IGJhc2UnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsYXJnZXIoeC52YWx1ZSwgeS52YWx1ZSk7XG4gICAgfSxcblxuICAgICdzdHJpbmcsIHN0cmluZyc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4geCA+IHk7XG4gICAgfSxcblxuICAgICdNYXRyaXgsIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuXG4gICAgICAvLyBwcm9jZXNzIG1hdHJpeCBzdG9yYWdlXG4gICAgICBzd2l0Y2ggKHguc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgc3dpdGNoICh5LnN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICAgICAgLy8gc3BhcnNlICsgc3BhcnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0wNyh4LCB5LCBsYXJnZXIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIHNwYXJzZSArIGRlbnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0wMyh5LCB4LCBsYXJnZXIsIHRydWUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgc3dpdGNoICh5LnN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICAgICAgLy8gZGVuc2UgKyBzcGFyc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTAzKHgsIHksIGxhcmdlciwgZmFsc2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIGRlbnNlICsgZGVuc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTEzKHgsIHksIGxhcmdlcik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG5cbiAgICAnQXJyYXksIEFycmF5JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBsYXJnZXIobWF0cml4KHgpLCBtYXRyaXgoeSkpLnZhbHVlT2YoKTtcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGxhcmdlcihtYXRyaXgoeCksIHkpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4LCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gbGFyZ2VyKHgsIG1hdHJpeCh5KSk7XG4gICAgfSxcblxuICAgICdNYXRyaXgsIGFueSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuICAgICAgLy8gY2hlY2sgc3RvcmFnZSBmb3JtYXRcbiAgICAgIHN3aXRjaCAoeC5zdG9yYWdlKCkpIHtcbiAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTIoeCwgeSwgbGFyZ2VyLCBmYWxzZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTE0KHgsIHksIGxhcmdlciwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfSxcblxuICAgICdhbnksIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuICAgICAgLy8gY2hlY2sgc3RvcmFnZSBmb3JtYXRcbiAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTIoeSwgeCwgbGFyZ2VyLCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTQoeSwgeCwgbGFyZ2VyLCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG5cbiAgICAnQXJyYXksIGFueSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gYWxnb3JpdGhtMTQobWF0cml4KHgpLCB5LCBsYXJnZXIsIGZhbHNlKS52YWx1ZU9mKCk7XG4gICAgfSxcblxuICAgICdhbnksIEFycmF5JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBhbGdvcml0aG0xNChtYXRyaXgoeSksIHgsIGxhcmdlciwgdHJ1ZSkudmFsdWVPZigpO1xuICAgIH1cbiAgfSk7XG5cbiAgbGFyZ2VyLnRvVGV4ID0gJ1xcXFxsZWZ0KCR7YXJnc1swXX0nICsgbGF0ZXgub3BlcmF0b3JzWydsYXJnZXInXSArICcke2FyZ3NbMV19XFxcXHJpZ2h0KSc7XG5cbiAgcmV0dXJuIGxhcmdlcjtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2xhcmdlcic7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbmVhcmx5RXF1YWwgPSByZXF1aXJlKCcuLi8uLi91dGlscy9udW1iZXInKS5uZWFybHlFcXVhbDtcbnZhciBiaWdOZWFybHlFcXVhbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2JpZ251bWJlci9uZWFybHlFcXVhbCcpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIFxuICB2YXIgbWF0cml4ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC9mdW5jdGlvbi9tYXRyaXgnKSk7XG5cbiAgdmFyIGFsZ29yaXRobTAzID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0wMycpKTtcbiAgdmFyIGFsZ29yaXRobTA3ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0wNycpKTtcbiAgdmFyIGFsZ29yaXRobTEyID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xMicpKTtcbiAgdmFyIGFsZ29yaXRobTEzID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xMycpKTtcbiAgdmFyIGFsZ29yaXRobTE0ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xNCcpKTtcblxuICB2YXIgbGF0ZXggPSByZXF1aXJlKCcuLi8uLi91dGlscy9sYXRleCcpO1xuXG4gIC8qKlxuICAgKiBUZXN0IHdoZXRoZXIgdmFsdWUgeCBpcyBsYXJnZXIgb3IgZXF1YWwgdG8geS5cbiAgICpcbiAgICogVGhlIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSB3aGVuIHggaXMgbGFyZ2VyIHRoYW4geSBvciB0aGUgcmVsYXRpdmVcbiAgICogZGlmZmVyZW5jZSBiZXR3ZWVuIHggYW5kIHkgaXMgc21hbGxlciB0aGFuIHRoZSBjb25maWd1cmVkIGVwc2lsb24uIFRoZVxuICAgKiBmdW5jdGlvbiBjYW5ub3QgYmUgdXNlZCB0byBjb21wYXJlIHZhbHVlcyBzbWFsbGVyIHRoYW4gYXBwcm94aW1hdGVseSAyLjIyZS0xNi5cbiAgICpcbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmxhcmdlckVxKHgsIHkpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmxhcmdlcigyLCAxICsgMSk7ICAgICAgICAgLy8gcmV0dXJucyBmYWxzZVxuICAgKiAgICBtYXRoLmxhcmdlckVxKDIsIDEgKyAxKTsgICAgICAgLy8gcmV0dXJucyB0cnVlXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBlcXVhbCwgdW5lcXVhbCwgc21hbGxlciwgc21hbGxlckVxLCBsYXJnZXIsIGNvbXBhcmVcbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb24gfCBib29sZWFuIHwgVW5pdCB8IHN0cmluZyB8IEFycmF5IHwgTWF0cml4fSB4IEZpcnN0IHZhbHVlIHRvIGNvbXBhcmVcbiAgICogQHBhcmFtICB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb24gfCBib29sZWFuIHwgVW5pdCB8IHN0cmluZyB8IEFycmF5IHwgTWF0cml4fSB5IFNlY29uZCB2YWx1ZSB0byBjb21wYXJlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW4gfCBBcnJheSB8IE1hdHJpeH0gUmV0dXJucyB0cnVlIHdoZW4gdGhlIHggaXMgbGFyZ2VyIG9yIGVxdWFsIHRvIHksIGVsc2UgcmV0dXJucyBmYWxzZVxuICAgKi9cbiAgdmFyIGxhcmdlckVxID0gdHlwZWQoJ2xhcmdlckVxJywge1xuXG4gICAgJ2Jvb2xlYW4sIGJvb2xlYW4nOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIHggPj0geTtcbiAgICB9LFxuXG4gICAgJ251bWJlciwgbnVtYmVyJzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHJldHVybiB4ID49IHkgfHwgbmVhcmx5RXF1YWwoeCwgeSwgY29uZmlnLmVwc2lsb24pO1xuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyLCBCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIHguZ3RlKHkpIHx8IGJpZ05lYXJseUVxdWFsKHgsIHksIGNvbmZpZy5lcHNpbG9uKTtcbiAgICB9LFxuXG4gICAgJ0ZyYWN0aW9uLCBGcmFjdGlvbic6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4geC5jb21wYXJlKHkpICE9PSAtMTtcbiAgICB9LFxuXG4gICAgJ0NvbXBsZXgsIENvbXBsZXgnOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdObyBvcmRlcmluZyByZWxhdGlvbiBpcyBkZWZpbmVkIGZvciBjb21wbGV4IG51bWJlcnMnKTtcbiAgICB9LFxuXG4gICAgJ1VuaXQsIFVuaXQnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgaWYgKCF4LmVxdWFsQmFzZSh5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb21wYXJlIHVuaXRzIHdpdGggZGlmZmVyZW50IGJhc2UnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsYXJnZXJFcSh4LnZhbHVlLCB5LnZhbHVlKTtcbiAgICB9LFxuXG4gICAgJ3N0cmluZywgc3RyaW5nJzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHJldHVybiB4ID49IHk7XG4gICAgfSxcblxuICAgICdNYXRyaXgsIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuXG4gICAgICAvLyBwcm9jZXNzIG1hdHJpeCBzdG9yYWdlXG4gICAgICBzd2l0Y2ggKHguc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgc3dpdGNoICh5LnN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICAgICAgLy8gc3BhcnNlICsgc3BhcnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0wNyh4LCB5LCBsYXJnZXJFcSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgLy8gc3BhcnNlICsgZGVuc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTAzKHksIHgsIGxhcmdlckVxLCB0cnVlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgICAgIC8vIGRlbnNlICsgc3BhcnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0wMyh4LCB5LCBsYXJnZXJFcSwgZmFsc2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIGRlbnNlICsgZGVuc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTEzKHgsIHksIGxhcmdlckVxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfSxcblxuICAgICdBcnJheSwgQXJyYXknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGxhcmdlckVxKG1hdHJpeCh4KSwgbWF0cml4KHkpKS52YWx1ZU9mKCk7XG4gICAgfSxcblxuICAgICdBcnJheSwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBsYXJnZXJFcShtYXRyaXgoeCksIHkpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4LCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gbGFyZ2VyRXEoeCwgbWF0cml4KHkpKTtcbiAgICB9LFxuXG4gICAgJ01hdHJpeCwgYW55JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHJlc3VsdFxuICAgICAgdmFyIGM7XG4gICAgICAvLyBjaGVjayBzdG9yYWdlIGZvcm1hdFxuICAgICAgc3dpdGNoICh4LnN0b3JhZ2UoKSkge1xuICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xMih4LCB5LCBsYXJnZXJFcSwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xNCh4LCB5LCBsYXJnZXJFcSwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfSxcblxuICAgICdhbnksIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuICAgICAgLy8gY2hlY2sgc3RvcmFnZSBmb3JtYXRcbiAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTIoeSwgeCwgbGFyZ2VyRXEsIHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xNCh5LCB4LCBsYXJnZXJFcSwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBhbnknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGFsZ29yaXRobTE0KG1hdHJpeCh4KSwgeSwgbGFyZ2VyRXEsIGZhbHNlKS52YWx1ZU9mKCk7XG4gICAgfSxcblxuICAgICdhbnksIEFycmF5JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBhbGdvcml0aG0xNChtYXRyaXgoeSksIHgsIGxhcmdlckVxLCB0cnVlKS52YWx1ZU9mKCk7XG4gICAgfVxuICB9KTtcblxuICBsYXJnZXJFcS50b1RleCA9ICdcXFxcbGVmdCgke2FyZ3NbMF19JyArIGxhdGV4Lm9wZXJhdG9yc1snbGFyZ2VyRXEnXSArICcke2FyZ3NbMV19XFxcXHJpZ2h0KSc7XG5cbiAgcmV0dXJuIGxhcmdlckVxO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnbGFyZ2VyRXEnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG5lYXJseUVxdWFsID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbnVtYmVyJykubmVhcmx5RXF1YWw7XG52YXIgYmlnTmVhcmx5RXF1YWwgPSByZXF1aXJlKCcuLi8uLi91dGlscy9iaWdudW1iZXIvbmVhcmx5RXF1YWwnKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuXG4gIHZhciBtYXRyaXggPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L2Z1bmN0aW9uL21hdHJpeCcpKTtcblxuICB2YXIgYWxnb3JpdGhtMDMgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTAzJykpO1xuICB2YXIgYWxnb3JpdGhtMDcgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTA3JykpO1xuICB2YXIgYWxnb3JpdGhtMTIgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTEyJykpO1xuICB2YXIgYWxnb3JpdGhtMTMgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTEzJykpO1xuICB2YXIgYWxnb3JpdGhtMTQgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTE0JykpO1xuXG4gIHZhciBsYXRleCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2xhdGV4Jyk7XG5cbiAgLyoqXG4gICAqIFRlc3Qgd2hldGhlciB2YWx1ZSB4IGlzIHNtYWxsZXIgdGhhbiB5LlxuICAgKlxuICAgKiBUaGUgZnVuY3Rpb24gcmV0dXJucyB0cnVlIHdoZW4geCBpcyBzbWFsbGVyIHRoYW4geSBhbmQgdGhlIHJlbGF0aXZlXG4gICAqIGRpZmZlcmVuY2UgYmV0d2VlbiB4IGFuZCB5IGlzIHNtYWxsZXIgdGhhbiB0aGUgY29uZmlndXJlZCBlcHNpbG9uLiBUaGVcbiAgICogZnVuY3Rpb24gY2Fubm90IGJlIHVzZWQgdG8gY29tcGFyZSB2YWx1ZXMgc21hbGxlciB0aGFuIGFwcHJveGltYXRlbHkgMi4yMmUtMTYuXG4gICAqXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5zbWFsbGVyKHgsIHkpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLnNtYWxsZXIoMiwgMyk7ICAgICAgICAgICAgLy8gcmV0dXJucyB0cnVlXG4gICAqICAgIG1hdGguc21hbGxlcig1LCAyICogMik7ICAgICAgICAvLyByZXR1cm5zIGZhbHNlXG4gICAqXG4gICAqICAgIHZhciBhID0gbWF0aC51bml0KCc1IGNtJyk7XG4gICAqICAgIHZhciBiID0gbWF0aC51bml0KCcyIGluY2gnKTtcbiAgICogICAgbWF0aC5zbWFsbGVyKGEsIGIpOyAgICAgICAgICAgIC8vIHJldHVybnMgdHJ1ZVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgZXF1YWwsIHVuZXF1YWwsIHNtYWxsZXJFcSwgc21hbGxlciwgc21hbGxlckVxLCBjb21wYXJlXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgYm9vbGVhbiB8IFVuaXQgfCBzdHJpbmcgfCBBcnJheSB8IE1hdHJpeH0geCBGaXJzdCB2YWx1ZSB0byBjb21wYXJlXG4gICAqIEBwYXJhbSAge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgYm9vbGVhbiB8IFVuaXQgfCBzdHJpbmcgfCBBcnJheSB8IE1hdHJpeH0geSBTZWNvbmQgdmFsdWUgdG8gY29tcGFyZVxuICAgKiBAcmV0dXJuIHtib29sZWFuIHwgQXJyYXkgfCBNYXRyaXh9IFJldHVybnMgdHJ1ZSB3aGVuIHRoZSB4IGlzIHNtYWxsZXIgdGhhbiB5LCBlbHNlIHJldHVybnMgZmFsc2VcbiAgICovXG4gIHZhciBzbWFsbGVyID0gdHlwZWQoJ3NtYWxsZXInLCB7XG5cbiAgICAnYm9vbGVhbiwgYm9vbGVhbic6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4geCA8IHk7XG4gICAgfSxcblxuICAgICdudW1iZXIsIG51bWJlcic6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4geCA8IHkgJiYgIW5lYXJseUVxdWFsKHgsIHksIGNvbmZpZy5lcHNpbG9uKTtcbiAgICB9LFxuXG4gICAgJ0JpZ051bWJlciwgQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHJldHVybiB4Lmx0KHkpICYmICFiaWdOZWFybHlFcXVhbCh4LCB5LCBjb25maWcuZXBzaWxvbik7XG4gICAgfSxcblxuICAgICdGcmFjdGlvbiwgRnJhY3Rpb24nOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIHguY29tcGFyZSh5KSA9PT0gLTE7XG4gICAgfSxcblxuICAgICdDb21wbGV4LCBDb21wbGV4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vIG9yZGVyaW5nIHJlbGF0aW9uIGlzIGRlZmluZWQgZm9yIGNvbXBsZXggbnVtYmVycycpO1xuICAgIH0sXG5cbiAgICAnVW5pdCwgVW5pdCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICBpZiAoIXguZXF1YWxCYXNlKHkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbXBhcmUgdW5pdHMgd2l0aCBkaWZmZXJlbnQgYmFzZScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNtYWxsZXIoeC52YWx1ZSwgeS52YWx1ZSk7XG4gICAgfSxcblxuICAgICdzdHJpbmcsIHN0cmluZyc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4geCA8IHk7XG4gICAgfSxcblxuICAgICdNYXRyaXgsIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuXG4gICAgICAvLyBwcm9jZXNzIG1hdHJpeCBzdG9yYWdlXG4gICAgICBzd2l0Y2ggKHguc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgc3dpdGNoICh5LnN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICAgICAgLy8gc3BhcnNlICsgc3BhcnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0wNyh4LCB5LCBzbWFsbGVyKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAvLyBzcGFyc2UgKyBkZW5zZVxuICAgICAgICAgICAgICBjID0gYWxnb3JpdGhtMDMoeSwgeCwgc21hbGxlciwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBzd2l0Y2ggKHkuc3RvcmFnZSgpKSB7XG4gICAgICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgICAgICAvLyBkZW5zZSArIHNwYXJzZVxuICAgICAgICAgICAgICBjID0gYWxnb3JpdGhtMDMoeCwgeSwgc21hbGxlciwgZmFsc2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIGRlbnNlICsgZGVuc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTEzKHgsIHksIHNtYWxsZXIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gc21hbGxlcihtYXRyaXgoeCksIG1hdHJpeCh5KSkudmFsdWVPZigpO1xuICAgIH0sXG5cbiAgICAnQXJyYXksIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gc21hbGxlcihtYXRyaXgoeCksIHkpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4LCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gc21hbGxlcih4LCBtYXRyaXgoeSkpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4LCBhbnknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gcmVzdWx0XG4gICAgICB2YXIgYztcbiAgICAgIC8vIGNoZWNrIHN0b3JhZ2UgZm9ybWF0XG4gICAgICBzd2l0Y2ggKHguc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTEyKHgsIHksIHNtYWxsZXIsIGZhbHNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTQoeCwgeSwgc21hbGxlciwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfSxcblxuICAgICdhbnksIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuICAgICAgLy8gY2hlY2sgc3RvcmFnZSBmb3JtYXRcbiAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTIoeSwgeCwgc21hbGxlciwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTE0KHksIHgsIHNtYWxsZXIsIHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfSxcblxuICAgICdBcnJheSwgYW55JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBhbGdvcml0aG0xNChtYXRyaXgoeCksIHksIHNtYWxsZXIsIGZhbHNlKS52YWx1ZU9mKCk7XG4gICAgfSxcblxuICAgICdhbnksIEFycmF5JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBhbGdvcml0aG0xNChtYXRyaXgoeSksIHgsIHNtYWxsZXIsIHRydWUpLnZhbHVlT2YoKTtcbiAgICB9XG4gIH0pO1xuXG4gIHNtYWxsZXIudG9UZXggPSAnXFxcXGxlZnQoJHthcmdzWzBdfScgKyBsYXRleC5vcGVyYXRvcnNbJ3NtYWxsZXInXSArICcke2FyZ3NbMV19XFxcXHJpZ2h0KSc7XG5cbiAgcmV0dXJuIHNtYWxsZXI7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdzbWFsbGVyJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBuZWFybHlFcXVhbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL251bWJlcicpLm5lYXJseUVxdWFsO1xudmFyIGJpZ05lYXJseUVxdWFsID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYmlnbnVtYmVyL25lYXJseUVxdWFsJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcblxuICB2YXIgbWF0cml4ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC9mdW5jdGlvbi9tYXRyaXgnKSk7XG5cbiAgdmFyIGFsZ29yaXRobTAzID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0wMycpKTtcbiAgdmFyIGFsZ29yaXRobTA3ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0wNycpKTtcbiAgdmFyIGFsZ29yaXRobTEyID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xMicpKTtcbiAgdmFyIGFsZ29yaXRobTEzID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xMycpKTtcbiAgdmFyIGFsZ29yaXRobTE0ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xNCcpKTtcblxuICB2YXIgbGF0ZXggPSByZXF1aXJlKCcuLi8uLi91dGlscy9sYXRleCcpO1xuXG4gIC8qKlxuICAgKiBUZXN0IHdoZXRoZXIgdmFsdWUgeCBpcyBzbWFsbGVyIG9yIGVxdWFsIHRvIHkuXG4gICAqXG4gICAqIFRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUgd2hlbiB4IGlzIHNtYWxsZXIgdGhhbiB5IG9yIHRoZSByZWxhdGl2ZVxuICAgKiBkaWZmZXJlbmNlIGJldHdlZW4geCBhbmQgeSBpcyBzbWFsbGVyIHRoYW4gdGhlIGNvbmZpZ3VyZWQgZXBzaWxvbi4gVGhlXG4gICAqIGZ1bmN0aW9uIGNhbm5vdCBiZSB1c2VkIHRvIGNvbXBhcmUgdmFsdWVzIHNtYWxsZXIgdGhhbiBhcHByb3hpbWF0ZWx5IDIuMjJlLTE2LlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguc21hbGxlckVxKHgsIHkpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLnNtYWxsZXIoMSArIDIsIDMpOyAgICAgICAgLy8gcmV0dXJucyBmYWxzZVxuICAgKiAgICBtYXRoLnNtYWxsZXJFcSgxICsgMiwgMyk7ICAgICAgLy8gcmV0dXJucyB0cnVlXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBlcXVhbCwgdW5lcXVhbCwgc21hbGxlciwgbGFyZ2VyLCBsYXJnZXJFcSwgY29tcGFyZVxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IGJvb2xlYW4gfCBVbml0IHwgc3RyaW5nIHwgQXJyYXkgfCBNYXRyaXh9IHggRmlyc3QgdmFsdWUgdG8gY29tcGFyZVxuICAgKiBAcGFyYW0gIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IGJvb2xlYW4gfCBVbml0IHwgc3RyaW5nIHwgQXJyYXkgfCBNYXRyaXh9IHkgU2Vjb25kIHZhbHVlIHRvIGNvbXBhcmVcbiAgICogQHJldHVybiB7Ym9vbGVhbiB8IEFycmF5IHwgTWF0cml4fSBSZXR1cm5zIHRydWUgd2hlbiB0aGUgeCBpcyBzbWFsbGVyIHRoYW4geSwgZWxzZSByZXR1cm5zIGZhbHNlXG4gICAqL1xuICB2YXIgc21hbGxlckVxID0gdHlwZWQoJ3NtYWxsZXJFcScsIHtcblxuICAgICdib29sZWFuLCBib29sZWFuJzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHJldHVybiB4IDw9IHk7XG4gICAgfSxcblxuICAgICdudW1iZXIsIG51bWJlcic6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4geCA8PSB5IHx8IG5lYXJseUVxdWFsKHgsIHksIGNvbmZpZy5lcHNpbG9uKTtcbiAgICB9LFxuXG4gICAgJ0JpZ051bWJlciwgQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHJldHVybiB4Lmx0ZSh5KSB8fCBiaWdOZWFybHlFcXVhbCh4LCB5LCBjb25maWcuZXBzaWxvbik7XG4gICAgfSxcblxuICAgICdGcmFjdGlvbiwgRnJhY3Rpb24nOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIHguY29tcGFyZSh5KSAhPT0gMTtcbiAgICB9LFxuXG4gICAgJ0NvbXBsZXgsIENvbXBsZXgnOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdObyBvcmRlcmluZyByZWxhdGlvbiBpcyBkZWZpbmVkIGZvciBjb21wbGV4IG51bWJlcnMnKTtcbiAgICB9LFxuXG4gICAgJ1VuaXQsIFVuaXQnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgaWYgKCF4LmVxdWFsQmFzZSh5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb21wYXJlIHVuaXRzIHdpdGggZGlmZmVyZW50IGJhc2UnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzbWFsbGVyRXEoeC52YWx1ZSwgeS52YWx1ZSk7XG4gICAgfSxcblxuICAgICdzdHJpbmcsIHN0cmluZyc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4geCA8PSB5O1xuICAgIH0sXG5cbiAgICAnTWF0cml4LCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gcmVzdWx0XG4gICAgICB2YXIgYztcblxuICAgICAgLy8gcHJvY2VzcyBtYXRyaXggc3RvcmFnZVxuICAgICAgc3dpdGNoICh4LnN0b3JhZ2UoKSkge1xuICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgICAgIC8vIHNwYXJzZSArIHNwYXJzZVxuICAgICAgICAgICAgICBjID0gYWxnb3JpdGhtMDcoeCwgeSwgc21hbGxlckVxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAvLyBzcGFyc2UgKyBkZW5zZVxuICAgICAgICAgICAgICBjID0gYWxnb3JpdGhtMDMoeSwgeCwgc21hbGxlckVxLCB0cnVlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgICAgIC8vIGRlbnNlICsgc3BhcnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0wMyh4LCB5LCBzbWFsbGVyRXEsIGZhbHNlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAvLyBkZW5zZSArIGRlbnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0xMyh4LCB5LCBzbWFsbGVyRXEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gc21hbGxlckVxKG1hdHJpeCh4KSwgbWF0cml4KHkpKS52YWx1ZU9mKCk7XG4gICAgfSxcblxuICAgICdBcnJheSwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBzbWFsbGVyRXEobWF0cml4KHgpLCB5KTtcbiAgICB9LFxuXG4gICAgJ01hdHJpeCwgQXJyYXknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIHNtYWxsZXJFcSh4LCBtYXRyaXgoeSkpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4LCBhbnknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gcmVzdWx0XG4gICAgICB2YXIgYztcbiAgICAgIC8vIGNoZWNrIHN0b3JhZ2UgZm9ybWF0XG4gICAgICBzd2l0Y2ggKHguc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTEyKHgsIHksIHNtYWxsZXJFcSwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xNCh4LCB5LCBzbWFsbGVyRXEsIGZhbHNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG5cbiAgICAnYW55LCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gcmVzdWx0XG4gICAgICB2YXIgYztcbiAgICAgIC8vIGNoZWNrIHN0b3JhZ2UgZm9ybWF0XG4gICAgICBzd2l0Y2ggKHkuc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTEyKHksIHgsIHNtYWxsZXJFcSwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTE0KHksIHgsIHNtYWxsZXJFcSwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBhbnknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGFsZ29yaXRobTE0KG1hdHJpeCh4KSwgeSwgc21hbGxlckVxLCBmYWxzZSkudmFsdWVPZigpO1xuICAgIH0sXG5cbiAgICAnYW55LCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gYWxnb3JpdGhtMTQobWF0cml4KHkpLCB4LCBzbWFsbGVyRXEsIHRydWUpLnZhbHVlT2YoKTtcbiAgICB9XG4gIH0pO1xuXG4gIHNtYWxsZXJFcS50b1RleCA9ICdcXFxcbGVmdCgke2FyZ3NbMF19JyArIGxhdGV4Lm9wZXJhdG9yc1snc21hbGxlckVxJ10gKyAnJHthcmdzWzFdfVxcXFxyaWdodCknO1xuXG4gIHJldHVybiBzbWFsbGVyRXE7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdzbWFsbGVyRXEnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG5lYXJseUVxdWFsID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbnVtYmVyJykubmVhcmx5RXF1YWw7XG52YXIgYmlnTmVhcmx5RXF1YWwgPSByZXF1aXJlKCcuLi8uLi91dGlscy9iaWdudW1iZXIvbmVhcmx5RXF1YWwnKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuXG4gIHZhciBtYXRyaXggPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L2Z1bmN0aW9uL21hdHJpeCcpKTtcblxuICB2YXIgYWxnb3JpdGhtMDMgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTAzJykpO1xuICB2YXIgYWxnb3JpdGhtMDcgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTA3JykpO1xuICB2YXIgYWxnb3JpdGhtMTIgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTEyJykpO1xuICB2YXIgYWxnb3JpdGhtMTMgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTEzJykpO1xuICB2YXIgYWxnb3JpdGhtMTQgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTE0JykpO1xuXG4gIHZhciBsYXRleCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2xhdGV4Jyk7XG5cbiAgLyoqXG4gICAqIFRlc3Qgd2hldGhlciB0d28gdmFsdWVzIGFyZSB1bmVxdWFsLlxuICAgKlxuICAgKiBUaGUgZnVuY3Rpb24gdGVzdHMgd2hldGhlciB0aGUgcmVsYXRpdmUgZGlmZmVyZW5jZSBiZXR3ZWVuIHggYW5kIHkgaXNcbiAgICogbGFyZ2VyIHRoYW4gdGhlIGNvbmZpZ3VyZWQgZXBzaWxvbi4gVGhlIGZ1bmN0aW9uIGNhbm5vdCBiZSB1c2VkIHRvIGNvbXBhcmVcbiAgICogdmFsdWVzIHNtYWxsZXIgdGhhbiBhcHByb3hpbWF0ZWx5IDIuMjJlLTE2LlxuICAgKlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKiBJbiBjYXNlIG9mIGNvbXBsZXggbnVtYmVycywgeC5yZSBtdXN0IHVuZXF1YWwgeS5yZSwgb3IgeC5pbSBtdXN0IHVuZXF1YWwgeS5pbS5cbiAgICpcbiAgICogVmFsdWVzIGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgYXJlIGNvbXBhcmVkIHN0cmljdGx5LCB0aHVzIGBudWxsYCBpcyB1bmVxdWFsXG4gICAqIHdpdGggZXZlcnl0aGluZyBleGNlcHQgYG51bGxgLCBhbmQgYHVuZGVmaW5lZGAgaXMgdW5lcXVhbCB3aXRoIGV2ZXJ5aW5nXG4gICAqIGV4Y2VwdC4gYHVuZGVmaW5lZGAuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC51bmVxdWFsKHgsIHkpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLnVuZXF1YWwoMiArIDIsIDMpOyAgICAgICAvLyByZXR1cm5zIHRydWVcbiAgICogICAgbWF0aC51bmVxdWFsKDIgKyAyLCA0KTsgICAgICAgLy8gcmV0dXJucyBmYWxzZVxuICAgKlxuICAgKiAgICB2YXIgYSA9IG1hdGgudW5pdCgnNTAgY20nKTtcbiAgICogICAgdmFyIGIgPSBtYXRoLnVuaXQoJzUgbScpO1xuICAgKiAgICBtYXRoLnVuZXF1YWwoYSwgYik7ICAgICAgICAgICAvLyByZXR1cm5zIGZhbHNlXG4gICAqXG4gICAqICAgIHZhciBjID0gWzIsIDUsIDFdO1xuICAgKiAgICB2YXIgZCA9IFsyLCA3LCAxXTtcbiAgICpcbiAgICogICAgbWF0aC51bmVxdWFsKGMsIGQpOyAgICAgICAgICAgLy8gcmV0dXJucyBbZmFsc2UsIHRydWUsIGZhbHNlXVxuICAgKiAgICBtYXRoLmRlZXBFcXVhbChjLCBkKTsgICAgICAgICAvLyByZXR1cm5zIGZhbHNlXG4gICAqXG4gICAqICAgIG1hdGgudW5lcXVhbCgwLCBudWxsKTsgICAgICAgIC8vIHJldHVybnMgdHJ1ZVxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgZXF1YWwsIGRlZXBFcXVhbCwgc21hbGxlciwgc21hbGxlckVxLCBsYXJnZXIsIGxhcmdlckVxLCBjb21wYXJlXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgYm9vbGVhbiB8IENvbXBsZXggfCBVbml0IHwgc3RyaW5nIHwgQXJyYXkgfCBNYXRyaXggfCB1bmRlZmluZWR9IHggRmlyc3QgdmFsdWUgdG8gY29tcGFyZVxuICAgKiBAcGFyYW0gIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IGJvb2xlYW4gfCBDb21wbGV4IHwgVW5pdCB8IHN0cmluZyB8IEFycmF5IHwgTWF0cml4IHwgdW5kZWZpbmVkfSB5IFNlY29uZCB2YWx1ZSB0byBjb21wYXJlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW4gfCBBcnJheSB8IE1hdHJpeH0gUmV0dXJucyB0cnVlIHdoZW4gdGhlIGNvbXBhcmVkIHZhbHVlcyBhcmUgdW5lcXVhbCwgZWxzZSByZXR1cm5zIGZhbHNlXG4gICAqL1xuICB2YXIgdW5lcXVhbCA9IHR5cGVkKCd1bmVxdWFsJywge1xuICAgIFxuICAgICdhbnksIGFueSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyBzdHJpY3QgZXF1YWxpdHkgZm9yIG51bGwgYW5kIHVuZGVmaW5lZD9cbiAgICAgIGlmICh4ID09PSBudWxsKSB7IHJldHVybiB5ICE9PSBudWxsOyB9XG4gICAgICBpZiAoeSA9PT0gbnVsbCkgeyByZXR1cm4geCAhPT0gbnVsbDsgfVxuICAgICAgaWYgKHggPT09IHVuZGVmaW5lZCkgeyByZXR1cm4geSAhPT0gdW5kZWZpbmVkOyB9XG4gICAgICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB4ICE9PSB1bmRlZmluZWQ7IH1cblxuICAgICAgcmV0dXJuIF91bmVxdWFsKHgsIHkpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4LCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gcmVzdWx0XG4gICAgICB2YXIgYztcblxuICAgICAgLy8gcHJvY2VzcyBtYXRyaXggc3RvcmFnZVxuICAgICAgc3dpdGNoICh4LnN0b3JhZ2UoKSkge1xuICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgICAgIC8vIHNwYXJzZSArIHNwYXJzZVxuICAgICAgICAgICAgICBjID0gYWxnb3JpdGhtMDcoeCwgeSwgX3VuZXF1YWwpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIHNwYXJzZSArIGRlbnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0wMyh5LCB4LCBfdW5lcXVhbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBzd2l0Y2ggKHkuc3RvcmFnZSgpKSB7XG4gICAgICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgICAgICAvLyBkZW5zZSArIHNwYXJzZVxuICAgICAgICAgICAgICBjID0gYWxnb3JpdGhtMDMoeCwgeSwgX3VuZXF1YWwsIGZhbHNlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAvLyBkZW5zZSArIGRlbnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0xMyh4LCB5LCBfdW5lcXVhbCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG5cbiAgICAnQXJyYXksIEFycmF5JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiB1bmVxdWFsKG1hdHJpeCh4KSwgbWF0cml4KHkpKS52YWx1ZU9mKCk7XG4gICAgfSxcblxuICAgICdBcnJheSwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiB1bmVxdWFsKG1hdHJpeCh4KSwgeSk7XG4gICAgfSxcblxuICAgICdNYXRyaXgsIEFycmF5JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiB1bmVxdWFsKHgsIG1hdHJpeCh5KSk7XG4gICAgfSxcblxuICAgICdNYXRyaXgsIGFueSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuICAgICAgLy8gY2hlY2sgc3RvcmFnZSBmb3JtYXRcbiAgICAgIHN3aXRjaCAoeC5zdG9yYWdlKCkpIHtcbiAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTIoeCwgeSwgX3VuZXF1YWwsIGZhbHNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTQoeCwgeSwgX3VuZXF1YWwsIGZhbHNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG5cbiAgICAnYW55LCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gcmVzdWx0XG4gICAgICB2YXIgYztcbiAgICAgIC8vIGNoZWNrIHN0b3JhZ2UgZm9ybWF0XG4gICAgICBzd2l0Y2ggKHkuc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTEyKHksIHgsIF91bmVxdWFsLCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTQoeSwgeCwgX3VuZXF1YWwsIHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfSxcblxuICAgICdBcnJheSwgYW55JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBhbGdvcml0aG0xNChtYXRyaXgoeCksIHksIF91bmVxdWFsLCBmYWxzZSkudmFsdWVPZigpO1xuICAgIH0sXG5cbiAgICAnYW55LCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gYWxnb3JpdGhtMTQobWF0cml4KHkpLCB4LCBfdW5lcXVhbCwgdHJ1ZSkudmFsdWVPZigpO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIF91bmVxdWFsID0gdHlwZWQoJ191bmVxdWFsJywge1xuXG4gICAgJ2Jvb2xlYW4sIGJvb2xlYW4nOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIHggIT09IHk7XG4gICAgfSxcblxuICAgICdudW1iZXIsIG51bWJlcic6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4gIW5lYXJseUVxdWFsKHgsIHksIGNvbmZpZy5lcHNpbG9uKTtcbiAgICB9LFxuXG4gICAgJ0JpZ051bWJlciwgQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHJldHVybiAhYmlnTmVhcmx5RXF1YWwoeCwgeSwgY29uZmlnLmVwc2lsb24pO1xuICAgIH0sXG5cbiAgICAnRnJhY3Rpb24sIEZyYWN0aW9uJzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHJldHVybiAheC5lcXVhbHMoeSk7XG4gICAgfSxcblxuICAgICdDb21wbGV4LCBDb21wbGV4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHJldHVybiAheC5lcXVhbHMoeSk7XG4gICAgfSxcblxuICAgICdVbml0LCBVbml0JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIGlmICgheC5lcXVhbEJhc2UoeSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29tcGFyZSB1bml0cyB3aXRoIGRpZmZlcmVudCBiYXNlJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5lcXVhbCh4LnZhbHVlLCB5LnZhbHVlKTtcbiAgICB9LFxuXG4gICAgJ3N0cmluZywgc3RyaW5nJzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHJldHVybiB4ICE9PSB5O1xuICAgIH1cbiAgfSk7XG5cbiAgdW5lcXVhbC50b1RleCA9ICdcXFxcbGVmdCgke2FyZ3NbMF19JyArIGxhdGV4Lm9wZXJhdG9yc1sndW5lcXVhbCddICsgJyR7YXJnc1sxXX1cXFxccmlnaHQpJztcblxuICByZXR1cm4gdW5lcXVhbDtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ3VuZXF1YWwnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIm1vZHVsZS5leHBvcnRzID0gW1xuICByZXF1aXJlKCcuL21heCcpLFxuICByZXF1aXJlKCcuL21lYW4nKSxcbiAgcmVxdWlyZSgnLi9tZWRpYW4nKSxcbiAgcmVxdWlyZSgnLi9taW4nKSxcbiAgcmVxdWlyZSgnLi9tb2RlJyksXG4gIHJlcXVpcmUoJy4vcHJvZCcpLFxuICByZXF1aXJlKCcuL3F1YW50aWxlU2VxJyksXG4gIHJlcXVpcmUoJy4vc3RkJyksXG4gIHJlcXVpcmUoJy4vc3VtJyksXG4gIHJlcXVpcmUoJy4vdmFyJylcbl07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVlcEZvckVhY2ggPSByZXF1aXJlKCcuLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBGb3JFYWNoJyk7XG52YXIgcmVkdWNlID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9yZWR1Y2UnKTtcbnZhciBjb250YWluc0NvbGxlY3Rpb25zID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9jb250YWluc0NvbGxlY3Rpb25zJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIGxhcmdlciA9IGxvYWQocmVxdWlyZSgnLi4vcmVsYXRpb25hbC9sYXJnZXInKSk7XG5cbiAgLyoqXG4gICAqIENvbXB1dGUgdGhlIG1heGltdW0gdmFsdWUgb2YgYSBtYXRyaXggb3IgYSAgbGlzdCB3aXRoIHZhbHVlcy5cbiAgICogSW4gY2FzZSBvZiBhIG11bHRpIGRpbWVuc2lvbmFsIGFycmF5LCB0aGUgbWF4aW11bSBvZiB0aGUgZmxhdHRlbmVkIGFycmF5XG4gICAqIHdpbGwgYmUgY2FsY3VsYXRlZC4gV2hlbiBgZGltYCBpcyBwcm92aWRlZCwgdGhlIG1heGltdW0gb3ZlciB0aGUgc2VsZWN0ZWRcbiAgICogZGltZW5zaW9uIHdpbGwgYmUgY2FsY3VsYXRlZC4gUGFyYW1ldGVyIGBkaW1gIGlzIHplcm8tYmFzZWQuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgIG1hdGgubWF4KGEsIGIsIGMsIC4uLilcbiAgICogICAgIG1hdGgubWF4KEEpXG4gICAqICAgICBtYXRoLm1heChBLCBkaW0pXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICAgbWF0aC5tYXgoMiwgMSwgNCwgMyk7ICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyA0XG4gICAqICAgICBtYXRoLm1heChbMiwgMSwgNCwgM10pOyAgICAgICAgICAgICAgICAvLyByZXR1cm5zIDRcbiAgICpcbiAgICogICAgIC8vIG1heGltdW0gb3ZlciBhIHNwZWNpZmllZCBkaW1lbnNpb24gKHplcm8tYmFzZWQpXG4gICAqICAgICBtYXRoLm1heChbWzIsIDVdLCBbNCwgM10sIFsxLCA3XV0sIDApOyAvLyByZXR1cm5zIFs0LCA3XVxuICAgKiAgICAgbWF0aC5tYXgoW1syLCA1XSwgWzQsIDNdXSwgWzEsIDddLCAxKTsgLy8gcmV0dXJucyBbNSwgNCwgN11cbiAgICpcbiAgICogICAgIG1hdGgubWF4KDIuNywgNy4xLCAtNC41LCAyLjAsIDQuMSk7ICAgIC8vIHJldHVybnMgNy4xXG4gICAqICAgICBtYXRoLm1pbigyLjcsIDcuMSwgLTQuNSwgMi4wLCA0LjEpOyAgICAvLyByZXR1cm5zIC00LjVcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIG1lYW4sIG1lZGlhbiwgbWluLCBwcm9kLCBzdGQsIHN1bSwgdmFyXG4gICAqXG4gICAqIEBwYXJhbSB7Li4uICp9IGFyZ3MgIEEgc2luZ2xlIG1hdHJpeCBvciBvciBtdWx0aXBsZSBzY2FsYXIgdmFsdWVzXG4gICAqIEByZXR1cm4geyp9IFRoZSBtYXhpbXVtIHZhbHVlXG4gICAqL1xuICB2YXIgbWF4ID0gdHlwZWQoJ21heCcsIHtcbiAgICAvLyBtYXgoW2EsIGIsIGMsIGQsIC4uLl0pXG4gICAgJ0FycmF5IHwgTWF0cml4JzogX21heCxcblxuICAgIC8vIG1heChbYSwgYiwgYywgZCwgLi4uXSwgZGltKVxuICAgICdBcnJheSB8IE1hdHJpeCwgbnVtYmVyIHwgQmlnTnVtYmVyJzogZnVuY3Rpb24gKGFycmF5LCBkaW0pIHtcbiAgICAgIHJldHVybiByZWR1Y2UoYXJyYXksIGRpbS52YWx1ZU9mKCksIF9sYXJnZXN0KTtcbiAgICB9LFxuXG4gICAgLy8gbWF4KGEsIGIsIGMsIGQsIC4uLilcbiAgICAnLi4uJzogZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgIGlmIChjb250YWluc0NvbGxlY3Rpb25zKGFyZ3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1NjYWxhciB2YWx1ZXMgZXhwZWN0ZWQgaW4gZnVuY3Rpb24gbWF4Jyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfbWF4KGFyZ3MpO1xuICAgIH1cbiAgfSk7XG5cbiAgbWF4LnRvVGV4ID0gJ1xcXFxtYXhcXFxcbGVmdCgke2FyZ3N9XFxcXHJpZ2h0KSc7XG5cbiAgcmV0dXJuIG1heDtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBsYXJnZXN0IG9mIHR3byB2YWx1ZXNcbiAgICogQHBhcmFtIHsqfSB4XG4gICAqIEBwYXJhbSB7Kn0geVxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB4IHdoZW4geCBpcyBsYXJnZXN0LCBvciB5IHdoZW4geSBpcyBsYXJnZXN0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfbGFyZ2VzdCh4LCB5KXtcbiAgICByZXR1cm4gbGFyZ2VyKHgsIHkpID8geCA6IHk7XG4gIH1cblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgY2FsY3VsYXRlIHRoZSBtYXhpbXVtIHZhbHVlIGluIGFuIG4tZGltZW5zaW9uYWwgYXJyYXlcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAgICogQHJldHVybiB7bnVtYmVyfSBtYXhcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9tYXgoYXJyYXkpIHtcbiAgICB2YXIgbWF4ID0gdW5kZWZpbmVkO1xuXG4gICAgZGVlcEZvckVhY2goYXJyYXksIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKG1heCA9PT0gdW5kZWZpbmVkIHx8IGxhcmdlcih2YWx1ZSwgbWF4KSkge1xuICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChtYXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY2FsY3VsYXRlIG1heCBvZiBhbiBlbXB0eSBhcnJheScpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXg7XG4gIH1cbn1cblxuZXhwb3J0cy5uYW1lID0gJ21heCc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2l6ZSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2FycmF5Jykuc2l6ZTtcbnZhciBkZWVwRm9yRWFjaCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vZGVlcEZvckVhY2gnKTtcbnZhciByZWR1Y2UgPSByZXF1aXJlKCcuLi8uLi91dGlscy9jb2xsZWN0aW9uL3JlZHVjZScpO1xudmFyIGNvbnRhaW5zQ29sbGVjdGlvbnMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9jb2xsZWN0aW9uL2NvbnRhaW5zQ29sbGVjdGlvbnMnKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgYWRkID0gbG9hZChyZXF1aXJlKCcuLi9hcml0aG1ldGljL2FkZCcpKTtcbiAgdmFyIGRpdmlkZSA9IGxvYWQocmVxdWlyZSgnLi4vYXJpdGhtZXRpYy9kaXZpZGUnKSk7XG5cbiAgLyoqXG4gICAqIENvbXB1dGUgdGhlIG1lYW4gdmFsdWUgb2YgbWF0cml4IG9yIGEgbGlzdCB3aXRoIHZhbHVlcy5cbiAgICogSW4gY2FzZSBvZiBhIG11bHRpIGRpbWVuc2lvbmFsIGFycmF5LCB0aGUgbWVhbiBvZiB0aGUgZmxhdHRlbmVkIGFycmF5XG4gICAqIHdpbGwgYmUgY2FsY3VsYXRlZC4gV2hlbiBgZGltYCBpcyBwcm92aWRlZCwgdGhlIG1heGltdW0gb3ZlciB0aGUgc2VsZWN0ZWRcbiAgICogZGltZW5zaW9uIHdpbGwgYmUgY2FsY3VsYXRlZC4gUGFyYW1ldGVyIGBkaW1gIGlzIHplcm8tYmFzZWQuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgIG1hdGgubWVhbihhLCBiLCBjLCAuLi4pXG4gICAqICAgICBtYXRoLm1lYW4oQSlcbiAgICogICAgIG1hdGgubWVhbihBLCBkaW0pXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICAgbWF0aC5tZWFuKDIsIDEsIDQsIDMpOyAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgMi41XG4gICAqICAgICBtYXRoLm1lYW4oWzEsIDIuNywgMy4yLCA0XSk7ICAgICAgICAgICAgICAgLy8gcmV0dXJucyAyLjcyNVxuICAgKlxuICAgKiAgICAgbWF0aC5tZWFuKFtbMiwgNV0sIFs2LCAzXSwgWzEsIDddXSwgMCk7ICAgIC8vIHJldHVybnMgWzMsIDVdXG4gICAqICAgICBtYXRoLm1lYW4oW1syLCA1XSwgWzYsIDNdLCBbMSwgN11dLCAxKTsgICAgLy8gcmV0dXJucyBbMy41LCA0LjUsIDRdXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICAgbWVkaWFuLCBtaW4sIG1heCwgc3VtLCBwcm9kLCBzdGQsIHZhclxuICAgKlxuICAgKiBAcGFyYW0gey4uLiAqfSBhcmdzICBBIHNpbmdsZSBtYXRyaXggb3Igb3IgbXVsdGlwbGUgc2NhbGFyIHZhbHVlc1xuICAgKiBAcmV0dXJuIHsqfSBUaGUgbWVhbiBvZiBhbGwgdmFsdWVzXG4gICAqL1xuICB2YXIgbWVhbiA9IHR5cGVkKCdtZWFuJywge1xuICAgICAgLy8gbWVhbihbYSwgYiwgYywgZCwgLi4uXSlcbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBfbWVhbixcblxuICAgICAgLy8gbWVhbihbYSwgYiwgYywgZCwgLi4uXSwgZGltKVxuICAgICdBcnJheSB8IE1hdHJpeCwgbnVtYmVyIHwgQmlnTnVtYmVyJzogX25tZWFuLFxuXG4gICAgLy8gbWVhbihhLCBiLCBjLCBkLCAuLi4pXG4gICAgJy4uLic6IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICBpZiAoY29udGFpbnNDb2xsZWN0aW9ucyhhcmdzKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTY2FsYXIgdmFsdWVzIGV4cGVjdGVkIGluIGZ1bmN0aW9uIG1lYW4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9tZWFuKGFyZ3MpO1xuICAgIH1cbiAgfSk7XG5cbiAgbWVhbi50b1RleCA9ICdcXFxcbWF0aHJteyR7bmFtZX19XFxcXGxlZnQoJHthcmdzfVxcXFxyaWdodCknO1xuXG4gIHJldHVybiBtZWFuO1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIG1lYW4gdmFsdWUgaW4gYW4gbi1kaW1lbnNpb25hbCBhcnJheSwgcmV0dXJuaW5nIGFcbiAgICogbi0xIGRpbWVuc2lvbmFsIGFycmF5XG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkaW1cbiAgICogQHJldHVybiB7bnVtYmVyfSBtZWFuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfbm1lYW4oYXJyYXksIGRpbSl7XG4gICAgdmFyIHN1bSA9IHJlZHVjZShhcnJheSwgZGltLCBhZGQpO1xuICAgIHZhciBzID0gQXJyYXkuaXNBcnJheShhcnJheSkgPyBzaXplKGFycmF5KSA6IGFycmF5LnNpemUoKTtcbiAgICByZXR1cm4gZGl2aWRlKHN1bSwgc1tkaW1dKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWN1cnNpdmVseSBjYWxjdWxhdGUgdGhlIG1lYW4gdmFsdWUgaW4gYW4gbi1kaW1lbnNpb25hbCBhcnJheVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IG1lYW5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9tZWFuKGFycmF5KSB7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgdmFyIG51bSA9IDA7XG5cbiAgICBkZWVwRm9yRWFjaChhcnJheSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBzdW0gPSBhZGQoc3VtLCB2YWx1ZSk7XG4gICAgICBudW0rKztcbiAgICB9KTtcblxuICAgIGlmIChudW0gPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNhbGN1bGF0ZSBtZWFuIG9mIGFuIGVtcHR5IGFycmF5Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpdmlkZShzdW0sIG51bSk7XG4gIH1cbn1cblxuZXhwb3J0cy5uYW1lID0gJ21lYW4nO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGZsYXR0ZW4gPSByZXF1aXJlKCcuLi8uLi91dGlscy9hcnJheScpLmZsYXR0ZW47XG52YXIgcmVkdWNlID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9yZWR1Y2UnKTtcbnZhciBjb250YWluc0NvbGxlY3Rpb25zID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9jb250YWluc0NvbGxlY3Rpb25zJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIGFkZCA9IGxvYWQocmVxdWlyZSgnLi4vYXJpdGhtZXRpYy9hZGRTY2FsYXInKSk7XG4gIHZhciBkaXZpZGUgPSBsb2FkKHJlcXVpcmUoJy4uL2FyaXRobWV0aWMvZGl2aWRlU2NhbGFyJykpO1xuICB2YXIgY29tcGFyZSA9IGxvYWQocmVxdWlyZSgnLi4vcmVsYXRpb25hbC9jb21wYXJlJykpO1xuICB2YXIgcGFydGl0aW9uU2VsZWN0ID0gbG9hZChyZXF1aXJlKCcuLi9tYXRyaXgvcGFydGl0aW9uU2VsZWN0JykpO1xuXG4gIC8qKlxuICAgKiBDb21wdXRlIHRoZSBtZWRpYW4gb2YgYSBtYXRyaXggb3IgYSBsaXN0IHdpdGggdmFsdWVzLiBUaGUgdmFsdWVzIGFyZVxuICAgKiBzb3J0ZWQgYW5kIHRoZSBtaWRkbGUgdmFsdWUgaXMgcmV0dXJuZWQuIEluIGNhc2Ugb2YgYW4gZXZlbiBudW1iZXIgb2ZcbiAgICogdmFsdWVzLCB0aGUgYXZlcmFnZSBvZiB0aGUgdHdvIG1pZGRsZSB2YWx1ZXMgaXMgcmV0dXJuZWQuXG4gICAqIFN1cHBvcnRlZCB0eXBlcyBvZiB2YWx1ZXMgYXJlOiBOdW1iZXIsIEJpZ051bWJlciwgVW5pdFxuICAgKlxuICAgKiBJbiBjYXNlIG9mIGEgKG11bHRpIGRpbWVuc2lvbmFsKSBhcnJheSBvciBtYXRyaXgsIHRoZSBtZWRpYW4gb2YgYWxsXG4gICAqIGVsZW1lbnRzIHdpbGwgYmUgY2FsY3VsYXRlZC5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICAgbWF0aC5tZWRpYW4oYSwgYiwgYywgLi4uKVxuICAgKiAgICAgbWF0aC5tZWRpYW4oQSlcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgICBtYXRoLm1lZGlhbig1LCAyLCA3KTsgICAgICAgIC8vIHJldHVybnMgNVxuICAgKiAgICAgbWF0aC5tZWRpYW4oWzMsIC0xLCA1LCA3XSk7ICAvLyByZXR1cm5zIDRcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgICBtZWFuLCBtaW4sIG1heCwgc3VtLCBwcm9kLCBzdGQsIHZhclxuICAgKlxuICAgKiBAcGFyYW0gey4uLiAqfSBhcmdzICBBIHNpbmdsZSBtYXRyaXggb3Igb3IgbXVsdGlwbGUgc2NhbGFyIHZhbHVlc1xuICAgKiBAcmV0dXJuIHsqfSBUaGUgbWVkaWFuXG4gICAqL1xuICB2YXIgbWVkaWFuID0gdHlwZWQoJ21lZGlhbicsIHtcbiAgICAvLyBtZWRpYW4oW2EsIGIsIGMsIGQsIC4uLl0pXG4gICAgJ0FycmF5IHwgTWF0cml4JzogX21lZGlhbixcblxuICAgIC8vIG1lZGlhbihbYSwgYiwgYywgZCwgLi4uXSwgZGltKVxuICAgICdBcnJheSB8IE1hdHJpeCwgbnVtYmVyIHwgQmlnTnVtYmVyJzogZnVuY3Rpb24gKGFycmF5LCBkaW0pIHtcbiAgICAgIC8vIFRPRE86IGltcGxlbWVudCBtZWRpYW4oQSwgZGltKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZWRpYW4oQSwgZGltKSBpcyBub3QgeWV0IHN1cHBvcnRlZCcpO1xuICAgICAgLy9yZXR1cm4gcmVkdWNlKGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdLCAuLi4pO1xuICAgIH0sXG5cbiAgICAvLyBtZWRpYW4oYSwgYiwgYywgZCwgLi4uKVxuICAgICcuLi4nOiBmdW5jdGlvbiAoYXJncykge1xuICAgICAgaWYgKGNvbnRhaW5zQ29sbGVjdGlvbnMoYXJncykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTY2FsYXIgdmFsdWVzIGV4cGVjdGVkIGluIGZ1bmN0aW9uIG1lZGlhbicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX21lZGlhbihhcmdzKTtcbiAgICB9XG4gIH0pO1xuXG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IGNhbGN1bGF0ZSB0aGUgbWVkaWFuIG9mIGFuIG4tZGltZW5zaW9uYWwgYXJyYXlcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAgICogQHJldHVybiB7TnVtYmVyfSBtZWRpYW5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9tZWRpYW4oYXJyYXkpIHtcbiAgICBhcnJheSA9IGZsYXR0ZW4oYXJyYXkudmFsdWVPZigpKTtcblxuICAgIHZhciBudW0gPSBhcnJheS5sZW5ndGg7XG4gICAgaWYgKG51bSA9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjYWxjdWxhdGUgbWVkaWFuIG9mIGFuIGVtcHR5IGFycmF5Jyk7XG4gICAgfVxuXG4gICAgaWYgKG51bSAlIDIgPT0gMCkge1xuICAgICAgLy8gZXZlbjogcmV0dXJuIHRoZSBhdmVyYWdlIG9mIHRoZSB0d28gbWlkZGxlIHZhbHVlc1xuICAgICAgdmFyIG1pZCA9IG51bSAvIDIgLSAxO1xuICAgICAgdmFyIHJpZ2h0ID0gcGFydGl0aW9uU2VsZWN0KGFycmF5LCBtaWQgKyAxKTtcblxuICAgICAgLy8gYXJyYXkgbm93IHBhcnRpdGlvbmVkIGF0IG1pZCArIDEsIHRha2UgbWF4IG9mIGxlZnQgcGFydFxuICAgICAgdmFyIGxlZnQgPSBhcnJheVttaWRdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaWQ7ICsraSkge1xuICAgICAgICBpZiAoY29tcGFyZShhcnJheVtpXSwgbGVmdCkgPiAwKSB7XG4gICAgICAgICAgbGVmdCA9IGFycmF5W2ldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtaWRkbGUyKGxlZnQsIHJpZ2h0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBvZGQ6IHJldHVybiB0aGUgbWlkZGxlIHZhbHVlXG4gICAgICB2YXIgbSA9IHBhcnRpdGlvblNlbGVjdChhcnJheSwgKG51bSAtIDEpIC8gMik7XG5cbiAgICAgIHJldHVybiBtaWRkbGUobSk7XG4gICAgfVxuICB9XG5cbiAgLy8gaGVscGVyIGZ1bmN0aW9uIHRvIHR5cGUgY2hlY2sgdGhlIG1pZGRsZSB2YWx1ZSBvZiB0aGUgYXJyYXlcbiAgdmFyIG1pZGRsZSA9IHR5cGVkKHtcbiAgICAnbnVtYmVyIHwgQmlnTnVtYmVyIHwgVW5pdCc6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gaGVscGVyIGZ1bmN0aW9uIHRvIHR5cGUgY2hlY2sgdGhlIHR3byBtaWRkbGUgdmFsdWUgb2YgdGhlIGFycmF5XG4gIHZhciBtaWRkbGUyID0gdHlwZWQoe1xuICAgICdudW1iZXIgfCBCaWdOdW1iZXIgfCBVbml0LCBudW1iZXIgfCBCaWdOdW1iZXIgfCBVbml0JzogZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XG4gICAgICByZXR1cm4gZGl2aWRlKGFkZChsZWZ0LCByaWdodCksIDIpO1xuICAgIH1cbiAgfSk7XG5cbiAgbWVkaWFuLnRvVGV4ID0gJ1xcXFxtYXRocm17JHtuYW1lfX1cXFxcbGVmdCgke2FyZ3N9XFxcXHJpZ2h0KSc7XG5cbiAgcmV0dXJuIG1lZGlhbjtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ21lZGlhbic7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVlcEZvckVhY2ggPSByZXF1aXJlKCcuLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBGb3JFYWNoJyk7XG52YXIgcmVkdWNlID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9yZWR1Y2UnKTtcbnZhciBjb250YWluc0NvbGxlY3Rpb25zID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9jb250YWluc0NvbGxlY3Rpb25zJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIHNtYWxsZXIgPSBsb2FkKHJlcXVpcmUoJy4uL3JlbGF0aW9uYWwvc21hbGxlcicpKTtcbiAgXG4gIC8qKlxuICAgKiBDb21wdXRlIHRoZSBtYXhpbXVtIHZhbHVlIG9mIGEgbWF0cml4IG9yIGEgIGxpc3Qgb2YgdmFsdWVzLlxuICAgKiBJbiBjYXNlIG9mIGEgbXVsdGkgZGltZW5zaW9uYWwgYXJyYXksIHRoZSBtYXhpbXVtIG9mIHRoZSBmbGF0dGVuZWQgYXJyYXlcbiAgICogd2lsbCBiZSBjYWxjdWxhdGVkLiBXaGVuIGBkaW1gIGlzIHByb3ZpZGVkLCB0aGUgbWF4aW11bSBvdmVyIHRoZSBzZWxlY3RlZFxuICAgKiBkaW1lbnNpb24gd2lsbCBiZSBjYWxjdWxhdGVkLiBQYXJhbWV0ZXIgYGRpbWAgaXMgemVyby1iYXNlZC5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICAgbWF0aC5taW4oYSwgYiwgYywgLi4uKVxuICAgKiAgICAgbWF0aC5taW4oQSlcbiAgICogICAgIG1hdGgubWluKEEsIGRpbSlcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgICBtYXRoLm1pbigyLCAxLCA0LCAzKTsgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIDFcbiAgICogICAgIG1hdGgubWluKFsyLCAxLCA0LCAzXSk7ICAgICAgICAgICAgICAgIC8vIHJldHVybnMgMVxuICAgKlxuICAgKiAgICAgLy8gbWF4aW11bSBvdmVyIGEgc3BlY2lmaWVkIGRpbWVuc2lvbiAoemVyby1iYXNlZClcbiAgICogICAgIG1hdGgubWluKFtbMiwgNV0sIFs0LCAzXSwgWzEsIDddXSwgMCk7IC8vIHJldHVybnMgWzEsIDNdXG4gICAqICAgICBtYXRoLm1pbihbWzIsIDVdLCBbNCwgM10sIFsxLCA3XV0sIDEpOyAvLyByZXR1cm5zIFsyLCAzLCAxXVxuICAgKlxuICAgKiAgICAgbWF0aC5tYXgoMi43LCA3LjEsIC00LjUsIDIuMCwgNC4xKTsgICAgLy8gcmV0dXJucyA3LjFcbiAgICogICAgIG1hdGgubWluKDIuNywgNy4xLCAtNC41LCAyLjAsIDQuMSk7ICAgIC8vIHJldHVybnMgLTQuNVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgbWVhbiwgbWVkaWFuLCBtYXgsIHByb2QsIHN0ZCwgc3VtLCB2YXJcbiAgICpcbiAgICogQHBhcmFtIHsuLi4gKn0gYXJncyAgQSBzaW5nbGUgbWF0cml4IG9yIG9yIG11bHRpcGxlIHNjYWxhciB2YWx1ZXNcbiAgICogQHJldHVybiB7Kn0gVGhlIG1pbmltdW0gdmFsdWVcbiAgICovXG4gIHZhciBtaW4gPSB0eXBlZCgnbWluJywge1xuICAgIC8vIG1pbihbYSwgYiwgYywgZCwgLi4uXSlcbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBfbWluLFxuXG4gICAgLy8gbWluKFthLCBiLCBjLCBkLCAuLi5dLCBkaW0pXG4gICAgJ0FycmF5IHwgTWF0cml4LCBudW1iZXIgfCBCaWdOdW1iZXInOiBmdW5jdGlvbiAoYXJyYXksIGRpbSkge1xuICAgICAgcmV0dXJuIHJlZHVjZShhcnJheSwgZGltLnZhbHVlT2YoKSwgX3NtYWxsZXN0KTtcbiAgICB9LFxuXG4gICAgLy8gbWluKGEsIGIsIGMsIGQsIC4uLilcbiAgICAnLi4uJzogZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgIGlmIChjb250YWluc0NvbGxlY3Rpb25zKGFyZ3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1NjYWxhciB2YWx1ZXMgZXhwZWN0ZWQgaW4gZnVuY3Rpb24gbWluJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfbWluKGFyZ3MpO1xuICAgIH1cbiAgfSk7XG5cbiAgbWluLnRvVGV4ID0gJ1xcXFxtaW5cXFxcbGVmdCgke2FyZ3N9XFxcXHJpZ2h0KSc7XG5cbiAgcmV0dXJuIG1pbjtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBzbWFsbGVzdCBvZiB0d28gdmFsdWVzXG4gICAqIEBwYXJhbSB7Kn0geFxuICAgKiBAcGFyYW0geyp9IHlcbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgeCB3aGVuIHggaXMgc21hbGxlc3QsIG9yIHkgd2hlbiB5IGlzIHNtYWxsZXN0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfc21hbGxlc3QoeCwgeSkge1xuICAgIHJldHVybiBzbWFsbGVyKHgsIHkpID8geCA6IHk7XG4gIH1cblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgY2FsY3VsYXRlIHRoZSBtaW5pbXVtIHZhbHVlIGluIGFuIG4tZGltZW5zaW9uYWwgYXJyYXlcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAgICogQHJldHVybiB7bnVtYmVyfSBtaW5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9taW4oYXJyYXkpIHtcbiAgICB2YXIgbWluID0gdW5kZWZpbmVkO1xuXG4gICAgZGVlcEZvckVhY2goYXJyYXksIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKG1pbiA9PT0gdW5kZWZpbmVkIHx8IHNtYWxsZXIodmFsdWUsIG1pbikpIHtcbiAgICAgICAgbWluID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAobWluID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNhbGN1bGF0ZSBtaW4gb2YgYW4gZW1wdHkgYXJyYXknKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWluO1xuICB9XG59XG5cbmV4cG9ydHMubmFtZSA9ICdtaW4nO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGZsYXR0ZW4gPSByZXF1aXJlKCcuLi8uLi91dGlscy9hcnJheScpLmZsYXR0ZW47XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcblxuICAvKipcbiAgKiBDb21wdXRlcyB0aGUgbW9kZSBvZiBhIHNldCBvZiBudW1iZXJzIG9yIGEgbGlzdCB3aXRoIHZhbHVlcyhudW1iZXJzIG9yIGNoYXJhY3RlcnMpLlxuICAqIElmIHRoZXJlIGFyZSBtb3JlIHRoYW4gb25lIG1vZGVzLCBpdCByZXR1cm5zIGEgbGlzdCBvZiB0aG9zZSB2YWx1ZXMuXG4gICpcbiAgKiBTeW50YXg6XG4gICpcbiAgKiAgICAgbWF0aC5tb2RlKGEsIGIsIGMsIC4uLilcbiAgKiAgICAgbWF0aC5tb2RlKEEpXG4gICpcbiAgKiBFeGFtcGxlczpcbiAgKlxuICAqICAgICBtYXRoLm1vZGUoMiwgMSwgNCwgMywgMSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgWzFdXG4gICogICAgIG1hdGgubW9kZShbMSwgMi43LCAzLjIsIDQsIDIuN10pOyAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBbMi43XVxuICAqICAgICBtYXRoLm1vZGUoMSwgNCwgNiwgMSwgNikgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgWzEsIDZdXG4gICogICAgIG1hdGgubW9kZSgnYScsJ2EnLCdiJywnYycpICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBbXCJhXCJdXG4gICogICAgIG1hdGgubW9kZSgxLCAxLjUsICdhYmMnKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBbMSwgMS41LCBcImFiY1wiXVxuICAqXG4gICogU2VlIGFsc286XG4gICpcbiAgKiAgICAgbWVkaWFuLFxuICAqICAgICBtZWFuXG4gICpcbiAgKiBAcGFyYW0gey4uLiAqfSBhcmdzICBBIHNpbmdsZSBtYXRyaXhcbiAgKiBAcmV0dXJuIHsqfSBUaGUgbW9kZSBvZiBhbGwgdmFsdWVzXG4gICovXG5cbiAgdmFyIG1vZGUgPSB0eXBlZCgnbW9kZScsIHtcbiAgICAnQXJyYXkgfCBNYXRyaXgnIDogX21vZGUsXG4gICAgXG4gICAgJy4uLic6IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICByZXR1cm4gX21vZGUoYXJncyk7XG4gICAgfVxuICB9KTtcbiAgXG4gIHJldHVybiBtb2RlO1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBtb2RlIGluIGFuIDEtZGltZW5zaW9uYWwgYXJyYXlcbiAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzXG4gICAqIEByZXR1cm4ge251bWJlcn0gbW9kZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX21vZGUodmFsdWVzKSB7XG4gICAgdmFsdWVzID0gZmxhdHRlbih2YWx1ZXMudmFsdWVPZigpKTtcbiAgICB2YXIgbnVtID0gdmFsdWVzLmxlbmd0aDtcbiAgICBpZiAobnVtID09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNhbGN1bGF0ZSBtb2RlIG9mIGFuIGVtcHR5IGFycmF5Jyk7XG4gICAgfVxuICAgIFxuICAgIHZhciBjb3VudCA9IHt9LFxuICAgICAgICBtb2RlID0gW10sXG4gICAgICAgIG1heCA9IDA7XG4gICAgZm9yICh2YXIgaSBpbiB2YWx1ZXMpIHtcbiAgICAgIGlmICghKHZhbHVlc1tpXSBpbiBjb3VudCkpe1xuICAgICAgICBjb3VudFt2YWx1ZXNbaV1dID0gMDtcbiAgICAgIH1cbiAgICAgIGNvdW50W3ZhbHVlc1tpXV0rKztcbiAgICAgIGlmIChjb3VudFt2YWx1ZXNbaV1dID09IG1heCl7XG4gICAgICAgIG1vZGUucHVzaCh2YWx1ZXNbaV0pO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY291bnRbdmFsdWVzW2ldXSA+IG1heCkge1xuICAgICAgICBtYXggPSBjb3VudFt2YWx1ZXNbaV1dO1xuICAgICAgICBtb2RlID0gW3ZhbHVlc1tpXV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtb2RlOyBcbiAgfTtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ21vZGUnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWVwRm9yRWFjaCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vZGVlcEZvckVhY2gnKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgbXVsdGlwbHkgPSBsb2FkKHJlcXVpcmUoJy4uL2FyaXRobWV0aWMvbXVsdGlwbHlTY2FsYXInKSk7XG5cbiAgLyoqXG4gICAqIENvbXB1dGUgdGhlIHByb2R1Y3Qgb2YgYSBtYXRyaXggb3IgYSBsaXN0IHdpdGggdmFsdWVzLlxuICAgKiBJbiBjYXNlIG9mIGEgKG11bHRpIGRpbWVuc2lvbmFsKSBhcnJheSBvciBtYXRyaXgsIHRoZSBzdW0gb2YgYWxsXG4gICAqIGVsZW1lbnRzIHdpbGwgYmUgY2FsY3VsYXRlZC5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICAgbWF0aC5wcm9kKGEsIGIsIGMsIC4uLilcbiAgICogICAgIG1hdGgucHJvZChBKVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgIG1hdGgubXVsdGlwbHkoMiwgMyk7ICAgICAgICAgICAvLyByZXR1cm5zIDZcbiAgICogICAgIG1hdGgucHJvZCgyLCAzKTsgICAgICAgICAgICAgICAvLyByZXR1cm5zIDZcbiAgICogICAgIG1hdGgucHJvZCgyLCAzLCA0KTsgICAgICAgICAgICAvLyByZXR1cm5zIDI0XG4gICAqICAgICBtYXRoLnByb2QoWzIsIDMsIDRdKTsgICAgICAgICAgLy8gcmV0dXJucyAyNFxuICAgKiAgICAgbWF0aC5wcm9kKFtbMiwgNV0sIFs0LCAzXV0pOyAgIC8vIHJldHVybnMgMTIwXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBtZWFuLCBtZWRpYW4sIG1pbiwgbWF4LCBzdW0sIHN0ZCwgdmFyXG4gICAqXG4gICAqIEBwYXJhbSB7Li4uICp9IGFyZ3MgIEEgc2luZ2xlIG1hdHJpeCBvciBvciBtdWx0aXBsZSBzY2FsYXIgdmFsdWVzXG4gICAqIEByZXR1cm4geyp9IFRoZSBwcm9kdWN0IG9mIGFsbCB2YWx1ZXNcbiAgICovXG4gIHZhciBwcm9kID0gdHlwZWQoJ3Byb2QnLCB7XG4gICAgLy8gcHJvZChbYSwgYiwgYywgZCwgLi4uXSlcbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBfcHJvZCxcblxuICAgIC8vIHByb2QoW2EsIGIsIGMsIGQsIC4uLl0sIGRpbSlcbiAgICAnQXJyYXkgfCBNYXRyaXgsIG51bWJlciB8IEJpZ051bWJlcic6IGZ1bmN0aW9uIChhcnJheSwgZGltKSB7XG4gICAgICAvLyBUT0RPOiBpbXBsZW1lbnQgcHJvZChBLCBkaW0pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2QoQSwgZGltKSBpcyBub3QgeWV0IHN1cHBvcnRlZCcpO1xuICAgICAgLy9yZXR1cm4gcmVkdWNlKGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdLCBtYXRoLnByb2QpO1xuICAgIH0sXG5cbiAgICAvLyBwcm9kKGEsIGIsIGMsIGQsIC4uLilcbiAgICAnLi4uJzogZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgIHJldHVybiBfcHJvZChhcmdzKTtcbiAgICB9XG4gIH0pO1xuXG4gIHByb2QudG9UZXggPSAnXFxcXG1hdGhybXske25hbWV9fVxcXFxsZWZ0KCR7YXJnc31cXFxccmlnaHQpJztcblxuICByZXR1cm4gcHJvZDtcblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgY2FsY3VsYXRlIHRoZSBwcm9kdWN0IG9mIGFuIG4tZGltZW5zaW9uYWwgYXJyYXlcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAgICogQHJldHVybiB7bnVtYmVyfSBwcm9kXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfcHJvZChhcnJheSkge1xuICAgIHZhciBwcm9kID0gdW5kZWZpbmVkO1xuXG4gICAgZGVlcEZvckVhY2goYXJyYXksIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcHJvZCA9IChwcm9kID09PSB1bmRlZmluZWQpID8gdmFsdWUgOiBtdWx0aXBseShwcm9kLCB2YWx1ZSk7XG4gICAgfSk7XG5cbiAgICBpZiAocHJvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjYWxjdWxhdGUgcHJvZCBvZiBhbiBlbXB0eSBhcnJheScpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9kO1xuICB9XG59XG5cbmV4cG9ydHMubmFtZSA9ICdwcm9kJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0ludGVnZXIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9udW1iZXInKS5pc0ludGVnZXI7XG52YXIgaXNOdW1iZXIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9udW1iZXInKS5pc051bWJlcjtcbnZhciBmbGF0dGVuID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYXJyYXknKS5mbGF0dGVuO1xudmFyIGlzQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vaXNDb2xsZWN0aW9uJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIGFkZCA9IGxvYWQocmVxdWlyZSgnLi4vYXJpdGhtZXRpYy9hZGQnKSk7XG4gIHZhciBtdWx0aXBseSA9IGxvYWQocmVxdWlyZSgnLi4vYXJpdGhtZXRpYy9tdWx0aXBseScpKTtcbiAgdmFyIHBhcnRpdGlvblNlbGVjdCA9IGxvYWQocmVxdWlyZSgnLi4vbWF0cml4L3BhcnRpdGlvblNlbGVjdCcpKTtcbiAgdmFyIGNvbXBhcmUgPSBsb2FkKHJlcXVpcmUoJy4uL3JlbGF0aW9uYWwvY29tcGFyZScpKTtcblxuICAvKipcbiAgICogQ29tcHV0ZSB0aGUgcHJvYiBvcmRlciBxdWFudGlsZSBvZiBhIG1hdHJpeCBvciBhIGxpc3Qgd2l0aCB2YWx1ZXMuXG4gICAqIFRoZSBzZXF1ZW5jZSBpcyBzb3J0ZWQgYW5kIHRoZSBtaWRkbGUgdmFsdWUgaXMgcmV0dXJuZWQuXG4gICAqIFN1cHBvcnRlZCB0eXBlcyBvZiBzZXF1ZW5jZSB2YWx1ZXMgYXJlOiBOdW1iZXIsIEJpZ051bWJlciwgVW5pdFxuICAgKiBTdXBwb3J0ZWQgdHlwZXMgb2YgcHJvYmFiaWxpdHkgYXJlOiBOdW1iZXIsIEJpZ051bWJlclxuICAgKlxuICAgKiBJbiBjYXNlIG9mIGEgKG11bHRpIGRpbWVuc2lvbmFsKSBhcnJheSBvciBtYXRyaXgsIHRoZSBwcm9iIG9yZGVyIHF1YW50aWxlXG4gICAqIG9mIGFsbCBlbGVtZW50cyB3aWxsIGJlIGNhbGN1bGF0ZWQuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgIG1hdGgucXVhbnRpbGVTZXEoQSwgcHJvYlssIHNvcnRlZF0pXG4gICAqICAgICBtYXRoLnF1YW50aWxlU2VxKEEsIFtwcm9iMSwgcHJvYjIsIC4uLl1bLCBzb3J0ZWRdKVxuICAgKiAgICAgbWF0aC5xdWFudGlsZVNlcShBLCBOWywgc29ydGVkXSlcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgICBtYXRoLnF1YW50aWxlU2VxKFszLCAtMSwgNSwgN10sIDAuNSk7ICAgICAgICAgLy8gcmV0dXJucyA0XG4gICAqICAgICBtYXRoLnF1YW50aWxlU2VxKFszLCAtMSwgNSwgN10sIFsxLzMsIDIvM10pOyAgLy8gcmV0dXJucyBbMywgNV1cbiAgICogICAgIG1hdGgucXVhbnRpbGVTZXEoWzMsIC0xLCA1LCA3XSwgMik7ICAgICAgICAgICAvLyByZXR1cm5zIFszLCA1XVxuICAgKiAgICAgbWF0aC5xdWFudGlsZVNlcShbLTEsIDMsIDUsIDddLCAwLjUsIHRydWUpOyAgIC8vIHJldHVybnMgNFxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgIG1lZGlhbiwgbWVhbiwgbWluLCBtYXgsIHN1bSwgcHJvZCwgc3RkLCB2YXJcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheSwgTWF0cml4fSBkYXRhICAgICAgICAgICAgICAgIEEgc2luZ2xlIG1hdHJpeCBvciBBcnJheVxuICAgKiBAcGFyYW0ge051bWJlciwgQmlnTnVtYmVyLCBBcnJheX0gcHJvYk9yTiAgcHJvYiBpcyB0aGUgb3JkZXIgb2YgdGhlIHF1YW50aWxlLCB3aGlsZSBOIGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgYW1vdW50IG9mIGV2ZW5seSBkaXN0cmlidXRlZCBzdGVwcyBvZlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvYmFiaWxpdGllczsgb25seSBvbmUgb2YgdGhlc2Ugb3B0aW9ucyBjYW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlIHByb3ZpZGVkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gc29ydGVkPWZhbHNlICAgICAgICAgICAgICBpcyBkYXRhIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXJcbiAgICogQHJldHVybiB7TnVtYmVyLCBCaWdOdW1iZXIsIFVuaXQsIEFycmF5fSAgIFF1YW50aWxlKHMpXG4gICAqL1xuICBmdW5jdGlvbiBxdWFudGlsZVNlcShkYXRhLCBwcm9iT3JOLCBzb3J0ZWQpIHtcbiAgICB2YXIgcHJvYkFyciwgZGF0YUFyciwgb25lO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyIHx8IGFyZ3VtZW50cy5sZW5ndGggPiAzKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0Z1bmN0aW9uIHF1YW50aWxlU2VxIHJlcXVpcmVzIHR3byBvciB0aHJlZSBwYXJhbWV0ZXJzJyk7XG4gICAgfVxuXG4gICAgaWYgKGlzQ29sbGVjdGlvbihkYXRhKSkge1xuICAgICAgc29ydGVkID0gc29ydGVkIHx8IGZhbHNlO1xuICAgICAgaWYgKHR5cGVvZiBzb3J0ZWQgPT09ICdib29sZWFuJykge1xuICAgICAgICBkYXRhQXJyID0gZGF0YS52YWx1ZU9mKCk7XG4gICAgICAgIGlmIChpc051bWJlcihwcm9iT3JOKSkge1xuICAgICAgICAgIGlmIChwcm9iT3JOIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOL3Byb2IgbXVzdCBiZSBub24tbmVnYXRpdmUnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocHJvYk9yTiA8PSAxKSB7XG4gICAgICAgICAgICAvLyBxdWFudGlsZVNlcShbYSwgYiwgYywgZCwgLi4uXSwgcHJvYlssc29ydGVkXSlcbiAgICAgICAgICAgIHJldHVybiBfcXVhbnRpbGVTZXEoZGF0YUFyciwgcHJvYk9yTiwgc29ydGVkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocHJvYk9yTiA+IDEpIHtcbiAgICAgICAgICAgIC8vIHF1YW50aWxlU2VxKFthLCBiLCBjLCBkLCAuLi5dLCBOWyxzb3J0ZWRdKVxuICAgICAgICAgICAgaWYgKCFpc0ludGVnZXIocHJvYk9yTikpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBuUGx1c09uZSA9IHByb2JPck4gKyAxO1xuICAgICAgICAgICAgcHJvYkFyciA9IG5ldyBBcnJheShwcm9iT3JOKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvYk9yTjspIHtcbiAgICAgICAgICAgICAgcHJvYkFycltpXSA9IF9xdWFudGlsZVNlcShkYXRhQXJyLCAoKytpKSAvIG5QbHVzT25lLCBzb3J0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByb2JBcnI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb2JPck4gJiYgcHJvYk9yTi5pc0JpZ051bWJlcikge1xuICAgICAgICAgIGlmIChwcm9iT3JOLmlzTmVnYXRpdmUoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOL3Byb2IgbXVzdCBiZSBub24tbmVnYXRpdmUnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvbmUgPSBuZXcgcHJvYk9yTi5jb25zdHJ1Y3RvcigxKTtcblxuICAgICAgICAgIGlmIChwcm9iT3JOLmx0ZShvbmUpKSB7XG4gICAgICAgICAgICAvLyBxdWFudGlsZVNlcShbYSwgYiwgYywgZCwgLi4uXSwgcHJvYlssc29ydGVkXSlcbiAgICAgICAgICAgIHJldHVybiBfcXVhbnRpbGVTZXEoZGF0YUFyciwgcHJvYk9yTiwgc29ydGVkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocHJvYk9yTi5ndChvbmUpKSB7XG4gICAgICAgICAgICAvLyBxdWFudGlsZVNlcShbYSwgYiwgYywgZCwgLi4uXSwgTlssc29ydGVkXSlcbiAgICAgICAgICAgIGlmICghcHJvYk9yTi5pc0ludGVnZXIoKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ04gbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbGFyZ2VzdCBwb3NzaWJsZSBBcnJheSBsZW5ndGggaXMgMl4zMi0xO1xuICAgICAgICAgICAgLy8gMl4zMiA8IDEwXjE1LCB0aHVzIHNhZmUgY29udmVyc2lvbiBndWFyYW50ZWVkXG4gICAgICAgICAgICB2YXIgaW50TiA9IHByb2JPck4udG9OdW1iZXIoKTtcbiAgICAgICAgICAgIGlmIChpbnROID4gNDI5NDk2NzI5NSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ04gbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gMl4zMi0xLCBhcyB0aGF0IGlzIHRoZSBtYXhpbXVtIGxlbmd0aCBvZiBhbiBBcnJheScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgblBsdXNPbmUgPSBuZXcgdHlwZS5CaWdOdW1iZXIoaW50TiArIDEpO1xuICAgICAgICAgICAgcHJvYkFyciA9IG5ldyBBcnJheShpbnROKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW50TjspIHtcbiAgICAgICAgICAgICAgcHJvYkFycltpXSA9IF9xdWFudGlsZVNlcShkYXRhQXJyLCBuZXcgdHlwZS5CaWdOdW1iZXIoKytpKS5kaXYoblBsdXNPbmUpLCBzb3J0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByb2JBcnI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvYk9yTikpIHtcbiAgICAgICAgICAvLyBxdWFudGlsZVNlcShbYSwgYiwgYywgZCwgLi4uXSwgW3Byb2IxLCBwcm9iMiwgLi4uXVssc29ydGVkXSlcbiAgICAgICAgICBwcm9iQXJyID0gbmV3IEFycmF5KHByb2JPck4ubGVuZ3RoKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb2JBcnIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBjdXJyUHJvYiA9IHByb2JPck5baV07XG4gICAgICAgICAgICBpZiAoaXNOdW1iZXIoY3VyclByb2IpKSB7XG4gICAgICAgICAgICAgIGlmIChjdXJyUHJvYiA8IDAgfHwgY3VyclByb2IgPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9iYWJpbGl0eSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMSwgaW5jbHVzaXZlJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VyclByb2IgJiYgY3VyclByb2IuaXNCaWdOdW1iZXIpIHtcbiAgICAgICAgICAgICAgb25lID0gbmV3IGN1cnJQcm9iLmNvbnN0cnVjdG9yKDEpO1xuICAgICAgICAgICAgICBpZiAoY3VyclByb2IuaXNOZWdhdGl2ZSgpIHx8IGN1cnJQcm9iLmd0KG9uZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2JhYmlsaXR5IG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxLCBpbmNsdXNpdmUnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5leHBlY3RlZCB0eXBlIG9mIGFyZ3VtZW50IGluIGZ1bmN0aW9uIHF1YW50aWxlU2VxJyk7IC8vIEZJWE1FOiBiZWNvbWVzIHJlZHVuZGFudCB3aGVuIGNvbnZlcnRlZCB0byB0eXBlZC1mdW5jdGlvblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcm9iQXJyW2ldID0gX3F1YW50aWxlU2VxKGRhdGFBcnIsIGN1cnJQcm9iLCBzb3J0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcHJvYkFycjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VuZXhwZWN0ZWQgdHlwZSBvZiBhcmd1bWVudCBpbiBmdW5jdGlvbiBxdWFudGlsZVNlcScpOyAvLyBGSVhNRTogYmVjb21lcyByZWR1bmRhbnQgd2hlbiBjb252ZXJ0ZWQgdG8gdHlwZWQtZnVuY3Rpb25cbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5leHBlY3RlZCB0eXBlIG9mIGFyZ3VtZW50IGluIGZ1bmN0aW9uIHF1YW50aWxlU2VxJyk7IC8vIEZJWE1FOiBiZWNvbWVzIHJlZHVuZGFudCB3aGVuIGNvbnZlcnRlZCB0byB0eXBlZC1mdW5jdGlvblxuICAgIH1cblxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VuZXhwZWN0ZWQgdHlwZSBvZiBhcmd1bWVudCBpbiBmdW5jdGlvbiBxdWFudGlsZVNlcScpOyAvLyBGSVhNRTogYmVjb21lcyByZWR1bmRhbnQgd2hlbiBjb252ZXJ0ZWQgdG8gdHlwZWQtZnVuY3Rpb25cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIHByb2Igb3JkZXIgcXVhbnRpbGUgb2YgYW4gbi1kaW1lbnNpb25hbCBhcnJheS5cbiAgICogXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gICAqIEBwYXJhbSB7TnVtYmVyLCBCaWdOdW1iZXJ9IHByb2JcbiAgICogQHBhcmFtIHtCb29sZWFufSBzb3J0ZWRcbiAgICogQHJldHVybiB7TnVtYmVyLCBCaWdOdW1iZXIsIFVuaXR9IHByb2Igb3JkZXIgcXVhbnRpbGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9xdWFudGlsZVNlcShhcnJheSwgcHJvYiwgc29ydGVkKSB7XG4gICAgdmFyIGZsYXQgPSBmbGF0dGVuKGFycmF5KTtcbiAgICB2YXIgbGVuID0gZmxhdC5sZW5ndGg7XG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY2FsY3VsYXRlIHF1YW50aWxlIG9mIGFuIGVtcHR5IHNlcXVlbmNlJyk7XG4gICAgfVxuXG4gICAgaWYgKGlzTnVtYmVyKHByb2IpKSB7XG4gICAgICB2YXIgaW5kZXggPSBwcm9iICogKGxlbi0xKTtcbiAgICAgIHZhciBmcmFjUGFydCA9IGluZGV4ICUgMTtcbiAgICAgIGlmIChmcmFjUGFydCA9PT0gMCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBzb3J0ZWQgPyBmbGF0W2luZGV4XSA6IHBhcnRpdGlvblNlbGVjdChmbGF0LCBpbmRleCk7XG5cbiAgICAgICAgdmFsaWRhdGUodmFsdWUpO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGludGVnZXJQYXJ0ID0gTWF0aC5mbG9vcihpbmRleCk7XG5cbiAgICAgIHZhciBsZWZ0LCByaWdodDtcbiAgICAgIGlmIChzb3J0ZWQpIHtcbiAgICAgICAgbGVmdCA9IGZsYXRbaW50ZWdlclBhcnRdO1xuICAgICAgICByaWdodCA9IGZsYXRbaW50ZWdlclBhcnQrMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByaWdodCA9IHBhcnRpdGlvblNlbGVjdChmbGF0LCBpbnRlZ2VyUGFydCsxKTtcblxuICAgICAgICAvLyBtYXggb2YgcGFydGl0aW9uIGlzIGt0aCBsYXJnZXN0XG4gICAgICAgIGxlZnQgPSBmbGF0W2ludGVnZXJQYXJ0XTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnRlZ2VyUGFydDsgKytpKSB7XG4gICAgICAgICAgaWYgKGNvbXBhcmUoZmxhdFtpXSwgbGVmdCkgPiAwKSB7XG4gICAgICAgICAgICBsZWZ0ID0gZmxhdFtpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFsaWRhdGUobGVmdCk7XG4gICAgICB2YWxpZGF0ZShyaWdodCk7XG5cbiAgICAgIC8vIFEocHJvYikgPSAoMS1mKSpBW2Zsb29yKGluZGV4KV0gKyBmKkFbZmxvb3IoaW5kZXgpKzFdXG4gICAgICByZXR1cm4gYWRkKG11bHRpcGx5KGxlZnQsIDEgLSBmcmFjUGFydCksIG11bHRpcGx5KHJpZ2h0LCBmcmFjUGFydCkpO1xuICAgIH1cblxuICAgIC8vIElmIHByb2IgaXMgYSBCaWdOdW1iZXJcbiAgICB2YXIgaW5kZXggPSBwcm9iLnRpbWVzKGxlbi0xKTtcbiAgICBpZiAoaW5kZXguaXNJbnRlZ2VyKCkpIHtcbiAgICAgIGluZGV4ID0gaW5kZXgudG9OdW1iZXIoKTtcbiAgICAgIHZhciB2YWx1ZSA9IHNvcnRlZCA/IGZsYXRbaW5kZXhdIDogcGFydGl0aW9uU2VsZWN0KGZsYXQsIGluZGV4KTtcblxuICAgICAgdmFsaWRhdGUodmFsdWUpO1xuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIGludGVnZXJQYXJ0ID0gaW5kZXguZmxvb3IoKTtcbiAgICB2YXIgZnJhY1BhcnQgPSBpbmRleC5taW51cyhpbnRlZ2VyUGFydCk7XG4gICAgdmFyIGludGVnZXJQYXJ0TnVtYmVyID0gaW50ZWdlclBhcnQudG9OdW1iZXIoKTtcblxuICAgIHZhciBsZWZ0LCByaWdodDtcbiAgICBpZiAoc29ydGVkKSB7XG4gICAgICBsZWZ0ID0gZmxhdFtpbnRlZ2VyUGFydE51bWJlcl07XG4gICAgICByaWdodCA9IGZsYXRbaW50ZWdlclBhcnROdW1iZXIrMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJpZ2h0ID0gcGFydGl0aW9uU2VsZWN0KGZsYXQsIGludGVnZXJQYXJ0TnVtYmVyKzEpO1xuXG4gICAgICAvLyBtYXggb2YgcGFydGl0aW9uIGlzIGt0aCBsYXJnZXN0XG4gICAgICBsZWZ0ID0gZmxhdFtpbnRlZ2VyUGFydE51bWJlcl07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGludGVnZXJQYXJ0TnVtYmVyOyArK2kpIHtcbiAgICAgICAgaWYgKGNvbXBhcmUoZmxhdFtpXSwgbGVmdCkgPiAwKSB7XG4gICAgICAgICAgbGVmdCA9IGZsYXRbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YWxpZGF0ZShsZWZ0KTtcbiAgICB2YWxpZGF0ZShyaWdodCk7XG5cbiAgICAvLyBRKHByb2IpID0gKDEtZikqQVtmbG9vcihpbmRleCldICsgZipBW2Zsb29yKGluZGV4KSsxXVxuICAgIHZhciBvbmUgPSBuZXcgZnJhY1BhcnQuY29uc3RydWN0b3IoMSk7XG4gICAgcmV0dXJuIGFkZChtdWx0aXBseShsZWZ0LCBvbmUubWludXMoZnJhY1BhcnQpKSwgbXVsdGlwbHkocmlnaHQsIGZyYWNQYXJ0KSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYXJyYXkgdmFsdWUgdHlwZXMgYXJlIHZhbGlkLCB0aHJvdyBlcnJvciBvdGhlcndpc2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgVW5pdH0geFxuICAgKiBAcGFyYW0ge251bWJlciB8IEJpZ051bWJlciB8IFVuaXR9IHhcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHZhciB2YWxpZGF0ZSA9IHR5cGVkKHtcbiAgICAnbnVtYmVyIHwgQmlnTnVtYmVyIHwgVW5pdCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBxdWFudGlsZVNlcTtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ3F1YW50aWxlU2VxJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIHNxcnQgICAgICAgPSBsb2FkKHJlcXVpcmUoJy4uL2FyaXRobWV0aWMvc3FydCcpKTtcbiAgdmFyIHZhcmlhbmNlICAgPSBsb2FkKHJlcXVpcmUoJy4uL3N0YXRpc3RpY3MvdmFyJykpO1xuXG4gIC8qKlxuICAgKiBDb21wdXRlIHRoZSBzdGFuZGFyZCBkZXZpYXRpb24gb2YgYSBtYXRyaXggb3IgYSAgbGlzdCB3aXRoIHZhbHVlcy5cbiAgICogVGhlIHN0YW5kYXJkIGRldmlhdGlvbnMgaXMgZGVmaW5lZCBhcyB0aGUgc3F1YXJlIHJvb3Qgb2YgdGhlIHZhcmlhbmNlOlxuICAgKiBgc3RkKEEpID0gc3FydCh2YXIoQSkpYC5cbiAgICogSW4gY2FzZSBvZiBhIChtdWx0aSBkaW1lbnNpb25hbCkgYXJyYXkgb3IgbWF0cml4LCB0aGUgc3RhbmRhcmQgZGV2aWF0aW9uXG4gICAqIG92ZXIgYWxsIGVsZW1lbnRzIHdpbGwgYmUgY2FsY3VsYXRlZC5cbiAgICpcbiAgICogT3B0aW9uYWxseSwgdGhlIHR5cGUgb2Ygbm9ybWFsaXphdGlvbiBjYW4gYmUgc3BlY2lmaWVkIGFzIHNlY29uZFxuICAgKiBwYXJhbWV0ZXIuIFRoZSBwYXJhbWV0ZXIgYG5vcm1hbGl6YXRpb25gIGNhbiBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZyB2YWx1ZXM6XG4gICAqXG4gICAqIC0gJ3VuYmlhc2VkJyAoZGVmYXVsdCkgVGhlIHN1bSBvZiBzcXVhcmVkIGVycm9ycyBpcyBkaXZpZGVkIGJ5IChuIC0gMSlcbiAgICogLSAndW5jb3JyZWN0ZWQnICAgICAgICBUaGUgc3VtIG9mIHNxdWFyZWQgZXJyb3JzIGlzIGRpdmlkZWQgYnkgblxuICAgKiAtICdiaWFzZWQnICAgICAgICAgICAgIFRoZSBzdW0gb2Ygc3F1YXJlZCBlcnJvcnMgaXMgZGl2aWRlZCBieSAobiArIDEpXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgIG1hdGguc3RkKGEsIGIsIGMsIC4uLilcbiAgICogICAgIG1hdGguc3RkKEEpXG4gICAqICAgICBtYXRoLnN0ZChBLCBub3JtYWxpemF0aW9uKVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgIG1hdGguc3RkKDIsIDQsIDYpOyAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgMlxuICAgKiAgICAgbWF0aC5zdGQoWzIsIDQsIDYsIDhdKTsgICAgICAgICAgICAgICAgLy8gcmV0dXJucyAyLjU4MTk4ODg5NzQ3MTYxMVxuICAgKiAgICAgbWF0aC5zdGQoWzIsIDQsIDYsIDhdLCAndW5jb3JyZWN0ZWQnKTsgLy8gcmV0dXJucyAyLjIzNjA2Nzk3NzQ5OTc5XG4gICAqICAgICBtYXRoLnN0ZChbMiwgNCwgNiwgOF0sICdiaWFzZWQnKTsgICAgICAvLyByZXR1cm5zIDJcbiAgICpcbiAgICogICAgIG1hdGguc3RkKFtbMSwgMiwgM10sIFs0LCA1LCA2XV0pOyAgICAgIC8vIHJldHVybnMgMS44NzA4Mjg2OTMzODY5NzA3XG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBtZWFuLCBtZWRpYW4sIG1heCwgbWluLCBwcm9kLCBzdW0sIHZhclxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5IHwgTWF0cml4fSBhcnJheVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIEEgc2luZ2xlIG1hdHJpeCBvciBvciBtdWx0aXBsZSBzY2FsYXIgdmFsdWVzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbm9ybWFsaXphdGlvbj0ndW5iaWFzZWQnXVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIERldGVybWluZXMgaG93IHRvIG5vcm1hbGl6ZSB0aGUgdmFyaWFuY2UuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgQ2hvb3NlICd1bmJpYXNlZCcgKGRlZmF1bHQpLCAndW5jb3JyZWN0ZWQnLCBvciAnYmlhc2VkJy5cbiAgICogQHJldHVybiB7Kn0gVGhlIHN0YW5kYXJkIGRldmlhdGlvblxuICAgKi9cbiAgdmFyIHN0ZCA9IHR5cGVkKCdzdGQnLCB7XG4gICAgLy8gc3RkKFthLCBiLCBjLCBkLCAuLi5dKVxuICAgICdBcnJheSB8IE1hdHJpeCc6IF9zdGQsXG5cbiAgICAvLyBzdGQoW2EsIGIsIGMsIGQsIC4uLl0sIG5vcm1hbGl6YXRpb24pXG4gICAgJ0FycmF5IHwgTWF0cml4LCBzdHJpbmcnOiBfc3RkLFxuXG4gICAgLy8gc3RkKGEsIGIsIGMsIGQsIC4uLilcbiAgICAnLi4uJzogZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgIHJldHVybiBfc3RkKGFyZ3MpO1xuICAgIH1cbiAgfSk7XG4gIFxuICBzdGQudG9UZXggPSAnXFxcXG1hdGhybXske25hbWV9fVxcXFxsZWZ0KCR7YXJnc31cXFxccmlnaHQpJztcblxuICByZXR1cm4gc3RkO1xuXG4gIGZ1bmN0aW9uIF9zdGQoYXJyYXksIG5vcm1hbGl6YXRpb24pIHtcbiAgICBpZiAoYXJyYXkubGVuZ3RoID09IDApIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignRnVuY3Rpb24gc3RkIHJlcXVpcmVzIG9uZSBvciBtb3JlIHBhcmFtZXRlcnMgKDAgcHJvdmlkZWQpJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNxcnQodmFyaWFuY2UuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gIH1cbn1cblxuZXhwb3J0cy5uYW1lID0gJ3N0ZCc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVlcEZvckVhY2ggPSByZXF1aXJlKCcuLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBGb3JFYWNoJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIGFkZCA9IGxvYWQocmVxdWlyZSgnLi4vYXJpdGhtZXRpYy9hZGRTY2FsYXInKSk7XG5cbiAgLyoqXG4gICAqIENvbXB1dGUgdGhlIHN1bSBvZiBhIG1hdHJpeCBvciBhIGxpc3Qgd2l0aCB2YWx1ZXMuXG4gICAqIEluIGNhc2Ugb2YgYSAobXVsdGkgZGltZW5zaW9uYWwpIGFycmF5IG9yIG1hdHJpeCwgdGhlIHN1bSBvZiBhbGxcbiAgICogZWxlbWVudHMgd2lsbCBiZSBjYWxjdWxhdGVkLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgICBtYXRoLnN1bShhLCBiLCBjLCAuLi4pXG4gICAqICAgICBtYXRoLnN1bShBKVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgIG1hdGguc3VtKDIsIDEsIDQsIDMpOyAgICAgICAgICAgICAgIC8vIHJldHVybnMgMTBcbiAgICogICAgIG1hdGguc3VtKFsyLCAxLCA0LCAzXSk7ICAgICAgICAgICAgIC8vIHJldHVybnMgMTBcbiAgICogICAgIG1hdGguc3VtKFtbMiwgNV0sIFs0LCAzXSwgWzEsIDddXSk7IC8vIHJldHVybnMgMjJcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIG1lYW4sIG1lZGlhbiwgbWluLCBtYXgsIHByb2QsIHN0ZCwgdmFyXG4gICAqXG4gICAqIEBwYXJhbSB7Li4uICp9IGFyZ3MgIEEgc2luZ2xlIG1hdHJpeCBvciBvciBtdWx0aXBsZSBzY2FsYXIgdmFsdWVzXG4gICAqIEByZXR1cm4geyp9IFRoZSBzdW0gb2YgYWxsIHZhbHVlc1xuICAgKi9cbiAgdmFyIHN1bSA9IHR5cGVkKCdzdW0nLCB7XG4gICAgJ0FycmF5IHwgTWF0cml4JzogZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgIC8vIHN1bShbYSwgYiwgYywgZCwgLi4uXSlcbiAgICAgIHJldHVybiBfc3VtKGFyZ3MpO1xuICAgIH0sXG5cbiAgICAnQXJyYXkgfCBNYXRyaXgsIG51bWJlciB8IEJpZ051bWJlcic6IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIHN1bShbYSwgYiwgYywgZCwgLi4uXSwgZGltKVxuICAgICAgLy8gVE9ETzogaW1wbGVtZW50IHN1bShBLCBkaW0pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N1bShBLCBkaW0pIGlzIG5vdCB5ZXQgc3VwcG9ydGVkJyk7XG4gICAgfSxcblxuICAgICcuLi4nOiBmdW5jdGlvbiAoYXJncykge1xuICAgICAgLy8gc3VtKGEsIGIsIGMsIGQsIC4uLilcbiAgICAgIHJldHVybiBfc3VtKGFyZ3MpO1xuICAgIH1cbiAgfSk7XG5cbiAgc3VtLnRvVGV4ID0gJ1xcXFxtYXRocm17JHtuYW1lfX1cXFxcbGVmdCgke2FyZ3N9XFxcXHJpZ2h0KSc7XG5cbiAgcmV0dXJuIHN1bTtcblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgY2FsY3VsYXRlIHRoZSBzdW0gb2YgYW4gbi1kaW1lbnNpb25hbCBhcnJheVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IHN1bVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX3N1bShhcnJheSkge1xuICAgIHZhciBzdW0gPSB1bmRlZmluZWQ7XG5cbiAgICBkZWVwRm9yRWFjaChhcnJheSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBzdW0gPSAoc3VtID09PSB1bmRlZmluZWQpID8gdmFsdWUgOiBhZGQoc3VtLCB2YWx1ZSk7XG4gICAgfSk7XG5cbiAgICBpZiAoc3VtID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHN3aXRjaCAoY29uZmlnLm51bWJlcikge1xuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBjYXNlICdCaWdOdW1iZXInOlxuICAgICAgICAgIHJldHVybiBuZXcgdHlwZS5CaWdOdW1iZXIoMCk7XG4gICAgICAgIGNhc2UgJ0ZyYWN0aW9uJzpcbiAgICAgICAgICByZXR1cm4gbmV3IHR5cGUuRnJhY3Rpb24oMCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1bTtcbiAgfVxufVxuXG5leHBvcnRzLm5hbWUgPSAnc3VtJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBERUZBVUxUX05PUk1BTElaQVRJT04gPSAndW5iaWFzZWQnO1xuXG52YXIgZGVlcEZvckVhY2ggPSByZXF1aXJlKCcuLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBGb3JFYWNoJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIGFkZCA9IGxvYWQocmVxdWlyZSgnLi4vYXJpdGhtZXRpYy9hZGRTY2FsYXInKSk7XG4gIHZhciBzdWJ0cmFjdCA9IGxvYWQocmVxdWlyZSgnLi4vYXJpdGhtZXRpYy9zdWJ0cmFjdCcpKTtcbiAgdmFyIG11bHRpcGx5ID0gbG9hZChyZXF1aXJlKCcuLi9hcml0aG1ldGljL211bHRpcGx5U2NhbGFyJykpO1xuICB2YXIgZGl2aWRlID0gbG9hZChyZXF1aXJlKCcuLi9hcml0aG1ldGljL2RpdmlkZVNjYWxhcicpKTtcblxuICAvKipcbiAgICogQ29tcHV0ZSB0aGUgdmFyaWFuY2Ugb2YgYSBtYXRyaXggb3IgYSAgbGlzdCB3aXRoIHZhbHVlcy5cbiAgICogSW4gY2FzZSBvZiBhIChtdWx0aSBkaW1lbnNpb25hbCkgYXJyYXkgb3IgbWF0cml4LCB0aGUgdmFyaWFuY2Ugb3ZlciBhbGxcbiAgICogZWxlbWVudHMgd2lsbCBiZSBjYWxjdWxhdGVkLlxuICAgKlxuICAgKiBPcHRpb25hbGx5LCB0aGUgdHlwZSBvZiBub3JtYWxpemF0aW9uIGNhbiBiZSBzcGVjaWZpZWQgYXMgc2Vjb25kXG4gICAqIHBhcmFtZXRlci4gVGhlIHBhcmFtZXRlciBgbm9ybWFsaXphdGlvbmAgY2FuIGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHZhbHVlczpcbiAgICpcbiAgICogLSAndW5iaWFzZWQnIChkZWZhdWx0KSBUaGUgc3VtIG9mIHNxdWFyZWQgZXJyb3JzIGlzIGRpdmlkZWQgYnkgKG4gLSAxKVxuICAgKiAtICd1bmNvcnJlY3RlZCcgICAgICAgIFRoZSBzdW0gb2Ygc3F1YXJlZCBlcnJvcnMgaXMgZGl2aWRlZCBieSBuXG4gICAqIC0gJ2JpYXNlZCcgICAgICAgICAgICAgVGhlIHN1bSBvZiBzcXVhcmVkIGVycm9ycyBpcyBkaXZpZGVkIGJ5IChuICsgMSlcbiAgICpcbiAgICogTm90ZSB0aGF0IG9sZGVyIGJyb3dzZXIgbWF5IG5vdCBsaWtlIHRoZSB2YXJpYWJsZSBuYW1lIGB2YXJgLiBJbiB0aGF0XG4gICAqIGNhc2UsIHRoZSBmdW5jdGlvbiBjYW4gYmUgY2FsbGVkIGFzIGBtYXRoWyd2YXInXSguLi4pYCBpbnN0ZWFkIG9mXG4gICAqIGBtYXRoLnZhciguLi4pYC5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICAgbWF0aC52YXIoYSwgYiwgYywgLi4uKVxuICAgKiAgICAgbWF0aC52YXIoQSlcbiAgICogICAgIG1hdGgudmFyKEEsIG5vcm1hbGl6YXRpb24pXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICAgbWF0aC52YXIoMiwgNCwgNik7ICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyA0XG4gICAqICAgICBtYXRoLnZhcihbMiwgNCwgNiwgOF0pOyAgICAgICAgICAgICAgICAvLyByZXR1cm5zIDYuNjY2NjY2NjY2NjY2NjY3XG4gICAqICAgICBtYXRoLnZhcihbMiwgNCwgNiwgOF0sICd1bmNvcnJlY3RlZCcpOyAvLyByZXR1cm5zIDVcbiAgICogICAgIG1hdGgudmFyKFsyLCA0LCA2LCA4XSwgJ2JpYXNlZCcpOyAgICAgIC8vIHJldHVybnMgNFxuICAgKlxuICAgKiAgICAgbWF0aC52YXIoW1sxLCAyLCAzXSwgWzQsIDUsIDZdXSk7ICAgICAgLy8gcmV0dXJucyAzLjVcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIG1lYW4sIG1lZGlhbiwgbWF4LCBtaW4sIHByb2QsIHN0ZCwgc3VtXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXkgfCBNYXRyaXh9IGFycmF5XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgQSBzaW5nbGUgbWF0cml4IG9yIG9yIG11bHRpcGxlIHNjYWxhciB2YWx1ZXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtub3JtYWxpemF0aW9uPSd1bmJpYXNlZCddXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgRGV0ZXJtaW5lcyBob3cgdG8gbm9ybWFsaXplIHRoZSB2YXJpYW5jZS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICBDaG9vc2UgJ3VuYmlhc2VkJyAoZGVmYXVsdCksICd1bmNvcnJlY3RlZCcsIG9yICdiaWFzZWQnLlxuICAgKiBAcmV0dXJuIHsqfSBUaGUgdmFyaWFuY2VcbiAgICovXG4gIHZhciB2YXJpYW5jZSA9IHR5cGVkKCd2YXJpYW5jZScsIHtcbiAgICAvLyB2YXIoW2EsIGIsIGMsIGQsIC4uLl0pXG4gICAgJ0FycmF5IHwgTWF0cml4JzogZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICByZXR1cm4gX3ZhcihhcnJheSwgREVGQVVMVF9OT1JNQUxJWkFUSU9OKTtcbiAgICB9LFxuXG4gICAgLy8gdmFyKFthLCBiLCBjLCBkLCAuLi5dLCBub3JtYWxpemF0aW9uKVxuICAgICdBcnJheSB8IE1hdHJpeCwgc3RyaW5nJzogX3ZhcixcblxuICAgIC8vIHZhcihhLCBiLCBjLCBkLCAuLi4pXG4gICAgJy4uLic6IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICByZXR1cm4gX3ZhcihhcmdzLCBERUZBVUxUX05PUk1BTElaQVRJT04pO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyaWFuY2UudG9UZXggPSAnXFxcXG1hdGhybXtWYXJ9XFxcXGxlZnQoJHthcmdzfVxcXFxyaWdodCknO1xuXG4gIHJldHVybiB2YXJpYW5jZTtcblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgY2FsY3VsYXRlIHRoZSB2YXJpYW5jZSBvZiBhbiBuLWRpbWVuc2lvbmFsIGFycmF5XG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBub3JtYWxpemF0aW9uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgRGV0ZXJtaW5lcyBob3cgdG8gbm9ybWFsaXplIHRoZSB2YXJpYW5jZTpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAtICd1bmJpYXNlZCcgICAgVGhlIHN1bSBvZiBzcXVhcmVkIGVycm9ycyBpcyBkaXZpZGVkIGJ5IChuIC0gMSlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAtICd1bmNvcnJlY3RlZCcgVGhlIHN1bSBvZiBzcXVhcmVkIGVycm9ycyBpcyBkaXZpZGVkIGJ5IG5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAtICdiaWFzZWQnICAgICAgVGhlIHN1bSBvZiBzcXVhcmVkIGVycm9ycyBpcyBkaXZpZGVkIGJ5IChuICsgMSlcbiAgICogQHJldHVybiB7bnVtYmVyIHwgQmlnTnVtYmVyfSB2YXJpYW5jZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX3ZhcihhcnJheSwgbm9ybWFsaXphdGlvbikge1xuICAgIHZhciBzdW0gPSAwO1xuICAgIHZhciBudW0gPSAwO1xuXG4gICAgaWYgKGFycmF5Lmxlbmd0aCA9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0Z1bmN0aW9uIHZhciByZXF1aXJlcyBvbmUgb3IgbW9yZSBwYXJhbWV0ZXJzICgwIHByb3ZpZGVkKScpO1xuICAgIH1cblxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgbWVhbiBhbmQgbnVtYmVyIG9mIGVsZW1lbnRzXG4gICAgZGVlcEZvckVhY2goYXJyYXksIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgc3VtID0gYWRkKHN1bSwgdmFsdWUpO1xuICAgICAgbnVtKys7XG4gICAgfSk7XG4gICAgaWYgKG51bSA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY2FsY3VsYXRlIHZhciBvZiBhbiBlbXB0eSBhcnJheScpO1xuXG4gICAgdmFyIG1lYW4gPSBkaXZpZGUoc3VtLCBudW0pO1xuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSB2YXJpYW5jZVxuICAgIHN1bSA9IDA7XG4gICAgZGVlcEZvckVhY2goYXJyYXksIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdmFyIGRpZmYgPSBzdWJ0cmFjdCh2YWx1ZSwgbWVhbik7XG4gICAgICBzdW0gPSBhZGQoc3VtLCBtdWx0aXBseShkaWZmLCBkaWZmKSk7XG4gICAgfSk7XG5cbiAgICBzd2l0Y2ggKG5vcm1hbGl6YXRpb24pIHtcbiAgICAgIGNhc2UgJ3VuY29ycmVjdGVkJzpcbiAgICAgICAgcmV0dXJuIGRpdmlkZShzdW0sIG51bSk7XG5cbiAgICAgIGNhc2UgJ2JpYXNlZCc6XG4gICAgICAgIHJldHVybiBkaXZpZGUoc3VtLCBudW0gKyAxKTtcblxuICAgICAgY2FzZSAndW5iaWFzZWQnOlxuICAgICAgICB2YXIgemVybyA9IChzdW0gJiYgc3VtLmlzQmlnTnVtYmVyID09PSB0cnVlKSA/IG5ldyB0eXBlLkJpZ051bWJlcigwKSA6IDA7XG4gICAgICAgIHJldHVybiAobnVtID09IDEpID8gemVybyA6IGRpdmlkZShzdW0sIG51bSAtIDEpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbm9ybWFsaXphdGlvbiBcIicgKyBub3JtYWxpemF0aW9uICsgJ1wiLiAnICtcbiAgICAgICAgJ0Nob29zZSBcInVuYmlhc2VkXCIgKGRlZmF1bHQpLCBcInVuY29ycmVjdGVkXCIsIG9yIFwiYmlhc2VkXCIuJyk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMubmFtZSA9ICd2YXInO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3N0cmluZycpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIC8qKlxuICAgKiBGb3JtYXQgYSB2YWx1ZSBvZiBhbnkgdHlwZSBpbnRvIGEgc3RyaW5nLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguZm9ybWF0KHZhbHVlKVxuICAgKiAgICBtYXRoLmZvcm1hdCh2YWx1ZSwgb3B0aW9ucylcbiAgICogICAgbWF0aC5mb3JtYXQodmFsdWUsIHByZWNpc2lvbilcbiAgICogICAgbWF0aC5mb3JtYXQodmFsdWUsIGZuKVxuICAgKlxuICAgKiBXaGVyZTpcbiAgICpcbiAgICogIC0gYHZhbHVlOiAqYFxuICAgKiAgICBUaGUgdmFsdWUgdG8gYmUgZm9ybWF0dGVkXG4gICAqICAtIGBvcHRpb25zOiBPYmplY3RgXG4gICAqICAgIEFuIG9iamVjdCB3aXRoIGZvcm1hdHRpbmcgb3B0aW9ucy4gQXZhaWxhYmxlIG9wdGlvbnM6XG4gICAqICAgIC0gYG5vdGF0aW9uOiBzdHJpbmdgXG4gICAqICAgICAgTnVtYmVyIG5vdGF0aW9uLiBDaG9vc2UgZnJvbTpcbiAgICogICAgICAtICdmaXhlZCdcbiAgICogICAgICAgIEFsd2F5cyB1c2UgcmVndWxhciBudW1iZXIgbm90YXRpb24uXG4gICAqICAgICAgICBGb3IgZXhhbXBsZSAnMTIzLjQwJyBhbmQgJzE0MDAwMDAwJ1xuICAgKiAgICAgIC0gJ2V4cG9uZW50aWFsJ1xuICAgKiAgICAgICAgQWx3YXlzIHVzZSBleHBvbmVudGlhbCBub3RhdGlvbi5cbiAgICogICAgICAgIEZvciBleGFtcGxlICcxLjIzNGUrMicgYW5kICcxLjRlKzcnXG4gICAqICAgICAgLSAnYXV0bycgKGRlZmF1bHQpXG4gICAqICAgICAgICBSZWd1bGFyIG51bWJlciBub3RhdGlvbiBmb3IgbnVtYmVycyBoYXZpbmcgYW4gYWJzb2x1dGUgdmFsdWUgYmV0d2VlblxuICAgKiAgICAgICAgYGxvd2VyYCBhbmQgYHVwcGVyYCBib3VuZHMsIGFuZCB1c2VzIGV4cG9uZW50aWFsIG5vdGF0aW9uIGVsc2V3aGVyZS5cbiAgICogICAgICAgIExvd2VyIGJvdW5kIGlzIGluY2x1ZGVkLCB1cHBlciBib3VuZCBpcyBleGNsdWRlZC5cbiAgICogICAgICAgIEZvciBleGFtcGxlICcxMjMuNCcgYW5kICcxLjRlNycuXG4gICAqICAgIC0gYHByZWNpc2lvbjogbnVtYmVyYFxuICAgKiAgICAgIEEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMTYgdG8gcm91bmQgdGhlIGRpZ2l0cyBvZiB0aGUgbnVtYmVyLiBJbiBjYXNlXG4gICAqICAgICAgb2Ygbm90YXRpb25zICdleHBvbmVudGlhbCcgYW5kICdhdXRvJywgYHByZWNpc2lvbmAgZGVmaW5lcyB0aGUgdG90YWxcbiAgICogICAgICBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIHJldHVybmVkIGFuZCBpcyB1bmRlZmluZWQgYnkgZGVmYXVsdC5cbiAgICogICAgICBJbiBjYXNlIG9mIG5vdGF0aW9uICdmaXhlZCcsIGBwcmVjaXNpb25gIGRlZmluZXMgdGhlIG51bWJlciBvZlxuICAgKiAgICAgIHNpZ25pZmljYW50IGRpZ2l0cyBhZnRlciB0aGUgZGVjaW1hbCBwb2ludCwgYW5kIGlzIDAgYnkgZGVmYXVsdC5cbiAgICogICAgLSBgZXhwb25lbnRpYWw6IE9iamVjdGBcbiAgICogICAgICBBbiBvYmplY3QgY29udGFpbmluZyB0d28gcGFyYW1ldGVycywge251bWJlcn0gbG93ZXIgYW5kIHtudW1iZXJ9IHVwcGVyLFxuICAgKiAgICAgIHVzZWQgYnkgbm90YXRpb24gJ2F1dG8nIHRvIGRldGVybWluZSB3aGVuIHRvIHJldHVybiBleHBvbmVudGlhbFxuICAgKiAgICAgIG5vdGF0aW9uLiBEZWZhdWx0IHZhbHVlcyBhcmUgYGxvd2VyPTFlLTNgIGFuZCBgdXBwZXI9MWU1YC4gT25seVxuICAgKiAgICAgIGFwcGxpY2FibGUgZm9yIG5vdGF0aW9uIGBhdXRvYC5cbiAgICogICAgLSBgZnJhY3Rpb246IHN0cmluZ2AuIEF2YWlsYWJsZSB2YWx1ZXM6ICdyYXRpbycgKGRlZmF1bHQpIG9yICdkZWNpbWFsJy5cbiAgICogICAgICBGb3IgZXhhbXBsZSBgZm9ybWF0KGZyYWN0aW9uKDEsIDMpKWAgd2lsbCBvdXRwdXQgJzEvMycgd2hlbiAncmF0aW8nIGlzXG4gICAqICAgICAgY29uZmlndXJlZCwgYW5kIHdpbGwgb3V0cHV0IGAwLigzKWAgd2hlbiAnZGVjaW1hbCcgaXMgY29uZmlndXJlZC5cbiAgICogLSBgZm46IEZ1bmN0aW9uYFxuICAgKiAgIEEgY3VzdG9tIGZvcm1hdHRpbmcgZnVuY3Rpb24uIENhbiBiZSB1c2VkIHRvIG92ZXJyaWRlIHRoZSBidWlsdC1pbiBub3RhdGlvbnMuXG4gICAqICAgRnVuY3Rpb24gYGZuYCBpcyBjYWxsZWQgd2l0aCBgdmFsdWVgIGFzIHBhcmFtZXRlciBhbmQgbXVzdCByZXR1cm4gYSBzdHJpbmcuXG4gICAqICAgSXMgdXNlZnVsIGZvciBleGFtcGxlIHRvIGZvcm1hdCBhbGwgdmFsdWVzIGluc2lkZSBhIG1hdHJpeCBpbiBhIHBhcnRpY3VsYXIgd2F5LlxuICAgKlxuICAgKiBXaGVuIGB2YWx1ZWAgaXMgYW4gT2JqZWN0OlxuICAgKlxuICAgKiAtIFdoZW4gdGhlIG9iamVjdCBjb250YWlucyBhIHByb3BlcnR5IGBmb3JtYXRgIGJlaW5nIGEgZnVuY3Rpb24sIHRoaXMgZnVuY3Rpb25cbiAgICogICBpcyBpbnZva2VkIGFzIGB2YWx1ZS5mb3JtYXQob3B0aW9ucylgIGFuZCB0aGUgcmVzdWx0IGlzIHJldHVybmVkLlxuICAgKiAtIFdoZW4gdGhlIG9iamVjdCBoYXMgaXRzIG93biBgdG9TdHJpbmdgIG1ldGhvZCwgdGhpcyBtZXRob2QgaXMgaW52b2tlZFxuICAgKiAgIGFuZCB0aGUgcmVzdWx0IGlzIHJldHVybmVkLlxuICAgKiAtIEluIG90aGVyIGNhc2VzIHRoZSBmdW5jdGlvbiB3aWxsIGxvb3Agb3ZlciBhbGwgb2JqZWN0IHByb3BlcnRpZXMgYW5kXG4gICAqICAgcmV0dXJuIEpTT04gb2JqZWN0IG5vdGF0aW9uIGxpa2UgJ3tcImFcIjogMiwgXCJiXCI6IDN9Jy5cbiAgICpcbiAgICogV2hlbiB2YWx1ZSBpcyBhIGZ1bmN0aW9uOlxuICAgKlxuICAgKiAtIFdoZW4gdGhlIGZ1bmN0aW9uIGhhcyBhIHByb3BlcnR5IGBzeW50YXhgLCBpdCByZXR1cm5zIHRoaXNcbiAgICogICBzeW50YXggZGVzY3JpcHRpb24uXG4gICAqIC0gSW4gb3RoZXIgY2FzZXMsIGEgc3RyaW5nIGAnZnVuY3Rpb24nYCBpcyByZXR1cm5lZC5cbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGguZm9ybWF0KDYuNCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgJzYuNCdcbiAgICogICAgbWF0aC5mb3JtYXQoMTI0MDAwMCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyAnMS4yNGU2J1xuICAgKiAgICBtYXRoLmZvcm1hdCgxLzMpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zICcwLjMzMzMzMzMzMzMzMzMzMzMnXG4gICAqICAgIG1hdGguZm9ybWF0KDEvMywgMyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgJzAuMzMzJ1xuICAgKiAgICBtYXRoLmZvcm1hdCgyMTM4NSwgMik7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zICcyMTAwMCdcbiAgICogICAgbWF0aC5mb3JtYXQoMTIuMDcxLCB7bm90YXRpb246ICdmaXhlZCd9KTsgICAgICAgICAgICAgICAgLy8gcmV0dXJucyAnMTInXG4gICAqICAgIG1hdGguZm9ybWF0KDIuMywgICAge25vdGF0aW9uOiAnZml4ZWQnLCBwcmVjaXNpb246IDJ9KTsgIC8vIHJldHVybnMgJzIuMzAnXG4gICAqICAgIG1hdGguZm9ybWF0KDUyLjgsICAge25vdGF0aW9uOiAnZXhwb25lbnRpYWwnfSk7ICAgICAgICAgIC8vIHJldHVybnMgJzUuMjhlKzEnXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBwcmludFxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZhbHVlIHRvIGJlIHN0cmluZ2lmaWVkXG4gICAqIEBwYXJhbSB7T2JqZWN0IHwgRnVuY3Rpb24gfCBudW1iZXJ9IFtvcHRpb25zXSAgRm9ybWF0dGluZyBvcHRpb25zXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGZvcm1hdHRlZCB2YWx1ZVxuICAgKi9cbiAgdmFyIGZvcm1hdCA9IHR5cGVkKCdmb3JtYXQnLCB7XG4gICAgJ2FueSc6IHN0cmluZy5mb3JtYXQsXG4gICAgJ2FueSwgT2JqZWN0IHwgZnVuY3Rpb24gfCBudW1iZXInOiBzdHJpbmcuZm9ybWF0XG4gIH0pO1xuXG4gIGZvcm1hdC50b1RleCA9ICdcXFxcbWF0aHJteyR7bmFtZX19XFxcXGxlZnQoJHthcmdzfVxcXFxyaWdodCknO1xuXG4gIHJldHVybiBmb3JtYXQ7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdmb3JtYXQnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIm1vZHVsZS5leHBvcnRzID0gW1xuICByZXF1aXJlKCcuL2Zvcm1hdCcpLFxuICByZXF1aXJlKCcuL3ByaW50Jylcbl07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc1N0cmluZyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3N0cmluZycpLmlzU3RyaW5nO1xudmFyIGZvcm1hdCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3N0cmluZycpLmZvcm1hdDtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICAvKipcbiAgICogSW50ZXJwb2xhdGUgdmFsdWVzIGludG8gYSBzdHJpbmcgdGVtcGxhdGUuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgIG1hdGgucHJpbnQodGVtcGxhdGUsIHZhbHVlcylcbiAgICogICAgIG1hdGgucHJpbnQodGVtcGxhdGUsIHZhbHVlcywgcHJlY2lzaW9uKVxuICAgKiAgICAgbWF0aC5wcmludCh0ZW1wbGF0ZSwgdmFsdWVzLCBvcHRpb25zKVxuICAgKlxuICAgKiBFeGFtcGxlIHVzYWdlOlxuICAgKlxuICAgKiAgICAgLy8gdGhlIGZvbGxvd2luZyBvdXRwdXRzOiAnTHVjeSBpcyA1IHllYXJzIG9sZCdcbiAgICogICAgIG1hdGgucHJpbnQoJ0x1Y3kgaXMgJGFnZSB5ZWFycyBvbGQnLCB7YWdlOiA1fSk7XG4gICAqXG4gICAqICAgICAvLyB0aGUgZm9sbG93aW5nIG91dHB1dHM6ICdUaGUgdmFsdWUgb2YgcGkgaXMgMy4xNDE1OTI2NTQnXG4gICAqICAgICBtYXRoLnByaW50KCdUaGUgdmFsdWUgb2YgcGkgaXMgJHBpJywge3BpOiBtYXRoLnBpfSwgMTApO1xuICAgKlxuICAgKiAgICAgLy8gdGhlIGZvbGxvd2luZyBvdXRwdXRzOiAnaGVsbG8gTWFyeSEgVGhlIGRhdGUgaXMgMjAxMy0wMy0yMydcbiAgICogICAgIG1hdGgucHJpbnQoJ0hlbGxvICR1c2VyLm5hbWUhIFRoZSBkYXRlIGlzICRkYXRlJywge1xuICAgKiAgICAgICB1c2VyOiB7XG4gICAqICAgICAgICAgbmFtZTogJ01hcnknLFxuICAgKiAgICAgICB9LFxuICAgKiAgICAgICBkYXRlOiBuZXcgRGF0ZSgyMDEzLCAyLCAyMykudG9JU09TdHJpbmcoKS5zdWJzdHJpbmcoMCwgMTApXG4gICAqICAgICB9KTtcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgICBmb3JtYXRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRlbXBsYXRlICAgICBBIHN0cmluZyBjb250YWluaW5nIHZhcmlhYmxlIHBsYWNlaG9sZGVycy5cbiAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlcyAgICAgICBBbiBvYmplY3QgY29udGFpbmluZyB2YXJpYWJsZXMgd2hpY2ggd2lsbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlIGZpbGxlZCBpbiBpbiB0aGUgdGVtcGxhdGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgT2JqZWN0fSBbb3B0aW9uc10gIEZvcm1hdHRpbmcgb3B0aW9ucyxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciB0aGUgbnVtYmVyIG9mIGRpZ2l0cyB0byBmb3JtYXQgbnVtYmVycy5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZWUgZnVuY3Rpb24gbWF0aC5mb3JtYXQgZm9yIGEgZGVzY3JpcHRpb25cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiBhbGwgb3B0aW9ucy5cbiAgICogQHJldHVybiB7c3RyaW5nfSBJbnRlcnBvbGF0ZWQgc3RyaW5nXG4gICAqL1xuICB2YXIgcHJpbnQgPSB0eXBlZCAoJ3ByaW50Jywge1xuICAgICdzdHJpbmcsIE9iamVjdCc6IF9wcmludCxcbiAgICAnc3RyaW5nLCBPYmplY3QsIG51bWJlcic6IF9wcmludFxuICB9KTtcblxuICBwcmludC50b1RleCA9ICdcXFxcbWF0aHJteyR7bmFtZX19XFxcXGxlZnQoJHthcmdzfVxcXFxyaWdodCknO1xuXG4gIHJldHVybiBwcmludDtcbn1cblxuLyoqXG4gKiBJbnRlcnBvbGF0ZSB2YWx1ZXMgaW50byBhIHN0cmluZyB0ZW1wbGF0ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZW1wbGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlc1xuICogQHBhcmFtIHtudW1iZXIgfCBPYmplY3R9IFtvcHRpb25zXVxuICogQHJldHVybnMge3N0cmluZ30gSW50ZXJwb2xhdGVkIHN0cmluZ1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX3ByaW50KHRlbXBsYXRlLCB2YWx1ZXMsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRlbXBsYXRlLnJlcGxhY2UoL1xcJChbXFx3XFwuXSspL2csIGZ1bmN0aW9uIChvcmlnaW5hbCwga2V5KSB7XG4gICAgICAgIHZhciBrZXlzID0ga2V5LnNwbGl0KCcuJyk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1trZXlzLnNoaWZ0KCldO1xuICAgICAgICB3aGlsZSAoa2V5cy5sZW5ndGggJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBrID0ga2V5cy5zaGlmdCgpO1xuICAgICAgICAgIHZhbHVlID0gayA/IHZhbHVlW2tdIDogdmFsdWUgKyAnLic7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICghaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0KHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsO1xuICAgICAgfVxuICApO1xufVxuXG5leHBvcnRzLm5hbWUgPSAncHJpbnQnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZXBNYXAgPSByZXF1aXJlKCcuLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBNYXAnKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGludmVyc2UgY29zaW5lIG9mIGEgdmFsdWUuXG4gICAqXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5hY29zKHgpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmFjb3MoMC41KTsgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIDEuMDQ3MTk3NTUxMTk2NTk3OVxuICAgKiAgICBtYXRoLmFjb3MobWF0aC5jb3MoMS41KSk7IC8vIHJldHVybnMgbnVtYmVyIDEuNVxuICAgKlxuICAgKiAgICBtYXRoLmFjb3MoMik7ICAgICAgICAgICAgIC8vIHJldHVybnMgQ29tcGxleCAwICsgMS4zMTY5NTc4OTY5MjQ4MTY2IGlcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGNvcywgYXRhbiwgYXNpblxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0geCAgRnVuY3Rpb24gaW5wdXRcbiAgICogQHJldHVybiB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSBUaGUgYXJjIGNvc2luZSBvZiB4XG4gICAqL1xuICB2YXIgYWNvcyA9IHR5cGVkKCdhY29zJywge1xuICAgICdudW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgaWYgKCh4ID49IC0xICYmIHggPD0gMSkgfHwgY29uZmlnLnByZWRpY3RhYmxlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFjb3MoeCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0eXBlLkNvbXBsZXgoeCwgMCkuYWNvcygpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAnQ29tcGxleCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5hY29zKCk7XG4gICAgfSxcblxuICAgICdCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHguYWNvcygpO1xuICAgIH0sXG5cbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIGRlZXBNYXAoeCwgYWNvcyk7XG4gICAgfVxuICB9KTtcblxuICBhY29zLnRvVGV4ID0gJ1xcXFxjb3Neey0xfVxcXFxsZWZ0KCR7YXJnc1swXX1cXFxccmlnaHQpJztcblxuICByZXR1cm4gYWNvcztcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2Fjb3MnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZXBNYXAgPSByZXF1aXJlKCcuLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBNYXAnKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGh5cGVyYm9saWMgYXJjY29zIG9mIGEgdmFsdWUsXG4gICAqIGRlZmluZWQgYXMgYGFjb3NoKHgpID0gbG4oc3FydCh4XjIgLSAxKSArIHgpYC5cbiAgICpcbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmFjb3NoKHgpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmFjb3NoKDEuNSk7ICAgICAgIC8vIHJldHVybnMgMC45NjI0MjM2NTAxMTkyMDY5XG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBjb3NoLCBhc2luaCwgYXRhbmhcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXIgfCBDb21wbGV4IHwgVW5pdCB8IEFycmF5IHwgTWF0cml4fSB4ICBGdW5jdGlvbiBpbnB1dFxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9IEh5cGVyYm9saWMgYXJjY29zaW5lIG9mIHhcbiAgICovXG4gIHZhciBhY29zaCA9IHR5cGVkKCdhY29zaCcsIHtcbiAgICAnbnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICh4ID49IDEgfHwgY29uZmlnLnByZWRpY3RhYmxlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmxvZyhNYXRoLnNxcnQoeCp4IC0gMSkgKyB4KTtcbiAgICAgIH1cbiAgICAgIGlmICh4IDw9IC0xKSB7XG4gICAgICAgIHJldHVybiBuZXcgdHlwZS5Db21wbGV4KE1hdGgubG9nKE1hdGguc3FydCh4KnggLSAxKSAtIHgpLCBNYXRoLlBJKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgdHlwZS5Db21wbGV4KHgsIDApLmFjb3NoKCk7XG4gICAgfSxcblxuICAgICdDb21wbGV4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LmFjb3NoKCk7XG4gICAgfSxcblxuICAgICdCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHguYWNvc2goKTtcbiAgICB9LFxuXG4gICAgJ0FycmF5IHwgTWF0cml4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBkZWVwTWFwKHgsIGFjb3NoKTtcbiAgICB9XG4gIH0pO1xuXG4gIGFjb3NoLnRvVGV4ID0gJ1xcXFxjb3NoXnstMX1cXFxcbGVmdCgke2FyZ3NbMF19XFxcXHJpZ2h0KSc7XG5cbiAgcmV0dXJuIGFjb3NoO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnYWNvc2gnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZXBNYXAgPSByZXF1aXJlKCcuLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBNYXAnKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGludmVyc2UgY290YW5nZW50IG9mIGEgdmFsdWUsIGRlZmluZWQgYXMgYGFjb3QoeCkgPSBhdGFuKDEveClgLlxuICAgKlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguYWNvdCh4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5hY290KDAuNSk7ICAgICAgICAgICAvLyByZXR1cm5zIG51bWJlciAwLjQ2MzY0NzYwOTAwMDgwNjFcbiAgICogICAgbWF0aC5hY290KG1hdGguY290KDEuNSkpOyAvLyByZXR1cm5zIG51bWJlciAxLjVcbiAgICpcbiAgICogICAgbWF0aC5hY290KDIpOyAgICAgICAgICAgICAvLyByZXR1cm5zIENvbXBsZXggMS41NzA3OTYzMjY3OTQ4OTY2IC0xLjMxNjk1Nzg5NjkyNDgxNjYgaVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgY290LCBhdGFuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSB4ICAgRnVuY3Rpb24gaW5wdXRcbiAgICogQHJldHVybiB7bnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSBUaGUgYXJjIGNvdGFuZ2VudCBvZiB4XG4gICAqL1xuICB2YXIgYWNvdCA9IHR5cGVkKCdhY290Jywge1xuICAgICdudW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIE1hdGguYXRhbigxIC8geCk7XG4gICAgfSxcblxuICAgICdDb21wbGV4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LmFjb3QoKTtcbiAgICB9LFxuXG4gICAgJ0JpZ051bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gbmV3IHR5cGUuQmlnTnVtYmVyKDEpLmRpdih4KS5hdGFuKCk7XG4gICAgfSxcblxuICAgICdBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gZGVlcE1hcCh4LCBhY290KTtcbiAgICB9XG4gIH0pO1xuXG4gIGFjb3QudG9UZXggPSAnXFxcXGNvdF57LTF9XFxcXGxlZnQoJHthcmdzWzBdfVxcXFxyaWdodCknO1xuXG4gIHJldHVybiBhY290O1xufVxuXG5leHBvcnRzLm5hbWUgPSAnYWNvdCc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVlcE1hcCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vZGVlcE1hcCcpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgaHlwZXJib2xpYyBhcmNjb3RhbmdlbnQgb2YgYSB2YWx1ZSxcbiAgICogZGVmaW5lZCBhcyBgYWNvdGgoeCkgPSBhdGFuaCgxL3gpID0gKGxuKCh4KzEpL3gpICsgbG4oeC8oeC0xKSkpIC8gMmAuXG4gICAqXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5hY290aCh4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5hY290aCgwLjUpOyAgICAgICAvLyByZXR1cm5zIDAuODA0NzE4OTU2MjE3MDUwM1xuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgYWNzY2gsIGFzZWNoXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSB4ICBGdW5jdGlvbiBpbnB1dFxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9IEh5cGVyYm9saWMgYXJjY290YW5nZW50IG9mIHhcbiAgICovXG4gIHZhciBhY290aCA9IHR5cGVkKCdhY290aCcsIHtcbiAgICAnbnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICh4ID49IDEgfHwgeCA8PSAtMSB8fCBjb25maWcucHJlZGljdGFibGUpIHtcbiAgICAgICAgcmV0dXJuIGlzRmluaXRlKHgpID8gKE1hdGgubG9nKCh4KzEpL3gpICsgTWF0aC5sb2coeC8oeC0xKSkpIC8gMiA6IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IHR5cGUuQ29tcGxleCh4LCAwKS5hY290aCgpO1xuICAgIH0sXG5cbiAgICAnQ29tcGxleCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5hY290aCgpO1xuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBuZXcgdHlwZS5CaWdOdW1iZXIoMSkuZGl2KHgpLmF0YW5oKCk7XG4gICAgfSxcblxuICAgICdBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gZGVlcE1hcCh4LCBhY290aCk7XG4gICAgfVxuICB9KTtcblxuICBhY290aC50b1RleCA9ICdcXFxcY290aF57LTF9XFxcXGxlZnQoJHthcmdzWzBdfVxcXFxyaWdodCknO1xuXG4gIHJldHVybiBhY290aDtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2Fjb3RoJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWVwTWFwID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9kZWVwTWFwJyk7XG5cblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGludmVyc2UgY29zZWNhbnQgb2YgYSB2YWx1ZSwgZGVmaW5lZCBhcyBgYWNzYyh4KSA9IGFzaW4oMS94KWAuXG4gICAqXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5hY3NjKHgpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmFjc2MoMC41KTsgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIDAuNTIzNTk4Nzc1NTk4Mjk4OVxuICAgKiAgICBtYXRoLmFjc2MobWF0aC5jc2MoMS41KSk7IC8vIHJldHVybnMgbnVtYmVyIH4xLjVcbiAgICpcbiAgICogICAgbWF0aC5hY3NjKDIpOyAgICAgICAgICAgICAvLyByZXR1cm5zIENvbXBsZXggMS41NzA3OTYzMjY3OTQ4OTY2IC0xLjMxNjk1Nzg5NjkyNDgxNjYgaVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgY3NjLCBhc2luLCBhc2VjXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSB4ICAgRnVuY3Rpb24gaW5wdXRcbiAgICogQHJldHVybiB7bnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSBUaGUgYXJjIGNvc2VjYW50IG9mIHhcbiAgICovXG4gIHZhciBhY3NjID0gdHlwZWQoJ2Fjc2MnLCB7XG4gICAgJ251bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAoeCA8PSAtMSB8fCB4ID49IDEgfHwgY29uZmlnLnByZWRpY3RhYmxlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFzaW4oMSAvIHgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyB0eXBlLkNvbXBsZXgoeCwgMCkuYWNzYygpO1xuICAgIH0sXG5cbiAgICAnQ29tcGxleCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5hY3NjKCk7XG4gICAgfSxcblxuICAgICdCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIG5ldyB0eXBlLkJpZ051bWJlcigxKS5kaXYoeCkuYXNpbigpO1xuICAgIH0sXG5cbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIGRlZXBNYXAoeCwgYWNzYyk7XG4gICAgfVxuICB9KTtcblxuICBhY3NjLnRvVGV4ID0gJ1xcXFxjc2Neey0xfVxcXFxsZWZ0KCR7YXJnc1swXX1cXFxccmlnaHQpJztcblxuICByZXR1cm4gYWNzYztcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2Fjc2MnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZXBNYXAgPSByZXF1aXJlKCcuLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBNYXAnKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGh5cGVyYm9saWMgYXJjY29zZWNhbnQgb2YgYSB2YWx1ZSxcbiAgICogZGVmaW5lZCBhcyBgYWNzY2goeCkgPSBhc2luaCgxL3gpID0gbG4oMS94ICsgc3FydCgxL3heMiArIDEpKWAuXG4gICAqXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5hY3NjaCh4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5hY3NjaCgwLjUpOyAgICAgICAvLyByZXR1cm5zIDEuNDQzNjM1NDc1MTc4ODEwM1xuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgYXNlY2gsIGFjb3RoXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSB4ICBGdW5jdGlvbiBpbnB1dFxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9IEh5cGVyYm9saWMgYXJjY29zZWNhbnQgb2YgeFxuICAgKi9cbiAgdmFyIGFjc2NoID0gdHlwZWQoJ2Fjc2NoJywge1xuICAgICdudW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgeCA9IDEgLyB4O1xuICAgICAgcmV0dXJuIE1hdGgubG9nKHggKyBNYXRoLnNxcnQoeCp4ICsgMSkpO1xuICAgIH0sXG5cbiAgICAnQ29tcGxleCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5hY3NjaCgpO1xuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBuZXcgdHlwZS5CaWdOdW1iZXIoMSkuZGl2KHgpLmFzaW5oKCk7XG4gICAgfSxcblxuICAgICdBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gZGVlcE1hcCh4LCBhY3NjaCk7XG4gICAgfVxuICB9KTtcblxuICBhY3NjaC50b1RleCA9ICdcXFxcbWF0aHJte2NzY2h9XnstMX1cXFxcbGVmdCgke2FyZ3NbMF19XFxcXHJpZ2h0KSc7XG5cbiAgcmV0dXJuIGFjc2NoO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnYWNzY2gnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZXBNYXAgPSByZXF1aXJlKCcuLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBNYXAnKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGludmVyc2Ugc2VjYW50IG9mIGEgdmFsdWUuIERlZmluZWQgYXMgYGFzZWMoeCkgPSBhY29zKDEveClgLlxuICAgKlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguYXNlYyh4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5hc2VjKDAuNSk7ICAgICAgICAgICAvLyByZXR1cm5zIDEuMDQ3MTk3NTUxMTk2NTk3OVxuICAgKiAgICBtYXRoLmFzZWMobWF0aC5zZWMoMS41KSk7IC8vIHJldHVybnMgMS41XG4gICAqXG4gICAqICAgIG1hdGguYXNlYygyKTsgICAgICAgICAgICAgLy8gcmV0dXJucyAwICsgMS4zMTY5NTc4OTY5MjQ4MTY2IGlcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGFjb3MsIGFjb3QsIGFjc2NcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9IHggIEZ1bmN0aW9uIGlucHV0XG4gICAqIEByZXR1cm4ge251bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0gVGhlIGFyYyBzZWNhbnQgb2YgeFxuICAgKi9cbiAgdmFyIGFzZWMgPSB0eXBlZCgnYXNlYycsIHtcbiAgICAnbnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICh4IDw9IC0xIHx8IHggPj0gMSB8fCBjb25maWcucHJlZGljdGFibGUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYWNvcygxIC8geCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IHR5cGUuQ29tcGxleCh4LCAwKS5hc2VjKCk7XG4gICAgfSxcblxuICAgICdDb21wbGV4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LmFzZWMoKTtcbiAgICB9LFxuXG4gICAgJ0JpZ051bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gbmV3IHR5cGUuQmlnTnVtYmVyKDEpLmRpdih4KS5hY29zKCk7XG4gICAgfSxcblxuICAgICdBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gZGVlcE1hcCh4LCBhc2VjKTtcbiAgICB9XG4gIH0pO1xuXG4gIGFzZWMudG9UZXggPSAnXFxcXHNlY157LTF9XFxcXGxlZnQoJHthcmdzWzBdfVxcXFxyaWdodCknO1xuXG4gIHJldHVybiBhc2VjO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnYXNlYyc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVlcE1hcCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vZGVlcE1hcCcpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBhY29zaCA9IHR5cGVkLmZpbmQobG9hZChyZXF1aXJlKCcuL2Fjb3NoJykpLCBbJ0NvbXBsZXgnXSk7XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgaHlwZXJib2xpYyBhcmNzZWNhbnQgb2YgYSB2YWx1ZSxcbiAgICogZGVmaW5lZCBhcyBgYXNlY2goeCkgPSBhY29zaCgxL3gpID0gbG4oc3FydCgxL3heMiAtIDEpICsgMS94KWAuXG4gICAqXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5hc2VjaCh4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5hc2VjaCgwLjUpOyAgICAgICAvLyByZXR1cm5zIDEuMzE2OTU3ODk2OTI0ODE2NlxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgYWNzY2gsIGFjb3RoXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSB4ICBGdW5jdGlvbiBpbnB1dFxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9IEh5cGVyYm9saWMgYXJjc2VjYW50IG9mIHhcbiAgICovXG4gIHZhciBhc2VjaCA9IHR5cGVkKCdhc2VjaCcsIHtcbiAgICAnbnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICgoeCA8PSAxICYmIHggPj0gLTEpIHx8IGNvbmZpZy5wcmVkaWN0YWJsZSkge1xuICAgICAgICB4ID0gMSAvIHg7XG5cbiAgICAgICAgdmFyIHJldCA9IE1hdGguc3FydCh4KnggLSAxKTtcbiAgICAgICAgaWYgKHggPiAwIHx8IGNvbmZpZy5wcmVkaWN0YWJsZSkge1xuICAgICAgICAgIHJldHVybiBNYXRoLmxvZyhyZXQgKyB4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgdHlwZS5Db21wbGV4KE1hdGgubG9nKHJldCAtIHgpLCBNYXRoLlBJKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyB0eXBlLkNvbXBsZXgoeCwgMCkuYXNlY2goKTtcbiAgICB9LFxuXG4gICAgJ0NvbXBsZXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHguYXNlY2goKVxuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBuZXcgdHlwZS5CaWdOdW1iZXIoMSkuZGl2KHgpLmFjb3NoKCk7XG4gICAgfSxcblxuICAgICdBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gZGVlcE1hcCh4LCBhc2VjaCk7XG4gICAgfVxuICB9KTtcblxuICBhc2VjaC50b1RleCA9ICdcXFxcbWF0aHJte3NlY2h9XnstMX1cXFxcbGVmdCgke2FyZ3NbMF19XFxcXHJpZ2h0KSc7XG5cbiAgcmV0dXJuIGFzZWNoO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnYXNlY2gnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZXBNYXAgPSByZXF1aXJlKCcuLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBNYXAnKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGludmVyc2Ugc2luZSBvZiBhIHZhbHVlLlxuICAgKlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguYXNpbih4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5hc2luKDAuNSk7ICAgICAgICAgICAvLyByZXR1cm5zIG51bWJlciAwLjUyMzU5ODc3NTU5ODI5ODlcbiAgICogICAgbWF0aC5hc2luKG1hdGguc2luKDEuNSkpOyAvLyByZXR1cm5zIG51bWJlciB+MS41XG4gICAqXG4gICAqICAgIG1hdGguYXNpbigyKTsgICAgICAgICAgICAgLy8gcmV0dXJucyBDb21wbGV4IDEuNTcwNzk2MzI2Nzk0ODk2NiAtMS4zMTY5NTc4OTY5MjQ4MTY2IGlcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIHNpbiwgYXRhbiwgYWNvc1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0geCAgIEZ1bmN0aW9uIGlucHV0XG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0gVGhlIGFyYyBzaW5lIG9mIHhcbiAgICovXG4gIHZhciBhc2luID0gdHlwZWQoJ2FzaW4nLCB7XG4gICAgJ251bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAoKHggPj0gLTEgJiYgeCA8PSAxKSB8fCBjb25maWcucHJlZGljdGFibGUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYXNpbih4KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IHR5cGUuQ29tcGxleCh4LCAwKS5hc2luKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgICdDb21wbGV4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LmFzaW4oKTtcbiAgICB9LFxuXG4gICAgJ0JpZ051bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5hc2luKCk7XG4gICAgfSxcblxuICAgICdBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAvLyBkZWVwIG1hcCBjb2xsZWN0aW9uLCBza2lwIHplcm9zIHNpbmNlIGFzaW4oMCkgPSAwXG4gICAgICByZXR1cm4gZGVlcE1hcCh4LCBhc2luLCB0cnVlKTtcbiAgICB9XG4gIH0pO1xuXG4gIGFzaW4udG9UZXggPSAnXFxcXHNpbl57LTF9XFxcXGxlZnQoJHthcmdzWzBdfVxcXFxyaWdodCknO1xuXG4gIHJldHVybiBhc2luO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnYXNpbic7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVlcE1hcCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vZGVlcE1hcCcpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgaHlwZXJib2xpYyBhcmNzaW5lIG9mIGEgdmFsdWUsXG4gICAqIGRlZmluZWQgYXMgYGFzaW5oKHgpID0gbG4oeCArIHNxcnQoeF4yICsgMSkpYC5cbiAgICpcbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmFzaW5oKHgpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmFzaW5oKDAuNSk7ICAgICAgIC8vIHJldHVybnMgMC40ODEyMTE4MjUwNTk2MDM0N1xuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgYWNvc2gsIGF0YW5oXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSB4ICBGdW5jdGlvbiBpbnB1dFxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9IEh5cGVyYm9saWMgYXJjc2luZSBvZiB4XG4gICAqL1xuICB2YXIgYXNpbmggPSB0eXBlZCgnYXNpbmgnLCB7XG4gICAgJ251bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gTWF0aC5sb2coTWF0aC5zcXJ0KHgqeCArIDEpICsgeCk7XG4gICAgfSxcblxuICAgICdDb21wbGV4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHguYXNpbmgoKTtcbiAgICB9LFxuXG4gICAgJ0JpZ051bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5hc2luaCgpO1xuICAgIH0sXG5cbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgLy8gZGVlcCBtYXAgY29sbGVjdGlvbiwgc2tpcCB6ZXJvcyBzaW5jZSBhc2luaCgwKSA9IDBcbiAgICAgIHJldHVybiBkZWVwTWFwKHgsIGFzaW5oLCB0cnVlKTtcbiAgICB9XG4gIH0pO1xuXG4gIGFzaW5oLnRvVGV4ID0gJ1xcXFxzaW5oXnstMX1cXFxcbGVmdCgke2FyZ3NbMF19XFxcXHJpZ2h0KSc7XG5cbiAgcmV0dXJuIGFzaW5oO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnYXNpbmgnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZXBNYXAgPSByZXF1aXJlKCcuLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBNYXAnKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGludmVyc2UgdGFuZ2VudCBvZiBhIHZhbHVlLlxuICAgKlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguYXRhbih4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5hdGFuKDAuNSk7ICAgICAgICAgICAvLyByZXR1cm5zIG51bWJlciAwLjQ2MzY0NzYwOTAwMDgwNjFcbiAgICogICAgbWF0aC5hdGFuKG1hdGgudGFuKDEuNSkpOyAvLyByZXR1cm5zIG51bWJlciAxLjVcbiAgICpcbiAgICogICAgbWF0aC5hdGFuKDIpOyAgICAgICAgICAgICAvLyByZXR1cm5zIENvbXBsZXggMS41NzA3OTYzMjY3OTQ4OTY2IC0xLjMxNjk1Nzg5NjkyNDgxNjYgaVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgdGFuLCBhc2luLCBhY29zXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSB4ICAgRnVuY3Rpb24gaW5wdXRcbiAgICogQHJldHVybiB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSBUaGUgYXJjIHRhbmdlbnQgb2YgeFxuICAgKi9cbiAgdmFyIGF0YW4gPSB0eXBlZCgnYXRhbicsIHtcbiAgICAnbnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBNYXRoLmF0YW4oeCk7XG4gICAgfSxcblxuICAgICdDb21wbGV4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LmF0YW4oKTtcbiAgICB9LFxuXG4gICAgJ0JpZ051bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5hdGFuKCk7XG4gICAgfSxcblxuICAgICdBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAvLyBkZWVwIG1hcCBjb2xsZWN0aW9uLCBza2lwIHplcm9zIHNpbmNlIGF0YW4oMCkgPSAwXG4gICAgICByZXR1cm4gZGVlcE1hcCh4LCBhdGFuLCB0cnVlKTtcbiAgICB9XG4gIH0pO1xuXG4gIGF0YW4udG9UZXggPSAnXFxcXHRhbl57LTF9XFxcXGxlZnQoJHthcmdzWzBdfVxcXFxyaWdodCknO1xuXG4gIHJldHVybiBhdGFuO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnYXRhbic7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG5cbiAgdmFyIG1hdHJpeCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvZnVuY3Rpb24vbWF0cml4JykpO1xuXG4gIHZhciBhbGdvcml0aG0wMiA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMDInKSk7XG4gIHZhciBhbGdvcml0aG0wMyA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMDMnKSk7XG4gIHZhciBhbGdvcml0aG0wOSA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMDknKSk7XG4gIHZhciBhbGdvcml0aG0xMSA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMTEnKSk7XG4gIHZhciBhbGdvcml0aG0xMiA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMTInKSk7XG4gIHZhciBhbGdvcml0aG0xMyA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMTMnKSk7XG4gIHZhciBhbGdvcml0aG0xNCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMTQnKSk7XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgaW52ZXJzZSB0YW5nZW50IGZ1bmN0aW9uIHdpdGggdHdvIGFyZ3VtZW50cywgeS94LlxuICAgKiBCeSBwcm92aWRpbmcgdHdvIGFyZ3VtZW50cywgdGhlIHJpZ2h0IHF1YWRyYW50IG9mIHRoZSBjb21wdXRlZCBhbmdsZSBjYW4gYmVcbiAgICogZGV0ZXJtaW5lZC5cbiAgICpcbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmF0YW4yKHksIHgpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmF0YW4yKDIsIDIpIC8gbWF0aC5waTsgICAgICAgLy8gcmV0dXJucyBudW1iZXIgMC4yNVxuICAgKlxuICAgKiAgICB2YXIgYW5nbGUgPSBtYXRoLnVuaXQoNjAsICdkZWcnKTsgLy8gcmV0dXJucyBVbml0IDYwIGRlZ1xuICAgKiAgICB2YXIgeCA9IG1hdGguY29zKGFuZ2xlKTtcbiAgICogICAgdmFyIHkgPSBtYXRoLnNpbihhbmdsZSk7XG4gICAqXG4gICAqICAgIG1hdGguYXRhbigyKTsgICAgICAgICAgICAgLy8gcmV0dXJucyBDb21wbGV4IDEuNTcwNzk2MzI2Nzk0ODk2NiAtMS4zMTY5NTc4OTY5MjQ4MTY2IGlcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIHRhbiwgYXRhbiwgc2luLCBjb3NcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXIgfCBBcnJheSB8IE1hdHJpeH0geSAgU2Vjb25kIGRpbWVuc2lvblxuICAgKiBAcGFyYW0ge251bWJlciB8IEFycmF5IHwgTWF0cml4fSB4ICBGaXJzdCBkaW1lbnNpb25cbiAgICogQHJldHVybiB7bnVtYmVyIHwgQXJyYXkgfCBNYXRyaXh9IEZvdXItcXVhZHJhbnQgaW52ZXJzZSB0YW5nZW50XG4gICAqL1xuICB2YXIgYXRhbjIgPSB0eXBlZCgnYXRhbjInLCB7XG5cbiAgICAnbnVtYmVyLCBudW1iZXInOiBNYXRoLmF0YW4yLFxuXG4gICAgLy8gQ29tcGxleCBudW1iZXJzIGRvZXNuJ3Qgc2VlbSB0byBoYXZlIGEgcmVhc29uYWJsZSBpbXBsZW1lbnRhdGlvbiBvZlxuICAgIC8vIGF0YW4yKCkuIEV2ZW4gTWF0bGFiIHJlbW92ZWQgdGhlIHN1cHBvcnQsIGFmdGVyIHRoZXkgb25seSBjYWxjdWxhdGVkXG4gICAgLy8gdGhlIGF0YW4gb25seSBvbiBiYXNlIG9mIHRoZSByZWFsIHBhcnQgb2YgdGhlIG51bWJlcnMgYW5kIGlnbm9yZWQgdGhlIGltYWdpbmFyeS5cblxuICAgICdCaWdOdW1iZXIsIEJpZ051bWJlcic6IGZ1bmN0aW9uICh5LCB4KSB7XG4gICAgICByZXR1cm4gdHlwZS5CaWdOdW1iZXIuYXRhbjIoeSwgeCk7XG4gICAgfSxcblxuICAgICdNYXRyaXgsIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuXG4gICAgICAvLyBwcm9jZXNzIG1hdHJpeCBzdG9yYWdlXG4gICAgICBzd2l0Y2ggKHguc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgc3dpdGNoICh5LnN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICAgICAgLy8gc3BhcnNlIC4qIHNwYXJzZVxuICAgICAgICAgICAgICBjID0gYWxnb3JpdGhtMDkoeCwgeSwgYXRhbjIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAvLyBzcGFyc2UgLiogZGVuc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTAyKHksIHgsIGF0YW4yLCB0cnVlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgICAgIC8vIGRlbnNlIC4qIHNwYXJzZVxuICAgICAgICAgICAgICBjID0gYWxnb3JpdGhtMDMoeCwgeSwgYXRhbjIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAvLyBkZW5zZSAuKiBkZW5zZVxuICAgICAgICAgICAgICBjID0gYWxnb3JpdGhtMTMoeCwgeSwgYXRhbjIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gYXRhbjIobWF0cml4KHgpLCBtYXRyaXgoeSkpLnZhbHVlT2YoKTtcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGF0YW4yKG1hdHJpeCh4KSwgeSk7XG4gICAgfSxcblxuICAgICdNYXRyaXgsIEFycmF5JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBhdGFuMih4LCBtYXRyaXgoeSkpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4LCBudW1iZXIgfCBCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gcmVzdWx0XG4gICAgICB2YXIgYztcbiAgICAgIC8vIGNoZWNrIHN0b3JhZ2UgZm9ybWF0XG4gICAgICBzd2l0Y2ggKHguc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTExKHgsIHksIGF0YW4yLCBmYWxzZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTE0KHgsIHksIGF0YW4yLCBmYWxzZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuXG4gICAgJ251bWJlciB8IEJpZ051bWJlciwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHJlc3VsdFxuICAgICAgdmFyIGM7XG4gICAgICAvLyBjaGVjayBzdG9yYWdlIGZvcm1hdFxuICAgICAgc3dpdGNoICh5LnN0b3JhZ2UoKSkge1xuICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xMih5LCB4LCBhdGFuMiwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTE0KHksIHgsIGF0YW4yLCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG5cbiAgICAnQXJyYXksIG51bWJlciB8IEJpZ051bWJlcic6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gYWxnb3JpdGhtMTQobWF0cml4KHgpLCB5LCBhdGFuMiwgZmFsc2UpLnZhbHVlT2YoKTtcbiAgICB9LFxuXG4gICAgJ251bWJlciB8IEJpZ051bWJlciwgQXJyYXknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGFsZ29yaXRobTE0KG1hdHJpeCh5KSwgeCwgYXRhbjIsIHRydWUpLnZhbHVlT2YoKTtcbiAgICB9XG4gIH0pO1xuXG4gIGF0YW4yLnRvVGV4ID0gJ1xcXFxtYXRocm17YXRhbjJ9XFxcXGxlZnQoJHthcmdzfVxcXFxyaWdodCknO1xuXG4gIHJldHVybiBhdGFuMjtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2F0YW4yJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWVwTWFwID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9kZWVwTWFwJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgaHlwZXJib2xpYyBhcmN0YW5nZW50IG9mIGEgdmFsdWUsXG4gICAqIGRlZmluZWQgYXMgYGF0YW5oKHgpID0gbG4oKDEgKyB4KS8oMSAtIHgpKSAvIDJgLlxuICAgKlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguYXRhbmgoeClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGguYXRhbmgoMC41KTsgICAgICAgLy8gcmV0dXJucyAwLjU0OTMwNjE0NDMzNDA1NDlcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGFjb3NoLCBhc2luaFxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0geCAgRnVuY3Rpb24gaW5wdXRcbiAgICogQHJldHVybiB7bnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSBIeXBlcmJvbGljIGFyY3RhbmdlbnQgb2YgeFxuICAgKi9cbiAgdmFyIGF0YW5oID0gdHlwZWQoJ2F0YW5oJywge1xuICAgICdudW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgaWYgKCh4IDw9IDEgJiYgeCA+PSAtMSkgfHwgY29uZmlnLnByZWRpY3RhYmxlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmxvZygoMSArIHgpLygxIC0geCkpIC8gMjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgdHlwZS5Db21wbGV4KHgsIDApLmF0YW5oKCk7XG4gICAgfSxcblxuICAgICdDb21wbGV4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LmF0YW5oKCk7XG4gICAgfSxcblxuICAgICdCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHguYXRhbmgoKTtcbiAgICB9LFxuXG4gICAgJ0FycmF5IHwgTWF0cml4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIC8vIGRlZXAgbWFwIGNvbGxlY3Rpb24sIHNraXAgemVyb3Mgc2luY2UgYXRhbmgoMCkgPSAwXG4gICAgICByZXR1cm4gZGVlcE1hcCh4LCBhdGFuaCwgdHJ1ZSk7XG4gICAgfVxuICB9KTtcblxuICBhdGFuaC50b1RleCA9ICdcXFxcdGFuaF57LTF9XFxcXGxlZnQoJHthcmdzWzBdfVxcXFxyaWdodCknO1xuXG4gIHJldHVybiBhdGFuaDtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2F0YW5oJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWVwTWFwID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9kZWVwTWFwJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBjb3NpbmUgb2YgYSB2YWx1ZS5cbiAgICpcbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmNvcyh4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5jb3MoMik7ICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIC0wLjQxNjE0NjgzNjU0NzE0MjJcbiAgICogICAgbWF0aC5jb3MobWF0aC5waSAvIDQpOyAgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyICAwLjcwNzEwNjc4MTE4NjU0NzVcbiAgICogICAgbWF0aC5jb3MobWF0aC51bml0KDE4MCwgJ2RlZycpKTsgIC8vIHJldHVybnMgbnVtYmVyIC0xXG4gICAqICAgIG1hdGguY29zKG1hdGgudW5pdCg2MCwgJ2RlZycpKTsgICAvLyByZXR1cm5zIG51bWJlciAgMC41XG4gICAqXG4gICAqICAgIHZhciBhbmdsZSA9IDAuMjtcbiAgICogICAgbWF0aC5wb3cobWF0aC5zaW4oYW5nbGUpLCAyKSArIG1hdGgucG93KG1hdGguY29zKGFuZ2xlKSwgMik7IC8vIHJldHVybnMgbnVtYmVyIH4xXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBjb3MsIHRhblxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXh9IHggIEZ1bmN0aW9uIGlucHV0XG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0gQ29zaW5lIG9mIHhcbiAgICovXG4gIHZhciBjb3MgPSB0eXBlZCgnY29zJywge1xuICAgICdudW1iZXInOiBNYXRoLmNvcyxcblxuICAgICdDb21wbGV4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LmNvcygpO1xuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LmNvcygpO1xuICAgIH0sXG5cbiAgICAnVW5pdCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAoIXguaGFzQmFzZSh0eXBlLlVuaXQuQkFTRV9VTklUUy5BTkdMRSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvciAoJ1VuaXQgaW4gZnVuY3Rpb24gY29zIGlzIG5vIGFuZ2xlJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29zKHgudmFsdWUpO1xuICAgIH0sXG5cbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIGRlZXBNYXAoeCwgY29zKTtcbiAgICB9XG4gIH0pO1xuXG4gIGNvcy50b1RleCA9ICdcXFxcY29zXFxcXGxlZnQoJHthcmdzWzBdfVxcXFxyaWdodCknO1xuXG4gIHJldHVybiBjb3M7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdjb3MnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBkZWVwTWFwID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9kZWVwTWFwJyk7XHJcblxyXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlIHRoZSBoeXBlcmJvbGljIGNvc2luZSBvZiBhIHZhbHVlLFxyXG4gICAqIGRlZmluZWQgYXMgYGNvc2goeCkgPSAxLzIgKiAoZXhwKHgpICsgZXhwKC14KSlgLlxyXG4gICAqXHJcbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cclxuICAgKlxyXG4gICAqIFN5bnRheDpcclxuICAgKlxyXG4gICAqICAgIG1hdGguY29zaCh4KVxyXG4gICAqXHJcbiAgICogRXhhbXBsZXM6XHJcbiAgICpcclxuICAgKiAgICBtYXRoLmNvc2goMC41KTsgICAgICAgLy8gcmV0dXJucyBudW1iZXIgMS4xMjc2MjU5NjUyMDYzODA3XHJcbiAgICpcclxuICAgKiBTZWUgYWxzbzpcclxuICAgKlxyXG4gICAqICAgIHNpbmgsIHRhbmhcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeH0geCAgRnVuY3Rpb24gaW5wdXRcclxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9IEh5cGVyYm9saWMgY29zaW5lIG9mIHhcclxuICAgKi9cclxuICB2YXIgY29zaCA9IHR5cGVkKCdjb3NoJywge1xyXG4gICAgJ251bWJlcic6IF9jb3NoLFxyXG5cclxuICAgICdDb21wbGV4JzogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgcmV0dXJuIHguY29zaCgpO1xyXG4gICAgfSxcclxuXHJcbiAgICAnQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgcmV0dXJuIHguY29zaCgpO1xyXG4gICAgfSxcclxuXHJcbiAgICAnVW5pdCc6IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgIGlmICgheC5oYXNCYXNlKHR5cGUuVW5pdC5CQVNFX1VOSVRTLkFOR0xFKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IgKCdVbml0IGluIGZ1bmN0aW9uIGNvc2ggaXMgbm8gYW5nbGUnKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gY29zaCh4LnZhbHVlKTtcclxuICAgIH0sXHJcblxyXG4gICAgJ0FycmF5IHwgTWF0cml4JzogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgcmV0dXJuIGRlZXBNYXAoeCwgY29zaCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIGNvc2gudG9UZXggPSAnXFxcXGNvc2hcXFxcbGVmdCgke2FyZ3NbMF19XFxcXHJpZ2h0KSc7XHJcblxyXG4gIHJldHVybiBjb3NoO1xyXG59XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlIHRoZSBoeXBlcmJvbGljIGNvc2luZSBvZiBhIG51bWJlclxyXG4gKiBAcGFyYW0ge251bWJlcn0geFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gX2Nvc2goeCkge1xyXG4gIHJldHVybiAoTWF0aC5leHAoeCkgKyBNYXRoLmV4cCgteCkpIC8gMjtcclxufVxyXG5cclxuZXhwb3J0cy5uYW1lID0gJ2Nvc2gnO1xyXG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xyXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWVwTWFwID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9kZWVwTWFwJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgY290YW5nZW50IG9mIGEgdmFsdWUuIERlZmluZWQgYXMgYGNvdCh4KSA9IDEgLyB0YW4oeClgLlxuICAgKlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguY290KHgpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmNvdCgyKTsgICAgICAvLyByZXR1cm5zIG51bWJlciAtMC40NTc2NTc1NTQzNjAyODU3N1xuICAgKiAgICAxIC8gbWF0aC50YW4oMik7ICAvLyByZXR1cm5zIG51bWJlciAtMC40NTc2NTc1NTQzNjAyODU3N1xuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgdGFuLCBzZWMsIGNzY1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlciB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXh9IHggIEZ1bmN0aW9uIGlucHV0XG4gICAqIEByZXR1cm4ge251bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0gQ290YW5nZW50IG9mIHhcbiAgICovXG4gIHZhciBjb3QgPSB0eXBlZCgnY290Jywge1xuICAgICdudW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIDEgLyBNYXRoLnRhbih4KTtcbiAgICB9LFxuXG4gICAgJ0NvbXBsZXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHguY290KCk7XG4gICAgfSxcblxuICAgICdCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIG5ldyB0eXBlLkJpZ051bWJlcigxKS5kaXYoeC50YW4oKSk7XG4gICAgfSxcblxuICAgICdVbml0JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICgheC5oYXNCYXNlKHR5cGUuVW5pdC5CQVNFX1VOSVRTLkFOR0xFKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yICgnVW5pdCBpbiBmdW5jdGlvbiBjb3QgaXMgbm8gYW5nbGUnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb3QoeC52YWx1ZSk7XG4gICAgfSxcblxuICAgICdBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gZGVlcE1hcCh4LCBjb3QpO1xuICAgIH1cbiAgfSk7XG5cbiAgY290LnRvVGV4ID0gJ1xcXFxjb3RcXFxcbGVmdCgke2FyZ3NbMF19XFxcXHJpZ2h0KSc7XG5cbiAgcmV0dXJuIGNvdDtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2NvdCc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGRlZXBNYXAgPSByZXF1aXJlKCcuLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBNYXAnKTtcclxuXHJcbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcclxuICAvKipcclxuICAgKiBDYWxjdWxhdGUgdGhlIGh5cGVyYm9saWMgY290YW5nZW50IG9mIGEgdmFsdWUsXHJcbiAgICogZGVmaW5lZCBhcyBgY290aCh4KSA9IDEgLyB0YW5oKHgpYC5cclxuICAgKlxyXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXHJcbiAgICpcclxuICAgKiBTeW50YXg6XHJcbiAgICpcclxuICAgKiAgICBtYXRoLmNvdGgoeClcclxuICAgKlxyXG4gICAqIEV4YW1wbGVzOlxyXG4gICAqXHJcbiAgICogICAgLy8gY290aCh4KSA9IDEgLyB0YW5oKHgpXHJcbiAgICogICAgbWF0aC5jb3RoKDIpOyAgICAgICAgIC8vIHJldHVybnMgMS4wMzczMTQ3MjA3Mjc1NDgyXHJcbiAgICogICAgMSAvIG1hdGgudGFuaCgyKTsgICAgIC8vIHJldHVybnMgMS4wMzczMTQ3MjA3Mjc1NDgyXHJcbiAgICpcclxuICAgKiBTZWUgYWxzbzpcclxuICAgKlxyXG4gICAqICAgIHNpbmgsIHRhbmgsIGNvc2hcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeH0geCAgRnVuY3Rpb24gaW5wdXRcclxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9IEh5cGVyYm9saWMgY290YW5nZW50IG9mIHhcclxuICAgKi9cclxuICB2YXIgY290aCA9IHR5cGVkKCdjb3RoJywge1xyXG4gICAgJ251bWJlcic6IF9jb3RoLFxyXG5cclxuICAgICdDb21wbGV4JzogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgcmV0dXJuIHguY290aCgpO1xyXG4gICAgfSxcclxuXHJcbiAgICAnQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgcmV0dXJuIG5ldyB0eXBlLkJpZ051bWJlcigxKS5kaXYoeC50YW5oKCkpO1xyXG4gICAgfSxcclxuXHJcbiAgICAnVW5pdCc6IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgIGlmICgheC5oYXNCYXNlKHR5cGUuVW5pdC5CQVNFX1VOSVRTLkFOR0xFKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IgKCdVbml0IGluIGZ1bmN0aW9uIGNvdGggaXMgbm8gYW5nbGUnKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gY290aCh4LnZhbHVlKTtcclxuICAgIH0sXHJcblxyXG4gICAgJ0FycmF5IHwgTWF0cml4JzogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgcmV0dXJuIGRlZXBNYXAoeCwgY290aCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIGNvdGgudG9UZXggPSAnXFxcXGNvdGhcXFxcbGVmdCgke2FyZ3NbMF19XFxcXHJpZ2h0KSc7XHJcblxyXG4gIHJldHVybiBjb3RoO1xyXG59XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlIHRoZSBoeXBlcmJvbGljIGNvc2luZSBvZiBhIG51bWJlclxyXG4gKiBAcGFyYW0ge251bWJlcn0geFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gX2NvdGgoeCkge1xyXG4gIHZhciBlID0gTWF0aC5leHAoMiAqIHgpO1xyXG4gIHJldHVybiAoZSArIDEpIC8gKGUgLSAxKTtcclxufVxyXG5cclxuZXhwb3J0cy5uYW1lID0gJ2NvdGgnO1xyXG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xyXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWVwTWFwID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9kZWVwTWFwJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgY29zZWNhbnQgb2YgYSB2YWx1ZSwgZGVmaW5lZCBhcyBgY3NjKHgpID0gMS9zaW4oeClgLlxuICAgKlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguY3NjKHgpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmNzYygyKTsgICAgICAvLyByZXR1cm5zIG51bWJlciAxLjA5OTc1MDE3MDI5NDYxN1xuICAgKiAgICAxIC8gbWF0aC5zaW4oMik7ICAvLyByZXR1cm5zIG51bWJlciAxLjA5OTc1MDE3MDI5NDYxN1xuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgc2luLCBzZWMsIGNvdFxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlciB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXh9IHggIEZ1bmN0aW9uIGlucHV0XG4gICAqIEByZXR1cm4ge251bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0gQ29zZWNhbnQgb2YgeFxuICAgKi9cbiAgdmFyIGNzYyA9IHR5cGVkKCdjc2MnLCB7XG4gICAgJ251bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gMSAvIE1hdGguc2luKHgpO1xuICAgIH0sXG5cbiAgICAnQ29tcGxleCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5jc2MoKTtcbiAgICB9LFxuXG4gICAgJ0JpZ051bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gbmV3IHR5cGUuQmlnTnVtYmVyKDEpLmRpdih4LnNpbigpKTtcbiAgICB9LFxuXG4gICAgJ1VuaXQnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgaWYgKCF4Lmhhc0Jhc2UodHlwZS5Vbml0LkJBU0VfVU5JVFMuQU5HTEUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IgKCdVbml0IGluIGZ1bmN0aW9uIGNzYyBpcyBubyBhbmdsZScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNzYyh4LnZhbHVlKTtcbiAgICB9LFxuXG4gICAgJ0FycmF5IHwgTWF0cml4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBkZWVwTWFwKHgsIGNzYyk7XG4gICAgfVxuICB9KTtcblxuICBjc2MudG9UZXggPSAnXFxcXGNzY1xcXFxsZWZ0KCR7YXJnc1swXX1cXFxccmlnaHQpJztcblxuICByZXR1cm4gY3NjO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnY3NjJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgZGVlcE1hcCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vZGVlcE1hcCcpO1xyXG52YXIgc2lnbiA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL251bWJlcicpLnNpZ247XHJcblxyXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlIHRoZSBoeXBlcmJvbGljIGNvc2VjYW50IG9mIGEgdmFsdWUsXHJcbiAgICogZGVmaW5lZCBhcyBgY3NjaCh4KSA9IDEgLyBzaW5oKHgpYC5cclxuICAgKlxyXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXHJcbiAgICpcclxuICAgKiBTeW50YXg6XHJcbiAgICpcclxuICAgKiAgICBtYXRoLmNzY2goeClcclxuICAgKlxyXG4gICAqIEV4YW1wbGVzOlxyXG4gICAqXHJcbiAgICogICAgLy8gY3NjaCh4KSA9IDEvIHNpbmgoeClcclxuICAgKiAgICBtYXRoLmNzY2goMC41KTsgICAgICAgLy8gcmV0dXJucyAxLjkxOTAzNDc1MTMzNDk0MzdcclxuICAgKiAgICAxIC8gbWF0aC5zaW5oKDAuNSk7ICAgLy8gcmV0dXJucyAxLjkxOTAzNDc1MTMzNDk0MzdcclxuICAgKlxyXG4gICAqIFNlZSBhbHNvOlxyXG4gICAqXHJcbiAgICogICAgc2luaCwgc2VjaCwgY290aFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXIgfCBDb21wbGV4IHwgVW5pdCB8IEFycmF5IHwgTWF0cml4fSB4ICBGdW5jdGlvbiBpbnB1dFxyXG4gICAqIEByZXR1cm4ge251bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0gSHlwZXJib2xpYyBjb3NlY2FudCBvZiB4XHJcbiAgICovXHJcbiAgdmFyIGNzY2ggPSB0eXBlZCgnY3NjaCcsIHtcclxuICAgICdudW1iZXInOiBfY3NjaCxcclxuXHJcbiAgICAnQ29tcGxleCc6IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgIHJldHVybiB4LmNzY2goKTtcclxuICAgIH0sXHJcblxyXG4gICAgJ0JpZ051bWJlcic6IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgIHJldHVybiBuZXcgdHlwZS5CaWdOdW1iZXIoMSkuZGl2KHguc2luaCgpKTtcclxuICAgIH0sXHJcblxyXG4gICAgJ1VuaXQnOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICBpZiAoIXguaGFzQmFzZSh0eXBlLlVuaXQuQkFTRV9VTklUUy5BTkdMRSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yICgnVW5pdCBpbiBmdW5jdGlvbiBjc2NoIGlzIG5vIGFuZ2xlJyk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGNzY2goeC52YWx1ZSk7XHJcbiAgICB9LFxyXG5cclxuICAgICdBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgIHJldHVybiBkZWVwTWFwKHgsIGNzY2gpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICBjc2NoLnRvVGV4ID0gJ1xcXFxtYXRocm17Y3NjaH1cXFxcbGVmdCgke2FyZ3NbMF19XFxcXHJpZ2h0KSc7XHJcblxyXG4gIHJldHVybiBjc2NoO1xyXG59XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlIHRoZSBoeXBlcmJvbGljIGNvc2VjYW50IG9mIGEgbnVtYmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBfY3NjaCh4KSB7XHJcbiAgLy8gY29uc2lkZXIgdmFsdWVzIGNsb3NlIHRvIHplcm8gKCsvLSlcclxuICBpZiAoeCA9PSAwKSB7XHJcbiAgICByZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xyXG4gIH1cclxuICBlbHNlIHtcclxuICAgIHJldHVybiBNYXRoLmFicygyIC8gKE1hdGguZXhwKHgpIC0gTWF0aC5leHAoLXgpKSkgKiBzaWduKHgpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5uYW1lID0gJ2NzY2gnO1xyXG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IFtcbiAgcmVxdWlyZSgnLi9hY29zJyksXG4gIHJlcXVpcmUoJy4vYWNvc2gnKSxcbiAgcmVxdWlyZSgnLi9hY290JyksXG4gIHJlcXVpcmUoJy4vYWNvdGgnKSxcbiAgcmVxdWlyZSgnLi9hY3NjJyksXG4gIHJlcXVpcmUoJy4vYWNzY2gnKSxcbiAgcmVxdWlyZSgnLi9hc2VjJyksXG4gIHJlcXVpcmUoJy4vYXNlY2gnKSxcbiAgcmVxdWlyZSgnLi9hc2luJyksXG4gIHJlcXVpcmUoJy4vYXNpbmgnKSxcbiAgcmVxdWlyZSgnLi9hdGFuJyksXG4gIHJlcXVpcmUoJy4vYXRhbjInKSxcbiAgcmVxdWlyZSgnLi9hdGFuaCcpLFxuICByZXF1aXJlKCcuL2NvcycpLFxuICByZXF1aXJlKCcuL2Nvc2gnKSxcbiAgcmVxdWlyZSgnLi9jb3QnKSxcbiAgcmVxdWlyZSgnLi9jb3RoJyksXG4gIHJlcXVpcmUoJy4vY3NjJyksXG4gIHJlcXVpcmUoJy4vY3NjaCcpLFxuICByZXF1aXJlKCcuL3NlYycpLFxuICByZXF1aXJlKCcuL3NlY2gnKSxcbiAgcmVxdWlyZSgnLi9zaW4nKSxcbiAgcmVxdWlyZSgnLi9zaW5oJyksXG4gIHJlcXVpcmUoJy4vdGFuJyksXG4gIHJlcXVpcmUoJy4vdGFuaCcpXG5dO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVlcE1hcCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vZGVlcE1hcCcpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIHNlY2FudCBvZiBhIHZhbHVlLCBkZWZpbmVkIGFzIGBzZWMoeCkgPSAxL2Nvcyh4KWAuXG4gICAqXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5zZWMoeClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGguc2VjKDIpOyAgICAgIC8vIHJldHVybnMgbnVtYmVyIC0yLjQwMjk5Nzk2MTcyMjM4MjJcbiAgICogICAgMSAvIG1hdGguY29zKDIpOyAgLy8gcmV0dXJucyBudW1iZXIgLTIuNDAyOTk3OTYxNzIyMzgyMlxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgY29zLCBjc2MsIGNvdFxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlciB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXh9IHggIEZ1bmN0aW9uIGlucHV0XG4gICAqIEByZXR1cm4ge251bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0gU2VjYW50IG9mIHhcbiAgICovXG4gIHZhciBzZWMgPSB0eXBlZCgnc2VjJywge1xuICAgICdudW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIDEgLyBNYXRoLmNvcyh4KTtcbiAgICB9LFxuXG4gICAgJ0NvbXBsZXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHguc2VjKCk7XG4gICAgfSxcblxuICAgICdCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIG5ldyB0eXBlLkJpZ051bWJlcigxKS5kaXYoeC5jb3MoKSk7XG4gICAgfSxcblxuICAgICdVbml0JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICgheC5oYXNCYXNlKHR5cGUuVW5pdC5CQVNFX1VOSVRTLkFOR0xFKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yICgnVW5pdCBpbiBmdW5jdGlvbiBzZWMgaXMgbm8gYW5nbGUnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWMoeC52YWx1ZSk7XG4gICAgfSxcblxuICAgICdBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gZGVlcE1hcCh4LCBzZWMpO1xuICAgIH1cbiAgfSk7XG5cbiAgc2VjLnRvVGV4ID0gJ1xcXFxzZWNcXFxcbGVmdCgke2FyZ3NbMF19XFxcXHJpZ2h0KSc7XG5cbiAgcmV0dXJuIHNlYztcbn1cblxuZXhwb3J0cy5uYW1lID0gJ3NlYyc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGRlZXBNYXAgPSByZXF1aXJlKCcuLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBNYXAnKTtcclxuXHJcbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcclxuICAvKipcclxuICAgKiBDYWxjdWxhdGUgdGhlIGh5cGVyYm9saWMgc2VjYW50IG9mIGEgdmFsdWUsXHJcbiAgICogZGVmaW5lZCBhcyBgc2VjaCh4KSA9IDEgLyBjb3NoKHgpYC5cclxuICAgKlxyXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXHJcbiAgICpcclxuICAgKiBTeW50YXg6XHJcbiAgICpcclxuICAgKiAgICBtYXRoLnNlY2goeClcclxuICAgKlxyXG4gICAqIEV4YW1wbGVzOlxyXG4gICAqXHJcbiAgICogICAgLy8gc2VjaCh4KSA9IDEvIGNvc2goeClcclxuICAgKiAgICBtYXRoLnNlY2goMC41KTsgICAgICAgLy8gcmV0dXJucyAwLjg4NjgxODg4Mzk3MDA3NFxyXG4gICAqICAgIDEgLyBtYXRoLmNvc2goMC41KTsgICAvLyByZXR1cm5zIDAuODg2ODE4ODgzOTcwMDc0XHJcbiAgICpcclxuICAgKiBTZWUgYWxzbzpcclxuICAgKlxyXG4gICAqICAgIGNvc2gsIGNzY2gsIGNvdGhcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeH0geCAgRnVuY3Rpb24gaW5wdXRcclxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9IEh5cGVyYm9saWMgc2VjYW50IG9mIHhcclxuICAgKi9cclxuICB2YXIgc2VjaCA9IHR5cGVkKCdzZWNoJywge1xyXG4gICAgJ251bWJlcic6IF9zZWNoLFxyXG5cclxuICAgICdDb21wbGV4JzogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgcmV0dXJuIHguc2VjaCgpO1xyXG4gICAgfSxcclxuXHJcbiAgICAnQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgcmV0dXJuIG5ldyB0eXBlLkJpZ051bWJlcigxKS5kaXYoeC5jb3NoKCkpO1xyXG4gICAgfSxcclxuXHJcbiAgICAnVW5pdCc6IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgIGlmICgheC5oYXNCYXNlKHR5cGUuVW5pdC5CQVNFX1VOSVRTLkFOR0xFKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IgKCdVbml0IGluIGZ1bmN0aW9uIHNlY2ggaXMgbm8gYW5nbGUnKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gc2VjaCh4LnZhbHVlKTtcclxuICAgIH0sXHJcblxyXG4gICAgJ0FycmF5IHwgTWF0cml4JzogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgcmV0dXJuIGRlZXBNYXAoeCwgc2VjaCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIHNlY2gudG9UZXggPSAnXFxcXG1hdGhybXtzZWNofVxcXFxsZWZ0KCR7YXJnc1swXX1cXFxccmlnaHQpJztcclxuXHJcbiAgcmV0dXJuIHNlY2g7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGUgdGhlIGh5cGVyYm9saWMgc2VjYW50IG9mIGEgbnVtYmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBfc2VjaCh4KSB7XHJcbiAgcmV0dXJuIDIgLyAoTWF0aC5leHAoeCkgKyBNYXRoLmV4cCgteCkpO1xyXG59XHJcblxyXG5leHBvcnRzLm5hbWUgPSAnc2VjaCc7XHJcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XHJcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZXBNYXAgPSByZXF1aXJlKCcuLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBNYXAnKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIHNpbmUgb2YgYSB2YWx1ZS5cbiAgICpcbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLnNpbih4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5zaW4oMik7ICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIDAuOTA5Mjk3NDI2ODI1NjgxM1xuICAgKiAgICBtYXRoLnNpbihtYXRoLnBpIC8gNCk7ICAgICAgICAgICAgLy8gcmV0dXJucyBudW1iZXIgMC43MDcxMDY3ODExODY1NDc1XG4gICAqICAgIG1hdGguc2luKG1hdGgudW5pdCg5MCwgJ2RlZycpKTsgICAvLyByZXR1cm5zIG51bWJlciAxXG4gICAqICAgIG1hdGguc2luKG1hdGgudW5pdCgzMCwgJ2RlZycpKTsgICAvLyByZXR1cm5zIG51bWJlciAwLjVcbiAgICpcbiAgICogICAgdmFyIGFuZ2xlID0gMC4yO1xuICAgKiAgICBtYXRoLnBvdyhtYXRoLnNpbihhbmdsZSksIDIpICsgbWF0aC5wb3cobWF0aC5jb3MoYW5nbGUpLCAyKTsgLy8gcmV0dXJucyBudW1iZXIgfjFcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGNvcywgdGFuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeH0geCAgRnVuY3Rpb24gaW5wdXRcbiAgICogQHJldHVybiB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSBTaW5lIG9mIHhcbiAgICovXG4gIHZhciBzaW4gPSB0eXBlZCgnc2luJywge1xuICAgICdudW1iZXInOiBNYXRoLnNpbixcblxuICAgICdDb21wbGV4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LnNpbigpO1xuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LnNpbigpO1xuICAgIH0sXG5cbiAgICAnVW5pdCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAoIXguaGFzQmFzZSh0eXBlLlVuaXQuQkFTRV9VTklUUy5BTkdMRSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvciAoJ1VuaXQgaW4gZnVuY3Rpb24gc2luIGlzIG5vIGFuZ2xlJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2luKHgudmFsdWUpO1xuICAgIH0sXG5cbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgLy8gZGVlcCBtYXAgY29sbGVjdGlvbiwgc2tpcCB6ZXJvcyBzaW5jZSBzaW4oMCkgPSAwXG4gICAgICByZXR1cm4gZGVlcE1hcCh4LCBzaW4sIHRydWUpO1xuICAgIH1cbiAgfSk7XG5cbiAgc2luLnRvVGV4ID0gJ1xcXFxzaW5cXFxcbGVmdCgke2FyZ3NbMF19XFxcXHJpZ2h0KSc7XG5cbiAgcmV0dXJuIHNpbjtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ3Npbic7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGRlZXBNYXAgPSByZXF1aXJlKCcuLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBNYXAnKTtcclxuXHJcbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcclxuICAvKipcclxuICAgKiBDYWxjdWxhdGUgdGhlIGh5cGVyYm9saWMgc2luZSBvZiBhIHZhbHVlLFxyXG4gICAqIGRlZmluZWQgYXMgYHNpbmgoeCkgPSAxLzIgKiAoZXhwKHgpIC0gZXhwKC14KSlgLlxyXG4gICAqXHJcbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cclxuICAgKlxyXG4gICAqIFN5bnRheDpcclxuICAgKlxyXG4gICAqICAgIG1hdGguc2luaCh4KVxyXG4gICAqXHJcbiAgICogRXhhbXBsZXM6XHJcbiAgICpcclxuICAgKiAgICBtYXRoLnNpbmgoMC41KTsgICAgICAgLy8gcmV0dXJucyBudW1iZXIgMC41MjEwOTUzMDU0OTM3NDc0XHJcbiAgICpcclxuICAgKiBTZWUgYWxzbzpcclxuICAgKlxyXG4gICAqICAgIGNvc2gsIHRhbmhcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeH0geCAgRnVuY3Rpb24gaW5wdXRcclxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9IEh5cGVyYm9saWMgc2luZSBvZiB4XHJcbiAgICovXHJcbiAgdmFyIHNpbmggPSB0eXBlZCgnc2luaCcsIHtcclxuICAgICdudW1iZXInOiBfc2luaCxcclxuXHJcbiAgICAnQ29tcGxleCc6IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgIHJldHVybiB4LnNpbmgoKTtcclxuICAgIH0sXHJcblxyXG4gICAgJ0JpZ051bWJlcic6IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgIHJldHVybiB4LnNpbmgoKTtcclxuICAgIH0sXHJcblxyXG4gICAgJ1VuaXQnOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICBpZiAoIXguaGFzQmFzZSh0eXBlLlVuaXQuQkFTRV9VTklUUy5BTkdMRSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yICgnVW5pdCBpbiBmdW5jdGlvbiBzaW5oIGlzIG5vIGFuZ2xlJyk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHNpbmgoeC52YWx1ZSk7XHJcbiAgICB9LFxyXG5cclxuICAgICdBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgIC8vIGRlZXAgbWFwIGNvbGxlY3Rpb24sIHNraXAgemVyb3Mgc2luY2Ugc2luaCgwKSA9IDBcclxuICAgICAgcmV0dXJuIGRlZXBNYXAoeCwgc2luaCwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIHNpbmgudG9UZXggPSAnXFxcXHNpbmhcXFxcbGVmdCgke2FyZ3NbMF19XFxcXHJpZ2h0KSc7XHJcblxyXG4gIHJldHVybiBzaW5oO1xyXG59XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlIHRoZSBoeXBlcmJvbGljIHNpbmUgb2YgYSBudW1iZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHhcclxuICogQHJldHVybnMge251bWJlcn1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIF9zaW5oICh4KSB7XHJcbiAgaWYgKE1hdGguYWJzKHgpIDwgMSkge1xyXG4gICAgcmV0dXJuIHggKyAoeCAqIHggKiB4KSAvIDYgKyAoeCAqIHggKiB4ICogeCAqIHgpIC8gMTIwO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gKE1hdGguZXhwKHgpIC0gTWF0aC5leHAoLXgpKSAvIDI7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLm5hbWUgPSAnc2luaCc7XHJcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XHJcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZXBNYXAgPSByZXF1aXJlKCcuLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBNYXAnKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSB0YW5nZW50IG9mIGEgdmFsdWUuIGB0YW4oeClgIGlzIGVxdWFsIHRvIGBzaW4oeCkgLyBjb3MoeClgLlxuICAgKlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGgudGFuKHgpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLnRhbigwLjUpOyAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBudW1iZXIgMC41NDYzMDI0ODk4NDM3OTA1XG4gICAqICAgIG1hdGguc2luKDAuNSkgLyBtYXRoLmNvcygwLjUpOyAgICAvLyByZXR1cm5zIG51bWJlciAwLjU0NjMwMjQ4OTg0Mzc5MDVcbiAgICogICAgbWF0aC50YW4obWF0aC5waSAvIDQpOyAgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIDFcbiAgICogICAgbWF0aC50YW4obWF0aC51bml0KDQ1LCAnZGVnJykpOyAgIC8vIHJldHVybnMgbnVtYmVyIDFcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGF0YW4sIHNpbiwgY29zXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeH0geCAgRnVuY3Rpb24gaW5wdXRcbiAgICogQHJldHVybiB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSBUYW5nZW50IG9mIHhcbiAgICovXG4gIHZhciB0YW4gPSB0eXBlZCgndGFuJywge1xuICAgICdudW1iZXInOiBNYXRoLnRhbixcblxuICAgICdDb21wbGV4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHgudGFuKCk7XG4gICAgfSxcblxuICAgICdCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHgudGFuKCk7XG4gICAgfSxcblxuICAgICdVbml0JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICgheC5oYXNCYXNlKHR5cGUuVW5pdC5CQVNFX1VOSVRTLkFOR0xFKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yICgnVW5pdCBpbiBmdW5jdGlvbiB0YW4gaXMgbm8gYW5nbGUnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YW4oeC52YWx1ZSk7XG4gICAgfSxcblxuICAgICdBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAvLyBkZWVwIG1hcCBjb2xsZWN0aW9uLCBza2lwIHplcm9zIHNpbmNlIHRhbigwKSA9IDBcbiAgICAgIHJldHVybiBkZWVwTWFwKHgsIHRhbiwgdHJ1ZSk7XG4gICAgfVxuICB9KTtcblxuICB0YW4udG9UZXggPSAnXFxcXHRhblxcXFxsZWZ0KCR7YXJnc1swXX1cXFxccmlnaHQpJztcblxuICByZXR1cm4gdGFuO1xufVxuXG5leHBvcnRzLm5hbWUgPSAndGFuJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgZGVlcE1hcCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vZGVlcE1hcCcpO1xyXG5cclxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZSB0aGUgaHlwZXJib2xpYyB0YW5nZW50IG9mIGEgdmFsdWUsXHJcbiAgICogZGVmaW5lZCBhcyBgdGFuaCh4KSA9IChleHAoMiAqIHgpIC0gMSkgLyAoZXhwKDIgKiB4KSArIDEpYC5cclxuICAgKlxyXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXHJcbiAgICpcclxuICAgKiBTeW50YXg6XHJcbiAgICpcclxuICAgKiAgICBtYXRoLnRhbmgoeClcclxuICAgKlxyXG4gICAqIEV4YW1wbGVzOlxyXG4gICAqXHJcbiAgICogICAgLy8gdGFuaCh4KSA9IHNpbmgoeCkgLyBjb3NoKHgpID0gMSAvIGNvdGgoeClcclxuICAgKiAgICBtYXRoLnRhbmgoMC41KTsgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyAwLjQ2MjExNzE1NzI2MDAwOTc0XHJcbiAgICogICAgbWF0aC5zaW5oKDAuNSkgLyBtYXRoLmNvc2goMC41KTsgIC8vIHJldHVybnMgMC40NjIxMTcxNTcyNjAwMDk3NFxyXG4gICAqICAgIDEgLyBtYXRoLmNvdGgoMC41KTsgICAgICAgICAgICAgICAvLyByZXR1cm5zIDAuNDYyMTE3MTU3MjYwMDA5NzRcclxuICAgKlxyXG4gICAqIFNlZSBhbHNvOlxyXG4gICAqXHJcbiAgICogICAgc2luaCwgY29zaCwgY290aFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBDb21wbGV4IHwgVW5pdCB8IEFycmF5IHwgTWF0cml4fSB4ICBGdW5jdGlvbiBpbnB1dFxyXG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0gSHlwZXJib2xpYyB0YW5nZW50IG9mIHhcclxuICAgKi9cclxuICB2YXIgdGFuaCA9IHR5cGVkKCd0YW5oJywge1xyXG4gICAgJ251bWJlcic6IF90YW5oLFxyXG5cclxuICAgICdDb21wbGV4JzogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICByZXR1cm4geC50YW5oKCk7XHJcbiAgICB9LFxyXG5cclxuICAgICdCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICByZXR1cm4geC50YW5oKCk7XHJcbiAgICB9LFxyXG5cclxuICAgICdVbml0JzogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgaWYgKCF4Lmhhc0Jhc2UodHlwZS5Vbml0LkJBU0VfVU5JVFMuQU5HTEUpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvciAoJ1VuaXQgaW4gZnVuY3Rpb24gdGFuaCBpcyBubyBhbmdsZScpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0YW5oKHgudmFsdWUpO1xyXG4gICAgfSxcclxuXHJcbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAvLyBkZWVwIG1hcCBjb2xsZWN0aW9uLCBza2lwIHplcm9zIHNpbmNlIHRhbmgoMCkgPSAwXHJcbiAgICAgIHJldHVybiBkZWVwTWFwKHgsIHRhbmgsIHRydWUpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICB0YW5oLnRvVGV4ID0gJ1xcXFx0YW5oXFxcXGxlZnQoJHthcmdzWzBdfVxcXFxyaWdodCknO1xyXG5cclxuICByZXR1cm4gdGFuaDtcclxufVxyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZSB0aGUgaHlwZXJib2xpYyB0YW5nZW50IG9mIGEgbnVtYmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBfdGFuaCAoeCkge1xyXG4gIHZhciBlID0gTWF0aC5leHAoMiAqIHgpO1xyXG4gIHJldHVybiAoZSAtIDEpIC8gKGUgKyAxKTtcclxufVxyXG5cclxuZXhwb3J0cy5uYW1lID0gJ3RhbmgnO1xyXG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IFtcbiAgcmVxdWlyZSgnLi90bycpXG5dOyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgbGF0ZXggPSByZXF1aXJlKCcuLi8uLi91dGlscy9sYXRleCcpO1xuXG4gIHZhciBtYXRyaXggPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L2Z1bmN0aW9uL21hdHJpeCcpKTtcblxuICB2YXIgYWxnb3JpdGhtMTMgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTEzJykpO1xuICB2YXIgYWxnb3JpdGhtMTQgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTE0JykpO1xuXG4gIC8qKlxuICAgKiBDaGFuZ2UgdGhlIHVuaXQgb2YgYSB2YWx1ZS5cbiAgICpcbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLnRvKHgsIHVuaXQpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLnRvKG1hdGgudW5pdCgnMiBpbmNoJyksICdjbScpOyAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIFVuaXQgNS4wOCBjbVxuICAgKiAgICBtYXRoLnRvKG1hdGgudW5pdCgnMiBpbmNoJyksIG1hdGgudW5pdChudWxsLCAnY20nKSk7ICAvLyByZXR1cm5zIFVuaXQgNS4wOCBjbVxuICAgKiAgICBtYXRoLnRvKG1hdGgudW5pdCgxNiwgJ2J5dGVzJyksICdiaXRzJyk7ICAgICAgICAgICAgICAvLyByZXR1cm5zIFVuaXQgMTI4IGJpdHNcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIHVuaXRcbiAgICpcbiAgICogQHBhcmFtIHtVbml0IHwgQXJyYXkgfCBNYXRyaXh9IHggICAgIFRoZSB1bml0IHRvIGJlIGNvbnZlcnRlZC5cbiAgICogQHBhcmFtIHtVbml0IHwgQXJyYXkgfCBNYXRyaXh9IHVuaXQgIE5ldyB1bml0LiBDYW4gYmUgYSBzdHJpbmcgbGlrZSBcImNtXCJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGEgdW5pdCB3aXRob3V0IHZhbHVlLlxuICAgKiBAcmV0dXJuIHtVbml0IHwgQXJyYXkgfCBNYXRyaXh9IHZhbHVlIHdpdGggY2hhbmdlZCwgZml4ZWQgdW5pdC5cbiAgICovXG4gIHZhciB0byA9IHR5cGVkKCd0bycsIHtcblxuICAgICdVbml0LCBVbml0IHwgc3RyaW5nJzogZnVuY3Rpb24gKHgsIHVuaXQpIHtcbiAgICAgIHJldHVybiB4LnRvKHVuaXQpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4LCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gU3BhcnNlTWF0cml4IGRvZXMgbm90IHN1cHBvcnQgVW5pdHNcbiAgICAgIHJldHVybiBhbGdvcml0aG0xMyh4LCB5LCB0byk7XG4gICAgfSxcblxuICAgICdBcnJheSwgQXJyYXknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIHRvKG1hdHJpeCh4KSwgbWF0cml4KHkpKS52YWx1ZU9mKCk7XG4gICAgfSxcblxuICAgICdBcnJheSwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiB0byhtYXRyaXgoeCksIHkpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4LCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gdG8oeCwgbWF0cml4KHkpKTtcbiAgICB9LFxuXG4gICAgJ01hdHJpeCwgYW55JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIFNwYXJzZU1hdHJpeCBkb2VzIG5vdCBzdXBwb3J0IFVuaXRzXG4gICAgICByZXR1cm4gYWxnb3JpdGhtMTQoeCwgeSwgdG8sIGZhbHNlKTtcbiAgICB9LFxuXG4gICAgJ2FueSwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIFNwYXJzZU1hdHJpeCBkb2VzIG5vdCBzdXBwb3J0IFVuaXRzXG4gICAgICByZXR1cm4gYWxnb3JpdGhtMTQoeSwgeCwgdG8sIHRydWUpO1xuICAgIH0sXG5cbiAgICAnQXJyYXksIGFueSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gYWxnb3JpdGhtMTQobWF0cml4KHgpLCB5LCB0bywgZmFsc2UpLnZhbHVlT2YoKTtcbiAgICB9LFxuXG4gICAgJ2FueSwgQXJyYXknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGFsZ29yaXRobTE0KG1hdHJpeCh5KSwgeCwgdG8sIHRydWUpLnZhbHVlT2YoKTtcbiAgICB9XG4gIH0pO1xuXG4gIHRvLnRvVGV4ID0gJ1xcXFxsZWZ0KCR7YXJnc1swXX0nICsgbGF0ZXgub3BlcmF0b3JzWyd0byddICsgJyR7YXJnc1sxXX1cXFxccmlnaHQpJztcblxuICByZXR1cm4gdG87XG59XG5cbmV4cG9ydHMubmFtZSA9ICd0byc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgb2JqZWN0PSByZXF1aXJlKCcuLi8uLi91dGlscy9vYmplY3QnKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICAvKipcbiAgICogQ2xvbmUgYW4gb2JqZWN0LlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgICBtYXRoLmNsb25lKHgpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmNsb25lKDMuNSk7ICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIDMuNVxuICAgKiAgICBtYXRoLmNsb25lKG1hdGguY29tcGxleCgnMi00aScpOyAvLyByZXR1cm5zIENvbXBsZXggMiAtIDRpXG4gICAqICAgIG1hdGguY2xvbmUobWF0aC51bml0KDQ1LCAnZGVnJykpOyAgLy8gcmV0dXJucyBVbml0IDQ1IGRlZ1xuICAgKiAgICBtYXRoLmNsb25lKFtbMSwgMl0sIFszLCA0XV0pOyAgICAgIC8vIHJldHVybnMgQXJyYXkgW1sxLCAyXSwgWzMsIDRdXVxuICAgKiAgICBtYXRoLmNsb25lKFwiaGVsbG8gd29ybGRcIik7ICAgICAgICAgLy8gcmV0dXJucyBzdHJpbmcgXCJoZWxsbyB3b3JsZFwiXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0geCAgIE9iamVjdCB0byBiZSBjbG9uZWRcbiAgICogQHJldHVybiB7Kn0gQSBjbG9uZSBvZiBvYmplY3QgeFxuICAgKi9cbiAgdmFyIGNsb25lID0gdHlwZWQoJ2Nsb25lJywge1xuICAgICdhbnknOiBvYmplY3QuY2xvbmVcbiAgfSk7XG5cbiAgY2xvbmUudG9UZXggPSAnXFxcXG1hdGhybXske25hbWV9fVxcXFxsZWZ0KCR7YXJnc31cXFxccmlnaHQpJztcblxuICByZXR1cm4gY2xvbmU7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdjbG9uZSc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBbXG4gIHJlcXVpcmUoJy4vY2xvbmUnKSxcbiAgcmVxdWlyZSgnLi9pc0ludGVnZXInKSxcbiAgcmVxdWlyZSgnLi9pc05lZ2F0aXZlJyksXG4gIHJlcXVpcmUoJy4vaXNOdW1lcmljJyksXG4gIHJlcXVpcmUoJy4vaXNQb3NpdGl2ZScpLFxuICByZXF1aXJlKCcuL2lzWmVybycpLFxuICByZXF1aXJlKCcuL3R5cGVvZicpXG5dO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVlcE1hcCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vZGVlcE1hcCcpO1xudmFyIG51bWJlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL251bWJlcicpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIC8qKlxuICAgKiBUZXN0IHdoZXRoZXIgYSB2YWx1ZSBpcyBhbiBpbnRlZ2VyIG51bWJlci5cbiAgICogVGhlIGZ1bmN0aW9uIHN1cHBvcnRzIGBudW1iZXJgLCBgQmlnTnVtYmVyYCwgYW5kIGBGcmFjdGlvbmAuXG4gICAqXG4gICAqIFRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudC13aXNlIGluIGNhc2Ugb2YgQXJyYXkgb3IgTWF0cml4IGlucHV0LlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgICBtYXRoLmlzSW50ZWdlcih4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5pc0ludGVnZXIoMik7ICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyB0cnVlXG4gICAqICAgIG1hdGguaXNJbnRlZ2VyKDApOyAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgdHJ1ZVxuICAgKiAgICBtYXRoLmlzSW50ZWdlcigwLjUpOyAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIGZhbHNlXG4gICAqICAgIG1hdGguaXNJbnRlZ2VyKG1hdGguYmlnbnVtYmVyKDUwMCkpOyAgIC8vIHJldHVybnMgdHJ1ZVxuICAgKiAgICBtYXRoLmlzSW50ZWdlcihtYXRoLmZyYWN0aW9uKDQpKTsgICAgICAvLyByZXR1cm5zIHRydWVcbiAgICogICAgbWF0aC5pc0ludGVnZXIoJzMnKTsgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyB0cnVlXG4gICAqICAgIG1hdGguaXNJbnRlZ2VyKFszLCAwLjUsIC0yXSk7ICAgICAgICAgIC8vIHJldHVybnMgW3RydWUsIGZhbHNlLCB0cnVlXVxuICAgKiAgICBtYXRoLmlzSW50ZWdlcihtYXRoLmNvbXBsZXgoJzItNGknKTsgICAvLyB0aHJvd3MgYW4gZXJyb3JcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGlzTnVtZXJpYywgaXNQb3NpdGl2ZSwgaXNOZWdhdGl2ZSwgaXNaZXJvXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb24gfCBBcnJheSB8IE1hdHJpeH0geCAgIFZhbHVlIHRvIGJlIHRlc3RlZFxuICAgKiBAcmV0dXJuIHtib29sZWFufSAgUmV0dXJucyB0cnVlIHdoZW4gYHhgIGNvbnRhaW5zIGEgbnVtZXJpYywgaW50ZWdlciB2YWx1ZS5cbiAgICogICAgICAgICAgICAgICAgICAgIFRocm93cyBhbiBlcnJvciBpbiBjYXNlIG9mIGFuIHVua25vd24gZGF0YSB0eXBlLlxuICAgKi9cbiAgdmFyIGlzSW50ZWdlciA9IHR5cGVkKCdpc0ludGVnZXInLCB7XG4gICAgJ251bWJlcic6IG51bWJlci5pc0ludGVnZXIsIC8vIFRPRE86IHdoYXQgdG8gZG8gd2l0aCBpc0ludGVnZXIoYWRkKDAuMSwgMC4yKSkgID9cblxuICAgICdCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHguaXNJbnQoKTtcbiAgICB9LFxuXG4gICAgJ0ZyYWN0aW9uJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LmQgPT09IDEgJiYgaXNGaW5pdGUoeC5uKTtcbiAgICB9LFxuXG4gICAgJ0FycmF5IHwgTWF0cml4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBkZWVwTWFwKHgsIGlzSW50ZWdlcik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gaXNJbnRlZ2VyO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnaXNJbnRlZ2VyJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWVwTWFwID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9kZWVwTWFwJyk7XG52YXIgbnVtYmVyID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbnVtYmVyJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgLyoqXG4gICAqIFRlc3Qgd2hldGhlciBhIHZhbHVlIGlzIG5lZ2F0aXZlOiBzbWFsbGVyIHRoYW4gemVyby5cbiAgICogVGhlIGZ1bmN0aW9uIHN1cHBvcnRzIHR5cGVzIGBudW1iZXJgLCBgQmlnTnVtYmVyYCwgYEZyYWN0aW9uYCwgYW5kIGBVbml0YC5cbiAgICpcbiAgICogVGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50LXdpc2UgaW4gY2FzZSBvZiBBcnJheSBvciBNYXRyaXggaW5wdXQuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgIG1hdGguaXNOZWdhdGl2ZSh4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5pc05lZ2F0aXZlKDMpOyAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgZmFsc2VcbiAgICogICAgbWF0aC5pc05lZ2F0aXZlKC0yKTsgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgdHJ1ZVxuICAgKiAgICBtYXRoLmlzTmVnYXRpdmUoMCk7ICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBmYWxzZVxuICAgKiAgICBtYXRoLmlzTmVnYXRpdmUoLTApOyAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBmYWxzZVxuICAgKiAgICBtYXRoLmlzTmVnYXRpdmUobWF0aC5iaWdudW1iZXIoMikpOyAgICAgLy8gcmV0dXJucyBmYWxzZVxuICAgKiAgICBtYXRoLmlzTmVnYXRpdmUobWF0aC5mcmFjdGlvbigtMiwgNSkpOyAgLy8gcmV0dXJucyB0cnVlXG4gICAqICAgIG1hdGguaXNOZWdhdGl2ZSgnLTInKTsgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIHRydWVcbiAgICogICAgbWF0aC5pc05lZ2F0aXZlKFsyLCAwLCAtM10nKTsgICAgICAgICAgIC8vIHJldHVybnMgW2ZhbHNlLCBmYWxzZSwgdHJ1ZV1cbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGlzTnVtZXJpYywgaXNQb3NpdGl2ZSwgaXNaZXJvLCBpc0ludGVnZXJcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeH0geCAgVmFsdWUgdG8gYmUgdGVzdGVkXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59ICBSZXR1cm5zIHRydWUgd2hlbiBgeGAgaXMgbGFyZ2VyIHRoYW4gemVyby5cbiAgICogICAgICAgICAgICAgICAgICAgIFRocm93cyBhbiBlcnJvciBpbiBjYXNlIG9mIGFuIHVua25vd24gZGF0YSB0eXBlLlxuICAgKi9cbiAgdmFyIGlzTmVnYXRpdmUgPSB0eXBlZCgnaXNOZWdhdGl2ZScsIHtcbiAgICAnbnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4IDwgMDtcbiAgICB9LFxuXG4gICAgJ0JpZ051bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5pc05lZygpICYmICF4LmlzWmVybygpICYmICF4LmlzTmFOKCk7XG4gICAgfSxcblxuICAgICdGcmFjdGlvbic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5zIDwgMDsgLy8gSXQncyBlbm91Z2ggdG8gZGVjaWRlIG9uIHRoZSBzaWduXG4gICAgfSxcblxuICAgICdVbml0JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBpc05lZ2F0aXZlKHgudmFsdWUpO1xuICAgIH0sXG5cbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIGRlZXBNYXAoeCwgaXNOZWdhdGl2ZSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gaXNOZWdhdGl2ZTtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2lzTmVnYXRpdmUnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZXBNYXAgPSByZXF1aXJlKCcuLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBNYXAnKTtcbnZhciBudW1iZXIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9udW1iZXInKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICAvKipcbiAgICogVGVzdCB3aGV0aGVyIGEgdmFsdWUgaXMgYW4gbnVtZXJpYyB2YWx1ZS5cbiAgICpcbiAgICogVGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50LXdpc2UgaW4gY2FzZSBvZiBBcnJheSBvciBNYXRyaXggaW5wdXQuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgIG1hdGguaXNOdW1lcmljKHgpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmlzTnVtZXJpYygyKTsgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIHRydWVcbiAgICogICAgbWF0aC5pc051bWVyaWMoMCk7ICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyB0cnVlXG4gICAqICAgIG1hdGguaXNOdW1lcmljKG1hdGguYmlnbnVtYmVyKDUwMCkpOyAgIC8vIHJldHVybnMgdHJ1ZVxuICAgKiAgICBtYXRoLmlzTnVtZXJpYyhtYXRoLmZyYWN0aW9uKDQpKTsgICAgICAvLyByZXR1cm5zIHRydWVcbiAgICogICAgbWF0aC5pc051bWVyaWMobWF0aC5jb21wbGV4KCcyLTRpJyk7ICAgLy8gcmV0dXJucyBmYWxzZVxuICAgKiAgICBtYXRoLmlzTnVtZXJpYygnMycpOyAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIGZhbHNlXG4gICAqICAgIG1hdGguaXNOdW1lcmljKFsyLjMsICdmb28nLCBmYWxzZV0pOyAgIC8vIHJldHVybnMgW3RydWUsIGZhbHNlLCB0cnVlXVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgaXNaZXJvLCBpc1Bvc2l0aXZlLCBpc05lZ2F0aXZlLCBpc0ludGVnZXJcbiAgICpcbiAgICogQHBhcmFtIHsqfSB4ICAgICAgIFZhbHVlIHRvIGJlIHRlc3RlZFxuICAgKiBAcmV0dXJuIHtib29sZWFufSAgUmV0dXJucyB0cnVlIHdoZW4gYHhgIGlzIGEgYG51bWJlcmAsIGBCaWdOdW1iZXJgLFxuICAgKiAgICAgICAgICAgICAgICAgICAgYEZyYWN0aW9uYCwgb3IgYGJvb2xlYW5gLiBSZXR1cm5zIGZhbHNlIGZvciBvdGhlciB0eXBlcy5cbiAgICogICAgICAgICAgICAgICAgICAgIFRocm93cyBhbiBlcnJvciBpbiBjYXNlIG9mIHVua25vd24gdHlwZXMuXG4gICAqL1xuICB2YXIgaXNOdW1lcmljID0gdHlwZWQoJ2lzTnVtZXJpYycsIHtcbiAgICAnbnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb24gfCBib29sZWFuJzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgICdDb21wbGV4IHwgVW5pdCB8IHN0cmluZyc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgJ0FycmF5IHwgTWF0cml4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBkZWVwTWFwKHgsIGlzTnVtZXJpYyk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gaXNOdW1lcmljO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnaXNOdW1lcmljJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWVwTWFwID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9kZWVwTWFwJyk7XG52YXIgbnVtYmVyID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbnVtYmVyJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgLyoqXG4gICAqIFRlc3Qgd2hldGhlciBhIHZhbHVlIGlzIHBvc2l0aXZlOiBsYXJnZXIgdGhhbiB6ZXJvLlxuICAgKiBUaGUgZnVuY3Rpb24gc3VwcG9ydHMgdHlwZXMgYG51bWJlcmAsIGBCaWdOdW1iZXJgLCBgRnJhY3Rpb25gLCBhbmQgYFVuaXRgLlxuICAgKlxuICAgKiBUaGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQtd2lzZSBpbiBjYXNlIG9mIEFycmF5IG9yIE1hdHJpeCBpbnB1dC5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICAgbWF0aC5pc1Bvc2l0aXZlKHgpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmlzUG9zaXRpdmUoMyk7ICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyB0cnVlXG4gICAqICAgIG1hdGguaXNQb3NpdGl2ZSgtMik7ICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIGZhbHNlXG4gICAqICAgIG1hdGguaXNQb3NpdGl2ZSgwKTsgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIGZhbHNlXG4gICAqICAgIG1hdGguaXNQb3NpdGl2ZSgtMCk7ICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIGZhbHNlXG4gICAqICAgIG1hdGguaXNQb3NpdGl2ZSgwLjUpOyAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIHRydWVcbiAgICogICAgbWF0aC5pc1Bvc2l0aXZlKG1hdGguYmlnbnVtYmVyKDIpKTsgICAgIC8vIHJldHVybnMgdHJ1ZVxuICAgKiAgICBtYXRoLmlzUG9zaXRpdmUobWF0aC5mcmFjdGlvbigtMiwgNSkpOyAgLy8gcmV0dXJucyBmYWxzZVxuICAgKiAgICBtYXRoLmlzUG9zaXRpdmUobWF0aC5mcmFjdGlvbigxLDMpKTsgICAgLy8gcmV0dXJucyBmYWxzZVxuICAgKiAgICBtYXRoLmlzUG9zaXRpdmUoJzInKTsgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyB0cnVlXG4gICAqICAgIG1hdGguaXNQb3NpdGl2ZShbMiwgMCwgLTNdJyk7ICAgICAgICAgICAvLyByZXR1cm5zIFt0cnVlLCBmYWxzZSwgZmFsc2VdXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBpc051bWVyaWMsIGlzWmVybywgaXNOZWdhdGl2ZSwgaXNJbnRlZ2VyXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb24gfCBVbml0IHwgQXJyYXkgfCBNYXRyaXh9IHggIFZhbHVlIHRvIGJlIHRlc3RlZFxuICAgKiBAcmV0dXJuIHtib29sZWFufSAgUmV0dXJucyB0cnVlIHdoZW4gYHhgIGlzIGxhcmdlciB0aGFuIHplcm8uXG4gICAqICAgICAgICAgICAgICAgICAgICBUaHJvd3MgYW4gZXJyb3IgaW4gY2FzZSBvZiBhbiB1bmtub3duIGRhdGEgdHlwZS5cbiAgICovXG4gIHZhciBpc1Bvc2l0aXZlID0gdHlwZWQoJ2lzUG9zaXRpdmUnLCB7XG4gICAgJ251bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geCA+IDA7XG4gICAgfSxcblxuICAgICdCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuICF4LmlzTmVnKCkgJiYgIXguaXNaZXJvKCkgJiYgIXguaXNOYU4oKTtcbiAgICB9LFxuXG4gICAgJ0ZyYWN0aW9uJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LnMgPiAwICYmIHgubiA+IDA7XG4gICAgfSxcblxuICAgICdVbml0JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBpc1Bvc2l0aXZlKHgudmFsdWUpO1xuICAgIH0sXG5cbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIGRlZXBNYXAoeCwgaXNQb3NpdGl2ZSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gaXNQb3NpdGl2ZTtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2lzUG9zaXRpdmUnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZXBNYXAgPSByZXF1aXJlKCcuLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBNYXAnKTtcbnZhciBudW1iZXIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9udW1iZXInKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICAvKipcbiAgICogVGVzdCB3aGV0aGVyIGEgdmFsdWUgaXMgemVyby5cbiAgICogVGhlIGZ1bmN0aW9uIGNhbiBjaGVjayBmb3IgemVybyBmb3IgdHlwZXMgYG51bWJlcmAsIGBCaWdOdW1iZXJgLCBgRnJhY3Rpb25gLFxuICAgKiBgQ29tcGxleGAsIGFuZCBgVW5pdGAuXG4gICAqXG4gICAqIFRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudC13aXNlIGluIGNhc2Ugb2YgQXJyYXkgb3IgTWF0cml4IGlucHV0LlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgICBtYXRoLmlzWmVybyh4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5pc1plcm8oMCk7ICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyB0cnVlXG4gICAqICAgIG1hdGguaXNaZXJvKDIpOyAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgZmFsc2VcbiAgICogICAgbWF0aC5pc1plcm8oMC41KTsgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBmYWxzZVxuICAgKiAgICBtYXRoLmlzWmVybyhtYXRoLmJpZ251bWJlcigwKSk7ICAgICAvLyByZXR1cm5zIHRydWVcbiAgICogICAgbWF0aC5pc1plcm8obWF0aC5mcmFjdGlvbigwKSk7ICAgICAgLy8gcmV0dXJucyB0cnVlXG4gICAqICAgIG1hdGguaXNaZXJvKG1hdGguZnJhY3Rpb24oMSwzKSk7ICAgIC8vIHJldHVybnMgZmFsc2VcbiAgICogICAgbWF0aC5pc1plcm8obWF0aC5jb21wbGV4KCcyIC0gNGknKTsgLy8gcmV0dXJucyBmYWxzZVxuICAgKiAgICBtYXRoLmlzWmVybyhtYXRoLmNvbXBsZXgoJzBpJyk7ICAgICAvLyByZXR1cm5zIHRydWVcbiAgICogICAgbWF0aC5pc1plcm8oJzAnKTsgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyB0cnVlXG4gICAqICAgIG1hdGguaXNaZXJvKCcyJyk7ICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgZmFsc2VcbiAgICogICAgbWF0aC5pc1plcm8oWzIsIDAsIC0zXScpOyAgICAgICAgICAgLy8gcmV0dXJucyBbZmFsc2UsIHRydWUsIGZhbHNlXVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgaXNOdW1lcmljLCBpc1Bvc2l0aXZlLCBpc05lZ2F0aXZlLCBpc0ludGVnZXJcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBDb21wbGV4IHwgRnJhY3Rpb24gfCBVbml0IHwgQXJyYXkgfCBNYXRyaXh9IHggICAgICAgVmFsdWUgdG8gYmUgdGVzdGVkXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59ICBSZXR1cm5zIHRydWUgd2hlbiBgeGAgaXMgemVyby5cbiAgICogICAgICAgICAgICAgICAgICAgIFRocm93cyBhbiBlcnJvciBpbiBjYXNlIG9mIGFuIHVua25vd24gZGF0YSB0eXBlLlxuICAgKi9cbiAgdmFyIGlzWmVybyA9IHR5cGVkKCdpc1plcm8nLCB7XG4gICAgJ251bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geCA9PT0gMDtcbiAgICB9LFxuXG4gICAgJ0JpZ051bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5pc1plcm8oKTtcbiAgICB9LFxuXG4gICAgJ0NvbXBsZXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHgucmUgPT09IDAgJiYgeC5pbSA9PT0gMDtcbiAgICB9LFxuXG4gICAgJ0ZyYWN0aW9uJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LmQgPT09IDEgJiYgeC5uID09PSAwO1xuICAgIH0sXG5cbiAgICAnVW5pdCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gaXNaZXJvKHgudmFsdWUpO1xuICAgIH0sXG5cbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIGRlZXBNYXAoeCwgaXNaZXJvKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBpc1plcm87XG59XG5cbmV4cG9ydHMubmFtZSA9ICdpc1plcm8nO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHR5cGVzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdHlwZXMnKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICAvKipcbiAgICogRGV0ZXJtaW5lIHRoZSB0eXBlIG9mIGEgdmFyaWFibGUuXG4gICAqXG4gICAqIEZ1bmN0aW9uIGB0eXBlb2ZgIHJlY29nbml6ZXMgdGhlIGZvbGxvd2luZyB0eXBlcyBvZiBvYmplY3RzOlxuICAgKlxuICAgKiBPYmplY3QgICAgICAgICAgICAgICAgIHwgUmV0dXJucyAgICAgICB8IEV4YW1wbGVcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8IC0tLS0tLS0tLS0tLS0gfCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogbnVsbCAgICAgICAgICAgICAgICAgICB8IGAnbnVsbCdgICAgICAgfCBgbWF0aC50eXBlb2YobnVsbClgXG4gICAqIG51bWJlciAgICAgICAgICAgICAgICAgfCBgJ251bWJlcidgICAgIHwgYG1hdGgudHlwZW9mKDMuNSlgXG4gICAqIGJvb2xlYW4gICAgICAgICAgICAgICAgfCBgJ2Jvb2xlYW4nYCAgIHwgYG1hdGgudHlwZW9mICh0cnVlKWBcbiAgICogc3RyaW5nICAgICAgICAgICAgICAgICB8IGAnc3RyaW5nJ2AgICAgfCBgbWF0aC50eXBlb2YgKCdoZWxsbyB3b3JsZCcpYFxuICAgKiBBcnJheSAgICAgICAgICAgICAgICAgIHwgYCdBcnJheSdgICAgICB8IGBtYXRoLnR5cGVvZiAoWzEsIDIsIDNdKWBcbiAgICogRGF0ZSAgICAgICAgICAgICAgICAgICB8IGAnRGF0ZSdgICAgICAgfCBgbWF0aC50eXBlb2YgKG5ldyBEYXRlKCkpYFxuICAgKiBGdW5jdGlvbiAgICAgICAgICAgICAgIHwgYCdGdW5jdGlvbidgICB8IGBtYXRoLnR5cGVvZiAoZnVuY3Rpb24gKCkge30pYFxuICAgKiBPYmplY3QgICAgICAgICAgICAgICAgIHwgYCdPYmplY3QnYCAgICB8IGBtYXRoLnR5cGVvZiAoe2E6IDIsIGI6IDN9KWBcbiAgICogUmVnRXhwICAgICAgICAgICAgICAgICB8IGAnUmVnRXhwJ2AgICAgfCBgbWF0aC50eXBlb2YgKC9hIHJlZ2V4cC8pYFxuICAgKiB1bmRlZmluZWQgICAgICAgICAgICAgIHwgYCd1bmRlZmluZWQnYCB8IGBtYXRoLnR5cGVvZih1bmRlZmluZWQpYFxuICAgKiBtYXRoLnR5cGUuQmlnTnVtYmVyICAgIHwgYCdCaWdOdW1iZXInYCB8IGBtYXRoLnR5cGVvZiAobWF0aC5iaWdudW1iZXIoJzIuM2U1MDAnKSlgXG4gICAqIG1hdGgudHlwZS5DaGFpbiAgICAgICAgfCBgJ0NoYWluJ2AgICAgIHwgYG1hdGgudHlwZW9mIChtYXRoLmNoYWluKDIpKWBcbiAgICogbWF0aC50eXBlLkNvbXBsZXggICAgICB8IGAnQ29tcGxleCdgICAgfCBgbWF0aC50eXBlb2YgKG1hdGguY29tcGxleCgyLCAzKSlgXG4gICAqIG1hdGgudHlwZS5GcmFjdGlvbiAgICAgfCBgJ0ZyYWN0aW9uJ2AgIHwgYG1hdGgudHlwZW9mIChtYXRoLmZyYWN0aW9uKDEsIDMpKWBcbiAgICogbWF0aC50eXBlLkhlbHAgICAgICAgICB8IGAnSGVscCdgICAgICAgfCBgbWF0aC50eXBlb2YgKG1hdGguaGVscCgnc3FydCcpKWBcbiAgICogbWF0aC50eXBlLkluZGV4ICAgICAgICB8IGAnSW5kZXgnYCAgICAgfCBgbWF0aC50eXBlb2YgKG1hdGguaW5kZXgoMSwgMykpYFxuICAgKiBtYXRoLnR5cGUuTWF0cml4ICAgICAgIHwgYCdNYXRyaXgnYCAgICB8IGBtYXRoLnR5cGVvZiAobWF0aC5tYXRyaXgoW1sxLDJdLCBbMywgNF1dKSlgXG4gICAqIG1hdGgudHlwZS5SYW5nZSAgICAgICAgfCBgJ1JhbmdlJ2AgICAgIHwgYG1hdGgudHlwZW9mIChtYXRoLnJhbmdlKDAsIDEwKSlgXG4gICAqIG1hdGgudHlwZS5Vbml0ICAgICAgICAgfCBgJ1VuaXQnYCAgICAgIHwgYG1hdGgudHlwZW9mIChtYXRoLnVuaXQoJzQ1IGRlZycpKWBcbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLnR5cGVvZih4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC50eXBlb2YoMy41KTsgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zICdudW1iZXInXG4gICAqICAgIG1hdGgudHlwZW9mKG1hdGguY29tcGxleCgnMi00aScpKTsgICAgLy8gcmV0dXJucyAnQ29tcGxleCdcbiAgICogICAgbWF0aC50eXBlb2YobWF0aC51bml0KCc0NSBkZWcnKSk7ICAgICAvLyByZXR1cm5zICdVbml0J1xuICAgKiAgICBtYXRoLnR5cGVvZignaGVsbG8gd29ybGQnKTsgICAgICAgICAgIC8vIHJldHVybnMgJ3N0cmluZydcbiAgICpcbiAgICogQHBhcmFtIHsqfSB4ICAgICBUaGUgdmFyaWFibGUgZm9yIHdoaWNoIHRvIHRlc3QgdGhlIHR5cGUuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgdHlwZS4gUHJpbWl0aXZlIHR5cGVzIGFyZSBsb3dlciBjYXNlLFxuICAgKiAgICAgICAgICAgICAgICAgIG5vbi1wcmltaXRpdmUgdHlwZXMgYXJlIHVwcGVyLWNhbWVsLWNhc2UuXG4gICAqICAgICAgICAgICAgICAgICAgRm9yIGV4YW1wbGUgJ251bWJlcicsICdzdHJpbmcnLCAnQXJyYXknLCAnRGF0ZScuXG4gICAqL1xuICB2YXIgX3R5cGVvZiA9IHR5cGVkKCdfdHlwZW9mJywge1xuICAgICdhbnknOiBmdW5jdGlvbiAoeCkge1xuICAgICAgLy8gSmF2YVNjcmlwdCB0eXBlc1xuICAgICAgdmFyIHQgPSB0eXBlcy50eXBlKHgpO1xuXG4gICAgICAvLyBtYXRoLmpzIHR5cGVzXG4gICAgICBpZiAodCA9PT0gJ09iamVjdCcpIHtcbiAgICAgICAgaWYgKHguaXNCaWdOdW1iZXIgPT09IHRydWUpIHJldHVybiAnQmlnTnVtYmVyJztcbiAgICAgICAgaWYgKHguaXNDb21wbGV4ID09PSB0cnVlKSAgIHJldHVybiAnQ29tcGxleCc7XG4gICAgICAgIGlmICh4LmlzRnJhY3Rpb24gPT09IHRydWUpICByZXR1cm4gJ0ZyYWN0aW9uJztcbiAgICAgICAgaWYgKHguaXNNYXRyaXggPT09IHRydWUpICAgIHJldHVybiAnTWF0cml4JztcbiAgICAgICAgaWYgKHguaXNVbml0ID09PSB0cnVlKSAgICAgIHJldHVybiAnVW5pdCc7XG4gICAgICAgIGlmICh4LmlzSW5kZXggPT09IHRydWUpICAgICByZXR1cm4gJ0luZGV4JztcbiAgICAgICAgaWYgKHguaXNSYW5nZSA9PT0gdHJ1ZSkgICAgIHJldHVybiAnUmFuZ2UnO1xuICAgICAgICBpZiAoeC5pc0NoYWluID09PSB0cnVlKSAgICAgcmV0dXJuICdDaGFpbic7XG4gICAgICAgIGlmICh4LmlzSGVscCA9PT0gdHJ1ZSkgICAgICByZXR1cm4gJ0hlbHAnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdDtcbiAgICB9XG4gIH0pO1xuXG4gIF90eXBlb2YudG9UZXggPSAnXFxcXG1hdGhybXske25hbWV9fVxcXFxsZWZ0KCR7YXJnc31cXFxccmlnaHQpJztcblxuICByZXR1cm4gX3R5cGVvZjtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ3R5cGVvZic7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBbXG4gIHJlcXVpcmUoJy4vdHlwZScpLCAgICAgICAgLy8gZGF0YSB0eXBlcyAoTWF0cml4LCBDb21wbGV4LCBVbml0LCAuLi4pXG4gIHJlcXVpcmUoJy4vY29uc3RhbnRzJyksICAgLy8gY29uc3RhbnRzXG4gIHJlcXVpcmUoJy4vZXhwcmVzc2lvbicpLCAgLy8gZXhwcmVzc2lvbiBwYXJzaW5nXG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24nKSwgICAgLy8gZnVuY3Rpb25zXG4gIHJlcXVpcmUoJy4vanNvbicpLCAgICAgICAgLy8gc2VyaWFsaXphdGlvbiB1dGlsaXR5IChtYXRoLmpzb24ucmV2aXZlcilcbiAgcmVxdWlyZSgnLi9lcnJvcicpICAgICAgICAvLyBlcnJvcnNcbl07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFtcbiAgcmVxdWlyZSgnLi9yZXZpdmVyJylcbl07XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgLyoqXG4gICAqIEluc3RhbnRpYXRlIG1hdGhqcyBkYXRhIHR5cGVzIGZyb20gdGhlaXIgSlNPTiByZXByZXNlbnRhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJldml2ZWQgb2JqZWN0XG4gICAqL1xuICByZXR1cm4gZnVuY3Rpb24gcmV2aXZlcihrZXksIHZhbHVlKSB7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gdHlwZVt2YWx1ZSAmJiB2YWx1ZS5tYXRoanNdO1xuICAgIGlmIChjb25zdHJ1Y3RvciAmJiB0eXBlb2YgY29uc3RydWN0b3IuZnJvbUpTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBjb25zdHJ1Y3Rvci5mcm9tSlNPTih2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbmV4cG9ydHMubmFtZSA9ICdyZXZpdmVyJztcbmV4cG9ydHMucGF0aCA9ICdqc29uJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCJ2YXIgRGVjaW1hbCA9IHJlcXVpcmUoJ2RlY2ltYWwuanMnKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCwgbWF0aCkge1xuICB2YXIgQmlnTnVtYmVyID0gRGVjaW1hbC5jbG9uZSh7cHJlY2lzaW9uOiBjb25maWcucHJlY2lzaW9ufSk7XG5cbiAgLyoqXG4gICAqIEF0dGFjaCB0eXBlIGluZm9ybWF0aW9uXG4gICAqL1xuICBCaWdOdW1iZXIucHJvdG90eXBlLnR5cGUgPSAnQmlnTnVtYmVyJztcbiAgQmlnTnVtYmVyLnByb3RvdHlwZS5pc0JpZ051bWJlciA9IHRydWU7XG5cbiAgLyoqXG4gICAqIEdldCBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYSBCaWdOdW1iZXIgY29udGFpbmluZ1xuICAgKiB0eXBlIGluZm9ybWF0aW9uXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYSBKU09OIG9iamVjdCBzdHJ1Y3R1cmVkIGFzOlxuICAgKiAgICAgICAgICAgICAgICAgICBge1wibWF0aGpzXCI6IFwiQmlnTnVtYmVyXCIsIFwidmFsdWVcIjogXCIwLjJcIn1gXG4gICAqL1xuICBCaWdOdW1iZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWF0aGpzOiAnQmlnTnVtYmVyJyxcbiAgICAgIHZhbHVlOiB0aGlzLnRvU3RyaW5nKClcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbnN0YW50aWF0ZSBhIEJpZ051bWJlciBmcm9tIGEgSlNPTiBvYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IGpzb24gIGEgSlNPTiBvYmplY3Qgc3RydWN0dXJlZCBhczpcbiAgICogICAgICAgICAgICAgICAgICAgICAgIGB7XCJtYXRoanNcIjogXCJCaWdOdW1iZXJcIiwgXCJ2YWx1ZVwiOiBcIjAuMlwifWBcbiAgICogQHJldHVybiB7QmlnTnVtYmVyfVxuICAgKi9cbiAgQmlnTnVtYmVyLmZyb21KU09OID0gZnVuY3Rpb24gKGpzb24pIHtcbiAgICByZXR1cm4gbmV3IEJpZ051bWJlcihqc29uLnZhbHVlKTtcbiAgfTtcblxuICAvLyBsaXN0ZW4gZm9yIGNoYW5nZWQgaW4gdGhlIGNvbmZpZ3VyYXRpb24sIGF1dG9tYXRpY2FsbHkgYXBwbHkgY2hhbmdlZCBwcmVjaXNpb25cbiAgbWF0aC5vbignY29uZmlnJywgZnVuY3Rpb24gKGN1cnIsIHByZXYpIHtcbiAgICBpZiAoY3Vyci5wcmVjaXNpb24gIT09IHByZXYucHJlY2lzaW9uKSB7XG4gICAgICBCaWdOdW1iZXIuY29uZmlnKHsgcHJlY2lzaW9uOiBjdXJyLnByZWNpc2lvbiB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBCaWdOdW1iZXI7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdCaWdOdW1iZXInO1xuZXhwb3J0cy5wYXRoID0gJ3R5cGUnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbmV4cG9ydHMubWF0aCA9IHRydWU7IC8vIHJlcXVlc3QgYWNjZXNzIHRvIHRoZSBtYXRoIG5hbWVzcGFjZSIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZXBNYXAgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBNYXAnKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICAvKipcbiAgICogQ3JlYXRlIGEgQmlnTnVtYmVyLCB3aGljaCBjYW4gc3RvcmUgbnVtYmVycyB3aXRoIGFyYml0cmFyeSBwcmVjaXNpb24uXG4gICAqIFdoZW4gYSBtYXRyaXggaXMgcHJvdmlkZWQsIGFsbCBlbGVtZW50cyB3aWxsIGJlIGNvbnZlcnRlZCB0byBCaWdOdW1iZXIuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5iaWdudW1iZXIoeClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIDAuMSArIDAuMjsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBudW1iZXIgMC4zMDAwMDAwMDAwMDAwMDAwNFxuICAgKiAgICBtYXRoLmJpZ251bWJlcigwLjEpICsgbWF0aC5iaWdudW1iZXIoMC4yKTsgIC8vIHJldHVybnMgQmlnTnVtYmVyIDAuM1xuICAgKlxuICAgKlxuICAgKiAgICA3LjJlNTAwOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIEluZmluaXR5XG4gICAqICAgIG1hdGguYmlnbnVtYmVyKCc3LjJlNTAwJyk7ICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBCaWdOdW1iZXIgNy4yZTUwMFxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgYm9vbGVhbiwgY29tcGxleCwgaW5kZXgsIG1hdHJpeCwgc3RyaW5nLCB1bml0XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgc3RyaW5nIHwgRnJhY3Rpb24gfCBCaWdOdW1iZXIgfCBBcnJheSB8IE1hdHJpeCB8IGJvb2xlYW4gfCBudWxsfSBbdmFsdWVdICBWYWx1ZSBmb3IgdGhlIGJpZyBudW1iZXIsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAgYnkgZGVmYXVsdC5cbiAgICogQHJldHVybnMge0JpZ051bWJlcn0gVGhlIGNyZWF0ZWQgYmlnbnVtYmVyXG4gICAqL1xuICB2YXIgYmlnbnVtYmVyID0gdHlwZWQoJ2JpZ251bWJlcicsIHtcbiAgICAnJzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyB0eXBlLkJpZ051bWJlcigwKTtcbiAgICB9LFxuXG4gICAgJ251bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAvLyBjb252ZXJ0IHRvIHN0cmluZyB0byBwcmV2ZW50IGVycm9ycyBpbiBjYXNlIG9mID4xNSBkaWdpdHNcbiAgICAgIHJldHVybiBuZXcgdHlwZS5CaWdOdW1iZXIoeCArICcnKTtcbiAgICB9LFxuXG4gICAgJ3N0cmluZyc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gbmV3IHR5cGUuQmlnTnVtYmVyKHgpO1xuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIC8vIHdlIGFzc3VtZSBhIEJpZ051bWJlciBpcyBpbW11dGFibGVcbiAgICAgIHJldHVybiB4O1xuICAgIH0sXG5cbiAgICAnRnJhY3Rpb24nOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIG5ldyB0eXBlLkJpZ051bWJlcih4Lm4pLmRpdih4LmQpO1xuICAgIH0sXG5cbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIGRlZXBNYXAoeCwgYmlnbnVtYmVyKTtcbiAgICB9XG4gIH0pO1xuXG4gIGJpZ251bWJlci50b1RleCA9IHtcbiAgICAwOiAnMCcsXG4gICAgMTogJ1xcXFxsZWZ0KCR7YXJnc1swXX1cXFxccmlnaHQpJ1xuICB9O1xuXG4gIHJldHVybiBiaWdudW1iZXI7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdiaWdudW1iZXInO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIm1vZHVsZS5leHBvcnRzID0gW1xuICAvLyB0eXBlXG4gIHJlcXVpcmUoJy4vQmlnTnVtYmVyJyksXG5cbiAgLy8gY29uc3RydWN0aW9uIGZ1bmN0aW9uXG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vYmlnbnVtYmVyJylcbl07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWVwTWFwID0gcmVxdWlyZSgnLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBNYXAnKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICAvKipcbiAgICogQ3JlYXRlIGEgYm9vbGVhbiBvciBjb252ZXJ0IGEgc3RyaW5nIG9yIG51bWJlciB0byBhIGJvb2xlYW4uXG4gICAqIEluIGNhc2Ugb2YgYSBudW1iZXIsIGB0cnVlYCBpcyByZXR1cm5lZCBmb3Igbm9uLXplcm8gbnVtYmVycywgYW5kIGBmYWxzZWAgaW5cbiAgICogY2FzZSBvZiB6ZXJvLlxuICAgKiBTdHJpbmdzIGNhbiBiZSBgJ3RydWUnYCBvciBgJ2ZhbHNlJ2AsIG9yIGNhbiBjb250YWluIGEgbnVtYmVyLlxuICAgKiBXaGVuIHZhbHVlIGlzIGEgbWF0cml4LCBhbGwgZWxlbWVudHMgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYm9vbGVhbi5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmJvb2xlYW4oeClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGguYm9vbGVhbigwKTsgICAgIC8vIHJldHVybnMgZmFsc2VcbiAgICogICAgbWF0aC5ib29sZWFuKDEpOyAgICAgLy8gcmV0dXJucyB0cnVlXG4gICAqICAgIG1hdGguYm9vbGVhbigtMyk7ICAgICAvLyByZXR1cm5zIHRydWVcbiAgICogICAgbWF0aC5ib29sZWFuKCd0cnVlJyk7ICAgICAvLyByZXR1cm5zIHRydWVcbiAgICogICAgbWF0aC5ib29sZWFuKCdmYWxzZScpOyAgICAgLy8gcmV0dXJucyBmYWxzZVxuICAgKiAgICBtYXRoLmJvb2xlYW4oWzEsIDAsIDEsIDFdKTsgICAgIC8vIHJldHVybnMgW3RydWUsIGZhbHNlLCB0cnVlLCB0cnVlXVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgYmlnbnVtYmVyLCBjb21wbGV4LCBpbmRleCwgbWF0cml4LCBzdHJpbmcsIHVuaXRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgQXJyYXkgfCBNYXRyaXggfCBudWxsfSB2YWx1ZSAgQSB2YWx1ZSBvZiBhbnkgdHlwZVxuICAgKiBAcmV0dXJuIHtib29sZWFuIHwgQXJyYXkgfCBNYXRyaXh9IFRoZSBib29sZWFuIHZhbHVlXG4gICAqL1xuICB2YXIgYm9vbCA9IHR5cGVkKCdib29sJywge1xuICAgICcnOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgICdib29sZWFuJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH0sXG5cbiAgICAnbnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiAhIXg7XG4gICAgfSxcblxuICAgICdCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuICF4LmlzWmVybygpO1xuICAgIH0sXG5cbiAgICAnc3RyaW5nJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIC8vIHRyeSBjYXNlIGluc2Vuc2l0aXZlXG4gICAgICB2YXIgbGNhc2UgPSB4LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAobGNhc2UgPT09ICd0cnVlJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGxjYXNlID09PSAnZmFsc2UnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gdGVzdCB3aGV0aGVyIHZhbHVlIGlzIGEgdmFsaWQgbnVtYmVyXG4gICAgICB2YXIgbnVtID0gTnVtYmVyKHgpO1xuICAgICAgaWYgKHggIT0gJycgJiYgIWlzTmFOKG51bSkpIHtcbiAgICAgICAgcmV0dXJuICEhbnVtO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IFwiJyArIHggKyAnXCIgdG8gYSBib29sZWFuJyk7XG4gICAgfSxcblxuICAgICdBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gZGVlcE1hcCh4LCBib29sKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBib29sO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnYm9vbGVhbic7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZm9ybWF0ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvc3RyaW5nJykuZm9ybWF0O1xudmFyIGxhenkgPSByZXF1aXJlKCcuLi8uLi91dGlscy9vYmplY3QnKS5sYXp5O1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkLCBtYXRoKSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3IgQ2hhaW5cbiAgICogV3JhcCBhbnkgdmFsdWUgaW4gYSBjaGFpbiwgYWxsb3dpbmcgdG8gcGVyZm9ybSBjaGFpbmVkIG9wZXJhdGlvbnMgb25cbiAgICogdGhlIHZhbHVlLlxuICAgKlxuICAgKiBBbGwgbWV0aG9kcyBhdmFpbGFibGUgaW4gdGhlIG1hdGguanMgbGlicmFyeSBjYW4gYmUgY2FsbGVkIHVwb24gdGhlIGNoYWluLFxuICAgKiBhbmQgdGhlbiB3aWxsIGJlIGV2YWx1YXRlZCB3aXRoIHRoZSB2YWx1ZSBpdHNlbGYgYXMgZmlyc3QgYXJndW1lbnQuXG4gICAqIFRoZSBjaGFpbiBjYW4gYmUgY2xvc2VkIGJ5IGV4ZWN1dGluZyBjaGFpbi5kb25lKCksIHdoaWNoIHdpbGwgcmV0dXJuXG4gICAqIHRoZSBmaW5hbCB2YWx1ZS5cbiAgICpcbiAgICogVGhlIENoYWluIGhhcyBhIG51bWJlciBvZiBzcGVjaWFsIGZ1bmN0aW9uczpcbiAgICogLSBkb25lKCkgICAgICAgICAgICAgRmluYWxpemUgdGhlIGNoYWluZWQgb3BlcmF0aW9uIGFuZCByZXR1cm4gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgIGNoYWluJ3MgdmFsdWUuXG4gICAqIC0gdmFsdWVPZigpICAgICAgICAgIFRoZSBzYW1lIGFzIGRvbmUoKVxuICAgKiAtIHRvU3RyaW5nKCkgICAgICAgICBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjaGFpbidzIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IFt2YWx1ZV1cbiAgICovXG4gIGZ1bmN0aW9uIENoYWluICh2YWx1ZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDaGFpbikpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQ29uc3RydWN0b3IgbXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgbmV3IG9wZXJhdG9yJyk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlICYmIHZhbHVlLmlzQ2hhaW4pIHtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZS52YWx1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEF0dGFjaCB0eXBlIGluZm9ybWF0aW9uXG4gICAqL1xuICBDaGFpbi5wcm90b3R5cGUudHlwZSA9ICdDaGFpbic7XG4gIENoYWluLnByb3RvdHlwZS5pc0NoYWluID0gdHJ1ZTtcblxuICAvKipcbiAgICogQ2xvc2UgdGhlIGNoYWluLiBSZXR1cm5zIHRoZSBmaW5hbCB2YWx1ZS5cbiAgICogRG9lcyB0aGUgc2FtZSBhcyBtZXRob2QgdmFsdWVPZigpXG4gICAqIEByZXR1cm5zIHsqfSB2YWx1ZVxuICAgKi9cbiAgQ2hhaW4ucHJvdG90eXBlLmRvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsb3NlIHRoZSBjaGFpbi4gUmV0dXJucyB0aGUgZmluYWwgdmFsdWUuXG4gICAqIERvZXMgdGhlIHNhbWUgYXMgbWV0aG9kIGRvbmUoKVxuICAgKiBAcmV0dXJucyB7Kn0gdmFsdWVcbiAgICovXG4gIENoYWluLnByb3RvdHlwZS52YWx1ZU9mID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZhbHVlIGluIHRoZSBjaGFpblxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgQ2hhaW4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmb3JtYXQodGhpcy52YWx1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHByb3h5IG1ldGhvZCBmb3IgdGhlIGNoYWluXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgICAgVGhlIGZ1bmN0aW9uIHRvIGJlIHByb3hpZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBmbiBpcyBubyBmdW5jdGlvbiwgaXQgaXMgc2lsZW50bHkgaWdub3JlZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZVByb3h5KG5hbWUsIGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgQ2hhaW4ucHJvdG90eXBlW25hbWVdID0gY2hhaW5pZnkoZm4pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBwcm94eSBtZXRob2QgZm9yIHRoZSBjaGFpblxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSByZXNvbHZlciAgIFRoZSBmdW5jdGlvbiByZXNvbHZpbmcgd2l0aCB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB0byBiZSBwcm94aWVkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVMYXp5UHJveHkobmFtZSwgcmVzb2x2ZXIpIHtcbiAgICBsYXp5KENoYWluLnByb3RvdHlwZSwgbmFtZSwgZnVuY3Rpb24gb3V0ZXJSZXNvbHZlcigpIHtcbiAgICAgIHZhciBmbiA9IHJlc29sdmVyKCk7XG4gICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBjaGFpbmlmeShmbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIGlmIG5vdCBhIGZ1bmN0aW9uLCBpZ25vcmVcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIGEgZnVuY3Rpb24gY2hhaW5hYmxlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBjaGFpbiBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gY2hhaW5pZnkgKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gW3RoaXMudmFsdWVdOyAgLy8gYHRoaXNgIHdpbGwgYmUgdGhlIGNvbnRleHQgb2YgYSBDaGFpbiBpbnN0YW5jZVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJnc1tpICsgMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgQ2hhaW4oZm4uYXBwbHkoZm4sIGFyZ3MpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgcHJveHkgZm9yIGEgc2luZ2xlIG1ldGhvZCwgb3IgYW4gb2JqZWN0IHdpdGggbXVsdGlwbGUgbWV0aG9kcy5cbiAgICogRXhhbXBsZSB1c2FnZTpcbiAgICpcbiAgICogICBDaGFpbi5jcmVhdGVQcm94eSgnYWRkJywgZnVuY3Rpb24gYWRkICh4LCB5KSB7Li4ufSk7XG4gICAqICAgQ2hhaW4uY3JlYXRlUHJveHkoe1xuICAgKiAgICAgYWRkOiAgICAgIGZ1bmN0aW9uIGFkZCAoeCwgeSkgey4uLn0sXG4gICAqICAgICBzdWJ0cmFjdDogZnVuY3Rpb24gc3VidHJhY3QgKHgsIHkpIHsuLi59XG4gICAqICAgfVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IE9iamVjdH0gYXJnMCAgIEEgbmFtZSAoc3RyaW5nKSwgb3IgYW4gb2JqZWN0IHdpdGhcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbnNcbiAgICogQHBhcmFtIHsqfSBbYXJnMV0gICAgICAgICAgICAgICBBIGZ1bmN0aW9uLCB3aGVuIGFyZzAgaXMgYSBuYW1lXG4gICAqL1xuICBDaGFpbi5jcmVhdGVQcm94eSA9IGZ1bmN0aW9uIChhcmcwLCBhcmcxKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcwID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gY3JlYXRlUHJveHkobmFtZSwgdmFsdWUpXG4gICAgICBjcmVhdGVQcm94eShhcmcwLCBhcmcxKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBjcmVhdGVQcm94eSh2YWx1ZXMpXG4gICAgICBmb3IgKHZhciBwcm9wIGluIGFyZzApIHtcbiAgICAgICAgaWYgKGFyZzAuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICBjcmVhdGVQcm94eShwcm9wLCBhcmcwW3Byb3BdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBjcmVhdGUgcHJveHkgZm9yIGV2ZXJ5dGhpbmcgdGhhdCBpcyBpbiBtYXRoLmpzXG4gIENoYWluLmNyZWF0ZVByb3h5KG1hdGgpO1xuXG4gIC8vIHJlZ2lzdGVyIG9uIHRoZSBpbXBvcnQgZXZlbnQsIGF1dG9tYXRpY2FsbHkgYWRkIGEgcHJveHkgZm9yIGV2ZXJ5IGltcG9ydGVkIGZ1bmN0aW9uLlxuICBtYXRoLm9uKCdpbXBvcnQnLCBmdW5jdGlvbiAobmFtZSwgcmVzb2x2ZXIsIHBhdGgpIHtcbiAgICBpZiAocGF0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBhbiBpbXBvcnRlZCBmdW5jdGlvbiAobm90IGEgZGF0YSB0eXBlIG9yIHNvbWV0aGluZyBzcGVjaWFsKVxuICAgICAgY3JlYXRlTGF6eVByb3h5KG5hbWUsIHJlc29sdmVyKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBDaGFpbjtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ0NoYWluJztcbmV4cG9ydHMucGF0aCA9ICd0eXBlJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG5leHBvcnRzLm1hdGggPSB0cnVlOyAgLy8gcmVxdWlyZSBwcm92aWRpbmcgdGhlIG1hdGggbmFtZXNwYWNlIGFzIDV0aCBhcmd1bWVudFxuZXhwb3J0cy5sYXp5ID0gZmFsc2U7IC8vIHdlIG5lZWQgdG8gcmVnaXN0ZXIgYSBsaXN0ZW5lciBvbiB0aGUgaW1wb3J0IGV2ZW50cywgc28gbm8gbGF6eSBsb2FkaW5nXG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgLyoqXG4gICAqIFdyYXAgYW55IHZhbHVlIGluIGEgY2hhaW4sIGFsbG93aW5nIHRvIHBlcmZvcm0gY2hhaW5lZCBvcGVyYXRpb25zIG9uXG4gICAqIHRoZSB2YWx1ZS5cbiAgICpcbiAgICogQWxsIG1ldGhvZHMgYXZhaWxhYmxlIGluIHRoZSBtYXRoLmpzIGxpYnJhcnkgY2FuIGJlIGNhbGxlZCB1cG9uIHRoZSBjaGFpbixcbiAgICogYW5kIHRoZW4gd2lsbCBiZSBldmFsdWF0ZWQgd2l0aCB0aGUgdmFsdWUgaXRzZWxmIGFzIGZpcnN0IGFyZ3VtZW50LlxuICAgKiBUaGUgY2hhaW4gY2FuIGJlIGNsb3NlZCBieSBleGVjdXRpbmcgYGNoYWluLmRvbmUoKWAsIHdoaWNoIHJldHVybnNcbiAgICogdGhlIGZpbmFsIHZhbHVlLlxuICAgKlxuICAgKiBUaGUgY2hhaW4gaGFzIGEgbnVtYmVyIG9mIHNwZWNpYWwgZnVuY3Rpb25zOlxuICAgKlxuICAgKiAtIGBkb25lKClgICAgICBGaW5hbGl6ZSB0aGUgY2hhaW4gYW5kIHJldHVybiB0aGUgY2hhaW4ncyB2YWx1ZS5cbiAgICogLSBgdmFsdWVPZigpYCAgVGhlIHNhbWUgYXMgYGRvbmUoKWBcbiAgICogLSBgdG9TdHJpbmcoKWAgRXhlY3V0ZXMgYG1hdGguZm9ybWF0KClgIG9udG8gdGhlIGNoYWluJ3MgdmFsdWUsIHJldHVybmluZ1xuICAgKiAgICAgICAgICAgICAgICBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmFsdWUuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5jaGFpbih2YWx1ZSlcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgICBtYXRoLmNoYWluKDMpXG4gICAqICAgICAgICAgLmFkZCg0KVxuICAgKiAgICAgICAgIC5zdWJ0cmFjdCgyKVxuICAgKiAgICAgICAgIC5kb25lKCk7ICAgICAvLyA1XG4gICAqXG4gICAqICAgICBtYXRoLmNoYWluKCBbWzEsIDJdLCBbMywgNF1dIClcbiAgICogICAgICAgICAuc3Vic2V0KG1hdGguaW5kZXgoMCwgMCksIDgpXG4gICAqICAgICAgICAgLm11bHRpcGx5KDMpXG4gICAqICAgICAgICAgLmRvbmUoKTsgICAgIC8vIFtbMjQsIDZdLCBbOSwgMTJdXVxuICAgKlxuICAgKiBAcGFyYW0geyp9IFt2YWx1ZV0gICBBIHZhbHVlIG9mIGFueSB0eXBlIG9uIHdoaWNoIHRvIHN0YXJ0IGEgY2hhaW5lZCBvcGVyYXRpb24uXG4gICAqIEByZXR1cm4ge21hdGgudHlwZS5DaGFpbn0gVGhlIGNyZWF0ZWQgY2hhaW5cbiAgICovXG4gIHJldHVybiB0eXBlZCgnY2hhaW4nLCB7XG4gICAgJyc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyB0eXBlLkNoYWluKCk7XG4gICAgfSxcblxuICAgICdhbnknOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIG5ldyB0eXBlLkNoYWluKHZhbHVlKTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnY2hhaW4nO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIm1vZHVsZS5leHBvcnRzID0gW1xuICAvLyB0eXBlXG4gIHJlcXVpcmUoJy4vQ2hhaW4nKSxcblxuICAvLyBjb25zdHJ1Y3Rpb24gZnVuY3Rpb25cbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi9jaGFpbicpXG5dO1xuIiwidmFyIENvbXBsZXggPSByZXF1aXJlKCdjb21wbGV4LmpzJyk7XG52YXIgZm9ybWF0ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbnVtYmVyJykuZm9ybWF0O1xudmFyIGlzTnVtYmVyID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbnVtYmVyJykuaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQsIG1hdGgpIHtcblxuICAvKipcbiAgICogQXR0YWNoIHR5cGUgaW5mb3JtYXRpb25cbiAgICovXG4gIENvbXBsZXgucHJvdG90eXBlLnR5cGUgPSAnQ29tcGxleCc7XG4gIENvbXBsZXgucHJvdG90eXBlLmlzQ29tcGxleCA9IHRydWU7XG5cblxuICAvKipcbiAgICogR2V0IGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29tcGxleCBudW1iZXJcbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhIEpTT04gb2JqZWN0IHN0cnVjdHVyZWQgYXM6XG4gICAqICAgICAgICAgICAgICAgICAgIGB7XCJtYXRoanNcIjogXCJDb21wbGV4XCIsIFwicmVcIjogMiwgXCJpbVwiOiAzfWBcbiAgICovXG4gIENvbXBsZXgucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWF0aGpzOiAnQ29tcGxleCcsXG4gICAgICByZTogdGhpcy5yZSxcbiAgICAgIGltOiB0aGlzLmltXG4gICAgfTtcbiAgfTtcblxuICAvKlxuICAgKiBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBjb21wbGV4IG51bWJlciBpbiBwb2xhciBub3RhdGlvblxuICAgKiBUaGUgYW5nbGUgcGhpIHdpbGwgYmUgc2V0IGluIHRoZSBpbnRlcnZhbCBvZiBbLXBpLCBwaV0uXG4gICAqIEByZXR1cm4ge3tyOiBudW1iZXIsIHBoaTogbnVtYmVyfX0gUmV0dXJucyBhbmQgb2JqZWN0IHdpdGggcHJvcGVydGllcyByIGFuZCBwaGkuXG4gICAqL1xuICBDb21wbGV4LnByb3RvdHlwZS50b1BvbGFyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICByOiB0aGlzLmFicygpLFxuICAgICAgcGhpOiB0aGlzLmFyZygpXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb21wbGV4IG51bWJlcixcbiAgICogd2l0aCBvcHRpb25hbCBmb3JtYXR0aW5nIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0IHwgbnVtYmVyIHwgRnVuY3Rpb259IFtvcHRpb25zXSAgRm9ybWF0dGluZyBvcHRpb25zLiBTZWVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaWIvdXRpbHMvbnVtYmVyOmZvcm1hdCBmb3IgYVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uIG9mIHRoZSBhdmFpbGFibGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHN0clxuICAgKi9cbiAgQ29tcGxleC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgc3RyID0gJyc7XG4gICAgdmFyIGltID0gdGhpcy5pbTtcbiAgICB2YXIgcmUgPSB0aGlzLnJlO1xuICAgIHZhciBzdHJSZSA9IGZvcm1hdCh0aGlzLnJlLCBvcHRpb25zKTtcbiAgICB2YXIgc3RySW0gPSBmb3JtYXQodGhpcy5pbSwgb3B0aW9ucyk7XG5cbiAgICAvLyByb3VuZCBlaXRoZXIgcmUgb3IgaW0gd2hlbiBzbWFsbGVyIHRoYW4gdGhlIGNvbmZpZ3VyZWQgcHJlY2lzaW9uXG4gICAgdmFyIHByZWNpc2lvbiA9IGlzTnVtYmVyKG9wdGlvbnMpID8gb3B0aW9ucyA6IG9wdGlvbnMgPyBvcHRpb25zLnByZWNpc2lvbiA6IG51bGw7XG4gICAgaWYgKHByZWNpc2lvbiAhPT0gbnVsbCkge1xuICAgICAgdmFyIGVwc2lsb24gPSBNYXRoLnBvdygxMCwgLXByZWNpc2lvbik7XG4gICAgICBpZiAoTWF0aC5hYnMocmUgLyBpbSkgPCBlcHNpbG9uKSB7XG4gICAgICAgIHJlID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChNYXRoLmFicyhpbSAvIHJlKSA8IGVwc2lsb24pIHtcbiAgICAgICAgaW0gPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpbSA9PSAwKSB7XG4gICAgICAvLyByZWFsIHZhbHVlXG4gICAgICBzdHIgPSBzdHJSZTtcbiAgICB9IGVsc2UgaWYgKHJlID09IDApIHtcbiAgICAgIC8vIHB1cmVseSBjb21wbGV4IHZhbHVlXG4gICAgICBpZiAoaW0gPT0gMSkge1xuICAgICAgICBzdHIgPSAnaSc7XG4gICAgICB9IGVsc2UgaWYgKGltID09IC0xKSB7XG4gICAgICAgIHN0ciA9ICctaSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBzdHJJbSArICdpJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY29tcGxleCB2YWx1ZVxuICAgICAgaWYgKGltID4gMCkge1xuICAgICAgICBpZiAoaW0gPT0gMSkge1xuICAgICAgICAgIHN0ciA9IHN0clJlICsgJyArIGknO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9IHN0clJlICsgJyArICcgKyBzdHJJbSArICdpJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGltID09IC0xKSB7XG4gICAgICAgICAgc3RyID0gc3RyUmUgKyAnIC0gaSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gc3RyUmUgKyAnIC0gJyArIHN0ckltLnN1YnN0cmluZygxKSArICdpJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBjb21wbGV4IG51bWJlciBmcm9tIHBvbGFyIGNvb3JkaW5hdGVzXG4gICAqXG4gICAqIFVzYWdlOlxuICAgKlxuICAgKiAgICAgQ29tcGxleC5mcm9tUG9sYXIocjogbnVtYmVyLCBwaGk6IG51bWJlcikgOiBDb21wbGV4XG4gICAqICAgICBDb21wbGV4LmZyb21Qb2xhcih7cjogbnVtYmVyLCBwaGk6IG51bWJlcn0pIDogQ29tcGxleFxuICAgKlxuICAgKiBAcGFyYW0geyp9IGFyZ3MuLi5cbiAgICogQHJldHVybiB7Q29tcGxleH1cbiAgICovXG4gIENvbXBsZXguZnJvbVBvbGFyID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgdmFyIGFyZyA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmcgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgcmV0dXJuIENvbXBsZXgoYXJnKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnB1dCBoYXMgdG8gYmUgYW4gb2JqZWN0IHdpdGggciBhbmQgcGhpIGtleXMuJyk7XG5cbiAgICAgIGNhc2UgMjpcbiAgICAgICAgdmFyIHIgPSBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgICBwaGkgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIGlmIChpc051bWJlcihyKSkge1xuICAgICAgICAgIGlmIChwaGkgJiYgcGhpLmlzVW5pdCAmJiBwaGkuaGFzQmFzZSgnQU5HTEUnKSkge1xuICAgICAgICAgICAgLy8gY29udmVydCB1bml0IHRvIGEgbnVtYmVyIGluIHJhZGlhbnNcbiAgICAgICAgICAgIHBoaSA9IHBoaS50b051bWJlcigncmFkJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzTnVtYmVyKHBoaSkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGxleCh7cjogciwgcGhpOiBwaGl9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQaGkgaXMgbm90IGEgbnVtYmVyIG5vciBhbiBhbmdsZSB1bml0LicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JhZGl1cyByIGlzIG5vdCBhIG51bWJlci4nKTtcbiAgICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1dyb25nIG51bWJlciBvZiBhcmd1bWVudHMgaW4gZnVuY3Rpb24gZnJvbVBvbGFyJyk7XG4gICAgfVxuICB9O1xuXG5cbiAgQ29tcGxleC5wcm90b3R5cGUudmFsdWVPZiA9IENvbXBsZXgucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBDb21wbGV4IG51bWJlciBmcm9tIGEgSlNPTiBvYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IGpzb24gIEEgSlNPTiBPYmplY3Qgc3RydWN0dXJlZCBhc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAge1wibWF0aGpzXCI6IFwiQ29tcGxleFwiLCBcInJlXCI6IDIsIFwiaW1cIjogM31cbiAgICogICAgICAgICAgICAgICAgICAgICAgIEFsbCBwcm9wZXJ0aWVzIGFyZSBvcHRpb25hbCwgZGVmYXVsdCB2YWx1ZXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgIGZvciBgcmVgIGFuZCBgaW1gIGFyZSAwLlxuICAgKiBAcmV0dXJuIHtDb21wbGV4fSBSZXR1cm5zIGEgbmV3IENvbXBsZXggbnVtYmVyXG4gICAqL1xuICBDb21wbGV4LmZyb21KU09OID0gZnVuY3Rpb24gKGpzb24pIHtcbiAgICByZXR1cm4gbmV3IENvbXBsZXgoanNvbik7XG4gIH07XG5cbiAgLy8gYXBwbHkgdGhlIGN1cnJlbnQgZXBzaWxvblxuICBDb21wbGV4LkVQU0lMT04gPSBjb25maWcuZXBzaWxvbjtcblxuICAvLyBsaXN0ZW4gZm9yIGNoYW5nZWQgaW4gdGhlIGNvbmZpZ3VyYXRpb24sIGF1dG9tYXRpY2FsbHkgYXBwbHkgY2hhbmdlZCBlcHNpbG9uXG4gIG1hdGgub24oJ2NvbmZpZycsIGZ1bmN0aW9uIChjdXJyLCBwcmV2KSB7XG4gICAgaWYgKGN1cnIuZXBzaWxvbiAhPT0gcHJldi5lcHNpbG9uKSB7XG4gICAgICBDb21wbGV4LkVQU0lMT04gPSBjdXJyLmVwc2lsb247XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gQ29tcGxleDtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ0NvbXBsZXgnO1xuZXhwb3J0cy5wYXRoID0gJ3R5cGUnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbmV4cG9ydHMubWF0aCA9IHRydWU7IC8vIHJlcXVlc3QgYWNjZXNzIHRvIHRoZSBtYXRoIG5hbWVzcGFjZVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVlcE1hcCA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vZGVlcE1hcCcpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBsYXRleCA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL2xhdGV4Jyk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGNvbXBsZXggdmFsdWUgb3IgY29udmVydCBhIHZhbHVlIHRvIGEgY29tcGxleCB2YWx1ZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICAgbWF0aC5jb21wbGV4KCkgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGVzIGEgY29tcGxleCB2YWx1ZSB3aXRoIHplcm9cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXMgcmVhbCBhbmQgaW1hZ2luYXJ5IHBhcnQuXG4gICAqICAgICBtYXRoLmNvbXBsZXgocmUgOiBudW1iZXIsIGltIDogc3RyaW5nKSAgIC8vIGNyZWF0ZXMgYSBjb21wbGV4IHZhbHVlIHdpdGggcHJvdmlkZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWVzIGZvciByZWFsIGFuZCBpbWFnaW5hcnkgcGFydC5cbiAgICogICAgIG1hdGguY29tcGxleChyZSA6IG51bWJlcikgICAgICAgICAgICAgICAgLy8gY3JlYXRlcyBhIGNvbXBsZXggdmFsdWUgd2l0aCBwcm92aWRlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZWFsIHZhbHVlIGFuZCB6ZXJvIGltYWdpbmFyeSBwYXJ0LlxuICAgKiAgICAgbWF0aC5jb21wbGV4KGNvbXBsZXggOiBDb21wbGV4KSAgICAgICAgICAvLyBjbG9uZXMgdGhlIHByb3ZpZGVkIGNvbXBsZXggdmFsdWUuXG4gICAqICAgICBtYXRoLmNvbXBsZXgoYXJnIDogc3RyaW5nKSAgICAgICAgICAgICAgIC8vIHBhcnNlcyBhIHN0cmluZyBpbnRvIGEgY29tcGxleCB2YWx1ZS5cbiAgICogICAgIG1hdGguY29tcGxleChhcnJheSA6IEFycmF5KSAgICAgICAgICAgICAgLy8gY29udmVydHMgdGhlIGVsZW1lbnRzIG9mIHRoZSBhcnJheVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvciBtYXRyaXggZWxlbWVudCB3aXNlIGludG8gYVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb21wbGV4IHZhbHVlLlxuICAgKiAgICAgbWF0aC5jb21wbGV4KHtyZTogbnVtYmVyLCBpbTogbnVtYmVyfSkgICAvLyBjcmVhdGVzIGEgY29tcGxleCB2YWx1ZSB3aXRoIHByb3ZpZGVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlcyBmb3IgcmVhbCBhbiBpbWFnaW5hcnkgcGFydC5cbiAgICogICAgIG1hdGguY29tcGxleCh7cjogbnVtYmVyLCBwaGk6IG51bWJlcn0pICAgLy8gY3JlYXRlcyBhIGNvbXBsZXggdmFsdWUgd2l0aCBwcm92aWRlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwb2xhciBjb29yZGluYXRlc1xuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgdmFyIGEgPSBtYXRoLmNvbXBsZXgoMywgLTQpOyAgICAgLy8gYSA9IENvbXBsZXggMyAtIDRpXG4gICAqICAgIGEucmUgPSA1OyAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgPSBDb21wbGV4IDUgLSA0aVxuICAgKiAgICB2YXIgaSA9IGEuaW07ICAgICAgICAgICAgICAgICAgICAvLyBOdW1iZXIgLTQ7XG4gICAqICAgIHZhciBiID0gbWF0aC5jb21wbGV4KCcyICsgNmknKTsgIC8vIENvbXBsZXggMiArIDZpXG4gICAqICAgIHZhciBjID0gbWF0aC5jb21wbGV4KCk7ICAgICAgICAgIC8vIENvbXBsZXggMCArIDBpXG4gICAqICAgIHZhciBkID0gbWF0aC5hZGQoYSwgYik7ICAgICAgICAgIC8vIENvbXBsZXggNSArIDJpXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBiaWdudW1iZXIsIGJvb2xlYW4sIGluZGV4LCBtYXRyaXgsIG51bWJlciwgc3RyaW5nLCB1bml0XG4gICAqXG4gICAqIEBwYXJhbSB7KiB8IEFycmF5IHwgTWF0cml4fSBbYXJnc11cbiAgICogICAgICAgICAgICBBcmd1bWVudHMgc3BlY2lmeWluZyB0aGUgcmVhbCBhbmQgaW1hZ2luYXJ5IHBhcnQgb2YgdGhlIGNvbXBsZXggbnVtYmVyXG4gICAqIEByZXR1cm4ge0NvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0gUmV0dXJucyBhIGNvbXBsZXggdmFsdWVcbiAgICovXG4gIHZhciBjb21wbGV4ID0gdHlwZWQoJ2NvbXBsZXgnLCB7XG4gICAgJyc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0eXBlLkNvbXBsZXguWkVSTztcbiAgICB9LFxuXG4gICAgJ251bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gbmV3IHR5cGUuQ29tcGxleCh4LCAwKTtcbiAgICB9LFxuXG4gICAgJ251bWJlciwgbnVtYmVyJzogZnVuY3Rpb24gKHJlLCBpbSkge1xuICAgICAgcmV0dXJuIG5ldyB0eXBlLkNvbXBsZXgocmUsIGltKTtcbiAgICB9LFxuXG4gICAgLy8gVE9ETzogdGhpcyBzaWduYXR1cmUgc2hvdWxkIGJlIHJlZHVuZGFudFxuICAgICdCaWdOdW1iZXIsIEJpZ051bWJlcic6IGZ1bmN0aW9uIChyZSwgaW0pIHtcbiAgICAgIHJldHVybiBuZXcgdHlwZS5Db21wbGV4KHJlLnRvTnVtYmVyKCksIGltLnRvTnVtYmVyKCkpO1xuICAgIH0sXG5cbiAgICAnQ29tcGxleCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5jbG9uZSgpO1xuICAgIH0sXG5cbiAgICAnc3RyaW5nJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB0eXBlLkNvbXBsZXgoeCk7IC8vIGZvciBleGFtcGxlICcyICsgM2knXG4gICAgfSxcblxuICAgICdPYmplY3QnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgaWYoJ3JlJyBpbiB4ICYmICdpbScgaW4geCkge1xuICAgICAgICByZXR1cm4gbmV3IHR5cGUuQ29tcGxleCh4LnJlLCB4LmltKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCdyJyBpbiB4ICYmICdwaGknIGluIHgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0eXBlLkNvbXBsZXgoeCk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgb2JqZWN0IHdpdGggZWl0aGVyIHByb3BlcnRpZXMgcmUgYW5kIGltLCBvciBwcm9wZXJ0aWVzIHIgYW5kIHBoaS4nKTtcbiAgICB9LFxuXG4gICAgJ0FycmF5IHwgTWF0cml4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBkZWVwTWFwKHgsIGNvbXBsZXgpO1xuICAgIH1cbiAgfSk7XG5cbiAgY29tcGxleC50b1RleCA9IHtcbiAgICAwOiAnMCcsXG4gICAgMTogJ1xcXFxsZWZ0KCR7YXJnc1swXX1cXFxccmlnaHQpJyxcbiAgICAyOiAnXFxcXGxlZnQoXFxcXGxlZnQoJHthcmdzWzBdfVxcXFxyaWdodCkrJ1xuICAgICAgKyBsYXRleC5zeW1ib2xzWydpJ10gKyAnXFxcXGNkb3RcXFxcbGVmdCgke2FyZ3NbMV19XFxcXHJpZ2h0KVxcXFxyaWdodCknXG4gIH07XG5cbiAgcmV0dXJuIGNvbXBsZXg7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdjb21wbGV4JztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFtcbiAgLy8gdHlwZVxuICByZXF1aXJlKCcuL0NvbXBsZXgnKSxcblxuICAvLyBjb25zdHJ1Y3Rpb24gZnVuY3Rpb25cbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi9jb21wbGV4Jylcbl07XG4iLCJ2YXIgRnJhY3Rpb24gPSByZXF1aXJlKCdmcmFjdGlvbi5qcycpO1xuXG4vKipcbiAqIEF0dGFjaCB0eXBlIGluZm9ybWF0aW9uXG4gKi9cbkZyYWN0aW9uLnByb3RvdHlwZS50eXBlID0gJ0ZyYWN0aW9uJztcbkZyYWN0aW9uLnByb3RvdHlwZS5pc0ZyYWN0aW9uID0gdHJ1ZTtcblxuLyoqXG4gKiBHZXQgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgRnJhY3Rpb24gY29udGFpbmluZyB0eXBlIGluZm9ybWF0aW9uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGEgSlNPTiBvYmplY3Qgc3RydWN0dXJlZCBhczpcbiAqICAgICAgICAgICAgICAgICAgIGB7XCJtYXRoanNcIjogXCJGcmFjdGlvblwiLCBcIm5cIjogMywgXCJkXCI6IDh9YFxuICovXG5GcmFjdGlvbi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIG1hdGhqczogJ0ZyYWN0aW9uJyxcbiAgICBuOiB0aGlzLnMgKiB0aGlzLm4sXG4gICAgZDogdGhpcy5kXG4gIH07XG59O1xuXG4vKipcbiAqIEluc3RhbnRpYXRlIGEgRnJhY3Rpb24gZnJvbSBhIEpTT04gb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0ganNvbiAgYSBKU09OIG9iamVjdCBzdHJ1Y3R1cmVkIGFzOlxuICogICAgICAgICAgICAgICAgICAgICAgIGB7XCJtYXRoanNcIjogXCJGcmFjdGlvblwiLCBcIm5cIjogMywgXCJkXCI6IDh9YFxuICogQHJldHVybiB7QmlnTnVtYmVyfVxuICovXG5GcmFjdGlvbi5mcm9tSlNPTiA9IGZ1bmN0aW9uIChqc29uKSB7XG4gIHJldHVybiBuZXcgRnJhY3Rpb24oanNvbik7XG59O1xuXG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgcmV0dXJuIEZyYWN0aW9uO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnRnJhY3Rpb24nO1xuZXhwb3J0cy5wYXRoID0gJ3R5cGUnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZXBNYXAgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBNYXAnKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICAvKipcbiAgICogQ3JlYXRlIGEgZnJhY3Rpb24gY29udmVydCBhIHZhbHVlIHRvIGEgZnJhY3Rpb24uXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICogICAgIG1hdGguZnJhY3Rpb24obnVtZXJhdG9yLCBkZW5vbWluYXRvcilcbiAgICogICAgIG1hdGguZnJhY3Rpb24oe246IG51bWVyYXRvciwgZDogZGVub21pbmF0b3J9KVxuICAgKiAgICAgbWF0aC5mcmFjdGlvbihtYXRyaXg6IEFycmF5IHwgTWF0cml4KSAgICAgICAgIFR1cm4gYWxsIG1hdHJpeCBlbnRyaWVzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50byBmcmFjdGlvbnNcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgICBtYXRoLmZyYWN0aW9uKDEsIDMpO1xuICAgKiAgICAgbWF0aC5mcmFjdGlvbignMi8zJyk7XG4gICAqICAgICBtYXRoLmZyYWN0aW9uKHtuOiAyLCBkOiAzfSk7XG4gICAqICAgICBtYXRoLmZyYWN0aW9uKFswLjIsIDAuMjUsIDEuMjVdKTtcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGJpZ251bWJlciwgbnVtYmVyLCBzdHJpbmcsIHVuaXRcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXIgfCBzdHJpbmcgfCBGcmFjdGlvbiB8IEJpZ051bWJlciB8IEFycmF5IHwgTWF0cml4fSBbYXJnc11cbiAgICogICAgICAgICAgICBBcmd1bWVudHMgc3BlY2lmeWluZyB0aGUgbnVtZXJhdG9yIGFuZCBkZW5vbWluYXRvciBvZlxuICAgKiAgICAgICAgICAgIHRoZSBmcmFjdGlvblxuICAgKiBAcmV0dXJuIHtGcmFjdGlvbiB8IEFycmF5IHwgTWF0cml4fSBSZXR1cm5zIGEgZnJhY3Rpb25cbiAgICovXG4gIHZhciBmcmFjdGlvbiA9IHR5cGVkKCdmcmFjdGlvbicsIHtcbiAgICAnbnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICghaXNGaW5pdGUoeCkgfHwgaXNOYU4oeCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHggKyAnIGNhbm5vdCBiZSByZXByZXNlbnRlZCBhcyBhIGZyYWN0aW9uJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgdHlwZS5GcmFjdGlvbih4KTtcbiAgICB9LFxuXG4gICAgJ3N0cmluZyc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gbmV3IHR5cGUuRnJhY3Rpb24oeCk7XG4gICAgfSxcblxuICAgICdudW1iZXIsIG51bWJlcic6IGZ1bmN0aW9uIChudW1lcmF0b3IsIGRlbm9taW5hdG9yKSB7XG4gICAgICByZXR1cm4gbmV3IHR5cGUuRnJhY3Rpb24obnVtZXJhdG9yLCBkZW5vbWluYXRvcik7XG4gICAgfSxcblxuICAgICdCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIG5ldyB0eXBlLkZyYWN0aW9uKHgudG9TdHJpbmcoKSk7XG4gICAgfSxcblxuICAgICdGcmFjdGlvbic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geDsgLy8gZnJhY3Rpb25zIGFyZSBpbW11dGFibGVcbiAgICB9LFxuXG4gICAgJ09iamVjdCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gbmV3IHR5cGUuRnJhY3Rpb24oeCk7XG4gICAgfSxcblxuICAgICdBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gZGVlcE1hcCh4LCBmcmFjdGlvbik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZnJhY3Rpb247XG59XG5cbmV4cG9ydHMubmFtZSA9ICdmcmFjdGlvbic7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBbXG4gIC8vIHR5cGVcbiAgcmVxdWlyZSgnLi9GcmFjdGlvbicpLFxuXG4gIC8vIGNvbnN0cnVjdGlvbiBmdW5jdGlvblxuICByZXF1aXJlKCcuL2Z1bmN0aW9uL2ZyYWN0aW9uJylcbl07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFtcbiAgcmVxdWlyZSgnLi9iaWdudW1iZXInKSxcbiAgcmVxdWlyZSgnLi9ib29sZWFuJyksXG4gIHJlcXVpcmUoJy4vY2hhaW4nKSxcbiAgcmVxdWlyZSgnLi9jb21wbGV4JyksXG4gIHJlcXVpcmUoJy4vZnJhY3Rpb24nKSxcbiAgcmVxdWlyZSgnLi9tYXRyaXgnKSxcbiAgcmVxdWlyZSgnLi9udW1iZXInKSxcbiAgcmVxdWlyZSgnLi9yZXN1bHRzZXQnKSxcbiAgcmVxdWlyZSgnLi9zdHJpbmcnKSxcbiAgcmVxdWlyZSgnLi91bml0Jylcbl07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvaW5kZXgnKTtcbnZhciBEaW1lbnNpb25FcnJvciA9IHJlcXVpcmUoJy4uLy4uL2Vycm9yL0RpbWVuc2lvbkVycm9yJyk7XG5cbnZhciBzdHJpbmcgPSB1dGlsLnN0cmluZztcbnZhciBhcnJheSA9IHV0aWwuYXJyYXk7XG52YXIgb2JqZWN0ID0gdXRpbC5vYmplY3Q7XG52YXIgbnVtYmVyID0gdXRpbC5udW1iZXI7XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbnZhciBpc051bWJlciA9IG51bWJlci5pc051bWJlcjtcbnZhciBpc0ludGVnZXIgPSBudW1iZXIuaXNJbnRlZ2VyO1xudmFyIGlzU3RyaW5nID0gc3RyaW5nLmlzU3RyaW5nO1xuXG52YXIgdmFsaWRhdGVJbmRleCA9IGFycmF5LnZhbGlkYXRlSW5kZXg7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIE1hdHJpeCA9IGxvYWQocmVxdWlyZSgnLi9NYXRyaXgnKSk7IC8vIGZvcmNlIGxvYWRpbmcgTWF0cml4IChkbyBub3QgdXNlIHZpYSB0eXBlLk1hdHJpeClcblxuICAvKipcbiAgICogRGVuc2UgTWF0cml4IGltcGxlbWVudGF0aW9uLiBBIHJlZ3VsYXIsIGRlbnNlIG1hdHJpeCwgc3VwcG9ydGluZyBtdWx0aS1kaW1lbnNpb25hbCBtYXRyaWNlcy4gVGhpcyBpcyB0aGUgZGVmYXVsdCBtYXRyaXggdHlwZS5cbiAgICogQGNsYXNzIERlbnNlTWF0cml4XG4gICAqL1xuICBmdW5jdGlvbiBEZW5zZU1hdHJpeChkYXRhLCBkYXRhdHlwZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEZW5zZU1hdHJpeCkpXG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0NvbnN0cnVjdG9yIG11c3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBvcGVyYXRvcicpO1xuICAgIGlmIChkYXRhdHlwZSAmJiAhaXNTdHJpbmcoZGF0YXR5cGUpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRhdGF0eXBlOiAnICsgZGF0YXR5cGUpO1xuXG4gICAgaWYgKGRhdGEgJiYgZGF0YS5pc01hdHJpeCA9PT0gdHJ1ZSkge1xuICAgICAgLy8gY2hlY2sgZGF0YSBpcyBhIERlbnNlTWF0cml4XG4gICAgICBpZiAoZGF0YS50eXBlID09PSAnRGVuc2VNYXRyaXgnKSB7XG4gICAgICAgIC8vIGNsb25lIGRhdGEgJiBzaXplXG4gICAgICAgIHRoaXMuX2RhdGEgPSBvYmplY3QuY2xvbmUoZGF0YS5fZGF0YSk7XG4gICAgICAgIHRoaXMuX3NpemUgPSBvYmplY3QuY2xvbmUoZGF0YS5fc2l6ZSk7XG4gICAgICAgIHRoaXMuX2RhdGF0eXBlID0gZGF0YXR5cGUgfHwgZGF0YS5fZGF0YXR5cGU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gYnVpbGQgZGF0YSBmcm9tIGV4aXN0aW5nIG1hdHJpeFxuICAgICAgICB0aGlzLl9kYXRhID0gZGF0YS50b0FycmF5KCk7XG4gICAgICAgIHRoaXMuX3NpemUgPSBkYXRhLnNpemUoKTtcbiAgICAgICAgdGhpcy5fZGF0YXR5cGUgPSBkYXRhdHlwZSB8fCBkYXRhLl9kYXRhdHlwZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YSAmJiBpc0FycmF5KGRhdGEuZGF0YSkgJiYgaXNBcnJheShkYXRhLnNpemUpKSB7XG4gICAgICAvLyBpbml0aWFsaXplIGZpZWxkcyBmcm9tIEpTT04gcmVwcmVzZW50YXRpb25cbiAgICAgIHRoaXMuX2RhdGEgPSBkYXRhLmRhdGE7XG4gICAgICB0aGlzLl9zaXplID0gZGF0YS5zaXplO1xuICAgICAgdGhpcy5fZGF0YXR5cGUgPSBkYXRhdHlwZSB8fCBkYXRhLmRhdGF0eXBlO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0FycmF5KGRhdGEpKSB7XG4gICAgICAvLyByZXBsYWNlIG5lc3RlZCBNYXRyaWNlcyB3aXRoIEFycmF5c1xuICAgICAgdGhpcy5fZGF0YSA9IHByZXByb2Nlc3MoZGF0YSk7XG4gICAgICAvLyBnZXQgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGFycmF5XG4gICAgICB0aGlzLl9zaXplID0gYXJyYXkuc2l6ZSh0aGlzLl9kYXRhKTtcbiAgICAgIC8vIHZlcmlmeSB0aGUgZGltZW5zaW9ucyBvZiB0aGUgYXJyYXksIFRPRE86IGNvbXB1dGUgc2l6ZSB3aGlsZSBwcm9jZXNzaW5nIGFycmF5XG4gICAgICBhcnJheS52YWxpZGF0ZSh0aGlzLl9kYXRhLCB0aGlzLl9zaXplKTtcbiAgICAgIC8vIGRhdGEgdHlwZSB1bmtub3duXG4gICAgICB0aGlzLl9kYXRhdHlwZSA9IGRhdGF0eXBlO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhKSB7XG4gICAgICAvLyB1bnN1cHBvcnRlZCB0eXBlXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbnN1cHBvcnRlZCB0eXBlIG9mIGRhdGEgKCcgKyB1dGlsLnR5cGVzLnR5cGUoZGF0YSkgKyAnKScpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIG5vdGhpbmcgcHJvdmlkZWRcbiAgICAgIHRoaXMuX2RhdGEgPSBbXTtcbiAgICAgIHRoaXMuX3NpemUgPSBbMF07XG4gICAgICB0aGlzLl9kYXRhdHlwZSA9IGRhdGF0eXBlO1xuICAgIH1cbiAgfVxuICBcbiAgRGVuc2VNYXRyaXgucHJvdG90eXBlID0gbmV3IE1hdHJpeCgpO1xuXG4gIC8qKlxuICAgKiBBdHRhY2ggdHlwZSBpbmZvcm1hdGlvblxuICAgKi9cbiAgRGVuc2VNYXRyaXgucHJvdG90eXBlLnR5cGUgPSAnRGVuc2VNYXRyaXgnO1xuICBEZW5zZU1hdHJpeC5wcm90b3R5cGUuaXNEZW5zZU1hdHJpeCA9IHRydWU7XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3RvcmFnZSBmb3JtYXQgdXNlZCBieSB0aGUgbWF0cml4LlxuICAgKlxuICAgKiBVc2FnZTpcbiAgICogICAgIHZhciBmb3JtYXQgPSBtYXRyaXguc3RvcmFnZSgpICAgICAgICAgICAgICAgICAgIC8vIHJldHJpZXZlIHN0b3JhZ2UgZm9ybWF0XG4gICAqXG4gICAqIEBtZW1iZXJvZiBEZW5zZU1hdHJpeFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9ICAgICAgICAgICBUaGUgc3RvcmFnZSBmb3JtYXQuXG4gICAqL1xuICBEZW5zZU1hdHJpeC5wcm90b3R5cGUuc3RvcmFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJ2RlbnNlJztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBkYXRhdHlwZSBvZiB0aGUgZGF0YSBzdG9yZWQgaW4gdGhlIG1hdHJpeC5cbiAgICpcbiAgICogVXNhZ2U6XG4gICAqICAgICB2YXIgZm9ybWF0ID0gbWF0cml4LmRhdGF0eXBlKCkgICAgICAgICAgICAgICAgICAgLy8gcmV0cmlldmUgbWF0cml4IGRhdGF0eXBlXG4gICAqXG4gICAqIEBtZW1iZXJvZiBEZW5zZU1hdHJpeFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9ICAgICAgICAgICBUaGUgZGF0YXR5cGUuXG4gICAqL1xuICBEZW5zZU1hdHJpeC5wcm90b3R5cGUuZGF0YXR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGF0eXBlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgRGVuc2VNYXRyaXhcbiAgICogQG1lbWJlcm9mIERlbnNlTWF0cml4XG4gICAqIEBwYXJhbSB7QXJyYXl9IGRhdGFcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtkYXRhdHlwZV1cbiAgICovXG4gIERlbnNlTWF0cml4LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoZGF0YSwgZGF0YXR5cGUpIHtcbiAgICByZXR1cm4gbmV3IERlbnNlTWF0cml4KGRhdGEsIGRhdGF0eXBlKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGEgc3Vic2V0IG9mIHRoZSBtYXRyaXgsIG9yIHJlcGxhY2UgYSBzdWJzZXQgb2YgdGhlIG1hdHJpeC5cbiAgICpcbiAgICogVXNhZ2U6XG4gICAqICAgICB2YXIgc3Vic2V0ID0gbWF0cml4LnN1YnNldChpbmRleCkgICAgICAgICAgICAgICAvLyByZXRyaWV2ZSBzdWJzZXRcbiAgICogICAgIHZhciB2YWx1ZSA9IG1hdHJpeC5zdWJzZXQoaW5kZXgsIHJlcGxhY2VtZW50KSAgIC8vIHJlcGxhY2Ugc3Vic2V0XG4gICAqXG4gICAqIEBtZW1iZXJvZiBEZW5zZU1hdHJpeFxuICAgKiBAcGFyYW0ge0luZGV4fSBpbmRleFxuICAgKiBAcGFyYW0ge0FycmF5IHwgRGVuc2VNYXRyaXggfCAqfSBbcmVwbGFjZW1lbnRdXG4gICAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZT0wXSAgICAgIERlZmF1bHQgdmFsdWUsIGZpbGxlZCBpbiBvbiBuZXcgZW50cmllcyB3aGVuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBtYXRyaXggaXMgcmVzaXplZC4gSWYgbm90IHByb3ZpZGVkLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgbWF0cml4IGVsZW1lbnRzIHdpbGwgYmUgZmlsbGVkIHdpdGggemVyb3MuXG4gICAqL1xuICBEZW5zZU1hdHJpeC5wcm90b3R5cGUuc3Vic2V0ID0gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBfZ2V0KHRoaXMsIGluZGV4KTtcblxuICAgICAgICAvLyBpbnRlbnRpb25hbCBmYWxsIHRocm91Z2hcbiAgICAgIGNhc2UgMjpcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuIF9zZXQodGhpcywgaW5kZXgsIHJlcGxhY2VtZW50LCBkZWZhdWx0VmFsdWUpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1dyb25nIG51bWJlciBvZiBhcmd1bWVudHMnKTtcbiAgICB9XG4gIH07XG4gIFxuICAvKipcbiAgICogR2V0IGEgc2luZ2xlIGVsZW1lbnQgZnJvbSB0aGUgbWF0cml4LlxuICAgKiBAbWVtYmVyb2YgRGVuc2VNYXRyaXhcbiAgICogQHBhcmFtIHtudW1iZXJbXX0gaW5kZXggICBaZXJvLWJhc2VkIGluZGV4XG4gICAqIEByZXR1cm4geyp9IHZhbHVlXG4gICAqL1xuICBEZW5zZU1hdHJpeC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgaWYgKCFpc0FycmF5KGluZGV4KSlcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5IGV4cGVjdGVkJyk7XG4gICAgaWYgKGluZGV4Lmxlbmd0aCAhPSB0aGlzLl9zaXplLmxlbmd0aClcbiAgICAgIHRocm93IG5ldyBEaW1lbnNpb25FcnJvcihpbmRleC5sZW5ndGgsIHRoaXMuX3NpemUubGVuZ3RoKTtcblxuICAgIC8vIGNoZWNrIGluZGV4XG4gICAgZm9yICh2YXIgeCA9IDA7IHggPCBpbmRleC5sZW5ndGg7IHgrKylcbiAgICAgIHZhbGlkYXRlSW5kZXgoaW5kZXhbeF0sIHRoaXMuX3NpemVbeF0pO1xuXG4gICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGluZGV4Lmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIHZhciBpbmRleF9pID0gaW5kZXhbaV07XG4gICAgICB2YWxpZGF0ZUluZGV4KGluZGV4X2ksIGRhdGEubGVuZ3RoKTtcbiAgICAgIGRhdGEgPSBkYXRhW2luZGV4X2ldO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9O1xuICBcbiAgLyoqXG4gICAqIFJlcGxhY2UgYSBzaW5nbGUgZWxlbWVudCBpbiB0aGUgbWF0cml4LlxuICAgKiBAbWVtYmVyb2YgRGVuc2VNYXRyaXhcbiAgICogQHBhcmFtIHtudW1iZXJbXX0gaW5kZXggICBaZXJvLWJhc2VkIGluZGV4XG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSAgICAgICAgRGVmYXVsdCB2YWx1ZSwgZmlsbGVkIGluIG9uIG5ldyBlbnRyaWVzIHdoZW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG1hdHJpeCBpcyByZXNpemVkLiBJZiBub3QgcHJvdmlkZWQsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBtYXRyaXggZWxlbWVudHMgd2lsbCBiZSBsZWZ0IHVuZGVmaW5lZC5cbiAgICogQHJldHVybiB7RGVuc2VNYXRyaXh9IHNlbGZcbiAgICovXG4gIERlbnNlTWF0cml4LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAoIWlzQXJyYXkoaW5kZXgpKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkgZXhwZWN0ZWQnKTtcbiAgICBpZiAoaW5kZXgubGVuZ3RoIDwgdGhpcy5fc2l6ZS5sZW5ndGgpXG4gICAgICB0aHJvdyBuZXcgRGltZW5zaW9uRXJyb3IoaW5kZXgubGVuZ3RoLCB0aGlzLl9zaXplLmxlbmd0aCwgJzwnKTtcblxuICAgIHZhciBpLCBpaSwgaW5kZXhfaTtcblxuICAgIC8vIGVubGFyZ2UgbWF0cml4IHdoZW4gbmVlZGVkXG4gICAgdmFyIHNpemUgPSBpbmRleC5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBpICsgMTtcbiAgICB9KTtcbiAgICBfZml0KHRoaXMsIHNpemUsIGRlZmF1bHRWYWx1ZSk7XG5cbiAgICAvLyB0cmF2ZXJzZSBvdmVyIHRoZSBkaW1lbnNpb25zXG4gICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgIGZvciAoaSA9IDAsIGlpID0gaW5kZXgubGVuZ3RoIC0gMTsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGluZGV4X2kgPSBpbmRleFtpXTtcbiAgICAgIHZhbGlkYXRlSW5kZXgoaW5kZXhfaSwgZGF0YS5sZW5ndGgpO1xuICAgICAgZGF0YSA9IGRhdGFbaW5kZXhfaV07XG4gICAgfVxuXG4gICAgLy8gc2V0IG5ldyB2YWx1ZVxuICAgIGluZGV4X2kgPSBpbmRleFtpbmRleC5sZW5ndGggLSAxXTtcbiAgICB2YWxpZGF0ZUluZGV4KGluZGV4X2ksIGRhdGEubGVuZ3RoKTtcbiAgICBkYXRhW2luZGV4X2ldID0gdmFsdWU7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBHZXQgYSBzdWJtYXRyaXggb2YgdGhpcyBtYXRyaXhcbiAgICogQG1lbWJlcm9mIERlbnNlTWF0cml4XG4gICAqIEBwYXJhbSB7RGVuc2VNYXRyaXh9IG1hdHJpeFxuICAgKiBAcGFyYW0ge0luZGV4fSBpbmRleCAgIFplcm8tYmFzZWQgaW5kZXhcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9nZXQgKG1hdHJpeCwgaW5kZXgpIHtcbiAgICBpZiAoIWluZGV4IHx8IGluZGV4LmlzSW5kZXggIT09IHRydWUpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaW5kZXgnKTtcbiAgICB9XG5cbiAgICB2YXIgaXNTY2FsYXIgPSBpbmRleC5pc1NjYWxhcigpO1xuICAgIGlmIChpc1NjYWxhcikge1xuICAgICAgLy8gcmV0dXJuIGEgc2NhbGFyXG4gICAgICByZXR1cm4gbWF0cml4LmdldChpbmRleC5taW4oKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gdmFsaWRhdGUgZGltZW5zaW9uc1xuICAgICAgdmFyIHNpemUgPSBpbmRleC5zaXplKCk7XG4gICAgICBpZiAoc2l6ZS5sZW5ndGggIT0gbWF0cml4Ll9zaXplLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRGltZW5zaW9uRXJyb3Ioc2l6ZS5sZW5ndGgsIG1hdHJpeC5fc2l6ZS5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZGF0ZSBpZiBhbnkgb2YgdGhlIHJhbmdlcyBpbiB0aGUgaW5kZXggaXMgb3V0IG9mIHJhbmdlXG4gICAgICB2YXIgbWluID0gaW5kZXgubWluKCk7XG4gICAgICB2YXIgbWF4ID0gaW5kZXgubWF4KCk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBtYXRyaXguX3NpemUubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICB2YWxpZGF0ZUluZGV4KG1pbltpXSwgbWF0cml4Ll9zaXplW2ldKTtcbiAgICAgICAgdmFsaWRhdGVJbmRleChtYXhbaV0sIG1hdHJpeC5fc2l6ZVtpXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHJldHJpZXZlIHN1Ym1hdHJpeFxuICAgICAgLy8gVE9ETzogbW9yZSBlZmZpY2llbnQgd2hlbiBjcmVhdGluZyBhbiBlbXB0eSBtYXRyaXggYW5kIHNldHRpbmcgX2RhdGEgYW5kIF9zaXplIG1hbnVhbGx5XG4gICAgICByZXR1cm4gbmV3IERlbnNlTWF0cml4KF9nZXRTdWJtYXRyaXgobWF0cml4Ll9kYXRhLCBpbmRleCwgc2l6ZS5sZW5ndGgsIDApLCBtYXRyaXguX2RhdGF0eXBlKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBSZWN1cnNpdmVseSBnZXQgYSBzdWJtYXRyaXggb2YgYSBtdWx0aSBkaW1lbnNpb25hbCBtYXRyaXguXG4gICAqIEluZGV4IGlzIG5vdCBjaGVja2VkIGZvciBjb3JyZWN0IG51bWJlciBvciBsZW5ndGggb2YgZGltZW5zaW9ucy5cbiAgICogQG1lbWJlcm9mIERlbnNlTWF0cml4XG4gICAqIEBwYXJhbSB7QXJyYXl9IGRhdGFcbiAgICogQHBhcmFtIHtJbmRleH0gaW5kZXhcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRpbXMgICBUb3RhbCBudW1iZXIgb2YgZGltZW5zaW9uc1xuICAgKiBAcGFyYW0ge251bWJlcn0gZGltICAgIEN1cnJlbnQgZGltZW5zaW9uXG4gICAqIEByZXR1cm4ge0FycmF5fSBzdWJtYXRyaXhcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9nZXRTdWJtYXRyaXggKGRhdGEsIGluZGV4LCBkaW1zLCBkaW0pIHtcbiAgICB2YXIgbGFzdCA9IChkaW0gPT0gZGltcyAtIDEpO1xuICAgIHZhciByYW5nZSA9IGluZGV4LmRpbWVuc2lvbihkaW0pO1xuXG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIHJldHVybiByYW5nZS5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFbaV07XG4gICAgICB9KS52YWx1ZU9mKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIHJhbmdlLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICB2YXIgY2hpbGQgPSBkYXRhW2ldO1xuICAgICAgICByZXR1cm4gX2dldFN1Ym1hdHJpeChjaGlsZCwgaW5kZXgsIGRpbXMsIGRpbSArIDEpO1xuICAgICAgfSkudmFsdWVPZigpO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIFJlcGxhY2UgYSBzdWJtYXRyaXggaW4gdGhpcyBtYXRyaXhcbiAgICogSW5kZXhlcyBhcmUgemVyby1iYXNlZC5cbiAgICogQG1lbWJlcm9mIERlbnNlTWF0cml4XG4gICAqIEBwYXJhbSB7RGVuc2VNYXRyaXh9IG1hdHJpeFxuICAgKiBAcGFyYW0ge0luZGV4fSBpbmRleFxuICAgKiBAcGFyYW0ge0RlbnNlTWF0cml4IHwgQXJyYXkgfCAqfSBzdWJtYXRyaXhcbiAgICogQHBhcmFtIHsqfSBkZWZhdWx0VmFsdWUgICAgICAgICAgRGVmYXVsdCB2YWx1ZSwgZmlsbGVkIGluIG9uIG5ldyBlbnRyaWVzIHdoZW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG1hdHJpeCBpcyByZXNpemVkLlxuICAgKiBAcmV0dXJuIHtEZW5zZU1hdHJpeH0gbWF0cml4XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfc2V0IChtYXRyaXgsIGluZGV4LCBzdWJtYXRyaXgsIGRlZmF1bHRWYWx1ZSkge1xuICAgIGlmICghaW5kZXggfHwgaW5kZXguaXNJbmRleCAhPT0gdHJ1ZSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBpbmRleCcpO1xuICAgIH1cblxuICAgIC8vIGdldCBpbmRleCBzaXplIGFuZCBjaGVjayB3aGV0aGVyIHRoZSBpbmRleCBjb250YWlucyBhIHNpbmdsZSB2YWx1ZVxuICAgIHZhciBpU2l6ZSA9IGluZGV4LnNpemUoKSxcbiAgICAgICAgaXNTY2FsYXIgPSBpbmRleC5pc1NjYWxhcigpO1xuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBzaXplIG9mIHRoZSBzdWJtYXRyaXgsIGFuZCBjb252ZXJ0IGl0IGludG8gYW4gQXJyYXkgaWYgbmVlZGVkXG4gICAgdmFyIHNTaXplO1xuICAgIGlmIChzdWJtYXRyaXggJiYgc3VibWF0cml4LmlzTWF0cml4ID09PSB0cnVlKSB7XG4gICAgICBzU2l6ZSA9IHN1Ym1hdHJpeC5zaXplKCk7XG4gICAgICBzdWJtYXRyaXggPSBzdWJtYXRyaXgudmFsdWVPZigpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHNTaXplID0gYXJyYXkuc2l6ZShzdWJtYXRyaXgpO1xuICAgIH1cblxuICAgIGlmIChpc1NjYWxhcikge1xuICAgICAgLy8gc2V0IGEgc2NhbGFyXG5cbiAgICAgIC8vIGNoZWNrIHdoZXRoZXIgc3VibWF0cml4IGlzIGEgc2NhbGFyXG4gICAgICBpZiAoc1NpemUubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1NjYWxhciBleHBlY3RlZCcpO1xuICAgICAgfVxuXG4gICAgICBtYXRyaXguc2V0KGluZGV4Lm1pbigpLCBzdWJtYXRyaXgsIGRlZmF1bHRWYWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gc2V0IGEgc3VibWF0cml4XG5cbiAgICAgIC8vIHZhbGlkYXRlIGRpbWVuc2lvbnNcbiAgICAgIGlmIChpU2l6ZS5sZW5ndGggPCBtYXRyaXguX3NpemUubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBEaW1lbnNpb25FcnJvcihpU2l6ZS5sZW5ndGgsIG1hdHJpeC5fc2l6ZS5sZW5ndGgsICc8Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzU2l6ZS5sZW5ndGggPCBpU2l6ZS5sZW5ndGgpIHtcbiAgICAgICAgLy8gY2FsY3VsYXRlIG51bWJlciBvZiBtaXNzaW5nIG91dGVyIGRpbWVuc2lvbnNcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgb3V0ZXIgPSAwO1xuICAgICAgICB3aGlsZSAoaVNpemVbaV0gPT09IDEgJiYgc1NpemVbaV0gPT09IDEpIHtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGlTaXplW2ldID09PSAxKSB7XG4gICAgICAgICAgb3V0ZXIrKztcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1bnNxdWVlemUgYm90aCBvdXRlciBhbmQgaW5uZXIgZGltZW5zaW9uc1xuICAgICAgICBzdWJtYXRyaXggPSBhcnJheS51bnNxdWVlemUoc3VibWF0cml4LCBpU2l6ZS5sZW5ndGgsIG91dGVyLCBzU2l6ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIHdoZXRoZXIgdGhlIHNpemUgb2YgdGhlIHN1Ym1hdHJpeCBtYXRjaGVzIHRoZSBpbmRleCBzaXplXG4gICAgICBpZiAoIW9iamVjdC5kZWVwRXF1YWwoaVNpemUsIHNTaXplKSkge1xuICAgICAgICB0aHJvdyBuZXcgRGltZW5zaW9uRXJyb3IoaVNpemUsIHNTaXplLCAnPicpO1xuICAgICAgfVxuXG4gICAgICAvLyBlbmxhcmdlIG1hdHJpeCB3aGVuIG5lZWRlZFxuICAgICAgdmFyIHNpemUgPSBpbmRleC5tYXgoKS5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIGkgKyAxO1xuICAgICAgfSk7XG4gICAgICBfZml0KG1hdHJpeCwgc2l6ZSwgZGVmYXVsdFZhbHVlKTtcblxuICAgICAgLy8gaW5zZXJ0IHRoZSBzdWIgbWF0cml4XG4gICAgICB2YXIgZGltcyA9IGlTaXplLmxlbmd0aCxcbiAgICAgICAgICBkaW0gPSAwO1xuICAgICAgX3NldFN1Ym1hdHJpeCAobWF0cml4Ll9kYXRhLCBpbmRleCwgc3VibWF0cml4LCBkaW1zLCBkaW0pO1xuICAgIH1cblxuICAgIHJldHVybiBtYXRyaXg7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBSZXBsYWNlIGEgc3VibWF0cml4IG9mIGEgbXVsdGkgZGltZW5zaW9uYWwgbWF0cml4LlxuICAgKiBAbWVtYmVyb2YgRGVuc2VNYXRyaXhcbiAgICogQHBhcmFtIHtBcnJheX0gZGF0YVxuICAgKiBAcGFyYW0ge0luZGV4fSBpbmRleFxuICAgKiBAcGFyYW0ge0FycmF5fSBzdWJtYXRyaXhcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRpbXMgICBUb3RhbCBudW1iZXIgb2YgZGltZW5zaW9uc1xuICAgKiBAcGFyYW0ge251bWJlcn0gZGltXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfc2V0U3VibWF0cml4IChkYXRhLCBpbmRleCwgc3VibWF0cml4LCBkaW1zLCBkaW0pIHtcbiAgICB2YXIgbGFzdCA9IChkaW0gPT0gZGltcyAtIDEpLFxuICAgICAgICByYW5nZSA9IGluZGV4LmRpbWVuc2lvbihkaW0pO1xuXG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIHJhbmdlLmZvckVhY2goZnVuY3Rpb24gKGRhdGFJbmRleCwgc3ViSW5kZXgpIHtcbiAgICAgICAgdmFsaWRhdGVJbmRleChkYXRhSW5kZXgpO1xuICAgICAgICBkYXRhW2RhdGFJbmRleF0gPSBzdWJtYXRyaXhbc3ViSW5kZXhbMF1dO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmFuZ2UuZm9yRWFjaChmdW5jdGlvbiAoZGF0YUluZGV4LCBzdWJJbmRleCkge1xuICAgICAgICB2YWxpZGF0ZUluZGV4KGRhdGFJbmRleCk7XG4gICAgICAgIF9zZXRTdWJtYXRyaXgoZGF0YVtkYXRhSW5kZXhdLCBpbmRleCwgc3VibWF0cml4W3N1YkluZGV4WzBdXSwgZGltcywgZGltICsgMSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBSZXNpemUgdGhlIG1hdHJpeCB0byB0aGUgZ2l2ZW4gc2l6ZS4gUmV0dXJucyBhIGNvcHkgb2YgdGhlIG1hdHJpeCB3aGVuXG4gICAqIGBjb3B5PXRydWVgLCBvdGhlcndpc2UgcmV0dXJuIHRoZSBtYXRyaXggaXRzZWxmIChyZXNpemUgaW4gcGxhY2UpLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgRGVuc2VNYXRyaXhcbiAgICogQHBhcmFtIHtudW1iZXJbXX0gc2l6ZSAgICAgICAgICAgVGhlIG5ldyBzaXplIHRoZSBtYXRyaXggc2hvdWxkIGhhdmUuXG4gICAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZT0wXSAgICAgIERlZmF1bHQgdmFsdWUsIGZpbGxlZCBpbiBvbiBuZXcgZW50cmllcy5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgbm90IHByb3ZpZGVkLCB0aGUgbWF0cml4IGVsZW1lbnRzIHdpbGxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmUgZmlsbGVkIHdpdGggemVyb3MuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NvcHldICAgICAgICAgIFJldHVybiBhIHJlc2l6ZWQgY29weSBvZiB0aGUgbWF0cml4XG4gICAqXG4gICAqIEByZXR1cm4ge01hdHJpeH0gICAgICAgICAgICAgICAgIFRoZSByZXNpemVkIG1hdHJpeFxuICAgKi9cbiAgRGVuc2VNYXRyaXgucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uIChzaXplLCBkZWZhdWx0VmFsdWUsIGNvcHkpIHtcbiAgICAvLyB2YWxpZGF0ZSBhcmd1bWVudHNcbiAgICBpZiAoIWlzQXJyYXkoc2l6ZSkpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheSBleHBlY3RlZCcpO1xuXG4gICAgLy8gbWF0cml4IHRvIHJlc2l6ZVxuICAgIHZhciBtID0gY29weSA/IHRoaXMuY2xvbmUoKSA6IHRoaXM7XG4gICAgLy8gcmVzaXplIG1hdHJpeFxuICAgIHJldHVybiBfcmVzaXplKG0sIHNpemUsIGRlZmF1bHRWYWx1ZSk7XG4gIH07XG4gIFxuICB2YXIgX3Jlc2l6ZSA9IGZ1bmN0aW9uIChtYXRyaXgsIHNpemUsIGRlZmF1bHRWYWx1ZSkge1xuICAgIC8vIGNoZWNrIHNpemVcbiAgICBpZiAoc2l6ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIGZpcnN0IHZhbHVlIGluIG1hdHJpeFxuICAgICAgdmFyIHYgPSBtYXRyaXguX2RhdGE7XG4gICAgICAvLyBnbyBkZWVwXG4gICAgICB3aGlsZSAoaXNBcnJheSh2KSkge1xuICAgICAgICB2ID0gdlswXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICAvLyByZXNpemUgbWF0cml4XG4gICAgbWF0cml4Ll9zaXplID0gc2l6ZS5zbGljZSgwKTsgLy8gY29weSB0aGUgYXJyYXlcbiAgICBtYXRyaXguX2RhdGEgPSBhcnJheS5yZXNpemUobWF0cml4Ll9kYXRhLCBtYXRyaXguX3NpemUsIGRlZmF1bHRWYWx1ZSk7XG4gICAgLy8gcmV0dXJuIG1hdHJpeFxuICAgIHJldHVybiBtYXRyaXg7XG4gIH07XG4gIFxuICAvKipcbiAgICogRW5sYXJnZSB0aGUgbWF0cml4IHdoZW4gaXQgaXMgc21hbGxlciB0aGFuIGdpdmVuIHNpemUuXG4gICAqIElmIHRoZSBtYXRyaXggaXMgbGFyZ2VyIG9yIGVxdWFsIHNpemVkLCBub3RoaW5nIGlzIGRvbmUuXG4gICAqIEBtZW1iZXJvZiBEZW5zZU1hdHJpeFxuICAgKiBAcGFyYW0ge0RlbnNlTWF0cml4fSBtYXRyaXggICAgICAgICAgIFRoZSBtYXRyaXggdG8gYmUgcmVzaXplZFxuICAgKiBAcGFyYW0ge251bWJlcltdfSBzaXplXG4gICAqIEBwYXJhbSB7Kn0gZGVmYXVsdFZhbHVlICAgICAgICAgIERlZmF1bHQgdmFsdWUsIGZpbGxlZCBpbiBvbiBuZXcgZW50cmllcy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9maXQobWF0cml4LCBzaXplLCBkZWZhdWx0VmFsdWUpIHtcbiAgICB2YXIgbmV3U2l6ZSA9IG1hdHJpeC5fc2l6ZS5zbGljZSgwKSwgLy8gY29weSB0aGUgYXJyYXlcbiAgICAgICAgY2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgLy8gYWRkIGRpbWVuc2lvbnMgd2hlbiBuZWVkZWRcbiAgICB3aGlsZSAobmV3U2l6ZS5sZW5ndGggPCBzaXplLmxlbmd0aCkge1xuICAgICAgbmV3U2l6ZS5wdXNoKDApO1xuICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gZW5sYXJnZSBzaXplIHdoZW4gbmVlZGVkXG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gc2l6ZS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBpZiAoc2l6ZVtpXSA+IG5ld1NpemVbaV0pIHtcbiAgICAgICAgbmV3U2l6ZVtpXSA9IHNpemVbaV07XG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAvLyByZXNpemUgb25seSB3aGVuIHNpemUgaXMgY2hhbmdlZFxuICAgICAgX3Jlc2l6ZShtYXRyaXgsIG5ld1NpemUsIGRlZmF1bHRWYWx1ZSk7XG4gICAgfVxuICB9XG4gIFxuICAvKipcbiAgICogQ3JlYXRlIGEgY2xvbmUgb2YgdGhlIG1hdHJpeFxuICAgKiBAbWVtYmVyb2YgRGVuc2VNYXRyaXhcbiAgICogQHJldHVybiB7RGVuc2VNYXRyaXh9IGNsb25lXG4gICAqL1xuICBEZW5zZU1hdHJpeC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG0gPSBuZXcgRGVuc2VNYXRyaXgoe1xuICAgICAgZGF0YTogb2JqZWN0LmNsb25lKHRoaXMuX2RhdGEpLFxuICAgICAgc2l6ZTogb2JqZWN0LmNsb25lKHRoaXMuX3NpemUpLFxuICAgICAgZGF0YXR5cGU6IHRoaXMuX2RhdGF0eXBlXG4gICAgfSk7XG4gICAgcmV0dXJuIG07XG4gIH07XG4gIFxuICAvKipcbiAgICogUmV0cmlldmUgdGhlIHNpemUgb2YgdGhlIG1hdHJpeC5cbiAgICogQG1lbWJlcm9mIERlbnNlTWF0cml4XG4gICAqIEByZXR1cm5zIHtudW1iZXJbXX0gc2l6ZVxuICAgKi9cbiAgRGVuc2VNYXRyaXgucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgbWF0cml4IHdpdGggdGhlIHJlc3VsdHMgb2YgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGV4ZWN1dGVkIG9uXG4gICAqIGVhY2ggZW50cnkgb2YgdGhlIG1hdHJpeC5cbiAgICogQG1lbWJlcm9mIERlbnNlTWF0cml4XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrICAgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudCwgdGhlIGluZGV4XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgdGhlIGVsZW1lbnQsIGFuZCB0aGUgTWF0cml4IGJlaW5nIHRyYXZlcnNlZC5cbiAgICpcbiAgICogQHJldHVybiB7RGVuc2VNYXRyaXh9IG1hdHJpeFxuICAgKi9cbiAgRGVuc2VNYXRyaXgucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIC8vIG1hdHJpeCBpbnN0YW5jZVxuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdmFyIHJlY3Vyc2UgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLm1hcChmdW5jdGlvbiAoY2hpbGQsIGkpIHtcbiAgICAgICAgICByZXR1cm4gcmVjdXJzZShjaGlsZCwgaW5kZXguY29uY2F0KGkpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgbWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgLy8gcmV0dXJuIGRlbnNlIGZvcm1hdFxuICAgIHJldHVybiBuZXcgRGVuc2VNYXRyaXgoe1xuICAgICAgZGF0YTogcmVjdXJzZSh0aGlzLl9kYXRhLCBbXSksXG4gICAgICBzaXplOiBvYmplY3QuY2xvbmUodGhpcy5fc2l6ZSksXG4gICAgICBkYXRhdHlwZTogdGhpcy5fZGF0YXR5cGVcbiAgICB9KTtcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBFeGVjdXRlIGEgY2FsbGJhY2sgZnVuY3Rpb24gb24gZWFjaCBlbnRyeSBvZiB0aGUgbWF0cml4LlxuICAgKiBAbWVtYmVyb2YgRGVuc2VNYXRyaXhcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgICBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyczogdGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50LCB0aGUgaW5kZXhcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiB0aGUgZWxlbWVudCwgYW5kIHRoZSBNYXRyaXggYmVpbmcgdHJhdmVyc2VkLlxuICAgKi9cbiAgRGVuc2VNYXRyaXgucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAvLyBtYXRyaXggaW5zdGFuY2VcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciByZWN1cnNlID0gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkLCBpKSB7XG4gICAgICAgICAgcmVjdXJzZShjaGlsZCwgaW5kZXguY29uY2F0KGkpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sodmFsdWUsIGluZGV4LCBtZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZWN1cnNlKHRoaXMuX2RhdGEsIFtdKTtcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gQXJyYXkgd2l0aCBhIGNvcHkgb2YgdGhlIGRhdGEgb2YgdGhlIERlbnNlTWF0cml4XG4gICAqIEBtZW1iZXJvZiBEZW5zZU1hdHJpeFxuICAgKiBAcmV0dXJucyB7QXJyYXl9IGFycmF5XG4gICAqL1xuICBEZW5zZU1hdHJpeC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gb2JqZWN0LmNsb25lKHRoaXMuX2RhdGEpO1xuICB9O1xuICBcbiAgLyoqXG4gICAqIEdldCB0aGUgcHJpbWl0aXZlIHZhbHVlIG9mIHRoZSBEZW5zZU1hdHJpeDogYSBtdWx0aWRpbWVuc2lvbmFsIGFycmF5XG4gICAqIEBtZW1iZXJvZiBEZW5zZU1hdHJpeFxuICAgKiBAcmV0dXJucyB7QXJyYXl9IGFycmF5XG4gICAqL1xuICBEZW5zZU1hdHJpeC5wcm90b3R5cGUudmFsdWVPZiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBHZXQgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeCwgd2l0aCBvcHRpb25hbCBmb3JtYXR0aW5nIG9wdGlvbnMuXG4gICAqIEBtZW1iZXJvZiBEZW5zZU1hdHJpeFxuICAgKiBAcGFyYW0ge09iamVjdCB8IG51bWJlciB8IEZ1bmN0aW9ufSBbb3B0aW9uc10gIEZvcm1hdHRpbmcgb3B0aW9ucy4gU2VlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGliL3V0aWxzL251bWJlcjpmb3JtYXQgZm9yIGFcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbiBvZiB0aGUgYXZhaWxhYmxlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5cbiAgICogQHJldHVybnMge3N0cmluZ30gc3RyXG4gICAqL1xuICBEZW5zZU1hdHJpeC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gc3RyaW5nLmZvcm1hdCh0aGlzLl9kYXRhLCBvcHRpb25zKTtcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBHZXQgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICAgKiBAbWVtYmVyb2YgRGVuc2VNYXRyaXhcbiAgICogQHJldHVybnMge3N0cmluZ30gc3RyXG4gICAqL1xuICBEZW5zZU1hdHJpeC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHN0cmluZy5mb3JtYXQodGhpcy5fZGF0YSk7XG4gIH07XG4gIFxuICAvKipcbiAgICogR2V0IGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XG4gICAqIEBtZW1iZXJvZiBEZW5zZU1hdHJpeFxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKi9cbiAgRGVuc2VNYXRyaXgucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWF0aGpzOiAnRGVuc2VNYXRyaXgnLFxuICAgICAgZGF0YTogdGhpcy5fZGF0YSxcbiAgICAgIHNpemU6IHRoaXMuX3NpemUsXG4gICAgICBkYXRhdHlwZTogdGhpcy5fZGF0YXR5cGVcbiAgICB9O1xuICB9O1xuICBcbiAgLyoqXG4gICAqIEdldCB0aGUga3RoIE1hdHJpeCBkaWFnb25hbC5cbiAgICpcbiAgICogQG1lbWJlcm9mIERlbnNlTWF0cml4XG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgQmlnTnVtYmVyfSBbaz0wXSAgICAgVGhlIGt0aCBkaWFnb25hbCB3aGVyZSB0aGUgdmVjdG9yIHdpbGwgcmV0cmlldmVkLlxuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXl9ICAgICAgICAgICAgICAgICAgICAgIFRoZSBhcnJheSB2ZWN0b3Igd2l0aCB0aGUgZGlhZ29uYWwgdmFsdWVzLlxuICAgKi9cbiAgRGVuc2VNYXRyaXgucHJvdG90eXBlLmRpYWdvbmFsID0gZnVuY3Rpb24oaykge1xuICAgIC8vIHZhbGlkYXRlIGsgaWYgYW55XG4gICAgaWYgKGspIHtcbiAgICAgIC8vIGNvbnZlcnQgQmlnTnVtYmVyIHRvIGEgbnVtYmVyXG4gICAgICBpZiAoay5pc0JpZ051bWJlciA9PT0gdHJ1ZSlcbiAgICAgICAgayA9IGsudG9OdW1iZXIoKTtcbiAgICAgIC8vIGlzIG11c3QgYmUgYW4gaW50ZWdlclxuICAgICAgaWYgKCFpc051bWJlcihrKSB8fCAhaXNJbnRlZ2VyKGspKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IgKCdUaGUgcGFyYW1ldGVyIGsgbXVzdCBiZSBhbiBpbnRlZ2VyIG51bWJlcicpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGRlZmF1bHQgdmFsdWVcbiAgICAgIGsgPSAwO1xuICAgIH1cblxuICAgIHZhciBrU3VwZXIgPSBrID4gMCA/IGsgOiAwO1xuICAgIHZhciBrU3ViID0gayA8IDAgPyAtayA6IDA7XG5cbiAgICAvLyByb3dzICYgY29sdW1uc1xuICAgIHZhciByb3dzID0gdGhpcy5fc2l6ZVswXTtcbiAgICB2YXIgY29sdW1ucyA9IHRoaXMuX3NpemVbMV07XG5cbiAgICAvLyBudW1iZXIgZGlhZ29uYWwgdmFsdWVzXG4gICAgdmFyIG4gPSBNYXRoLm1pbihyb3dzIC0ga1N1YiwgY29sdW1ucyAtICBrU3VwZXIpO1xuICAgIFxuICAgIC8vIHggaXMgYSBtYXRyaXggZ2V0IGRpYWdvbmFsIGZyb20gbWF0cml4XG4gICAgdmFyIGRhdGEgPSBbXTtcbiAgICBcbiAgICAvLyBsb29wIHJvd3NcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgZGF0YVtpXSA9IHRoaXMuX2RhdGFbaSArIGtTdWJdW2kgKyBrU3VwZXJdO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBEZW5zZU1hdHJpeFxuICAgIHJldHVybiBuZXcgRGVuc2VNYXRyaXgoe1xuICAgICAgZGF0YTogZGF0YSxcbiAgICAgIHNpemU6IFtuXSxcbiAgICAgIGRhdGF0eXBlOiB0aGlzLl9kYXRhdHlwZVxuICAgIH0pO1xuICB9O1xuICBcbiAgLyoqXG4gICAqIENyZWF0ZSBhIGRpYWdvbmFsIG1hdHJpeC5cbiAgICpcbiAgICogQG1lbWJlcm9mIERlbnNlTWF0cml4XG4gICAqIEBwYXJhbSB7QXJyYXl9IHNpemUgICAgICAgICAgICAgICAgICAgVGhlIG1hdHJpeCBzaXplLlxuICAgKiBAcGFyYW0ge251bWJlciB8IEFycmF5fSB2YWx1ZSAgICAgICAgICBUaGUgdmFsdWVzIGZvciB0aGUgZGlhZ29uYWwuXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgQmlnTnVtYmVyfSBbaz0wXSAgICAgVGhlIGt0aCBkaWFnb25hbCB3aGVyZSB0aGUgdmVjdG9yIHdpbGwgYmUgZmlsbGVkIGluLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RlZmF1bHRWYWx1ZV0gICAgICAgIFRoZSBkZWZhdWx0IHZhbHVlIGZvciBub24tZGlhZ29uYWxcbiAgICpcbiAgICogQHJldHVybnMge0RlbnNlTWF0cml4fVxuICAgKi9cbiAgRGVuc2VNYXRyaXguZGlhZ29uYWwgPSBmdW5jdGlvbiAoc2l6ZSwgdmFsdWUsIGssIGRlZmF1bHRWYWx1ZSwgZGF0YXR5cGUpIHtcbiAgICBpZiAoIWlzQXJyYXkoc2l6ZSkpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheSBleHBlY3RlZCwgc2l6ZSBwYXJhbWV0ZXInKTtcbiAgICBpZiAoc2l6ZS5sZW5ndGggIT09IDIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgdHdvIGRpbWVuc2lvbnMgbWF0cml4IGFyZSBzdXBwb3J0ZWQnKTtcblxuICAgIC8vIG1hcCBzaXplICYgdmFsaWRhdGVcbiAgICBzaXplID0gc2l6ZS5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgIC8vIGNoZWNrIGl0IGlzIGEgYmlnIG51bWJlclxuICAgICAgaWYgKHMgJiYgcy5pc0JpZ051bWJlciA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBjb252ZXJ0IGl0XG4gICAgICAgIHMgPSBzLnRvTnVtYmVyKCk7XG4gICAgICB9XG4gICAgICAvLyB2YWxpZGF0ZSBhcmd1bWVudHNcbiAgICAgIGlmICghaXNOdW1iZXIocykgfHwgIWlzSW50ZWdlcihzKSB8fCBzIDwgMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NpemUgdmFsdWVzIG11c3QgYmUgcG9zaXRpdmUgaW50ZWdlcnMnKTtcbiAgICAgIH0gXG4gICAgICByZXR1cm4gcztcbiAgICB9KTtcblxuICAgIC8vIHZhbGlkYXRlIGsgaWYgYW55XG4gICAgaWYgKGspIHtcbiAgICAgIC8vIGNvbnZlcnQgQmlnTnVtYmVyIHRvIGEgbnVtYmVyXG4gICAgICBpZiAoayAmJiBrLmlzQmlnTnVtYmVyID09PSB0cnVlKVxuICAgICAgICBrID0gay50b051bWJlcigpO1xuICAgICAgLy8gaXMgbXVzdCBiZSBhbiBpbnRlZ2VyXG4gICAgICBpZiAoIWlzTnVtYmVyKGspIHx8ICFpc0ludGVnZXIoaykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvciAoJ1RoZSBwYXJhbWV0ZXIgayBtdXN0IGJlIGFuIGludGVnZXIgbnVtYmVyJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gZGVmYXVsdCB2YWx1ZVxuICAgICAgayA9IDA7XG4gICAgfVxuICAgIFxuICAgIGlmIChkZWZhdWx0VmFsdWUgJiYgaXNTdHJpbmcoZGF0YXR5cGUpKSB7XG4gICAgICAvLyBjb252ZXJ0IGRlZmF1bHRWYWx1ZSB0byB0aGUgc2FtZSBkYXRhdHlwZVxuICAgICAgZGVmYXVsdFZhbHVlID0gdHlwZWQuY29udmVydChkZWZhdWx0VmFsdWUsIGRhdGF0eXBlKTtcbiAgICB9XG5cbiAgICB2YXIga1N1cGVyID0gayA+IDAgPyBrIDogMDtcbiAgICB2YXIga1N1YiA9IGsgPCAwID8gLWsgOiAwO1xuICAgIFxuICAgIC8vIHJvd3MgYW5kIGNvbHVtbnNcbiAgICB2YXIgcm93cyA9IHNpemVbMF07XG4gICAgdmFyIGNvbHVtbnMgPSBzaXplWzFdO1xuXG4gICAgLy8gbnVtYmVyIG9mIG5vbi16ZXJvIGl0ZW1zXG4gICAgdmFyIG4gPSBNYXRoLm1pbihyb3dzIC0ga1N1YiwgY29sdW1ucyAtICBrU3VwZXIpO1xuXG4gICAgLy8gdmFsdWUgZXh0cmFjdGlvbiBmdW5jdGlvblxuICAgIHZhciBfdmFsdWU7XG5cbiAgICAvLyBjaGVjayB2YWx1ZVxuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgLy8gdmFsaWRhdGUgYXJyYXlcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggIT09IG4pIHtcbiAgICAgICAgLy8gbnVtYmVyIG9mIHZhbHVlcyBpbiBhcnJheSBtdXN0IGJlIG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlIGFycmF5IGxlbmd0aCcpO1xuICAgICAgfVxuICAgICAgLy8gZGVmaW5lIGZ1bmN0aW9uXG4gICAgICBfdmFsdWUgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAvLyByZXR1cm4gdmFsdWUgQCBpXG4gICAgICAgIHJldHVybiB2YWx1ZVtpXTtcbiAgICAgIH07ICAgICAgXG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlICYmIHZhbHVlLmlzTWF0cml4ID09PSB0cnVlKSB7XG4gICAgICAvLyBtYXRyaXggc2l6ZVxuICAgICAgdmFyIG1zID0gdmFsdWUuc2l6ZSgpO1xuICAgICAgLy8gdmFsaWRhdGUgbWF0cml4XG4gICAgICBpZiAobXMubGVuZ3RoICE9PSAxIHx8IG1zWzBdICE9PSBuKSB7XG4gICAgICAgIC8vIG51bWJlciBvZiB2YWx1ZXMgaW4gYXJyYXkgbXVzdCBiZSBuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtYXRyaXggbGVuZ3RoJyk7XG4gICAgICB9XG4gICAgICAvLyBkZWZpbmUgZnVuY3Rpb25cbiAgICAgIF92YWx1ZSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIC8vIHJldHVybiB2YWx1ZSBAIGlcbiAgICAgICAgcmV0dXJuIHZhbHVlLmdldChbaV0pO1xuICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBkZWZpbmUgZnVuY3Rpb25cbiAgICAgIF92YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gcmV0dXJuIHZhbHVlXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIC8vIGRpc2NvdmVyIGRlZmF1bHQgdmFsdWUgaWYgbmVlZGVkXG4gICAgaWYgKCFkZWZhdWx0VmFsdWUpIHtcbiAgICAgIC8vIGNoZWNrIGZpcnN0IHZhbHVlIGluIGFycmF5XG4gICAgICBkZWZhdWx0VmFsdWUgPSAoX3ZhbHVlKDApICYmIF92YWx1ZSgwKS5pc0JpZ051bWJlciA9PT0gdHJ1ZSkgPyBuZXcgdHlwZS5CaWdOdW1iZXIoMCkgOiAwO1xuICAgIH1cblxuICAgIC8vIGVtcHR5IGFycmF5XG4gICAgdmFyIGRhdGEgPSBbXTtcblxuICAgIC8vIGNoZWNrIHdlIG5lZWQgdG8gcmVzaXplIGFycmF5XG4gICAgaWYgKHNpemUubGVuZ3RoID4gMCkge1xuICAgICAgLy8gcmVzaXplIGFycmF5XG4gICAgICBkYXRhID0gYXJyYXkucmVzaXplKGRhdGEsIHNpemUsIGRlZmF1bHRWYWx1ZSk7XG4gICAgICAvLyBmaWxsIGRpYWdvbmFsXG4gICAgICBmb3IgKHZhciBkID0gMDsgZCA8IG47IGQrKykge1xuICAgICAgICBkYXRhW2QgKyBrU3ViXVtkICsga1N1cGVyXSA9IF92YWx1ZShkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gY3JlYXRlIERlbnNlTWF0cml4XG4gICAgcmV0dXJuIG5ldyBEZW5zZU1hdHJpeCh7XG4gICAgICBkYXRhOiBkYXRhLFxuICAgICAgc2l6ZTogW3Jvd3MsIGNvbHVtbnNdXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgbWF0cml4IGZyb20gYSBKU09OIG9iamVjdFxuICAgKiBAbWVtYmVyb2YgRGVuc2VNYXRyaXhcbiAgICogQHBhcmFtIHtPYmplY3R9IGpzb24gIEFuIG9iamVjdCBzdHJ1Y3R1cmVkIGxpa2VcbiAgICogICAgICAgICAgICAgICAgICAgICAgIGB7XCJtYXRoanNcIjogXCJEZW5zZU1hdHJpeFwiLCBkYXRhOiBbXSwgc2l6ZTogW119YCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgIHdoZXJlIG1hdGhqcyBpcyBvcHRpb25hbFxuICAgKiBAcmV0dXJucyB7RGVuc2VNYXRyaXh9XG4gICAqL1xuICBEZW5zZU1hdHJpeC5mcm9tSlNPTiA9IGZ1bmN0aW9uIChqc29uKSB7XG4gICAgcmV0dXJuIG5ldyBEZW5zZU1hdHJpeChqc29uKTtcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBTd2FwIHJvd3MgaSBhbmQgaiBpbiBNYXRyaXguXG4gICAqXG4gICAqIEBtZW1iZXJvZiBEZW5zZU1hdHJpeFxuICAgKiBAcGFyYW0ge251bWJlcn0gaSAgICAgICBNYXRyaXggcm93IGluZGV4IDFcbiAgICogQHBhcmFtIHtudW1iZXJ9IGogICAgICAgTWF0cml4IHJvdyBpbmRleCAyXG4gICAqXG4gICAqIEByZXR1cm4ge01hdHJpeH0gICAgICAgIFRoZSBtYXRyaXggcmVmZXJlbmNlXG4gICAqL1xuICBEZW5zZU1hdHJpeC5wcm90b3R5cGUuc3dhcFJvd3MgPSBmdW5jdGlvbiAoaSwgaikge1xuICAgIC8vIGNoZWNrIGluZGV4XG4gICAgaWYgKCFpc051bWJlcihpKSB8fCAhaXNJbnRlZ2VyKGkpIHx8ICFpc051bWJlcihqKSB8fCAhaXNJbnRlZ2VyKGopKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JvdyBpbmRleCBtdXN0IGJlIHBvc2l0aXZlIGludGVnZXJzJyk7XG4gICAgfVxuICAgIC8vIGNoZWNrIGRpbWVuc2lvbnNcbiAgICBpZiAodGhpcy5fc2l6ZS5sZW5ndGggIT09IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT25seSB0d28gZGltZW5zaW9uYWwgbWF0cml4IGlzIHN1cHBvcnRlZCcpO1xuICAgIH1cbiAgICAvLyB2YWxpZGF0ZSBpbmRleFxuICAgIHZhbGlkYXRlSW5kZXgoaSwgdGhpcy5fc2l6ZVswXSk7XG4gICAgdmFsaWRhdGVJbmRleChqLCB0aGlzLl9zaXplWzBdKTtcblxuICAgIC8vIHN3YXAgcm93c1xuICAgIERlbnNlTWF0cml4Ll9zd2FwUm93cyhpLCBqLCB0aGlzLl9kYXRhKTtcbiAgICAvLyByZXR1cm4gY3VycmVudCBpbnN0YW5jZVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTd2FwIHJvd3MgaSBhbmQgaiBpbiBEZW5zZSBNYXRyaXggZGF0YSBzdHJ1Y3R1cmUuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpICAgICAgIE1hdHJpeCByb3cgaW5kZXggMVxuICAgKiBAcGFyYW0ge251bWJlcn0gaiAgICAgICBNYXRyaXggcm93IGluZGV4IDJcbiAgICovXG4gIERlbnNlTWF0cml4Ll9zd2FwUm93cyA9IGZ1bmN0aW9uIChpLCBqLCBkYXRhKSB7XG4gICAgLy8gc3dhcCB2YWx1ZXMgaSA8LT4galxuICAgIHZhciB2aSA9IGRhdGFbaV07XG4gICAgZGF0YVtpXSA9IGRhdGFbal07XG4gICAgZGF0YVtqXSA9IHZpO1xuICB9O1xuICAgXG4gIC8qKlxuICAgKiBQcmVwcm9jZXNzIGRhdGEsIHdoaWNoIGNhbiBiZSBhbiBBcnJheSBvciBEZW5zZU1hdHJpeCB3aXRoIG5lc3RlZCBBcnJheXMgYW5kXG4gICAqIE1hdHJpY2VzLiBSZXBsYWNlcyBhbGwgbmVzdGVkIE1hdHJpY2VzIHdpdGggQXJyYXlzXG4gICAqIEBtZW1iZXJvZiBEZW5zZU1hdHJpeFxuICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhXG4gICAqIEByZXR1cm4ge0FycmF5fSBkYXRhXG4gICAqL1xuICBmdW5jdGlvbiBwcmVwcm9jZXNzKGRhdGEpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBkYXRhLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIHZhciBlbGVtID0gZGF0YVtpXTtcbiAgICAgIGlmIChpc0FycmF5KGVsZW0pKSB7XG4gICAgICAgIGRhdGFbaV0gPSBwcmVwcm9jZXNzKGVsZW0pO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZWxlbSAmJiBlbGVtLmlzTWF0cml4ID09PSB0cnVlKSB7XG4gICAgICAgIGRhdGFbaV0gPSBwcmVwcm9jZXNzKGVsZW0udmFsdWVPZigpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIC8vIHJlZ2lzdGVyIHRoaXMgdHlwZSBpbiB0aGUgYmFzZSBjbGFzcyBNYXRyaXhcbiAgdHlwZS5NYXRyaXguX3N0b3JhZ2UuZGVuc2UgPSBEZW5zZU1hdHJpeDtcbiAgdHlwZS5NYXRyaXguX3N0b3JhZ2VbJ2RlZmF1bHQnXSA9IERlbnNlTWF0cml4O1xuXG4gIC8vIGV4cG9ydHNcbiAgcmV0dXJuIERlbnNlTWF0cml4O1xufVxuXG5leHBvcnRzLm5hbWUgPSAnRGVuc2VNYXRyaXgnO1xuZXhwb3J0cy5wYXRoID0gJ3R5cGUnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbmV4cG9ydHMubGF6eSA9IGZhbHNlOyAgLy8gbm8gbGF6eSBsb2FkaW5nLCBhcyB3ZSBhbHRlciB0eXBlLk1hdHJpeC5fc3RvcmFnZSIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICBcbiAgdmFyIHNtYWxsZXIgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL2Z1bmN0aW9uL3JlbGF0aW9uYWwvc21hbGxlcicpKTtcbiAgdmFyIGxhcmdlciA9IGxvYWQocmVxdWlyZSgnLi4vLi4vZnVuY3Rpb24vcmVsYXRpb25hbC9sYXJnZXInKSk7XG4gIFxuICB2YXIgb25lT3ZlckxvZ1BoaSA9IDEuMCAvIE1hdGgubG9nKCgxLjAgKyBNYXRoLnNxcnQoNS4wKSkgLyAyLjApO1xuICBcbiAgLyoqXG4gICAqIEZpYm9uYWNjaSBIZWFwIGltcGxlbWVudGF0aW9uLCB1c2VkIGludGVyYWxseSBmb3IgTWF0cml4IG1hdGguXG4gICAqIEBjbGFzcyBGaWJvbmFjY2lIZWFwXG4gICAqIEBjb25zdHJ1Y3RvciBGaWJvbmFjY2lIZWFwXG4gICAqL1xuICBmdW5jdGlvbiBGaWJvbmFjY2lIZWFwKCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBGaWJvbmFjY2lIZWFwKSlcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQ29uc3RydWN0b3IgbXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgbmV3IG9wZXJhdG9yJyk7XG5cbiAgICAvLyBpbml0aWFsaXplIGZpZWxkc1xuICAgIHRoaXMuX21pbmltdW0gPSBudWxsO1xuICAgIHRoaXMuX3NpemUgPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGFjaCB0eXBlIGluZm9ybWF0aW9uXG4gICAqL1xuICBGaWJvbmFjY2lIZWFwLnByb3RvdHlwZS50eXBlID0gJ0ZpYm9uYWNjaUhlYXAnO1xuICBGaWJvbmFjY2lIZWFwLnByb3RvdHlwZS5pc0ZpYm9uYWNjaUhlYXAgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBJbnNlcnRzIGEgbmV3IGRhdGEgZWxlbWVudCBpbnRvIHRoZSBoZWFwLiBObyBoZWFwIGNvbnNvbGlkYXRpb24gaXNcbiAgICogcGVyZm9ybWVkIGF0IHRoaXMgdGltZSwgdGhlIG5ldyBub2RlIGlzIHNpbXBseSBpbnNlcnRlZCBpbnRvIHRoZSByb290XG4gICAqIGxpc3Qgb2YgdGhpcyBoZWFwLiBSdW5uaW5nIHRpbWU6IE8oMSkgYWN0dWFsLlxuICAgKiBAbWVtYmVyb2YgRmlib25hY2NpSGVhcFxuICAgKi9cbiAgRmlib25hY2NpSGVhcC5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAvLyBjcmVhdGUgbm9kZVxuICAgIHZhciBub2RlID0ge1xuICAgICAga2V5OiBrZXksXG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBkZWdyZWU6IDBcbiAgICB9O1xuICAgIC8vIGNoZWNrIHdlIGhhdmUgYSBub2RlIGluIHRoZSBtaW5pbXVtXG4gICAgaWYgKHRoaXMuX21pbmltdW0pIHtcbiAgICAgIC8vIG1pbmltdW0gbm9kZVxuICAgICAgdmFyIG1pbmltdW0gPSB0aGlzLl9taW5pbXVtO1xuICAgICAgLy8gdXBkYXRlIGxlZnQgJiByaWdodCBvZiBub2RlXG4gICAgICBub2RlLmxlZnQgPSBtaW5pbXVtO1xuICAgICAgbm9kZS5yaWdodCA9IG1pbmltdW0ucmlnaHQ7XG4gICAgICBtaW5pbXVtLnJpZ2h0ID0gbm9kZTtcbiAgICAgIG5vZGUucmlnaHQubGVmdCA9IG5vZGU7XG4gICAgICAvLyB1cGRhdGUgbWluaW11bSBub2RlIGluIGhlYXAgaWYgbmVlZGVkXG4gICAgICBpZiAoc21hbGxlcihrZXksIG1pbmltdW0ua2V5KSkge1xuICAgICAgICAvLyBub2RlIGhhcyBhIHNtYWxsZXIga2V5LCB1c2UgaXQgYXMgbWluaW11bVxuICAgICAgICB0aGlzLl9taW5pbXVtID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBzZXQgbGVmdCAmIHJpZ2h0XG4gICAgICBub2RlLmxlZnQgPSBub2RlO1xuICAgICAgbm9kZS5yaWdodCA9IG5vZGU7XG4gICAgICAvLyB0aGlzIGlzIHRoZSBmaXJzdCBub2RlXG4gICAgICB0aGlzLl9taW5pbXVtID0gbm9kZTtcbiAgICB9XG4gICAgLy8gaW5jcmVtZW50IG51bWJlciBvZiBub2RlcyBpbiBoZWFwXG4gICAgdGhpcy5fc2l6ZSsrO1xuICAgIC8vIHJldHVybiBub2RlXG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBub2RlcyBpbiBoZWFwLiBSdW5uaW5nIHRpbWU6IE8oMSkgYWN0dWFsLlxuICAgKiBAbWVtYmVyb2YgRmlib25hY2NpSGVhcFxuICAgKi9cbiAgRmlib25hY2NpSGVhcC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgZWxlbWVudHMgZnJvbSB0aGlzIGhlYXAuXG4gICAqIEBtZW1iZXJvZiBGaWJvbmFjY2lIZWFwXG4gICAqL1xuICBGaWJvbmFjY2lIZWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9taW5pbXVtID0gbnVsbDtcbiAgICB0aGlzLl9zaXplID0gMDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBoZWFwIGlzIGVtcHR5LCBvdGhlcndpc2UgZmFsc2UuXG4gICAqIEBtZW1iZXJvZiBGaWJvbmFjY2lIZWFwXG4gICAqL1xuICBGaWJvbmFjY2lIZWFwLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIXRoaXMuX21pbmltdW07XG4gIH07XG4gIFxuICAvKipcbiAgICogRXh0cmFjdHMgdGhlIG5vZGUgd2l0aCBtaW5pbXVtIGtleSBmcm9tIGhlYXAuIEFtb3J0aXplZCBydW5uaW5nIFxuICAgKiB0aW1lOiBPKGxvZyBuKS5cbiAgICogQG1lbWJlcm9mIEZpYm9uYWNjaUhlYXBcbiAgICovXG4gIEZpYm9uYWNjaUhlYXAucHJvdG90eXBlLmV4dHJhY3RNaW5pbXVtID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIG5vZGUgdG8gcmVtb3ZlXG4gICAgdmFyIG5vZGUgPSB0aGlzLl9taW5pbXVtO1xuICAgIC8vIGNoZWNrIHdlIGhhdmUgYSBtaW5pbXVtXG4gICAgaWYgKG5vZGUgPT09IG51bGwpXG4gICAgICByZXR1cm4gbm9kZTtcbiAgICAvLyBjdXJyZW50IG1pbmltdW1cbiAgICB2YXIgbWluaW11bSA9IHRoaXMuX21pbmltdW07XG4gICAgLy8gZ2V0IG51bWJlciBvZiBjaGlsZHJlblxuICAgIHZhciBudW1iZXJPZkNoaWxkcmVuID0gbm9kZS5kZWdyZWU7XG4gICAgLy8gcG9pbnRlciB0byB0aGUgZmlyc3QgY2hpbGRcbiAgICB2YXIgeCA9IG5vZGUuY2hpbGQ7XG4gICAgLy8gZm9yIGVhY2ggY2hpbGQgb2Ygbm9kZSBkby4uLlxuICAgIHdoaWxlIChudW1iZXJPZkNoaWxkcmVuID4gMCkge1xuICAgICAgLy8gc3RvcmUgbm9kZSBpbiByaWdodCBzaWRlXG4gICAgICB2YXIgdGVtcFJpZ2h0ID0geC5yaWdodDtcbiAgICAgIC8vIHJlbW92ZSB4IGZyb20gY2hpbGQgbGlzdFxuICAgICAgeC5sZWZ0LnJpZ2h0ID0geC5yaWdodDtcbiAgICAgIHgucmlnaHQubGVmdCA9IHgubGVmdDtcbiAgICAgIC8vIGFkZCB4IHRvIHJvb3QgbGlzdCBvZiBoZWFwXG4gICAgICB4LmxlZnQgPSBtaW5pbXVtO1xuICAgICAgeC5yaWdodCA9IG1pbmltdW0ucmlnaHQ7XG4gICAgICBtaW5pbXVtLnJpZ2h0ID0geDtcbiAgICAgIHgucmlnaHQubGVmdCA9IHg7XG4gICAgICAvLyBzZXQgUGFyZW50W3hdIHRvIG51bGxcbiAgICAgIHgucGFyZW50ID0gbnVsbDtcbiAgICAgIHggPSB0ZW1wUmlnaHQ7XG4gICAgICBudW1iZXJPZkNoaWxkcmVuLS07XG4gICAgfVxuICAgIC8vIHJlbW92ZSBub2RlIGZyb20gcm9vdCBsaXN0IG9mIGhlYXBcbiAgICBub2RlLmxlZnQucmlnaHQgPSBub2RlLnJpZ2h0O1xuICAgIG5vZGUucmlnaHQubGVmdCA9IG5vZGUubGVmdDtcbiAgICAvLyB1cGRhdGUgbWluaW11bVxuICAgIGlmIChub2RlID09IG5vZGUucmlnaHQpIHtcbiAgICAgIC8vIGVtcHR5XG4gICAgICBtaW5pbXVtID0gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyB1cGRhdGUgbWluaW11bVxuICAgICAgbWluaW11bSA9IG5vZGUucmlnaHQ7XG4gICAgICAvLyB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgcG9pbnRlciB0byB0aGUgcm9vdCB3aXRoIG1pbmltdW0ga2V5XG4gICAgICBtaW5pbXVtID0gX2ZpbmRNaW5pbXVtTm9kZShtaW5pbXVtLCB0aGlzLl9zaXplKTtcbiAgICB9XG4gICAgLy8gZGVjcmVtZW50IHNpemUgb2YgaGVhcFxuICAgIHRoaXMuX3NpemUtLTtcbiAgICAvLyB1cGRhdGUgbWluaW11bVxuICAgIHRoaXMuX21pbmltdW0gPSBtaW5pbXVtO1xuICAgIC8vIHJldHVybiBub2RlXG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG4gIFxuICAvKipcbiAgICogUmVtb3ZlcyBhIG5vZGUgZnJvbSB0aGUgaGVhcCBnaXZlbiB0aGUgcmVmZXJlbmNlIHRvIHRoZSBub2RlLiBUaGUgdHJlZXNcbiAgICogaW4gdGhlIGhlYXAgd2lsbCBiZSBjb25zb2xpZGF0ZWQsIGlmIG5lY2Vzc2FyeS4gVGhpcyBvcGVyYXRpb24gbWF5IGZhaWxcbiAgICogdG8gcmVtb3ZlIHRoZSBjb3JyZWN0IGVsZW1lbnQgaWYgdGhlcmUgYXJlIG5vZGVzIHdpdGgga2V5IHZhbHVlIC1JbmZpbml0eS5cbiAgICogUnVubmluZyB0aW1lOiBPKGxvZyBuKSBhbW9ydGl6ZWQuXG4gICAqIEBtZW1iZXJvZiBGaWJvbmFjY2lIZWFwXG4gICAqL1xuICBGaWJvbmFjY2lIZWFwLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIC8vIGRlY3JlYXNlIGtleSB2YWx1ZVxuICAgIHRoaXMuX21pbmltdW0gPSBfZGVjcmVhc2VLZXkodGhpcy5fbWluaW11bSwgbm9kZSwgLTEpO1xuICAgIC8vIHJlbW92ZSB0aGUgc21hbGxlc3RcbiAgICB0aGlzLmV4dHJhY3RNaW5pbXVtKCk7XG4gIH07XG4gIFxuICAvKipcbiAgICogRGVjcmVhc2VzIHRoZSBrZXkgdmFsdWUgZm9yIGEgaGVhcCBub2RlLCBnaXZlbiB0aGUgbmV3IHZhbHVlIHRvIHRha2Ugb24uXG4gICAqIFRoZSBzdHJ1Y3R1cmUgb2YgdGhlIGhlYXAgbWF5IGJlIGNoYW5nZWQgYW5kIHdpbGwgbm90IGJlIGNvbnNvbGlkYXRlZC4gXG4gICAqIFJ1bm5pbmcgdGltZTogTygxKSBhbW9ydGl6ZWQuXG4gICAqIEBtZW1iZXJvZiBGaWJvbmFjY2lIZWFwXG4gICAqL1xuICB2YXIgX2RlY3JlYXNlS2V5ID0gZnVuY3Rpb24gKG1pbmltdW0sIG5vZGUsIGtleSkge1xuICAgIC8vIHNldCBub2RlIGtleVxuICAgIG5vZGUua2V5ID0ga2V5O1xuICAgIC8vIGdldCBwYXJlbnQgbm9kZVxuICAgIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudDtcbiAgICBpZiAocGFyZW50ICYmIHNtYWxsZXIobm9kZS5rZXksIHBhcmVudC5rZXkpKSB7XG4gICAgICAvLyByZW1vdmUgbm9kZSBmcm9tIHBhcmVudFxuICAgICAgX2N1dChtaW5pbXVtLCBub2RlLCBwYXJlbnQpO1xuICAgICAgLy8gcmVtb3ZlIGFsbCBub2RlcyBmcm9tIHBhcmVudCB0byB0aGUgcm9vdCBwYXJlbnRcbiAgICAgIF9jYXNjYWRpbmdDdXQobWluaW11bSwgcGFyZW50KTtcbiAgICB9XG4gICAgLy8gdXBkYXRlIG1pbmltdW0gbm9kZSBpZiBuZWVkZWRcbiAgICBpZiAoc21hbGxlcihub2RlLmtleSwgbWluaW11bS5rZXkpKVxuICAgICAgbWluaW11bSA9IG5vZGU7XG4gICAgLy8gcmV0dXJuIG1pbmltdW1cbiAgICByZXR1cm4gbWluaW11bTtcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBUaGUgcmV2ZXJzZSBvZiB0aGUgbGluayBvcGVyYXRpb246IHJlbW92ZXMgbm9kZSBmcm9tIHRoZSBjaGlsZCBsaXN0IG9mIHBhcmVudC5cbiAgICogVGhpcyBtZXRob2QgYXNzdW1lcyB0aGF0IG1pbiBpcyBub24tbnVsbC4gUnVubmluZyB0aW1lOiBPKDEpLlxuICAgKiBAbWVtYmVyb2YgRmlib25hY2NpSGVhcFxuICAgKi9cbiAgdmFyIF9jdXQgPSBmdW5jdGlvbiAobWluaW11bSwgbm9kZSwgcGFyZW50KSB7XG4gICAgLy8gcmVtb3ZlIG5vZGUgZnJvbSBwYXJlbnQgY2hpbGRyZW4gYW5kIGRlY3JlbWVudCBEZWdyZWVbcGFyZW50XVxuICAgIG5vZGUubGVmdC5yaWdodCA9IG5vZGUucmlnaHQ7XG4gICAgbm9kZS5yaWdodC5sZWZ0ID0gbm9kZS5sZWZ0O1xuICAgIHBhcmVudC5kZWdyZWUtLTtcbiAgICAvLyByZXNldCB5LmNoaWxkIGlmIG5lY2Vzc2FyeVxuICAgIGlmIChwYXJlbnQuY2hpbGQgPT0gbm9kZSlcbiAgICAgIHBhcmVudC5jaGlsZCA9IG5vZGUucmlnaHQ7XG4gICAgLy8gcmVtb3ZlIGNoaWxkIGlmIGRlZ3JlZSBpcyAwXG4gICAgaWYgKHBhcmVudC5kZWdyZWUgPT09IDApXG4gICAgICBwYXJlbnQuY2hpbGQgPSBudWxsO1xuICAgIC8vIGFkZCBub2RlIHRvIHJvb3QgbGlzdCBvZiBoZWFwXG4gICAgbm9kZS5sZWZ0ID0gbWluaW11bTtcbiAgICBub2RlLnJpZ2h0ID0gbWluaW11bS5yaWdodDtcbiAgICBtaW5pbXVtLnJpZ2h0ID0gbm9kZTtcbiAgICBub2RlLnJpZ2h0LmxlZnQgPSBub2RlO1xuICAgIC8vIHNldCBwYXJlbnRbbm9kZV0gdG8gbnVsbFxuICAgIG5vZGUucGFyZW50ID0gbnVsbDtcbiAgICAvLyBzZXQgbWFya1tub2RlXSB0byBmYWxzZVxuICAgIG5vZGUubWFyayA9IGZhbHNlO1xuICB9O1xuICBcbiAgLyoqXG4gICAqIFBlcmZvcm1zIGEgY2FzY2FkaW5nIGN1dCBvcGVyYXRpb24uIFRoaXMgY3V0cyBub2RlIGZyb20gaXRzIHBhcmVudCBhbmQgdGhlblxuICAgKiBkb2VzIHRoZSBzYW1lIGZvciBpdHMgcGFyZW50LCBhbmQgc28gb24gdXAgdGhlIHRyZWUuXG4gICAqIFJ1bm5pbmcgdGltZTogTyhsb2cgbik7IE8oMSkgZXhjbHVkaW5nIHRoZSByZWN1cnNpb24uXG4gICAqIEBtZW1iZXJvZiBGaWJvbmFjY2lIZWFwXG4gICAqL1xuICB2YXIgX2Nhc2NhZGluZ0N1dD0gZnVuY3Rpb24gKG1pbmltdW0sIG5vZGUpIHtcbiAgICAvLyBzdG9yZSBwYXJlbnQgbm9kZVxuICAgIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudDtcbiAgICAvLyBpZiB0aGVyZSdzIGEgcGFyZW50Li4uXG4gICAgaWYgKCFwYXJlbnQpXG4gICAgICByZXR1cm47XG4gICAgLy8gaWYgbm9kZSBpcyB1bm1hcmtlZCwgc2V0IGl0IG1hcmtlZFxuICAgIGlmICghbm9kZS5tYXJrKSB7XG4gICAgICBub2RlLm1hcmsgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGl0J3MgbWFya2VkLCBjdXQgaXQgZnJvbSBwYXJlbnRcbiAgICAgIF9jdXQobWluaW11bSwgbm9kZSwgcGFyZW50KTtcbiAgICAgIC8vIGN1dCBpdHMgcGFyZW50IGFzIHdlbGxcbiAgICAgIF9jYXNjYWRpbmdDdXQocGFyZW50KTtcbiAgICB9XG4gIH07XG4gIFxuICAvKipcbiAgICogTWFrZSB0aGUgZmlyc3Qgbm9kZSBhIGNoaWxkIG9mIHRoZSBzZWNvbmQgb25lLiBSdW5uaW5nIHRpbWU6IE8oMSkgYWN0dWFsLlxuICAgKiBAbWVtYmVyb2YgRmlib25hY2NpSGVhcFxuICAgKi9cbiAgdmFyIF9saW5rTm9kZXMgPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50KSB7XG4gICAgLy8gcmVtb3ZlIG5vZGUgZnJvbSByb290IGxpc3Qgb2YgaGVhcFxuICAgIG5vZGUubGVmdC5yaWdodCA9IG5vZGUucmlnaHQ7XG4gICAgbm9kZS5yaWdodC5sZWZ0ID0gbm9kZS5sZWZ0O1xuICAgIC8vIG1ha2Ugbm9kZSBhIENoaWxkIG9mIHBhcmVudFxuICAgIG5vZGUucGFyZW50ID0gcGFyZW50O1xuICAgIGlmICghcGFyZW50LmNoaWxkKSB7XG4gICAgICBwYXJlbnQuY2hpbGQgPSBub2RlO1xuICAgICAgbm9kZS5yaWdodCA9IG5vZGU7XG4gICAgICBub2RlLmxlZnQgPSBub2RlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIG5vZGUubGVmdCA9IHBhcmVudC5jaGlsZDtcbiAgICAgIG5vZGUucmlnaHQgPSBwYXJlbnQuY2hpbGQucmlnaHQ7XG4gICAgICBwYXJlbnQuY2hpbGQucmlnaHQgPSBub2RlO1xuICAgICAgbm9kZS5yaWdodC5sZWZ0ID0gbm9kZTtcbiAgICB9XG4gICAgLy8gaW5jcmVhc2UgZGVncmVlW3BhcmVudF1cbiAgICBwYXJlbnQuZGVncmVlKys7XG4gICAgLy8gc2V0IG1hcmtbbm9kZV0gZmFsc2VcbiAgICBub2RlLm1hcmsgPSBmYWxzZTtcbiAgfTtcbiAgXG4gIHZhciBfZmluZE1pbmltdW1Ob2RlID0gZnVuY3Rpb24gKG1pbmltdW0sIHNpemUpIHtcbiAgICAvLyB0byBmaW5kIHRyZWVzIG9mIHRoZSBzYW1lIGRlZ3JlZSBlZmZpY2llbnRseSB3ZSB1c2UgYW4gYXJyYXkgb2YgbGVuZ3RoIE8obG9nIG4pIGluIHdoaWNoIHdlIGtlZXAgYSBwb2ludGVyIHRvIG9uZSByb290IG9mIGVhY2ggZGVncmVlXG4gICAgdmFyIGFycmF5U2l6ZSA9IE1hdGguZmxvb3IoTWF0aC5sb2coc2l6ZSkgKiBvbmVPdmVyTG9nUGhpKSArIDE7XG4gICAgLy8gY3JlYXRlIGxpc3Qgd2l0aCBpbml0aWFsIGNhcGFjaXR5XG4gICAgdmFyIGFycmF5ID0gbmV3IEFycmF5KGFycmF5U2l6ZSk7XG4gICAgLy8gZmluZCB0aGUgbnVtYmVyIG9mIHJvb3Qgbm9kZXMuXG4gICAgdmFyIG51bVJvb3RzID0gMDtcbiAgICB2YXIgeCA9IG1pbmltdW07XG4gICAgaWYgKHgpIHtcbiAgICAgIG51bVJvb3RzKys7XG4gICAgICB4ID0geC5yaWdodDtcbiAgICAgIHdoaWxlICh4ICE9PSBtaW5pbXVtKSB7XG4gICAgICAgIG51bVJvb3RzKys7XG4gICAgICAgIHggPSB4LnJpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgICAvLyB2YXJzXG4gICAgdmFyIHk7XG4gICAgLy8gRm9yIGVhY2ggbm9kZSBpbiByb290IGxpc3QgZG8uLi5cbiAgICB3aGlsZSAobnVtUm9vdHMgPiAwKSB7XG4gICAgICAvLyBhY2Nlc3MgdGhpcyBub2RlJ3MgZGVncmVlLi5cbiAgICAgIHZhciBkID0geC5kZWdyZWU7XG4gICAgICAvLyBnZXQgbmV4dCBub2RlXG4gICAgICB2YXIgbmV4dCA9IHgucmlnaHQ7XG4gICAgICAvLyBjaGVjayBpZiB0aGVyZSBpcyBhIG5vZGUgYWxyZWFkeSBpbiBhcnJheSB3aXRoIHRoZSBzYW1lIGRlZ3JlZVxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgLy8gZ2V0IG5vZGUgd2l0aCB0aGUgc2FtZSBkZWdyZWUgaXMgYW55XG4gICAgICAgIHkgPSBhcnJheVtkXTtcbiAgICAgICAgaWYgKCF5KVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBtYWtlIG9uZSBub2RlIHdpdGggdGhlIHNhbWUgZGVncmVlIGEgY2hpbGQgb2YgdGhlIG90aGVyLCBkbyB0aGlzIGJhc2VkIG9uIHRoZSBrZXkgdmFsdWUuXG4gICAgICAgIGlmIChsYXJnZXIoeC5rZXksIHkua2V5KSkge1xuICAgICAgICAgIHZhciB0ZW1wID0geTtcbiAgICAgICAgICB5ID0geDtcbiAgICAgICAgICB4ID0gdGVtcDtcbiAgICAgICAgfVxuICAgICAgICAvLyBtYWtlIHkgYSBjaGlsZCBvZiB4XG4gICAgICAgIF9saW5rTm9kZXMoeSwgeCk7XG4gICAgICAgIC8vIHdlIGhhdmUgaGFuZGxlZCB0aGlzIGRlZ3JlZSwgZ28gdG8gbmV4dCBvbmUuXG4gICAgICAgIGFycmF5W2RdID0gbnVsbDtcbiAgICAgICAgZCsrO1xuICAgICAgfVxuICAgICAgLy8gc2F2ZSB0aGlzIG5vZGUgZm9yIGxhdGVyIHdoZW4gd2UgbWlnaHQgZW5jb3VudGVyIGFub3RoZXIgb2YgdGhlIHNhbWUgZGVncmVlLlxuICAgICAgYXJyYXlbZF0gPSB4O1xuICAgICAgLy8gbW92ZSBmb3J3YXJkIHRocm91Z2ggbGlzdC5cbiAgICAgIHggPSBuZXh0O1xuICAgICAgbnVtUm9vdHMtLTtcbiAgICB9XG4gICAgLy8gU2V0IG1pbiB0byBudWxsIChlZmZlY3RpdmVseSBsb3NpbmcgdGhlIHJvb3QgbGlzdCkgYW5kIHJlY29uc3RydWN0IHRoZSByb290IGxpc3QgZnJvbSB0aGUgYXJyYXkgZW50cmllcyBpbiBhcnJheVtdLlxuICAgIG1pbmltdW0gPSBudWxsO1xuICAgIC8vIGxvb3Agbm9kZXMgaW4gYXJyYXlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5U2l6ZTsgaSsrKSB7XG4gICAgICAvLyBnZXQgY3VycmVudCBub2RlXG4gICAgICB5ID0gYXJyYXlbaV07XG4gICAgICBpZiAoIXkpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgLy8gY2hlY2sgaWYgd2UgaGF2ZSBhIGxpbmtlZCBsaXN0XG4gICAgICBpZiAobWluaW11bSkge1xuICAgICAgICAvLyBGaXJzdCByZW1vdmUgbm9kZSBmcm9tIHJvb3QgbGlzdC5cbiAgICAgICAgeS5sZWZ0LnJpZ2h0ID0geS5yaWdodDtcbiAgICAgICAgeS5yaWdodC5sZWZ0ID0geS5sZWZ0O1xuICAgICAgICAvLyBub3cgYWRkIHRvIHJvb3QgbGlzdCwgYWdhaW4uXG4gICAgICAgIHkubGVmdCA9IG1pbmltdW07XG4gICAgICAgIHkucmlnaHQgPSBtaW5pbXVtLnJpZ2h0O1xuICAgICAgICBtaW5pbXVtLnJpZ2h0ID0geTtcbiAgICAgICAgeS5yaWdodC5sZWZ0ID0geTtcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBhIG5ldyBtaW4uXG4gICAgICAgIGlmIChzbWFsbGVyKHkua2V5LCBtaW5pbXVtLmtleSkpXG4gICAgICAgICAgbWluaW11bSA9IHk7XG4gICAgICB9XG4gICAgICBlbHNlXG4gICAgICAgIG1pbmltdW0gPSB5O1xuICAgIH1cbiAgICByZXR1cm4gbWluaW11bTtcbiAgfTtcbiAgXG4gIHJldHVybiBGaWJvbmFjY2lIZWFwO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnRmlib25hY2NpSGVhcCc7XG5leHBvcnRzLnBhdGggPSAndHlwZSc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2luZGV4Jyk7XG5cbnZhciBzdHJpbmcgPSB1dGlsLnN0cmluZztcbnZhciBvYmplY3QgPSB1dGlsLm9iamVjdDtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xudmFyIGlzU3RyaW5nID0gc3RyaW5nLmlzU3RyaW5nO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQpIHtcblxuICB2YXIgRGVuc2VNYXRyaXggPSBsb2FkKHJlcXVpcmUoJy4vRGVuc2VNYXRyaXgnKSk7XG5cbiAgdmFyIHNtYWxsZXIgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL2Z1bmN0aW9uL3JlbGF0aW9uYWwvc21hbGxlcicpKTtcblxuICBmdW5jdGlvbiBJbW11dGFibGVEZW5zZU1hdHJpeChkYXRhLCBkYXRhdHlwZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBJbW11dGFibGVEZW5zZU1hdHJpeCkpXG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0NvbnN0cnVjdG9yIG11c3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBvcGVyYXRvcicpO1xuICAgIGlmIChkYXRhdHlwZSAmJiAhaXNTdHJpbmcoZGF0YXR5cGUpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRhdGF0eXBlOiAnICsgZGF0YXR5cGUpO1xuXG4gICAgaWYgKChkYXRhICYmIGRhdGEuaXNNYXRyaXggPT09IHRydWUpIHx8IGlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIC8vIHVzZSBEZW5zZU1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgdmFyIG1hdHJpeCA9IG5ldyBEZW5zZU1hdHJpeChkYXRhLCBkYXRhdHlwZSk7XG4gICAgICAvLyBpbnRlcm5hbCBzdHJ1Y3R1cmVzXG4gICAgICB0aGlzLl9kYXRhID0gbWF0cml4Ll9kYXRhO1xuICAgICAgdGhpcy5fc2l6ZSA9IG1hdHJpeC5fc2l6ZTtcbiAgICAgIHRoaXMuX2RhdGF0eXBlID0gbWF0cml4Ll9kYXRhdHlwZTtcbiAgICAgIHRoaXMuX21pbiA9IG51bGw7XG4gICAgICB0aGlzLl9tYXggPSBudWxsO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhICYmIGlzQXJyYXkoZGF0YS5kYXRhKSAmJiBpc0FycmF5KGRhdGEuc2l6ZSkpIHtcbiAgICAgIC8vIGluaXRpYWxpemUgZmllbGRzIGZyb20gSlNPTiByZXByZXNlbnRhdGlvblxuICAgICAgdGhpcy5fZGF0YSA9IGRhdGEuZGF0YTtcbiAgICAgIHRoaXMuX3NpemUgPSBkYXRhLnNpemU7XG4gICAgICB0aGlzLl9kYXRhdHlwZSA9IGRhdGEuZGF0YXR5cGU7XG4gICAgICB0aGlzLl9taW4gPSB0eXBlb2YgZGF0YS5taW4gIT09ICd1bmRlZmluZWQnID8gZGF0YS5taW4gOiBudWxsO1xuICAgICAgdGhpcy5fbWF4ID0gdHlwZW9mIGRhdGEubWF4ICE9PSAndW5kZWZpbmVkJyA/IGRhdGEubWF4IDogbnVsbDtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YSkge1xuICAgICAgLy8gdW5zdXBwb3J0ZWQgdHlwZVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5zdXBwb3J0ZWQgdHlwZSBvZiBkYXRhICgnICsgdXRpbC50eXBlcy50eXBlKGRhdGEpICsgJyknKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBub3RoaW5nIHByb3ZpZGVkXG4gICAgICB0aGlzLl9kYXRhID0gW107XG4gICAgICB0aGlzLl9zaXplID0gWzBdO1xuICAgICAgdGhpcy5fZGF0YXR5cGUgPSBkYXRhdHlwZTtcbiAgICAgIHRoaXMuX21pbiA9IG51bGw7XG4gICAgICB0aGlzLl9tYXggPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIEltbXV0YWJsZURlbnNlTWF0cml4LnByb3RvdHlwZSA9IG5ldyBEZW5zZU1hdHJpeCgpO1xuXG4gIC8qKlxuICAgKiBBdHRhY2ggdHlwZSBpbmZvcm1hdGlvblxuICAgKi9cbiAgSW1tdXRhYmxlRGVuc2VNYXRyaXgucHJvdG90eXBlLnR5cGUgPSAnSW1tdXRhYmxlRGVuc2VNYXRyaXgnO1xuICBJbW11dGFibGVEZW5zZU1hdHJpeC5wcm90b3R5cGUuaXNJbW11dGFibGVEZW5zZU1hdHJpeCA9IHRydWU7XG5cbiAgLyoqXG4gICAqIEdldCBhIHN1YnNldCBvZiB0aGUgbWF0cml4LCBvciByZXBsYWNlIGEgc3Vic2V0IG9mIHRoZSBtYXRyaXguXG4gICAqXG4gICAqIFVzYWdlOlxuICAgKiAgICAgdmFyIHN1YnNldCA9IG1hdHJpeC5zdWJzZXQoaW5kZXgpICAgICAgICAgICAgICAgLy8gcmV0cmlldmUgc3Vic2V0XG4gICAqICAgICB2YXIgdmFsdWUgPSBtYXRyaXguc3Vic2V0KGluZGV4LCByZXBsYWNlbWVudCkgICAvLyByZXBsYWNlIHN1YnNldFxuICAgKlxuICAgKiBAcGFyYW0ge0luZGV4fSBpbmRleFxuICAgKiBAcGFyYW0ge0FycmF5IHwgSW1tdXRhYmxlRGVuc2VNYXRyaXggfCAqfSBbcmVwbGFjZW1lbnRdXG4gICAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZT0wXSAgICAgIERlZmF1bHQgdmFsdWUsIGZpbGxlZCBpbiBvbiBuZXcgZW50cmllcyB3aGVuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBtYXRyaXggaXMgcmVzaXplZC4gSWYgbm90IHByb3ZpZGVkLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgbWF0cml4IGVsZW1lbnRzIHdpbGwgYmUgZmlsbGVkIHdpdGggemVyb3MuXG4gICAqL1xuICBJbW11dGFibGVEZW5zZU1hdHJpeC5wcm90b3R5cGUuc3Vic2V0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIC8vIHVzZSBiYXNlIGltcGxlbWVudGF0aW9uXG4gICAgICAgIHZhciBtID0gRGVuc2VNYXRyaXgucHJvdG90eXBlLnN1YnNldC5jYWxsKHRoaXMsIGluZGV4KTtcbiAgICAgICAgLy8gY2hlY2sgcmVzdWx0IGlzIGEgbWF0cml4XG4gICAgICAgIGlmIChtLmlzTWF0cml4KSB7XG4gICAgICAgICAgLy8gcmV0dXJuIGltbXV0YWJsZSBtYXRyaXhcbiAgICAgICAgICByZXR1cm4gbmV3IEltbXV0YWJsZURlbnNlTWF0cml4KHtcbiAgICAgICAgICAgIGRhdGE6IG0uX2RhdGEsXG4gICAgICAgICAgICBzaXplOiBtLl9zaXplLFxuICAgICAgICAgICAgZGF0YXR5cGU6IG0uX2RhdGF0eXBlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIFxuICAgICAgICAvLyBpbnRlbnRpb25hbCBmYWxsIHRocm91Z2hcbiAgICAgIGNhc2UgMjpcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52b2tlIHNldCBzdWJzZXQgb24gYW4gSW1tdXRhYmxlIE1hdHJpeCBpbnN0YW5jZScpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1dyb25nIG51bWJlciBvZiBhcmd1bWVudHMnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcGxhY2UgYSBzaW5nbGUgZWxlbWVudCBpbiB0aGUgbWF0cml4LlxuICAgKiBAcGFyYW0ge051bWJlcltdfSBpbmRleCAgIFplcm8tYmFzZWQgaW5kZXhcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdICAgICAgICBEZWZhdWx0IHZhbHVlLCBmaWxsZWQgaW4gb24gbmV3IGVudHJpZXMgd2hlblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgbWF0cml4IGlzIHJlc2l6ZWQuIElmIG5vdCBwcm92aWRlZCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IG1hdHJpeCBlbGVtZW50cyB3aWxsIGJlIGxlZnQgdW5kZWZpbmVkLlxuICAgKiBAcmV0dXJuIHtJbW11dGFibGVEZW5zZU1hdHJpeH0gc2VsZlxuICAgKi9cbiAgSW1tdXRhYmxlRGVuc2VNYXRyaXgucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZva2Ugc2V0IG9uIGFuIEltbXV0YWJsZSBNYXRyaXggaW5zdGFuY2UnKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVzaXplIHRoZSBtYXRyaXggdG8gdGhlIGdpdmVuIHNpemUuIFJldHVybnMgYSBjb3B5IG9mIHRoZSBtYXRyaXggd2hlblxuICAgKiBgY29weT10cnVlYCwgb3RoZXJ3aXNlIHJldHVybiB0aGUgbWF0cml4IGl0c2VsZiAocmVzaXplIGluIHBsYWNlKS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJbXX0gc2l6ZSAgICAgICAgICAgVGhlIG5ldyBzaXplIHRoZSBtYXRyaXggc2hvdWxkIGhhdmUuXG4gICAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZT0wXSAgICAgIERlZmF1bHQgdmFsdWUsIGZpbGxlZCBpbiBvbiBuZXcgZW50cmllcy5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgbm90IHByb3ZpZGVkLCB0aGUgbWF0cml4IGVsZW1lbnRzIHdpbGxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmUgZmlsbGVkIHdpdGggemVyb3MuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NvcHldICAgICAgICAgIFJldHVybiBhIHJlc2l6ZWQgY29weSBvZiB0aGUgbWF0cml4XG4gICAqXG4gICAqIEByZXR1cm4ge01hdHJpeH0gICAgICAgICAgICAgICAgIFRoZSByZXNpemVkIG1hdHJpeFxuICAgKi9cbiAgSW1tdXRhYmxlRGVuc2VNYXRyaXgucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZva2UgcmVzaXplIG9uIGFuIEltbXV0YWJsZSBNYXRyaXggaW5zdGFuY2UnKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgY2xvbmUgb2YgdGhlIG1hdHJpeFxuICAgKiBAcmV0dXJuIHtJbW11dGFibGVEZW5zZU1hdHJpeH0gY2xvbmVcbiAgICovXG4gIEltbXV0YWJsZURlbnNlTWF0cml4LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbSA9IG5ldyBJbW11dGFibGVEZW5zZU1hdHJpeCh7XG4gICAgICBkYXRhOiBvYmplY3QuY2xvbmUodGhpcy5fZGF0YSksXG4gICAgICBzaXplOiBvYmplY3QuY2xvbmUodGhpcy5fc2l6ZSksXG4gICAgICBkYXRhdHlwZTogdGhpcy5fZGF0YXR5cGVcbiAgICB9KTtcbiAgICByZXR1cm4gbTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqL1xuICBJbW11dGFibGVEZW5zZU1hdHJpeC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtYXRoanM6ICdJbW11dGFibGVEZW5zZU1hdHJpeCcsXG4gICAgICBkYXRhOiB0aGlzLl9kYXRhLFxuICAgICAgc2l6ZTogdGhpcy5fc2l6ZSxcbiAgICAgIGRhdGF0eXBlOiB0aGlzLl9kYXRhdHlwZVxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgbWF0cml4IGZyb20gYSBKU09OIG9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0ganNvbiAgQW4gb2JqZWN0IHN0cnVjdHVyZWQgbGlrZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgYHtcIm1hdGhqc1wiOiBcIkltbXV0YWJsZURlbnNlTWF0cml4XCIsIGRhdGE6IFtdLCBzaXplOiBbXX1gLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgd2hlcmUgbWF0aGpzIGlzIG9wdGlvbmFsXG4gICAqIEByZXR1cm5zIHtJbW11dGFibGVEZW5zZU1hdHJpeH1cbiAgICovXG4gIEltbXV0YWJsZURlbnNlTWF0cml4LmZyb21KU09OID0gZnVuY3Rpb24gKGpzb24pIHtcbiAgICByZXR1cm4gbmV3IEltbXV0YWJsZURlbnNlTWF0cml4KGpzb24pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTd2FwIHJvd3MgaSBhbmQgaiBpbiBNYXRyaXguXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpICAgICAgIE1hdHJpeCByb3cgaW5kZXggMVxuICAgKiBAcGFyYW0ge051bWJlcn0gaiAgICAgICBNYXRyaXggcm93IGluZGV4IDJcbiAgICpcbiAgICogQHJldHVybiB7TWF0cml4fSAgICAgICAgVGhlIG1hdHJpeCByZWZlcmVuY2VcbiAgICovXG4gIEltbXV0YWJsZURlbnNlTWF0cml4LnByb3RvdHlwZS5zd2FwUm93cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZva2Ugc3dhcFJvd3Mgb24gYW4gSW1tdXRhYmxlIE1hdHJpeCBpbnN0YW5jZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIG1pbmltdW0gdmFsdWUgaW4gdGhlIHNldFxuICAgKiBAcmV0dXJuIHtOdW1iZXIgfCB1bmRlZmluZWR9IG1pblxuICAgKi9cbiAgSW1tdXRhYmxlRGVuc2VNYXRyaXgucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBjaGVjayBtaW4gaGFzIGJlZW4gY2FsY3VsYXRlZCBiZWZvcmVcbiAgICBpZiAodGhpcy5fbWluID09PSBudWxsKSB7XG4gICAgICAvLyBtaW5pbXVtXG4gICAgICB2YXIgbSA9IG51bGw7XG4gICAgICAvLyBjb21wdXRlIG1pblxuICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIGlmIChtID09PSBudWxsIHx8IHNtYWxsZXIodiwgbSkpXG4gICAgICAgICAgbSA9IHY7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX21pbiA9IG0gIT09IG51bGwgPyBtIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbWluO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIG1heGltdW0gdmFsdWUgaW4gdGhlIHNldFxuICAgKiBAcmV0dXJuIHtOdW1iZXIgfCB1bmRlZmluZWR9IG1heFxuICAgKi9cbiAgSW1tdXRhYmxlRGVuc2VNYXRyaXgucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBjaGVjayBtYXggaGFzIGJlZW4gY2FsY3VsYXRlZCBiZWZvcmVcbiAgICBpZiAodGhpcy5fbWF4ID09PSBudWxsKSB7XG4gICAgICAvLyBtYXhpbXVtXG4gICAgICB2YXIgbSA9IG51bGw7XG4gICAgICAvLyBjb21wdXRlIG1heFxuICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIGlmIChtID09PSBudWxsIHx8IHNtYWxsZXIobSwgdikpXG4gICAgICAgICAgbSA9IHY7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX21heCA9IG0gIT09IG51bGwgPyBtIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbWF4O1xuICB9O1xuXG4gIC8vIGV4cG9ydHNcbiAgcmV0dXJuIEltbXV0YWJsZURlbnNlTWF0cml4O1xufVxuXG5leHBvcnRzLm5hbWUgPSAnSW1tdXRhYmxlRGVuc2VNYXRyaXgnO1xuZXhwb3J0cy5wYXRoID0gJ3R5cGUnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlscy9pbmRleCcpO1xuXG52YXIgc3RyaW5nID0gdXRpbC5zdHJpbmc7XG5cbnZhciBpc1N0cmluZyA9IHN0cmluZy5pc1N0cmluZztcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yIE1hdHJpeFxuICAgKlxuICAgKiBBIE1hdHJpeCBpcyBhIHdyYXBwZXIgYXJvdW5kIGFuIEFycmF5LiBBIG1hdHJpeCBjYW4gaG9sZCBhIG11bHRpIGRpbWVuc2lvbmFsXG4gICAqIGFycmF5LiBBIG1hdHJpeCBjYW4gYmUgY29uc3RydWN0ZWQgYXM6XG4gICAqICAgICB2YXIgbWF0cml4ID0gbWF0aC5tYXRyaXgoZGF0YSlcbiAgICpcbiAgICogTWF0cml4IGNvbnRhaW5zIHRoZSBmdW5jdGlvbnMgdG8gcmVzaXplLCBnZXQgYW5kIHNldCB2YWx1ZXMsIGdldCB0aGUgc2l6ZSxcbiAgICogY2xvbmUgdGhlIG1hdHJpeCBhbmQgdG8gY29udmVydCB0aGUgbWF0cml4IHRvIGEgdmVjdG9yLCBhcnJheSwgb3Igc2NhbGFyLlxuICAgKiBGdXJ0aGVybW9yZSwgb25lIGNhbiBpdGVyYXRlIG92ZXIgdGhlIG1hdHJpeCB1c2luZyBtYXAgYW5kIGZvckVhY2guXG4gICAqIFRoZSBpbnRlcm5hbCBBcnJheSBvZiB0aGUgTWF0cml4IGNhbiBiZSBhY2Nlc3NlZCB1c2luZyB0aGUgZnVuY3Rpb24gdmFsdWVPZi5cbiAgICpcbiAgICogRXhhbXBsZSB1c2FnZTpcbiAgICogICAgIHZhciBtYXRyaXggPSBtYXRoLm1hdHJpeChbWzEsIDJdLCBbMywgNF1dKTtcbiAgICogICAgIG1hdGl4LnNpemUoKTsgICAgICAgICAgICAgIC8vIFsyLCAyXVxuICAgKiAgICAgbWF0cml4LnJlc2l6ZShbMywgMl0sIDUpO1xuICAgKiAgICAgbWF0cml4LnZhbHVlT2YoKTsgICAgICAgICAgLy8gW1sxLCAyXSwgWzMsIDRdLCBbNSwgNV1dXG4gICAqICAgICBtYXRyaXguc3Vic2V0KFsxLDJdKSAgICAgICAvLyAzIChpbmRleGVzIGFyZSB6ZXJvLWJhc2VkKVxuICAgKlxuICAgKi9cbiAgZnVuY3Rpb24gTWF0cml4KCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNYXRyaXgpKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0NvbnN0cnVjdG9yIG11c3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBvcGVyYXRvcicpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRhY2ggdHlwZSBpbmZvcm1hdGlvblxuICAgKi9cbiAgTWF0cml4LnByb3RvdHlwZS50eXBlID0gJ01hdHJpeCc7XG4gIE1hdHJpeC5wcm90b3R5cGUuaXNNYXRyaXggPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIE1hdHJpeCBzdG9yYWdlIGNvbnN0cnVjdG9yIGZvciB0aGUgZ2l2ZW4gZm9ybWF0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0ICAgICAgIFRoZSBNYXRyaXggc3RvcmFnZSBmb3JtYXQuXG4gICAqXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSAgICAgICAgICAgVGhlIE1hdHJpeCBzdG9yYWdlIGNvbnN0cnVjdG9yLlxuICAgKi9cbiAgTWF0cml4LnN0b3JhZ2UgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgLy8gY2hlY2sgc3RvcmFnZSBmb3JtYXQgaXMgYSBzdHJpbmdcbiAgICBpZiAoIWlzU3RyaW5nKGZvcm1hdCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Zvcm1hdCBtdXN0IGJlIGEgc3RyaW5nIHZhbHVlJyk7XG4gICAgfVxuXG4gICAgLy8gZ2V0IHN0b3JhZ2UgZm9ybWF0IGNvbnN0cnVjdG9yXG4gICAgdmFyIGNvbnN0cnVjdG9yID0gTWF0cml4Ll9zdG9yYWdlW2Zvcm1hdF07XG4gICAgaWYgKCFjb25zdHJ1Y3Rvcikge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbnN1cHBvcnRlZCBtYXRyaXggc3RvcmFnZSBmb3JtYXQ6ICcgKyBmb3JtYXQpO1xuICAgIH1cblxuICAgIC8vIHJldHVybiBzdG9yYWdlIGNvbnN0cnVjdG9yXG4gICAgcmV0dXJuIGNvbnN0cnVjdG9yO1xuICB9O1xuXG4gIC8vIGEgbWFwIHdpdGggYWxsIGNvbnN0cnVjdG9ycyBmb3IgYWxsIHN0b3JhZ2UgdHlwZXNcbiAgTWF0cml4Ll9zdG9yYWdlID0ge307XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3RvcmFnZSBmb3JtYXQgdXNlZCBieSB0aGUgbWF0cml4LlxuICAgKlxuICAgKiBVc2FnZTpcbiAgICogICAgIHZhciBmb3JtYXQgPSBtYXRyaXguc3RvcmFnZSgpICAgICAgICAgICAgICAgICAgIC8vIHJldHJpZXZlIHN0b3JhZ2UgZm9ybWF0XG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgICAgIFRoZSBzdG9yYWdlIGZvcm1hdC5cbiAgICovXG4gIE1hdHJpeC5wcm90b3R5cGUuc3RvcmFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IGVhY2ggb2YgdGhlIE1hdHJpeCBpbXBsZW1lbnRhdGlvbnNcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZva2Ugc3RvcmFnZSBvbiBhIE1hdHJpeCBpbnRlcmZhY2UnKTtcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRhdGF0eXBlIG9mIHRoZSBkYXRhIHN0b3JlZCBpbiB0aGUgbWF0cml4LlxuICAgKlxuICAgKiBVc2FnZTpcbiAgICogICAgIHZhciBmb3JtYXQgPSBtYXRyaXguZGF0YXR5cGUoKSAgICAgICAgICAgICAgICAgICAvLyByZXRyaWV2ZSBtYXRyaXggZGF0YXR5cGVcbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSAgICAgICAgICAgVGhlIGRhdGF0eXBlLlxuICAgKi9cbiAgTWF0cml4LnByb3RvdHlwZS5kYXRhdHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IGVhY2ggb2YgdGhlIE1hdHJpeCBpbXBsZW1lbnRhdGlvbnNcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZva2UgZGF0YXR5cGUgb24gYSBNYXRyaXggaW50ZXJmYWNlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBNYXRyaXggV2l0aCB0aGUgdHlwZSBvZiB0aGUgY3VycmVudCBtYXRyaXggaW5zdGFuY2VcbiAgICogQHBhcmFtIHtBcnJheSB8IE9iamVjdH0gZGF0YVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2RhdGF0eXBlXVxuICAgKi9cbiAgTWF0cml4LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoZGF0YSwgZGF0YXR5cGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZva2UgY3JlYXRlIG9uIGEgTWF0cml4IGludGVyZmFjZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSBzdWJzZXQgb2YgdGhlIG1hdHJpeCwgb3IgcmVwbGFjZSBhIHN1YnNldCBvZiB0aGUgbWF0cml4LlxuICAgKlxuICAgKiBVc2FnZTpcbiAgICogICAgIHZhciBzdWJzZXQgPSBtYXRyaXguc3Vic2V0KGluZGV4KSAgICAgICAgICAgICAgIC8vIHJldHJpZXZlIHN1YnNldFxuICAgKiAgICAgdmFyIHZhbHVlID0gbWF0cml4LnN1YnNldChpbmRleCwgcmVwbGFjZW1lbnQpICAgLy8gcmVwbGFjZSBzdWJzZXRcbiAgICpcbiAgICogQHBhcmFtIHtJbmRleH0gaW5kZXhcbiAgICogQHBhcmFtIHtBcnJheSB8IE1hdHJpeCB8ICp9IFtyZXBsYWNlbWVudF1cbiAgICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlPTBdICAgICAgRGVmYXVsdCB2YWx1ZSwgZmlsbGVkIGluIG9uIG5ldyBlbnRyaWVzIHdoZW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG1hdHJpeCBpcyByZXNpemVkLiBJZiBub3QgcHJvdmlkZWQsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBtYXRyaXggZWxlbWVudHMgd2lsbCBiZSBmaWxsZWQgd2l0aCB6ZXJvcy5cbiAgICovXG4gIE1hdHJpeC5wcm90b3R5cGUuc3Vic2V0ID0gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgLy8gbXVzdCBiZSBpbXBsZW1lbnRlZCBieSBlYWNoIG9mIHRoZSBNYXRyaXggaW1wbGVtZW50YXRpb25zXG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52b2tlIHN1YnNldCBvbiBhIE1hdHJpeCBpbnRlcmZhY2UnKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGEgc2luZ2xlIGVsZW1lbnQgZnJvbSB0aGUgbWF0cml4LlxuICAgKiBAcGFyYW0ge251bWJlcltdfSBpbmRleCAgIFplcm8tYmFzZWQgaW5kZXhcbiAgICogQHJldHVybiB7Kn0gdmFsdWVcbiAgICovXG4gIE1hdHJpeC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgLy8gbXVzdCBiZSBpbXBsZW1lbnRlZCBieSBlYWNoIG9mIHRoZSBNYXRyaXggaW1wbGVtZW50YXRpb25zXG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52b2tlIGdldCBvbiBhIE1hdHJpeCBpbnRlcmZhY2UnKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVwbGFjZSBhIHNpbmdsZSBlbGVtZW50IGluIHRoZSBtYXRyaXguXG4gICAqIEBwYXJhbSB7bnVtYmVyW119IGluZGV4ICAgWmVyby1iYXNlZCBpbmRleFxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gICAgICAgIERlZmF1bHQgdmFsdWUsIGZpbGxlZCBpbiBvbiBuZXcgZW50cmllcyB3aGVuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBtYXRyaXggaXMgcmVzaXplZC4gSWYgbm90IHByb3ZpZGVkLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgbWF0cml4IGVsZW1lbnRzIHdpbGwgYmUgbGVmdCB1bmRlZmluZWQuXG4gICAqIEByZXR1cm4ge01hdHJpeH0gc2VsZlxuICAgKi9cbiAgTWF0cml4LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAvLyBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IGVhY2ggb2YgdGhlIE1hdHJpeCBpbXBsZW1lbnRhdGlvbnNcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZva2Ugc2V0IG9uIGEgTWF0cml4IGludGVyZmFjZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXNpemUgdGhlIG1hdHJpeCB0byB0aGUgZ2l2ZW4gc2l6ZS4gUmV0dXJucyBhIGNvcHkgb2YgdGhlIG1hdHJpeCB3aGVuIFxuICAgKiBgY29weT10cnVlYCwgb3RoZXJ3aXNlIHJldHVybiB0aGUgbWF0cml4IGl0c2VsZiAocmVzaXplIGluIHBsYWNlKS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJbXX0gc2l6ZSAgICAgICAgICAgVGhlIG5ldyBzaXplIHRoZSBtYXRyaXggc2hvdWxkIGhhdmUuXG4gICAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZT0wXSAgICAgIERlZmF1bHQgdmFsdWUsIGZpbGxlZCBpbiBvbiBuZXcgZW50cmllcy5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgbm90IHByb3ZpZGVkLCB0aGUgbWF0cml4IGVsZW1lbnRzIHdpbGxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmUgZmlsbGVkIHdpdGggemVyb3MuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NvcHldICAgICAgICAgIFJldHVybiBhIHJlc2l6ZWQgY29weSBvZiB0aGUgbWF0cml4XG4gICAqXG4gICAqIEByZXR1cm4ge01hdHJpeH0gICAgICAgICAgICAgICAgIFRoZSByZXNpemVkIG1hdHJpeFxuICAgKi9cbiAgTWF0cml4LnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAoc2l6ZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgLy8gbXVzdCBiZSBpbXBsZW1lbnRlZCBieSBlYWNoIG9mIHRoZSBNYXRyaXggaW1wbGVtZW50YXRpb25zXG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52b2tlIHJlc2l6ZSBvbiBhIE1hdHJpeCBpbnRlcmZhY2UnKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgY2xvbmUgb2YgdGhlIG1hdHJpeFxuICAgKiBAcmV0dXJuIHtNYXRyaXh9IGNsb25lXG4gICAqL1xuICBNYXRyaXgucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgZWFjaCBvZiB0aGUgTWF0cml4IGltcGxlbWVudGF0aW9uc1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludm9rZSBjbG9uZSBvbiBhIE1hdHJpeCBpbnRlcmZhY2UnKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlldmUgdGhlIHNpemUgb2YgdGhlIG1hdHJpeC5cbiAgICogQHJldHVybnMge251bWJlcltdfSBzaXplXG4gICAqL1xuICBNYXRyaXgucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IGVhY2ggb2YgdGhlIE1hdHJpeCBpbXBsZW1lbnRhdGlvbnNcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZva2Ugc2l6ZSBvbiBhIE1hdHJpeCBpbnRlcmZhY2UnKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IG1hdHJpeCB3aXRoIHRoZSByZXN1bHRzIG9mIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBleGVjdXRlZCBvblxuICAgKiBlYWNoIGVudHJ5IG9mIHRoZSBtYXRyaXguXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrICAgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudCwgdGhlIGluZGV4XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgdGhlIGVsZW1lbnQsIGFuZCB0aGUgTWF0cml4IGJlaW5nIHRyYXZlcnNlZC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbc2tpcFplcm9zXSBJbnZva2UgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIG5vbi16ZXJvIHZhbHVlcyBvbmx5LlxuICAgKlxuICAgKiBAcmV0dXJuIHtNYXRyaXh9IG1hdHJpeFxuICAgKi9cbiAgTWF0cml4LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHNraXBaZXJvcykge1xuICAgIC8vIG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgZWFjaCBvZiB0aGUgTWF0cml4IGltcGxlbWVudGF0aW9uc1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludm9rZSBtYXAgb24gYSBNYXRyaXggaW50ZXJmYWNlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYSBjYWxsYmFjayBmdW5jdGlvbiBvbiBlYWNoIGVudHJ5IG9mIHRoZSBtYXRyaXguXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrICAgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudCwgdGhlIGluZGV4XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgdGhlIGVsZW1lbnQsIGFuZCB0aGUgTWF0cml4IGJlaW5nIHRyYXZlcnNlZC5cbiAgICovXG4gIE1hdHJpeC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIC8vIG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgZWFjaCBvZiB0aGUgTWF0cml4IGltcGxlbWVudGF0aW9uc1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludm9rZSBmb3JFYWNoIG9uIGEgTWF0cml4IGludGVyZmFjZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gQXJyYXkgd2l0aCBhIGNvcHkgb2YgdGhlIGRhdGEgb2YgdGhlIE1hdHJpeFxuICAgKiBAcmV0dXJucyB7QXJyYXl9IGFycmF5XG4gICAqL1xuICBNYXRyaXgucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gbXVzdCBiZSBpbXBsZW1lbnRlZCBieSBlYWNoIG9mIHRoZSBNYXRyaXggaW1wbGVtZW50YXRpb25zXG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52b2tlIHRvQXJyYXkgb24gYSBNYXRyaXggaW50ZXJmYWNlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcHJpbWl0aXZlIHZhbHVlIG9mIHRoZSBNYXRyaXg6IGEgbXVsdGlkaW1lbnNpb25hbCBhcnJheVxuICAgKiBAcmV0dXJucyB7QXJyYXl9IGFycmF5XG4gICAqL1xuICBNYXRyaXgucHJvdG90eXBlLnZhbHVlT2YgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gbXVzdCBiZSBpbXBsZW1lbnRlZCBieSBlYWNoIG9mIHRoZSBNYXRyaXggaW1wbGVtZW50YXRpb25zXG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52b2tlIHZhbHVlT2Ygb24gYSBNYXRyaXggaW50ZXJmYWNlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4LCB3aXRoIG9wdGlvbmFsIGZvcm1hdHRpbmcgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtPYmplY3QgfCBudW1iZXIgfCBGdW5jdGlvbn0gW29wdGlvbnNdICBGb3JtYXR0aW5nIG9wdGlvbnMuIFNlZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpYi91dGlscy9udW1iZXI6Zm9ybWF0IGZvciBhXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gb2YgdGhlIGF2YWlsYWJsZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IHN0clxuICAgKi9cbiAgTWF0cml4LnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIC8vIG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgZWFjaCBvZiB0aGUgTWF0cml4IGltcGxlbWVudGF0aW9uc1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludm9rZSBmb3JtYXQgb24gYSBNYXRyaXggaW50ZXJmYWNlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IHN0clxuICAgKi9cbiAgTWF0cml4LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IGVhY2ggb2YgdGhlIE1hdHJpeCBpbXBsZW1lbnRhdGlvbnNcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZva2UgdG9TdHJpbmcgb24gYSBNYXRyaXggaW50ZXJmYWNlJyk7XG4gIH07XG4gICBcbiAgLy8gZXhwb3J0c1xuICByZXR1cm4gTWF0cml4O1xufVxuXG5leHBvcnRzLm5hbWUgPSAnTWF0cml4JztcbmV4cG9ydHMucGF0aCA9ICd0eXBlJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjbG9uZSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdCcpLmNsb25lO1xudmFyIGlzSW50ZWdlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL251bWJlcicpLmlzSW50ZWdlcjtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSkge1xuICBcbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbmRleC4gQW4gSW5kZXggY2FuIHN0b3JlIHJhbmdlcyBhbmQgc2V0cyBmb3IgbXVsdGlwbGUgZGltZW5zaW9ucy5cbiAgICogTWF0cml4LmdldCwgTWF0cml4LnNldCwgYW5kIG1hdGguc3Vic2V0IGFjY2VwdCBhbiBJbmRleCBhcyBpbnB1dC5cbiAgICpcbiAgICogVXNhZ2U6XG4gICAqICAgICB2YXIgaW5kZXggPSBuZXcgSW5kZXgocmFuZ2UxLCByYW5nZTIsIG1hdHJpeDEsIGFycmF5MSwgLi4uKTtcbiAgICpcbiAgICogV2hlcmUgZWFjaCBwYXJhbWV0ZXIgY2FuIGJlIGFueSBvZjpcbiAgICogICAgIEEgbnVtYmVyXG4gICAqICAgICBBIHN0cmluZyAoY29udGFpbmluZyBhIG5hbWUgb2YgYW4gb2JqZWN0IHByb3BlcnR5KVxuICAgKiAgICAgQW4gaW5zdGFuY2Ugb2YgUmFuZ2VcbiAgICogICAgIEFuIEFycmF5IHdpdGggdGhlIFNldCB2YWx1ZXNcbiAgICogICAgIEEgTWF0cml4IHdpdGggdGhlIFNldCB2YWx1ZXNcbiAgICpcbiAgICogVGhlIHBhcmFtZXRlcnMgc3RhcnQsIGVuZCwgYW5kIHN0ZXAgbXVzdCBiZSBpbnRlZ2VyIG51bWJlcnMuXG4gICAqXG4gICAqIEBjbGFzcyBJbmRleFxuICAgKiBAQ29uc3RydWN0b3IgSW5kZXhcbiAgICogQHBhcmFtIHsuLi4qfSByYW5nZXNcbiAgICovXG4gIGZ1bmN0aW9uIEluZGV4KHJhbmdlcykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBJbmRleCkpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQ29uc3RydWN0b3IgbXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgbmV3IG9wZXJhdG9yJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGltZW5zaW9ucyA9IFtdO1xuICAgIHRoaXMuX2lzU2NhbGFyID0gdHJ1ZTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICB2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBpZiAoYXJnICYmIChhcmcuaXNSYW5nZSA9PT0gdHJ1ZSkpIHtcbiAgICAgICAgdGhpcy5fZGltZW5zaW9ucy5wdXNoKGFyZyk7XG4gICAgICAgIHRoaXMuX2lzU2NhbGFyID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhcmcgJiYgKEFycmF5LmlzQXJyYXkoYXJnKSB8fCBhcmcuaXNNYXRyaXggPT09IHRydWUpKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBtYXRyaXhcbiAgICAgICAgdmFyIG0gPSBfY3JlYXRlSW1tdXRhYmxlTWF0cml4KGFyZy52YWx1ZU9mKCkpO1xuICAgICAgICB0aGlzLl9kaW1lbnNpb25zLnB1c2gobSk7XG4gICAgICAgIC8vIHNpemVcbiAgICAgICAgdmFyIHNpemUgPSBtLnNpemUoKTtcbiAgICAgICAgLy8gc2NhbGFyXG4gICAgICAgIGlmIChzaXplLmxlbmd0aCAhPT0gMSB8fCBzaXplWzBdICE9PSAxKSB7XG4gICAgICAgICAgdGhpcy5faXNTY2FsYXIgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhpcy5fZGltZW5zaW9ucy5wdXNoKF9jcmVhdGVJbW11dGFibGVNYXRyaXgoW2FyZ10pKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIG9iamVjdCBwcm9wZXJ0eSAoYXJndW1lbnRzLmNvdW50IHNob3VsZCBiZSAxKVxuICAgICAgICB0aGlzLl9kaW1lbnNpb25zLnB1c2goYXJnKTtcbiAgICAgIH1cbiAgICAgIC8vIFRPRE86IGltcGxlbWVudCBzdXBwb3J0IGZvciB3aWxkY2FyZCAnKidcbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdEaW1lbnNpb24gbXVzdCBiZSBhbiBBcnJheSwgTWF0cml4LCBudW1iZXIsIHN0cmluZywgb3IgUmFuZ2UnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXR0YWNoIHR5cGUgaW5mb3JtYXRpb25cbiAgICovXG4gIEluZGV4LnByb3RvdHlwZS50eXBlID0gJ0luZGV4JztcbiAgSW5kZXgucHJvdG90eXBlLmlzSW5kZXggPSB0cnVlO1xuXG4gIGZ1bmN0aW9uIF9jcmVhdGVJbW11dGFibGVNYXRyaXgoYXJnKSB7XG4gICAgLy8gbG9vcCBhcnJheSBlbGVtZW50c1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJnLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHR5cGVvZiBhcmdbaV0gIT09ICdudW1iZXInIHx8ICFpc0ludGVnZXIoYXJnW2ldKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbmRleCBwYXJhbWV0ZXJzIG11c3QgYmUgcG9zaXRpdmUgaW50ZWdlciBudW1iZXJzJyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGNyZWF0ZSBtYXRyaXhcbiAgICByZXR1cm4gbmV3IHR5cGUuSW1tdXRhYmxlRGVuc2VNYXRyaXgoYXJnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBjbG9uZSBvZiB0aGUgaW5kZXhcbiAgICogQG1lbWJlcm9mIEluZGV4XG4gICAqIEByZXR1cm4ge0luZGV4fSBjbG9uZVxuICAgKi9cbiAgSW5kZXgucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbmRleCA9IG5ldyBJbmRleCgpO1xuICAgIGluZGV4Ll9kaW1lbnNpb25zID0gY2xvbmUodGhpcy5fZGltZW5zaW9ucyk7XG4gICAgaW5kZXguX2lzU2NhbGFyID0gdGhpcy5faXNTY2FsYXI7XG4gICAgcmV0dXJuIGluZGV4O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5kZXggZnJvbSBhbiBhcnJheSB3aXRoIHJhbmdlcy9udW1iZXJzXG4gICAqIEBtZW1iZXJvZiBJbmRleFxuICAgKiBAcGFyYW0ge0FycmF5LjxBcnJheSB8IG51bWJlcj59IHJhbmdlc1xuICAgKiBAcmV0dXJuIHtJbmRleH0gaW5kZXhcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEluZGV4LmNyZWF0ZSA9IGZ1bmN0aW9uIChyYW5nZXMpIHtcbiAgICB2YXIgaW5kZXggPSBuZXcgSW5kZXgoKTtcbiAgICBJbmRleC5hcHBseShpbmRleCwgcmFuZ2VzKTtcbiAgICByZXR1cm4gaW5kZXg7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSBzaXplIG9mIHRoZSBpbmRleCwgdGhlIG51bWJlciBvZiBlbGVtZW50cyBmb3IgZWFjaCBkaW1lbnNpb24uXG4gICAqIEBtZW1iZXJvZiBJbmRleFxuICAgKiBAcmV0dXJucyB7bnVtYmVyW119IHNpemVcbiAgICovXG4gIEluZGV4LnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzaXplID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLl9kaW1lbnNpb25zLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIHZhciBkID0gdGhpcy5fZGltZW5zaW9uc1tpXTtcbiAgICAgIHNpemVbaV0gPSAodHlwZW9mIGQgPT09ICdzdHJpbmcnKSA/IDEgOiBkLnNpemUoKVswXTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2l6ZTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBtYXhpbXVtIHZhbHVlIGZvciBlYWNoIG9mIHRoZSBpbmRleGVzIHJhbmdlcy5cbiAgICogQG1lbWJlcm9mIEluZGV4XG4gICAqIEByZXR1cm5zIHtudW1iZXJbXX0gbWF4XG4gICAqL1xuICBJbmRleC5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHRoaXMuX2RpbWVuc2lvbnMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5fZGltZW5zaW9uc1tpXTtcbiAgICAgIHZhbHVlc1tpXSA9ICh0eXBlb2YgcmFuZ2UgPT09ICdzdHJpbmcnKSA/IHJhbmdlIDogcmFuZ2UubWF4KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBtaW5pbXVtIHZhbHVlIGZvciBlYWNoIG9mIHRoZSBpbmRleGVzIHJhbmdlcy5cbiAgICogQG1lbWJlcm9mIEluZGV4XG4gICAqIEByZXR1cm5zIHtudW1iZXJbXX0gbWluXG4gICAqL1xuICBJbmRleC5wcm90b3R5cGUubWluID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHRoaXMuX2RpbWVuc2lvbnMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5fZGltZW5zaW9uc1tpXTtcbiAgICAgIHZhbHVlc1tpXSA9ICh0eXBlb2YgcmFuZ2UgPT09ICdzdHJpbmcnKSA/IHJhbmdlIDogcmFuZ2UubWluKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfTtcblxuICAvKipcbiAgICogTG9vcCBvdmVyIGVhY2ggb2YgdGhlIHJhbmdlcyBvZiB0aGUgaW5kZXhcbiAgICogQG1lbWJlcm9mIEluZGV4XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrICAgQ2FsbGVkIGZvciBlYWNoIHJhbmdlIHdpdGggYSBSYW5nZSBhcyBmaXJzdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50LCB0aGUgZGltZW5zaW9uIGFzIHNlY29uZCwgYW5kIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4IG9iamVjdCBhcyB0aGlyZC5cbiAgICovXG4gIEluZGV4LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdGhpcy5fZGltZW5zaW9ucy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBjYWxsYmFjayh0aGlzLl9kaW1lbnNpb25zW2ldLCBpLCB0aGlzKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSBkaW1lbnNpb24gZm9yIHRoZSBnaXZlbiBpbmRleFxuICAgKiBAbWVtYmVyb2YgSW5kZXhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRpbSAgICAgICAgICAgICAgICAgIE51bWJlciBvZiB0aGUgZGltZW5zaW9uXG4gICAqIEByZXR1cm5zIHtSYW5nZSB8IG51bGx9IHJhbmdlXG4gICAqL1xuICBJbmRleC5wcm90b3R5cGUuZGltZW5zaW9uID0gZnVuY3Rpb24gKGRpbSkge1xuICAgIHJldHVybiB0aGlzLl9kaW1lbnNpb25zW2RpbV0gfHwgbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogVGVzdCB3aGV0aGVyIHRoaXMgaW5kZXggY29udGFpbnMgYW4gb2JqZWN0IHByb3BlcnR5XG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGluZGV4IGlzIGFuIG9iamVjdCBwcm9wZXJ0eVxuICAgKi9cbiAgSW5kZXgucHJvdG90eXBlLmlzT2JqZWN0UHJvcGVydHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RpbWVuc2lvbnMubGVuZ3RoID09PSAxICYmIHR5cGVvZiB0aGlzLl9kaW1lbnNpb25zWzBdID09PSAnc3RyaW5nJztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb2JqZWN0IHByb3BlcnR5IG5hbWUgd2hlbiB0aGUgSW5kZXggaG9sZHMgYSBzaW5nbGUgb2JqZWN0IHByb3BlcnR5LFxuICAgKiBlbHNlIHJldHVybnMgbnVsbFxuICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgbnVsbH1cbiAgICovXG4gIEluZGV4LnByb3RvdHlwZS5nZXRPYmplY3RQcm9wZXJ0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pc09iamVjdFByb3BlcnR5KCkgPyB0aGlzLl9kaW1lbnNpb25zWzBdIDogbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogVGVzdCB3aGV0aGVyIHRoaXMgaW5kZXggY29udGFpbnMgb25seSBhIHNpbmdsZSB2YWx1ZS5cbiAgICpcbiAgICogVGhpcyBpcyB0aGUgY2FzZSB3aGVuIHRoZSBpbmRleCBpcyBjcmVhdGVkIHdpdGggb25seSBzY2FsYXIgdmFsdWVzIGFzIHJhbmdlcyxcbiAgICogbm90IGZvciByYW5nZXMgcmVzb2x2aW5nIGludG8gYSBzaW5nbGUgdmFsdWUuXG4gICAqIEBtZW1iZXJvZiBJbmRleFxuICAgKiBAcmV0dXJuIHtib29sZWFufSBpc1NjYWxhclxuICAgKi9cbiAgSW5kZXgucHJvdG90eXBlLmlzU2NhbGFyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1NjYWxhcjtcbiAgfTtcblxuICAvKipcbiAgICogRXhwYW5kIHRoZSBJbmRleCBpbnRvIGFuIGFycmF5LlxuICAgKiBGb3IgZXhhbXBsZSBuZXcgSW5kZXgoWzAsM10sIFsyLDddKSByZXR1cm5zIFtbMCwxLDJdLCBbMiwzLDQsNSw2XV1cbiAgICogQG1lbWJlcm9mIEluZGV4XG4gICAqIEByZXR1cm5zIHtBcnJheX0gYXJyYXlcbiAgICovXG4gIEluZGV4LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHRoaXMuX2RpbWVuc2lvbnMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgdmFyIGRpbWVuc2lvbiA9IHRoaXMuX2RpbWVuc2lvbnNbaV07XG4gICAgICBhcnJheS5wdXNoKCh0eXBlb2YgZGltZW5zaW9uID09PSAnc3RyaW5nJykgPyBkaW1lbnNpb24gOiBkaW1lbnNpb24udG9BcnJheSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHByaW1pdGl2ZSB2YWx1ZSBvZiB0aGUgSW5kZXgsIGEgdHdvIGRpbWVuc2lvbmFsIGFycmF5LlxuICAgKiBFcXVpdmFsZW50IHRvIEluZGV4LnRvQXJyYXkoKS5cbiAgICogQG1lbWJlcm9mIEluZGV4XG4gICAqIEByZXR1cm5zIHtBcnJheX0gYXJyYXlcbiAgICovXG4gIEluZGV4LnByb3RvdHlwZS52YWx1ZU9mID0gSW5kZXgucHJvdG90eXBlLnRvQXJyYXk7XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbmRleCwgZm9yIGV4YW1wbGUgJ1syOjZdJyBvciAnWzA6MjoxMCwgNDo3LCBbMSwyLDNdXSdcbiAgICogQG1lbWJlcm9mIEluZGV4XG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IHN0clxuICAgKi9cbiAgSW5kZXgucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdHJpbmdzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLl9kaW1lbnNpb25zLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIHZhciBkaW1lbnNpb24gPSB0aGlzLl9kaW1lbnNpb25zW2ldO1xuICAgICAgaWYgKHR5cGVvZiBkaW1lbnNpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHN0cmluZ3MucHVzaChKU09OLnN0cmluZ2lmeShkaW1lbnNpb24pKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzdHJpbmdzLnB1c2goZGltZW5zaW9uLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnWycgKyBzdHJpbmdzLmpvaW4oJywgJykgKyAnXSc7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIEluZGV4XG4gICAqIEBtZW1iZXJvZiBJbmRleFxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGEgSlNPTiBvYmplY3Qgc3RydWN0dXJlZCBhczpcbiAgICogICAgICAgICAgICAgICAgICAgYHtcIm1hdGhqc1wiOiBcIkluZGV4XCIsIFwicmFuZ2VzXCI6IFt7XCJtYXRoanNcIjogXCJSYW5nZVwiLCBzdGFydDogMCwgZW5kOiAxMCwgc3RlcDoxfSwgLi4uXX1gXG4gICAqL1xuICBJbmRleC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtYXRoanM6ICdJbmRleCcsXG4gICAgICBkaW1lbnNpb25zOiB0aGlzLl9kaW1lbnNpb25zXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogSW5zdGFudGlhdGUgYW4gSW5kZXggZnJvbSBhIEpTT04gb2JqZWN0XG4gICAqIEBtZW1iZXJvZiBJbmRleFxuICAgKiBAcGFyYW0ge09iamVjdH0ganNvbiBBIEpTT04gb2JqZWN0IHN0cnVjdHVyZWQgYXM6XG4gICAqICAgICAgICAgICAgICAgICAgICAgYHtcIm1hdGhqc1wiOiBcIkluZGV4XCIsIFwiZGltZW5zaW9uc1wiOiBbe1wibWF0aGpzXCI6IFwiUmFuZ2VcIiwgc3RhcnQ6IDAsIGVuZDogMTAsIHN0ZXA6MX0sIC4uLl19YFxuICAgKiBAcmV0dXJuIHtJbmRleH1cbiAgICovXG4gIEluZGV4LmZyb21KU09OID0gZnVuY3Rpb24gKGpzb24pIHtcbiAgICByZXR1cm4gSW5kZXguY3JlYXRlKGpzb24uZGltZW5zaW9ucyk7XG4gIH07XG5cbiAgcmV0dXJuIEluZGV4O1xufVxuXG5leHBvcnRzLm5hbWUgPSAnSW5kZXgnO1xuZXhwb3J0cy5wYXRoID0gJ3R5cGUnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG51bWJlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL251bWJlcicpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSByYW5nZS4gQSByYW5nZSBoYXMgYSBzdGFydCwgc3RlcCwgYW5kIGVuZCwgYW5kIGNvbnRhaW5zIGZ1bmN0aW9uc1xuICAgKiB0byBpdGVyYXRlIG92ZXIgdGhlIHJhbmdlLlxuICAgKlxuICAgKiBBIHJhbmdlIGNhbiBiZSBjb25zdHJ1Y3RlZCBhczpcbiAgICogICAgIHZhciByYW5nZSA9IG5ldyBSYW5nZShzdGFydCwgZW5kKTtcbiAgICogICAgIHZhciByYW5nZSA9IG5ldyBSYW5nZShzdGFydCwgZW5kLCBzdGVwKTtcbiAgICpcbiAgICogVG8gZ2V0IHRoZSByZXN1bHQgb2YgdGhlIHJhbmdlOlxuICAgKiAgICAgcmFuZ2UuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgKiAgICAgICAgIGNvbnNvbGUubG9nKHgpO1xuICAgKiAgICAgfSk7XG4gICAqICAgICByYW5nZS5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICogICAgICAgICByZXR1cm4gbWF0aC5zaW4oeCk7XG4gICAqICAgICB9KTtcbiAgICogICAgIHJhbmdlLnRvQXJyYXkoKTtcbiAgICpcbiAgICogRXhhbXBsZSB1c2FnZTpcbiAgICogICAgIHZhciBjID0gbmV3IFJhbmdlKDIsIDYpOyAgICAgICAgIC8vIDI6MTo1XG4gICAqICAgICBjLnRvQXJyYXkoKTsgICAgICAgICAgICAgICAgICAgICAvLyBbMiwgMywgNCwgNV1cbiAgICogICAgIHZhciBkID0gbmV3IFJhbmdlKDIsIC0zLCAtMSk7ICAgIC8vIDI6LTE6LTJcbiAgICogICAgIGQudG9BcnJheSgpOyAgICAgICAgICAgICAgICAgICAgIC8vIFsyLCAxLCAwLCAtMSwgLTJdXG4gICAqXG4gICAqIEBjbGFzcyBSYW5nZVxuICAgKiBAY29uc3RydWN0b3IgUmFuZ2VcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0ICBpbmNsdWRlZCBsb3dlciBib3VuZFxuICAgKiBAcGFyYW0ge251bWJlcn0gZW5kICAgIGV4Y2x1ZGVkIHVwcGVyIGJvdW5kXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RlcF0gc3RlcCBzaXplLCBkZWZhdWx0IHZhbHVlIGlzIDFcbiAgICovXG4gIGZ1bmN0aW9uIFJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXApIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmFuZ2UpKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0NvbnN0cnVjdG9yIG11c3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBvcGVyYXRvcicpO1xuICAgIH1cblxuICAgIGlmIChzdGFydCAhPSBudWxsKSB7XG4gICAgICBpZiAoc3RhcnQuaXNCaWdOdW1iZXIgPT09IHRydWUpXG4gICAgICAgIHN0YXJ0ID0gc3RhcnQudG9OdW1iZXIoKTtcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBzdGFydCAhPT0gJ251bWJlcicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BhcmFtZXRlciBzdGFydCBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgfVxuICAgIGlmIChlbmQgIT0gbnVsbCkge1xuICAgICAgaWYgKGVuZC5pc0JpZ051bWJlciA9PT0gdHJ1ZSlcbiAgICAgICAgZW5kID0gZW5kLnRvTnVtYmVyKCk7XG4gICAgICBlbHNlIGlmICh0eXBlb2YgZW5kICE9PSAnbnVtYmVyJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUGFyYW1ldGVyIGVuZCBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgfVxuICAgIGlmIChzdGVwICE9IG51bGwpIHtcbiAgICAgIGlmIChzdGVwLmlzQmlnTnVtYmVyID09PSB0cnVlKVxuICAgICAgICBzdGVwID0gc3RlcC50b051bWJlcigpO1xuICAgICAgZWxzZSBpZiAodHlwZW9mIHN0ZXAgIT09ICdudW1iZXInKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQYXJhbWV0ZXIgc3RlcCBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zdGFydCA9IChzdGFydCAhPSBudWxsKSA/IHBhcnNlRmxvYXQoc3RhcnQpIDogMDtcbiAgICB0aGlzLmVuZCAgID0gKGVuZCAhPSBudWxsKSAgID8gcGFyc2VGbG9hdChlbmQpICAgOiAwO1xuICAgIHRoaXMuc3RlcCAgPSAoc3RlcCAhPSBudWxsKSAgPyBwYXJzZUZsb2F0KHN0ZXApICA6IDE7XG4gIH1cblxuICAvKipcbiAgICogQXR0YWNoIHR5cGUgaW5mb3JtYXRpb25cbiAgICovXG4gIFJhbmdlLnByb3RvdHlwZS50eXBlID0gJ1JhbmdlJztcbiAgUmFuZ2UucHJvdG90eXBlLmlzUmFuZ2UgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBQYXJzZSBhIHN0cmluZyBpbnRvIGEgcmFuZ2UsXG4gICAqIFRoZSBzdHJpbmcgY29udGFpbnMgdGhlIHN0YXJ0LCBvcHRpb25hbCBzdGVwLCBhbmQgZW5kLCBzZXBhcmF0ZWQgYnkgYSBjb2xvbi5cbiAgICogSWYgdGhlIHN0cmluZyBkb2VzIG5vdCBjb250YWluIGEgdmFsaWQgcmFuZ2UsIG51bGwgaXMgcmV0dXJuZWQuXG4gICAqIEZvciBleGFtcGxlIHN0cj0nMDoyOjExJy5cbiAgICogQG1lbWJlcm9mIFJhbmdlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAgICogQHJldHVybiB7UmFuZ2UgfCBudWxsfSByYW5nZVxuICAgKi9cbiAgUmFuZ2UucGFyc2UgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgYXJncyA9IHN0ci5zcGxpdCgnOicpO1xuICAgIHZhciBudW1zID0gYXJncy5tYXAoZnVuY3Rpb24gKGFyZykge1xuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoYXJnKTtcbiAgICB9KTtcblxuICAgIHZhciBpbnZhbGlkID0gbnVtcy5zb21lKGZ1bmN0aW9uIChudW0pIHtcbiAgICAgIHJldHVybiBpc05hTihudW0pO1xuICAgIH0pO1xuICAgIGlmIChpbnZhbGlkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKG51bXMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2UobnVtc1swXSwgbnVtc1sxXSk7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2UobnVtc1swXSwgbnVtc1syXSwgbnVtc1sxXSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGNsb25lIG9mIHRoZSByYW5nZVxuICAgKiBAcmV0dXJuIHtSYW5nZX0gY2xvbmVcbiAgICovXG4gIFJhbmdlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFJhbmdlKHRoaXMuc3RhcnQsIHRoaXMuZW5kLCB0aGlzLnN0ZXApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgc2l6ZSBvZiB0aGUgcmFuZ2UuXG4gICAqIFJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyBvbmUgbnVtYmVyLCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSByYW5nZS5cbiAgICogQG1lbWJlcm9mIFJhbmdlXG4gICAqIEByZXR1cm5zIHtudW1iZXJbXX0gc2l6ZVxuICAgKi9cbiAgUmFuZ2UucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IDAsXG4gICAgICAgIHN0YXJ0ID0gdGhpcy5zdGFydCxcbiAgICAgICAgc3RlcCA9IHRoaXMuc3RlcCxcbiAgICAgICAgZW5kID0gdGhpcy5lbmQsXG4gICAgICAgIGRpZmYgPSBlbmQgLSBzdGFydDtcblxuICAgIGlmIChudW1iZXIuc2lnbihzdGVwKSA9PSBudW1iZXIuc2lnbihkaWZmKSkge1xuICAgICAgbGVuID0gTWF0aC5jZWlsKChkaWZmKSAvIHN0ZXApO1xuICAgIH1cbiAgICBlbHNlIGlmIChkaWZmID09IDApIHtcbiAgICAgIGxlbiA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGlzTmFOKGxlbikpIHtcbiAgICAgIGxlbiA9IDA7XG4gICAgfVxuICAgIHJldHVybiBbbGVuXTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBtaW5pbXVtIHZhbHVlIGluIHRoZSByYW5nZVxuICAgKiBAbWVtYmVyb2YgUmFuZ2VcbiAgICogQHJldHVybiB7bnVtYmVyIHwgdW5kZWZpbmVkfSBtaW5cbiAgICovXG4gIFJhbmdlLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLnNpemUoKVswXTtcblxuICAgIGlmIChzaXplID4gMCkge1xuICAgICAgaWYgKHRoaXMuc3RlcCA+IDApIHtcbiAgICAgICAgLy8gcG9zaXRpdmUgc3RlcFxuICAgICAgICByZXR1cm4gdGhpcy5zdGFydDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBuZWdhdGl2ZSBzdGVwXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0ICsgKHNpemUgLSAxKSAqIHRoaXMuc3RlcDtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBtYXhpbXVtIHZhbHVlIGluIHRoZSByYW5nZVxuICAgKiBAbWVtYmVyb2YgUmFuZ2VcbiAgICogQHJldHVybiB7bnVtYmVyIHwgdW5kZWZpbmVkfSBtYXhcbiAgICovXG4gIFJhbmdlLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLnNpemUoKVswXTtcblxuICAgIGlmIChzaXplID4gMCkge1xuICAgICAgaWYgKHRoaXMuc3RlcCA+IDApIHtcbiAgICAgICAgLy8gcG9zaXRpdmUgc3RlcFxuICAgICAgICByZXR1cm4gdGhpcy5zdGFydCArIChzaXplIC0gMSkgKiB0aGlzLnN0ZXA7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gbmVnYXRpdmUgc3RlcFxuICAgICAgICByZXR1cm4gdGhpcy5zdGFydDtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIGEgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIGVhY2ggdmFsdWUgaW4gdGhlIHJhbmdlLlxuICAgKiBAbWVtYmVyb2YgUmFuZ2VcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgICBUaGUgY2FsbGJhY2sgbWV0aG9kIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudCwgdGhlIGluZGV4XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgdGhlIGVsZW1lbnQsIGFuZCB0aGUgUmFuZ2UgYmVpbmcgdHJhdmVyc2VkLlxuICAgKi9cbiAgUmFuZ2UucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB2YXIgeCA9IHRoaXMuc3RhcnQ7XG4gICAgdmFyIHN0ZXAgPSB0aGlzLnN0ZXA7XG4gICAgdmFyIGVuZCA9IHRoaXMuZW5kO1xuICAgIHZhciBpID0gMDtcblxuICAgIGlmIChzdGVwID4gMCkge1xuICAgICAgd2hpbGUgKHggPCBlbmQpIHtcbiAgICAgICAgY2FsbGJhY2soeCwgW2ldLCB0aGlzKTtcbiAgICAgICAgeCArPSBzdGVwO1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0ZXAgPCAwKSB7XG4gICAgICB3aGlsZSAoeCA+IGVuZCkge1xuICAgICAgICBjYWxsYmFjayh4LCBbaV0sIHRoaXMpO1xuICAgICAgICB4ICs9IHN0ZXA7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgZWFjaCB2YWx1ZSBpbiB0aGUgUmFuZ2UsIGFuZCByZXR1cm4gdGhlXG4gICAqIHJlc3VsdHMgYXMgYW4gYXJyYXlcbiAgICogQG1lbWJlcm9mIFJhbmdlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrICAgVGhlIGNhbGxiYWNrIG1ldGhvZCBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiB0aGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQsIHRoZSBpbmRleFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIHRoZSBlbGVtZW50LCBhbmQgdGhlIE1hdHJpeCBiZWluZyB0cmF2ZXJzZWQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gYXJyYXlcbiAgICovXG4gIFJhbmdlLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgb2JqKSB7XG4gICAgICBhcnJheVtpbmRleFswXV0gPSBjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIG9iaik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFycmF5O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gQXJyYXkgd2l0aCBhIGNvcHkgb2YgdGhlIFJhbmdlcyBkYXRhXG4gICAqIEBtZW1iZXJvZiBSYW5nZVxuICAgKiBAcmV0dXJucyB7QXJyYXl9IGFycmF5XG4gICAqL1xuICBSYW5nZS5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgYXJyYXlbaW5kZXhbMF1dID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFycmF5O1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHByaW1pdGl2ZSB2YWx1ZSBvZiB0aGUgUmFuZ2UsIGEgb25lIGRpbWVuc2lvbmFsIGFycmF5XG4gICAqIEBtZW1iZXJvZiBSYW5nZVxuICAgKiBAcmV0dXJucyB7QXJyYXl9IGFycmF5XG4gICAqL1xuICBSYW5nZS5wcm90b3R5cGUudmFsdWVPZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBUT0RPOiBpbXBsZW1lbnQgYSBjYWNoaW5nIG1lY2hhbmlzbSBmb3IgcmFuZ2UudmFsdWVPZigpXG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHJhbmdlLCB3aXRoIG9wdGlvbmFsIGZvcm1hdHRpbmcgb3B0aW9ucy5cbiAgICogT3V0cHV0IGlzIGZvcm1hdHRlZCBhcyAnc3RhcnQ6c3RlcDplbmQnLCBmb3IgZXhhbXBsZSAnMjo2JyBvciAnMDowLjI6MTEnXG4gICAqIEBtZW1iZXJvZiBSYW5nZVxuICAgKiBAcGFyYW0ge09iamVjdCB8IG51bWJlciB8IGZ1bmN0aW9ufSBbb3B0aW9uc10gIEZvcm1hdHRpbmcgb3B0aW9ucy4gU2VlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGliL3V0aWxzL251bWJlcjpmb3JtYXQgZm9yIGFcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbiBvZiB0aGUgYXZhaWxhYmxlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5cbiAgICogQHJldHVybnMge3N0cmluZ30gc3RyXG4gICAqL1xuICBSYW5nZS5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgc3RyID0gbnVtYmVyLmZvcm1hdCh0aGlzLnN0YXJ0LCBvcHRpb25zKTtcblxuICAgIGlmICh0aGlzLnN0ZXAgIT0gMSkge1xuICAgICAgc3RyICs9ICc6JyArIG51bWJlci5mb3JtYXQodGhpcy5zdGVwLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RyICs9ICc6JyArIG51bWJlci5mb3JtYXQodGhpcy5lbmQsIG9wdGlvbnMpO1xuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcmFuZ2UuXG4gICAqIEBtZW1iZXJvZiBSYW5nZVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgUmFuZ2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmZvcm1hdCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSByYW5nZVxuICAgKiBAbWVtYmVyb2YgUmFuZ2VcbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhIEpTT04gb2JqZWN0IHN0cnVjdHVyZWQgYXM6XG4gICAqICAgICAgICAgICAgICAgICAgIGB7XCJtYXRoanNcIjogXCJSYW5nZVwiLCBcInN0YXJ0XCI6IDIsIFwiZW5kXCI6IDQsIFwic3RlcFwiOiAxfWBcbiAgICovXG4gIFJhbmdlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hdGhqczogJ1JhbmdlJyxcbiAgICAgIHN0YXJ0OiB0aGlzLnN0YXJ0LFxuICAgICAgZW5kOiB0aGlzLmVuZCxcbiAgICAgIHN0ZXA6IHRoaXMuc3RlcFxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIEluc3RhbnRpYXRlIGEgUmFuZ2UgZnJvbSBhIEpTT04gb2JqZWN0XG4gICAqIEBtZW1iZXJvZiBSYW5nZVxuICAgKiBAcGFyYW0ge09iamVjdH0ganNvbiBBIEpTT04gb2JqZWN0IHN0cnVjdHVyZWQgYXM6XG4gICAqICAgICAgICAgICAgICAgICAgICAgIGB7XCJtYXRoanNcIjogXCJSYW5nZVwiLCBcInN0YXJ0XCI6IDIsIFwiZW5kXCI6IDQsIFwic3RlcFwiOiAxfWBcbiAgICogQHJldHVybiB7UmFuZ2V9XG4gICAqL1xuICBSYW5nZS5mcm9tSlNPTiA9IGZ1bmN0aW9uIChqc29uKSB7XG4gICAgcmV0dXJuIG5ldyBSYW5nZShqc29uLnN0YXJ0LCBqc29uLmVuZCwganNvbi5zdGVwKTtcbiAgfTtcblxuICByZXR1cm4gUmFuZ2U7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdSYW5nZSc7XG5leHBvcnRzLnBhdGggPSAndHlwZSc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQpIHtcbiAgXG4gIHZhciBhZGQgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL2Z1bmN0aW9uL2FyaXRobWV0aWMvYWRkJykpO1xuICB2YXIgZXF1YWxTY2FsYXIgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL2Z1bmN0aW9uL3JlbGF0aW9uYWwvZXF1YWxTY2FsYXInKSk7XG4gIFxuICAvKipcbiAgICogQW4gb3JkZXJlZCBTcGFyc2UgQWNjdW11bGF0b3IgaXMgYSByZXByZXNlbnRhdGlvbiBmb3IgYSBzcGFyc2UgdmVjdG9yIHRoYXQgaW5jbHVkZXMgYSBkZW5zZSBhcnJheSBcbiAgICogb2YgdGhlIHZlY3RvciBlbGVtZW50cyBhbmQgYW4gb3JkZXJlZCBsaXN0IG9mIG5vbi16ZXJvIGVsZW1lbnRzLlxuICAgKi9cbiAgZnVuY3Rpb24gU3BhKCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTcGEpKVxuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdDb25zdHJ1Y3RvciBtdXN0IGJlIGNhbGxlZCB3aXRoIHRoZSBuZXcgb3BlcmF0b3InKTtcbiAgICBcbiAgICAvLyBhbGxvY2F0ZSB2ZWN0b3IsIFRPRE8gdXNlIHR5cGVkIGFycmF5c1xuICAgIHRoaXMuX3ZhbHVlcyA9IFtdO1xuICAgIHRoaXMuX2hlYXAgPSBuZXcgdHlwZS5GaWJvbmFjY2lIZWFwKCk7XG4gIH1cblxuICAvKipcbiAgICogQXR0YWNoIHR5cGUgaW5mb3JtYXRpb25cbiAgICovXG4gIFNwYS5wcm90b3R5cGUudHlwZSA9ICdTcGEnO1xuICBTcGEucHJvdG90eXBlLmlzU3BhID0gdHJ1ZTtcblxuICAvKipcbiAgICogU2V0IHRoZSB2YWx1ZSBmb3IgaW5kZXggaS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGkgICAgICAgICAgICAgICAgICAgICAgIFRoZSBpbmRleFxuICAgKiBAcGFyYW0ge251bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXh9ICAgVGhlIHZhbHVlIGF0IGluZGV4IGlcbiAgICovXG4gIFNwYS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGksIHYpIHtcbiAgICAvLyBjaGVjayB3ZSBoYXZlIGEgdmFsdWUgQCBpXG4gICAgaWYgKCF0aGlzLl92YWx1ZXNbaV0pIHtcbiAgICAgIC8vIGluc2VydCBpbiBoZWFwXG4gICAgICB2YXIgbm9kZSA9IHRoaXMuX2hlYXAuaW5zZXJ0KGksIHYpO1xuICAgICAgLy8gc2V0IHRoZSB2YWx1ZSBAIGlcbiAgICAgIHRoaXMuX3ZhbHVlc1tpXSA9IG5vZGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gdXBkYXRlIHRoZSB2YWx1ZSBAIGlcbiAgICAgIHRoaXMuX3ZhbHVlc1tpXS52YWx1ZSA9IHY7XG4gICAgfVxuICB9O1xuICBcbiAgU3BhLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaSkge1xuICAgIHZhciBub2RlID0gdGhpcy5fdmFsdWVzW2ldO1xuICAgIGlmIChub2RlKVxuICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gICAgcmV0dXJuIDA7XG4gIH07XG4gIFxuICBTcGEucHJvdG90eXBlLmFjY3VtdWxhdGUgPSBmdW5jdGlvbiAoaSwgdikge1xuICAgIC8vIG5vZGUgQCBpXG4gICAgdmFyIG5vZGUgPSB0aGlzLl92YWx1ZXNbaV07XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICAvLyBpbnNlcnQgaW4gaGVhcFxuICAgICAgbm9kZSA9IHRoaXMuX2hlYXAuaW5zZXJ0KGksIHYpO1xuICAgICAgLy8gaW5pdGlhbGl6ZSB2YWx1ZVxuICAgICAgdGhpcy5fdmFsdWVzW2ldID0gbm9kZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBhY2N1bXVsYXRlIHZhbHVlXG4gICAgICBub2RlLnZhbHVlID0gYWRkKG5vZGUudmFsdWUsIHYpO1xuICAgIH1cbiAgfTtcbiAgXG4gIFNwYS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmcm9tLCB0bywgY2FsbGJhY2spIHtcbiAgICAvLyByZWZlcmVuY2VzXG4gICAgdmFyIGhlYXAgPSB0aGlzLl9oZWFwO1xuICAgIHZhciB2YWx1ZXMgPSB0aGlzLl92YWx1ZXM7XG4gICAgLy8gbm9kZXNcbiAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICAvLyBub2RlIHdpdGggbWluaW11bSBrZXksIHNhdmUgaXRcbiAgICB2YXIgbm9kZSA9IGhlYXAuZXh0cmFjdE1pbmltdW0oKTtcbiAgICBpZiAobm9kZSlcbiAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgLy8gZXh0cmFjdCBub2RlcyBmcm9tIGhlYXAgKG9yZGVyZWQpXG4gICAgd2hpbGUgKG5vZGUgJiYgbm9kZS5rZXkgPD0gdG8pIHtcbiAgICAgIC8vIGNoZWNrIGl0IGlzIGluIHJhbmdlXG4gICAgICBpZiAobm9kZS5rZXkgPj0gZnJvbSkge1xuICAgICAgICAvLyBjaGVjayB2YWx1ZSBpcyBub3QgemVyb1xuICAgICAgICBpZiAoIWVxdWFsU2NhbGFyKG5vZGUudmFsdWUsIDApKSB7XG4gICAgICAgICAgLy8gaW52b2tlIGNhbGxiYWNrXG4gICAgICAgICAgY2FsbGJhY2sobm9kZS5rZXksIG5vZGUudmFsdWUsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBleHRyYWN0IG5leHQgbm9kZSwgc2F2ZSBpdFxuICAgICAgbm9kZSA9IGhlYXAuZXh0cmFjdE1pbmltdW0oKTtcbiAgICAgIGlmIChub2RlKVxuICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgIH1cbiAgICAvLyByZWluc2VydCBhbGwgbm9kZXMgaW4gaGVhcFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIGN1cnJlbnQgbm9kZVxuICAgICAgdmFyIG4gPSBub2Rlc1tpXTtcbiAgICAgIC8vIGluc2VydCBub2RlIGluIGhlYXBcbiAgICAgIG5vZGUgPSBoZWFwLmluc2VydChuLmtleSwgbi52YWx1ZSk7XG4gICAgICAvLyB1cGRhdGUgdmFsdWVzXG4gICAgICB2YWx1ZXNbbm9kZS5rZXldID0gbm9kZTtcbiAgICB9XG4gIH07XG4gIFxuICBTcGEucHJvdG90eXBlLnN3YXAgPSBmdW5jdGlvbiAoaSwgaikge1xuICAgIC8vIG5vZGUgQCBpIGFuZCBqXG4gICAgdmFyIG5vZGVpID0gdGhpcy5fdmFsdWVzW2ldO1xuICAgIHZhciBub2RlaiA9IHRoaXMuX3ZhbHVlc1tqXTtcbiAgICAvLyBjaGVjayB3ZSBuZWVkIHRvIGluc2VydCBpbmRlY2VzXG4gICAgaWYgKCFub2RlaSAmJiBub2Rlaikge1xuICAgICAgLy8gaW5zZXJ0IGluIGhlYXBcbiAgICAgIG5vZGVpID0gdGhpcy5faGVhcC5pbnNlcnQoaSwgbm9kZWoudmFsdWUpO1xuICAgICAgLy8gcmVtb3ZlIGZyb20gaGVhcFxuICAgICAgdGhpcy5faGVhcC5yZW1vdmUobm9kZWopO1xuICAgICAgLy8gc2V0IHZhbHVlc1xuICAgICAgdGhpcy5fdmFsdWVzW2ldID0gbm9kZWk7XG4gICAgICB0aGlzLl92YWx1ZXNbal0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGVpICYmICFub2Rlaikge1xuICAgICAgLy8gaW5zZXJ0IGluIGhlYXBcbiAgICAgIG5vZGVqID0gdGhpcy5faGVhcC5pbnNlcnQoaiwgbm9kZWkudmFsdWUpO1xuICAgICAgLy8gcmVtb3ZlIGZyb20gaGVhcFxuICAgICAgdGhpcy5faGVhcC5yZW1vdmUobm9kZWkpO1xuICAgICAgLy8gc2V0IHZhbHVlc1xuICAgICAgdGhpcy5fdmFsdWVzW2pdID0gbm9kZWo7XG4gICAgICB0aGlzLl92YWx1ZXNbaV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGVpICYmIG5vZGVqKSB7XG4gICAgICAvLyBzd2FwIHZhbHVlc1xuICAgICAgdmFyIHYgPSBub2RlaS52YWx1ZTtcbiAgICAgIG5vZGVpLnZhbHVlID0gbm9kZWoudmFsdWU7XG4gICAgICBub2Rlai52YWx1ZSA9IHY7XG4gICAgfVxuICB9O1xuICBcbiAgcmV0dXJuIFNwYTtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ1NwYSc7XG5leHBvcnRzLnBhdGggPSAndHlwZSc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2luZGV4Jyk7XG52YXIgRGltZW5zaW9uRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9lcnJvci9EaW1lbnNpb25FcnJvcicpO1xuXG52YXIgYXJyYXkgPSB1dGlsLmFycmF5O1xudmFyIG9iamVjdCA9IHV0aWwub2JqZWN0O1xudmFyIHN0cmluZyA9IHV0aWwuc3RyaW5nO1xudmFyIG51bWJlciA9IHV0aWwubnVtYmVyO1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG52YXIgaXNOdW1iZXIgPSBudW1iZXIuaXNOdW1iZXI7XG52YXIgaXNJbnRlZ2VyID0gbnVtYmVyLmlzSW50ZWdlcjtcbnZhciBpc1N0cmluZyA9IHN0cmluZy5pc1N0cmluZztcblxudmFyIHZhbGlkYXRlSW5kZXggPSBhcnJheS52YWxpZGF0ZUluZGV4O1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBNYXRyaXggPSBsb2FkKHJlcXVpcmUoJy4vTWF0cml4JykpOyAvLyBmb3JjZSBsb2FkaW5nIE1hdHJpeCAoZG8gbm90IHVzZSB2aWEgdHlwZS5NYXRyaXgpXG4gIHZhciBlcXVhbFNjYWxhciA9IGxvYWQocmVxdWlyZSgnLi4vLi4vZnVuY3Rpb24vcmVsYXRpb25hbC9lcXVhbFNjYWxhcicpKTtcblxuICAvKipcbiAgICogU3BhcnNlIE1hdHJpeCBpbXBsZW1lbnRhdGlvbi4gVGhpcyB0eXBlIGltcGxlbWVudHMgYSBDb21wcmVzc2VkIENvbHVtbiBTdG9yYWdlIGZvcm1hdFxuICAgKiBmb3Igc3BhcnNlIG1hdHJpY2VzLlxuICAgKiBAY2xhc3MgU3BhcnNlTWF0cml4XG4gICAqL1xuICBmdW5jdGlvbiBTcGFyc2VNYXRyaXgoZGF0YSwgZGF0YXR5cGUpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU3BhcnNlTWF0cml4KSlcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQ29uc3RydWN0b3IgbXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgbmV3IG9wZXJhdG9yJyk7XG4gICAgaWYgKGRhdGF0eXBlICYmICFpc1N0cmluZyhkYXRhdHlwZSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGF0YXR5cGU6ICcgKyBkYXRhdHlwZSk7XG4gICAgXG4gICAgaWYgKGRhdGEgJiYgZGF0YS5pc01hdHJpeCA9PT0gdHJ1ZSkge1xuICAgICAgLy8gY3JlYXRlIGZyb20gbWF0cml4XG4gICAgICBfY3JlYXRlRnJvbU1hdHJpeCh0aGlzLCBkYXRhLCBkYXRhdHlwZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGEgJiYgaXNBcnJheShkYXRhLmluZGV4KSAmJiBpc0FycmF5KGRhdGEucHRyKSAmJiBpc0FycmF5KGRhdGEuc2l6ZSkpIHtcbiAgICAgIC8vIGluaXRpYWxpemUgZmllbGRzXG4gICAgICB0aGlzLl92YWx1ZXMgPSBkYXRhLnZhbHVlcztcbiAgICAgIHRoaXMuX2luZGV4ID0gZGF0YS5pbmRleDtcbiAgICAgIHRoaXMuX3B0ciA9IGRhdGEucHRyO1xuICAgICAgdGhpcy5fc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICAgIHRoaXMuX2RhdGF0eXBlID0gZGF0YXR5cGUgfHwgZGF0YS5kYXRhdHlwZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNBcnJheShkYXRhKSkge1xuICAgICAgLy8gY3JlYXRlIGZyb20gYXJyYXlcbiAgICAgIF9jcmVhdGVGcm9tQXJyYXkodGhpcywgZGF0YSwgZGF0YXR5cGUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhKSB7XG4gICAgICAvLyB1bnN1cHBvcnRlZCB0eXBlXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbnN1cHBvcnRlZCB0eXBlIG9mIGRhdGEgKCcgKyB1dGlsLnR5cGVzLnR5cGUoZGF0YSkgKyAnKScpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIG5vdGhpbmcgcHJvdmlkZWRcbiAgICAgIHRoaXMuX3ZhbHVlcyA9IFtdO1xuICAgICAgdGhpcy5faW5kZXggPSBbXTtcbiAgICAgIHRoaXMuX3B0ciA9IFswXTtcbiAgICAgIHRoaXMuX3NpemUgPSBbMCwgMF07XG4gICAgICB0aGlzLl9kYXRhdHlwZSA9IGRhdGF0eXBlO1xuICAgIH1cbiAgfVxuICBcbiAgdmFyIF9jcmVhdGVGcm9tTWF0cml4ID0gZnVuY3Rpb24gKG1hdHJpeCwgc291cmNlLCBkYXRhdHlwZSkge1xuICAgIC8vIGNoZWNrIG1hdHJpeCB0eXBlXG4gICAgaWYgKHNvdXJjZS50eXBlID09PSAnU3BhcnNlTWF0cml4Jykge1xuICAgICAgLy8gY2xvbmUgYXJyYXlzXG4gICAgICBtYXRyaXguX3ZhbHVlcyA9IHNvdXJjZS5fdmFsdWVzID8gb2JqZWN0LmNsb25lKHNvdXJjZS5fdmFsdWVzKSA6IHVuZGVmaW5lZDtcbiAgICAgIG1hdHJpeC5faW5kZXggPSBvYmplY3QuY2xvbmUoc291cmNlLl9pbmRleCk7XG4gICAgICBtYXRyaXguX3B0ciA9IG9iamVjdC5jbG9uZShzb3VyY2UuX3B0cik7XG4gICAgICBtYXRyaXguX3NpemUgPSBvYmplY3QuY2xvbmUoc291cmNlLl9zaXplKTtcbiAgICAgIG1hdHJpeC5fZGF0YXR5cGUgPSBkYXRhdHlwZSB8fCBzb3VyY2UuX2RhdGF0eXBlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGJ1aWxkIGZyb20gbWF0cml4IGRhdGFcbiAgICAgIF9jcmVhdGVGcm9tQXJyYXkobWF0cml4LCBzb3VyY2UudmFsdWVPZigpLCBkYXRhdHlwZSB8fCBzb3VyY2UuX2RhdGF0eXBlKTtcbiAgICB9XG4gIH07XG4gIFxuICB2YXIgX2NyZWF0ZUZyb21BcnJheSA9IGZ1bmN0aW9uIChtYXRyaXgsIGRhdGEsIGRhdGF0eXBlKSB7XG4gICAgLy8gaW5pdGlhbGl6ZSBmaWVsZHNcbiAgICBtYXRyaXguX3ZhbHVlcyA9IFtdO1xuICAgIG1hdHJpeC5faW5kZXggPSBbXTtcbiAgICBtYXRyaXguX3B0ciA9IFtdO1xuICAgIG1hdHJpeC5fZGF0YXR5cGUgPSBkYXRhdHlwZTtcbiAgICAvLyBkaXNjb3ZlciByb3dzICYgY29sdW1ucywgZG8gbm90IHVzZSBtYXRoLnNpemUoKSB0byBhdm9pZCBsb29waW5nIGFycmF5IHR3aWNlXG4gICAgdmFyIHJvd3MgPSBkYXRhLmxlbmd0aDtcbiAgICB2YXIgY29sdW1ucyA9IDA7XG4gICAgXG4gICAgLy8gZXF1YWwgc2lnbmF0dXJlIHRvIHVzZVxuICAgIHZhciBlcSA9IGVxdWFsU2NhbGFyO1xuICAgIC8vIHplcm8gdmFsdWVcbiAgICB2YXIgemVybyA9IDA7XG4gICAgXG4gICAgaWYgKGlzU3RyaW5nKGRhdGF0eXBlKSkge1xuICAgICAgLy8gZmluZCBzaWduYXR1cmUgdGhhdCBtYXRjaGVzIChkYXRhdHlwZSwgZGF0YXR5cGUpXG4gICAgICBlcSA9IHR5cGVkLmZpbmQoZXF1YWxTY2FsYXIsIFtkYXRhdHlwZSwgZGF0YXR5cGVdKSB8fCBlcXVhbFNjYWxhcjtcbiAgICAgIC8vIGNvbnZlcnQgMCB0byB0aGUgc2FtZSBkYXRhdHlwZVxuICAgICAgemVybyA9IHR5cGVkLmNvbnZlcnQoMCwgZGF0YXR5cGUpO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIHdlIGhhdmUgcm93cyAoZW1wdHkgYXJyYXkpXG4gICAgaWYgKHJvd3MgPiAwKSB7XG4gICAgICAvLyBjb2x1bW4gaW5kZXhcbiAgICAgIHZhciBqID0gMDtcbiAgICAgIGRvIHtcbiAgICAgICAgLy8gc3RvcmUgcG9pbnRlciB0byB2YWx1ZXMgaW5kZXhcbiAgICAgICAgbWF0cml4Ll9wdHIucHVzaChtYXRyaXguX2luZGV4Lmxlbmd0aCk7XG4gICAgICAgIC8vIGxvb3Agcm93c1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgICAgIC8vIGN1cnJlbnQgcm93XG4gICAgICAgICAgdmFyIHJvdyA9IGRhdGFbaV07XG4gICAgICAgICAgLy8gY2hlY2sgcm93IGlzIGFuIGFycmF5XG4gICAgICAgICAgaWYgKGlzQXJyYXkocm93KSkge1xuICAgICAgICAgICAgLy8gdXBkYXRlIGNvbHVtbnMgaWYgbmVlZGVkIChvbmx5IG9uIGZpcnN0IGNvbHVtbilcbiAgICAgICAgICAgIGlmIChqID09PSAwICYmIGNvbHVtbnMgPCByb3cubGVuZ3RoKVxuICAgICAgICAgICAgICBjb2x1bW5zID0gcm93Lmxlbmd0aDtcbiAgICAgICAgICAgIC8vIGNoZWNrIHJvdyBoYXMgY29sdW1uXG4gICAgICAgICAgICBpZiAoaiA8IHJvdy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgLy8gdmFsdWVcbiAgICAgICAgICAgICAgdmFyIHYgPSByb3dbal07XG4gICAgICAgICAgICAgIC8vIGNoZWNrIHZhbHVlICE9IDBcbiAgICAgICAgICAgICAgaWYgKCFlcSh2LCB6ZXJvKSkge1xuICAgICAgICAgICAgICAgIC8vIHN0b3JlIHZhbHVlXG4gICAgICAgICAgICAgICAgbWF0cml4Ll92YWx1ZXMucHVzaCh2KTtcbiAgICAgICAgICAgICAgICAvLyBpbmRleFxuICAgICAgICAgICAgICAgIG1hdHJpeC5faW5kZXgucHVzaChpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBjb2x1bW5zIGlmIG5lZWRlZCAob25seSBvbiBmaXJzdCBjb2x1bW4pXG4gICAgICAgICAgICBpZiAoaiA9PT0gMCAmJiBjb2x1bW5zIDwgMSlcbiAgICAgICAgICAgICAgY29sdW1ucyA9IDE7XG4gICAgICAgICAgICAvLyBjaGVjayB2YWx1ZSAhPSAwIChyb3cgaXMgYSBzY2FsYXIpXG4gICAgICAgICAgICBpZiAoIWVxKHJvdywgemVybykpIHtcbiAgICAgICAgICAgICAgLy8gc3RvcmUgdmFsdWVcbiAgICAgICAgICAgICAgbWF0cml4Ll92YWx1ZXMucHVzaChyb3cpO1xuICAgICAgICAgICAgICAvLyBpbmRleFxuICAgICAgICAgICAgICBtYXRyaXguX2luZGV4LnB1c2goaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGluY3JlbWVudCBpbmRleFxuICAgICAgICBqKys7ICAgICAgXG4gICAgICB9XG4gICAgICB3aGlsZSAoaiA8IGNvbHVtbnMpO1xuICAgIH1cbiAgICAvLyBzdG9yZSBudW1iZXIgb2YgdmFsdWVzIGluIHB0clxuICAgIG1hdHJpeC5fcHRyLnB1c2gobWF0cml4Ll9pbmRleC5sZW5ndGgpO1xuICAgIC8vIHNpemVcbiAgICBtYXRyaXguX3NpemUgPSBbcm93cywgY29sdW1uc107XG4gIH07XG4gIFxuICBTcGFyc2VNYXRyaXgucHJvdG90eXBlID0gbmV3IE1hdHJpeCgpO1xuXG4gIC8qKlxuICAgKiBBdHRhY2ggdHlwZSBpbmZvcm1hdGlvblxuICAgKi9cbiAgU3BhcnNlTWF0cml4LnByb3RvdHlwZS50eXBlID0gJ1NwYXJzZU1hdHJpeCc7XG4gIFNwYXJzZU1hdHJpeC5wcm90b3R5cGUuaXNTcGFyc2VNYXRyaXggPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0b3JhZ2UgZm9ybWF0IHVzZWQgYnkgdGhlIG1hdHJpeC5cbiAgICpcbiAgICogVXNhZ2U6XG4gICAqICAgICB2YXIgZm9ybWF0ID0gbWF0cml4LnN0b3JhZ2UoKSAgICAgICAgICAgICAgICAgICAvLyByZXRyaWV2ZSBzdG9yYWdlIGZvcm1hdFxuICAgKlxuICAgKiBAbWVtYmVyb2YgU3BhcnNlTWF0cml4XG4gICAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgICAgIFRoZSBzdG9yYWdlIGZvcm1hdC5cbiAgICovXG4gIFNwYXJzZU1hdHJpeC5wcm90b3R5cGUuc3RvcmFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJ3NwYXJzZSc7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGF0YXR5cGUgb2YgdGhlIGRhdGEgc3RvcmVkIGluIHRoZSBtYXRyaXguXG4gICAqXG4gICAqIFVzYWdlOlxuICAgKiAgICAgdmFyIGZvcm1hdCA9IG1hdHJpeC5kYXRhdHlwZSgpICAgICAgICAgICAgICAgICAgIC8vIHJldHJpZXZlIG1hdHJpeCBkYXRhdHlwZVxuICAgKlxuICAgKiBAbWVtYmVyb2YgU3BhcnNlTWF0cml4XG4gICAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgICAgIFRoZSBkYXRhdHlwZS5cbiAgICovXG4gIFNwYXJzZU1hdHJpeC5wcm90b3R5cGUuZGF0YXR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGF0eXBlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgU3BhcnNlTWF0cml4XG4gICAqIEBtZW1iZXJvZiBTcGFyc2VNYXRyaXhcbiAgICogQHBhcmFtIHtBcnJheX0gZGF0YVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2RhdGF0eXBlXVxuICAgKi9cbiAgU3BhcnNlTWF0cml4LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoZGF0YSwgZGF0YXR5cGUpIHtcbiAgICByZXR1cm4gbmV3IFNwYXJzZU1hdHJpeChkYXRhLCBkYXRhdHlwZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWF0cml4IGRlbnNpdHkuXG4gICAqXG4gICAqIFVzYWdlOlxuICAgKiAgICAgdmFyIGRlbnNpdHkgPSBtYXRyaXguZGVuc2l0eSgpICAgICAgICAgICAgICAgICAgIC8vIHJldHJpZXZlIG1hdHJpeCBkZW5zaXR5XG4gICAqXG4gICAqIEBtZW1iZXJvZiBTcGFyc2VNYXRyaXhcbiAgICogQHJldHVybiB7bnVtYmVyfSAgICAgICAgICAgVGhlIG1hdHJpeCBkZW5zaXR5LlxuICAgKi9cbiAgU3BhcnNlTWF0cml4LnByb3RvdHlwZS5kZW5zaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHJvd3MgJiBjb2x1bW5zXG4gICAgdmFyIHJvd3MgPSB0aGlzLl9zaXplWzBdO1xuICAgIHZhciBjb2x1bW5zID0gdGhpcy5fc2l6ZVsxXTtcbiAgICAvLyBjYWxjdWxhdGUgZGVuc2l0eVxuICAgIHJldHVybiByb3dzICE9PSAwICYmIGNvbHVtbnMgIT09IDAgPyAodGhpcy5faW5kZXgubGVuZ3RoIC8gKHJvd3MgKiBjb2x1bW5zKSkgOiAwO1xuICB9O1xuICBcbiAgLyoqXG4gICAqIEdldCBhIHN1YnNldCBvZiB0aGUgbWF0cml4LCBvciByZXBsYWNlIGEgc3Vic2V0IG9mIHRoZSBtYXRyaXguXG4gICAqXG4gICAqIFVzYWdlOlxuICAgKiAgICAgdmFyIHN1YnNldCA9IG1hdHJpeC5zdWJzZXQoaW5kZXgpICAgICAgICAgICAgICAgLy8gcmV0cmlldmUgc3Vic2V0XG4gICAqICAgICB2YXIgdmFsdWUgPSBtYXRyaXguc3Vic2V0KGluZGV4LCByZXBsYWNlbWVudCkgICAvLyByZXBsYWNlIHN1YnNldFxuICAgKlxuICAgKiBAbWVtYmVyb2YgU3BhcnNlTWF0cml4XG4gICAqIEBwYXJhbSB7SW5kZXh9IGluZGV4XG4gICAqIEBwYXJhbSB7QXJyYXkgfCBNYXl0cml4IHwgKn0gW3JlcGxhY2VtZW50XVxuICAgKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWU9MF0gICAgICBEZWZhdWx0IHZhbHVlLCBmaWxsZWQgaW4gb24gbmV3IGVudHJpZXMgd2hlblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgbWF0cml4IGlzIHJlc2l6ZWQuIElmIG5vdCBwcm92aWRlZCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IG1hdHJpeCBlbGVtZW50cyB3aWxsIGJlIGZpbGxlZCB3aXRoIHplcm9zLlxuICAgKi9cbiAgU3BhcnNlTWF0cml4LnByb3RvdHlwZS5zdWJzZXQgPSBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50LCBkZWZhdWx0VmFsdWUpIHsgLy8gY2hlY2sgaXQgaXMgYSBwYXR0ZXJuIG1hdHJpeFxuICAgIGlmICghdGhpcy5fdmFsdWVzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52b2tlIHN1YnNldCBvbiBhIFBhdHRlcm4gb25seSBtYXRyaXgnKTtcblxuICAgIC8vIGNoZWNrIGFyZ3VtZW50c1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gX2dldHN1YnNldCh0aGlzLCBpbmRleCk7XG5cbiAgICAgICAgLy8gaW50ZW50aW9uYWwgZmFsbCB0aHJvdWdoXG4gICAgICBjYXNlIDI6XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiBfc2V0c3Vic2V0KHRoaXMsIGluZGV4LCByZXBsYWNlbWVudCwgZGVmYXVsdFZhbHVlKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdXcm9uZyBudW1iZXIgb2YgYXJndW1lbnRzJyk7XG4gICAgfVxuICB9O1xuICBcbiAgdmFyIF9nZXRzdWJzZXQgPSBmdW5jdGlvbiAobWF0cml4LCBpZHgpIHtcbiAgICAvLyBjaGVjayBpZHhcbiAgICBpZiAoIWlkeCB8fCBpZHguaXNJbmRleCAhPT0gdHJ1ZSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBpbmRleCcpO1xuICAgIH1cblxuICAgIHZhciBpc1NjYWxhciA9IGlkeC5pc1NjYWxhcigpO1xuICAgIGlmIChpc1NjYWxhcikge1xuICAgICAgLy8gcmV0dXJuIGEgc2NhbGFyXG4gICAgICByZXR1cm4gbWF0cml4LmdldChpZHgubWluKCkpO1xuICAgIH1cbiAgICAvLyB2YWxpZGF0ZSBkaW1lbnNpb25zXG4gICAgdmFyIHNpemUgPSBpZHguc2l6ZSgpO1xuICAgIGlmIChzaXplLmxlbmd0aCAhPSBtYXRyaXguX3NpemUubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRGltZW5zaW9uRXJyb3Ioc2l6ZS5sZW5ndGgsIG1hdHJpeC5fc2l6ZS5sZW5ndGgpO1xuICAgIH1cblxuICAgIC8vIHZhcnNcbiAgICB2YXIgaSwgaWksIGssIGtrO1xuICAgIFxuICAgIC8vIHZhbGlkYXRlIGlmIGFueSBvZiB0aGUgcmFuZ2VzIGluIHRoZSBpbmRleCBpcyBvdXQgb2YgcmFuZ2VcbiAgICB2YXIgbWluID0gaWR4Lm1pbigpO1xuICAgIHZhciBtYXggPSBpZHgubWF4KCk7XG4gICAgZm9yIChpID0gMCwgaWkgPSBtYXRyaXguX3NpemUubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgdmFsaWRhdGVJbmRleChtaW5baV0sIG1hdHJpeC5fc2l6ZVtpXSk7XG4gICAgICB2YWxpZGF0ZUluZGV4KG1heFtpXSwgbWF0cml4Ll9zaXplW2ldKTtcbiAgICB9XG4gICAgXG4gICAgLy8gbWF0cml4IGFycmF5c1xuICAgIHZhciBtdmFsdWVzID0gbWF0cml4Ll92YWx1ZXM7XG4gICAgdmFyIG1pbmRleCA9IG1hdHJpeC5faW5kZXg7XG4gICAgdmFyIG1wdHIgPSBtYXRyaXguX3B0cjtcbiAgICAgICAgXG4gICAgLy8gcm93cyAmIGNvbHVtbnMgZGltZW5zaW9ucyBmb3IgcmVzdWx0IG1hdHJpeFxuICAgIHZhciByb3dzID0gaWR4LmRpbWVuc2lvbigwKTtcbiAgICB2YXIgY29sdW1ucyA9IGlkeC5kaW1lbnNpb24oMSk7XG4gICAgXG4gICAgLy8gd29ya3NwYWNlICYgcGVybXV0YXRpb24gdmVjdG9yXG4gICAgdmFyIHcgPSBbXTtcbiAgICB2YXIgcHYgPSBbXTtcbiAgICBcbiAgICAvLyBsb29wIHJvd3MgaW4gcmVzdWx0aW5nIG1hdHJpeFxuICAgIHJvd3MuZm9yRWFjaChmdW5jdGlvbiAoaSwgcikge1xuICAgICAgLy8gdXBkYXRlIHBlcm11dGF0aW9uIHZlY3RvclxuICAgICAgcHZbaV0gPSByWzBdOyAgXG4gICAgICAvLyBtYXJrIGkgaW4gd29ya3NwYWNlXG4gICAgICB3W2ldID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIC8vIHJlc3VsdCBtYXRyaXggYXJyYXlzXG4gICAgdmFyIHZhbHVlcyA9IG12YWx1ZXMgPyBbXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgaW5kZXggPSBbXTtcbiAgICB2YXIgcHRyID0gW107XG4gICAgICAgIFxuICAgIC8vIGxvb3AgY29sdW1ucyBpbiByZXN1bHQgbWF0cml4XG4gICAgY29sdW1ucy5mb3JFYWNoKGZ1bmN0aW9uIChqKSB7XG4gICAgICAvLyB1cGRhdGUgcHRyXG4gICAgICBwdHIucHVzaChpbmRleC5sZW5ndGgpO1xuICAgICAgLy8gbG9vcCB2YWx1ZXMgaW4gY29sdW1uIGpcbiAgICAgIGZvciAoayA9IG1wdHJbal0sIGtrID0gbXB0cltqICsgMV07IGsgPCBrazsgaysrKSB7XG4gICAgICAgIC8vIHJvd1xuICAgICAgICBpID0gbWluZGV4W2tdO1xuICAgICAgICAvLyBjaGVjayByb3cgaXMgaW4gcmVzdWx0IG1hdHJpeFxuICAgICAgICBpZiAod1tpXSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIC8vIHB1c2ggaW5kZXhcbiAgICAgICAgICBpbmRleC5wdXNoKHB2W2ldKTtcbiAgICAgICAgICAvLyBjaGVjayB3ZSBuZWVkIHRvIHByb2Nlc3MgdmFsdWVzXG4gICAgICAgICAgaWYgKHZhbHVlcylcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKG12YWx1ZXNba10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gdXBkYXRlIHB0clxuICAgIHB0ci5wdXNoKGluZGV4Lmxlbmd0aCk7XG4gICAgXG4gICAgLy8gcmV0dXJuIG1hdHJpeFxuICAgIHJldHVybiBuZXcgU3BhcnNlTWF0cml4KHtcbiAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgcHRyOiBwdHIsXG4gICAgICBzaXplOiBzaXplLFxuICAgICAgZGF0YXR5cGU6IG1hdHJpeC5fZGF0YXR5cGVcbiAgICB9KTtcbiAgfTtcbiAgXG4gIHZhciBfc2V0c3Vic2V0ID0gZnVuY3Rpb24gKG1hdHJpeCwgaW5kZXgsIHN1Ym1hdHJpeCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgLy8gY2hlY2sgaW5kZXhcbiAgICBpZiAoIWluZGV4IHx8IGluZGV4LmlzSW5kZXggIT09IHRydWUpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaW5kZXgnKTtcbiAgICB9XG4gICAgXG4gICAgLy8gZ2V0IGluZGV4IHNpemUgYW5kIGNoZWNrIHdoZXRoZXIgdGhlIGluZGV4IGNvbnRhaW5zIGEgc2luZ2xlIHZhbHVlXG4gICAgdmFyIGlTaXplID0gaW5kZXguc2l6ZSgpLFxuICAgICAgICBpc1NjYWxhciA9IGluZGV4LmlzU2NhbGFyKCk7XG4gICAgXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBzaXplIG9mIHRoZSBzdWJtYXRyaXgsIGFuZCBjb252ZXJ0IGl0IGludG8gYW4gQXJyYXkgaWYgbmVlZGVkXG4gICAgdmFyIHNTaXplO1xuICAgIGlmIChzdWJtYXRyaXggJiYgc3VibWF0cml4LmlzTWF0cml4ID09PSB0cnVlKSB7XG4gICAgICAvLyBzdWJtYXRyaXggc2l6ZVxuICAgICAgc1NpemUgPSBzdWJtYXRyaXguc2l6ZSgpO1xuICAgICAgLy8gdXNlIGFycmF5IHJlcHJlc2VudGF0aW9uXG4gICAgICBzdWJtYXRyaXggPSBzdWJtYXRyaXgudG9BcnJheSgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGdldCBzdWJtYXRyaXggc2l6ZSAoYXJyYXksIHNjYWxhcilcbiAgICAgIHNTaXplID0gYXJyYXkuc2l6ZShzdWJtYXRyaXgpO1xuICAgIH1cbiAgICBcbiAgICAvLyBjaGVjayBpbmRleCBpcyBhIHNjYWxhclxuICAgIGlmIChpc1NjYWxhcikge1xuICAgICAgLy8gdmVyaWZ5IHN1Ym1hdHJpeCBpcyBhIHNjYWxhclxuICAgICAgaWYgKHNTaXplLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTY2FsYXIgZXhwZWN0ZWQnKTtcbiAgICAgIH1cbiAgICAgIC8vIHNldCB2YWx1ZVxuICAgICAgbWF0cml4LnNldChpbmRleC5taW4oKSwgc3VibWF0cml4LCBkZWZhdWx0VmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIHZhbGlkYXRlIGRpbWVuc2lvbnMsIGluZGV4IHNpemUgbXVzdCBiZSBvbmUgb3IgdHdvIGRpbWVuc2lvbnNcbiAgICAgIGlmIChpU2l6ZS5sZW5ndGggIT09IDEgJiYgaVNpemUubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBEaW1lbnNpb25FcnJvcihpU2l6ZS5sZW5ndGgsIG1hdHJpeC5fc2l6ZS5sZW5ndGgsICc8Jyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIGNoZWNrIHN1Ym1hdHJpeCBhbmQgaW5kZXggaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb25zXG4gICAgICBpZiAoc1NpemUubGVuZ3RoIDwgaVNpemUubGVuZ3RoKSB7XG4gICAgICAgIC8vIGNhbGN1bGF0ZSBudW1iZXIgb2YgbWlzc2luZyBvdXRlciBkaW1lbnNpb25zXG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIG91dGVyID0gMDtcbiAgICAgICAgd2hpbGUgKGlTaXplW2ldID09PSAxICYmIHNTaXplW2ldID09PSAxKSB7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChpU2l6ZVtpXSA9PT0gMSkge1xuICAgICAgICAgIG91dGVyKys7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIC8vIHVuc3F1ZWV6ZSBib3RoIG91dGVyIGFuZCBpbm5lciBkaW1lbnNpb25zXG4gICAgICAgIHN1Ym1hdHJpeCA9IGFycmF5LnVuc3F1ZWV6ZShzdWJtYXRyaXgsIGlTaXplLmxlbmd0aCwgb3V0ZXIsIHNTaXplKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gY2hlY2sgd2hldGhlciB0aGUgc2l6ZSBvZiB0aGUgc3VibWF0cml4IG1hdGNoZXMgdGhlIGluZGV4IHNpemVcbiAgICAgIGlmICghb2JqZWN0LmRlZXBFcXVhbChpU2l6ZSwgc1NpemUpKSB7XG4gICAgICAgIHRocm93IG5ldyBEaW1lbnNpb25FcnJvcihpU2l6ZSwgc1NpemUsICc+Jyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIG9mZnNldHNcbiAgICAgIHZhciB4MCA9IGluZGV4Lm1pbigpWzBdO1xuICAgICAgdmFyIHkwID0gaW5kZXgubWluKClbMV07ICAgICAgXG4gICAgICBcbiAgICAgIC8vIHN1Ym1hdHJpeCByb3dzIGFuZCBjb2x1bW5zXG4gICAgICB2YXIgbSA9IHNTaXplWzBdO1xuICAgICAgdmFyIG4gPSBzU2l6ZVsxXTtcblxuICAgICAgLy8gbG9vcCBzdWJtYXRyaXhcbiAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgbTsgeCsrKSB7XG4gICAgICAgIC8vIGxvb3AgY29sdW1uc1xuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IG47IHkrKykge1xuICAgICAgICAgIC8vIHZhbHVlIGF0IGksIGpcbiAgICAgICAgICB2YXIgdiA9IHN1Ym1hdHJpeFt4XVt5XTtcbiAgICAgICAgICAvLyBpbnZva2Ugc2V0ICh6ZXJvIHZhbHVlIHdpbGwgcmVtb3ZlIGVudHJ5IGZyb20gbWF0cml4KVxuICAgICAgICAgIG1hdHJpeC5zZXQoW3ggKyB4MCwgeSArIHkwXSwgdiwgZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF0cml4O1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSBzaW5nbGUgZWxlbWVudCBmcm9tIHRoZSBtYXRyaXguXG4gICAqIEBtZW1iZXJvZiBTcGFyc2VNYXRyaXhcbiAgICogQHBhcmFtIHtudW1iZXJbXX0gaW5kZXggICBaZXJvLWJhc2VkIGluZGV4XG4gICAqIEByZXR1cm4geyp9IHZhbHVlXG4gICAqL1xuICBTcGFyc2VNYXRyaXgucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIGlmICghaXNBcnJheShpbmRleCkpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheSBleHBlY3RlZCcpO1xuICAgIGlmIChpbmRleC5sZW5ndGggIT0gdGhpcy5fc2l6ZS5sZW5ndGgpXG4gICAgICB0aHJvdyBuZXcgRGltZW5zaW9uRXJyb3IoaW5kZXgubGVuZ3RoLCB0aGlzLl9zaXplLmxlbmd0aCk7XG5cbiAgICAvLyBjaGVjayBpdCBpcyBhIHBhdHRlcm4gbWF0cml4XG4gICAgaWYgKCF0aGlzLl92YWx1ZXMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZva2UgZ2V0IG9uIGEgUGF0dGVybiBvbmx5IG1hdHJpeCcpO1xuXG4gICAgLy8gcm93IGFuZCBjb2x1bW5cbiAgICB2YXIgaSA9IGluZGV4WzBdO1xuICAgIHZhciBqID0gaW5kZXhbMV07XG5cbiAgICAvLyBjaGVjayBpLCBqIGFyZSB2YWxpZFxuICAgIHZhbGlkYXRlSW5kZXgoaSwgdGhpcy5fc2l6ZVswXSk7XG4gICAgdmFsaWRhdGVJbmRleChqLCB0aGlzLl9zaXplWzFdKTtcblxuICAgIC8vIGZpbmQgdmFsdWUgaW5kZXhcbiAgICB2YXIgayA9IF9nZXRWYWx1ZUluZGV4KGksIHRoaXMuX3B0cltqXSwgdGhpcy5fcHRyW2ogKyAxXSwgdGhpcy5faW5kZXgpO1xuICAgIC8vIGNoZWNrIGsgaXMgcHJpb3IgdG8gbmV4dCBjb2x1bW4gayBhbmQgaXQgaXMgaW4gdGhlIGNvcnJlY3Qgcm93XG4gICAgaWYgKGsgPCB0aGlzLl9wdHJbaiArIDFdICYmIHRoaXMuX2luZGV4W2tdID09PSBpKVxuICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlc1trXTtcblxuICAgIHJldHVybiAwO1xuICB9O1xuICBcbiAgLyoqXG4gICAqIFJlcGxhY2UgYSBzaW5nbGUgZWxlbWVudCBpbiB0aGUgbWF0cml4LlxuICAgKiBAbWVtYmVyb2YgU3BhcnNlTWF0cml4XG4gICAqIEBwYXJhbSB7bnVtYmVyW119IGluZGV4ICAgWmVyby1iYXNlZCBpbmRleFxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gICAgICAgIERlZmF1bHQgdmFsdWUsIGZpbGxlZCBpbiBvbiBuZXcgZW50cmllcyB3aGVuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBtYXRyaXggaXMgcmVzaXplZC4gSWYgbm90IHByb3ZpZGVkLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgbWF0cml4IGVsZW1lbnRzIHdpbGwgYmUgc2V0IHRvIHplcm8uXG4gICAqIEByZXR1cm4ge1NwYXJzZU1hdHJpeH0gc2VsZlxuICAgKi9cbiAgU3BhcnNlTWF0cml4LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoaW5kZXgsIHYsIGRlZmF1bHRWYWx1ZSkge1xuICAgIGlmICghaXNBcnJheShpbmRleCkpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheSBleHBlY3RlZCcpO1xuICAgIGlmIChpbmRleC5sZW5ndGggIT0gdGhpcy5fc2l6ZS5sZW5ndGgpXG4gICAgICB0aHJvdyBuZXcgRGltZW5zaW9uRXJyb3IoaW5kZXgubGVuZ3RoLCB0aGlzLl9zaXplLmxlbmd0aCk7XG5cbiAgICAvLyBjaGVjayBpdCBpcyBhIHBhdHRlcm4gbWF0cml4XG4gICAgaWYgKCF0aGlzLl92YWx1ZXMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZva2Ugc2V0IG9uIGEgUGF0dGVybiBvbmx5IG1hdHJpeCcpO1xuICAgICAgXG4gICAgLy8gcm93IGFuZCBjb2x1bW5cbiAgICB2YXIgaSA9IGluZGV4WzBdO1xuICAgIHZhciBqID0gaW5kZXhbMV07XG5cbiAgICAvLyByb3dzICYgY29sdW1uc1xuICAgIHZhciByb3dzID0gdGhpcy5fc2l6ZVswXTtcbiAgICB2YXIgY29sdW1ucyA9IHRoaXMuX3NpemVbMV07XG4gICAgXG4gICAgLy8gZXF1YWwgc2lnbmF0dXJlIHRvIHVzZVxuICAgIHZhciBlcSA9IGVxdWFsU2NhbGFyO1xuICAgIC8vIHplcm8gdmFsdWVcbiAgICB2YXIgemVybyA9IDA7XG5cbiAgICBpZiAoaXNTdHJpbmcodGhpcy5fZGF0YXR5cGUpKSB7XG4gICAgICAvLyBmaW5kIHNpZ25hdHVyZSB0aGF0IG1hdGNoZXMgKGRhdGF0eXBlLCBkYXRhdHlwZSlcbiAgICAgIGVxID0gdHlwZWQuZmluZChlcXVhbFNjYWxhciwgW3RoaXMuX2RhdGF0eXBlLCB0aGlzLl9kYXRhdHlwZV0pIHx8IGVxdWFsU2NhbGFyO1xuICAgICAgLy8gY29udmVydCAwIHRvIHRoZSBzYW1lIGRhdGF0eXBlXG4gICAgICB6ZXJvID0gdHlwZWQuY29udmVydCgwLCB0aGlzLl9kYXRhdHlwZSk7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgd2UgbmVlZCB0byByZXNpemUgbWF0cml4XG4gICAgaWYgKGkgPiByb3dzIC0gMSB8fCBqID4gY29sdW1ucyAtIDEpIHtcbiAgICAgIC8vIHJlc2l6ZSBtYXRyaXhcbiAgICAgIF9yZXNpemUodGhpcywgTWF0aC5tYXgoaSArIDEsIHJvd3MpLCBNYXRoLm1heChqICsgMSwgY29sdW1ucyksIGRlZmF1bHRWYWx1ZSk7XG4gICAgICAvLyB1cGRhdGUgcm93cyAmIGNvbHVtbnNcbiAgICAgIHJvd3MgPSB0aGlzLl9zaXplWzBdO1xuICAgICAgY29sdW1ucyA9IHRoaXMuX3NpemVbMV07XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgaSwgaiBhcmUgdmFsaWRcbiAgICB2YWxpZGF0ZUluZGV4KGksIHJvd3MpO1xuICAgIHZhbGlkYXRlSW5kZXgoaiwgY29sdW1ucyk7XG5cbiAgICAvLyBmaW5kIHZhbHVlIGluZGV4XG4gICAgdmFyIGsgPSBfZ2V0VmFsdWVJbmRleChpLCB0aGlzLl9wdHJbal0sIHRoaXMuX3B0cltqICsgMV0sIHRoaXMuX2luZGV4KTtcbiAgICAvLyBjaGVjayBrIGlzIHByaW9yIHRvIG5leHQgY29sdW1uIGsgYW5kIGl0IGlzIGluIHRoZSBjb3JyZWN0IHJvd1xuICAgIGlmIChrIDwgdGhpcy5fcHRyW2ogKyAxXSAmJiB0aGlzLl9pbmRleFtrXSA9PT0gaSkge1xuICAgICAgLy8gY2hlY2sgdmFsdWUgIT0gMFxuICAgICAgaWYgKCFlcSh2LCB6ZXJvKSkge1xuICAgICAgICAvLyB1cGRhdGUgdmFsdWVcbiAgICAgICAgdGhpcy5fdmFsdWVzW2tdID0gdjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyByZW1vdmUgdmFsdWUgZnJvbSBtYXRyaXhcbiAgICAgICAgX3JlbW92ZShrLCBqLCB0aGlzLl92YWx1ZXMsIHRoaXMuX2luZGV4LCB0aGlzLl9wdHIpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGluc2VydCB2YWx1ZSBAIChpLCBqKVxuICAgICAgX2luc2VydChrLCBpLCBqLCB2LCB0aGlzLl92YWx1ZXMsIHRoaXMuX2luZGV4LCB0aGlzLl9wdHIpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBcbiAgdmFyIF9nZXRWYWx1ZUluZGV4ID0gZnVuY3Rpb24oaSwgdG9wLCBib3R0b20sIGluZGV4KSB7XG4gICAgLy8gY2hlY2sgcm93IGlzIG9uIHRoZSBib3R0b20gc2lkZVxuICAgIGlmIChib3R0b20gLSB0b3AgPT09IDApXG4gICAgICByZXR1cm4gYm90dG9tO1xuICAgIC8vIGxvb3Agcm93cyBbdG9wLCBib3R0b21bXG4gICAgZm9yICh2YXIgciA9IHRvcDsgciA8IGJvdHRvbTsgcisrKSB7XG4gICAgICAvLyBjaGVjayB3ZSBmb3VuZCB2YWx1ZSBpbmRleFxuICAgICAgaWYgKGluZGV4W3JdID09PSBpKVxuICAgICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgLy8gd2UgZGlkIG5vdCBmaW5kIHJvd1xuICAgIHJldHVybiB0b3A7XG4gIH07XG5cbiAgdmFyIF9yZW1vdmUgPSBmdW5jdGlvbiAoaywgaiwgdmFsdWVzLCBpbmRleCwgcHRyKSB7XG4gICAgLy8gcmVtb3ZlIHZhbHVlIEAga1xuICAgIHZhbHVlcy5zcGxpY2UoaywgMSk7XG4gICAgaW5kZXguc3BsaWNlKGssIDEpO1xuICAgIC8vIHVwZGF0ZSBwb2ludGVyc1xuICAgIGZvciAodmFyIHggPSBqICsgMTsgeCA8IHB0ci5sZW5ndGg7IHgrKylcbiAgICAgIHB0clt4XS0tO1xuICB9O1xuXG4gIHZhciBfaW5zZXJ0ID0gZnVuY3Rpb24gKGssIGksIGosIHYsIHZhbHVlcywgaW5kZXgsIHB0cikge1xuICAgIC8vIGluc2VydCB2YWx1ZVxuICAgIHZhbHVlcy5zcGxpY2UoaywgMCwgdik7XG4gICAgLy8gdXBkYXRlIHJvdyBmb3Iga1xuICAgIGluZGV4LnNwbGljZShrLCAwLCBpKTtcbiAgICAvLyB1cGRhdGUgY29sdW1uIHBvaW50ZXJzXG4gICAgZm9yICh2YXIgeCA9IGogKyAxOyB4IDwgcHRyLmxlbmd0aDsgeCsrKVxuICAgICAgcHRyW3hdKys7XG4gIH07XG4gIFxuICAvKipcbiAgICogUmVzaXplIHRoZSBtYXRyaXggdG8gdGhlIGdpdmVuIHNpemUuIFJldHVybnMgYSBjb3B5IG9mIHRoZSBtYXRyaXggd2hlbiBcbiAgICogYGNvcHk9dHJ1ZWAsIG90aGVyd2lzZSByZXR1cm4gdGhlIG1hdHJpeCBpdHNlbGYgKHJlc2l6ZSBpbiBwbGFjZSkuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBTcGFyc2VNYXRyaXhcbiAgICogQHBhcmFtIHtudW1iZXJbXX0gc2l6ZSAgICAgICAgICAgVGhlIG5ldyBzaXplIHRoZSBtYXRyaXggc2hvdWxkIGhhdmUuXG4gICAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZT0wXSAgICAgIERlZmF1bHQgdmFsdWUsIGZpbGxlZCBpbiBvbiBuZXcgZW50cmllcy5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgbm90IHByb3ZpZGVkLCB0aGUgbWF0cml4IGVsZW1lbnRzIHdpbGxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmUgZmlsbGVkIHdpdGggemVyb3MuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NvcHldICAgICAgICAgIFJldHVybiBhIHJlc2l6ZWQgY29weSBvZiB0aGUgbWF0cml4XG4gICAqXG4gICAqIEByZXR1cm4ge01hdHJpeH0gICAgICAgICAgICAgICAgIFRoZSByZXNpemVkIG1hdHJpeFxuICAgKi9cbiAgU3BhcnNlTWF0cml4LnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAoc2l6ZSwgZGVmYXVsdFZhbHVlLCBjb3B5KSB7ICAgIFxuICAgIC8vIHZhbGlkYXRlIGFyZ3VtZW50c1xuICAgIGlmICghaXNBcnJheShzaXplKSlcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5IGV4cGVjdGVkJyk7XG4gICAgaWYgKHNpemUubGVuZ3RoICE9PSAyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IHR3byBkaW1lbnNpb25zIG1hdHJpeCBhcmUgc3VwcG9ydGVkJyk7XG5cbiAgICAvLyBjaGVjayBzaXplc1xuICAgIHNpemUuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICghbnVtYmVyLmlzTnVtYmVyKHZhbHVlKSB8fCAhbnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgfHwgdmFsdWUgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc2l6ZSwgbXVzdCBjb250YWluIHBvc2l0aXZlIGludGVnZXJzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcoc2l6ZTogJyArIHN0cmluZy5mb3JtYXQoc2l6ZSkgKyAnKScpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIC8vIG1hdHJpeCB0byByZXNpemVcbiAgICB2YXIgbSA9IGNvcHkgPyB0aGlzLmNsb25lKCkgOiB0aGlzO1xuICAgIC8vIHJlc2l6ZSBtYXRyaXhcbiAgICByZXR1cm4gX3Jlc2l6ZShtLCBzaXplWzBdLCBzaXplWzFdLCBkZWZhdWx0VmFsdWUpO1xuICB9O1xuICBcbiAgdmFyIF9yZXNpemUgPSBmdW5jdGlvbiAobWF0cml4LCByb3dzLCBjb2x1bW5zLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAvLyB2YWx1ZSB0byBpbnNlcnQgYXQgdGhlIHRpbWUgb2YgZ3Jvd2luZyBtYXRyaXhcbiAgICB2YXIgdmFsdWUgPSBkZWZhdWx0VmFsdWUgfHwgMDtcbiAgICBcbiAgICAvLyBlcXVhbCBzaWduYXR1cmUgdG8gdXNlXG4gICAgdmFyIGVxID0gZXF1YWxTY2FsYXI7XG4gICAgLy8gemVybyB2YWx1ZVxuICAgIHZhciB6ZXJvID0gMDtcblxuICAgIGlmIChpc1N0cmluZyhtYXRyaXguX2RhdGF0eXBlKSkge1xuICAgICAgLy8gZmluZCBzaWduYXR1cmUgdGhhdCBtYXRjaGVzIChkYXRhdHlwZSwgZGF0YXR5cGUpXG4gICAgICBlcSA9IHR5cGVkLmZpbmQoZXF1YWxTY2FsYXIsIFttYXRyaXguX2RhdGF0eXBlLCBtYXRyaXguX2RhdGF0eXBlXSkgfHwgZXF1YWxTY2FsYXI7XG4gICAgICAvLyBjb252ZXJ0IDAgdG8gdGhlIHNhbWUgZGF0YXR5cGVcbiAgICAgIHplcm8gPSB0eXBlZC5jb252ZXJ0KDAsIG1hdHJpeC5fZGF0YXR5cGUpO1xuICAgICAgLy8gY29udmVydCB2YWx1ZSB0byB0aGUgc2FtZSBkYXRhdHlwZVxuICAgICAgdmFsdWUgPSB0eXBlZC5jb252ZXJ0KHZhbHVlLCBtYXRyaXguX2RhdGF0eXBlKTtcbiAgICB9XG4gICAgXG4gICAgLy8gc2hvdWxkIHdlIGluc2VydCB0aGUgdmFsdWU/XG4gICAgdmFyIGlucyA9ICFlcSh2YWx1ZSwgemVybyk7XG5cbiAgICAvLyBvbGQgY29sdW1ucyBhbmQgcm93c1xuICAgIHZhciByID0gbWF0cml4Ll9zaXplWzBdO1xuICAgIHZhciBjID0gbWF0cml4Ll9zaXplWzFdO1xuXG4gICAgdmFyIGksIGosIGs7XG5cbiAgICAvLyBjaGVjayB3ZSBuZWVkIHRvIGluY3JlYXNlIGNvbHVtbnNcbiAgICBpZiAoY29sdW1ucyA+IGMpIHtcbiAgICAgIC8vIGxvb3AgbmV3IGNvbHVtbnNcbiAgICAgIGZvciAoaiA9IGM7IGogPCBjb2x1bW5zOyBqKyspIHtcbiAgICAgICAgLy8gdXBkYXRlIG1hdHJpeC5fcHRyIGZvciBjdXJyZW50IGNvbHVtblxuICAgICAgICBtYXRyaXguX3B0cltqXSA9IG1hdHJpeC5fdmFsdWVzLmxlbmd0aDtcbiAgICAgICAgLy8gY2hlY2sgd2UgbmVlZCB0byBpbnNlcnQgbWF0cml4Ll92YWx1ZXNcbiAgICAgICAgaWYgKGlucykge1xuICAgICAgICAgIC8vIGxvb3Agcm93c1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCByOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGFkZCBuZXcgbWF0cml4Ll92YWx1ZXNcbiAgICAgICAgICAgIG1hdHJpeC5fdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgLy8gdXBkYXRlIG1hdHJpeC5faW5kZXhcbiAgICAgICAgICAgIG1hdHJpeC5faW5kZXgucHVzaChpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gICAgICAgIFxuICAgICAgfVxuICAgICAgLy8gc3RvcmUgbnVtYmVyIG9mIG1hdHJpeC5fdmFsdWVzIGluIG1hdHJpeC5fcHRyXG4gICAgICBtYXRyaXguX3B0cltjb2x1bW5zXSA9IG1hdHJpeC5fdmFsdWVzLmxlbmd0aDtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29sdW1ucyA8IGMpIHtcbiAgICAgIC8vIHRydW5jYXRlIG1hdHJpeC5fcHRyXG4gICAgICBtYXRyaXguX3B0ci5zcGxpY2UoY29sdW1ucyArIDEsIGMgLSBjb2x1bW5zKTtcbiAgICAgIC8vIHRydW5jYXRlIG1hdHJpeC5fdmFsdWVzIGFuZCBtYXRyaXguX2luZGV4XG4gICAgICBtYXRyaXguX3ZhbHVlcy5zcGxpY2UobWF0cml4Ll9wdHJbY29sdW1uc10sIG1hdHJpeC5fdmFsdWVzLmxlbmd0aCk7XG4gICAgICBtYXRyaXguX2luZGV4LnNwbGljZShtYXRyaXguX3B0cltjb2x1bW5zXSwgbWF0cml4Ll9pbmRleC5sZW5ndGgpO1xuICAgIH1cbiAgICAvLyB1cGRhdGUgY29sdW1uc1xuICAgIGMgPSBjb2x1bW5zO1xuXG4gICAgLy8gY2hlY2sgd2UgbmVlZCB0byBpbmNyZWFzZSByb3dzXG4gICAgaWYgKHJvd3MgPiByKSB7XG4gICAgICAvLyBjaGVjayB3ZSBoYXZlIHRvIGluc2VydCB2YWx1ZXNcbiAgICAgIGlmIChpbnMpIHtcbiAgICAgICAgLy8gaW5zZXJ0c1xuICAgICAgICB2YXIgbiA9IDA7XG4gICAgICAgIC8vIGxvb3AgY29sdW1uc1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgYzsgaisrKSB7XG4gICAgICAgICAgLy8gdXBkYXRlIG1hdHJpeC5fcHRyIGZvciBjdXJyZW50IGNvbHVtblxuICAgICAgICAgIG1hdHJpeC5fcHRyW2pdID0gbWF0cml4Ll9wdHJbal0gKyBuO1xuICAgICAgICAgIC8vIHdoZXJlIHRvIGluc2VydCBtYXRyaXguX3ZhbHVlc1xuICAgICAgICAgIGsgPSBtYXRyaXguX3B0cltqICsgMV0gKyBuO1xuICAgICAgICAgIC8vIHBvaW50ZXJcbiAgICAgICAgICB2YXIgcCA9IDA7XG4gICAgICAgICAgLy8gbG9vcCBuZXcgcm93cywgaW5pdGlhbGl6ZSBwb2ludGVyXG4gICAgICAgICAgZm9yIChpID0gcjsgaSA8IHJvd3M7IGkrKywgcCsrKSB7XG4gICAgICAgICAgICAvLyBhZGQgdmFsdWVcbiAgICAgICAgICAgIG1hdHJpeC5fdmFsdWVzLnNwbGljZShrICsgcCwgMCwgdmFsdWUpO1xuICAgICAgICAgICAgLy8gdXBkYXRlIG1hdHJpeC5faW5kZXhcbiAgICAgICAgICAgIG1hdHJpeC5faW5kZXguc3BsaWNlKGsgKyBwLCAwLCBpKTtcbiAgICAgICAgICAgIC8vIGluY3JlbWVudCBpbnNlcnRzXG4gICAgICAgICAgICBuKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHN0b3JlIG51bWJlciBvZiBtYXRyaXguX3ZhbHVlcyBpbiBtYXRyaXguX3B0clxuICAgICAgICBtYXRyaXguX3B0cltjXSA9IG1hdHJpeC5fdmFsdWVzLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocm93cyA8IHIpIHtcbiAgICAgIC8vIGRlbGV0ZXNcbiAgICAgIHZhciBkID0gMDtcbiAgICAgIC8vIGxvb3AgY29sdW1uc1xuICAgICAgZm9yIChqID0gMDsgaiA8IGM7IGorKykge1xuICAgICAgICAvLyB1cGRhdGUgbWF0cml4Ll9wdHIgZm9yIGN1cnJlbnQgY29sdW1uXG4gICAgICAgIG1hdHJpeC5fcHRyW2pdID0gbWF0cml4Ll9wdHJbal0gLSBkO1xuICAgICAgICAvLyB3aGVyZSBtYXRyaXguX3ZhbHVlcyBzdGFydCBmb3IgbmV4dCBjb2x1bW5cbiAgICAgICAgdmFyIGswID0gbWF0cml4Ll9wdHJbal07XG4gICAgICAgIHZhciBrMSA9IG1hdHJpeC5fcHRyW2ogKyAxXSAtIGQ7XG4gICAgICAgIC8vIGxvb3AgbWF0cml4Ll9pbmRleFxuICAgICAgICBmb3IgKGsgPSBrMDsgayA8IGsxOyBrKyspIHtcbiAgICAgICAgICAvLyByb3dcbiAgICAgICAgICBpID0gbWF0cml4Ll9pbmRleFtrXTtcbiAgICAgICAgICAvLyBjaGVjayB3ZSBuZWVkIHRvIGRlbGV0ZSB2YWx1ZSBhbmQgbWF0cml4Ll9pbmRleFxuICAgICAgICAgIGlmIChpID4gcm93cyAtIDEpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSB2YWx1ZVxuICAgICAgICAgICAgbWF0cml4Ll92YWx1ZXMuc3BsaWNlKGssIDEpO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGl0ZW0gZnJvbSBtYXRyaXguX2luZGV4XG4gICAgICAgICAgICBtYXRyaXguX2luZGV4LnNwbGljZShrLCAxKTtcbiAgICAgICAgICAgIC8vIGluY3JlYXNlIGRlbGV0ZXNcbiAgICAgICAgICAgIGQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIHVwZGF0ZSBtYXRyaXguX3B0ciBmb3IgY3VycmVudCBjb2x1bW5cbiAgICAgIG1hdHJpeC5fcHRyW2pdID0gbWF0cml4Ll92YWx1ZXMubGVuZ3RoO1xuICAgIH1cbiAgICAvLyB1cGRhdGUgbWF0cml4Ll9zaXplXG4gICAgbWF0cml4Ll9zaXplWzBdID0gcm93cztcbiAgICBtYXRyaXguX3NpemVbMV0gPSBjb2x1bW5zO1xuICAgIC8vIHJldHVybiBtYXRyaXhcbiAgICByZXR1cm4gbWF0cml4O1xuICB9O1xuICBcbiAgLyoqXG4gICAqIENyZWF0ZSBhIGNsb25lIG9mIHRoZSBtYXRyaXhcbiAgICogQG1lbWJlcm9mIFNwYXJzZU1hdHJpeFxuICAgKiBAcmV0dXJuIHtTcGFyc2VNYXRyaXh9IGNsb25lXG4gICAqL1xuICBTcGFyc2VNYXRyaXgucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtID0gbmV3IFNwYXJzZU1hdHJpeCh7XG4gICAgICB2YWx1ZXM6IHRoaXMuX3ZhbHVlcyA/IG9iamVjdC5jbG9uZSh0aGlzLl92YWx1ZXMpIDogdW5kZWZpbmVkLFxuICAgICAgaW5kZXg6IG9iamVjdC5jbG9uZSh0aGlzLl9pbmRleCksXG4gICAgICBwdHI6IG9iamVjdC5jbG9uZSh0aGlzLl9wdHIpLFxuICAgICAgc2l6ZTogb2JqZWN0LmNsb25lKHRoaXMuX3NpemUpLFxuICAgICAgZGF0YXR5cGU6IHRoaXMuX2RhdGF0eXBlXG4gICAgfSk7XG4gICAgcmV0dXJuIG07XG4gIH07XG4gIFxuICAvKipcbiAgICogUmV0cmlldmUgdGhlIHNpemUgb2YgdGhlIG1hdHJpeC5cbiAgICogQG1lbWJlcm9mIFNwYXJzZU1hdHJpeFxuICAgKiBAcmV0dXJucyB7bnVtYmVyW119IHNpemVcbiAgICovXG4gIFNwYXJzZU1hdHJpeC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9zaXplLnNsaWNlKDApOyAvLyBjb3B5IHRoZSBBcnJheVxuICB9O1xuICBcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBtYXRyaXggd2l0aCB0aGUgcmVzdWx0cyBvZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gZXhlY3V0ZWQgb25cbiAgICogZWFjaCBlbnRyeSBvZiB0aGUgbWF0cml4LlxuICAgKiBAbWVtYmVyb2YgU3BhcnNlTWF0cml4XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrICAgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudCwgdGhlIGluZGV4XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgdGhlIGVsZW1lbnQsIGFuZCB0aGUgTWF0cml4IGJlaW5nIHRyYXZlcnNlZC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbc2tpcFplcm9zXSBJbnZva2UgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIG5vbi16ZXJvIHZhbHVlcyBvbmx5LlxuICAgKlxuICAgKiBAcmV0dXJuIHtTcGFyc2VNYXRyaXh9IG1hdHJpeFxuICAgKi9cbiAgU3BhcnNlTWF0cml4LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHNraXBaZXJvcykge1xuICAgIC8vIGNoZWNrIGl0IGlzIGEgcGF0dGVybiBtYXRyaXhcbiAgICBpZiAoIXRoaXMuX3ZhbHVlcylcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludm9rZSBtYXAgb24gYSBQYXR0ZXJuIG9ubHkgbWF0cml4Jyk7XG4gICAgLy8gbWF0cml4IGluc3RhbmNlXG4gICAgdmFyIG1lID0gdGhpcztcbiAgICAvLyByb3dzIGFuZCBjb2x1bW5zXG4gICAgdmFyIHJvd3MgPSB0aGlzLl9zaXplWzBdO1xuICAgIHZhciBjb2x1bW5zID0gdGhpcy5fc2l6ZVsxXTtcbiAgICAvLyBpbnZva2UgY2FsbGJhY2tcbiAgICB2YXIgaW52b2tlID0gZnVuY3Rpb24gKHYsIGksIGopIHtcbiAgICAgIC8vIGludm9rZSBjYWxsYmFja1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKHYsIFtpLCBqXSwgbWUpO1xuICAgIH07XG4gICAgLy8gaW52b2tlIF9tYXBcbiAgICByZXR1cm4gX21hcCh0aGlzLCAwLCByb3dzIC0gMSwgMCwgY29sdW1ucyAtIDEsIGludm9rZSwgc2tpcFplcm9zKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IG1hdHJpeCB3aXRoIHRoZSByZXN1bHRzIG9mIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBleGVjdXRlZCBvbiB0aGUgaW50ZXJ2YWxcbiAgICogW21pblJvdy4ubWF4Um93LCBtaW5Db2x1bW4uLm1heENvbHVtbl0uXG4gICAqL1xuICB2YXIgX21hcCA9IGZ1bmN0aW9uIChtYXRyaXgsIG1pblJvdywgbWF4Um93LCBtaW5Db2x1bW4sIG1heENvbHVtbiwgY2FsbGJhY2ssIHNraXBaZXJvcykge1xuICAgIC8vIHJlc3VsdCBhcnJheXNcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgdmFyIGluZGV4ID0gW107XG4gICAgdmFyIHB0ciA9IFtdO1xuICAgIFxuICAgIC8vIGVxdWFsIHNpZ25hdHVyZSB0byB1c2VcbiAgICB2YXIgZXEgPSBlcXVhbFNjYWxhcjtcbiAgICAvLyB6ZXJvIHZhbHVlXG4gICAgdmFyIHplcm8gPSAwO1xuXG4gICAgaWYgKGlzU3RyaW5nKG1hdHJpeC5fZGF0YXR5cGUpKSB7XG4gICAgICAvLyBmaW5kIHNpZ25hdHVyZSB0aGF0IG1hdGNoZXMgKGRhdGF0eXBlLCBkYXRhdHlwZSlcbiAgICAgIGVxID0gdHlwZWQuZmluZChlcXVhbFNjYWxhciwgW21hdHJpeC5fZGF0YXR5cGUsIG1hdHJpeC5fZGF0YXR5cGVdKSB8fCBlcXVhbFNjYWxhcjtcbiAgICAgIC8vIGNvbnZlcnQgMCB0byB0aGUgc2FtZSBkYXRhdHlwZVxuICAgICAgemVybyA9IHR5cGVkLmNvbnZlcnQoMCwgbWF0cml4Ll9kYXRhdHlwZSk7XG4gICAgfVxuICAgIFxuICAgIC8vIGludm9rZSBjYWxsYmFja1xuICAgIHZhciBpbnZva2UgPSBmdW5jdGlvbiAodiwgeCwgeSkge1xuICAgICAgLy8gaW52b2tlIGNhbGxiYWNrXG4gICAgICB2ID0gY2FsbGJhY2sodiwgeCwgeSk7XG4gICAgICAvLyBjaGVjayB2YWx1ZSAhPSAwXG4gICAgICBpZiAoIWVxKHYsIHplcm8pKSB7XG4gICAgICAgIC8vIHN0b3JlIHZhbHVlXG4gICAgICAgIHZhbHVlcy5wdXNoKHYpO1xuICAgICAgICAvLyBpbmRleFxuICAgICAgICBpbmRleC5wdXNoKHgpO1xuICAgICAgfVxuICAgIH07XG4gICAgLy8gbG9vcCBjb2x1bW5zXG4gICAgZm9yICh2YXIgaiA9IG1pbkNvbHVtbjsgaiA8PSBtYXhDb2x1bW47IGorKykge1xuICAgICAgLy8gc3RvcmUgcG9pbnRlciB0byB2YWx1ZXMgaW5kZXhcbiAgICAgIHB0ci5wdXNoKHZhbHVlcy5sZW5ndGgpO1xuICAgICAgLy8gazAgPD0gayA8IGsxIHdoZXJlIGswID0gX3B0cltqXSAmJiBrMSA9IF9wdHJbaisxXVxuICAgICAgdmFyIGswID0gbWF0cml4Ll9wdHJbal07XG4gICAgICB2YXIgazEgPSBtYXRyaXguX3B0cltqICsgMV07XG4gICAgICAvLyByb3cgcG9pbnRlclxuICAgICAgdmFyIHAgPSBtaW5Sb3c7XG4gICAgICAvLyBsb29wIGsgd2l0aGluIFtrMCwgazFbXG4gICAgICBmb3IgKHZhciBrID0gazA7IGsgPCBrMTsgaysrKSB7XG4gICAgICAgIC8vIHJvdyBpbmRleFxuICAgICAgICB2YXIgaSA9IG1hdHJpeC5faW5kZXhba107XG4gICAgICAgIC8vIGNoZWNrIGkgaXMgaW4gcmFuZ2VcbiAgICAgICAgaWYgKGkgPj0gbWluUm93ICYmIGkgPD0gbWF4Um93KSB7XG4gICAgICAgICAgLy8gemVybyB2YWx1ZXNcbiAgICAgICAgICBpZiAoIXNraXBaZXJvcykge1xuICAgICAgICAgICBmb3IgKHZhciB4ID0gcDsgeCA8IGk7IHgrKylcbiAgICAgICAgICAgICBpbnZva2UoMCwgeCAtIG1pblJvdywgaiAtIG1pbkNvbHVtbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHZhbHVlIEAga1xuICAgICAgICAgIGludm9rZShtYXRyaXguX3ZhbHVlc1trXSwgaSAtIG1pblJvdywgaiAtIG1pbkNvbHVtbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXBkYXRlIHBvaW50ZXJcbiAgICAgICAgcCA9IGkgKyAxO1xuICAgICAgfVxuICAgICAgLy8gemVybyB2YWx1ZXNcbiAgICAgIGlmICghc2tpcFplcm9zKSB7XG4gICAgICAgIGZvciAodmFyIHkgPSBwOyB5IDw9IG1heFJvdzsgeSsrKVxuICAgICAgICAgIGludm9rZSgwLCB5IC0gbWluUm93LCBqIC0gbWluQ29sdW1uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gc3RvcmUgbnVtYmVyIG9mIHZhbHVlcyBpbiBwdHJcbiAgICBwdHIucHVzaCh2YWx1ZXMubGVuZ3RoKTtcbiAgICAvLyByZXR1cm4gc3BhcnNlIG1hdHJpeFxuICAgIHJldHVybiBuZXcgU3BhcnNlTWF0cml4KHtcbiAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgcHRyOiBwdHIsXG4gICAgICBzaXplOiBbbWF4Um93IC0gbWluUm93ICsgMSwgbWF4Q29sdW1uIC0gbWluQ29sdW1uICsgMV1cbiAgICB9KTtcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBFeGVjdXRlIGEgY2FsbGJhY2sgZnVuY3Rpb24gb24gZWFjaCBlbnRyeSBvZiB0aGUgbWF0cml4LlxuICAgKiBAbWVtYmVyb2YgU3BhcnNlTWF0cml4XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrICAgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudCwgdGhlIGluZGV4XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgdGhlIGVsZW1lbnQsIGFuZCB0aGUgTWF0cml4IGJlaW5nIHRyYXZlcnNlZC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbc2tpcFplcm9zXSBJbnZva2UgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIG5vbi16ZXJvIHZhbHVlcyBvbmx5LlxuICAgKi9cbiAgU3BhcnNlTWF0cml4LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBza2lwWmVyb3MpIHtcbiAgICAvLyBjaGVjayBpdCBpcyBhIHBhdHRlcm4gbWF0cml4XG4gICAgaWYgKCF0aGlzLl92YWx1ZXMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZva2UgZm9yRWFjaCBvbiBhIFBhdHRlcm4gb25seSBtYXRyaXgnKTtcbiAgICAvLyBtYXRyaXggaW5zdGFuY2VcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIC8vIHJvd3MgYW5kIGNvbHVtbnNcbiAgICB2YXIgcm93cyA9IHRoaXMuX3NpemVbMF07XG4gICAgdmFyIGNvbHVtbnMgPSB0aGlzLl9zaXplWzFdO1xuICAgIC8vIGxvb3AgY29sdW1uc1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29sdW1uczsgaisrKSB7XG4gICAgICAvLyBrMCA8PSBrIDwgazEgd2hlcmUgazAgPSBfcHRyW2pdICYmIGsxID0gX3B0cltqKzFdXG4gICAgICB2YXIgazAgPSB0aGlzLl9wdHJbal07XG4gICAgICB2YXIgazEgPSB0aGlzLl9wdHJbaiArIDFdO1xuICAgICAgLy8gY29sdW1uIHBvaW50ZXJcbiAgICAgIHZhciBwID0gMDtcbiAgICAgIC8vIGxvb3AgayB3aXRoaW4gW2swLCBrMVtcbiAgICAgIGZvciAodmFyIGsgPSBrMDsgayA8IGsxOyBrKyspIHtcbiAgICAgICAgLy8gcm93IGluZGV4XG4gICAgICAgIHZhciBpID0gdGhpcy5faW5kZXhba107XG4gICAgICAgIC8vIGNoZWNrIHdlIG5lZWQgdG8gcHJvY2VzcyB6ZXJvc1xuICAgICAgICBpZiAoIXNraXBaZXJvcykge1xuICAgICAgICAgIC8vIHplcm8gdmFsdWVzXG4gICAgICAgICAgZm9yICh2YXIgeCA9IHA7IHggPCBpOyB4KyspXG4gICAgICAgICAgICBjYWxsYmFjaygwLCBbeCwgal0sIG1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB2YWx1ZSBAIGtcbiAgICAgICAgY2FsbGJhY2sodGhpcy5fdmFsdWVzW2tdLCBbaSwgal0sIG1lKTtcbiAgICAgICAgLy8gdXBkYXRlIHBvaW50ZXJcbiAgICAgICAgcCA9IGkgKyAxO1xuICAgICAgfVxuICAgICAgLy8gY2hlY2sgd2UgbmVlZCB0byBwcm9jZXNzIHplcm9zXG4gICAgICBpZiAoIXNraXBaZXJvcykge1xuICAgICAgICAvLyB6ZXJvIHZhbHVlc1xuICAgICAgICBmb3IgKHZhciB5ID0gcDsgeSA8IHJvd3M7IHkrKylcbiAgICAgICAgICBjYWxsYmFjaygwLCBbeSwgal0sIG1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIFxuICAvKipcbiAgICogQ3JlYXRlIGFuIEFycmF5IHdpdGggYSBjb3B5IG9mIHRoZSBkYXRhIG9mIHRoZSBTcGFyc2VNYXRyaXhcbiAgICogQG1lbWJlcm9mIFNwYXJzZU1hdHJpeFxuICAgKiBAcmV0dXJucyB7QXJyYXl9IGFycmF5XG4gICAqL1xuICBTcGFyc2VNYXRyaXgucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF90b0FycmF5KHRoaXMuX3ZhbHVlcywgdGhpcy5faW5kZXgsIHRoaXMuX3B0ciwgdGhpcy5fc2l6ZSwgdHJ1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcHJpbWl0aXZlIHZhbHVlIG9mIHRoZSBTcGFyc2VNYXRyaXg6IGEgdHdvIGRpbWVuc2lvbnMgYXJyYXlcbiAgICogQG1lbWJlcm9mIFNwYXJzZU1hdHJpeFxuICAgKiBAcmV0dXJucyB7QXJyYXl9IGFycmF5XG4gICAqL1xuICBTcGFyc2VNYXRyaXgucHJvdG90eXBlLnZhbHVlT2YgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF90b0FycmF5KHRoaXMuX3ZhbHVlcywgdGhpcy5faW5kZXgsIHRoaXMuX3B0ciwgdGhpcy5fc2l6ZSwgZmFsc2UpO1xuICB9O1xuICBcbiAgdmFyIF90b0FycmF5ID0gZnVuY3Rpb24gKHZhbHVlcywgaW5kZXgsIHB0ciwgc2l6ZSwgY29weSkgeyAgICBcbiAgICAvLyByb3dzIGFuZCBjb2x1bW5zXG4gICAgdmFyIHJvd3MgPSBzaXplWzBdO1xuICAgIHZhciBjb2x1bW5zID0gc2l6ZVsxXTtcbiAgICAvLyByZXN1bHRcbiAgICB2YXIgYSA9IFtdO1xuICAgIC8vIHZhcnNcbiAgICB2YXIgaSwgajtcbiAgICAvLyBpbml0aWFsaXplIGFycmF5XG4gICAgZm9yIChpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgYVtpXSA9IFtdO1xuICAgICAgZm9yIChqID0gMDsgaiA8IGNvbHVtbnM7IGorKylcbiAgICAgICAgYVtpXVtqXSA9IDA7XG4gICAgfVxuXG4gICAgLy8gbG9vcCBjb2x1bW5zXG4gICAgZm9yIChqID0gMDsgaiA8IGNvbHVtbnM7IGorKykge1xuICAgICAgLy8gazAgPD0gayA8IGsxIHdoZXJlIGswID0gX3B0cltqXSAmJiBrMSA9IF9wdHJbaisxXVxuICAgICAgdmFyIGswID0gcHRyW2pdO1xuICAgICAgdmFyIGsxID0gcHRyW2ogKyAxXTtcbiAgICAgIC8vIGxvb3AgayB3aXRoaW4gW2swLCBrMVtcbiAgICAgIGZvciAodmFyIGsgPSBrMDsgayA8IGsxOyBrKyspIHtcbiAgICAgICAgLy8gcm93IGluZGV4XG4gICAgICAgIGkgPSBpbmRleFtrXTtcbiAgICAgICAgLy8gc2V0IHZhbHVlICh1c2Ugb25lIGZvciBwYXR0ZXJuIG1hdHJpeClcbiAgICAgICAgYVtpXVtqXSA9IHZhbHVlcyA/IChjb3B5ID8gb2JqZWN0LmNsb25lKHZhbHVlc1trXSkgOiB2YWx1ZXNba10pIDogMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH07XG4gIFxuICAvKipcbiAgICogR2V0IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXgsIHdpdGggb3B0aW9uYWwgZm9ybWF0dGluZyBvcHRpb25zLlxuICAgKiBAbWVtYmVyb2YgU3BhcnNlTWF0cml4XG4gICAqIEBwYXJhbSB7T2JqZWN0IHwgbnVtYmVyIHwgRnVuY3Rpb259IFtvcHRpb25zXSAgRm9ybWF0dGluZyBvcHRpb25zLiBTZWVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaWIvdXRpbHMvbnVtYmVyOmZvcm1hdCBmb3IgYVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uIG9mIHRoZSBhdmFpbGFibGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBzdHJcbiAgICovXG4gIFNwYXJzZU1hdHJpeC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAvLyByb3dzIGFuZCBjb2x1bW5zXG4gICAgdmFyIHJvd3MgPSB0aGlzLl9zaXplWzBdO1xuICAgIHZhciBjb2x1bW5zID0gdGhpcy5fc2l6ZVsxXTtcbiAgICAvLyBkZW5zaXR5XG4gICAgdmFyIGRlbnNpdHkgPSB0aGlzLmRlbnNpdHkoKTtcbiAgICAvLyByb3dzICYgY29sdW1uc1xuICAgIHZhciBzdHIgPSAnU3BhcnNlIE1hdHJpeCBbJyArIHN0cmluZy5mb3JtYXQocm93cywgb3B0aW9ucykgKyAnIHggJyArIHN0cmluZy5mb3JtYXQoY29sdW1ucywgb3B0aW9ucykgKyAnXSBkZW5zaXR5OiAnICsgc3RyaW5nLmZvcm1hdChkZW5zaXR5LCBvcHRpb25zKSArICdcXG4nO1xuICAgIC8vIGxvb3AgY29sdW1uc1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29sdW1uczsgaisrKSB7XG4gICAgICAvLyBrMCA8PSBrIDwgazEgd2hlcmUgazAgPSBfcHRyW2pdICYmIGsxID0gX3B0cltqKzFdXG4gICAgICB2YXIgazAgPSB0aGlzLl9wdHJbal07XG4gICAgICB2YXIgazEgPSB0aGlzLl9wdHJbaiArIDFdO1xuICAgICAgLy8gbG9vcCBrIHdpdGhpbiBbazAsIGsxW1xuICAgICAgZm9yICh2YXIgayA9IGswOyBrIDwgazE7IGsrKykge1xuICAgICAgICAvLyByb3cgaW5kZXhcbiAgICAgICAgdmFyIGkgPSB0aGlzLl9pbmRleFtrXTtcbiAgICAgICAgLy8gYXBwZW5kIHZhbHVlXG4gICAgICAgIHN0ciArPSAnXFxuICAgICgnICsgc3RyaW5nLmZvcm1hdChpLCBvcHRpb25zKSArICcsICcgKyBzdHJpbmcuZm9ybWF0KGosIG9wdGlvbnMpICsgJykgPT0+ICcgKyAodGhpcy5fdmFsdWVzID8gc3RyaW5nLmZvcm1hdCh0aGlzLl92YWx1ZXNba10sIG9wdGlvbnMpIDogJ1gnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBHZXQgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICAgKiBAbWVtYmVyb2YgU3BhcnNlTWF0cml4XG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IHN0clxuICAgKi9cbiAgU3BhcnNlTWF0cml4LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc3RyaW5nLmZvcm1hdCh0aGlzLnRvQXJyYXkoKSk7XG4gIH07XG4gIFxuICAvKipcbiAgICogR2V0IGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XG4gICAqIEBtZW1iZXJvZiBTcGFyc2VNYXRyaXhcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG4gIFNwYXJzZU1hdHJpeC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtYXRoanM6ICdTcGFyc2VNYXRyaXgnLFxuICAgICAgdmFsdWVzOiB0aGlzLl92YWx1ZXMsXG4gICAgICBpbmRleDogdGhpcy5faW5kZXgsXG4gICAgICBwdHI6IHRoaXMuX3B0cixcbiAgICAgIHNpemU6IHRoaXMuX3NpemUsXG4gICAgICBkYXRhdHlwZTogdGhpcy5fZGF0YXR5cGVcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGt0aCBNYXRyaXggZGlhZ29uYWwuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBTcGFyc2VNYXRyaXhcbiAgICogQHBhcmFtIHtudW1iZXIgfCBCaWdOdW1iZXJ9IFtrPTBdICAgICBUaGUga3RoIGRpYWdvbmFsIHdoZXJlIHRoZSB2ZWN0b3Igd2lsbCByZXRyaWV2ZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtNYXRyaXh9ICAgICAgICAgICAgICAgICAgICAgVGhlIG1hdHJpeCB2ZWN0b3Igd2l0aCB0aGUgZGlhZ29uYWwgdmFsdWVzLlxuICAgKi9cbiAgU3BhcnNlTWF0cml4LnByb3RvdHlwZS5kaWFnb25hbCA9IGZ1bmN0aW9uKGspIHtcbiAgICAvLyB2YWxpZGF0ZSBrIGlmIGFueVxuICAgIGlmIChrKSB7XG4gICAgICAvLyBjb252ZXJ0IEJpZ051bWJlciB0byBhIG51bWJlclxuICAgICAgaWYgKGsuaXNCaWdOdW1iZXIgPT09IHRydWUpXG4gICAgICAgIGsgPSBrLnRvTnVtYmVyKCk7XG4gICAgICAvLyBpcyBtdXN0IGJlIGFuIGludGVnZXJcbiAgICAgIGlmICghaXNOdW1iZXIoaykgfHwgIWlzSW50ZWdlcihrKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yICgnVGhlIHBhcmFtZXRlciBrIG11c3QgYmUgYW4gaW50ZWdlciBudW1iZXInKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBkZWZhdWx0IHZhbHVlXG4gICAgICBrID0gMDtcbiAgICB9XG5cbiAgICB2YXIga1N1cGVyID0gayA+IDAgPyBrIDogMDtcbiAgICB2YXIga1N1YiA9IGsgPCAwID8gLWsgOiAwO1xuICAgIFxuICAgIC8vIHJvd3MgJiBjb2x1bW5zXG4gICAgdmFyIHJvd3MgPSB0aGlzLl9zaXplWzBdO1xuICAgIHZhciBjb2x1bW5zID0gdGhpcy5fc2l6ZVsxXTtcbiAgICBcbiAgICAvLyBudW1iZXIgZGlhZ29uYWwgdmFsdWVzXG4gICAgdmFyIG4gPSBNYXRoLm1pbihyb3dzIC0ga1N1YiwgY29sdW1ucyAtICBrU3VwZXIpO1xuICAgIFxuICAgIC8vIGRpYWdvbmFsIGFycmF5c1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICB2YXIgaW5kZXggPSBbXTtcbiAgICB2YXIgcHRyID0gW107XG4gICAgLy8gaW5pdGlhbCBwdHIgdmFsdWVcbiAgICBwdHJbMF0gPSAwO1xuICAgIC8vIGxvb3AgY29sdW1uc1xuICAgIGZvciAodmFyIGogPSBrU3VwZXI7IGogPCBjb2x1bW5zICYmIHZhbHVlcy5sZW5ndGggPCBuOyBqKyspIHtcbiAgICAgIC8vIGswIDw9IGsgPCBrMSB3aGVyZSBrMCA9IF9wdHJbal0gJiYgazEgPSBfcHRyW2orMV1cbiAgICAgIHZhciBrMCA9IHRoaXMuX3B0cltqXTtcbiAgICAgIHZhciBrMSA9IHRoaXMuX3B0cltqICsgMV07XG4gICAgICAvLyBsb29wIHggd2l0aGluIFtrMCwgazFbXG4gICAgICBmb3IgKHZhciB4ID0gazA7IHggPCBrMTsgeCsrKSB7XG4gICAgICAgIC8vIHJvdyBpbmRleFxuICAgICAgICB2YXIgaSA9IHRoaXMuX2luZGV4W3hdO1xuICAgICAgICAvLyBjaGVjayByb3dcbiAgICAgICAgaWYgKGkgPT09IGogLSBrU3VwZXIgKyBrU3ViKSB7XG4gICAgICAgICAgLy8gdmFsdWUgb24gdGhpcyBjb2x1bW5cbiAgICAgICAgICB2YWx1ZXMucHVzaCh0aGlzLl92YWx1ZXNbeF0pO1xuICAgICAgICAgIC8vIHN0b3JlIHJvd1xuICAgICAgICAgIGluZGV4W3ZhbHVlcy5sZW5ndGggLSAxXSA9IGkgLSBrU3ViO1xuICAgICAgICAgIC8vIGV4aXQgbG9vcFxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGNsb3NlIHB0clxuICAgIHB0ci5wdXNoKHZhbHVlcy5sZW5ndGgpO1xuICAgIC8vIHJldHVybiBtYXRyaXhcbiAgICByZXR1cm4gbmV3IFNwYXJzZU1hdHJpeCh7XG4gICAgICB2YWx1ZXM6IHZhbHVlcyxcbiAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgIHB0cjogcHRyLFxuICAgICAgc2l6ZTogW24sIDFdXG4gICAgfSk7XG4gIH07XG4gIFxuICAvKipcbiAgICogR2VuZXJhdGUgYSBtYXRyaXggZnJvbSBhIEpTT04gb2JqZWN0XG4gICAqIEBtZW1iZXJvZiBTcGFyc2VNYXRyaXhcbiAgICogQHBhcmFtIHtPYmplY3R9IGpzb24gIEFuIG9iamVjdCBzdHJ1Y3R1cmVkIGxpa2VcbiAgICogICAgICAgICAgICAgICAgICAgICAgIGB7XCJtYXRoanNcIjogXCJTcGFyc2VNYXRyaXhcIiwgXCJ2YWx1ZXNcIjogW10sIFwiaW5kZXhcIjogW10sIFwicHRyXCI6IFtdLCBcInNpemVcIjogW119YCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgIHdoZXJlIG1hdGhqcyBpcyBvcHRpb25hbFxuICAgKiBAcmV0dXJucyB7U3BhcnNlTWF0cml4fVxuICAgKi9cbiAgU3BhcnNlTWF0cml4LmZyb21KU09OID0gZnVuY3Rpb24gKGpzb24pIHtcbiAgICByZXR1cm4gbmV3IFNwYXJzZU1hdHJpeChqc29uKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgZGlhZ29uYWwgbWF0cml4LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgU3BhcnNlTWF0cml4XG4gICAqIEBwYXJhbSB7QXJyYXl9IHNpemUgICAgICAgICAgICAgICAgICAgICAgIFRoZSBtYXRyaXggc2l6ZS5cbiAgICogQHBhcmFtIHtudW1iZXIgfCBBcnJheSB8IE1hdHJpeCB9IHZhbHVlICAgVGhlIHZhbHVlcyBmb3IgdGhlIGRpYWdvbmFsLlxuICAgKiBAcGFyYW0ge251bWJlciB8IEJpZ051bWJlcn0gW2s9MF0gICAgICAgICBUaGUga3RoIGRpYWdvbmFsIHdoZXJlIHRoZSB2ZWN0b3Igd2lsbCBiZSBmaWxsZWQgaW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZGF0YXR5cGVdICAgICAgICAgICAgICAgIFRoZSBNYXRyaXggZGF0YXR5cGUsIHZhbHVlcyBtdXN0IGJlIG9mIHRoaXMgZGF0YXR5cGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtTcGFyc2VNYXRyaXh9XG4gICAqL1xuICBTcGFyc2VNYXRyaXguZGlhZ29uYWwgPSBmdW5jdGlvbiAoc2l6ZSwgdmFsdWUsIGssIGRlZmF1bHRWYWx1ZSwgZGF0YXR5cGUpIHtcbiAgICBpZiAoIWlzQXJyYXkoc2l6ZSkpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheSBleHBlY3RlZCwgc2l6ZSBwYXJhbWV0ZXInKTtcbiAgICBpZiAoc2l6ZS5sZW5ndGggIT09IDIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgdHdvIGRpbWVuc2lvbnMgbWF0cml4IGFyZSBzdXBwb3J0ZWQnKTtcbiAgICBcbiAgICAvLyBtYXAgc2l6ZSAmIHZhbGlkYXRlXG4gICAgc2l6ZSA9IHNpemUubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICAvLyBjaGVjayBpdCBpcyBhIGJpZyBudW1iZXJcbiAgICAgIGlmIChzICYmIHMuaXNCaWdOdW1iZXIgPT09IHRydWUpIHtcbiAgICAgICAgLy8gY29udmVydCBpdFxuICAgICAgICBzID0gcy50b051bWJlcigpO1xuICAgICAgfVxuICAgICAgLy8gdmFsaWRhdGUgYXJndW1lbnRzXG4gICAgICBpZiAoIWlzTnVtYmVyKHMpIHx8ICFpc0ludGVnZXIocykgfHwgcyA8IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaXplIHZhbHVlcyBtdXN0IGJlIHBvc2l0aXZlIGludGVnZXJzJyk7XG4gICAgICB9IFxuICAgICAgcmV0dXJuIHM7XG4gICAgfSk7XG4gICAgXG4gICAgLy8gdmFsaWRhdGUgayBpZiBhbnlcbiAgICBpZiAoaykge1xuICAgICAgLy8gY29udmVydCBCaWdOdW1iZXIgdG8gYSBudW1iZXJcbiAgICAgIGlmIChrLmlzQmlnTnVtYmVyID09PSB0cnVlKVxuICAgICAgICBrID0gay50b051bWJlcigpO1xuICAgICAgLy8gaXMgbXVzdCBiZSBhbiBpbnRlZ2VyXG4gICAgICBpZiAoIWlzTnVtYmVyKGspIHx8ICFpc0ludGVnZXIoaykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvciAoJ1RoZSBwYXJhbWV0ZXIgayBtdXN0IGJlIGFuIGludGVnZXIgbnVtYmVyJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gZGVmYXVsdCB2YWx1ZVxuICAgICAgayA9IDA7XG4gICAgfVxuXG4gICAgLy8gZXF1YWwgc2lnbmF0dXJlIHRvIHVzZVxuICAgIHZhciBlcSA9IGVxdWFsU2NhbGFyO1xuICAgIC8vIHplcm8gdmFsdWVcbiAgICB2YXIgemVybyA9IDA7XG5cbiAgICBpZiAoaXNTdHJpbmcoZGF0YXR5cGUpKSB7XG4gICAgICAvLyBmaW5kIHNpZ25hdHVyZSB0aGF0IG1hdGNoZXMgKGRhdGF0eXBlLCBkYXRhdHlwZSlcbiAgICAgIGVxID0gdHlwZWQuZmluZChlcXVhbFNjYWxhciwgW2RhdGF0eXBlLCBkYXRhdHlwZV0pIHx8IGVxdWFsU2NhbGFyO1xuICAgICAgLy8gY29udmVydCAwIHRvIHRoZSBzYW1lIGRhdGF0eXBlXG4gICAgICB6ZXJvID0gdHlwZWQuY29udmVydCgwLCBkYXRhdHlwZSk7XG4gICAgfVxuICAgIFxuICAgIHZhciBrU3VwZXIgPSBrID4gMCA/IGsgOiAwO1xuICAgIHZhciBrU3ViID0gayA8IDAgPyAtayA6IDA7XG4gICAgXG4gICAgLy8gcm93cyBhbmQgY29sdW1uc1xuICAgIHZhciByb3dzID0gc2l6ZVswXTtcbiAgICB2YXIgY29sdW1ucyA9IHNpemVbMV07XG4gICAgXG4gICAgLy8gbnVtYmVyIG9mIG5vbi16ZXJvIGl0ZW1zXG4gICAgdmFyIG4gPSBNYXRoLm1pbihyb3dzIC0ga1N1YiwgY29sdW1ucyAtICBrU3VwZXIpO1xuICAgIFxuICAgIC8vIHZhbHVlIGV4dHJhY3Rpb24gZnVuY3Rpb25cbiAgICB2YXIgX3ZhbHVlO1xuICAgICAgXG4gICAgLy8gY2hlY2sgdmFsdWVcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIC8vIHZhbGlkYXRlIGFycmF5XG4gICAgICBpZiAodmFsdWUubGVuZ3RoICE9PSBuKSB7XG4gICAgICAgIC8vIG51bWJlciBvZiB2YWx1ZXMgaW4gYXJyYXkgbXVzdCBiZSBuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZSBhcnJheSBsZW5ndGgnKTtcbiAgICAgIH1cbiAgICAgIC8vIGRlZmluZSBmdW5jdGlvblxuICAgICAgX3ZhbHVlID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgLy8gcmV0dXJuIHZhbHVlIEAgaVxuICAgICAgICByZXR1cm4gdmFsdWVbaV07XG4gICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZSAmJiB2YWx1ZS5pc01hdHJpeCA9PT0gdHJ1ZSkge1xuICAgICAgLy8gbWF0cml4IHNpemVcbiAgICAgIHZhciBtcyA9IHZhbHVlLnNpemUoKTtcbiAgICAgIC8vIHZhbGlkYXRlIG1hdHJpeFxuICAgICAgaWYgKG1zLmxlbmd0aCAhPT0gMSB8fCBtc1swXSAhPT0gbikge1xuICAgICAgICAvLyBudW1iZXIgb2YgdmFsdWVzIGluIGFycmF5IG11c3QgYmUgblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWF0cml4IGxlbmd0aCcpO1xuICAgICAgfVxuICAgICAgLy8gZGVmaW5lIGZ1bmN0aW9uXG4gICAgICBfdmFsdWUgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAvLyByZXR1cm4gdmFsdWUgQCBpXG4gICAgICAgIHJldHVybiB2YWx1ZS5nZXQoW2ldKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gZGVmaW5lIGZ1bmN0aW9uXG4gICAgICBfdmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHJldHVybiB2YWx1ZVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICAvLyBjcmVhdGUgYXJyYXlzXG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgIHZhciBpbmRleCA9IFtdO1xuICAgIHZhciBwdHIgPSBbXTtcbiAgICBcbiAgICAvLyBsb29wIGl0ZW1zXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb2x1bW5zOyBqKyspIHtcbiAgICAgIC8vIG51bWJlciBvZiByb3dzIHdpdGggdmFsdWVcbiAgICAgIHB0ci5wdXNoKHZhbHVlcy5sZW5ndGgpO1xuICAgICAgLy8gZGlhZ29uYWwgaW5kZXhcbiAgICAgIHZhciBpID0gaiAtIGtTdXBlcjsgICAgICBcbiAgICAgIC8vIGNoZWNrIHdlIG5lZWQgdG8gc2V0IGRpYWdvbmFsIHZhbHVlXG4gICAgICBpZiAoaSA+PSAwICYmIGkgPCBuKSB7XG4gICAgICAgIC8vIGdldCB2YWx1ZSBAIGlcbiAgICAgICAgdmFyIHYgPSBfdmFsdWUoaSk7XG4gICAgICAgIC8vIGNoZWNrIGZvciB6ZXJvXG4gICAgICAgIGlmICghZXEodiwgemVybykpIHtcbiAgICAgICAgICAvLyBjb2x1bW5cbiAgICAgICAgICBpbmRleC5wdXNoKGkgKyBrU3ViKTtcbiAgICAgICAgICAvLyBhZGQgdmFsdWVcbiAgICAgICAgICB2YWx1ZXMucHVzaCh2KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBsYXN0IHZhbHVlIHNob3VsZCBiZSBudW1iZXIgb2YgdmFsdWVzXG4gICAgcHRyLnB1c2godmFsdWVzLmxlbmd0aCk7XG4gICAgLy8gY3JlYXRlIFNwYXJzZU1hdHJpeFxuICAgIHJldHVybiBuZXcgU3BhcnNlTWF0cml4KHtcbiAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgcHRyOiBwdHIsXG4gICAgICBzaXplOiBbcm93cywgY29sdW1uc11cbiAgICB9KTtcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBTd2FwIHJvd3MgaSBhbmQgaiBpbiBNYXRyaXguXG4gICAqXG4gICAqIEBtZW1iZXJvZiBTcGFyc2VNYXRyaXhcbiAgICogQHBhcmFtIHtudW1iZXJ9IGkgICAgICAgTWF0cml4IHJvdyBpbmRleCAxXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBqICAgICAgIE1hdHJpeCByb3cgaW5kZXggMlxuICAgKlxuICAgKiBAcmV0dXJuIHtNYXRyaXh9ICAgICAgICBUaGUgbWF0cml4IHJlZmVyZW5jZVxuICAgKi9cbiAgU3BhcnNlTWF0cml4LnByb3RvdHlwZS5zd2FwUm93cyA9IGZ1bmN0aW9uIChpLCBqKSB7XG4gICAgLy8gY2hlY2sgaW5kZXhcbiAgICBpZiAoIWlzTnVtYmVyKGkpIHx8ICFpc0ludGVnZXIoaSkgfHwgIWlzTnVtYmVyKGopIHx8ICFpc0ludGVnZXIoaikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUm93IGluZGV4IG11c3QgYmUgcG9zaXRpdmUgaW50ZWdlcnMnKTtcbiAgICB9XG4gICAgLy8gY2hlY2sgZGltZW5zaW9uc1xuICAgIGlmICh0aGlzLl9zaXplLmxlbmd0aCAhPT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IHR3byBkaW1lbnNpb25hbCBtYXRyaXggaXMgc3VwcG9ydGVkJyk7XG4gICAgfVxuICAgIC8vIHZhbGlkYXRlIGluZGV4XG4gICAgdmFsaWRhdGVJbmRleChpLCB0aGlzLl9zaXplWzBdKTtcbiAgICB2YWxpZGF0ZUluZGV4KGosIHRoaXMuX3NpemVbMF0pO1xuICAgIFxuICAgIC8vIHN3YXAgcm93c1xuICAgIFNwYXJzZU1hdHJpeC5fc3dhcFJvd3MoaSwgaiwgdGhpcy5fc2l6ZVsxXSwgdGhpcy5fdmFsdWVzLCB0aGlzLl9pbmRleCwgdGhpcy5fcHRyKTtcbiAgICAvLyByZXR1cm4gY3VycmVudCBpbnN0YW5jZVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBcbiAgLyoqXG4gICAqIExvb3Agcm93cyB3aXRoIGRhdGEgaW4gY29sdW1uIGouXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBqICAgICAgICAgICAgQ29sdW1uXG4gICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyAgICAgICAgTWF0cml4IHZhbHVlc1xuICAgKiBAcGFyYW0ge0FycmF5fSBpbmRleCAgICAgICAgIE1hdHJpeCByb3cgaW5kZWNlc1xuICAgKiBAcGFyYW0ge0FycmF5fSBwdHIgICAgICAgICAgIE1hdHJpeCBjb2x1bW4gcG9pbnRlcnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgICBDYWxsYmFjayBmdW5jdGlvbiBpbnZva2VkIGZvciBldmVyeSByb3cgaW4gY29sdW1uIGpcbiAgICovXG4gIFNwYXJzZU1hdHJpeC5fZm9yRWFjaFJvdyA9IGZ1bmN0aW9uIChqLCB2YWx1ZXMsIGluZGV4LCBwdHIsIGNhbGxiYWNrKSB7XG4gICAgLy8gaW5kZWNlcyBmb3IgY29sdW1uIGpcbiAgICB2YXIgazAgPSBwdHJbal07XG4gICAgdmFyIGsxID0gcHRyW2ogKyAxXTtcbiAgICAvLyBsb29wXG4gICAgZm9yICh2YXIgayA9IGswOyBrIDwgazE7IGsrKykge1xuICAgICAgLy8gaW52b2tlIGNhbGxiYWNrXG4gICAgICBjYWxsYmFjayhpbmRleFtrXSwgdmFsdWVzW2tdKTtcbiAgICB9XG4gIH07XG4gIFxuICAvKipcbiAgICogU3dhcCByb3dzIHggYW5kIHkgaW4gU3BhcnNlIE1hdHJpeCBkYXRhIHN0cnVjdHVyZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4ICAgICAgICAgTWF0cml4IHJvdyBpbmRleCAxXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5ICAgICAgICAgTWF0cml4IHJvdyBpbmRleCAyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5zICAgTnVtYmVyIG9mIGNvbHVtbnMgaW4gbWF0cml4XG4gICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyAgICAgTWF0cml4IHZhbHVlc1xuICAgKiBAcGFyYW0ge0FycmF5fSBpbmRleCAgICAgIE1hdHJpeCByb3cgaW5kZWNlc1xuICAgKiBAcGFyYW0ge0FycmF5fSBwdHIgICAgICAgIE1hdHJpeCBjb2x1bW4gcG9pbnRlcnNcbiAgICovXG4gIFNwYXJzZU1hdHJpeC5fc3dhcFJvd3MgPSBmdW5jdGlvbiAoeCwgeSwgY29sdW1ucywgdmFsdWVzLCBpbmRleCwgcHRyKSB7XG4gICAgLy8gbG9vcCBjb2x1bW5zXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb2x1bW5zOyBqKyspIHtcbiAgICAgIC8vIGswIDw9IGsgPCBrMSB3aGVyZSBrMCA9IF9wdHJbal0gJiYgazEgPSBfcHRyW2orMV1cbiAgICAgIHZhciBrMCA9IHB0cltqXTtcbiAgICAgIHZhciBrMSA9IHB0cltqICsgMV07XG4gICAgICAvLyBmaW5kIHZhbHVlIGluZGV4IEAgeFxuICAgICAgdmFyIGt4ID0gX2dldFZhbHVlSW5kZXgoeCwgazAsIGsxLCBpbmRleCk7XG4gICAgICAvLyBmaW5kIHZhbHVlIGluZGV4IEAgeFxuICAgICAgdmFyIGt5ID0gX2dldFZhbHVlSW5kZXgoeSwgazAsIGsxLCBpbmRleCk7XG4gICAgICAvLyBjaGVjayBib3RoIHJvd3MgZXhpc3QgaW4gbWF0cml4XG4gICAgICBpZiAoa3ggPCBrMSAmJiBreSA8IGsxICYmIGluZGV4W2t4XSA9PT0geCAmJiBpbmRleFtreV0gPT09IHkpIHtcbiAgICAgICAgLy8gc3dhcCB2YWx1ZXMgKGNoZWNrIGZvciBwYXR0ZXJuIG1hdHJpeClcbiAgICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICAgIHZhciB2ID0gdmFsdWVzW2t4XTtcbiAgICAgICAgICB2YWx1ZXNba3hdID0gdmFsdWVzW2t5XTtcbiAgICAgICAgICB2YWx1ZXNba3ldID0gdjtcbiAgICAgICAgfVxuICAgICAgICAvLyBuZXh0IGNvbHVtblxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIGNoZWNrIHggcm93IGV4aXN0ICYgbm8geSByb3dcbiAgICAgIGlmIChreCA8IGsxICYmIGluZGV4W2t4XSA9PT0geCAmJiAoa3kgPj0gazEgfHwgaW5kZXhba3ldICE9PSB5KSkge1xuICAgICAgICAvLyB2YWx1ZSBAIHggKGNoZWNrIGZvciBwYXR0ZXJuIG1hdHJpeClcbiAgICAgICAgdmFyIHZ4ID0gdmFsdWVzID8gdmFsdWVzW2t4XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gaW5zZXJ0IHZhbHVlIEAgeVxuICAgICAgICBpbmRleC5zcGxpY2Uoa3ksIDAsIHkpO1xuICAgICAgICBpZiAodmFsdWVzKVxuICAgICAgICAgIHZhbHVlcy5zcGxpY2Uoa3ksIDAsIHZ4KTsgICAgICAgIFxuICAgICAgICAvLyByZW1vdmUgdmFsdWUgQCB4IChhZGp1c3QgYXJyYXkgaW5kZXggaWYgbmVlZGVkKVxuICAgICAgICBpbmRleC5zcGxpY2Uoa3kgPD0ga3ggPyBreCArIDEgOiBreCwgMSk7XG4gICAgICAgIGlmICh2YWx1ZXMpXG4gICAgICAgICAgdmFsdWVzLnNwbGljZShreSA8PSBreCA/IGt4ICsgMSA6IGt4LCAxKTtcbiAgICAgICAgLy8gbmV4dCBjb2x1bW5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBjaGVjayB5IHJvdyBleGlzdCAmIG5vIHggcm93XG4gICAgICBpZiAoa3kgPCBrMSAmJiBpbmRleFtreV0gPT09IHkgJiYgKGt4ID49IGsxIHx8IGluZGV4W2t4XSAhPT0geCkpIHtcbiAgICAgICAgLy8gdmFsdWUgQCB5IChjaGVjayBmb3IgcGF0dGVybiBtYXRyaXgpXG4gICAgICAgIHZhciB2eSA9IHZhbHVlcyA/IHZhbHVlc1treV0gOiB1bmRlZmluZWQ7XG4gICAgICAgIC8vIGluc2VydCB2YWx1ZSBAIHhcbiAgICAgICAgaW5kZXguc3BsaWNlKGt4LCAwLCB4KTtcbiAgICAgICAgaWYgKHZhbHVlcylcbiAgICAgICAgICB2YWx1ZXMuc3BsaWNlKGt4LCAwLCB2eSk7XG4gICAgICAgIC8vIHJlbW92ZSB2YWx1ZSBAIHkgKGFkanVzdCBhcnJheSBpbmRleCBpZiBuZWVkZWQpXG4gICAgICAgIGluZGV4LnNwbGljZShreCA8PSBreSA/IGt5ICsgMSA6IGt5LCAxKTtcbiAgICAgICAgaWYgKHZhbHVlcylcbiAgICAgICAgICB2YWx1ZXMuc3BsaWNlKGt4IDw9IGt5ID8ga3kgKyAxIDoga3ksIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyByZWdpc3RlciB0aGlzIHR5cGUgaW4gdGhlIGJhc2UgY2xhc3MgTWF0cml4XG4gIHR5cGUuTWF0cml4Ll9zdG9yYWdlLnNwYXJzZSA9IFNwYXJzZU1hdHJpeDtcblxuICByZXR1cm4gU3BhcnNlTWF0cml4O1xufVxuXG5leHBvcnRzLm5hbWUgPSAnU3BhcnNlTWF0cml4JztcbmV4cG9ydHMucGF0aCA9ICd0eXBlJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG5leHBvcnRzLmxhenkgPSBmYWxzZTsgIC8vIG5vIGxhenkgbG9hZGluZywgYXMgd2UgYWx0ZXIgdHlwZS5NYXRyaXguX3N0b3JhZ2VcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICAvKipcbiAgICogQ3JlYXRlIGFuIGluZGV4LiBBbiBJbmRleCBjYW4gc3RvcmUgcmFuZ2VzIGhhdmluZyBzdGFydCwgc3RlcCwgYW5kIGVuZFxuICAgKiBmb3IgbXVsdGlwbGUgZGltZW5zaW9ucy5cbiAgICogTWF0cml4LmdldCwgTWF0cml4LnNldCwgYW5kIG1hdGguc3Vic2V0IGFjY2VwdCBhbiBJbmRleCBhcyBpbnB1dC5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICAgbWF0aC5pbmRleChyYW5nZTEsIHJhbmdlMiwgLi4uKVxuICAgKlxuICAgKiBXaGVyZSBlYWNoIHJhbmdlIGNhbiBiZSBhbnkgb2Y6XG4gICAqXG4gICAqIC0gQSBudW1iZXJcbiAgICogLSBBIHN0cmluZyBmb3IgZ2V0dGluZy9zZXR0aW5nIGFuIG9iamVjdCBwcm9wZXJ0eVxuICAgKiAtIEFuIGluc3RhbmNlIG9mIGBSYW5nZWBcbiAgICogLSBBIG9uZS1kaW1lbnNpb25hbCBBcnJheSBvciBhIE1hdHJpeCB3aXRoIG51bWJlcnNcbiAgICpcbiAgICogSW5kZXhlcyBtdXN0IGJlIHplcm8tYmFzZWQsIGludGVnZXIgbnVtYmVycy5cbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIHZhciBtYXRoID0gbWF0aC5qc1xuICAgKlxuICAgKiAgICB2YXIgYiA9IFsxLCAyLCAzLCA0LCA1XTtcbiAgICogICAgbWF0aC5zdWJzZXQoYiwgbWF0aC5pbmRleChbMSwgMiwgM10pKTsgICAgIC8vIHJldHVybnMgWzIsIDMsIDRdXG4gICAqXG4gICAqICAgIHZhciBhID0gbWF0aC5tYXRyaXgoW1sxLCAyXSwgWzMsIDRdXSk7XG4gICAqICAgIGEuc3Vic2V0KG1hdGguaW5kZXgoMCwgMSkpOyAgICAgICAgICAgICAvLyByZXR1cm5zIDJcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGJpZ251bWJlciwgYm9vbGVhbiwgY29tcGxleCwgbWF0cml4LCBudW1iZXIsIHN0cmluZywgdW5pdFxuICAgKlxuICAgKiBAcGFyYW0gey4uLip9IHJhbmdlcyAgIFplcm8gb3IgbW9yZSByYW5nZXMgb3IgbnVtYmVycy5cbiAgICogQHJldHVybiB7SW5kZXh9ICAgICAgICBSZXR1cm5zIHRoZSBjcmVhdGVkIGluZGV4XG4gICAqL1xuICByZXR1cm4gdHlwZWQoJ2luZGV4Jywge1xuICAgICcuLi5udW1iZXIgfCBzdHJpbmcgfCBCaWdOdW1iZXIgfCBSYW5nZSB8IEFycmF5IHwgTWF0cml4JzogZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgIHZhciByYW5nZXMgPSBhcmdzLm1hcChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIGlmIChhcmcgJiYgYXJnLmlzQmlnTnVtYmVyID09PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuIGFyZy50b051bWJlcigpOyAvLyBjb252ZXJ0IEJpZ051bWJlciB0byBOdW1iZXJcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcmcgJiYgKEFycmF5LmlzQXJyYXkoYXJnKSB8fCBhcmcuaXNNYXRyaXggPT09IHRydWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGFyZy5tYXAoZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgQmlnTnVtYmVyIHRvIE51bWJlclxuICAgICAgICAgICAgcmV0dXJuIChlbGVtICYmIGVsZW0uaXNCaWdOdW1iZXIgPT09IHRydWUpID8gZWxlbS50b051bWJlcigpIDogZWxlbTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdmFyIHJlcyA9IG5ldyB0eXBlLkluZGV4KCk7XG4gICAgICB0eXBlLkluZGV4LmFwcGx5KHJlcywgcmFuZ2VzKTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2luZGV4JztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIE1hdHJpeC4gVGhlIGZ1bmN0aW9uIGNyZWF0ZXMgYSBuZXcgYG1hdGgudHlwZS5NYXRyaXhgIG9iamVjdCBmcm9tXG4gICAqIGFuIGBBcnJheWAuIEEgTWF0cml4IGhhcyB1dGlsaXR5IGZ1bmN0aW9ucyB0byBtYW5pcHVsYXRlIHRoZSBkYXRhIGluIHRoZVxuICAgKiBtYXRyaXgsIGxpa2UgZ2V0dGluZyB0aGUgc2l6ZSBhbmQgZ2V0dGluZyBvciBzZXR0aW5nIHZhbHVlcyBpbiB0aGUgbWF0cml4LlxuICAgKiBTdXBwb3J0ZWQgc3RvcmFnZSBmb3JtYXRzIGFyZSAnZGVuc2UnIGFuZCAnc3BhcnNlJy5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLm1hdHJpeCgpICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZXMgYW4gZW1wdHkgbWF0cml4IHVzaW5nIGRlZmF1bHQgc3RvcmFnZSBmb3JtYXQgKGRlbnNlKS5cbiAgICogICAgbWF0aC5tYXRyaXgoZGF0YSkgICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGVzIGEgbWF0cml4IHdpdGggaW5pdGlhbCBkYXRhIHVzaW5nIGRlZmF1bHQgc3RvcmFnZSBmb3JtYXQgKGRlbnNlKS5cbiAgICogICAgbWF0aC5tYXRyaXgoJ2RlbnNlJykgICAgICAgICAgICAgICAgICAvLyBjcmVhdGVzIGFuIGVtcHR5IG1hdHJpeCB1c2luZyB0aGUgZ2l2ZW4gc3RvcmFnZSBmb3JtYXQuXG4gICAqICAgIG1hdGgubWF0cml4KGRhdGEsICdkZW5zZScpICAgICAgICAgICAgLy8gY3JlYXRlcyBhIG1hdHJpeCB3aXRoIGluaXRpYWwgZGF0YSB1c2luZyB0aGUgZ2l2ZW4gc3RvcmFnZSBmb3JtYXQuXG4gICAqICAgIG1hdGgubWF0cml4KGRhdGEsICdzcGFyc2UnKSAgICAgICAgICAgLy8gY3JlYXRlcyBhIHNwYXJzZSBtYXRyaXggd2l0aCBpbml0aWFsIGRhdGEuXG4gICAqICAgIG1hdGgubWF0cml4KGRhdGEsICdzcGFyc2UnLCAnbnVtYmVyJykgLy8gY3JlYXRlcyBhIHNwYXJzZSBtYXRyaXggd2l0aCBpbml0aWFsIGRhdGEsIG51bWJlciBkYXRhIHR5cGUuXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICB2YXIgbSA9IG1hdGgubWF0cml4KFtbMSwgMl0sIFszLCA0XV0pO1xuICAgKiAgICBtLnNpemUoKTsgICAgICAgICAgICAgICAgICAgICAgICAvLyBBcnJheSBbMiwgMl1cbiAgICogICAgbS5yZXNpemUoWzMsIDJdLCA1KTtcbiAgICogICAgbS52YWx1ZU9mKCk7ICAgICAgICAgICAgICAgICAgICAgLy8gQXJyYXkgW1sxLCAyXSwgWzMsIDRdLCBbNSwgNV1dXG4gICAqICAgIG0uZ2V0KFsxLCAwXSkgICAgICAgICAgICAgICAgICAgIC8vIG51bWJlciAzXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBiaWdudW1iZXIsIGJvb2xlYW4sIGNvbXBsZXgsIGluZGV4LCBudW1iZXIsIHN0cmluZywgdW5pdCwgc3BhcnNlXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXkgfCBNYXRyaXh9IFtkYXRhXSAgICBBIG11bHRpIGRpbWVuc2lvbmFsIGFycmF5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZm9ybWF0XSAgICAgICAgICBUaGUgTWF0cml4IHN0b3JhZ2UgZm9ybWF0XG4gICAqXG4gICAqIEByZXR1cm4ge01hdHJpeH0gVGhlIGNyZWF0ZWQgbWF0cml4XG4gICAqL1xuICB2YXIgbWF0cml4ID0gdHlwZWQoJ21hdHJpeCcsIHtcbiAgICAnJzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9jcmVhdGUoW10pO1xuICAgIH0sXG5cbiAgICAnc3RyaW5nJzogZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgcmV0dXJuIF9jcmVhdGUoW10sIGZvcm1hdCk7XG4gICAgfSxcbiAgICBcbiAgICAnc3RyaW5nLCBzdHJpbmcnOiBmdW5jdGlvbiAoZm9ybWF0LCBkYXRhdHlwZSkge1xuICAgICAgcmV0dXJuIF9jcmVhdGUoW10sIGZvcm1hdCwgZGF0YXR5cGUpO1xuICAgIH0sXG5cbiAgICAnQXJyYXknOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgcmV0dXJuIF9jcmVhdGUoZGF0YSk7XG4gICAgfSxcbiAgICAgIFxuICAgICdNYXRyaXgnOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgcmV0dXJuIF9jcmVhdGUoZGF0YSwgZGF0YS5zdG9yYWdlKCkpO1xuICAgIH0sXG4gICAgXG4gICAgJ0FycmF5IHwgTWF0cml4LCBzdHJpbmcnOiBfY3JlYXRlLFxuICAgIFxuICAgICdBcnJheSB8IE1hdHJpeCwgc3RyaW5nLCBzdHJpbmcnOiBfY3JlYXRlXG4gIH0pO1xuXG4gIG1hdHJpeC50b1RleCA9IHtcbiAgICAwOiAnXFxcXGJlZ2lue2JtYXRyaXh9XFxcXGVuZHtibWF0cml4fScsXG4gICAgMTogJ1xcXFxsZWZ0KCR7YXJnc1swXX1cXFxccmlnaHQpJyxcbiAgICAyOiAnXFxcXGxlZnQoJHthcmdzWzBdfVxcXFxyaWdodCknXG4gIH07XG5cbiAgcmV0dXJuIG1hdHJpeDtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IE1hdHJpeCB3aXRoIGdpdmVuIHN0b3JhZ2UgZm9ybWF0XG4gICAqIEBwYXJhbSB7QXJyYXl9IGRhdGFcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtmb3JtYXRdXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZGF0YXR5cGVdXG4gICAqIEByZXR1cm5zIHtNYXRyaXh9IFJldHVybnMgYSBuZXcgTWF0cml4XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfY3JlYXRlKGRhdGEsIGZvcm1hdCwgZGF0YXR5cGUpIHtcbiAgICAvLyBnZXQgc3RvcmFnZSBmb3JtYXQgY29uc3RydWN0b3JcbiAgICB2YXIgTSA9IHR5cGUuTWF0cml4LnN0b3JhZ2UoZm9ybWF0IHx8ICdkZWZhdWx0Jyk7XG5cbiAgICAvLyBjcmVhdGUgaW5zdGFuY2VcbiAgICByZXR1cm4gbmV3IE0oZGF0YSwgZGF0YXR5cGUpO1xuICB9XG59XG5cbmV4cG9ydHMubmFtZSA9ICdtYXRyaXgnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuXG4gIHZhciBTcGFyc2VNYXRyaXggPSB0eXBlLlNwYXJzZU1hdHJpeDtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgU3BhcnNlIE1hdHJpeC4gVGhlIGZ1bmN0aW9uIGNyZWF0ZXMgYSBuZXcgYG1hdGgudHlwZS5NYXRyaXhgIG9iamVjdCBmcm9tXG4gICAqIGFuIGBBcnJheWAuIEEgTWF0cml4IGhhcyB1dGlsaXR5IGZ1bmN0aW9ucyB0byBtYW5pcHVsYXRlIHRoZSBkYXRhIGluIHRoZVxuICAgKiBtYXRyaXgsIGxpa2UgZ2V0dGluZyB0aGUgc2l6ZSBhbmQgZ2V0dGluZyBvciBzZXR0aW5nIHZhbHVlcyBpbiB0aGUgbWF0cml4LlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguc3BhcnNlKCkgICAgICAgICAgICAgICAvLyBjcmVhdGVzIGFuIGVtcHR5IHNwYXJzZSBtYXRyaXguXG4gICAqICAgIG1hdGguc3BhcnNlKGRhdGEpICAgICAgICAgICAvLyBjcmVhdGVzIGEgc3BhcnNlIG1hdHJpeCB3aXRoIGluaXRpYWwgZGF0YS5cbiAgICogICAgbWF0aC5zcGFyc2UoZGF0YSwgJ251bWJlcicpIC8vIGNyZWF0ZXMgYSBzcGFyc2UgbWF0cml4IHdpdGggaW5pdGlhbCBkYXRhLCBudW1iZXIgZGF0YXR5cGUuXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICB2YXIgbSA9IG1hdGguc3BhcnNlKFtbMSwgMl0sIFszLCA0XV0pO1xuICAgKiAgICBtLnNpemUoKTsgICAgICAgICAgICAgICAgICAgICAgICAvLyBBcnJheSBbMiwgMl1cbiAgICogICAgbS5yZXNpemUoWzMsIDJdLCA1KTtcbiAgICogICAgbS52YWx1ZU9mKCk7ICAgICAgICAgICAgICAgICAgICAgLy8gQXJyYXkgW1sxLCAyXSwgWzMsIDRdLCBbNSwgNV1dXG4gICAqICAgIG0uZ2V0KFsxLCAwXSkgICAgICAgICAgICAgICAgICAgIC8vIG51bWJlciAzXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBiaWdudW1iZXIsIGJvb2xlYW4sIGNvbXBsZXgsIGluZGV4LCBudW1iZXIsIHN0cmluZywgdW5pdCwgbWF0cml4XG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXkgfCBNYXRyaXh9IFtkYXRhXSAgICBBIHR3byBkaW1lbnNpb25hbCBhcnJheVxuICAgKlxuICAgKiBAcmV0dXJuIHtNYXRyaXh9IFRoZSBjcmVhdGVkIG1hdHJpeFxuICAgKi9cbiAgdmFyIHNwYXJzZSA9IHR5cGVkKCdzcGFyc2UnLCB7XG4gICAgJyc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgU3BhcnNlTWF0cml4KFtdKTtcbiAgICB9LFxuICAgIFxuICAgICdzdHJpbmcnOiBmdW5jdGlvbiAoZGF0YXR5cGUpIHtcbiAgICAgIHJldHVybiBuZXcgU3BhcnNlTWF0cml4KFtdLCBkYXRhdHlwZSk7XG4gICAgfSxcblxuICAgICdBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICByZXR1cm4gbmV3IFNwYXJzZU1hdHJpeChkYXRhKTtcbiAgICB9LFxuICAgIFxuICAgICdBcnJheSB8IE1hdHJpeCwgc3RyaW5nJzogZnVuY3Rpb24gKGRhdGEsIGRhdGF0eXBlKSB7XG4gICAgICByZXR1cm4gbmV3IFNwYXJzZU1hdHJpeChkYXRhLCBkYXRhdHlwZSk7XG4gICAgfVxuICB9KTtcblxuICBzcGFyc2UudG9UZXggPSB7XG4gICAgMDogJ1xcXFxiZWdpbntic3BhcnNlfVxcXFxlbmR7YnNwYXJzZX0nLFxuICAgIDE6ICdcXFxcbGVmdCgke2FyZ3NbMF19XFxcXHJpZ2h0KSdcbiAgfTtcblxuICByZXR1cm4gc3BhcnNlO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnc3BhcnNlJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFtcbiAgLy8gdHlwZXNcbiAgcmVxdWlyZSgnLi9NYXRyaXgnKSxcbiAgcmVxdWlyZSgnLi9EZW5zZU1hdHJpeCcpLFxuICByZXF1aXJlKCcuL1NwYXJzZU1hdHJpeCcpLFxuICByZXF1aXJlKCcuL1NwYScpLFxuICByZXF1aXJlKCcuL0ZpYm9uYWNjaUhlYXAnKSxcbiAgcmVxdWlyZSgnLi9JbW11dGFibGVEZW5zZU1hdHJpeCcpLFxuICByZXF1aXJlKCcuL01hdHJpeEluZGV4JyksXG4gIHJlcXVpcmUoJy4vUmFuZ2UnKSxcblxuICAvLyBjb25zdHJ1Y3Rpb24gZnVuY3Rpb25zXG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vaW5kZXgnKSxcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi9tYXRyaXgnKSxcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi9zcGFyc2UnKVxuXTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIERpbWVuc2lvbkVycm9yID0gcmVxdWlyZSgnLi4vLi4vLi4vZXJyb3IvRGltZW5zaW9uRXJyb3InKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuXG4gIHZhciBEZW5zZU1hdHJpeCA9IHR5cGUuRGVuc2VNYXRyaXg7XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGVzIG92ZXIgU3BhcnNlTWF0cml4IG5vbnplcm8gaXRlbXMgYW5kIGludm9rZXMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGYoRGlqLCBTaWopLiBcbiAgICogQ2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlZCBOTlogdGltZXMgKG51bWJlciBvZiBub256ZXJvIGl0ZW1zIGluIFNwYXJzZU1hdHJpeCkuXG4gICAqXG4gICAqXG4gICAqICAgICAgICAgIOKUjCAgZihEaWosIFNpaikgIDsgUyhpLGopICE9PSAwXG4gICAqIEMoaSxqKSA9IOKUpFxuICAgKiAgICAgICAgICDilJQgIERpaiAgICAgICAgICA7IG90aGVyd2lzZVxuICAgKlxuICAgKlxuICAgKiBAcGFyYW0ge01hdHJpeH0gICBkZW5zZU1hdHJpeCAgICAgICBUaGUgRGVuc2VNYXRyaXggaW5zdGFuY2UgKEQpXG4gICAqIEBwYXJhbSB7TWF0cml4fSAgIHNwYXJzZU1hdHJpeCAgICAgIFRoZSBTcGFyc2VNYXRyaXggaW5zdGFuY2UgKFMpXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrICAgICAgICAgIFRoZSBmKERpaixTaWopIG9wZXJhdGlvbiB0byBpbnZva2UsIHdoZXJlIERpaiA9IERlbnNlTWF0cml4KGksaikgYW5kIFNpaiA9IFNwYXJzZU1hdHJpeChpLGopXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gIGludmVyc2UgICAgICAgICAgIEEgdHJ1ZSB2YWx1ZSBpbmRpY2F0ZXMgY2FsbGJhY2sgc2hvdWxkIGJlIGludm9rZWQgZihTaWosRGlqKVxuICAgKlxuICAgKiBAcmV0dXJuIHtNYXRyaXh9ICAgICAgICAgICAgICAgICAgICBEZW5zZU1hdHJpeCAoQylcbiAgICpcbiAgICogc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qb3NkZWpvbmcvbWF0aGpzL3B1bGwvMzQ2I2lzc3VlY29tbWVudC05NzQ3NzU3MVxuICAgKi9cbiAgdmFyIGFsZ29yaXRobTAxID0gZnVuY3Rpb24gKGRlbnNlTWF0cml4LCBzcGFyc2VNYXRyaXgsIGNhbGxiYWNrLCBpbnZlcnNlKSB7XG4gICAgLy8gZGVuc2UgbWF0cml4IGFycmF5c1xuICAgIHZhciBhZGF0YSA9IGRlbnNlTWF0cml4Ll9kYXRhO1xuICAgIHZhciBhc2l6ZSA9IGRlbnNlTWF0cml4Ll9zaXplO1xuICAgIHZhciBhZHQgPSBkZW5zZU1hdHJpeC5fZGF0YXR5cGU7XG4gICAgLy8gc3BhcnNlIG1hdHJpeCBhcnJheXNcbiAgICB2YXIgYnZhbHVlcyA9IHNwYXJzZU1hdHJpeC5fdmFsdWVzO1xuICAgIHZhciBiaW5kZXggPSBzcGFyc2VNYXRyaXguX2luZGV4O1xuICAgIHZhciBicHRyID0gc3BhcnNlTWF0cml4Ll9wdHI7XG4gICAgdmFyIGJzaXplID0gc3BhcnNlTWF0cml4Ll9zaXplO1xuICAgIHZhciBiZHQgPSBzcGFyc2VNYXRyaXguX2RhdGF0eXBlO1xuXG4gICAgLy8gdmFsaWRhdGUgZGltZW5zaW9uc1xuICAgIGlmIChhc2l6ZS5sZW5ndGggIT09IGJzaXplLmxlbmd0aClcbiAgICAgIHRocm93IG5ldyBEaW1lbnNpb25FcnJvcihhc2l6ZS5sZW5ndGgsIGJzaXplLmxlbmd0aCk7XG5cbiAgICAvLyBjaGVjayByb3dzICYgY29sdW1uc1xuICAgIGlmIChhc2l6ZVswXSAhPT0gYnNpemVbMF0gfHwgYXNpemVbMV0gIT09IGJzaXplWzFdKVxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0RpbWVuc2lvbiBtaXNtYXRjaC4gTWF0cml4IEEgKCcgKyBhc2l6ZSArICcpIG11c3QgbWF0Y2ggTWF0cml4IEIgKCcgKyBic2l6ZSArICcpJyk7XG5cbiAgICAvLyBzcGFyc2UgbWF0cml4IGNhbm5vdCBiZSBhIFBhdHRlcm4gbWF0cml4XG4gICAgaWYgKCFidmFsdWVzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcGVyZm9ybSBvcGVyYXRpb24gb24gRGVuc2UgTWF0cml4IGFuZCBQYXR0ZXJuIFNwYXJzZSBNYXRyaXgnKTtcblxuICAgIC8vIHJvd3MgJiBjb2x1bW5zXG4gICAgdmFyIHJvd3MgPSBhc2l6ZVswXTtcbiAgICB2YXIgY29sdW1ucyA9IGFzaXplWzFdO1xuXG4gICAgLy8gcHJvY2VzcyBkYXRhIHR5cGVzXG4gICAgdmFyIGR0ID0gdHlwZW9mIGFkdCA9PT0gJ3N0cmluZycgJiYgYWR0ID09PSBiZHQgPyBhZHQgOiB1bmRlZmluZWQ7XG4gICAgLy8gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICB2YXIgY2YgPSBkdCA/IHR5cGVkLmZpbmQoY2FsbGJhY2ssIFtkdCwgZHRdKSA6IGNhbGxiYWNrO1xuXG4gICAgLy8gdmFyc1xuICAgIHZhciBpLCBqO1xuICAgIFxuICAgIC8vIHJlc3VsdCAoRGVuc2VNYXRyaXgpXG4gICAgdmFyIGNkYXRhID0gW107XG4gICAgLy8gaW5pdGlhbGl6ZSBjXG4gICAgZm9yIChpID0gMDsgaSA8IHJvd3M7IGkrKylcbiAgICAgIGNkYXRhW2ldID0gW107ICAgICAgXG4gICAgXG4gICAgLy8gd29ya3NwYWNlXG4gICAgdmFyIHggPSBbXTtcbiAgICAvLyBtYXJrcyBpbmRpY2F0aW5nIHdlIGhhdmUgYSB2YWx1ZSBpbiB4IGZvciBhIGdpdmVuIGNvbHVtblxuICAgIHZhciB3ID0gW107XG5cbiAgICAvLyBsb29wIGNvbHVtbnMgaW4gYlxuICAgIGZvciAoaiA9IDA7IGogPCBjb2x1bW5zOyBqKyspIHtcbiAgICAgIC8vIGNvbHVtbiBtYXJrXG4gICAgICB2YXIgbWFyayA9IGogKyAxO1xuICAgICAgLy8gdmFsdWVzIGluIGNvbHVtbiBqXG4gICAgICBmb3IgKHZhciBrMCA9IGJwdHJbal0sIGsxID0gYnB0cltqICsgMV0sIGsgPSBrMDsgayA8IGsxOyBrKyspIHtcbiAgICAgICAgLy8gcm93XG4gICAgICAgIGkgPSBiaW5kZXhba107XG4gICAgICAgIC8vIHVwZGF0ZSB3b3Jrc3BhY2VcbiAgICAgICAgeFtpXSA9IGludmVyc2UgPyBjZihidmFsdWVzW2tdLCBhZGF0YVtpXVtqXSkgOiBjZihhZGF0YVtpXVtqXSwgYnZhbHVlc1trXSk7XG4gICAgICAgIC8vIG1hcmsgaSBhcyB1cGRhdGVkXG4gICAgICAgIHdbaV0gPSBtYXJrO1xuICAgICAgfVxuICAgICAgLy8gbG9vcCByb3dzXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG4gICAgICAgIC8vIGNoZWNrIHJvdyBpcyBpbiB3b3Jrc3BhY2VcbiAgICAgICAgaWYgKHdbaV0gPT09IG1hcmspIHtcbiAgICAgICAgICAvLyBjW2ldW2pdIHdhcyBhbHJlYWR5IGNhbGN1bGF0ZWRcbiAgICAgICAgICBjZGF0YVtpXVtqXSA9IHhbaV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgLy8gaXRlbSBkb2VzIG5vdCBleGlzdCBpbiBTXG4gICAgICAgICAgY2RhdGFbaV1bal0gPSBhZGF0YVtpXVtqXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJldHVybiBkZW5zZSBtYXRyaXhcbiAgICByZXR1cm4gbmV3IERlbnNlTWF0cml4KHtcbiAgICAgIGRhdGE6IGNkYXRhLFxuICAgICAgc2l6ZTogW3Jvd3MsIGNvbHVtbnNdLFxuICAgICAgZGF0YXR5cGU6IGR0XG4gICAgfSk7XG4gIH07XG4gIFxuICByZXR1cm4gYWxnb3JpdGhtMDE7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdhbGdvcml0aG0wMSc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRGltZW5zaW9uRXJyb3IgPSByZXF1aXJlKCcuLi8uLi8uLi9lcnJvci9EaW1lbnNpb25FcnJvcicpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG5cbiAgdmFyIGVxdWFsU2NhbGFyID0gbG9hZChyZXF1aXJlKCcuLi8uLi8uLi9mdW5jdGlvbi9yZWxhdGlvbmFsL2VxdWFsU2NhbGFyJykpO1xuXG4gIHZhciBTcGFyc2VNYXRyaXggPSB0eXBlLlNwYXJzZU1hdHJpeDtcblxuICAvKipcbiAgICogSXRlcmF0ZXMgb3ZlciBTcGFyc2VNYXRyaXggbm9uemVybyBpdGVtcyBhbmQgaW52b2tlcyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gZihEaWosIFNpaikuIFxuICAgKiBDYWxsYmFjayBmdW5jdGlvbiBpbnZva2VkIE5OWiB0aW1lcyAobnVtYmVyIG9mIG5vbnplcm8gaXRlbXMgaW4gU3BhcnNlTWF0cml4KS5cbiAgICpcbiAgICpcbiAgICogICAgICAgICAg4pSMICBmKERpaiwgU2lqKSAgOyBTKGksaikgIT09IDBcbiAgICogQyhpLGopID0g4pSkXG4gICAqICAgICAgICAgIOKUlCAgMCAgICAgICAgICAgIDsgb3RoZXJ3aXNlXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSB7TWF0cml4fSAgIGRlbnNlTWF0cml4ICAgICAgIFRoZSBEZW5zZU1hdHJpeCBpbnN0YW5jZSAoRClcbiAgICogQHBhcmFtIHtNYXRyaXh9ICAgc3BhcnNlTWF0cml4ICAgICAgVGhlIFNwYXJzZU1hdHJpeCBpbnN0YW5jZSAoUylcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgICAgICAgICAgVGhlIGYoRGlqLFNpaikgb3BlcmF0aW9uIHRvIGludm9rZSwgd2hlcmUgRGlqID0gRGVuc2VNYXRyaXgoaSxqKSBhbmQgU2lqID0gU3BhcnNlTWF0cml4KGksailcbiAgICogQHBhcmFtIHtib29sZWFufSAgaW52ZXJzZSAgICAgICAgICAgQSB0cnVlIHZhbHVlIGluZGljYXRlcyBjYWxsYmFjayBzaG91bGQgYmUgaW52b2tlZCBmKFNpaixEaWopXG4gICAqXG4gICAqIEByZXR1cm4ge01hdHJpeH0gICAgICAgICAgICAgICAgICAgIFNwYXJzZU1hdHJpeCAoQylcbiAgICpcbiAgICogc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qb3NkZWpvbmcvbWF0aGpzL3B1bGwvMzQ2I2lzc3VlY29tbWVudC05NzQ3NzU3MVxuICAgKi9cbiAgdmFyIGFsZ29yaXRobTAyID0gZnVuY3Rpb24gKGRlbnNlTWF0cml4LCBzcGFyc2VNYXRyaXgsIGNhbGxiYWNrLCBpbnZlcnNlKSB7XG4gICAgLy8gZGVuc2UgbWF0cml4IGFycmF5c1xuICAgIHZhciBhZGF0YSA9IGRlbnNlTWF0cml4Ll9kYXRhO1xuICAgIHZhciBhc2l6ZSA9IGRlbnNlTWF0cml4Ll9zaXplO1xuICAgIHZhciBhZHQgPSBkZW5zZU1hdHJpeC5fZGF0YXR5cGU7XG4gICAgLy8gc3BhcnNlIG1hdHJpeCBhcnJheXNcbiAgICB2YXIgYnZhbHVlcyA9IHNwYXJzZU1hdHJpeC5fdmFsdWVzO1xuICAgIHZhciBiaW5kZXggPSBzcGFyc2VNYXRyaXguX2luZGV4O1xuICAgIHZhciBicHRyID0gc3BhcnNlTWF0cml4Ll9wdHI7XG4gICAgdmFyIGJzaXplID0gc3BhcnNlTWF0cml4Ll9zaXplO1xuICAgIHZhciBiZHQgPSBzcGFyc2VNYXRyaXguX2RhdGF0eXBlO1xuXG4gICAgLy8gdmFsaWRhdGUgZGltZW5zaW9uc1xuICAgIGlmIChhc2l6ZS5sZW5ndGggIT09IGJzaXplLmxlbmd0aClcbiAgICAgIHRocm93IG5ldyBEaW1lbnNpb25FcnJvcihhc2l6ZS5sZW5ndGgsIGJzaXplLmxlbmd0aCk7XG5cbiAgICAvLyBjaGVjayByb3dzICYgY29sdW1uc1xuICAgIGlmIChhc2l6ZVswXSAhPT0gYnNpemVbMF0gfHwgYXNpemVbMV0gIT09IGJzaXplWzFdKVxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0RpbWVuc2lvbiBtaXNtYXRjaC4gTWF0cml4IEEgKCcgKyBhc2l6ZSArICcpIG11c3QgbWF0Y2ggTWF0cml4IEIgKCcgKyBic2l6ZSArICcpJyk7XG5cbiAgICAvLyBzcGFyc2UgbWF0cml4IGNhbm5vdCBiZSBhIFBhdHRlcm4gbWF0cml4XG4gICAgaWYgKCFidmFsdWVzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcGVyZm9ybSBvcGVyYXRpb24gb24gRGVuc2UgTWF0cml4IGFuZCBQYXR0ZXJuIFNwYXJzZSBNYXRyaXgnKTtcblxuICAgIC8vIHJvd3MgJiBjb2x1bW5zXG4gICAgdmFyIHJvd3MgPSBhc2l6ZVswXTtcbiAgICB2YXIgY29sdW1ucyA9IGFzaXplWzFdO1xuICAgIFxuICAgIC8vIGRhdGF0eXBlXG4gICAgdmFyIGR0O1xuICAgIC8vIGVxdWFsIHNpZ25hdHVyZSB0byB1c2VcbiAgICB2YXIgZXEgPSBlcXVhbFNjYWxhcjtcbiAgICAvLyB6ZXJvIHZhbHVlXG4gICAgdmFyIHplcm8gPSAwO1xuICAgIC8vIGNhbGxiYWNrIHNpZ25hdHVyZSB0byB1c2VcbiAgICB2YXIgY2YgPSBjYWxsYmFjaztcblxuICAgIC8vIHByb2Nlc3MgZGF0YSB0eXBlc1xuICAgIGlmICh0eXBlb2YgYWR0ID09PSAnc3RyaW5nJyAmJiBhZHQgPT09IGJkdCkge1xuICAgICAgLy8gZGF0YXR5cGVcbiAgICAgIGR0ID0gYWR0O1xuICAgICAgLy8gZmluZCBzaWduYXR1cmUgdGhhdCBtYXRjaGVzIChkdCwgZHQpXG4gICAgICBlcSA9IHR5cGVkLmZpbmQoZXF1YWxTY2FsYXIsIFtkdCwgZHRdKTtcbiAgICAgIC8vIGNvbnZlcnQgMCB0byB0aGUgc2FtZSBkYXRhdHlwZVxuICAgICAgemVybyA9IHR5cGVkLmNvbnZlcnQoMCwgZHQpO1xuICAgICAgLy8gY2FsbGJhY2tcbiAgICAgIGNmID0gdHlwZWQuZmluZChjYWxsYmFjaywgW2R0LCBkdF0pO1xuICAgIH1cblxuICAgIC8vIHJlc3VsdCAoU3BhcnNlTWF0cml4KVxuICAgIHZhciBjdmFsdWVzID0gW107XG4gICAgdmFyIGNpbmRleCA9IFtdO1xuICAgIHZhciBjcHRyID0gW107XG5cbiAgICAvLyBsb29wIGNvbHVtbnMgaW4gYlxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29sdW1uczsgaisrKSB7XG4gICAgICAvLyB1cGRhdGUgY3B0clxuICAgICAgY3B0cltqXSA9IGNpbmRleC5sZW5ndGg7XG4gICAgICAvLyB2YWx1ZXMgaW4gY29sdW1uIGpcbiAgICAgIGZvciAodmFyIGswID0gYnB0cltqXSwgazEgPSBicHRyW2ogKyAxXSwgayA9IGswOyBrIDwgazE7IGsrKykge1xuICAgICAgICAvLyByb3dcbiAgICAgICAgdmFyIGkgPSBiaW5kZXhba107XG4gICAgICAgIC8vIHVwZGF0ZSBDKGksailcbiAgICAgICAgdmFyIGNpaiA9IGludmVyc2UgPyBjZihidmFsdWVzW2tdLCBhZGF0YVtpXVtqXSkgOiBjZihhZGF0YVtpXVtqXSwgYnZhbHVlc1trXSk7XG4gICAgICAgIC8vIGNoZWNrIGZvciBub256ZXJvXG4gICAgICAgIGlmICghZXEoY2lqLCB6ZXJvKSkge1xuICAgICAgICAgIC8vIHB1c2ggaSAmIHZcbiAgICAgICAgICBjaW5kZXgucHVzaChpKTtcbiAgICAgICAgICBjdmFsdWVzLnB1c2goY2lqKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyB1cGRhdGUgY3B0clxuICAgIGNwdHJbY29sdW1uc10gPSBjaW5kZXgubGVuZ3RoO1xuXG4gICAgLy8gcmV0dXJuIHNwYXJzZSBtYXRyaXhcbiAgICByZXR1cm4gbmV3IFNwYXJzZU1hdHJpeCh7XG4gICAgICB2YWx1ZXM6IGN2YWx1ZXMsXG4gICAgICBpbmRleDogY2luZGV4LFxuICAgICAgcHRyOiBjcHRyLFxuICAgICAgc2l6ZTogW3Jvd3MsIGNvbHVtbnNdLFxuICAgICAgZGF0YXR5cGU6IGR0XG4gICAgfSk7XG4gIH07XG4gIFxuICByZXR1cm4gYWxnb3JpdGhtMDI7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdhbGdvcml0aG0wMic7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRGltZW5zaW9uRXJyb3IgPSByZXF1aXJlKCcuLi8uLi8uLi9lcnJvci9EaW1lbnNpb25FcnJvcicpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG5cbiAgdmFyIERlbnNlTWF0cml4ID0gdHlwZS5EZW5zZU1hdHJpeDtcblxuICAvKipcbiAgICogSXRlcmF0ZXMgb3ZlciBTcGFyc2VNYXRyaXggaXRlbXMgYW5kIGludm9rZXMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGYoRGlqLCBTaWopLlxuICAgKiBDYWxsYmFjayBmdW5jdGlvbiBpbnZva2VkIE0qTiB0aW1lcy5cbiAgICpcbiAgICpcbiAgICogICAgICAgICAg4pSMICBmKERpaiwgU2lqKSAgOyBTKGksaikgIT09IDBcbiAgICogQyhpLGopID0g4pSkXG4gICAqICAgICAgICAgIOKUlCAgZihEaWosIDApICAgIDsgb3RoZXJ3aXNlXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSB7TWF0cml4fSAgIGRlbnNlTWF0cml4ICAgICAgIFRoZSBEZW5zZU1hdHJpeCBpbnN0YW5jZSAoRClcbiAgICogQHBhcmFtIHtNYXRyaXh9ICAgc3BhcnNlTWF0cml4ICAgICAgVGhlIFNwYXJzZU1hdHJpeCBpbnN0YW5jZSAoQylcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgICAgICAgICAgVGhlIGYoRGlqLFNpaikgb3BlcmF0aW9uIHRvIGludm9rZSwgd2hlcmUgRGlqID0gRGVuc2VNYXRyaXgoaSxqKSBhbmQgU2lqID0gU3BhcnNlTWF0cml4KGksailcbiAgICogQHBhcmFtIHtib29sZWFufSAgaW52ZXJzZSAgICAgICAgICAgQSB0cnVlIHZhbHVlIGluZGljYXRlcyBjYWxsYmFjayBzaG91bGQgYmUgaW52b2tlZCBmKFNpaixEaWopXG4gICAqXG4gICAqIEByZXR1cm4ge01hdHJpeH0gICAgICAgICAgICAgICAgICAgIERlbnNlTWF0cml4IChDKVxuICAgKlxuICAgKiBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2pvc2Rlam9uZy9tYXRoanMvcHVsbC8zNDYjaXNzdWVjb21tZW50LTk3NDc3NTcxXG4gICAqL1xuICB2YXIgYWxnb3JpdGhtMDMgPSBmdW5jdGlvbiAoZGVuc2VNYXRyaXgsIHNwYXJzZU1hdHJpeCwgY2FsbGJhY2ssIGludmVyc2UpIHtcbiAgICAvLyBkZW5zZSBtYXRyaXggYXJyYXlzXG4gICAgdmFyIGFkYXRhID0gZGVuc2VNYXRyaXguX2RhdGE7XG4gICAgdmFyIGFzaXplID0gZGVuc2VNYXRyaXguX3NpemU7XG4gICAgdmFyIGFkdCA9IGRlbnNlTWF0cml4Ll9kYXRhdHlwZTtcbiAgICAvLyBzcGFyc2UgbWF0cml4IGFycmF5c1xuICAgIHZhciBidmFsdWVzID0gc3BhcnNlTWF0cml4Ll92YWx1ZXM7XG4gICAgdmFyIGJpbmRleCA9IHNwYXJzZU1hdHJpeC5faW5kZXg7XG4gICAgdmFyIGJwdHIgPSBzcGFyc2VNYXRyaXguX3B0cjtcbiAgICB2YXIgYnNpemUgPSBzcGFyc2VNYXRyaXguX3NpemU7XG4gICAgdmFyIGJkdCA9IHNwYXJzZU1hdHJpeC5fZGF0YXR5cGU7XG5cbiAgICAvLyB2YWxpZGF0ZSBkaW1lbnNpb25zXG4gICAgaWYgKGFzaXplLmxlbmd0aCAhPT0gYnNpemUubGVuZ3RoKVxuICAgICAgdGhyb3cgbmV3IERpbWVuc2lvbkVycm9yKGFzaXplLmxlbmd0aCwgYnNpemUubGVuZ3RoKTtcblxuICAgIC8vIGNoZWNrIHJvd3MgJiBjb2x1bW5zXG4gICAgaWYgKGFzaXplWzBdICE9PSBic2l6ZVswXSB8fCBhc2l6ZVsxXSAhPT0gYnNpemVbMV0pXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignRGltZW5zaW9uIG1pc21hdGNoLiBNYXRyaXggQSAoJyArIGFzaXplICsgJykgbXVzdCBtYXRjaCBNYXRyaXggQiAoJyArIGJzaXplICsgJyknKTtcblxuICAgIC8vIHNwYXJzZSBtYXRyaXggY2Fubm90IGJlIGEgUGF0dGVybiBtYXRyaXhcbiAgICBpZiAoIWJ2YWx1ZXMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBwZXJmb3JtIG9wZXJhdGlvbiBvbiBEZW5zZSBNYXRyaXggYW5kIFBhdHRlcm4gU3BhcnNlIE1hdHJpeCcpO1xuXG4gICAgLy8gcm93cyAmIGNvbHVtbnNcbiAgICB2YXIgcm93cyA9IGFzaXplWzBdO1xuICAgIHZhciBjb2x1bW5zID0gYXNpemVbMV07XG5cbiAgICAvLyBkYXRhdHlwZVxuICAgIHZhciBkdDtcbiAgICAvLyB6ZXJvIHZhbHVlXG4gICAgdmFyIHplcm8gPSAwO1xuICAgIC8vIGNhbGxiYWNrIHNpZ25hdHVyZSB0byB1c2VcbiAgICB2YXIgY2YgPSBjYWxsYmFjaztcblxuICAgIC8vIHByb2Nlc3MgZGF0YSB0eXBlc1xuICAgIGlmICh0eXBlb2YgYWR0ID09PSAnc3RyaW5nJyAmJiBhZHQgPT09IGJkdCkge1xuICAgICAgLy8gZGF0YXR5cGVcbiAgICAgIGR0ID0gYWR0O1xuICAgICAgLy8gY29udmVydCAwIHRvIHRoZSBzYW1lIGRhdGF0eXBlXG4gICAgICB6ZXJvID0gdHlwZWQuY29udmVydCgwLCBkdCk7XG4gICAgICAvLyBjYWxsYmFja1xuICAgICAgY2YgPSB0eXBlZC5maW5kKGNhbGxiYWNrLCBbZHQsIGR0XSk7XG4gICAgfVxuXG4gICAgLy8gcmVzdWx0IChEZW5zZU1hdHJpeClcbiAgICB2YXIgY2RhdGEgPSBbXTtcblxuICAgIC8vIGluaXRpYWxpemUgZGVuc2UgbWF0cml4XG4gICAgZm9yICh2YXIgeiA9IDA7IHogPCByb3dzOyB6KyspIHtcbiAgICAgIC8vIGluaXRpYWxpemUgcm93XG4gICAgICBjZGF0YVt6XSA9IFtdO1xuICAgIH1cblxuICAgIC8vIHdvcmtzcGFjZVxuICAgIHZhciB4ID0gW107XG4gICAgLy8gbWFya3MgaW5kaWNhdGluZyB3ZSBoYXZlIGEgdmFsdWUgaW4geCBmb3IgYSBnaXZlbiBjb2x1bW5cbiAgICB2YXIgdyA9IFtdO1xuXG4gICAgLy8gbG9vcCBjb2x1bW5zIGluIGJcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbHVtbnM7IGorKykge1xuICAgICAgLy8gY29sdW1uIG1hcmtcbiAgICAgIHZhciBtYXJrID0gaiArIDE7XG4gICAgICAvLyB2YWx1ZXMgaW4gY29sdW1uIGpcbiAgICAgIGZvciAodmFyIGswID0gYnB0cltqXSwgazEgPSBicHRyW2ogKyAxXSwgayA9IGswOyBrIDwgazE7IGsrKykge1xuICAgICAgICAvLyByb3dcbiAgICAgICAgdmFyIGkgPSBiaW5kZXhba107XG4gICAgICAgIC8vIHVwZGF0ZSB3b3Jrc3BhY2VcbiAgICAgICAgeFtpXSA9IGludmVyc2UgPyBjZihidmFsdWVzW2tdLCBhZGF0YVtpXVtqXSkgOiBjZihhZGF0YVtpXVtqXSwgYnZhbHVlc1trXSk7XG4gICAgICAgIHdbaV0gPSBtYXJrO1xuICAgICAgfVxuICAgICAgLy8gcHJvY2VzcyB3b3Jrc3BhY2VcbiAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgcm93czsgeSsrKSB7XG4gICAgICAgIC8vIGNoZWNrIHdlIGhhdmUgYSBjYWxjdWxhdGVkIHZhbHVlIGZvciBjdXJyZW50IHJvd1xuICAgICAgICBpZiAod1t5XSA9PT0gbWFyaykge1xuICAgICAgICAgIC8vIHVzZSBjYWxjdWxhdGVkIHZhbHVlXG4gICAgICAgICAgY2RhdGFbeV1bal0gPSB4W3ldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIGNhbGN1bGF0ZSB2YWx1ZVxuICAgICAgICAgIGNkYXRhW3ldW2pdID0gaW52ZXJzZSA/IGNmKHplcm8sIGFkYXRhW3ldW2pdKSA6IGNmKGFkYXRhW3ldW2pdLCB6ZXJvKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJldHVybiBkZW5zZSBtYXRyaXhcbiAgICByZXR1cm4gbmV3IERlbnNlTWF0cml4KHtcbiAgICAgIGRhdGE6IGNkYXRhLFxuICAgICAgc2l6ZTogW3Jvd3MsIGNvbHVtbnNdLFxuICAgICAgZGF0YXR5cGU6IGR0XG4gICAgfSk7XG4gIH07XG4gIFxuICByZXR1cm4gYWxnb3JpdGhtMDM7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdhbGdvcml0aG0wMyc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRGltZW5zaW9uRXJyb3IgPSByZXF1aXJlKCcuLi8uLi8uLi9lcnJvci9EaW1lbnNpb25FcnJvcicpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG5cbiAgdmFyIGVxdWFsU2NhbGFyID0gbG9hZChyZXF1aXJlKCcuLi8uLi8uLi9mdW5jdGlvbi9yZWxhdGlvbmFsL2VxdWFsU2NhbGFyJykpO1xuXG4gIHZhciBTcGFyc2VNYXRyaXggPSB0eXBlLlNwYXJzZU1hdHJpeDtcblxuICAvKipcbiAgICogSXRlcmF0ZXMgb3ZlciBTcGFyc2VNYXRyaXggQSBhbmQgU3BhcnNlTWF0cml4IEIgbm9uemVybyBpdGVtcyBhbmQgaW52b2tlcyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gZihBaWosIEJpaikuIFxuICAgKiBDYWxsYmFjayBmdW5jdGlvbiBpbnZva2VkIE1BWChOTlpBLCBOTlpCKSB0aW1lc1xuICAgKlxuICAgKlxuICAgKiAgICAgICAgICDilIwgIGYoQWlqLCBCaWopICA7IEEoaSxqKSAhPT0gMCAmJiBCKGksaikgIT09IDBcbiAgICogQyhpLGopID0g4pSkICBBKGksaikgICAgICAgOyBBKGksaikgIT09IDBcbiAgICogICAgICAgICAg4pSUICBCKGksaikgICAgICAgOyBCKGksaikgIT09IDBcbiAgICpcbiAgICpcbiAgICogQHBhcmFtIHtNYXRyaXh9ICAgYSAgICAgICAgICAgICAgICAgVGhlIFNwYXJzZU1hdHJpeCBpbnN0YW5jZSAoQSlcbiAgICogQHBhcmFtIHtNYXRyaXh9ICAgYiAgICAgICAgICAgICAgICAgVGhlIFNwYXJzZU1hdHJpeCBpbnN0YW5jZSAoQilcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgICAgICAgICAgVGhlIGYoQWlqLEJpaikgb3BlcmF0aW9uIHRvIGludm9rZVxuICAgKlxuICAgKiBAcmV0dXJuIHtNYXRyaXh9ICAgICAgICAgICAgICAgICAgICBTcGFyc2VNYXRyaXggKEMpXG4gICAqXG4gICAqIHNlZSBodHRwczovL2dpdGh1Yi5jb20vam9zZGVqb25nL21hdGhqcy9wdWxsLzM0NiNpc3N1ZWNvbW1lbnQtOTc2MjAyOTRcbiAgICovXG4gIHZhciBhbGdvcml0aG0wNCA9IGZ1bmN0aW9uIChhLCBiLCBjYWxsYmFjaykge1xuICAgIC8vIHNwYXJzZSBtYXRyaXggYXJyYXlzXG4gICAgdmFyIGF2YWx1ZXMgPSBhLl92YWx1ZXM7XG4gICAgdmFyIGFpbmRleCA9IGEuX2luZGV4O1xuICAgIHZhciBhcHRyID0gYS5fcHRyO1xuICAgIHZhciBhc2l6ZSA9IGEuX3NpemU7XG4gICAgdmFyIGFkdCA9IGEuX2RhdGF0eXBlO1xuICAgIC8vIHNwYXJzZSBtYXRyaXggYXJyYXlzXG4gICAgdmFyIGJ2YWx1ZXMgPSBiLl92YWx1ZXM7XG4gICAgdmFyIGJpbmRleCA9IGIuX2luZGV4O1xuICAgIHZhciBicHRyID0gYi5fcHRyO1xuICAgIHZhciBic2l6ZSA9IGIuX3NpemU7XG4gICAgdmFyIGJkdCA9IGIuX2RhdGF0eXBlO1xuXG4gICAgLy8gdmFsaWRhdGUgZGltZW5zaW9uc1xuICAgIGlmIChhc2l6ZS5sZW5ndGggIT09IGJzaXplLmxlbmd0aClcbiAgICAgIHRocm93IG5ldyBEaW1lbnNpb25FcnJvcihhc2l6ZS5sZW5ndGgsIGJzaXplLmxlbmd0aCk7XG5cbiAgICAvLyBjaGVjayByb3dzICYgY29sdW1uc1xuICAgIGlmIChhc2l6ZVswXSAhPT0gYnNpemVbMF0gfHwgYXNpemVbMV0gIT09IGJzaXplWzFdKVxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0RpbWVuc2lvbiBtaXNtYXRjaC4gTWF0cml4IEEgKCcgKyBhc2l6ZSArICcpIG11c3QgbWF0Y2ggTWF0cml4IEIgKCcgKyBic2l6ZSArICcpJyk7XG5cbiAgICAvLyByb3dzICYgY29sdW1uc1xuICAgIHZhciByb3dzID0gYXNpemVbMF07XG4gICAgdmFyIGNvbHVtbnMgPSBhc2l6ZVsxXTtcblxuICAgIC8vIGRhdGF0eXBlXG4gICAgdmFyIGR0O1xuICAgIC8vIGVxdWFsIHNpZ25hdHVyZSB0byB1c2VcbiAgICB2YXIgZXEgPSBlcXVhbFNjYWxhcjtcbiAgICAvLyB6ZXJvIHZhbHVlXG4gICAgdmFyIHplcm8gPSAwO1xuICAgIC8vIGNhbGxiYWNrIHNpZ25hdHVyZSB0byB1c2VcbiAgICB2YXIgY2YgPSBjYWxsYmFjaztcblxuICAgIC8vIHByb2Nlc3MgZGF0YSB0eXBlc1xuICAgIGlmICh0eXBlb2YgYWR0ID09PSAnc3RyaW5nJyAmJiBhZHQgPT09IGJkdCkge1xuICAgICAgLy8gZGF0YXR5cGVcbiAgICAgIGR0ID0gYWR0O1xuICAgICAgLy8gZmluZCBzaWduYXR1cmUgdGhhdCBtYXRjaGVzIChkdCwgZHQpXG4gICAgICBlcSA9IHR5cGVkLmZpbmQoZXF1YWxTY2FsYXIsIFtkdCwgZHRdKTtcbiAgICAgIC8vIGNvbnZlcnQgMCB0byB0aGUgc2FtZSBkYXRhdHlwZVxuICAgICAgemVybyA9IHR5cGVkLmNvbnZlcnQoMCwgZHQpO1xuICAgICAgLy8gY2FsbGJhY2tcbiAgICAgIGNmID0gdHlwZWQuZmluZChjYWxsYmFjaywgW2R0LCBkdF0pO1xuICAgIH1cblxuICAgIC8vIHJlc3VsdCBhcnJheXNcbiAgICB2YXIgY3ZhbHVlcyA9IGF2YWx1ZXMgJiYgYnZhbHVlcyA/IFtdIDogdW5kZWZpbmVkO1xuICAgIHZhciBjaW5kZXggPSBbXTtcbiAgICB2YXIgY3B0ciA9IFtdO1xuICAgIC8vIG1hdHJpeFxuICAgIHZhciBjID0gbmV3IFNwYXJzZU1hdHJpeCh7XG4gICAgICB2YWx1ZXM6IGN2YWx1ZXMsXG4gICAgICBpbmRleDogY2luZGV4LFxuICAgICAgcHRyOiBjcHRyLFxuICAgICAgc2l6ZTogW3Jvd3MsIGNvbHVtbnNdLFxuICAgICAgZGF0YXR5cGU6IGR0XG4gICAgfSk7XG5cbiAgICAvLyB3b3Jrc3BhY2VcbiAgICB2YXIgeGEgPSBhdmFsdWVzICYmIGJ2YWx1ZXMgPyBbXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgeGIgPSBhdmFsdWVzICYmIGJ2YWx1ZXMgPyBbXSA6IHVuZGVmaW5lZDtcbiAgICAvLyBtYXJrcyBpbmRpY2F0aW5nIHdlIGhhdmUgYSB2YWx1ZSBpbiB4IGZvciBhIGdpdmVuIGNvbHVtblxuICAgIHZhciB3YSA9IFtdO1xuICAgIHZhciB3YiA9IFtdO1xuXG4gICAgLy8gdmFycyBcbiAgICB2YXIgaSwgaiwgaywgazAsIGsxO1xuICAgIFxuICAgIC8vIGxvb3AgY29sdW1uc1xuICAgIGZvciAoaiA9IDA7IGogPCBjb2x1bW5zOyBqKyspIHtcbiAgICAgIC8vIHVwZGF0ZSBjcHRyXG4gICAgICBjcHRyW2pdID0gY2luZGV4Lmxlbmd0aDtcbiAgICAgIC8vIGNvbHVtbnMgbWFya1xuICAgICAgdmFyIG1hcmsgPSBqICsgMTtcbiAgICAgIC8vIGxvb3AgQSg6LGopXG4gICAgICBmb3IgKGswID0gYXB0cltqXSwgazEgPSBhcHRyW2ogKyAxXSwgayA9IGswOyBrIDwgazE7IGsrKykge1xuICAgICAgICAvLyByb3dcbiAgICAgICAgaSA9IGFpbmRleFtrXTtcbiAgICAgICAgLy8gdXBkYXRlIGNcbiAgICAgICAgY2luZGV4LnB1c2goaSk7XG4gICAgICAgIC8vIHVwZGF0ZSB3b3Jrc3BhY2VcbiAgICAgICAgd2FbaV0gPSBtYXJrO1xuICAgICAgICAvLyBjaGVjayB3ZSBuZWVkIHRvIHByb2Nlc3MgdmFsdWVzXG4gICAgICAgIGlmICh4YSlcbiAgICAgICAgICB4YVtpXSA9IGF2YWx1ZXNba107XG4gICAgICB9XG4gICAgICAvLyBsb29wIEIoOixqKVxuICAgICAgZm9yIChrMCA9IGJwdHJbal0sIGsxID0gYnB0cltqICsgMV0sIGsgPSBrMDsgayA8IGsxOyBrKyspIHtcbiAgICAgICAgLy8gcm93XG4gICAgICAgIGkgPSBiaW5kZXhba107XG4gICAgICAgIC8vIGNoZWNrIHJvdyBleGlzdHMgaW4gQVxuICAgICAgICBpZiAod2FbaV0gPT09IG1hcmspIHtcbiAgICAgICAgICAvLyB1cGRhdGUgcmVjb3JkIGluIHhhIEAgaVxuICAgICAgICAgIGlmICh4YSkge1xuICAgICAgICAgICAgLy8gaW52b2tlIGNhbGxiYWNrXG4gICAgICAgICAgICB2YXIgdiA9IGNmKHhhW2ldLCBidmFsdWVzW2tdKTtcbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciB6ZXJvXG4gICAgICAgICAgICBpZiAoIWVxKHYsIHplcm8pKSB7XG4gICAgICAgICAgICAgIC8vIHVwZGF0ZSB3b3Jrc3BhY2VcbiAgICAgICAgICAgICAgeGFbaV0gPSB2OyAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gcmVtb3ZlIG1hcmsgKGluZGV4IHdpbGwgYmUgcmVtb3ZlZCBsYXRlcilcbiAgICAgICAgICAgICAgd2FbaV0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyB1cGRhdGUgY1xuICAgICAgICAgIGNpbmRleC5wdXNoKGkpO1xuICAgICAgICAgIC8vIHVwZGF0ZSB3b3Jrc3BhY2VcbiAgICAgICAgICB3YltpXSA9IG1hcms7XG4gICAgICAgICAgLy8gY2hlY2sgd2UgbmVlZCB0byBwcm9jZXNzIHZhbHVlc1xuICAgICAgICAgIGlmICh4YilcbiAgICAgICAgICAgIHhiW2ldID0gYnZhbHVlc1trXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gY2hlY2sgd2UgbmVlZCB0byBwcm9jZXNzIHZhbHVlcyAobm9uIHBhdHRlcm4gbWF0cml4KVxuICAgICAgaWYgKHhhICYmIHhiKSB7XG4gICAgICAgIC8vIGluaXRpYWxpemUgZmlyc3QgaW5kZXggaW4galxuICAgICAgICBrID0gY3B0cltqXTtcbiAgICAgICAgLy8gbG9vcCBpbmRleCBpbiBqXG4gICAgICAgIHdoaWxlIChrIDwgY2luZGV4Lmxlbmd0aCkge1xuICAgICAgICAgIC8vIHJvd1xuICAgICAgICAgIGkgPSBjaW5kZXhba107XG4gICAgICAgICAgLy8gY2hlY2sgd29ya3NwYWNlIGhhcyB2YWx1ZSBAIGlcbiAgICAgICAgICBpZiAod2FbaV0gPT09IG1hcmspIHtcbiAgICAgICAgICAgIC8vIHB1c2ggdmFsdWUgKEFpaiAhPSAwIHx8IChBaWogIT0gMCAmJiBCaWogIT0gMCkpXG4gICAgICAgICAgICBjdmFsdWVzW2tdID0geGFbaV07XG4gICAgICAgICAgICAvLyBpbmNyZW1lbnQgcG9pbnRlclxuICAgICAgICAgICAgaysrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICh3YltpXSA9PT0gbWFyaykge1xuICAgICAgICAgICAgLy8gcHVzaCB2YWx1ZSAoYmlqICE9IDApXG4gICAgICAgICAgICBjdmFsdWVzW2tdID0geGJbaV07XG4gICAgICAgICAgICAvLyBpbmNyZW1lbnQgcG9pbnRlclxuICAgICAgICAgICAgaysrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBpbmRleCBAIGtcbiAgICAgICAgICAgIGNpbmRleC5zcGxpY2UoaywgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVwZGF0ZSBjcHRyXG4gICAgY3B0cltjb2x1bW5zXSA9IGNpbmRleC5sZW5ndGg7XG5cbiAgICAvLyByZXR1cm4gc3BhcnNlIG1hdHJpeFxuICAgIHJldHVybiBjO1xuICB9O1xuICBcbiAgcmV0dXJuIGFsZ29yaXRobTA0O1xufVxuXG5leHBvcnRzLm5hbWUgPSAnYWxnb3JpdGhtMDQnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIERpbWVuc2lvbkVycm9yID0gcmVxdWlyZSgnLi4vLi4vLi4vZXJyb3IvRGltZW5zaW9uRXJyb3InKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuXG4gIHZhciBlcXVhbFNjYWxhciA9IGxvYWQocmVxdWlyZSgnLi4vLi4vLi4vZnVuY3Rpb24vcmVsYXRpb25hbC9lcXVhbFNjYWxhcicpKTtcbiAgXG4gIHZhciBTcGFyc2VNYXRyaXggPSB0eXBlLlNwYXJzZU1hdHJpeDtcblxuICAvKipcbiAgICogSXRlcmF0ZXMgb3ZlciBTcGFyc2VNYXRyaXggQSBhbmQgU3BhcnNlTWF0cml4IEIgbm9uemVybyBpdGVtcyBhbmQgaW52b2tlcyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gZihBaWosIEJpaikuIFxuICAgKiBDYWxsYmFjayBmdW5jdGlvbiBpbnZva2VkIE1BWChOTlpBLCBOTlpCKSB0aW1lc1xuICAgKlxuICAgKlxuICAgKiAgICAgICAgICDilIwgIGYoQWlqLCBCaWopICA7IEEoaSxqKSAhPT0gMCB8fCBCKGksaikgIT09IDBcbiAgICogQyhpLGopID0g4pSkICBcbiAgICogICAgICAgICAg4pSUICAwICAgICAgICAgICAgOyBvdGhlcndpc2VcbiAgICpcbiAgICpcbiAgICogQHBhcmFtIHtNYXRyaXh9ICAgYSAgICAgICAgICAgICAgICAgVGhlIFNwYXJzZU1hdHJpeCBpbnN0YW5jZSAoQSlcbiAgICogQHBhcmFtIHtNYXRyaXh9ICAgYiAgICAgICAgICAgICAgICAgVGhlIFNwYXJzZU1hdHJpeCBpbnN0YW5jZSAoQilcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgICAgICAgICAgVGhlIGYoQWlqLEJpaikgb3BlcmF0aW9uIHRvIGludm9rZVxuICAgKlxuICAgKiBAcmV0dXJuIHtNYXRyaXh9ICAgICAgICAgICAgICAgICAgICBTcGFyc2VNYXRyaXggKEMpXG4gICAqXG4gICAqIHNlZSBodHRwczovL2dpdGh1Yi5jb20vam9zZGVqb25nL21hdGhqcy9wdWxsLzM0NiNpc3N1ZWNvbW1lbnQtOTc2MjAyOTRcbiAgICovXG4gIHZhciBhbGdvcml0aG0wNSA9IGZ1bmN0aW9uIChhLCBiLCBjYWxsYmFjaykge1xuICAgIC8vIHNwYXJzZSBtYXRyaXggYXJyYXlzXG4gICAgdmFyIGF2YWx1ZXMgPSBhLl92YWx1ZXM7XG4gICAgdmFyIGFpbmRleCA9IGEuX2luZGV4O1xuICAgIHZhciBhcHRyID0gYS5fcHRyO1xuICAgIHZhciBhc2l6ZSA9IGEuX3NpemU7XG4gICAgdmFyIGFkdCA9IGEuX2RhdGF0eXBlO1xuICAgIC8vIHNwYXJzZSBtYXRyaXggYXJyYXlzXG4gICAgdmFyIGJ2YWx1ZXMgPSBiLl92YWx1ZXM7XG4gICAgdmFyIGJpbmRleCA9IGIuX2luZGV4O1xuICAgIHZhciBicHRyID0gYi5fcHRyO1xuICAgIHZhciBic2l6ZSA9IGIuX3NpemU7XG4gICAgdmFyIGJkdCA9IGIuX2RhdGF0eXBlO1xuXG4gICAgLy8gdmFsaWRhdGUgZGltZW5zaW9uc1xuICAgIGlmIChhc2l6ZS5sZW5ndGggIT09IGJzaXplLmxlbmd0aClcbiAgICAgIHRocm93IG5ldyBEaW1lbnNpb25FcnJvcihhc2l6ZS5sZW5ndGgsIGJzaXplLmxlbmd0aCk7XG5cbiAgICAvLyBjaGVjayByb3dzICYgY29sdW1uc1xuICAgIGlmIChhc2l6ZVswXSAhPT0gYnNpemVbMF0gfHwgYXNpemVbMV0gIT09IGJzaXplWzFdKVxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0RpbWVuc2lvbiBtaXNtYXRjaC4gTWF0cml4IEEgKCcgKyBhc2l6ZSArICcpIG11c3QgbWF0Y2ggTWF0cml4IEIgKCcgKyBic2l6ZSArICcpJyk7XG5cbiAgICAvLyByb3dzICYgY29sdW1uc1xuICAgIHZhciByb3dzID0gYXNpemVbMF07XG4gICAgdmFyIGNvbHVtbnMgPSBhc2l6ZVsxXTtcblxuICAgIC8vIGRhdGF0eXBlXG4gICAgdmFyIGR0O1xuICAgIC8vIGVxdWFsIHNpZ25hdHVyZSB0byB1c2VcbiAgICB2YXIgZXEgPSBlcXVhbFNjYWxhcjtcbiAgICAvLyB6ZXJvIHZhbHVlXG4gICAgdmFyIHplcm8gPSAwO1xuICAgIC8vIGNhbGxiYWNrIHNpZ25hdHVyZSB0byB1c2VcbiAgICB2YXIgY2YgPSBjYWxsYmFjaztcblxuICAgIC8vIHByb2Nlc3MgZGF0YSB0eXBlc1xuICAgIGlmICh0eXBlb2YgYWR0ID09PSAnc3RyaW5nJyAmJiBhZHQgPT09IGJkdCkge1xuICAgICAgLy8gZGF0YXR5cGVcbiAgICAgIGR0ID0gYWR0O1xuICAgICAgLy8gZmluZCBzaWduYXR1cmUgdGhhdCBtYXRjaGVzIChkdCwgZHQpXG4gICAgICBlcSA9IHR5cGVkLmZpbmQoZXF1YWxTY2FsYXIsIFtkdCwgZHRdKTtcbiAgICAgIC8vIGNvbnZlcnQgMCB0byB0aGUgc2FtZSBkYXRhdHlwZVxuICAgICAgemVybyA9IHR5cGVkLmNvbnZlcnQoMCwgZHQpO1xuICAgICAgLy8gY2FsbGJhY2tcbiAgICAgIGNmID0gdHlwZWQuZmluZChjYWxsYmFjaywgW2R0LCBkdF0pO1xuICAgIH1cblxuICAgIC8vIHJlc3VsdCBhcnJheXNcbiAgICB2YXIgY3ZhbHVlcyA9IGF2YWx1ZXMgJiYgYnZhbHVlcyA/IFtdIDogdW5kZWZpbmVkO1xuICAgIHZhciBjaW5kZXggPSBbXTtcbiAgICB2YXIgY3B0ciA9IFtdO1xuICAgIC8vIG1hdHJpeFxuICAgIHZhciBjID0gbmV3IFNwYXJzZU1hdHJpeCh7XG4gICAgICB2YWx1ZXM6IGN2YWx1ZXMsXG4gICAgICBpbmRleDogY2luZGV4LFxuICAgICAgcHRyOiBjcHRyLFxuICAgICAgc2l6ZTogW3Jvd3MsIGNvbHVtbnNdLFxuICAgICAgZGF0YXR5cGU6IGR0XG4gICAgfSk7XG5cbiAgICAvLyB3b3Jrc3BhY2VzXG4gICAgdmFyIHhhID0gY3ZhbHVlcyA/IFtdIDogdW5kZWZpbmVkO1xuICAgIHZhciB4YiA9IGN2YWx1ZXMgPyBbXSA6IHVuZGVmaW5lZDtcbiAgICAvLyBtYXJrcyBpbmRpY2F0aW5nIHdlIGhhdmUgYSB2YWx1ZSBpbiB4IGZvciBhIGdpdmVuIGNvbHVtblxuICAgIHZhciB3YSA9IFtdO1xuICAgIHZhciB3YiA9IFtdO1xuXG4gICAgLy8gdmFyc1xuICAgIHZhciBpLCBqLCBrLCBrMTtcbiAgICBcbiAgICAvLyBsb29wIGNvbHVtbnNcbiAgICBmb3IgKGogPSAwOyBqIDwgY29sdW1uczsgaisrKSB7XG4gICAgICAvLyB1cGRhdGUgY3B0clxuICAgICAgY3B0cltqXSA9IGNpbmRleC5sZW5ndGg7XG4gICAgICAvLyBjb2x1bW5zIG1hcmtcbiAgICAgIHZhciBtYXJrID0gaiArIDE7XG4gICAgICAvLyBsb29wIHZhbHVlcyBBKDosailcbiAgICAgIGZvciAoayA9IGFwdHJbal0sIGsxID0gYXB0cltqICsgMV07IGsgPCBrMTsgaysrKSB7XG4gICAgICAgIC8vIHJvd1xuICAgICAgICBpID0gYWluZGV4W2tdO1xuICAgICAgICAvLyBwdXNoIGluZGV4XG4gICAgICAgIGNpbmRleC5wdXNoKGkpO1xuICAgICAgICAvLyB1cGRhdGUgd29ya3NwYWNlXG4gICAgICAgIHdhW2ldID0gbWFyaztcbiAgICAgICAgLy8gY2hlY2sgd2UgbmVlZCB0byBwcm9jZXNzIHZhbHVlc1xuICAgICAgICBpZiAoeGEpXG4gICAgICAgICAgeGFbaV0gPSBhdmFsdWVzW2tdO1xuICAgICAgfVxuICAgICAgLy8gbG9vcCB2YWx1ZXMgQig6LGopXG4gICAgICBmb3IgKGsgPSBicHRyW2pdLCBrMSA9IGJwdHJbaiArIDFdOyBrIDwgazE7IGsrKykge1xuICAgICAgICAvLyByb3dcbiAgICAgICAgaSA9IGJpbmRleFtrXTtcbiAgICAgICAgLy8gY2hlY2sgcm93IGV4aXN0ZWQgaW4gQVxuICAgICAgICBpZiAod2FbaV0gIT09IG1hcmspIHtcbiAgICAgICAgICAvLyBwdXNoIGluZGV4XG4gICAgICAgICAgY2luZGV4LnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXBkYXRlIHdvcmtzcGFjZVxuICAgICAgICB3YltpXSA9IG1hcms7XG4gICAgICAgIC8vIGNoZWNrIHdlIG5lZWQgdG8gcHJvY2VzcyB2YWx1ZXNcbiAgICAgICAgaWYgKHhiKVxuICAgICAgICAgIHhiW2ldID0gYnZhbHVlc1trXTtcbiAgICAgIH1cbiAgICAgIC8vIGNoZWNrIHdlIG5lZWQgdG8gcHJvY2VzcyB2YWx1ZXMgKG5vbiBwYXR0ZXJuIG1hdHJpeClcbiAgICAgIGlmIChjdmFsdWVzKSB7XG4gICAgICAgIC8vIGluaXRpYWxpemUgZmlyc3QgaW5kZXggaW4galxuICAgICAgICBrID0gY3B0cltqXTtcbiAgICAgICAgLy8gbG9vcCBpbmRleCBpbiBqXG4gICAgICAgIHdoaWxlIChrIDwgY2luZGV4Lmxlbmd0aCkge1xuICAgICAgICAgIC8vIHJvd1xuICAgICAgICAgIGkgPSBjaW5kZXhba107XG4gICAgICAgICAgLy8gbWFya3NcbiAgICAgICAgICB2YXIgd2FpID0gd2FbaV07XG4gICAgICAgICAgdmFyIHdiaSA9IHdiW2ldO1xuICAgICAgICAgIC8vIGNoZWNrIEFpaiBvciBCaWogYXJlIG5vbnplcm9cbiAgICAgICAgICBpZiAod2FpID09PSBtYXJrIHx8IHdiaSA9PT0gbWFyaykge1xuICAgICAgICAgICAgLy8gbWF0cml4IHZhbHVlcyBAIGksalxuICAgICAgICAgICAgdmFyIHZhID0gd2FpID09PSBtYXJrID8geGFbaV0gOiB6ZXJvO1xuICAgICAgICAgICAgdmFyIHZiID0gd2JpID09PSBtYXJrID8geGJbaV0gOiB6ZXJvO1xuICAgICAgICAgICAgLy8gQ2lqXG4gICAgICAgICAgICB2YXIgdmMgPSBjZih2YSwgdmIpO1xuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHplcm9cbiAgICAgICAgICAgIGlmICghZXEodmMsIHplcm8pKSB7XG4gICAgICAgICAgICAgIC8vIHB1c2ggdmFsdWVcbiAgICAgICAgICAgICAgY3ZhbHVlcy5wdXNoKHZjKTtcbiAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IHBvaW50ZXJcbiAgICAgICAgICAgICAgaysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHJlbW92ZSB2YWx1ZSBAIGksIGRvIG5vdCBpbmNyZW1lbnQgcG9pbnRlclxuICAgICAgICAgICAgICBjaW5kZXguc3BsaWNlKGssIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyB1cGRhdGUgY3B0clxuICAgIGNwdHJbY29sdW1uc10gPSBjaW5kZXgubGVuZ3RoO1xuXG4gICAgLy8gcmV0dXJuIHNwYXJzZSBtYXRyaXhcbiAgICByZXR1cm4gYztcbiAgfTtcblxuICByZXR1cm4gYWxnb3JpdGhtMDU7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdhbGdvcml0aG0wNSc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2NhdHRlciA9IHJlcXVpcmUoJy4vLi4vLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9zY2F0dGVyJyk7XG52YXIgRGltZW5zaW9uRXJyb3IgPSByZXF1aXJlKCcuLi8uLi8uLi9lcnJvci9EaW1lbnNpb25FcnJvcicpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG5cbiAgdmFyIGVxdWFsU2NhbGFyID0gbG9hZChyZXF1aXJlKCcuLi8uLi8uLi9mdW5jdGlvbi9yZWxhdGlvbmFsL2VxdWFsU2NhbGFyJykpO1xuXG4gIHZhciBTcGFyc2VNYXRyaXggPSB0eXBlLlNwYXJzZU1hdHJpeDtcblxuICAvKipcbiAgICogSXRlcmF0ZXMgb3ZlciBTcGFyc2VNYXRyaXggQSBhbmQgU3BhcnNlTWF0cml4IEIgbm9uemVybyBpdGVtcyBhbmQgaW52b2tlcyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gZihBaWosIEJpaikuIFxuICAgKiBDYWxsYmFjayBmdW5jdGlvbiBpbnZva2VkIChBbnogVSBCbnopIHRpbWVzLCB3aGVyZSBBbnogYW5kIEJueiBhcmUgdGhlIG5vbnplcm8gZWxlbWVudHMgaW4gYm90aCBtYXRyaWNlcy5cbiAgICpcbiAgICpcbiAgICogICAgICAgICAg4pSMICBmKEFpaiwgQmlqKSAgOyBBKGksaikgIT09IDAgJiYgQihpLGopICE9PSAwXG4gICAqIEMoaSxqKSA9IOKUpCAgXG4gICAqICAgICAgICAgIOKUlCAgMCAgICAgICAgICAgIDsgb3RoZXJ3aXNlXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSB7TWF0cml4fSAgIGEgICAgICAgICAgICAgICAgIFRoZSBTcGFyc2VNYXRyaXggaW5zdGFuY2UgKEEpXG4gICAqIEBwYXJhbSB7TWF0cml4fSAgIGIgICAgICAgICAgICAgICAgIFRoZSBTcGFyc2VNYXRyaXggaW5zdGFuY2UgKEIpXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrICAgICAgICAgIFRoZSBmKEFpaixCaWopIG9wZXJhdGlvbiB0byBpbnZva2VcbiAgICpcbiAgICogQHJldHVybiB7TWF0cml4fSAgICAgICAgICAgICAgICAgICAgU3BhcnNlTWF0cml4IChDKVxuICAgKlxuICAgKiBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2pvc2Rlam9uZy9tYXRoanMvcHVsbC8zNDYjaXNzdWVjb21tZW50LTk3NjIwMjk0XG4gICAqL1xuICB2YXIgYWxnb3JpdGhtMDYgPSBmdW5jdGlvbiAoYSwgYiwgY2FsbGJhY2spIHtcbiAgICAvLyBzcGFyc2UgbWF0cml4IGFycmF5c1xuICAgIHZhciBhdmFsdWVzID0gYS5fdmFsdWVzO1xuICAgIHZhciBhc2l6ZSA9IGEuX3NpemU7XG4gICAgdmFyIGFkdCA9IGEuX2RhdGF0eXBlO1xuICAgIC8vIHNwYXJzZSBtYXRyaXggYXJyYXlzXG4gICAgdmFyIGJ2YWx1ZXMgPSBiLl92YWx1ZXM7XG4gICAgdmFyIGJzaXplID0gYi5fc2l6ZTtcbiAgICB2YXIgYmR0ID0gYi5fZGF0YXR5cGU7XG5cbiAgICAvLyB2YWxpZGF0ZSBkaW1lbnNpb25zXG4gICAgaWYgKGFzaXplLmxlbmd0aCAhPT0gYnNpemUubGVuZ3RoKVxuICAgICAgdGhyb3cgbmV3IERpbWVuc2lvbkVycm9yKGFzaXplLmxlbmd0aCwgYnNpemUubGVuZ3RoKTtcblxuICAgIC8vIGNoZWNrIHJvd3MgJiBjb2x1bW5zXG4gICAgaWYgKGFzaXplWzBdICE9PSBic2l6ZVswXSB8fCBhc2l6ZVsxXSAhPT0gYnNpemVbMV0pXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignRGltZW5zaW9uIG1pc21hdGNoLiBNYXRyaXggQSAoJyArIGFzaXplICsgJykgbXVzdCBtYXRjaCBNYXRyaXggQiAoJyArIGJzaXplICsgJyknKTtcblxuICAgIC8vIHJvd3MgJiBjb2x1bW5zXG4gICAgdmFyIHJvd3MgPSBhc2l6ZVswXTtcbiAgICB2YXIgY29sdW1ucyA9IGFzaXplWzFdO1xuXG4gICAgLy8gZGF0YXR5cGVcbiAgICB2YXIgZHQ7XG4gICAgLy8gZXF1YWwgc2lnbmF0dXJlIHRvIHVzZVxuICAgIHZhciBlcSA9IGVxdWFsU2NhbGFyO1xuICAgIC8vIHplcm8gdmFsdWVcbiAgICB2YXIgemVybyA9IDA7XG4gICAgLy8gY2FsbGJhY2sgc2lnbmF0dXJlIHRvIHVzZVxuICAgIHZhciBjZiA9IGNhbGxiYWNrO1xuXG4gICAgLy8gcHJvY2VzcyBkYXRhIHR5cGVzXG4gICAgaWYgKHR5cGVvZiBhZHQgPT09ICdzdHJpbmcnICYmIGFkdCA9PT0gYmR0KSB7XG4gICAgICAvLyBkYXRhdHlwZVxuICAgICAgZHQgPSBhZHQ7XG4gICAgICAvLyBmaW5kIHNpZ25hdHVyZSB0aGF0IG1hdGNoZXMgKGR0LCBkdClcbiAgICAgIGVxID0gdHlwZWQuZmluZChlcXVhbFNjYWxhciwgW2R0LCBkdF0pO1xuICAgICAgLy8gY29udmVydCAwIHRvIHRoZSBzYW1lIGRhdGF0eXBlXG4gICAgICB6ZXJvID0gdHlwZWQuY29udmVydCgwLCBkdCk7XG4gICAgICAvLyBjYWxsYmFja1xuICAgICAgY2YgPSB0eXBlZC5maW5kKGNhbGxiYWNrLCBbZHQsIGR0XSk7XG4gICAgfVxuXG4gICAgLy8gcmVzdWx0IGFycmF5c1xuICAgIHZhciBjdmFsdWVzID0gYXZhbHVlcyAmJiBidmFsdWVzID8gW10gOiB1bmRlZmluZWQ7XG4gICAgdmFyIGNpbmRleCA9IFtdO1xuICAgIHZhciBjcHRyID0gW107XG4gICAgLy8gbWF0cml4XG4gICAgdmFyIGMgPSBuZXcgU3BhcnNlTWF0cml4KHtcbiAgICAgIHZhbHVlczogY3ZhbHVlcyxcbiAgICAgIGluZGV4OiBjaW5kZXgsXG4gICAgICBwdHI6IGNwdHIsXG4gICAgICBzaXplOiBbcm93cywgY29sdW1uc10sXG4gICAgICBkYXRhdHlwZTogZHRcbiAgICB9KTtcblxuICAgIC8vIHdvcmtzcGFjZXNcbiAgICB2YXIgeCA9IGN2YWx1ZXMgPyBbXSA6IHVuZGVmaW5lZDtcbiAgICAvLyBtYXJrcyBpbmRpY2F0aW5nIHdlIGhhdmUgYSB2YWx1ZSBpbiB4IGZvciBhIGdpdmVuIGNvbHVtblxuICAgIHZhciB3ID0gW107XG4gICAgLy8gbWFya3MgaW5kaWNhdGluZyB2YWx1ZSBpbiBhIGdpdmVuIHJvdyBoYXMgYmVlbiB1cGRhdGVkXG4gICAgdmFyIHUgPSBbXTtcblxuICAgIC8vIGxvb3AgY29sdW1uc1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29sdW1uczsgaisrKSB7XG4gICAgICAvLyB1cGRhdGUgY3B0clxuICAgICAgY3B0cltqXSA9IGNpbmRleC5sZW5ndGg7XG4gICAgICAvLyBjb2x1bW5zIG1hcmtcbiAgICAgIHZhciBtYXJrID0gaiArIDE7XG4gICAgICAvLyBzY2F0dGVyIHRoZSB2YWx1ZXMgb2YgQSg6LGopIGludG8gd29ya3NwYWNlXG4gICAgICBzY2F0dGVyKGEsIGosIHcsIHgsIHUsIG1hcmssIGMsIGNmKTtcbiAgICAgIC8vIHNjYXR0ZXIgdGhlIHZhbHVlcyBvZiBCKDosaikgaW50byB3b3Jrc3BhY2VcbiAgICAgIHNjYXR0ZXIoYiwgaiwgdywgeCwgdSwgbWFyaywgYywgY2YpO1xuICAgICAgLy8gY2hlY2sgd2UgbmVlZCB0byBwcm9jZXNzIHZhbHVlcyAobm9uIHBhdHRlcm4gbWF0cml4KVxuICAgICAgaWYgKHgpIHtcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBmaXJzdCBpbmRleCBpbiBqXG4gICAgICAgIHZhciBrID0gY3B0cltqXTtcbiAgICAgICAgLy8gbG9vcCBpbmRleCBpbiBqXG4gICAgICAgIHdoaWxlIChrIDwgY2luZGV4Lmxlbmd0aCkge1xuICAgICAgICAgIC8vIHJvd1xuICAgICAgICAgIHZhciBpID0gY2luZGV4W2tdO1xuICAgICAgICAgIC8vIGNoZWNrIGZ1bmN0aW9uIHdhcyBpbnZva2VkIG9uIGN1cnJlbnQgcm93IChBaWogIT0wICYmIEJpaiAhPSAwKVxuICAgICAgICAgIGlmICh1W2ldID09PSBtYXJrKSB7XG4gICAgICAgICAgICAvLyB2YWx1ZSBAIGlcbiAgICAgICAgICAgIHZhciB2ID0geFtpXTtcbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciB6ZXJvIHZhbHVlXG4gICAgICAgICAgICBpZiAoIWVxKHYsIHplcm8pKSB7XG4gICAgICAgICAgICAgIC8vIHB1c2ggdmFsdWVcbiAgICAgICAgICAgICAgY3ZhbHVlcy5wdXNoKHYpO1xuICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgcG9pbnRlclxuICAgICAgICAgICAgICBrKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gcmVtb3ZlIHZhbHVlIEAgaSwgZG8gbm90IGluY3JlbWVudCBwb2ludGVyXG4gICAgICAgICAgICAgIGNpbmRleC5zcGxpY2UoaywgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHZhbHVlIEAgaSwgZG8gbm90IGluY3JlbWVudCBwb2ludGVyXG4gICAgICAgICAgICBjaW5kZXguc3BsaWNlKGssIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIGluaXRpYWxpemUgZmlyc3QgaW5kZXggaW4galxuICAgICAgICB2YXIgcCA9IGNwdHJbal07XG4gICAgICAgIC8vIGxvb3AgaW5kZXggaW4galxuICAgICAgICB3aGlsZSAocCA8IGNpbmRleC5sZW5ndGgpIHtcbiAgICAgICAgICAvLyByb3dcbiAgICAgICAgICB2YXIgciA9IGNpbmRleFtwXTtcbiAgICAgICAgICAvLyBjaGVjayBmdW5jdGlvbiB3YXMgaW52b2tlZCBvbiBjdXJyZW50IHJvdyAoQWlqICE9MCAmJiBCaWogIT0gMClcbiAgICAgICAgICBpZiAodVtyXSAhPT0gbWFyaykge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHZhbHVlIEAgaSwgZG8gbm90IGluY3JlbWVudCBwb2ludGVyXG4gICAgICAgICAgICBjaW5kZXguc3BsaWNlKHAsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGluY3JlbWVudCBwb2ludGVyXG4gICAgICAgICAgICBwKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVwZGF0ZSBjcHRyXG4gICAgY3B0cltjb2x1bW5zXSA9IGNpbmRleC5sZW5ndGg7XG5cbiAgICAvLyByZXR1cm4gc3BhcnNlIG1hdHJpeFxuICAgIHJldHVybiBjO1xuICB9O1xuICBcbiAgcmV0dXJuIGFsZ29yaXRobTA2O1xufVxuXG5leHBvcnRzLm5hbWUgPSAnYWxnb3JpdGhtMDYnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIERpbWVuc2lvbkVycm9yID0gcmVxdWlyZSgnLi4vLi4vLi4vZXJyb3IvRGltZW5zaW9uRXJyb3InKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuXG4gIHZhciBEZW5zZU1hdHJpeCA9IHR5cGUuRGVuc2VNYXRyaXg7XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGVzIG92ZXIgU3BhcnNlTWF0cml4IEEgYW5kIFNwYXJzZU1hdHJpeCBCIGl0ZW1zICh6ZXJvIGFuZCBub256ZXJvKSBhbmQgaW52b2tlcyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gZihBaWosIEJpaikuIFxuICAgKiBDYWxsYmFjayBmdW5jdGlvbiBpbnZva2VkIE14TiB0aW1lcy5cbiAgICpcbiAgICogQyhpLGopID0gZihBaWosIEJpailcbiAgICpcbiAgICogQHBhcmFtIHtNYXRyaXh9ICAgYSAgICAgICAgICAgICAgICAgVGhlIFNwYXJzZU1hdHJpeCBpbnN0YW5jZSAoQSlcbiAgICogQHBhcmFtIHtNYXRyaXh9ICAgYiAgICAgICAgICAgICAgICAgVGhlIFNwYXJzZU1hdHJpeCBpbnN0YW5jZSAoQilcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgICAgICAgICAgVGhlIGYoQWlqLEJpaikgb3BlcmF0aW9uIHRvIGludm9rZVxuICAgKlxuICAgKiBAcmV0dXJuIHtNYXRyaXh9ICAgICAgICAgICAgICAgICAgICBEZW5zZU1hdHJpeCAoQylcbiAgICpcbiAgICogc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qb3NkZWpvbmcvbWF0aGpzL3B1bGwvMzQ2I2lzc3VlY29tbWVudC05NzYyMDI5NFxuICAgKi9cbiAgdmFyIGFsZ29yaXRobTA3ID0gZnVuY3Rpb24gKGEsIGIsIGNhbGxiYWNrKSB7XG4gICAgLy8gc3BhcnNlIG1hdHJpeCBhcnJheXNcbiAgICB2YXIgYXNpemUgPSBhLl9zaXplO1xuICAgIHZhciBhZHQgPSBhLl9kYXRhdHlwZTtcbiAgICAvLyBzcGFyc2UgbWF0cml4IGFycmF5c1xuICAgIHZhciBic2l6ZSA9IGIuX3NpemU7XG4gICAgdmFyIGJkdCA9IGIuX2RhdGF0eXBlO1xuXG4gICAgLy8gdmFsaWRhdGUgZGltZW5zaW9uc1xuICAgIGlmIChhc2l6ZS5sZW5ndGggIT09IGJzaXplLmxlbmd0aClcbiAgICAgIHRocm93IG5ldyBEaW1lbnNpb25FcnJvcihhc2l6ZS5sZW5ndGgsIGJzaXplLmxlbmd0aCk7XG5cbiAgICAvLyBjaGVjayByb3dzICYgY29sdW1uc1xuICAgIGlmIChhc2l6ZVswXSAhPT0gYnNpemVbMF0gfHwgYXNpemVbMV0gIT09IGJzaXplWzFdKVxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0RpbWVuc2lvbiBtaXNtYXRjaC4gTWF0cml4IEEgKCcgKyBhc2l6ZSArICcpIG11c3QgbWF0Y2ggTWF0cml4IEIgKCcgKyBic2l6ZSArICcpJyk7XG5cbiAgICAvLyByb3dzICYgY29sdW1uc1xuICAgIHZhciByb3dzID0gYXNpemVbMF07XG4gICAgdmFyIGNvbHVtbnMgPSBhc2l6ZVsxXTtcblxuICAgIC8vIGRhdGF0eXBlXG4gICAgdmFyIGR0O1xuICAgIC8vIHplcm8gdmFsdWVcbiAgICB2YXIgemVybyA9IDA7XG4gICAgLy8gY2FsbGJhY2sgc2lnbmF0dXJlIHRvIHVzZVxuICAgIHZhciBjZiA9IGNhbGxiYWNrO1xuXG4gICAgLy8gcHJvY2VzcyBkYXRhIHR5cGVzXG4gICAgaWYgKHR5cGVvZiBhZHQgPT09ICdzdHJpbmcnICYmIGFkdCA9PT0gYmR0KSB7XG4gICAgICAvLyBkYXRhdHlwZVxuICAgICAgZHQgPSBhZHQ7XG4gICAgICAvLyBjb252ZXJ0IDAgdG8gdGhlIHNhbWUgZGF0YXR5cGVcbiAgICAgIHplcm8gPSB0eXBlZC5jb252ZXJ0KDAsIGR0KTtcbiAgICAgIC8vIGNhbGxiYWNrXG4gICAgICBjZiA9IHR5cGVkLmZpbmQoY2FsbGJhY2ssIFtkdCwgZHRdKTtcbiAgICB9XG5cbiAgICAvLyB2YXJzXG4gICAgdmFyIGksIGo7XG4gICAgXG4gICAgLy8gcmVzdWx0IGFycmF5c1xuICAgIHZhciBjZGF0YSA9IFtdO1xuICAgIC8vIGluaXRpYWxpemUgY1xuICAgIGZvciAoaSA9IDA7IGkgPCByb3dzOyBpKyspXG4gICAgICBjZGF0YVtpXSA9IFtdO1xuXG4gICAgLy8gbWF0cml4XG4gICAgdmFyIGMgPSBuZXcgRGVuc2VNYXRyaXgoe1xuICAgICAgZGF0YTogY2RhdGEsXG4gICAgICBzaXplOiBbcm93cywgY29sdW1uc10sXG4gICAgICBkYXRhdHlwZTogZHRcbiAgICB9KTtcblxuICAgIC8vIHdvcmtzcGFjZXNcbiAgICB2YXIgeGEgPSBbXTtcbiAgICB2YXIgeGIgPSBbXTtcbiAgICAvLyBtYXJrcyBpbmRpY2F0aW5nIHdlIGhhdmUgYSB2YWx1ZSBpbiB4IGZvciBhIGdpdmVuIGNvbHVtblxuICAgIHZhciB3YSA9IFtdO1xuICAgIHZhciB3YiA9IFtdO1xuXG4gICAgLy8gbG9vcCBjb2x1bW5zXG4gICAgZm9yIChqID0gMDsgaiA8IGNvbHVtbnM7IGorKykge1xuICAgICAgLy8gY29sdW1ucyBtYXJrXG4gICAgICB2YXIgbWFyayA9IGogKyAxO1xuICAgICAgLy8gc2NhdHRlciB0aGUgdmFsdWVzIG9mIEEoOixqKSBpbnRvIHdvcmtzcGFjZVxuICAgICAgX3NjYXR0ZXIoYSwgaiwgd2EsIHhhLCBtYXJrKTtcbiAgICAgIC8vIHNjYXR0ZXIgdGhlIHZhbHVlcyBvZiBCKDosaikgaW50byB3b3Jrc3BhY2VcbiAgICAgIF9zY2F0dGVyKGIsIGosIHdiLCB4YiwgbWFyayk7XG4gICAgICAvLyBsb29wIHJvd3NcbiAgICAgIGZvciAoaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgICAgLy8gbWF0cml4IHZhbHVlcyBAIGksalxuICAgICAgICB2YXIgdmEgPSB3YVtpXSA9PT0gbWFyayA/IHhhW2ldIDogemVybztcbiAgICAgICAgdmFyIHZiID0gd2JbaV0gPT09IG1hcmsgPyB4YltpXSA6IHplcm87XG4gICAgICAgIC8vIGludm9rZSBjYWxsYmFja1xuICAgICAgICBjZGF0YVtpXVtqXSA9IGNmKHZhLCB2Yik7XG4gICAgICB9ICAgICAgICAgIFxuICAgIH1cblxuICAgIC8vIHJldHVybiBzcGFyc2UgbWF0cml4XG4gICAgcmV0dXJuIGM7XG4gIH07XG4gIFxuICB2YXIgX3NjYXR0ZXIgPSBmdW5jdGlvbiAobSwgaiwgdywgeCwgbWFyaykge1xuICAgIC8vIGEgYXJyYXlzXG4gICAgdmFyIHZhbHVlcyA9IG0uX3ZhbHVlcztcbiAgICB2YXIgaW5kZXggPSBtLl9pbmRleDtcbiAgICB2YXIgcHRyID0gbS5fcHRyO1xuICAgIC8vIGxvb3AgdmFsdWVzIGluIGNvbHVtbiBqXG4gICAgZm9yICh2YXIgayA9IHB0cltqXSwgazEgPSBwdHJbaiArIDFdOyBrIDwgazE7IGsrKykge1xuICAgICAgLy8gcm93XG4gICAgICB2YXIgaSA9IGluZGV4W2tdO1xuICAgICAgLy8gdXBkYXRlIHdvcmtzcGFjZVxuICAgICAgd1tpXSA9IG1hcms7XG4gICAgICB4W2ldID0gdmFsdWVzW2tdO1xuICAgIH1cbiAgfTtcbiAgXG4gIHJldHVybiBhbGdvcml0aG0wNztcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2FsZ29yaXRobTA3JztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBEaW1lbnNpb25FcnJvciA9IHJlcXVpcmUoJy4uLy4uLy4uL2Vycm9yL0RpbWVuc2lvbkVycm9yJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcblxuICB2YXIgZXF1YWxTY2FsYXIgPSBsb2FkKHJlcXVpcmUoJy4uLy4uLy4uL2Z1bmN0aW9uL3JlbGF0aW9uYWwvZXF1YWxTY2FsYXInKSk7XG5cbiAgdmFyIFNwYXJzZU1hdHJpeCA9IHR5cGUuU3BhcnNlTWF0cml4O1xuXG4gIC8qKlxuICAgKiBJdGVyYXRlcyBvdmVyIFNwYXJzZU1hdHJpeCBBIGFuZCBTcGFyc2VNYXRyaXggQiBub256ZXJvIGl0ZW1zIGFuZCBpbnZva2VzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBmKEFpaiwgQmlqKS4gXG4gICAqIENhbGxiYWNrIGZ1bmN0aW9uIGludm9rZWQgTUFYKE5OWkEsIE5OWkIpIHRpbWVzXG4gICAqXG4gICAqXG4gICAqICAgICAgICAgIOKUjCAgZihBaWosIEJpaikgIDsgQShpLGopICE9PSAwICYmIEIoaSxqKSAhPT0gMFxuICAgKiBDKGksaikgPSDilKQgIEEoaSxqKSAgICAgICA7IEEoaSxqKSAhPT0gMFxuICAgKiAgICAgICAgICDilJQgIDAgICAgICAgICAgICA7IG90aGVyd2lzZVxuICAgKlxuICAgKlxuICAgKiBAcGFyYW0ge01hdHJpeH0gICBhICAgICAgICAgICAgICAgICBUaGUgU3BhcnNlTWF0cml4IGluc3RhbmNlIChBKVxuICAgKiBAcGFyYW0ge01hdHJpeH0gICBiICAgICAgICAgICAgICAgICBUaGUgU3BhcnNlTWF0cml4IGluc3RhbmNlIChCKVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAgICAgICAgICBUaGUgZihBaWosQmlqKSBvcGVyYXRpb24gdG8gaW52b2tlXG4gICAqXG4gICAqIEByZXR1cm4ge01hdHJpeH0gICAgICAgICAgICAgICAgICAgIFNwYXJzZU1hdHJpeCAoQylcbiAgICpcbiAgICogc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qb3NkZWpvbmcvbWF0aGpzL3B1bGwvMzQ2I2lzc3VlY29tbWVudC05NzYyMDI5NFxuICAgKi9cbiAgdmFyIGFsZ29yaXRobTA4ID0gZnVuY3Rpb24gKGEsIGIsIGNhbGxiYWNrKSB7XG4gICAgLy8gc3BhcnNlIG1hdHJpeCBhcnJheXNcbiAgICB2YXIgYXZhbHVlcyA9IGEuX3ZhbHVlcztcbiAgICB2YXIgYWluZGV4ID0gYS5faW5kZXg7XG4gICAgdmFyIGFwdHIgPSBhLl9wdHI7XG4gICAgdmFyIGFzaXplID0gYS5fc2l6ZTtcbiAgICB2YXIgYWR0ID0gYS5fZGF0YXR5cGU7XG4gICAgLy8gc3BhcnNlIG1hdHJpeCBhcnJheXNcbiAgICB2YXIgYnZhbHVlcyA9IGIuX3ZhbHVlcztcbiAgICB2YXIgYmluZGV4ID0gYi5faW5kZXg7XG4gICAgdmFyIGJwdHIgPSBiLl9wdHI7XG4gICAgdmFyIGJzaXplID0gYi5fc2l6ZTtcbiAgICB2YXIgYmR0ID0gYi5fZGF0YXR5cGU7XG5cbiAgICAvLyB2YWxpZGF0ZSBkaW1lbnNpb25zXG4gICAgaWYgKGFzaXplLmxlbmd0aCAhPT0gYnNpemUubGVuZ3RoKVxuICAgICAgdGhyb3cgbmV3IERpbWVuc2lvbkVycm9yKGFzaXplLmxlbmd0aCwgYnNpemUubGVuZ3RoKTtcblxuICAgIC8vIGNoZWNrIHJvd3MgJiBjb2x1bW5zXG4gICAgaWYgKGFzaXplWzBdICE9PSBic2l6ZVswXSB8fCBhc2l6ZVsxXSAhPT0gYnNpemVbMV0pXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignRGltZW5zaW9uIG1pc21hdGNoLiBNYXRyaXggQSAoJyArIGFzaXplICsgJykgbXVzdCBtYXRjaCBNYXRyaXggQiAoJyArIGJzaXplICsgJyknKTtcblxuICAgIC8vIHNwYXJzZSBtYXRyaXggY2Fubm90IGJlIGEgUGF0dGVybiBtYXRyaXhcbiAgICBpZiAoIWF2YWx1ZXMgfHwgIWJ2YWx1ZXMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBwZXJmb3JtIG9wZXJhdGlvbiBvbiBQYXR0ZXJuIFNwYXJzZSBNYXRyaWNlcycpO1xuXG4gICAgLy8gcm93cyAmIGNvbHVtbnNcbiAgICB2YXIgcm93cyA9IGFzaXplWzBdO1xuICAgIHZhciBjb2x1bW5zID0gYXNpemVbMV07XG5cbiAgICAvLyBkYXRhdHlwZVxuICAgIHZhciBkdDtcbiAgICAvLyBlcXVhbCBzaWduYXR1cmUgdG8gdXNlXG4gICAgdmFyIGVxID0gZXF1YWxTY2FsYXI7XG4gICAgLy8gemVybyB2YWx1ZVxuICAgIHZhciB6ZXJvID0gMDtcbiAgICAvLyBjYWxsYmFjayBzaWduYXR1cmUgdG8gdXNlXG4gICAgdmFyIGNmID0gY2FsbGJhY2s7XG5cbiAgICAvLyBwcm9jZXNzIGRhdGEgdHlwZXNcbiAgICBpZiAodHlwZW9mIGFkdCA9PT0gJ3N0cmluZycgJiYgYWR0ID09PSBiZHQpIHtcbiAgICAgIC8vIGRhdGF0eXBlXG4gICAgICBkdCA9IGFkdDtcbiAgICAgIC8vIGZpbmQgc2lnbmF0dXJlIHRoYXQgbWF0Y2hlcyAoZHQsIGR0KVxuICAgICAgZXEgPSB0eXBlZC5maW5kKGVxdWFsU2NhbGFyLCBbZHQsIGR0XSk7XG4gICAgICAvLyBjb252ZXJ0IDAgdG8gdGhlIHNhbWUgZGF0YXR5cGVcbiAgICAgIHplcm8gPSB0eXBlZC5jb252ZXJ0KDAsIGR0KTtcbiAgICAgIC8vIGNhbGxiYWNrXG4gICAgICBjZiA9IHR5cGVkLmZpbmQoY2FsbGJhY2ssIFtkdCwgZHRdKTtcbiAgICB9XG5cbiAgICAvLyByZXN1bHQgYXJyYXlzXG4gICAgdmFyIGN2YWx1ZXMgPSBbXTtcbiAgICB2YXIgY2luZGV4ID0gW107XG4gICAgdmFyIGNwdHIgPSBbXTtcbiAgICAvLyBtYXRyaXhcbiAgICB2YXIgYyA9IG5ldyBTcGFyc2VNYXRyaXgoe1xuICAgICAgdmFsdWVzOiBjdmFsdWVzLFxuICAgICAgaW5kZXg6IGNpbmRleCxcbiAgICAgIHB0cjogY3B0cixcbiAgICAgIHNpemU6IFtyb3dzLCBjb2x1bW5zXSxcbiAgICAgIGRhdGF0eXBlOiBkdFxuICAgIH0pO1xuXG4gICAgLy8gd29ya3NwYWNlXG4gICAgdmFyIHggPSBbXTtcbiAgICAvLyBtYXJrcyBpbmRpY2F0aW5nIHdlIGhhdmUgYSB2YWx1ZSBpbiB4IGZvciBhIGdpdmVuIGNvbHVtblxuICAgIHZhciB3ID0gW107XG5cbiAgICAvLyB2YXJzXG4gICAgdmFyIGssIGswLCBrMSwgaTtcblxuICAgIC8vIGxvb3AgY29sdW1uc1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29sdW1uczsgaisrKSB7XG4gICAgICAvLyB1cGRhdGUgY3B0clxuICAgICAgY3B0cltqXSA9IGNpbmRleC5sZW5ndGg7XG4gICAgICAvLyBjb2x1bW5zIG1hcmtcbiAgICAgIHZhciBtYXJrID0gaiArIDE7XG4gICAgICAvLyBsb29wIHZhbHVlcyBpbiBhXG4gICAgICBmb3IgKGswID0gYXB0cltqXSwgazEgPSBhcHRyW2ogKyAxXSwgayA9IGswOyBrIDwgazE7IGsrKykge1xuICAgICAgICAvLyByb3dcbiAgICAgICAgaSA9IGFpbmRleFtrXTtcbiAgICAgICAgLy8gbWFyayB3b3Jrc3BhY2VcbiAgICAgICAgd1tpXSA9IG1hcms7XG4gICAgICAgIC8vIHNldCB2YWx1ZVxuICAgICAgICB4W2ldID0gYXZhbHVlc1trXTtcbiAgICAgICAgLy8gYWRkIGluZGV4XG4gICAgICAgIGNpbmRleC5wdXNoKGkpO1xuICAgICAgfVxuICAgICAgLy8gbG9vcCB2YWx1ZXMgaW4gYlxuICAgICAgZm9yIChrMCA9IGJwdHJbal0sIGsxID0gYnB0cltqICsgMV0sIGsgPSBrMDsgayA8IGsxOyBrKyspIHtcbiAgICAgICAgLy8gcm93XG4gICAgICAgIGkgPSBiaW5kZXhba107XG4gICAgICAgIC8vIGNoZWNrIHZhbHVlIGV4aXN0cyBpbiB3b3Jrc3BhY2VcbiAgICAgICAgaWYgKHdbaV0gPT09IG1hcmspIHtcbiAgICAgICAgICAvLyBldmFsdWF0ZSBjYWxsYmFja1xuICAgICAgICAgIHhbaV0gPSBjZih4W2ldLCBidmFsdWVzW2tdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gaW5pdGlhbGl6ZSBmaXJzdCBpbmRleCBpbiBqXG4gICAgICBrID0gY3B0cltqXTtcbiAgICAgIC8vIGxvb3AgaW5kZXggaW4galxuICAgICAgd2hpbGUgKGsgPCBjaW5kZXgubGVuZ3RoKSB7XG4gICAgICAgIC8vIHJvd1xuICAgICAgICBpID0gY2luZGV4W2tdO1xuICAgICAgICAvLyB2YWx1ZSBAIGlcbiAgICAgICAgdmFyIHYgPSB4W2ldO1xuICAgICAgICAvLyBjaGVjayBmb3IgemVybyB2YWx1ZVxuICAgICAgICBpZiAoIWVxKHYsIHplcm8pKSB7XG4gICAgICAgICAgLy8gcHVzaCB2YWx1ZVxuICAgICAgICAgIGN2YWx1ZXMucHVzaCh2KTtcbiAgICAgICAgICAvLyBpbmNyZW1lbnQgcG9pbnRlclxuICAgICAgICAgIGsrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyByZW1vdmUgdmFsdWUgQCBpLCBkbyBub3QgaW5jcmVtZW50IHBvaW50ZXJcbiAgICAgICAgICBjaW5kZXguc3BsaWNlKGssIDEpO1xuICAgICAgICB9XG4gICAgICB9ICAgICAgXG4gICAgfVxuICAgIC8vIHVwZGF0ZSBjcHRyXG4gICAgY3B0cltjb2x1bW5zXSA9IGNpbmRleC5sZW5ndGg7XG5cbiAgICAvLyByZXR1cm4gc3BhcnNlIG1hdHJpeFxuICAgIHJldHVybiBjO1xuICB9O1xuXG4gIHJldHVybiBhbGdvcml0aG0wODtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2FsZ29yaXRobTA4JztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBEaW1lbnNpb25FcnJvciA9IHJlcXVpcmUoJy4uLy4uLy4uL2Vycm9yL0RpbWVuc2lvbkVycm9yJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcblxuICB2YXIgZXF1YWxTY2FsYXIgPSBsb2FkKHJlcXVpcmUoJy4uLy4uLy4uL2Z1bmN0aW9uL3JlbGF0aW9uYWwvZXF1YWxTY2FsYXInKSk7XG5cbiAgdmFyIFNwYXJzZU1hdHJpeCA9IHR5cGUuU3BhcnNlTWF0cml4O1xuXG4gIC8qKlxuICAgKiBJdGVyYXRlcyBvdmVyIFNwYXJzZU1hdHJpeCBBIGFuZCBpbnZva2VzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBmKEFpaiwgQmlqKS4gXG4gICAqIENhbGxiYWNrIGZ1bmN0aW9uIGludm9rZWQgTlpBIHRpbWVzLCBudW1iZXIgb2Ygbm9uemVybyBlbGVtZW50cyBpbiBBLlxuICAgKlxuICAgKlxuICAgKiAgICAgICAgICDilIwgIGYoQWlqLCBCaWopICA7IEEoaSxqKSAhPT0gMFxuICAgKiBDKGksaikgPSDilKQgIFxuICAgKiAgICAgICAgICDilJQgIDAgICAgICAgICAgICA7IG90aGVyd2lzZVxuICAgKlxuICAgKlxuICAgKiBAcGFyYW0ge01hdHJpeH0gICBhICAgICAgICAgICAgICAgICBUaGUgU3BhcnNlTWF0cml4IGluc3RhbmNlIChBKVxuICAgKiBAcGFyYW0ge01hdHJpeH0gICBiICAgICAgICAgICAgICAgICBUaGUgU3BhcnNlTWF0cml4IGluc3RhbmNlIChCKVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAgICAgICAgICBUaGUgZihBaWosQmlqKSBvcGVyYXRpb24gdG8gaW52b2tlXG4gICAqXG4gICAqIEByZXR1cm4ge01hdHJpeH0gICAgICAgICAgICAgICAgICAgIFNwYXJzZU1hdHJpeCAoQylcbiAgICpcbiAgICogc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qb3NkZWpvbmcvbWF0aGpzL3B1bGwvMzQ2I2lzc3VlY29tbWVudC05NzYyMDI5NFxuICAgKi9cbiAgdmFyIGFsZ29yaXRobTA5ID0gZnVuY3Rpb24gKGEsIGIsIGNhbGxiYWNrKSB7XG4gICAgLy8gc3BhcnNlIG1hdHJpeCBhcnJheXNcbiAgICB2YXIgYXZhbHVlcyA9IGEuX3ZhbHVlcztcbiAgICB2YXIgYWluZGV4ID0gYS5faW5kZXg7XG4gICAgdmFyIGFwdHIgPSBhLl9wdHI7XG4gICAgdmFyIGFzaXplID0gYS5fc2l6ZTtcbiAgICB2YXIgYWR0ID0gYS5fZGF0YXR5cGU7XG4gICAgLy8gc3BhcnNlIG1hdHJpeCBhcnJheXNcbiAgICB2YXIgYnZhbHVlcyA9IGIuX3ZhbHVlcztcbiAgICB2YXIgYmluZGV4ID0gYi5faW5kZXg7XG4gICAgdmFyIGJwdHIgPSBiLl9wdHI7XG4gICAgdmFyIGJzaXplID0gYi5fc2l6ZTtcbiAgICB2YXIgYmR0ID0gYi5fZGF0YXR5cGU7XG5cbiAgICAvLyB2YWxpZGF0ZSBkaW1lbnNpb25zXG4gICAgaWYgKGFzaXplLmxlbmd0aCAhPT0gYnNpemUubGVuZ3RoKVxuICAgICAgdGhyb3cgbmV3IERpbWVuc2lvbkVycm9yKGFzaXplLmxlbmd0aCwgYnNpemUubGVuZ3RoKTtcblxuICAgIC8vIGNoZWNrIHJvd3MgJiBjb2x1bW5zXG4gICAgaWYgKGFzaXplWzBdICE9PSBic2l6ZVswXSB8fCBhc2l6ZVsxXSAhPT0gYnNpemVbMV0pXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignRGltZW5zaW9uIG1pc21hdGNoLiBNYXRyaXggQSAoJyArIGFzaXplICsgJykgbXVzdCBtYXRjaCBNYXRyaXggQiAoJyArIGJzaXplICsgJyknKTtcblxuICAgIC8vIHJvd3MgJiBjb2x1bW5zXG4gICAgdmFyIHJvd3MgPSBhc2l6ZVswXTtcbiAgICB2YXIgY29sdW1ucyA9IGFzaXplWzFdO1xuXG4gICAgLy8gZGF0YXR5cGVcbiAgICB2YXIgZHQ7XG4gICAgLy8gZXF1YWwgc2lnbmF0dXJlIHRvIHVzZVxuICAgIHZhciBlcSA9IGVxdWFsU2NhbGFyO1xuICAgIC8vIHplcm8gdmFsdWVcbiAgICB2YXIgemVybyA9IDA7XG4gICAgLy8gY2FsbGJhY2sgc2lnbmF0dXJlIHRvIHVzZVxuICAgIHZhciBjZiA9IGNhbGxiYWNrO1xuXG4gICAgLy8gcHJvY2VzcyBkYXRhIHR5cGVzXG4gICAgaWYgKHR5cGVvZiBhZHQgPT09ICdzdHJpbmcnICYmIGFkdCA9PT0gYmR0KSB7XG4gICAgICAvLyBkYXRhdHlwZVxuICAgICAgZHQgPSBhZHQ7XG4gICAgICAvLyBmaW5kIHNpZ25hdHVyZSB0aGF0IG1hdGNoZXMgKGR0LCBkdClcbiAgICAgIGVxID0gdHlwZWQuZmluZChlcXVhbFNjYWxhciwgW2R0LCBkdF0pO1xuICAgICAgLy8gY29udmVydCAwIHRvIHRoZSBzYW1lIGRhdGF0eXBlXG4gICAgICB6ZXJvID0gdHlwZWQuY29udmVydCgwLCBkdCk7XG4gICAgICAvLyBjYWxsYmFja1xuICAgICAgY2YgPSB0eXBlZC5maW5kKGNhbGxiYWNrLCBbZHQsIGR0XSk7XG4gICAgfVxuXG4gICAgLy8gcmVzdWx0IGFycmF5c1xuICAgIHZhciBjdmFsdWVzID0gYXZhbHVlcyAmJiBidmFsdWVzID8gW10gOiB1bmRlZmluZWQ7XG4gICAgdmFyIGNpbmRleCA9IFtdO1xuICAgIHZhciBjcHRyID0gW107XG4gICAgLy8gbWF0cml4XG4gICAgdmFyIGMgPSBuZXcgU3BhcnNlTWF0cml4KHtcbiAgICAgIHZhbHVlczogY3ZhbHVlcyxcbiAgICAgIGluZGV4OiBjaW5kZXgsXG4gICAgICBwdHI6IGNwdHIsXG4gICAgICBzaXplOiBbcm93cywgY29sdW1uc10sXG4gICAgICBkYXRhdHlwZTogZHRcbiAgICB9KTtcblxuICAgIC8vIHdvcmtzcGFjZXNcbiAgICB2YXIgeCA9IGN2YWx1ZXMgPyBbXSA6IHVuZGVmaW5lZDtcbiAgICAvLyBtYXJrcyBpbmRpY2F0aW5nIHdlIGhhdmUgYSB2YWx1ZSBpbiB4IGZvciBhIGdpdmVuIGNvbHVtblxuICAgIHZhciB3ID0gW107XG5cbiAgICAvLyB2YXJzXG4gICAgdmFyIGksIGosIGssIGswLCBrMTtcbiAgICBcbiAgICAvLyBsb29wIGNvbHVtbnNcbiAgICBmb3IgKGogPSAwOyBqIDwgY29sdW1uczsgaisrKSB7XG4gICAgICAvLyB1cGRhdGUgY3B0clxuICAgICAgY3B0cltqXSA9IGNpbmRleC5sZW5ndGg7XG4gICAgICAvLyBjb2x1bW4gbWFya1xuICAgICAgdmFyIG1hcmsgPSBqICsgMTtcbiAgICAgIC8vIGNoZWNrIHdlIG5lZWQgdG8gcHJvY2VzcyB2YWx1ZXNcbiAgICAgIGlmICh4KSB7XG4gICAgICAgIC8vIGxvb3AgQig6LGopXG4gICAgICAgIGZvciAoazAgPSBicHRyW2pdLCBrMSA9IGJwdHJbaiArIDFdLCBrID0gazA7IGsgPCBrMTsgaysrKSB7XG4gICAgICAgICAgLy8gcm93XG4gICAgICAgICAgaSA9IGJpbmRleFtrXTtcbiAgICAgICAgICAvLyB1cGRhdGUgd29ya3NwYWNlXG4gICAgICAgICAgd1tpXSA9IG1hcms7XG4gICAgICAgICAgeFtpXSA9IGJ2YWx1ZXNba107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGxvb3AgQSg6LGopXG4gICAgICBmb3IgKGswID0gYXB0cltqXSwgazEgPSBhcHRyW2ogKyAxXSwgayA9IGswOyBrIDwgazE7IGsrKykge1xuICAgICAgICAvLyByb3dcbiAgICAgICAgaSA9IGFpbmRleFtrXTtcbiAgICAgICAgLy8gY2hlY2sgd2UgbmVlZCB0byBwcm9jZXNzIHZhbHVlc1xuICAgICAgICBpZiAoeCkge1xuICAgICAgICAgIC8vIGIgdmFsdWUgQCBpLGpcbiAgICAgICAgICB2YXIgdmIgPSB3W2ldID09PSBtYXJrID8geFtpXSA6IHplcm87XG4gICAgICAgICAgLy8gaW52b2tlIGZcbiAgICAgICAgICB2YXIgdmMgPSBjZihhdmFsdWVzW2tdLCB2Yik7XG4gICAgICAgICAgLy8gY2hlY2sgemVybyB2YWx1ZVxuICAgICAgICAgIGlmICghZXEodmMsIHplcm8pKSB7XG4gICAgICAgICAgICAvLyBwdXNoIGluZGV4XG4gICAgICAgICAgICBjaW5kZXgucHVzaChpKTtcbiAgICAgICAgICAgIC8vIHB1c2ggdmFsdWVcbiAgICAgICAgICAgIGN2YWx1ZXMucHVzaCh2Yyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIHB1c2ggaW5kZXhcbiAgICAgICAgICBjaW5kZXgucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyB1cGRhdGUgY3B0clxuICAgIGNwdHJbY29sdW1uc10gPSBjaW5kZXgubGVuZ3RoO1xuXG4gICAgLy8gcmV0dXJuIHNwYXJzZSBtYXRyaXhcbiAgICByZXR1cm4gYztcbiAgfTtcblxuICByZXR1cm4gYWxnb3JpdGhtMDk7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdhbGdvcml0aG0wOSc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG5cbiAgdmFyIERlbnNlTWF0cml4ID0gdHlwZS5EZW5zZU1hdHJpeDtcblxuICAvKipcbiAgICogSXRlcmF0ZXMgb3ZlciBTcGFyc2VNYXRyaXggUyBub256ZXJvIGl0ZW1zIGFuZCBpbnZva2VzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBmKFNpaiwgYikuIFxuICAgKiBDYWxsYmFjayBmdW5jdGlvbiBpbnZva2VkIE5aIHRpbWVzIChudW1iZXIgb2Ygbm9uemVybyBpdGVtcyBpbiBTKS5cbiAgICpcbiAgICpcbiAgICogICAgICAgICAg4pSMICBmKFNpaiwgYikgIDsgUyhpLGopICE9PSAwXG4gICAqIEMoaSxqKSA9IOKUpCAgXG4gICAqICAgICAgICAgIOKUlCAgYiAgICAgICAgICA7IG90aGVyd2lzZVxuICAgKlxuICAgKlxuICAgKiBAcGFyYW0ge01hdHJpeH0gICBzICAgICAgICAgICAgICAgICBUaGUgU3BhcnNlTWF0cml4IGluc3RhbmNlIChTKVxuICAgKiBAcGFyYW0ge1NjYWxhcn0gICBiICAgICAgICAgICAgICAgICBUaGUgU2NhbGFyIHZhbHVlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrICAgICAgICAgIFRoZSBmKEFpaixiKSBvcGVyYXRpb24gdG8gaW52b2tlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gIGludmVyc2UgICAgICAgICAgIEEgdHJ1ZSB2YWx1ZSBpbmRpY2F0ZXMgY2FsbGJhY2sgc2hvdWxkIGJlIGludm9rZWQgZihiLFNpailcbiAgICpcbiAgICogQHJldHVybiB7TWF0cml4fSAgICAgICAgICAgICAgICAgICAgRGVuc2VNYXRyaXggKEMpXG4gICAqXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9qb3NkZWpvbmcvbWF0aGpzL3B1bGwvMzQ2I2lzc3VlY29tbWVudC05NzYyNjgxM1xuICAgKi9cbiAgdmFyIGFsZ29yaXRobTEwID0gZnVuY3Rpb24gKHMsIGIsIGNhbGxiYWNrLCBpbnZlcnNlKSB7XG4gICAgLy8gc3BhcnNlIG1hdHJpeCBhcnJheXNcbiAgICB2YXIgYXZhbHVlcyA9IHMuX3ZhbHVlcztcbiAgICB2YXIgYWluZGV4ID0gcy5faW5kZXg7XG4gICAgdmFyIGFwdHIgPSBzLl9wdHI7XG4gICAgdmFyIGFzaXplID0gcy5fc2l6ZTtcbiAgICB2YXIgYWR0ID0gcy5fZGF0YXR5cGU7XG5cbiAgICAvLyBzcGFyc2UgbWF0cml4IGNhbm5vdCBiZSBhIFBhdHRlcm4gbWF0cml4XG4gICAgaWYgKCFhdmFsdWVzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcGVyZm9ybSBvcGVyYXRpb24gb24gUGF0dGVybiBTcGFyc2UgTWF0cml4IGFuZCBTY2FsYXIgdmFsdWUnKTtcblxuICAgIC8vIHJvd3MgJiBjb2x1bW5zXG4gICAgdmFyIHJvd3MgPSBhc2l6ZVswXTtcbiAgICB2YXIgY29sdW1ucyA9IGFzaXplWzFdO1xuXG4gICAgLy8gZGF0YXR5cGVcbiAgICB2YXIgZHQ7XG4gICAgLy8gY2FsbGJhY2sgc2lnbmF0dXJlIHRvIHVzZVxuICAgIHZhciBjZiA9IGNhbGxiYWNrO1xuXG4gICAgLy8gcHJvY2VzcyBkYXRhIHR5cGVzXG4gICAgaWYgKHR5cGVvZiBhZHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBkYXRhdHlwZVxuICAgICAgZHQgPSBhZHQ7XG4gICAgICAvLyBjb252ZXJ0IGIgdG8gdGhlIHNhbWUgZGF0YXR5cGVcbiAgICAgIGIgPSB0eXBlZC5jb252ZXJ0KGIsIGR0KTtcbiAgICAgIC8vIGNhbGxiYWNrXG4gICAgICBjZiA9IHR5cGVkLmZpbmQoY2FsbGJhY2ssIFtkdCwgZHRdKTtcbiAgICB9XG5cbiAgICAvLyByZXN1bHQgYXJyYXlzXG4gICAgdmFyIGNkYXRhID0gW107XG4gICAgLy8gbWF0cml4XG4gICAgdmFyIGMgPSBuZXcgRGVuc2VNYXRyaXgoe1xuICAgICAgZGF0YTogY2RhdGEsXG4gICAgICBzaXplOiBbcm93cywgY29sdW1uc10sXG4gICAgICBkYXRhdHlwZTogZHRcbiAgICB9KTtcblxuICAgIC8vIHdvcmtzcGFjZXNcbiAgICB2YXIgeCA9IFtdO1xuICAgIC8vIG1hcmtzIGluZGljYXRpbmcgd2UgaGF2ZSBhIHZhbHVlIGluIHggZm9yIGEgZ2l2ZW4gY29sdW1uXG4gICAgdmFyIHcgPSBbXTtcblxuICAgIC8vIGxvb3AgY29sdW1uc1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29sdW1uczsgaisrKSB7XG4gICAgICAvLyBjb2x1bW5zIG1hcmtcbiAgICAgIHZhciBtYXJrID0gaiArIDE7XG4gICAgICAvLyB2YWx1ZXMgaW4galxuICAgICAgZm9yICh2YXIgazAgPSBhcHRyW2pdLCBrMSA9IGFwdHJbaiArIDFdLCBrID0gazA7IGsgPCBrMTsgaysrKSB7XG4gICAgICAgIC8vIHJvd1xuICAgICAgICB2YXIgciA9IGFpbmRleFtrXTtcbiAgICAgICAgLy8gdXBkYXRlIHdvcmtzcGFjZVxuICAgICAgICB4W3JdID0gYXZhbHVlc1trXTtcbiAgICAgICAgd1tyXSA9IG1hcms7XG4gICAgICB9XG4gICAgICAvLyBsb29wIHJvd3NcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG4gICAgICAgIC8vIGluaXRpYWxpemUgQyBvbiBmaXJzdCBjb2x1bW5cbiAgICAgICAgaWYgKGogPT09IDApIHtcbiAgICAgICAgICAvLyBjcmVhdGUgcm93IGFycmF5XG4gICAgICAgICAgY2RhdGFbaV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBzcGFyc2UgbWF0cml4IGhhcyBhIHZhbHVlIEAgaSxqXG4gICAgICAgIGlmICh3W2ldID09PSBtYXJrKSB7XG4gICAgICAgICAgLy8gaW52b2tlIGNhbGxiYWNrLCB1cGRhdGUgQ1xuICAgICAgICAgIGNkYXRhW2ldW2pdID0gaW52ZXJzZSA/IGNmKGIsIHhbaV0pIDogY2YoeFtpXSwgYik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgLy8gZGVuc2UgbWF0cml4IHZhbHVlIEAgaSwgalxuICAgICAgICAgIGNkYXRhW2ldW2pdID0gYjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJldHVybiBzcGFyc2UgbWF0cml4XG4gICAgcmV0dXJuIGM7XG4gIH07XG5cbiAgcmV0dXJuIGFsZ29yaXRobTEwO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnYWxnb3JpdGhtMTAnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuXG4gIHZhciBlcXVhbFNjYWxhciA9IGxvYWQocmVxdWlyZSgnLi4vLi4vLi4vZnVuY3Rpb24vcmVsYXRpb25hbC9lcXVhbFNjYWxhcicpKTtcblxuICB2YXIgU3BhcnNlTWF0cml4ID0gdHlwZS5TcGFyc2VNYXRyaXg7XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGVzIG92ZXIgU3BhcnNlTWF0cml4IFMgbm9uemVybyBpdGVtcyBhbmQgaW52b2tlcyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gZihTaWosIGIpLiBcbiAgICogQ2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlZCBOWiB0aW1lcyAobnVtYmVyIG9mIG5vbnplcm8gaXRlbXMgaW4gUykuXG4gICAqXG4gICAqXG4gICAqICAgICAgICAgIOKUjCAgZihTaWosIGIpICA7IFMoaSxqKSAhPT0gMFxuICAgKiBDKGksaikgPSDilKQgIFxuICAgKiAgICAgICAgICDilJQgIDAgICAgICAgICAgOyBvdGhlcndpc2VcbiAgICpcbiAgICpcbiAgICogQHBhcmFtIHtNYXRyaXh9ICAgcyAgICAgICAgICAgICAgICAgVGhlIFNwYXJzZU1hdHJpeCBpbnN0YW5jZSAoUylcbiAgICogQHBhcmFtIHtTY2FsYXJ9ICAgYiAgICAgICAgICAgICAgICAgVGhlIFNjYWxhciB2YWx1ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAgICAgICAgICBUaGUgZihBaWosYikgb3BlcmF0aW9uIHRvIGludm9rZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICBpbnZlcnNlICAgICAgICAgICBBIHRydWUgdmFsdWUgaW5kaWNhdGVzIGNhbGxiYWNrIHNob3VsZCBiZSBpbnZva2VkIGYoYixTaWopXG4gICAqXG4gICAqIEByZXR1cm4ge01hdHJpeH0gICAgICAgICAgICAgICAgICAgIFNwYXJzZU1hdHJpeCAoQylcbiAgICpcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL2pvc2Rlam9uZy9tYXRoanMvcHVsbC8zNDYjaXNzdWVjb21tZW50LTk3NjI2ODEzXG4gICAqL1xuICB2YXIgYWxnb3JpdGhtMTEgPSBmdW5jdGlvbiAocywgYiwgY2FsbGJhY2ssIGludmVyc2UpIHtcbiAgICAvLyBzcGFyc2UgbWF0cml4IGFycmF5c1xuICAgIHZhciBhdmFsdWVzID0gcy5fdmFsdWVzO1xuICAgIHZhciBhaW5kZXggPSBzLl9pbmRleDtcbiAgICB2YXIgYXB0ciA9IHMuX3B0cjtcbiAgICB2YXIgYXNpemUgPSBzLl9zaXplO1xuICAgIHZhciBhZHQgPSBzLl9kYXRhdHlwZTtcblxuICAgIC8vIHNwYXJzZSBtYXRyaXggY2Fubm90IGJlIGEgUGF0dGVybiBtYXRyaXhcbiAgICBpZiAoIWF2YWx1ZXMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBwZXJmb3JtIG9wZXJhdGlvbiBvbiBQYXR0ZXJuIFNwYXJzZSBNYXRyaXggYW5kIFNjYWxhciB2YWx1ZScpO1xuXG4gICAgLy8gcm93cyAmIGNvbHVtbnNcbiAgICB2YXIgcm93cyA9IGFzaXplWzBdO1xuICAgIHZhciBjb2x1bW5zID0gYXNpemVbMV07XG5cbiAgICAvLyBkYXRhdHlwZVxuICAgIHZhciBkdDtcbiAgICAvLyBlcXVhbCBzaWduYXR1cmUgdG8gdXNlXG4gICAgdmFyIGVxID0gZXF1YWxTY2FsYXI7XG4gICAgLy8gemVybyB2YWx1ZVxuICAgIHZhciB6ZXJvID0gMDtcbiAgICAvLyBjYWxsYmFjayBzaWduYXR1cmUgdG8gdXNlXG4gICAgdmFyIGNmID0gY2FsbGJhY2s7XG5cbiAgICAvLyBwcm9jZXNzIGRhdGEgdHlwZXNcbiAgICBpZiAodHlwZW9mIGFkdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIGRhdGF0eXBlXG4gICAgICBkdCA9IGFkdDtcbiAgICAgIC8vIGZpbmQgc2lnbmF0dXJlIHRoYXQgbWF0Y2hlcyAoZHQsIGR0KVxuICAgICAgZXEgPSB0eXBlZC5maW5kKGVxdWFsU2NhbGFyLCBbZHQsIGR0XSk7XG4gICAgICAvLyBjb252ZXJ0IDAgdG8gdGhlIHNhbWUgZGF0YXR5cGVcbiAgICAgIHplcm8gPSB0eXBlZC5jb252ZXJ0KDAsIGR0KTtcbiAgICAgIC8vIGNvbnZlcnQgYiB0byB0aGUgc2FtZSBkYXRhdHlwZVxuICAgICAgYiA9IHR5cGVkLmNvbnZlcnQoYiwgZHQpO1xuICAgICAgLy8gY2FsbGJhY2tcbiAgICAgIGNmID0gdHlwZWQuZmluZChjYWxsYmFjaywgW2R0LCBkdF0pO1xuICAgIH1cblxuICAgIC8vIHJlc3VsdCBhcnJheXNcbiAgICB2YXIgY3ZhbHVlcyA9IFtdO1xuICAgIHZhciBjaW5kZXggPSBbXTtcbiAgICB2YXIgY3B0ciA9IFtdO1xuICAgIC8vIG1hdHJpeFxuICAgIHZhciBjID0gbmV3IFNwYXJzZU1hdHJpeCh7XG4gICAgICB2YWx1ZXM6IGN2YWx1ZXMsXG4gICAgICBpbmRleDogY2luZGV4LFxuICAgICAgcHRyOiBjcHRyLFxuICAgICAgc2l6ZTogW3Jvd3MsIGNvbHVtbnNdLFxuICAgICAgZGF0YXR5cGU6IGR0XG4gICAgfSk7XG5cbiAgICAvLyBsb29wIGNvbHVtbnNcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbHVtbnM7IGorKykge1xuICAgICAgLy8gaW5pdGlhbGl6ZSBwdHJcbiAgICAgIGNwdHJbal0gPSBjaW5kZXgubGVuZ3RoO1xuICAgICAgLy8gdmFsdWVzIGluIGpcbiAgICAgIGZvciAodmFyIGswID0gYXB0cltqXSwgazEgPSBhcHRyW2ogKyAxXSwgayA9IGswOyBrIDwgazE7IGsrKykge1xuICAgICAgICAvLyByb3dcbiAgICAgICAgdmFyIGkgPSBhaW5kZXhba107XG4gICAgICAgIC8vIGludm9rZSBjYWxsYmFja1xuICAgICAgICB2YXIgdiA9IGludmVyc2UgPyBjZihiLCBhdmFsdWVzW2tdKSA6IGNmKGF2YWx1ZXNba10sIGIpO1xuICAgICAgICAvLyBjaGVjayB2YWx1ZSBpcyB6ZXJvXG4gICAgICAgIGlmICghZXEodiwgemVybykpIHtcbiAgICAgICAgICAvLyBwdXNoIGluZGV4ICYgdmFsdWVcbiAgICAgICAgICBjaW5kZXgucHVzaChpKTtcbiAgICAgICAgICBjdmFsdWVzLnB1c2godik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdXBkYXRlIHB0clxuICAgIGNwdHJbY29sdW1uc10gPSBjaW5kZXgubGVuZ3RoO1xuXG4gICAgLy8gcmV0dXJuIHNwYXJzZSBtYXRyaXhcbiAgICByZXR1cm4gYztcbiAgfTtcblxuICByZXR1cm4gYWxnb3JpdGhtMTE7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdhbGdvcml0aG0xMSc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG5cbiAgdmFyIERlbnNlTWF0cml4ID0gdHlwZS5EZW5zZU1hdHJpeDtcblxuICAvKipcbiAgICogSXRlcmF0ZXMgb3ZlciBTcGFyc2VNYXRyaXggUyBub256ZXJvIGl0ZW1zIGFuZCBpbnZva2VzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBmKFNpaiwgYikuIFxuICAgKiBDYWxsYmFjayBmdW5jdGlvbiBpbnZva2VkIE14TiB0aW1lcy5cbiAgICpcbiAgICpcbiAgICogICAgICAgICAg4pSMICBmKFNpaiwgYikgIDsgUyhpLGopICE9PSAwXG4gICAqIEMoaSxqKSA9IOKUpCAgXG4gICAqICAgICAgICAgIOKUlCAgZigwLCBiKSAgICA7IG90aGVyd2lzZVxuICAgKlxuICAgKlxuICAgKiBAcGFyYW0ge01hdHJpeH0gICBzICAgICAgICAgICAgICAgICBUaGUgU3BhcnNlTWF0cml4IGluc3RhbmNlIChTKVxuICAgKiBAcGFyYW0ge1NjYWxhcn0gICBiICAgICAgICAgICAgICAgICBUaGUgU2NhbGFyIHZhbHVlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrICAgICAgICAgIFRoZSBmKEFpaixiKSBvcGVyYXRpb24gdG8gaW52b2tlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gIGludmVyc2UgICAgICAgICAgIEEgdHJ1ZSB2YWx1ZSBpbmRpY2F0ZXMgY2FsbGJhY2sgc2hvdWxkIGJlIGludm9rZWQgZihiLFNpailcbiAgICpcbiAgICogQHJldHVybiB7TWF0cml4fSAgICAgICAgICAgICAgICAgICAgRGVuc2VNYXRyaXggKEMpXG4gICAqXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9qb3NkZWpvbmcvbWF0aGpzL3B1bGwvMzQ2I2lzc3VlY29tbWVudC05NzYyNjgxM1xuICAgKi9cbiAgdmFyIGFsZ29yaXRobTEyID0gZnVuY3Rpb24gKHMsIGIsIGNhbGxiYWNrLCBpbnZlcnNlKSB7XG4gICAgLy8gc3BhcnNlIG1hdHJpeCBhcnJheXNcbiAgICB2YXIgYXZhbHVlcyA9IHMuX3ZhbHVlcztcbiAgICB2YXIgYWluZGV4ID0gcy5faW5kZXg7XG4gICAgdmFyIGFwdHIgPSBzLl9wdHI7XG4gICAgdmFyIGFzaXplID0gcy5fc2l6ZTtcbiAgICB2YXIgYWR0ID0gcy5fZGF0YXR5cGU7XG5cbiAgICAvLyBzcGFyc2UgbWF0cml4IGNhbm5vdCBiZSBhIFBhdHRlcm4gbWF0cml4XG4gICAgaWYgKCFhdmFsdWVzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcGVyZm9ybSBvcGVyYXRpb24gb24gUGF0dGVybiBTcGFyc2UgTWF0cml4IGFuZCBTY2FsYXIgdmFsdWUnKTtcblxuICAgIC8vIHJvd3MgJiBjb2x1bW5zXG4gICAgdmFyIHJvd3MgPSBhc2l6ZVswXTtcbiAgICB2YXIgY29sdW1ucyA9IGFzaXplWzFdO1xuXG4gICAgLy8gZGF0YXR5cGVcbiAgICB2YXIgZHQ7XG4gICAgLy8gY2FsbGJhY2sgc2lnbmF0dXJlIHRvIHVzZVxuICAgIHZhciBjZiA9IGNhbGxiYWNrO1xuXG4gICAgLy8gcHJvY2VzcyBkYXRhIHR5cGVzXG4gICAgaWYgKHR5cGVvZiBhZHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBkYXRhdHlwZVxuICAgICAgZHQgPSBhZHQ7XG4gICAgICAvLyBjb252ZXJ0IGIgdG8gdGhlIHNhbWUgZGF0YXR5cGVcbiAgICAgIGIgPSB0eXBlZC5jb252ZXJ0KGIsIGR0KTtcbiAgICAgIC8vIGNhbGxiYWNrXG4gICAgICBjZiA9IHR5cGVkLmZpbmQoY2FsbGJhY2ssIFtkdCwgZHRdKTtcbiAgICB9XG4gICAgXG4gICAgLy8gcmVzdWx0IGFycmF5c1xuICAgIHZhciBjZGF0YSA9IFtdO1xuICAgIC8vIG1hdHJpeFxuICAgIHZhciBjID0gbmV3IERlbnNlTWF0cml4KHtcbiAgICAgIGRhdGE6IGNkYXRhLFxuICAgICAgc2l6ZTogW3Jvd3MsIGNvbHVtbnNdLFxuICAgICAgZGF0YXR5cGU6IGR0XG4gICAgfSk7XG5cbiAgICAvLyB3b3Jrc3BhY2VzXG4gICAgdmFyIHggPSBbXTtcbiAgICAvLyBtYXJrcyBpbmRpY2F0aW5nIHdlIGhhdmUgYSB2YWx1ZSBpbiB4IGZvciBhIGdpdmVuIGNvbHVtblxuICAgIHZhciB3ID0gW107XG5cbiAgICAvLyBsb29wIGNvbHVtbnNcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbHVtbnM7IGorKykge1xuICAgICAgLy8gY29sdW1ucyBtYXJrXG4gICAgICB2YXIgbWFyayA9IGogKyAxO1xuICAgICAgLy8gdmFsdWVzIGluIGpcbiAgICAgIGZvciAodmFyIGswID0gYXB0cltqXSwgazEgPSBhcHRyW2ogKyAxXSwgayA9IGswOyBrIDwgazE7IGsrKykge1xuICAgICAgICAvLyByb3dcbiAgICAgICAgdmFyIHIgPSBhaW5kZXhba107XG4gICAgICAgIC8vIHVwZGF0ZSB3b3Jrc3BhY2VcbiAgICAgICAgeFtyXSA9IGF2YWx1ZXNba107XG4gICAgICAgIHdbcl0gPSBtYXJrO1xuICAgICAgfVxuICAgICAgLy8gbG9vcCByb3dzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgICAvLyBpbml0aWFsaXplIEMgb24gZmlyc3QgY29sdW1uXG4gICAgICAgIGlmIChqID09PSAwKSB7XG4gICAgICAgICAgLy8gY3JlYXRlIHJvdyBhcnJheVxuICAgICAgICAgIGNkYXRhW2ldID0gW107XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgc3BhcnNlIG1hdHJpeCBoYXMgYSB2YWx1ZSBAIGksalxuICAgICAgICBpZiAod1tpXSA9PT0gbWFyaykge1xuICAgICAgICAgIC8vIGludm9rZSBjYWxsYmFjaywgdXBkYXRlIENcbiAgICAgICAgICBjZGF0YVtpXVtqXSA9IGludmVyc2UgPyBjZihiLCB4W2ldKSA6IGNmKHhbaV0sIGIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIGRlbnNlIG1hdHJpeCB2YWx1ZSBAIGksIGpcbiAgICAgICAgICBjZGF0YVtpXVtqXSA9IGludmVyc2UgPyBjZihiLCAwKSA6IGNmKDAsIGIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIHNwYXJzZSBtYXRyaXhcbiAgICByZXR1cm4gYztcbiAgfTtcbiAgXG4gIHJldHVybiBhbGdvcml0aG0xMjtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2FsZ29yaXRobTEyJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMvaW5kZXgnKTtcbnZhciBEaW1lbnNpb25FcnJvciA9IHJlcXVpcmUoJy4uLy4uLy4uL2Vycm9yL0RpbWVuc2lvbkVycm9yJyk7XG5cbnZhciBzdHJpbmcgPSB1dGlsLnN0cmluZyxcbiAgICBpc1N0cmluZyA9IHN0cmluZy5pc1N0cmluZztcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuXG4gIHZhciBEZW5zZU1hdHJpeCA9IHR5cGUuRGVuc2VNYXRyaXg7XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGVzIG92ZXIgRGVuc2VNYXRyaXggaXRlbXMgYW5kIGludm9rZXMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGYoQWlqLi56LCBCaWouLnopLiBcbiAgICogQ2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlZCBNeE4gdGltZXMuXG4gICAqXG4gICAqIEMoaSxqLC4uLnopID0gZihBaWouLnosIEJpai4ueilcbiAgICpcbiAgICogQHBhcmFtIHtNYXRyaXh9ICAgYSAgICAgICAgICAgICAgICAgVGhlIERlbnNlTWF0cml4IGluc3RhbmNlIChBKVxuICAgKiBAcGFyYW0ge01hdHJpeH0gICBiICAgICAgICAgICAgICAgICBUaGUgRGVuc2VNYXRyaXggaW5zdGFuY2UgKEIpXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrICAgICAgICAgIFRoZSBmKEFpai4ueixCaWouLnopIG9wZXJhdGlvbiB0byBpbnZva2VcbiAgICpcbiAgICogQHJldHVybiB7TWF0cml4fSAgICAgICAgICAgICAgICAgICAgRGVuc2VNYXRyaXggKEMpXG4gICAqXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9qb3NkZWpvbmcvbWF0aGpzL3B1bGwvMzQ2I2lzc3VlY29tbWVudC05NzY1ODY1OFxuICAgKi9cbiAgdmFyIGFsZ29yaXRobTEzID0gZnVuY3Rpb24gKGEsIGIsIGNhbGxiYWNrKSB7XG4gICAgLy8gYSBhcnJheXNcbiAgICB2YXIgYWRhdGEgPSBhLl9kYXRhO1xuICAgIHZhciBhc2l6ZSA9IGEuX3NpemU7XG4gICAgdmFyIGFkdCA9IGEuX2RhdGF0eXBlO1xuICAgIC8vIGIgYXJyYXlzXG4gICAgdmFyIGJkYXRhID0gYi5fZGF0YTtcbiAgICB2YXIgYnNpemUgPSBiLl9zaXplO1xuICAgIHZhciBiZHQgPSBiLl9kYXRhdHlwZTtcbiAgICAvLyBjIGFycmF5c1xuICAgIHZhciBjc2l6ZSA9IFtdO1xuXG4gICAgLy8gdmFsaWRhdGUgZGltZW5zaW9uc1xuICAgIGlmIChhc2l6ZS5sZW5ndGggIT09IGJzaXplLmxlbmd0aClcbiAgICAgIHRocm93IG5ldyBEaW1lbnNpb25FcnJvcihhc2l6ZS5sZW5ndGgsIGJzaXplLmxlbmd0aCk7XG5cbiAgICAvLyB2YWxpZGF0ZSBlYWNoIG9uZSBvZiB0aGUgZGltZW5zaW9uIHNpemVzXG4gICAgZm9yICh2YXIgcyA9IDA7IHMgPCBhc2l6ZS5sZW5ndGg7IHMrKykge1xuICAgICAgLy8gbXVzdCBtYXRjaFxuICAgICAgaWYgKGFzaXplW3NdICE9PSBic2l6ZVtzXSlcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0RpbWVuc2lvbiBtaXNtYXRjaC4gTWF0cml4IEEgKCcgKyBhc2l6ZSArICcpIG11c3QgbWF0Y2ggTWF0cml4IEIgKCcgKyBic2l6ZSArICcpJyk7XG4gICAgICAvLyB1cGRhdGUgZGltZW5zaW9uIGluIGNcbiAgICAgIGNzaXplW3NdID0gYXNpemVbc107XG4gICAgfVxuXG4gICAgLy8gZGF0YXR5cGVcbiAgICB2YXIgZHQ7XG4gICAgLy8gY2FsbGJhY2sgc2lnbmF0dXJlIHRvIHVzZVxuICAgIHZhciBjZiA9IGNhbGxiYWNrO1xuXG4gICAgLy8gcHJvY2VzcyBkYXRhIHR5cGVzXG4gICAgaWYgKHR5cGVvZiBhZHQgPT09ICdzdHJpbmcnICYmIGFkdCA9PT0gYmR0KSB7XG4gICAgICAvLyBkYXRhdHlwZVxuICAgICAgZHQgPSBhZHQ7XG4gICAgICAvLyBjb252ZXJ0IGIgdG8gdGhlIHNhbWUgZGF0YXR5cGVcbiAgICAgIGIgPSB0eXBlZC5jb252ZXJ0KGIsIGR0KTtcbiAgICAgIC8vIGNhbGxiYWNrXG4gICAgICBjZiA9IHR5cGVkLmZpbmQoY2FsbGJhY2ssIFtkdCwgZHRdKTtcbiAgICB9XG5cbiAgICAvLyBwb3B1bGF0ZSBjZGF0YSwgaXRlcmF0ZSB0aHJvdWdoIGRpbWVuc2lvbnNcbiAgICB2YXIgY2RhdGEgPSBjc2l6ZS5sZW5ndGggPiAwID8gX2l0ZXJhdGUoY2YsIDAsIGNzaXplLCBjc2l6ZVswXSwgYWRhdGEsIGJkYXRhKSA6IFtdO1xuICAgIFxuICAgIC8vIGMgbWF0cml4XG4gICAgcmV0dXJuIG5ldyBEZW5zZU1hdHJpeCh7XG4gICAgICBkYXRhOiBjZGF0YSxcbiAgICAgIHNpemU6IGNzaXplLFxuICAgICAgZGF0YXR5cGU6IGR0XG4gICAgfSk7XG4gIH07XG4gIFxuICAvLyByZWN1cnNpdmUgZnVuY3Rpb25cbiAgdmFyIF9pdGVyYXRlID0gZnVuY3Rpb24gKGYsIGxldmVsLCBzLCBuLCBhdiwgYnYpIHtcbiAgICAvLyBpbml0aWFsaXplIGFycmF5IGZvciB0aGlzIGxldmVsXG4gICAgdmFyIGN2ID0gW107XG4gICAgLy8gY2hlY2sgd2UgcmVhY2ggdGhlIGxhc3QgbGV2ZWxcbiAgICBpZiAobGV2ZWwgPT09IHMubGVuZ3RoIC0gMSkge1xuICAgICAgLy8gbG9vcCBhcnJheXMgaW4gbGFzdCBsZXZlbFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgLy8gaW52b2tlIGNhbGxiYWNrIGFuZCBzdG9yZSB2YWx1ZVxuICAgICAgICBjdltpXSA9IGYoYXZbaV0sIGJ2W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBpdGVyYXRlIGN1cnJlbnQgbGV2ZWxcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICAgIC8vIGl0ZXJhdGUgbmV4dCBsZXZlbFxuICAgICAgICBjdltqXSA9IF9pdGVyYXRlKGYsIGxldmVsICsgMSwgcywgc1tsZXZlbCArIDFdLCBhdltqXSwgYnZbal0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3Y7XG4gIH07XG4gIFxuICByZXR1cm4gYWxnb3JpdGhtMTM7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdhbGdvcml0aG0xMyc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2xvbmUgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscy9vYmplY3QnKS5jbG9uZTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuXG4gIHZhciBEZW5zZU1hdHJpeCA9IHR5cGUuRGVuc2VNYXRyaXg7XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGVzIG92ZXIgRGVuc2VNYXRyaXggaXRlbXMgYW5kIGludm9rZXMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGYoQWlqLi56LCBiKS4gXG4gICAqIENhbGxiYWNrIGZ1bmN0aW9uIGludm9rZWQgTXhOIHRpbWVzLlxuICAgKlxuICAgKiBDKGksaiwuLi56KSA9IGYoQWlqLi56LCBiKVxuICAgKlxuICAgKiBAcGFyYW0ge01hdHJpeH0gICBhICAgICAgICAgICAgICAgICBUaGUgRGVuc2VNYXRyaXggaW5zdGFuY2UgKEEpXG4gICAqIEBwYXJhbSB7U2NhbGFyfSAgIGIgICAgICAgICAgICAgICAgIFRoZSBTY2FsYXIgdmFsdWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgICAgICAgICAgVGhlIGYoQWlqLi56LGIpIG9wZXJhdGlvbiB0byBpbnZva2VcbiAgICogQHBhcmFtIHtib29sZWFufSAgaW52ZXJzZSAgICAgICAgICAgQSB0cnVlIHZhbHVlIGluZGljYXRlcyBjYWxsYmFjayBzaG91bGQgYmUgaW52b2tlZCBmKGIsQWlqLi56KVxuICAgKlxuICAgKiBAcmV0dXJuIHtNYXRyaXh9ICAgICAgICAgICAgICAgICAgICBEZW5zZU1hdHJpeCAoQylcbiAgICpcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL2pvc2Rlam9uZy9tYXRoanMvcHVsbC8zNDYjaXNzdWVjb21tZW50LTk3NjU5MDQyXG4gICAqL1xuICB2YXIgYWxnb3JpdGhtMTQgPSBmdW5jdGlvbiAoYSwgYiwgY2FsbGJhY2ssIGludmVyc2UpIHtcbiAgICAvLyBhIGFycmF5c1xuICAgIHZhciBhZGF0YSA9IGEuX2RhdGE7XG4gICAgdmFyIGFzaXplID0gYS5fc2l6ZTtcbiAgICB2YXIgYWR0ID0gYS5fZGF0YXR5cGU7XG4gICAgXG4gICAgLy8gZGF0YXR5cGVcbiAgICB2YXIgZHQ7XG4gICAgLy8gY2FsbGJhY2sgc2lnbmF0dXJlIHRvIHVzZVxuICAgIHZhciBjZiA9IGNhbGxiYWNrO1xuXG4gICAgLy8gcHJvY2VzcyBkYXRhIHR5cGVzXG4gICAgaWYgKHR5cGVvZiBhZHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBkYXRhdHlwZVxuICAgICAgZHQgPSBhZHQ7XG4gICAgICAvLyBjb252ZXJ0IGIgdG8gdGhlIHNhbWUgZGF0YXR5cGVcbiAgICAgIGIgPSB0eXBlZC5jb252ZXJ0KGIsIGR0KTtcbiAgICAgIC8vIGNhbGxiYWNrXG4gICAgICBjZiA9IHR5cGVkLmZpbmQoY2FsbGJhY2ssIFtkdCwgZHRdKTtcbiAgICB9XG4gICAgXG4gICAgLy8gcG9wdWxhdGUgY2RhdGEsIGl0ZXJhdGUgdGhyb3VnaCBkaW1lbnNpb25zXG4gICAgdmFyIGNkYXRhID0gYXNpemUubGVuZ3RoID4gMCA/IF9pdGVyYXRlKGNmLCAwLCBhc2l6ZSwgYXNpemVbMF0sIGFkYXRhLCBiLCBpbnZlcnNlKSA6IFtdO1xuXG4gICAgLy8gYyBtYXRyaXhcbiAgICByZXR1cm4gbmV3IERlbnNlTWF0cml4KHtcbiAgICAgIGRhdGE6IGNkYXRhLFxuICAgICAgc2l6ZTogY2xvbmUoYXNpemUpLFxuICAgICAgZGF0YXR5cGU6IGR0XG4gICAgfSk7XG4gIH07XG4gIFxuICAvLyByZWN1cnNpdmUgZnVuY3Rpb25cbiAgdmFyIF9pdGVyYXRlID0gZnVuY3Rpb24gKGYsIGxldmVsLCBzLCBuLCBhdiwgYnYsIGludmVyc2UpIHtcbiAgICAvLyBpbml0aWFsaXplIGFycmF5IGZvciB0aGlzIGxldmVsXG4gICAgdmFyIGN2ID0gW107XG4gICAgLy8gY2hlY2sgd2UgcmVhY2ggdGhlIGxhc3QgbGV2ZWxcbiAgICBpZiAobGV2ZWwgPT09IHMubGVuZ3RoIC0gMSkge1xuICAgICAgLy8gbG9vcCBhcnJheXMgaW4gbGFzdCBsZXZlbFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgLy8gaW52b2tlIGNhbGxiYWNrIGFuZCBzdG9yZSB2YWx1ZVxuICAgICAgICBjdltpXSA9IGludmVyc2UgPyBmKGJ2LCBhdltpXSkgOiBmKGF2W2ldLCBidik7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gaXRlcmF0ZSBjdXJyZW50IGxldmVsXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgICAvLyBpdGVyYXRlIG5leHQgbGV2ZWxcbiAgICAgICAgY3Zbal0gPSBfaXRlcmF0ZShmLCBsZXZlbCArIDEsIHMsIHNbbGV2ZWwgKyAxXSwgYXZbal0sIGJ2LCBpbnZlcnNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGN2O1xuICB9O1xuXG4gIHJldHVybiBhbGdvcml0aG0xNDtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2FsZ29yaXRobTE0JztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWVwTWFwID0gcmVxdWlyZSgnLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBNYXAnKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbnVtYmVyIG9yIGNvbnZlcnQgYSBzdHJpbmcsIGJvb2xlYW4sIG9yIHVuaXQgdG8gYSBudW1iZXIuXG4gICAqIFdoZW4gdmFsdWUgaXMgYSBtYXRyaXgsIGFsbCBlbGVtZW50cyB3aWxsIGJlIGNvbnZlcnRlZCB0byBudW1iZXIuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5udW1iZXIodmFsdWUpXG4gICAqICAgIG1hdGgubnVtYmVyKHVuaXQsIHZhbHVlbGVzc1VuaXQpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLm51bWJlcigyKTsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBudW1iZXIgMlxuICAgKiAgICBtYXRoLm51bWJlcignNy4yJyk7ICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBudW1iZXIgNy4yXG4gICAqICAgIG1hdGgubnVtYmVyKHRydWUpOyAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIG51bWJlciAxXG4gICAqICAgIG1hdGgubnVtYmVyKFt0cnVlLCBmYWxzZSwgdHJ1ZSwgdHJ1ZV0pOyAvLyByZXR1cm5zIFsxLCAwLCAxLCAxXVxuICAgKiAgICBtYXRoLm51bWJlcihtYXRoLnVuaXQoJzUyY20nKSwgJ20nKTsgICAgLy8gcmV0dXJucyAwLjUyXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBiaWdudW1iZXIsIGJvb2xlYW4sIGNvbXBsZXgsIGluZGV4LCBtYXRyaXgsIHN0cmluZywgdW5pdFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgYm9vbGVhbiB8IEFycmF5IHwgTWF0cml4IHwgVW5pdCB8IG51bGx9IFt2YWx1ZV0gIFZhbHVlIHRvIGJlIGNvbnZlcnRlZFxuICAgKiBAcGFyYW0ge1VuaXQgfCBzdHJpbmd9IFt2YWx1ZWxlc3NVbml0XSBBIHZhbHVlbGVzcyB1bml0LCB1c2VkIHRvIGNvbnZlcnQgYSB1bml0IHRvIGEgbnVtYmVyXG4gICAqIEByZXR1cm4ge251bWJlciB8IEFycmF5IHwgTWF0cml4fSBUaGUgY3JlYXRlZCBudW1iZXJcbiAgICovXG4gIHZhciBudW1iZXIgPSB0eXBlZCgnbnVtYmVyJywge1xuICAgICcnOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgJ251bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9LFxuXG4gICAgJ3N0cmluZyc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICB2YXIgbnVtID0gTnVtYmVyKHgpO1xuICAgICAgaWYgKGlzTmFOKG51bSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdTdHJpbmcgXCInICsgeCArICdcIiBpcyBubyB2YWxpZCBudW1iZXInKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudW07XG4gICAgfSxcblxuICAgICdCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHgudG9OdW1iZXIoKTtcbiAgICB9LFxuXG4gICAgJ0ZyYWN0aW9uJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LnZhbHVlT2YoKTtcbiAgICB9LFxuXG4gICAgJ1VuaXQnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZWNvbmQgYXJndW1lbnQgd2l0aCB2YWx1ZWxlc3MgdW5pdCBleHBlY3RlZCcpO1xuICAgIH0sXG5cbiAgICAnVW5pdCwgc3RyaW5nIHwgVW5pdCc6IGZ1bmN0aW9uICh1bml0LCB2YWx1ZWxlc3NVbml0KSB7XG4gICAgICByZXR1cm4gdW5pdC50b051bWJlcih2YWx1ZWxlc3NVbml0KTtcbiAgICB9LFxuXG4gICAgJ0FycmF5IHwgTWF0cml4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBkZWVwTWFwKHgsIG51bWJlcik7XG4gICAgfVxuICB9KTtcblxuICBudW1iZXIudG9UZXggPSB7XG4gICAgMDogJzAnLFxuICAgIDE6ICdcXFxcbGVmdCgke2FyZ3NbMF19XFxcXHJpZ2h0KScsXG4gICAgMjogJ1xcXFxsZWZ0KFxcXFxsZWZ0KCR7YXJnc1swXX1cXFxccmlnaHQpJHthcmdzWzFdfVxcXFxyaWdodCknXG4gIH07XG5cbiAgcmV0dXJuIG51bWJlcjtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ251bWJlcic7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIC8qKlxuICAgKiBBIFJlc3VsdFNldCBjb250YWlucyBhIGxpc3Qgb3IgcmVzdWx0c1xuICAgKiBAY2xhc3MgUmVzdWx0U2V0XG4gICAqIEBwYXJhbSB7QXJyYXl9IGVudHJpZXNcbiAgICogQGNvbnN0cnVjdG9yIFJlc3VsdFNldFxuICAgKi9cbiAgZnVuY3Rpb24gUmVzdWx0U2V0KGVudHJpZXMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVzdWx0U2V0KSkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdDb25zdHJ1Y3RvciBtdXN0IGJlIGNhbGxlZCB3aXRoIHRoZSBuZXcgb3BlcmF0b3InKTtcbiAgICB9XG5cbiAgICB0aGlzLmVudHJpZXMgPSBlbnRyaWVzIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGFjaCB0eXBlIGluZm9ybWF0aW9uXG4gICAqL1xuICBSZXN1bHRTZXQucHJvdG90eXBlLnR5cGUgPSAnUmVzdWx0U2V0JztcbiAgUmVzdWx0U2V0LnByb3RvdHlwZS5pc1Jlc3VsdFNldCA9IHRydWU7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFycmF5IHdpdGggcmVzdWx0cyBob2xkIGJ5IHRoaXMgUmVzdWx0U2V0XG4gICAqIEBtZW1iZXJvZiBSZXN1bHRTZXRcbiAgICogQHJldHVybnMge0FycmF5fSBlbnRyaWVzXG4gICAqL1xuICBSZXN1bHRTZXQucHJvdG90eXBlLnZhbHVlT2YgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW50cmllcztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RyaW5naWZpZWQgcmVzdWx0cyBvZiB0aGUgUmVzdWx0U2V0XG4gICAqIEBtZW1iZXJvZiBSZXN1bHRTZXRcbiAgICogQHJldHVybnMge3N0cmluZ30gc3RyaW5nXG4gICAqL1xuICBSZXN1bHRTZXQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnWycgKyB0aGlzLmVudHJpZXMuam9pbignLCAnKSArICddJztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgUmVzdWx0U2V0XG4gICAqIEBtZW1iZXJvZiBSZXN1bHRTZXRcbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhIEpTT04gb2JqZWN0IHN0cnVjdHVyZWQgYXM6XG4gICAqICAgICAgICAgICAgICAgICAgIGB7XCJtYXRoanNcIjogXCJSZXN1bHRTZXRcIiwgXCJlbnRyaWVzXCI6IFsuLi5dfWBcbiAgICovXG4gIFJlc3VsdFNldC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtYXRoanM6ICdSZXN1bHRTZXQnLFxuICAgICAgZW50cmllczogdGhpcy5lbnRyaWVzXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogSW5zdGFudGlhdGUgYSBSZXN1bHRTZXQgZnJvbSBhIEpTT04gb2JqZWN0XG4gICAqIEBtZW1iZXJvZiBSZXN1bHRTZXRcbiAgICogQHBhcmFtIHtPYmplY3R9IGpzb24gIEEgSlNPTiBvYmplY3Qgc3RydWN0dXJlZCBhczpcbiAgICogICAgICAgICAgICAgICAgICAgICAgIGB7XCJtYXRoanNcIjogXCJSZXN1bHRTZXRcIiwgXCJlbnRyaWVzXCI6IFsuLi5dfWBcbiAgICogQHJldHVybiB7UmVzdWx0U2V0fVxuICAgKi9cbiAgUmVzdWx0U2V0LmZyb21KU09OID0gZnVuY3Rpb24gKGpzb24pIHtcbiAgICByZXR1cm4gbmV3IFJlc3VsdFNldChqc29uLmVudHJpZXMpO1xuICB9O1xuXG4gIHJldHVybiBSZXN1bHRTZXQ7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdSZXN1bHRTZXQnO1xuZXhwb3J0cy5wYXRoID0gJ3R5cGUnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIm1vZHVsZS5leHBvcnRzID0gW1xuICAvLyB0eXBlXG4gIHJlcXVpcmUoJy4vUmVzdWx0U2V0Jylcbl07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWVwTWFwID0gcmVxdWlyZSgnLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBNYXAnKTtcbnZhciBudW1iZXIgPSByZXF1aXJlKCcuLi91dGlscy9udW1iZXInKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICAvKipcbiAgICogQ3JlYXRlIGEgc3RyaW5nIG9yIGNvbnZlcnQgYW55IG9iamVjdCBpbnRvIGEgc3RyaW5nLlxuICAgKiBFbGVtZW50cyBvZiBBcnJheXMgYW5kIE1hdHJpY2VzIGFyZSBwcm9jZXNzZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguc3RyaW5nKHZhbHVlKVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5zdHJpbmcoNC4yKTsgICAgICAgICAgICAgICAvLyByZXR1cm5zIHN0cmluZyAnNC4yJ1xuICAgKiAgICBtYXRoLnN0cmluZyhtYXRoLmNvbXBsZXgoMywgMik7IC8vIHJldHVybnMgc3RyaW5nICczICsgMmknXG4gICAqXG4gICAqICAgIHZhciB1ID0gbWF0aC51bml0KDUsICdrbScpO1xuICAgKiAgICBtYXRoLnN0cmluZyh1LnRvKCdtJykpOyAgICAgICAgIC8vIHJldHVybnMgc3RyaW5nICc1MDAwIG0nXG4gICAqXG4gICAqICAgIG1hdGguc3RyaW5nKFt0cnVlLCBmYWxzZV0pOyAgICAgLy8gcmV0dXJucyBbJ3RydWUnLCAnZmFsc2UnXVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgYmlnbnVtYmVyLCBib29sZWFuLCBjb21wbGV4LCBpbmRleCwgbWF0cml4LCBudW1iZXIsIHVuaXRcbiAgICpcbiAgICogQHBhcmFtIHsqIHwgQXJyYXkgfCBNYXRyaXggfCBudWxsfSBbdmFsdWVdICBBIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBzdHJpbmdcbiAgICogQHJldHVybiB7c3RyaW5nIHwgQXJyYXkgfCBNYXRyaXh9IFRoZSBjcmVhdGVkIHN0cmluZ1xuICAgKi9cbiAgdmFyIHN0cmluZyA9IHR5cGVkKCdzdHJpbmcnLCB7XG4gICAgJyc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9LFxuXG4gICAgJ251bWJlcic6IG51bWJlci5mb3JtYXQsXG5cbiAgICAnbnVsbCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gJ251bGwnO1xuICAgIH0sXG5cbiAgICAnYm9vbGVhbic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geCArICcnO1xuICAgIH0sXG5cbiAgICAnc3RyaW5nJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH0sXG5cbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIGRlZXBNYXAoeCwgc3RyaW5nKTtcbiAgICB9LFxuXG4gICAgJ2FueSc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gU3RyaW5nKHgpO1xuICAgIH1cbiAgfSk7XG5cbiAgc3RyaW5nLnRvVGV4ID0ge1xuICAgIDA6ICdcXFxcbWF0aHR0e1wiXCJ9JyxcbiAgICAxOiAnXFxcXG1hdGhybXtzdHJpbmd9XFxcXGxlZnQoJHthcmdzWzBdfVxcXFxyaWdodCknXG4gIH07XG5cbiAgcmV0dXJuIHN0cmluZztcbn1cblxuZXhwb3J0cy5uYW1lID0gJ3N0cmluZyc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW5kc1dpdGggPSByZXF1aXJlKCcuLi8uLi91dGlscy9zdHJpbmcnKS5lbmRzV2l0aDtcbnZhciBjbG9uZSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdCcpLmNsb25lO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2JpZ251bWJlci9jb25zdGFudHMnKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCwgbWF0aCkge1xuICB2YXIgYWRkICAgICAgID0gbG9hZChyZXF1aXJlKCcuLi8uLi9mdW5jdGlvbi9hcml0aG1ldGljL2FkZFNjYWxhcicpKTtcbiAgdmFyIHN1YnRyYWN0ICA9IGxvYWQocmVxdWlyZSgnLi4vLi4vZnVuY3Rpb24vYXJpdGhtZXRpYy9zdWJ0cmFjdCcpKTtcbiAgdmFyIG11bHRpcGx5ICA9IGxvYWQocmVxdWlyZSgnLi4vLi4vZnVuY3Rpb24vYXJpdGhtZXRpYy9tdWx0aXBseVNjYWxhcicpKTtcbiAgdmFyIGRpdmlkZSAgICA9IGxvYWQocmVxdWlyZSgnLi4vLi4vZnVuY3Rpb24vYXJpdGhtZXRpYy9kaXZpZGVTY2FsYXInKSk7XG4gIHZhciBwb3cgICAgICAgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL2Z1bmN0aW9uL2FyaXRobWV0aWMvcG93JykpO1xuICB2YXIgYWJzICAgICAgID0gbG9hZChyZXF1aXJlKCcuLi8uLi9mdW5jdGlvbi9hcml0aG1ldGljL2FicycpKTtcbiAgdmFyIGVxdWFsICAgICA9IGxvYWQocmVxdWlyZSgnLi4vLi4vZnVuY3Rpb24vcmVsYXRpb25hbC9lcXVhbCcpKTtcbiAgdmFyIGlzTnVtZXJpYyA9IGxvYWQocmVxdWlyZSgnLi4vLi4vZnVuY3Rpb24vdXRpbHMvaXNOdW1lcmljJykpO1xuICB2YXIgZm9ybWF0ICAgID0gbG9hZChyZXF1aXJlKCcuLi8uLi9mdW5jdGlvbi9zdHJpbmcvZm9ybWF0JykpO1xuICB2YXIgZ2V0VHlwZU9mID0gbG9hZChyZXF1aXJlKCcuLi8uLi9mdW5jdGlvbi91dGlscy90eXBlb2YnKSk7XG4gIHZhciB0b051bWJlciAgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbnVtYmVyJykpO1xuICB2YXIgQ29tcGxleCAgID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL2NvbXBsZXgvQ29tcGxleCcpKTtcblxuICAvKipcbiAgICogQSB1bml0IGNhbiBiZSBjb25zdHJ1Y3RlZCBpbiB0aGUgZm9sbG93aW5nIHdheXM6XG4gICAqICAgICB2YXIgYSA9IG5ldyBVbml0KHZhbHVlLCBuYW1lKTtcbiAgICogICAgIHZhciBiID0gbmV3IFVuaXQobnVsbCwgbmFtZSk7XG4gICAqICAgICB2YXIgYyA9IFVuaXQucGFyc2Uoc3RyKTtcbiAgICpcbiAgICogRXhhbXBsZSB1c2FnZTpcbiAgICogICAgIHZhciBhID0gbmV3IFVuaXQoNSwgJ2NtJyk7ICAgICAgICAgICAgICAgLy8gNTAgbW1cbiAgICogICAgIHZhciBiID0gVW5pdC5wYXJzZSgnMjMga2cnKTsgICAgICAgICAgICAgLy8gMjMga2dcbiAgICogICAgIHZhciBjID0gbWF0aC5pbihhLCBuZXcgVW5pdChudWxsLCAnbScpOyAgLy8gMC4wNSBtXG4gICAqICAgICB2YXIgZCA9IG5ldyBVbml0KDkuODEsIFwibS9zXjJcIik7ICAgICAgICAgLy8gOS44MSBtL3NeMlxuICAgKlxuICAgKiBAY2xhc3MgVW5pdFxuICAgKiBAY29uc3RydWN0b3IgVW5pdFxuICAgKiBAcGFyYW0ge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgQ29tcGxleCB8IGJvb2xlYW59IFt2YWx1ZV0gIEEgdmFsdWUgbGlrZSA1LjJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lXSAgIEEgdW5pdCBuYW1lIGxpa2UgXCJjbVwiIG9yIFwiaW5jaFwiLCBvciBhIGRlcml2ZWQgdW5pdCBvZiB0aGUgZm9ybTogXCJ1MVteZXgxXSBbdTJbXmV4Ml0gLi4uXSBbLyB1M1teZXgzXSBbdTRbXmV4NF1dXVwiLCBzdWNoIGFzIFwia2cgbV4yL3NeMlwiLCB3aGVyZSBlYWNoIHVuaXQgYXBwZWFyaW5nIGFmdGVyIHRoZSBmb3J3YXJkIHNsYXNoIGlzIHRha2VuIHRvIGJlIGluIHRoZSBkZW5vbWluYXRvci4gXCJrZyBtXjIgc14tMlwiIGlzIGEgc3lub255bSBhbmQgaXMgYWxzbyBhY2NlcHRhYmxlLiBBbnkgb2YgdGhlIHVuaXRzIGNhbiBpbmNsdWRlIGEgcHJlZml4LlxuICAgKi9cbiAgZnVuY3Rpb24gVW5pdCh2YWx1ZSwgbmFtZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBVbml0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25zdHJ1Y3RvciBtdXN0IGJlIGNhbGxlZCB3aXRoIHRoZSBuZXcgb3BlcmF0b3InKTtcbiAgICB9XG5cbiAgICBpZiAoISh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IGlzTnVtZXJpYyh2YWx1ZSkgfHwgdmFsdWUuaXNDb21wbGV4KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgcGFyYW1ldGVyIGluIFVuaXQgY29uc3RydWN0b3IgbXVzdCBiZSBudW1iZXIsIEJpZ051bWJlciwgRnJhY3Rpb24sIENvbXBsZXgsIG9yIHVuZGVmaW5lZCcpO1xuICAgIH1cbiAgICBpZiAobmFtZSAhPSB1bmRlZmluZWQgJiYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fCBuYW1lID09ICcnKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU2Vjb25kIHBhcmFtZXRlciBpbiBVbml0IGNvbnN0cnVjdG9yIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICBpZiAobmFtZSAhPSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciB1ID0gVW5pdC5wYXJzZShuYW1lKTtcbiAgICAgIHRoaXMudW5pdHMgPSB1LnVuaXRzO1xuICAgICAgdGhpcy5kaW1lbnNpb25zID0gdS5kaW1lbnNpb25zO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMudW5pdHMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICB1bml0OiBVTklUX05PTkUsXG4gICAgICAgICAgcHJlZml4OiBQUkVGSVhFUy5OT05FLCAgLy8gbGluayB0byBhIGxpc3Qgd2l0aCBzdXBwb3J0ZWQgcHJlZml4ZXNcbiAgICAgICAgICBwb3dlcjogMFxuICAgICAgICB9XG4gICAgICBdO1xuICAgICAgdGhpcy5kaW1lbnNpb25zID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdO1xuICAgIH1cblxuICAgIHRoaXMudmFsdWUgPSAodmFsdWUgIT0gdW5kZWZpbmVkKSA/IHRoaXMuX25vcm1hbGl6ZSh2YWx1ZSkgOiBudWxsO1xuXG4gICAgdGhpcy5maXhQcmVmaXggPSBmYWxzZTsgLy8gaWYgdHJ1ZSwgZnVuY3Rpb24gZm9ybWF0IHdpbGwgbm90IHNlYXJjaCBmb3IgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmVzdCBwcmVmaXggYnV0IGxlYXZlIGl0IGFzIGluaXRpYWxseSBwcm92aWRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaXhQcmVmaXggaXMgc2V0IHRydWUgYnkgdGhlIG1ldGhvZCBVbml0LnRvXG5cbiAgICAvLyBUaGUganVzdGlmaWNhdGlvbiBiZWhpbmQgdGhpcyBpcyB0aGF0IGlmIHRoZSBjb25zdHJ1Y3RvciBpcyBleHBsaWNpdGx5IGNhbGxlZCxcbiAgICAvLyB0aGUgY2FsbGVyIHdpc2hlcyB0aGUgdW5pdHMgdG8gYmUgcmV0dXJuZWQgZXhhY3RseSBhcyBoZSBzdXBwbGllZC5cbiAgICB0aGlzLmlzVW5pdExpc3RTaW1wbGlmaWVkID0gdHJ1ZTtcblxuICB9XG5cbiAgLyoqXG4gICAqIEF0dGFjaCB0eXBlIGluZm9ybWF0aW9uXG4gICAqL1xuICBVbml0LnByb3RvdHlwZS50eXBlID0gJ1VuaXQnO1xuICBVbml0LnByb3RvdHlwZS5pc1VuaXQgPSB0cnVlO1xuXG4gIC8vIHByaXZhdGUgdmFyaWFibGVzIGFuZCBmdW5jdGlvbnMgZm9yIHRoZSBVbml0IHBhcnNlclxuICB2YXIgdGV4dCwgaW5kZXgsIGM7XG5cbiAgZnVuY3Rpb24gc2tpcFdoaXRlc3BhY2UoKSB7XG4gICAgd2hpbGUgKGMgPT0gJyAnIHx8IGMgPT0gJ1xcdCcpIHtcbiAgICAgIG5leHQoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc0RpZ2l0RG90KGMpIHtcbiAgICByZXR1cm4gKChjID49ICcwJyAmJiBjIDw9ICc5JykgfHwgYyA9PSAnLicpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNEaWdpdChjKSB7XG4gICAgcmV0dXJuICgoYyA+PSAnMCcgJiYgYyA8PSAnOScpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgaW5kZXgrKztcbiAgICBjID0gdGV4dC5jaGFyQXQoaW5kZXgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmV2ZXJ0KG9sZEluZGV4KSB7XG4gICAgaW5kZXggPSBvbGRJbmRleDtcbiAgICBjID0gdGV4dC5jaGFyQXQoaW5kZXgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VOdW1iZXIoKSB7XG4gICAgdmFyIG51bWJlciA9ICcnO1xuICAgIHZhciBvbGRJbmRleDtcbiAgICBvbGRJbmRleCA9IGluZGV4O1xuXG4gICAgaWYgKGMgPT0gJysnKSB7XG4gICAgICBuZXh0KCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGMgPT0gJy0nKSB7XG4gICAgICBudW1iZXIgKz0gYztcbiAgICAgIG5leHQoKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzRGlnaXREb3QoYykpIHtcbiAgICAgIC8vIGEgKyBvciAtIG11c3QgYmUgZm9sbG93ZWQgYnkgYSBkaWdpdFxuICAgICAgcmV2ZXJ0KG9sZEluZGV4KTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIGdldCBudW1iZXIsIGNhbiBoYXZlIGEgc2luZ2xlIGRvdFxuICAgIGlmIChjID09ICcuJykge1xuICAgICAgbnVtYmVyICs9IGM7XG4gICAgICBuZXh0KCk7XG4gICAgICBpZiAoIWlzRGlnaXQoYykpIHtcbiAgICAgICAgLy8gdGhpcyBpcyBubyBsZWdhbCBudW1iZXIsIGl0IGlzIGp1c3QgYSBkb3RcbiAgICAgICAgcmV2ZXJ0KG9sZEluZGV4KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgd2hpbGUgKGlzRGlnaXQoYykpIHtcbiAgICAgICAgbnVtYmVyICs9IGM7XG4gICAgICAgIG5leHQoKTtcbiAgICAgIH1cbiAgICAgIGlmIChjID09ICcuJykge1xuICAgICAgICBudW1iZXIgKz0gYztcbiAgICAgICAgbmV4dCgpO1xuICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAoaXNEaWdpdChjKSkge1xuICAgICAgbnVtYmVyICs9IGM7XG4gICAgICBuZXh0KCk7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgZm9yIGV4cG9uZW50aWFsIG5vdGF0aW9uIGxpa2UgXCIyLjNlLTRcIiBvciBcIjEuMjNlNTBcIlxuICAgIGlmIChjID09ICdFJyB8fCBjID09ICdlJykge1xuICAgICAgLy8gVGhlIGdyYW1tYXIgYnJhbmNoZXMgaGVyZS4gVGhpcyBjb3VsZCBlaXRoZXIgYmUgcGFydCBvZiBhbiBleHBvbmVudCBvciB0aGUgc3RhcnQgb2YgYSB1bml0IHRoYXQgYmVnaW5zIHdpdGggdGhlIGxldHRlciBlLCBzdWNoIGFzIFwiNGV4YWJ5dGVzXCJcblxuICAgICAgdmFyIHRlbnRhdGl2ZU51bWJlciA9ICcnO1xuICAgICAgdmFyIHRlbnRhdGl2ZUluZGV4ID0gaW5kZXg7XG5cbiAgICAgIHRlbnRhdGl2ZU51bWJlciArPSBjO1xuICAgICAgbmV4dCgpO1xuXG4gICAgICBpZiAoYyA9PSAnKycgfHwgYyA9PSAnLScpIHtcbiAgICAgICAgdGVudGF0aXZlTnVtYmVyICs9IGM7XG4gICAgICAgIG5leHQoKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2NpZW50aWZpYyBub3RhdGlvbiBNVVNUIGJlIGZvbGxvd2VkIGJ5IGFuIGV4cG9uZW50IChvdGhlcndpc2Ugd2UgYXNzdW1lIGl0IGlzIG5vdCBzY2llbnRpZmljIG5vdGF0aW9uKVxuICAgICAgaWYgKCFpc0RpZ2l0KGMpKSB7XG4gICAgICAgIC8vIFRoZSBlIG9yIEUgbXVzdCBiZWxvbmcgdG8gc29tZXRoaW5nIGVsc2UsIHNvIHJldHVybiB0aGUgbnVtYmVyIHdpdGhvdXQgdGhlIGUgb3IgRS5cbiAgICAgICAgcmV2ZXJ0KHRlbnRhdGl2ZUluZGV4KTtcbiAgICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gV2UgY2FuIG5vdyBzYWZlbHkgc2F5IHRoYXQgdGhpcyBpcyBzY2llbnRpZmljIG5vdGF0aW9uLlxuICAgICAgbnVtYmVyID0gbnVtYmVyICsgdGVudGF0aXZlTnVtYmVyO1xuICAgICAgd2hpbGUgKGlzRGlnaXQoYykpIHtcbiAgICAgICAgbnVtYmVyICs9IGM7XG4gICAgICAgIG5leHQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVtYmVyO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VVbml0KCkge1xuICAgIHZhciB1bml0TmFtZSA9ICcnO1xuXG4gICAgLy8gQWxwaGFudW1lcmljIGNoYXJhY3RlcnMgb25seTsgbWF0Y2hlcyBbYS16QS1aMC05XVxuICAgIHZhciBjb2RlID0gdGV4dC5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICB3aGlsZSAoIChjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpIHx8XG4gICAgICAgICAgICAoY29kZSA+PSA2NSAmJiBjb2RlIDw9IDkwKSB8fFxuICAgICAgICAgICAgKGNvZGUgPj0gOTcgJiYgY29kZSA8PSAxMjIpKSB7XG4gICAgICB1bml0TmFtZSArPSBjO1xuICAgICAgbmV4dCgpO1xuICAgICAgY29kZSA9IHRleHQuY2hhckNvZGVBdChpbmRleCk7XG4gICAgfVxuXG4gICAgLy8gTXVzdCBiZWdpbiB3aXRoIFthLXpBLVpdXG4gICAgY29kZSA9IHVuaXROYW1lLmNoYXJDb2RlQXQoMCk7XG4gICAgaWYgKChjb2RlID49IDY1ICYmIGNvZGUgPD0gOTApIHx8XG4gICAgICAgIChjb2RlID49IDk3ICYmIGNvZGUgPD0gMTIyKSkge1xuICAgICAgICByZXR1cm4gdW5pdE5hbWUgfHwgbnVsbDtcbiAgICB9IFxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VDaGFyYWN0ZXIodG9GaW5kKSB7XG4gICAgaWYgKGMgPT09IHRvRmluZCkge1xuICAgICAgbmV4dCgpO1xuICAgICAgcmV0dXJuIHRvRmluZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgYSBzdHJpbmcgaW50byBhIHVuaXQuIFRoZSB2YWx1ZSBvZiB0aGUgdW5pdCBpcyBwYXJzZWQgYXMgbnVtYmVyLFxuICAgKiBCaWdOdW1iZXIsIG9yIEZyYWN0aW9uIGRlcGVuZGluZyBvbiB0aGUgbWF0aC5qcyBjb25maWcgc2V0dGluZyBgbnVtYmVyYC5cbiAgICpcbiAgICogVGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiB0aGUgcHJvdmlkZWQgc3RyaW5nIGRvZXMgbm90IGNvbnRhaW4gYSB2YWxpZCB1bml0IG9yXG4gICAqIGNhbm5vdCBiZSBwYXJzZWQuXG4gICAqIEBtZW1iZXJvZiBVbml0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgICAgICAgIEEgc3RyaW5nIGxpa2UgXCI1LjIgaW5jaFwiLCBcIjRlMiBjbS9zXjJcIlxuICAgKiBAcmV0dXJuIHtVbml0fSB1bml0XG4gICAqL1xuICBVbml0LnBhcnNlID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHRleHQgPSBzdHI7XG4gICAgaW5kZXggPSAtMTtcbiAgICBjID0gJyc7XG5cbiAgICBpZiAodHlwZW9mIHRleHQgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFyZ3VtZW50IGluIFVuaXQucGFyc2UsIHN0cmluZyBleHBlY3RlZCcpO1xuICAgIH1cblxuICAgIHZhciB1bml0ID0gbmV3IFVuaXQoKTtcbiAgICB1bml0LnVuaXRzID0gW107XG5cbiAgICAvLyBBIHVuaXQgc2hvdWxkIGZvbGxvdyB0aGlzIHBhdHRlcm46XG4gICAgLy8gW251bWJlcl11bml0W15udW1iZXJdIFt1bml0W15udW1iZXJdXS4uLlsvdW5pdFtebnVtYmVyXSBbdW5pdFtebnVtYmVyXV1dXG5cbiAgICAvLyBSdWxlczpcbiAgICAvLyBudW1iZXIgaXMgYW55IGZsb2F0aW5nIHBvaW50IG51bWJlci5cbiAgICAvLyB1bml0IGlzIGFueSBhbHBoYW51bWVyaWMgc3RyaW5nIGJlZ2lubmluZyB3aXRoIGFuIGFscGhhLiBVbml0cyB3aXRoIG5hbWVzIGxpa2UgZTMgc2hvdWxkIGJlIGF2b2lkZWQgYmVjYXVzZSB0aGV5IGxvb2sgbGlrZSB0aGUgZXhwb25lbnQgb2YgYSBmbG9hdGluZyBwb2ludCBudW1iZXIhXG4gICAgLy8gVGhlIHN0cmluZyBtYXkgb3B0aW9uYWxseSBiZWdpbiB3aXRoIGEgbnVtYmVyLlxuICAgIC8vIEVhY2ggdW5pdCBtYXkgb3B0aW9uYWxseSBiZSBmb2xsb3dlZCBieSBebnVtYmVyLlxuICAgIC8vIFdoaXRlc3BhY2Ugb3IgYSBmb3J3YXJkIHNsYXNoIGlzIHJlY29tbWVuZGVkIGJldHdlZW4gY29uc2VjdXRpdmUgdW5pdHMsIGFsdGhvdWdoIHRoZSBmb2xsb3dpbmcgdGVjaG5pY2FsbHkgaXMgcGFyc2VhYmxlOlxuICAgIC8vICAgMm1eMmtnL3NeMlxuICAgIC8vIGl0IGlzIG5vdCBnb29kIGZvcm0uIElmIGEgdW5pdCBzdGFydHMgd2l0aCBlLCB0aGVuIGl0IGNvdWxkIGJlIGNvbmZ1c2VkIGFzIGEgZmxvYXRpbmcgcG9pbnQgbnVtYmVyOlxuICAgIC8vICAgNGVyZ1xuXG4gICAgbmV4dCgpO1xuICAgIHNraXBXaGl0ZXNwYWNlKCk7XG4gICAgLy8gT3B0aW9uYWwgbnVtYmVyIGF0IHRoZSBzdGFydCBvZiB0aGUgc3RyaW5nXG4gICAgdmFyIHZhbHVlU3RyID0gcGFyc2VOdW1iZXIoKTtcbiAgICB2YXIgdmFsdWUgPSBudWxsO1xuICAgIGlmKHZhbHVlU3RyKSB7XG4gICAgICBpZiAoY29uZmlnLm51bWJlciA9PT0gJ0JpZ051bWJlcicpIHtcbiAgICAgICAgdmFsdWUgPSBuZXcgdHlwZS5CaWdOdW1iZXIodmFsdWVTdHIpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY29uZmlnLm51bWJlciA9PT0gJ0ZyYWN0aW9uJykge1xuICAgICAgICB2YWx1ZSA9IG5ldyB0eXBlLkZyYWN0aW9uKHZhbHVlU3RyKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgeyAvLyBudW1iZXJcbiAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlU3RyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2tpcFdoaXRlc3BhY2UoKTsgICAgLy8gV2hpdGVzcGFjZSBpcyBub3QgcmVxdWlyZWQgaGVyZVxuXG4gICAgLy8gTmV4dCwgd2UgcmVhZCBhbnkgbnVtYmVyIG9mIHVuaXRbXm51bWJlcl1cbiAgICB2YXIgcG93ZXJNdWx0aXBsaWVyQ3VycmVudCA9IDE7XG4gICAgdmFyIGV4cGVjdGluZ1VuaXQgPSBmYWxzZTtcblxuICAgIC8vIFN0YWNrIHRvIGtlZXAgdHJhY2sgb2YgcG93ZXJNdWx0aXBsaWVycyBhcHBsaWVkIHRvIGVhY2ggcGFyZW50aGVzZXMgZ3JvdXBcbiAgICB2YXIgcG93ZXJNdWx0aXBsaWVyU3RhY2sgPSBbXTtcblxuICAgIC8vIFJ1bm5pbmcgcHJvZHVjdCBvZiBhbGwgZWxlbWVudHMgaW4gcG93ZXJNdWx0aXBsaWVyU3RhY2tcbiAgICB2YXIgcG93ZXJNdWx0aXBsaWVyU3RhY2tQcm9kdWN0ID0gMTtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBza2lwV2hpdGVzcGFjZSgpO1xuXG4gICAgICAvLyBDaGVjayBmb3IgYW5kIGNvbnN1bWUgb3BlbmluZyBwYXJlbnRoZXNlcywgcHVzaGluZyBwb3dlck11bHRpcGxpZXJDdXJyZW50IHRvIHRoZSBzdGFja1xuICAgICAgLy8gQSAnKCcgd2lsbCBhbHdheXMgYXBwZWFyIGRpcmVjdGx5IGJlZm9yZSBhIHVuaXQuXG4gICAgICB3aGlsZSAoYyA9PT0gJygnKSB7XG4gICAgICAgIHBvd2VyTXVsdGlwbGllclN0YWNrLnB1c2gocG93ZXJNdWx0aXBsaWVyQ3VycmVudCk7XG4gICAgICAgIHBvd2VyTXVsdGlwbGllclN0YWNrUHJvZHVjdCAqPSBwb3dlck11bHRpcGxpZXJDdXJyZW50O1xuICAgICAgICBwb3dlck11bHRpcGxpZXJDdXJyZW50ID0gMTtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgICBza2lwV2hpdGVzcGFjZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBJcyB0aGVyZSBzb21ldGhpbmcgaGVyZT9cbiAgICAgIGlmKGMpIHtcbiAgICAgICAgdmFyIG9sZEMgPSBjO1xuICAgICAgICB2YXIgdVN0ciA9IHBhcnNlVW5pdCgpO1xuICAgICAgICBpZih1U3RyID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1VuZXhwZWN0ZWQgXCInICsgb2xkQyArICdcIiBpbiBcIicgKyB0ZXh0ICsgJ1wiIGF0IGluZGV4ICcgKyBpbmRleC50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIEVuZCBvZiBpbnB1dC5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIFZlcmlmeSB0aGUgdW5pdCBleGlzdHMgYW5kIGdldCB0aGUgcHJlZml4IChpZiBhbnkpXG4gICAgICB2YXIgcmVzID0gX2ZpbmRVbml0KHVTdHIpO1xuICAgICAgaWYocmVzID09IG51bGwpIHtcbiAgICAgICAgLy8gVW5pdCBub3QgZm91bmQuXG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVW5pdCBcIicgKyB1U3RyICsgJ1wiIG5vdCBmb3VuZC4nKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvd2VyID0gcG93ZXJNdWx0aXBsaWVyQ3VycmVudCAqIHBvd2VyTXVsdGlwbGllclN0YWNrUHJvZHVjdDtcbiAgICAgIC8vIElzIHRoZXJlIGEgXCJeIG51bWJlclwiP1xuICAgICAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgICAgIGlmIChwYXJzZUNoYXJhY3RlcignXicpKSB7XG4gICAgICAgIHNraXBXaGl0ZXNwYWNlKCk7XG4gICAgICAgIHZhciBwID0gcGFyc2VOdW1iZXIoKTtcbiAgICAgICAgaWYocCA9PSBudWxsKSB7XG4gICAgICAgICAgLy8gTm8gdmFsaWQgbnVtYmVyIGZvdW5kIGZvciB0aGUgcG93ZXIhXG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdJbiBcIicgKyBzdHIgKyAnXCIsIFwiXlwiIG11c3QgYmUgZm9sbG93ZWQgYnkgYSBmbG9hdGluZy1wb2ludCBudW1iZXInKTtcbiAgICAgICAgfVxuICAgICAgICBwb3dlciAqPSBwO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgdGhlIHVuaXQgdG8gdGhlIGxpc3RcbiAgICAgIHVuaXQudW5pdHMucHVzaCgge1xuICAgICAgICB1bml0OiByZXMudW5pdCxcbiAgICAgICAgcHJlZml4OiByZXMucHJlZml4LFxuICAgICAgICBwb3dlcjogcG93ZXJcbiAgICAgIH0pO1xuICAgICAgZm9yKHZhciBpPTA7IGk8QkFTRV9ESU1FTlNJT05TLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHVuaXQuZGltZW5zaW9uc1tpXSArPSByZXMudW5pdC5kaW1lbnNpb25zW2ldICogcG93ZXI7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGZvciBhbmQgY29uc3VtZSBjbG9zaW5nIHBhcmVudGhlc2VzLCBwb3BwaW5nIGZyb20gdGhlIHN0YWNrLlxuICAgICAgLy8gQSAnKScgd2lsbCBhbHdheXMgZm9sbG93IGEgdW5pdC5cbiAgICAgIHNraXBXaGl0ZXNwYWNlKCk7XG4gICAgICB3aGlsZSAoYyA9PT0gJyknKSB7XG4gICAgICAgIGlmKHBvd2VyTXVsdGlwbGllclN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVW5tYXRjaGVkIFwiKVwiIGluIFwiJyArIHRleHQgKyAnXCIgYXQgaW5kZXggJyArIGluZGV4LnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIHBvd2VyTXVsdGlwbGllclN0YWNrUHJvZHVjdCAvPSBwb3dlck11bHRpcGxpZXJTdGFjay5wb3AoKTtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgICBza2lwV2hpdGVzcGFjZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBcIipcIiBhbmQgXCIvXCIgc2hvdWxkIG1lYW4gd2UgYXJlIGV4cGVjdGluZyBzb21ldGhpbmcgdG8gY29tZSBuZXh0LlxuICAgICAgLy8gSXMgdGhlcmUgYSBmb3J3YXJkIHNsYXNoPyBJZiBzbywgbmVnYXRlIHBvd2VyTXVsdGlwbGllckN1cnJlbnQuIFRoZSBuZXh0IHVuaXQgb3IgcGFyZW4gZ3JvdXAgaXMgaW4gdGhlIGRlbm9taW5hdG9yLlxuICAgICAgZXhwZWN0aW5nVW5pdCA9IGZhbHNlO1xuXG4gICAgICBpZiAocGFyc2VDaGFyYWN0ZXIoJyonKSkge1xuICAgICAgICAvLyBleHBsaWNpdCBtdWx0aXBsaWNhdGlvblxuICAgICAgICBwb3dlck11bHRpcGxpZXJDdXJyZW50ID0gMTtcbiAgICAgICAgZXhwZWN0aW5nVW5pdCA9IHRydWU7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChwYXJzZUNoYXJhY3RlcignLycpKSB7XG4gICAgICAgIC8vIGRpdmlzaW9uXG4gICAgICAgIHBvd2VyTXVsdGlwbGllckN1cnJlbnQgPSAtMTtcbiAgICAgICAgZXhwZWN0aW5nVW5pdCA9IHRydWU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gaW1wbGljaXQgbXVsdGlwbGljYXRpb25cbiAgICAgICAgcG93ZXJNdWx0aXBsaWVyQ3VycmVudCA9IDE7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlcGxhY2UgdGhlIHVuaXQgaW50byB0aGUgYXV0byB1bml0IHN5c3RlbVxuICAgICAgdmFyIGJhc2VEaW0gPSByZXMudW5pdC5iYXNlLmtleTtcbiAgICAgIFVOSVRfU1lTVEVNUy5hdXRvW2Jhc2VEaW1dID0ge1xuICAgICAgICB1bml0OiByZXMudW5pdCxcbiAgICAgICAgcHJlZml4OiByZXMucHJlZml4XG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICAvLyBIYXMgdGhlIHN0cmluZyBiZWVuIGVudGlyZWx5IGNvbnN1bWVkP1xuICAgIHNraXBXaGl0ZXNwYWNlKCk7XG4gICAgaWYoYykge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdDb3VsZCBub3QgcGFyc2U6IFwiJyArIHN0ciArICdcIicpO1xuICAgIH1cblxuICAgIC8vIElzIHRoZXJlIGEgdHJhaWxpbmcgc2xhc2g/XG4gICAgaWYoZXhwZWN0aW5nVW5pdCkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdUcmFpbGluZyBjaGFyYWN0ZXJzOiBcIicgKyBzdHIgKyAnXCInKTtcbiAgICB9XG5cbiAgICAvLyBJcyB0aGUgcGFyZW50aGVzZXMgc3RhY2sgZW1wdHk/XG4gICAgaWYocG93ZXJNdWx0aXBsaWVyU3RhY2subGVuZ3RoICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1VubWF0Y2hlZCBcIihcIiBpbiBcIicgKyB0ZXh0ICsgJ1wiJyk7XG4gICAgfVxuXG4gICAgLy8gQXJlIHRoZXJlIGFueSB1bml0cyBhdCBhbGw/XG4gICAgaWYodW5pdC51bml0cy5sZW5ndGggPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdcIicgKyBzdHIgKyAnXCIgY29udGFpbnMgbm8gdW5pdHMnKTtcbiAgICB9XG5cbiAgICB1bml0LnZhbHVlID0gKHZhbHVlICE9IHVuZGVmaW5lZCkgPyB1bml0Ll9ub3JtYWxpemUodmFsdWUpIDogbnVsbDtcbiAgICByZXR1cm4gdW5pdDtcbiAgfTtcblxuICAvKipcbiAgICogY3JlYXRlIGEgY29weSBvZiB0aGlzIHVuaXRcbiAgICogQG1lbWJlcm9mIFVuaXRcbiAgICogQHJldHVybiB7VW5pdH0gUmV0dXJucyBhIGNsb25lZCB2ZXJzaW9uIG9mIHRoZSB1bml0XG4gICAqL1xuICBVbml0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdW5pdCA9IG5ldyBVbml0KCk7XG5cbiAgICB1bml0LmZpeFByZWZpeCA9IHRoaXMuZml4UHJlZml4O1xuICAgIHVuaXQuaXNVbml0TGlzdFNpbXBsaWZpZWQgPSB0aGlzLmlzVW5pdExpc3RTaW1wbGlmaWVkO1xuXG4gICAgdW5pdC52YWx1ZSA9IGNsb25lKHRoaXMudmFsdWUpO1xuICAgIHVuaXQuZGltZW5zaW9ucyA9IHRoaXMuZGltZW5zaW9ucy5zbGljZSgwKTtcbiAgICB1bml0LnVuaXRzID0gW107XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMudW5pdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHVuaXQudW5pdHNbaV0gPSB7IH07XG4gICAgICBmb3IgKHZhciBwIGluIHRoaXMudW5pdHNbaV0pIHtcbiAgICAgICAgaWYgKHRoaXMudW5pdHNbaV0uaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgICAgICB1bml0LnVuaXRzW2ldW3BdID0gdGhpcy51bml0c1tpXVtwXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB1bml0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGUgdW5pdCBpcyBkZXJpdmVkIChzdWNoIGFzIG0vcywgb3IgY21eMiwgYnV0IG5vdCBOKVxuICAgKiBAbWVtYmVyb2YgVW5pdFxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSB1bml0IGlzIGRlcml2ZWRcbiAgICovXG4gIFVuaXQucHJvdG90eXBlLl9pc0Rlcml2ZWQgPSBmdW5jdGlvbigpIHtcbiAgICBpZih0aGlzLnVuaXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy51bml0cy5sZW5ndGggPiAxIHx8IE1hdGguYWJzKHRoaXMudW5pdHNbMF0ucG93ZXIgLSAxLjApID4gMWUtMTU7XG4gIH07XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZSBhIHZhbHVlLCBiYXNlZCBvbiBpdHMgY3VycmVudGx5IHNldCB1bml0KHMpXG4gICAqIEBtZW1iZXJvZiBVbml0XG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb24gfCBib29sZWFufSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IGJvb2xlYW59IG5vcm1hbGl6ZWQgdmFsdWVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFVuaXQucHJvdG90eXBlLl9ub3JtYWxpemUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgdW5pdFZhbHVlLCB1bml0T2Zmc2V0LCB1bml0UG93ZXIsIHVuaXRQcmVmaXhWYWx1ZTtcbiAgICB2YXIgY29udmVydDtcblxuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHRoaXMudW5pdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuX2lzRGVyaXZlZCgpKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgZGVyaXZlZCB1bml0LCBzbyBkbyBub3QgYXBwbHkgb2Zmc2V0cy5cbiAgICAgIC8vIEZvciBleGFtcGxlLCB3aXRoIEoga2deLTEgZGVnQ14tMSB5b3Ugd291bGQgTk9UIHdhbnQgdG8gYXBwbHkgdGhlIG9mZnNldC5cbiAgICAgIHZhciByZXMgPSB2YWx1ZTtcbiAgICAgIGNvbnZlcnQgPSBVbml0Ll9nZXROdW1iZXJDb252ZXJ0ZXIoZ2V0VHlwZU9mKHZhbHVlKSk7IC8vIGNvbnZlcnQgdG8gRnJhY3Rpb24gb3IgQmlnTnVtYmVyIGlmIG5lZWRlZFxuXG4gICAgICBmb3IodmFyIGk9MDsgaSA8IHRoaXMudW5pdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdW5pdFZhbHVlICAgICAgID0gY29udmVydCh0aGlzLnVuaXRzW2ldLnVuaXQudmFsdWUpO1xuICAgICAgICB1bml0UHJlZml4VmFsdWUgPSBjb252ZXJ0KHRoaXMudW5pdHNbaV0ucHJlZml4LnZhbHVlKTtcbiAgICAgICAgdW5pdFBvd2VyICAgICAgID0gY29udmVydCh0aGlzLnVuaXRzW2ldLnBvd2VyKTtcbiAgICAgICAgcmVzID0gbXVsdGlwbHkocmVzLCBwb3cobXVsdGlwbHkodW5pdFZhbHVlLCB1bml0UHJlZml4VmFsdWUpLCB1bml0UG93ZXIpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBUaGlzIGlzIGEgc2luZ2xlIHVuaXQgb2YgcG93ZXIgMSwgbGlrZSBrZyBvciBkZWdDXG4gICAgICBjb252ZXJ0ID0gVW5pdC5fZ2V0TnVtYmVyQ29udmVydGVyKGdldFR5cGVPZih2YWx1ZSkpOyAvLyBjb252ZXJ0IHRvIEZyYWN0aW9uIG9yIEJpZ051bWJlciBpZiBuZWVkZWRcblxuICAgICAgdW5pdFZhbHVlICAgICAgID0gY29udmVydCh0aGlzLnVuaXRzWzBdLnVuaXQudmFsdWUpO1xuICAgICAgdW5pdE9mZnNldCAgICAgID0gY29udmVydCh0aGlzLnVuaXRzWzBdLnVuaXQub2Zmc2V0KTtcbiAgICAgIHVuaXRQcmVmaXhWYWx1ZSA9IGNvbnZlcnQodGhpcy51bml0c1swXS5wcmVmaXgudmFsdWUpO1xuXG4gICAgICByZXR1cm4gbXVsdGlwbHkoYWRkKHZhbHVlLCB1bml0T2Zmc2V0KSwgbXVsdGlwbHkodW5pdFZhbHVlLCB1bml0UHJlZml4VmFsdWUpKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIERlbm9ybWFsaXplIGEgdmFsdWUsIGJhc2VkIG9uIGl0cyBjdXJyZW50bHkgc2V0IHVuaXQocylcbiAgICogQG1lbWJlcm9mIFVuaXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlZml4VmFsdWVdICAgIE9wdGlvbmFsIHByZWZpeCB2YWx1ZSB0byBiZSB1c2VkIChpZ25vcmVkIGlmIHRoaXMgaXMgYSBkZXJpdmVkIHVuaXQpXG4gICAqIEByZXR1cm4ge251bWJlcn0gZGVub3JtYWxpemVkIHZhbHVlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBVbml0LnByb3RvdHlwZS5fZGVub3JtYWxpemUgPSBmdW5jdGlvbiAodmFsdWUsIHByZWZpeFZhbHVlKSB7XG4gICAgdmFyIHVuaXRWYWx1ZSwgdW5pdE9mZnNldCwgdW5pdFBvd2VyLCB1bml0UHJlZml4VmFsdWU7XG4gICAgdmFyIGNvbnZlcnQ7XG5cbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0aGlzLnVuaXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLl9pc0Rlcml2ZWQoKSkge1xuICAgICAgLy8gVGhpcyBpcyBhIGRlcml2ZWQgdW5pdCwgc28gZG8gbm90IGFwcGx5IG9mZnNldHMuXG4gICAgICAvLyBGb3IgZXhhbXBsZSwgd2l0aCBKIGtnXi0xIGRlZ0NeLTEgeW91IHdvdWxkIE5PVCB3YW50IHRvIGFwcGx5IHRoZSBvZmZzZXQuXG4gICAgICAvLyBBbHNvLCBwcmVmaXhWYWx1ZSBpcyBpZ25vcmVkLS1idXQgd2Ugd2lsbCBzdGlsbCB1c2UgdGhlIHByZWZpeCB2YWx1ZSBzdG9yZWQgaW4gZWFjaCB1bml0LCBzaW5jZSBrZyBpcyB1c3VhbGx5IHByZWZlcmFibGUgdG8gZyB1bmxlc3MgdGhlIHVzZXIgZGVjaWRlcyBvdGhlcndpc2UuXG4gICAgICB2YXIgcmVzID0gdmFsdWU7XG4gICAgICBjb252ZXJ0ID0gVW5pdC5fZ2V0TnVtYmVyQ29udmVydGVyKGdldFR5cGVPZih2YWx1ZSkpOyAvLyBjb252ZXJ0IHRvIEZyYWN0aW9uIG9yIEJpZ051bWJlciBpZiBuZWVkZWRcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnVuaXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHVuaXRWYWx1ZSAgICAgICA9IGNvbnZlcnQodGhpcy51bml0c1tpXS51bml0LnZhbHVlKTtcbiAgICAgICAgdW5pdFByZWZpeFZhbHVlID0gY29udmVydCh0aGlzLnVuaXRzW2ldLnByZWZpeC52YWx1ZSk7XG4gICAgICAgIHVuaXRQb3dlciAgICAgICA9IGNvbnZlcnQodGhpcy51bml0c1tpXS5wb3dlcik7XG4gICAgICAgIHJlcyA9IGRpdmlkZShyZXMsIHBvdyhtdWx0aXBseSh1bml0VmFsdWUsIHVuaXRQcmVmaXhWYWx1ZSksIHVuaXRQb3dlcikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBzaW5nbGUgdW5pdCBvZiBwb3dlciAxLCBsaWtlIGtnIG9yIGRlZ0NcbiAgICAgIGNvbnZlcnQgPSBVbml0Ll9nZXROdW1iZXJDb252ZXJ0ZXIoZ2V0VHlwZU9mKHZhbHVlKSk7IC8vIGNvbnZlcnQgdG8gRnJhY3Rpb24gb3IgQmlnTnVtYmVyIGlmIG5lZWRlZFxuXG4gICAgICB1bml0VmFsdWUgICAgICAgPSBjb252ZXJ0KHRoaXMudW5pdHNbMF0udW5pdC52YWx1ZSk7XG4gICAgICB1bml0UHJlZml4VmFsdWUgPSBjb252ZXJ0KHRoaXMudW5pdHNbMF0ucHJlZml4LnZhbHVlKTtcbiAgICAgIHVuaXRPZmZzZXQgICAgICA9IGNvbnZlcnQodGhpcy51bml0c1swXS51bml0Lm9mZnNldCk7XG5cbiAgICAgIGlmIChwcmVmaXhWYWx1ZSA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHN1YnRyYWN0KGRpdmlkZShkaXZpZGUodmFsdWUsIHVuaXRWYWx1ZSksIHVuaXRQcmVmaXhWYWx1ZSksIHVuaXRPZmZzZXQpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBzdWJ0cmFjdChkaXZpZGUoZGl2aWRlKHZhbHVlLCB1bml0VmFsdWUpLCBwcmVmaXhWYWx1ZSksIHVuaXRPZmZzZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRmluZCBhIHVuaXQgZnJvbSBhIHN0cmluZ1xuICAgKiBAbWVtYmVyb2YgVW5pdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyICAgICAgICAgICAgICBBIHN0cmluZyBsaWtlICdjbScgb3IgJ2luY2gnXG4gICAqIEByZXR1cm5zIHtPYmplY3QgfCBudWxsfSByZXN1bHQgIFdoZW4gZm91bmQsIGFuIG9iamVjdCB3aXRoIGZpZWxkcyB1bml0IGFuZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVmaXggaXMgcmV0dXJuZWQuIEVsc2UsIG51bGwgaXMgcmV0dXJuZWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfZmluZFVuaXQoc3RyKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBVTklUUykge1xuICAgICAgaWYgKFVOSVRTLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGlmIChlbmRzV2l0aChzdHIsIG5hbWUpKSB7XG4gICAgICAgICAgdmFyIHVuaXQgPSBVTklUU1tuYW1lXTtcbiAgICAgICAgICB2YXIgcHJlZml4TGVuID0gKHN0ci5sZW5ndGggLSBuYW1lLmxlbmd0aCk7XG4gICAgICAgICAgdmFyIHByZWZpeE5hbWUgPSBzdHIuc3Vic3RyaW5nKDAsIHByZWZpeExlbik7XG4gICAgICAgICAgdmFyIHByZWZpeCA9IHVuaXQucHJlZml4ZXNbcHJlZml4TmFtZV07XG4gICAgICAgICAgaWYgKHByZWZpeCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBzdG9yZSB1bml0LCBwcmVmaXgsIGFuZCB2YWx1ZVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdW5pdDogdW5pdCxcbiAgICAgICAgICAgICAgcHJlZml4OiBwcmVmaXhcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogVGVzdCBpZiB0aGUgZ2l2ZW4gZXhwcmVzc2lvbiBpcyBhIHVuaXQuXG4gICAqIFRoZSB1bml0IGNhbiBoYXZlIGEgcHJlZml4IGJ1dCBjYW5ub3QgaGF2ZSBhIHZhbHVlLlxuICAgKiBAbWVtYmVyb2YgVW5pdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAgIEEgc3RyaW5nIHRvIGJlIHRlc3RlZCB3aGV0aGVyIGl0IGlzIGEgdmFsdWUgbGVzcyB1bml0LlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIFRoZSB1bml0IGNhbiBoYXZlIHByZWZpeCwgbGlrZSBcImNtXCJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gICAgICB0cnVlIGlmIHRoZSBnaXZlbiBzdHJpbmcgaXMgYSB1bml0XG4gICAqL1xuICBVbml0LmlzVmFsdWVsZXNzVW5pdCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIChfZmluZFVuaXQobmFtZSkgIT0gbnVsbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIGNoZWNrIGlmIHRoaXMgdW5pdCBoYXMgZ2l2ZW4gYmFzZSB1bml0XG4gICAqIElmIHRoaXMgdW5pdCBpcyBhIGRlcml2ZWQgdW5pdCwgdGhpcyB3aWxsIEFMV0FZUyByZXR1cm4gZmFsc2UsIHNpbmNlIGJ5IGRlZmluaXRpb24gYmFzZSB1bml0cyBhcmUgbm90IGRlcml2ZWQuXG4gICAqIEBtZW1iZXJvZiBVbml0XG4gICAqIEBwYXJhbSB7QkFTRV9VTklUUyB8IHN0cmluZyB8IHVuZGVmaW5lZH0gYmFzZVxuICAgKi9cbiAgVW5pdC5wcm90b3R5cGUuaGFzQmFzZSA9IGZ1bmN0aW9uIChiYXNlKSB7XG5cbiAgICBpZih0eXBlb2YoYmFzZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGJhc2UgPSBCQVNFX1VOSVRTW2Jhc2VdO1xuICAgIH1cblxuICAgIGlmKCFiYXNlKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG5cbiAgICAvLyBBbGwgZGltZW5zaW9ucyBtdXN0IGJlIHRoZSBzYW1lXG4gICAgZm9yKHZhciBpPTA7IGk8QkFTRV9ESU1FTlNJT05TLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoTWF0aC5hYnModGhpcy5kaW1lbnNpb25zW2ldIC0gYmFzZS5kaW1lbnNpb25zW2ldKSA+IDFlLTEyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhpcyB1bml0IGhhcyBhIGJhc2Ugb3IgYmFzZXMgZXF1YWwgdG8gYW5vdGhlciBiYXNlIG9yIGJhc2VzXG4gICAqIEZvciBkZXJpdmVkIHVuaXRzLCB0aGUgZXhwb25lbnQgb24gZWFjaCBiYXNlIGFsc28gbXVzdCBtYXRjaFxuICAgKiBAbWVtYmVyb2YgVW5pdFxuICAgKiBAcGFyYW0ge1VuaXR9IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgZXF1YWwgYmFzZVxuICAgKi9cbiAgVW5pdC5wcm90b3R5cGUuZXF1YWxCYXNlID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgLy8gQWxsIGRpbWVuc2lvbnMgbXVzdCBiZSB0aGUgc2FtZVxuICAgIGZvcih2YXIgaT0wOyBpPEJBU0VfRElNRU5TSU9OUy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKE1hdGguYWJzKHRoaXMuZGltZW5zaW9uc1tpXSAtIG90aGVyLmRpbWVuc2lvbnNbaV0pID4gMWUtMTIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhpcyB1bml0IGVxdWFscyBhbm90aGVyIHVuaXRcbiAgICogQG1lbWJlcm9mIFVuaXRcbiAgICogQHBhcmFtIHtVbml0fSBvdGhlclxuICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIGJvdGggdW5pdHMgYXJlIGVxdWFsXG4gICAqL1xuICBVbml0LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICByZXR1cm4gKHRoaXMuZXF1YWxCYXNlKG90aGVyKSAmJiBlcXVhbCh0aGlzLnZhbHVlLCBvdGhlci52YWx1ZSkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNdWx0aXBseSB0aGlzIHVuaXQgd2l0aCBhbm90aGVyIG9uZVxuICAgKiBAbWVtYmVyb2YgVW5pdFxuICAgKiBAcGFyYW0ge1VuaXR9IG90aGVyXG4gICAqIEByZXR1cm4ge1VuaXR9IHByb2R1Y3Qgb2YgdGhpcyB1bml0IGFuZCB0aGUgb3RoZXIgdW5pdFxuICAgKi9cbiAgVW5pdC5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICB2YXIgcmVzID0gdGhpcy5jbG9uZSgpO1xuICAgIFxuICAgIGZvcih2YXIgaSA9IDA7IGk8QkFTRV9ESU1FTlNJT05TLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXMuZGltZW5zaW9uc1tpXSA9IHRoaXMuZGltZW5zaW9uc1tpXSArIG90aGVyLmRpbWVuc2lvbnNbaV07XG4gICAgfVxuXG4gICAgLy8gQXBwZW5kIG90aGVyJ3MgdW5pdHMgbGlzdCBvbnRvIHJlcyAoc2ltcGxpZnkgbGF0ZXIgaW4gVW5pdC5wcm90b3R5cGUuZm9ybWF0KVxuICAgIGZvcih2YXIgaT0wOyBpPG90aGVyLnVuaXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaW52ZXJ0ZWQgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG90aGVyLnVuaXRzW2ldKSk7IFxuICAgICAgcmVzLnVuaXRzLnB1c2goaW52ZXJ0ZWQpO1xuICAgIH1cblxuICAgIC8vIElmIGF0IGxlYXN0IG9uZSBvcGVyYW5kIGhhcyBhIHZhbHVlLCB0aGVuIHRoZSByZXN1bHQgc2hvdWxkIGFsc28gaGF2ZSBhIHZhbHVlXG4gICAgaWYodGhpcy52YWx1ZSAhPSBudWxsIHx8IG90aGVyLnZhbHVlICE9IG51bGwpIHtcbiAgICAgIHZhciB2YWxUaGlzID0gdGhpcy52YWx1ZSA9PSBudWxsID8gdGhpcy5fbm9ybWFsaXplKDEpIDogdGhpcy52YWx1ZTtcbiAgICAgIHZhciB2YWxPdGhlciA9IG90aGVyLnZhbHVlID09IG51bGwgPyBvdGhlci5fbm9ybWFsaXplKDEpIDogb3RoZXIudmFsdWU7XG4gICAgICByZXMudmFsdWUgPSBtdWx0aXBseSh2YWxUaGlzLCB2YWxPdGhlcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmVzLnZhbHVlID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBUcmlnZ2VyIHNpbXBsaWZpY2F0aW9uIG9mIHRoZSB1bml0IGxpc3QgYXQgc29tZSBmdXR1cmUgdGltZVxuICAgIHJlcy5pc1VuaXRMaXN0U2ltcGxpZmllZCA9IGZhbHNlO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIERpdmlkZSB0aGlzIHVuaXQgYnkgYW5vdGhlciBvbmVcbiAgICogQG1lbWJlcm9mIFVuaXRcbiAgICogQHBhcmFtIHtVbml0fSBvdGhlclxuICAgKiBAcmV0dXJuIHtVbml0fSByZXN1bHQgb2YgZGl2aWRpbmcgdGhpcyB1bml0IGJ5IHRoZSBvdGhlciB1bml0XG4gICAqL1xuICBVbml0LnByb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICB2YXIgcmVzID0gdGhpcy5jbG9uZSgpO1xuICAgIFxuICAgIGZvcih2YXIgaT0wOyBpPEJBU0VfRElNRU5TSU9OUy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzLmRpbWVuc2lvbnNbaV0gPSB0aGlzLmRpbWVuc2lvbnNbaV0gLSBvdGhlci5kaW1lbnNpb25zW2ldO1xuICAgIH1cblxuICAgIC8vIEludmVydCBhbmQgYXBwZW5kIG90aGVyJ3MgdW5pdHMgbGlzdCBvbnRvIHJlcyAoc2ltcGxpZnkgbGF0ZXIgaW4gVW5pdC5wcm90b3R5cGUuZm9ybWF0KVxuICAgIGZvcih2YXIgaT0wOyBpPG90aGVyLnVuaXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBDbG9uZSBvdGhlcidzIHVuaXRcbiAgICAgIHZhciBpbnZlcnRlZCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob3RoZXIudW5pdHNbaV0pKTsgXG4gICAgICBpbnZlcnRlZC5wb3dlciA9IC1pbnZlcnRlZC5wb3dlcjtcbiAgICAgIHJlcy51bml0cy5wdXNoKGludmVydGVkKTtcbiAgICB9XG5cbiAgICAvLyBJZiBhdCBsZWFzdCBvbmUgb3BlcmFuZCBoYXMgYSB2YWx1ZSwgdGhlIHJlc3VsdCBzaG91bGQgaGF2ZSBhIHZhbHVlXG4gICAgaWYgKHRoaXMudmFsdWUgIT0gbnVsbCB8fCBvdGhlci52YWx1ZSAhPSBudWxsKSB7XG4gICAgICB2YXIgdmFsVGhpcyA9IHRoaXMudmFsdWUgPT0gbnVsbCA/IHRoaXMuX25vcm1hbGl6ZSgxKSA6IHRoaXMudmFsdWU7XG4gICAgICB2YXIgdmFsT3RoZXIgPSBvdGhlci52YWx1ZSA9PSBudWxsID8gb3RoZXIuX25vcm1hbGl6ZSgxKSA6IG90aGVyLnZhbHVlO1xuICAgICAgcmVzLnZhbHVlID0gZGl2aWRlKHZhbFRoaXMsIHZhbE90aGVyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXMudmFsdWUgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFRyaWdnZXIgc2ltcGxpZmljYXRpb24gb2YgdGhlIHVuaXQgbGlzdCBhdCBzb21lIGZ1dHVyZSB0aW1lXG4gICAgcmVzLmlzVW5pdExpc3RTaW1wbGlmaWVkID0gZmFsc2U7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBwb3dlciBvZiBhIHVuaXRcbiAgICogQG1lbWJlcm9mIFVuaXRcbiAgICogQHBhcmFtIHtudW1iZXIgfCBGcmFjdGlvbiB8IEJpZ051bWJlcn0gcFxuICAgKiBAcmV0dXJucyB7VW5pdH0gICAgICBUaGUgcmVzdWx0OiB0aGlzXnBcbiAgICovXG4gIFVuaXQucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uIChwKSB7XG4gICAgdmFyIHJlcyA9IHRoaXMuY2xvbmUoKTtcbiAgICBcbiAgICBmb3IodmFyIGk9MDsgaTxCQVNFX0RJTUVOU0lPTlMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlcy5kaW1lbnNpb25zW2ldID0gdGhpcy5kaW1lbnNpb25zW2ldICogcDtcbiAgICB9XG5cbiAgICAvLyBBZGp1c3QgdGhlIHBvd2VyIG9mIGVhY2ggdW5pdCBpbiB0aGUgbGlzdFxuICAgIGZvcih2YXIgaT0wOyBpPHJlcy51bml0cy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzLnVuaXRzW2ldLnBvd2VyICo9IHA7XG4gICAgfVxuXG4gICAgaWYocmVzLnZhbHVlICE9IG51bGwpIHtcbiAgICAgIHJlcy52YWx1ZSA9IHBvdyhyZXMudmFsdWUsIHApO1xuXG4gICAgICAvLyBvbmx5IGFsbG93IG51bWVyaWMgb3V0cHV0LCB3ZSBkb24ndCB3YW50IHRvIHJldHVybiBhIENvbXBsZXggbnVtYmVyXG4gICAgICAvL2lmICghaXNOdW1lcmljKHJlcy52YWx1ZSkpIHtcbiAgICAgIC8vICByZXMudmFsdWUgPSBOYU47XG4gICAgICAvL31cbiAgICAgIC8vIFVwZGF0ZTogQ29tcGxleCBzdXBwb3J0ZWQgbm93XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmVzLnZhbHVlID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBUcmlnZ2VyIGxhenkgZXZhbHVhdGlvbiBvZiB0aGUgdW5pdCBsaXN0XG4gICAgcmVzLmlzVW5pdExpc3RTaW1wbGlmaWVkID0gZmFsc2U7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiBhIHVuaXRcbiAgICogQG1lbWJlcm9mIFVuaXRcbiAgICogQHBhcmFtIHtudW1iZXIgfCBGcmFjdGlvbiB8IEJpZ051bWJlcn0geFxuICAgKiBAcmV0dXJucyB7VW5pdH0gICAgICBUaGUgcmVzdWx0OiB8eHwsIGFic29sdXRlIHZhbHVlIG9mIHhcbiAgICovXG4gIFVuaXQucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBUaGlzIGdpdmVzIGNvcnJlY3QsIGJ1dCB1bmV4cGVjdGVkLCByZXN1bHRzIGZvciB1bml0cyB3aXRoIGFuIG9mZnNldC5cbiAgICAvLyBGb3IgZXhhbXBsZSwgYWJzKC0yODMuMTUgZGVnQykgPSAtMjYzLjE1IGRlZ0MgISEhXG4gICAgdmFyIHJldCA9IHRoaXMuY2xvbmUoKTtcbiAgICByZXQudmFsdWUgPSBhYnMocmV0LnZhbHVlKTtcblxuICAgIGZvcih2YXIgaSBpbiByZXQudW5pdHMpIHtcbiAgICAgIGlmKHJldC51bml0c1tpXS51bml0Lm5hbWUgPT09ICdWQScgfHwgcmV0LnVuaXRzW2ldLnVuaXQubmFtZSA9PT0gJ1ZBUicpIHtcbiAgICAgICAgcmV0LnVuaXRzW2ldLnVuaXQgPSBVTklUU1tcIldcIl07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydCB0aGUgdW5pdCB0byBhIHNwZWNpZmljIHVuaXQgbmFtZS5cbiAgICogQG1lbWJlcm9mIFVuaXRcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBVbml0fSB2YWx1ZWxlc3NVbml0ICAgQSB1bml0IHdpdGhvdXQgdmFsdWUuIENhbiBoYXZlIHByZWZpeCwgbGlrZSBcImNtXCJcbiAgICogQHJldHVybnMge1VuaXR9IFJldHVybnMgYSBjbG9uZSBvZiB0aGUgdW5pdCB3aXRoIGEgZml4ZWQgcHJlZml4IGFuZCB1bml0LlxuICAgKi9cbiAgVW5pdC5wcm90b3R5cGUudG8gPSBmdW5jdGlvbiAodmFsdWVsZXNzVW5pdCkge1xuICAgIHZhciBvdGhlcjtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlID09IG51bGwgPyB0aGlzLl9ub3JtYWxpemUoMSkgOiB0aGlzLnZhbHVlO1xuICAgIGlmICh0eXBlb2YgdmFsdWVsZXNzVW5pdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vb3RoZXIgPSBuZXcgVW5pdChudWxsLCB2YWx1ZWxlc3NVbml0KTtcbiAgICAgIG90aGVyID0gVW5pdC5wYXJzZSh2YWx1ZWxlc3NVbml0KTtcbiAgICAgIGlmICghdGhpcy5lcXVhbEJhc2Uob3RoZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5pdHMgZG8gbm90IG1hdGNoJyk7XG4gICAgICB9XG4gICAgICBpZiAob3RoZXIudmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29udmVydCB0byBhIHVuaXQgd2l0aCBhIHZhbHVlJyk7XG4gICAgICB9XG5cbiAgICAgIG90aGVyLnZhbHVlID0gY2xvbmUodmFsdWUpO1xuICAgICAgb3RoZXIuZml4UHJlZml4ID0gdHJ1ZTtcbiAgICAgIG90aGVyLmlzVW5pdExpc3RTaW1wbGlmaWVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBvdGhlcjtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWVsZXNzVW5pdCAmJiB2YWx1ZWxlc3NVbml0LmlzVW5pdCkge1xuICAgICAgaWYgKCF0aGlzLmVxdWFsQmFzZSh2YWx1ZWxlc3NVbml0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuaXRzIGRvIG5vdCBtYXRjaCcpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlbGVzc1VuaXQudmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29udmVydCB0byBhIHVuaXQgd2l0aCBhIHZhbHVlJyk7XG4gICAgICB9XG4gICAgICBvdGhlciA9IHZhbHVlbGVzc1VuaXQuY2xvbmUoKTtcbiAgICAgIG90aGVyLnZhbHVlID0gY2xvbmUodmFsdWUpO1xuICAgICAgb3RoZXIuZml4UHJlZml4ID0gdHJ1ZTtcbiAgICAgIG90aGVyLmlzVW5pdExpc3RTaW1wbGlmaWVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBvdGhlcjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0cmluZyBvciBVbml0IGV4cGVjdGVkIGFzIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgdW5pdCB3aGVuIHJlcHJlc2VudGVkIHdpdGggZ2l2ZW4gdmFsdWVsZXNzIHVuaXRcbiAgICogQG1lbWJlcm9mIFVuaXRcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBVbml0fSB2YWx1ZWxlc3NVbml0ICAgIEZvciBleGFtcGxlICdjbScgb3IgJ2luY2gnXG4gICAqIEByZXR1cm4ge251bWJlcn0gUmV0dXJucyB0aGUgdW5pdCB2YWx1ZSBhcyBudW1iZXIuXG4gICAqL1xuICAvLyBUT0RPOiBkZXByZWNhdGUgVW5pdC50b051bWJlcj8gSXQncyBhbHdheXMgYmV0dGVyIHRvIHVzZSB0b051bWVyaWNcbiAgVW5pdC5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiAodmFsdWVsZXNzVW5pdCkge1xuICAgIHJldHVybiB0b051bWJlcih0aGlzLnRvTnVtZXJpYyh2YWx1ZWxlc3NVbml0KSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgdmFsdWUgb2YgdGhlIHVuaXQgaW4gdGhlIG9yaWdpbmFsIG51bWVyaWMgdHlwZVxuICAgKiBAbWVtYmVyb2YgVW5pdFxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFVuaXR9IHZhbHVlbGVzc1VuaXQgICAgRm9yIGV4YW1wbGUgJ2NtJyBvciAnaW5jaCdcbiAgICogQHJldHVybiB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb259IFJldHVybnMgdGhlIHVuaXQgdmFsdWVcbiAgICovXG4gIFVuaXQucHJvdG90eXBlLnRvTnVtZXJpYyA9IGZ1bmN0aW9uICh2YWx1ZWxlc3NVbml0KSB7XG4gICAgdmFyIG90aGVyID0gdGhpcy50byh2YWx1ZWxlc3NVbml0KTtcbiAgICBpZihvdGhlci5faXNEZXJpdmVkKCkpIHtcbiAgICAgIHJldHVybiBvdGhlci5fZGVub3JtYWxpemUob3RoZXIudmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBvdGhlci5fZGVub3JtYWxpemUob3RoZXIudmFsdWUsIG90aGVyLnVuaXRzWzBdLnByZWZpeC52YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHVuaXQuXG4gICAqIEBtZW1iZXJvZiBVbml0XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIFVuaXQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmZvcm1hdCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB1bml0XG4gICAqIEBtZW1iZXJvZiBVbml0XG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYSBKU09OIG9iamVjdCBzdHJ1Y3R1cmVkIGFzOlxuICAgKiAgICAgICAgICAgICAgICAgICBge1wibWF0aGpzXCI6IFwiVW5pdFwiLCBcInZhbHVlXCI6IDIsIFwidW5pdFwiOiBcImNtXCIsIFwiZml4UHJlZml4XCI6IGZhbHNlfWBcbiAgICovXG4gIFVuaXQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWF0aGpzOiAnVW5pdCcsXG4gICAgICB2YWx1ZTogdGhpcy5fZGVub3JtYWxpemUodGhpcy52YWx1ZSksXG4gICAgICB1bml0OiB0aGlzLmZvcm1hdFVuaXRzKCksXG4gICAgICBmaXhQcmVmaXg6IHRoaXMuZml4UHJlZml4XG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogSW5zdGFudGlhdGUgYSBVbml0IGZyb20gYSBKU09OIG9iamVjdFxuICAgKiBAbWVtYmVyb2YgVW5pdFxuICAgKiBAcGFyYW0ge09iamVjdH0ganNvbiAgQSBKU09OIG9iamVjdCBzdHJ1Y3R1cmVkIGFzOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgYHtcIm1hdGhqc1wiOiBcIlVuaXRcIiwgXCJ2YWx1ZVwiOiAyLCBcInVuaXRcIjogXCJjbVwiLCBcImZpeFByZWZpeFwiOiBmYWxzZX1gXG4gICAqIEByZXR1cm4ge1VuaXR9XG4gICAqL1xuICBVbml0LmZyb21KU09OID0gZnVuY3Rpb24gKGpzb24pIHtcbiAgICB2YXIgdW5pdCA9IG5ldyBVbml0KGpzb24udmFsdWUsIGpzb24udW5pdCk7XG4gICAgdW5pdC5maXhQcmVmaXggPSBqc29uLmZpeFByZWZpeCB8fCBmYWxzZTtcbiAgICByZXR1cm4gdW5pdDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB1bml0LlxuICAgKiBAbWVtYmVyb2YgVW5pdFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBVbml0LnByb3RvdHlwZS52YWx1ZU9mID0gVW5pdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbiAgLyoqXG4gICAqIEF0dGVtcHQgdG8gc2ltcGxpZnkgdGhlIGxpc3Qgb2YgdW5pdHMgZm9yIHRoaXMgdW5pdCBhY2NvcmRpbmcgdG8gdGhlIGRpbWVuc2lvbnMgYXJyYXkgYW5kIHRoZSBjdXJyZW50IHVuaXQgc3lzdGVtLiBBZnRlciB0aGUgY2FsbCwgdGhpcyBVbml0IHdpbGwgY29udGFpbiBhIGxpc3Qgb2YgdGhlIFwiYmVzdFwiIHVuaXRzIGZvciBmb3JtYXR0aW5nLlxuICAgKiBJbnRlbmRlZCB0byBiZSBldmFsdWF0ZWQgbGF6aWx5LiBZb3UgbXVzdCBzZXQgaXNVbml0TGlzdFNpbXBsaWZpZWQgPSBmYWxzZSBiZWZvcmUgdGhlIGNhbGwhIEFmdGVyIHRoZSBjYWxsLCBpc1VuaXRMaXN0U2ltcGxpZmllZCB3aWxsIGJlIHNldCB0byB0cnVlLlxuICAgKi9cbiAgVW5pdC5wcm90b3R5cGUuc2ltcGxpZnlVbml0TGlzdExhenkgPSBmdW5jdGlvbigpIHtcblxuICAgIGlmICh0aGlzLmlzVW5pdExpc3RTaW1wbGlmaWVkIHx8IHRoaXMudmFsdWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcm9wb3NlZFVuaXRMaXN0ID0gW107XG5cbiAgICAvLyBTZWFyY2ggZm9yIGEgbWF0Y2hpbmcgYmFzZVxuICAgIHZhciBtYXRjaGluZ0Jhc2U7XG4gICAgZm9yKHZhciBrZXkgaW4gY3VycmVudFVuaXRTeXN0ZW0pIHtcbiAgICAgIGlmKHRoaXMuaGFzQmFzZShCQVNFX1VOSVRTW2tleV0pKSB7XG4gICAgICAgIG1hdGNoaW5nQmFzZSA9IGtleTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYobWF0Y2hpbmdCYXNlID09PSAnTk9ORScpXG4gICAge1xuICAgICAgdGhpcy51bml0cyA9IFtdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBtYXRjaGluZ1VuaXQ7XG4gICAgICBpZihtYXRjaGluZ0Jhc2UpIHtcbiAgICAgICAgLy8gRG9lcyB0aGUgdW5pdCBzeXN0ZW0gaGF2ZSBhIG1hdGNoaW5nIHVuaXQ/XG4gICAgICAgIGlmKGN1cnJlbnRVbml0U3lzdGVtLmhhc093blByb3BlcnR5KG1hdGNoaW5nQmFzZSkpIHtcbiAgICAgICAgICBtYXRjaGluZ1VuaXQgPSBjdXJyZW50VW5pdFN5c3RlbVttYXRjaGluZ0Jhc2VdXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlO1xuICAgICAgdmFyIHN0cjtcbiAgICAgIGlmKG1hdGNoaW5nVW5pdCkge1xuICAgICAgICB0aGlzLnVuaXRzID0gW3tcbiAgICAgICAgICB1bml0OiBtYXRjaGluZ1VuaXQudW5pdCxcbiAgICAgICAgICBwcmVmaXg6IG1hdGNoaW5nVW5pdC5wcmVmaXgsXG4gICAgICAgICAgcG93ZXI6IDEuMFxuICAgICAgICB9XTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBNdWx0aXBsZSB1bml0cyBvciB1bml0cyB3aXRoIHBvd2VycyBhcmUgZm9ybWF0dGVkIGxpa2UgdGhpczpcbiAgICAgICAgLy8gNSAoa2cgbV4yKSAvIChzXjMgbW9sKVxuICAgICAgICAvLyBCdWlsZCBhbiByZXByZXNlbnRhdGlvbiBmcm9tIHRoZSBiYXNlIHVuaXRzIG9mIHRoZSBjdXJyZW50IHVuaXQgc3lzdGVtXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPEJBU0VfRElNRU5TSU9OUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBiYXNlRGltID0gQkFTRV9ESU1FTlNJT05TW2ldO1xuICAgICAgICAgIGlmKE1hdGguYWJzKHRoaXMuZGltZW5zaW9uc1tpXSkgPiAxZS0xMikge1xuICAgICAgICAgICAgcHJvcG9zZWRVbml0TGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgdW5pdDogY3VycmVudFVuaXRTeXN0ZW1bYmFzZURpbV0udW5pdCxcbiAgICAgICAgICAgICAgcHJlZml4OiBjdXJyZW50VW5pdFN5c3RlbVtiYXNlRGltXS5wcmVmaXgsXG4gICAgICAgICAgICAgIHBvd2VyOiB0aGlzLmRpbWVuc2lvbnNbaV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElzIHRoZSBwcm9wb3NlZCB1bml0IGxpc3QgXCJzaW1wbGVyXCIgdGhhbiB0aGUgZXhpc3Rpbmcgb25lP1xuICAgICAgICBpZihwcm9wb3NlZFVuaXRMaXN0Lmxlbmd0aCA8IHRoaXMudW5pdHMubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gUmVwbGFjZSB0aGlzIHVuaXQgbGlzdCB3aXRoIHRoZSBwcm9wb3NlZCBsaXN0XG4gICAgICAgICAgdGhpcy51bml0cyA9IHByb3Bvc2VkVW5pdExpc3Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmlzVW5pdExpc3RTaW1wbGlmaWVkID0gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB1bml0cyBvZiB0aGlzIFVuaXQsIHdpdGhvdXQgdGhlIHZhbHVlLlxuICAgKiBAbWVtYmVyb2YgVW5pdFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBVbml0LnByb3RvdHlwZS5mb3JtYXRVbml0cyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIExhenkgZXZhbHVhdGlvbiBvZiB0aGUgdW5pdCBsaXN0XG4gICAgdGhpcy5zaW1wbGlmeVVuaXRMaXN0TGF6eSgpO1xuXG4gICAgdmFyIHN0ck51bSA9IFwiXCI7XG4gICAgdmFyIHN0ckRlbiA9IFwiXCI7XG4gICAgdmFyIG5OdW0gPSAwO1xuICAgIHZhciBuRGVuID0gMDtcblxuICAgIGZvcih2YXIgaT0wOyBpPHRoaXMudW5pdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmKHRoaXMudW5pdHNbaV0ucG93ZXIgPiAwKSB7XG4gICAgICAgIG5OdW0rKztcbiAgICAgICAgc3RyTnVtICs9IFwiIFwiICsgdGhpcy51bml0c1tpXS5wcmVmaXgubmFtZSArIHRoaXMudW5pdHNbaV0udW5pdC5uYW1lO1xuICAgICAgICBpZihNYXRoLmFicyh0aGlzLnVuaXRzW2ldLnBvd2VyIC0gMS4wKSA+IDFlLTE1KSB7XG4gICAgICAgICAgc3RyTnVtICs9IFwiXlwiICsgdGhpcy51bml0c1tpXS5wb3dlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZih0aGlzLnVuaXRzW2ldLnBvd2VyIDwgMCkge1xuICAgICAgICBuRGVuKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYobkRlbiA+IDApIHtcbiAgICAgIGZvcih2YXIgaT0wOyBpPHRoaXMudW5pdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYodGhpcy51bml0c1tpXS5wb3dlciA8IDApIHtcbiAgICAgICAgICBpZihuTnVtID4gMCkge1xuICAgICAgICAgICAgc3RyRGVuICs9IFwiIFwiICsgdGhpcy51bml0c1tpXS5wcmVmaXgubmFtZSArIHRoaXMudW5pdHNbaV0udW5pdC5uYW1lO1xuICAgICAgICAgICAgaWYoTWF0aC5hYnModGhpcy51bml0c1tpXS5wb3dlciArIDEuMCkgPiAxZS0xNSkge1xuICAgICAgICAgICAgICBzdHJEZW4gKz0gXCJeXCIgKyAoLXRoaXMudW5pdHNbaV0ucG93ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0ckRlbiArPSBcIiBcIiArIHRoaXMudW5pdHNbaV0ucHJlZml4Lm5hbWUgKyB0aGlzLnVuaXRzW2ldLnVuaXQubmFtZTtcbiAgICAgICAgICAgIHN0ckRlbiArPSBcIl5cIiArICh0aGlzLnVuaXRzW2ldLnBvd2VyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmVtb3ZlIGxlYWRpbmcgXCIgXCJcbiAgICBzdHJOdW0gPSBzdHJOdW0uc3Vic3RyKDEpO1xuICAgIHN0ckRlbiA9IHN0ckRlbi5zdWJzdHIoMSk7XG5cbiAgICAvLyBBZGQgcGFyYW5zIGZvciBiZXR0ZXIgY29weS9wYXN0ZSBiYWNrIGludG8gdGhlIGV2YWwsIGZvciBleGFtcGxlLCBvciBmb3IgYmV0dGVyIHByZXR0eSBwcmludCBmb3JtYXR0aW5nXG4gICAgaWYobk51bSA+IDEgJiYgbkRlbiA+IDApIHtcbiAgICAgIHN0ck51bSA9IFwiKFwiICsgc3RyTnVtICsgXCIpXCI7XG4gICAgfVxuICAgIGlmKG5EZW4gPiAxICYmIG5OdW0gPiAwKSB7XG4gICAgICBzdHJEZW4gPSBcIihcIiArIHN0ckRlbiArIFwiKVwiO1xuICAgIH1cblxuICAgIHZhciBzdHIgPSBzdHJOdW07XG4gICAgaWYobk51bSA+IDAgJiYgbkRlbiA+IDApIHtcbiAgICAgIHN0ciArPSBcIiAvIFwiO1xuICAgIH1cbiAgICBzdHIgKz0gc3RyRGVuO1xuXG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBVbml0LCB3aXRoIG9wdGlvbmFsIGZvcm1hdHRpbmcgb3B0aW9ucy5cbiAgICogQG1lbWJlcm9mIFVuaXRcbiAgICogQHBhcmFtIHtPYmplY3QgfCBudW1iZXIgfCBGdW5jdGlvbn0gW29wdGlvbnNdICBGb3JtYXR0aW5nIG9wdGlvbnMuIFNlZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpYi91dGlscy9udW1iZXI6Zm9ybWF0IGZvciBhXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gb2YgdGhlIGF2YWlsYWJsZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIFVuaXQucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cbiAgICAvLyBTaW1wbGZ5IHRoZSB1bml0IGxpc3QsIGlmIG5lY2Vzc2FyeVxuICAgIHRoaXMuc2ltcGxpZnlVbml0TGlzdExhenkoKTtcblxuICAgIC8vIEFwcGx5IHNvbWUgY3VzdG9tIGxvZ2ljIGZvciBoYW5kbGluZyBWQSBhbmQgVkFSLiBUaGUgZ29hbCBpcyB0byBleHByZXNzIHRoZSB2YWx1ZSBvZiB0aGUgdW5pdCBhcyBhIHJlYWwgdmFsdWUsIGlmIHBvc3NpYmxlLiBPdGhlcndpc2UsIHVzZSBhIHJlYWwtdmFsdWVkIHVuaXQgaW5zdGVhZCBvZiBhIGNvbXBsZXgtdmFsdWVkIG9uZS5cbiAgICB2YXIgaXNJbWFnaW5hcnkgPSBmYWxzZTtcbiAgICB2YXIgaXNSZWFsID0gdHJ1ZTtcbiAgICBpZih0eXBlb2YodGhpcy52YWx1ZSkgIT09ICd1bmRlZmluZWQnICYmIHRoaXMudmFsdWUgIT09IG51bGwgJiYgdGhpcy52YWx1ZS5pc0NvbXBsZXgpIHtcbiAgICAgIC8vIFRPRE86IE1ha2UgdGhpcyBiZXR0ZXIsIGZvciBleGFtcGxlLCB1c2UgcmVsYXRpdmUgbWFnbml0dWRlIG9mIHJlIGFuZCBpbSByYXRoZXIgdGhhbiBhYnNvbHV0ZVxuICAgICAgaXNJbWFnaW5hcnkgPSBNYXRoLmFicyh0aGlzLnZhbHVlLnJlKSA8IDFlLTE0O1xuICAgICAgaXNSZWFsID0gTWF0aC5hYnModGhpcy52YWx1ZS5pbSkgPCAxZS0xNDtcbiAgICB9XG4gICAgXG4gICAgZm9yKHZhciBpIGluIHRoaXMudW5pdHMpIHtcbiAgICAgIGlmKHRoaXMudW5pdHNbaV0udW5pdCkge1xuICAgICAgICBpZih0aGlzLnVuaXRzW2ldLnVuaXQubmFtZSA9PT0gJ1ZBJyAmJiBpc0ltYWdpbmFyeSkge1xuICAgICAgICAgIHRoaXMudW5pdHNbaV0udW5pdCA9IFVOSVRTW1wiVkFSXCJdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYodGhpcy51bml0c1tpXS51bml0Lm5hbWUgPT09ICdWQVInICYmICFpc0ltYWdpbmFyeSkge1xuICAgICAgICAgIHRoaXMudW5pdHNbaV0udW5pdCA9IFVOSVRTW1wiVkFcIl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cblxuICAgIC8vIE5vdyBhcHBseSB0aGUgYmVzdCBwcmVmaXhcbiAgICAvLyBVbml0cyBtdXN0IGhhdmUgb25seSBvbmUgdW5pdCBhbmQgbm90IGhhdmUgdGhlIGZpeFByZWZpeCBmbGFnIHNldFxuICAgIGlmICh0aGlzLnVuaXRzLmxlbmd0aCA9PT0gMSAmJiAhdGhpcy5maXhQcmVmaXgpIHtcbiAgICAgIC8vIFVuaXRzIG11c3QgaGF2ZSBpbnRlZ2VyIHBvd2Vycywgb3RoZXJ3aXNlIHRoZSBwcmVmaXggd2lsbCBjaGFuZ2UgdGhlXG4gICAgICAvLyBvdXRwdXR0ZWQgdmFsdWUgYnkgbm90LWFuLWludGVnZXItcG93ZXItb2YtdGVuXG4gICAgICBpZiAoTWF0aC5hYnModGhpcy51bml0c1swXS5wb3dlciAtIE1hdGgucm91bmQodGhpcy51bml0c1swXS5wb3dlcikpIDwgMWUtMTQpIHtcbiAgICAgICAgLy8gQXBwbHkgdGhlIGJlc3QgcHJlZml4XG4gICAgICAgIHRoaXMudW5pdHNbMF0ucHJlZml4ID0gdGhpcy5fYmVzdFByZWZpeCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IHRoaXMuX2Rlbm9ybWFsaXplKHRoaXMudmFsdWUpO1xuICAgIHZhciBzdHIgPSAodGhpcy52YWx1ZSAhPT0gbnVsbCkgPyBmb3JtYXQodmFsdWUsIG9wdGlvbnMgfHwge30pIDogJyc7XG4gICAgdmFyIHVuaXRTdHIgPSB0aGlzLmZvcm1hdFVuaXRzKCk7XG4gICAgaWYodGhpcy52YWx1ZSAmJiB0aGlzLnZhbHVlLmlzQ29tcGxleCkge1xuICAgICAgc3RyID0gXCIoXCIgKyBzdHIgKyBcIilcIjsgICAgLy8gU3Vycm91bmQgY29tcGxleCB2YWx1ZXMgd2l0aCAoICkgdG8gZW5hYmxlIGJldHRlciBwYXJzaW5nIFxuICAgIH1cbiAgICBpZih1bml0U3RyLmxlbmd0aCA+IDAgJiYgc3RyLmxlbmd0aCA+IDApIHtcbiAgICAgIHN0ciArPSBcIiBcIjtcbiAgICB9XG4gICAgc3RyICs9IHVuaXRTdHI7XG5cbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGJlc3QgcHJlZml4IHVzaW5nIGN1cnJlbnQgdmFsdWUuXG4gICAqIEBtZW1iZXJvZiBVbml0XG4gICAqIEByZXR1cm5zIHtPYmplY3R9IHByZWZpeFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgVW5pdC5wcm90b3R5cGUuX2Jlc3RQcmVmaXggPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMudW5pdHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gb25seSBjb21wdXRlIHRoZSBiZXN0IHByZWZpeCBmb3Igc2luZ2xlIHVuaXRzIHdpdGggaW50ZWdlciBwb3dlcnMsIGxpa2Uga2csIHNeMiwgTl4tMSwgYW5kIHNvIGZvcnRoIVwiKTtcbiAgICB9XG4gICAgaWYgKE1hdGguYWJzKHRoaXMudW5pdHNbMF0ucG93ZXIgLSBNYXRoLnJvdW5kKHRoaXMudW5pdHNbMF0ucG93ZXIpKSA+PSAxZS0xNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG9ubHkgY29tcHV0ZSB0aGUgYmVzdCBwcmVmaXggZm9yIHNpbmdsZSB1bml0cyB3aXRoIGludGVnZXIgcG93ZXJzLCBsaWtlIGtnLCBzXjIsIE5eLTEsIGFuZCBzbyBmb3J0aCFcIik7XG4gICAgfVxuXG4gICAgLy8gZmluZCB0aGUgYmVzdCBwcmVmaXggdmFsdWUgKHJlc3VsdGluZyBpbiB0aGUgdmFsdWUgb2Ygd2hpY2hcbiAgICAvLyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhlIGxvZzEwIGlzIGNsb3Nlc3QgdG8gemVybyxcbiAgICAvLyB0aG91Z2ggd2l0aCBhIGxpdHRsZSBvZmZzZXQgb2YgMS4yIGZvciBuaWNlciB2YWx1ZXM6IHlvdSBnZXQgYVxuICAgIC8vIHNlcXVlbmNlIDFtbSAxMDBtbSA1MDBtbSAwLjZtIDFtIDEwbSAxMDBtIDUwMG0gMC42a20gMWttIC4uLlxuXG4gICAgLy8gTm90ZTogdGhlIHVuaXRzIHZhbHVlIGNhbiBiZSBhbnkgbnVtZXJpYyB0eXBlLCBidXQgdG8gZmluZCB0aGUgYmVzdFxuICAgIC8vIHByZWZpeCBpdCdzIGVub3VnaCB0byB3b3JrIHdpdGggbGltaXRlZCBwcmVjaXNpb24gb2YgYSByZWd1bGFyIG51bWJlclxuICAgIC8vIFVwZGF0ZTogdXNpbmcgbWF0aGpzIGFicyBzaW5jZSB3ZSBhbHNvIGFsbG93IGNvbXBsZXggbnVtYmVyc1xuICAgIHZhciBhYnNWYWx1ZSA9IGFicyh0aGlzLnZhbHVlKTtcbiAgICB2YXIgYWJzVW5pdFZhbHVlID0gYWJzKHRoaXMudW5pdHNbMF0udW5pdC52YWx1ZSk7XG4gICAgdmFyIGJlc3RQcmVmaXggPSB0aGlzLnVuaXRzWzBdLnByZWZpeDtcbiAgICBpZiAoYWJzVmFsdWUgPT09IDApIHtcbiAgICAgIHJldHVybiBiZXN0UHJlZml4O1xuICAgIH1cbiAgICB2YXIgcG93ZXIgPSB0aGlzLnVuaXRzWzBdLnBvd2VyO1xuICAgIHZhciBiZXN0RGlmZiA9IE1hdGguYWJzKFxuICAgICAgICBNYXRoLmxvZyhhYnNWYWx1ZSAvIE1hdGgucG93KGJlc3RQcmVmaXgudmFsdWUgKiBhYnNVbml0VmFsdWUsIHBvd2VyKSkgLyBNYXRoLkxOMTAgLSAxLjIpO1xuXG4gICAgdmFyIHByZWZpeGVzID0gdGhpcy51bml0c1swXS51bml0LnByZWZpeGVzO1xuICAgIGZvciAodmFyIHAgaW4gcHJlZml4ZXMpIHtcbiAgICAgIGlmIChwcmVmaXhlcy5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgICB2YXIgcHJlZml4ID0gcHJlZml4ZXNbcF07XG4gICAgICAgIGlmIChwcmVmaXguc2NpZW50aWZpYykge1xuXG4gICAgICAgICAgdmFyIGRpZmYgPSBNYXRoLmFicyhcbiAgICAgICAgICAgICAgTWF0aC5sb2coYWJzVmFsdWUgLyBNYXRoLnBvdyhwcmVmaXgudmFsdWUgKiBhYnNVbml0VmFsdWUsIHBvd2VyKSkgLyBNYXRoLkxOMTAgLSAxLjIpO1xuXG4gICAgICAgICAgaWYgKGRpZmYgPCBiZXN0RGlmZlxuICAgICAgICAgICAgICB8fCAoZGlmZiA9PT0gYmVzdERpZmYgJiYgcHJlZml4Lm5hbWUubGVuZ3RoIDwgYmVzdFByZWZpeC5uYW1lLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAvLyBjaG9vc2UgdGhlIHByZWZpeCB3aXRoIHRoZSBzbWFsbGVzdCBkaWZmLCBvciBpZiBlcXVhbCwgY2hvb3NlIHRoZSBvbmVcbiAgICAgICAgICAgICAgICAvLyB3aXRoIHRoZSBzaG9ydGVzdCBuYW1lIChjYW4gaGFwcGVuIHdpdGggU0hPUlRMT05HIGZvciBleGFtcGxlKVxuICAgICAgICAgICAgICAgIGJlc3RQcmVmaXggPSBwcmVmaXg7XG4gICAgICAgICAgICAgICAgYmVzdERpZmYgPSBkaWZmO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBiZXN0UHJlZml4O1xuICB9O1xuXG4gIHZhciBQUkVGSVhFUyA9IHtcbiAgICBOT05FOiB7XG4gICAgICAnJzoge25hbWU6ICcnLCB2YWx1ZTogMSwgc2NpZW50aWZpYzogdHJ1ZX1cbiAgICB9LFxuICAgIFNIT1JUOiB7XG4gICAgICAnJzoge25hbWU6ICcnLCB2YWx1ZTogMSwgc2NpZW50aWZpYzogdHJ1ZX0sXG5cbiAgICAgICdkYSc6IHtuYW1lOiAnZGEnLCB2YWx1ZTogMWUxLCBzY2llbnRpZmljOiBmYWxzZX0sXG4gICAgICAnaCc6IHtuYW1lOiAnaCcsIHZhbHVlOiAxZTIsIHNjaWVudGlmaWM6IGZhbHNlfSxcbiAgICAgICdrJzoge25hbWU6ICdrJywgdmFsdWU6IDFlMywgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnTSc6IHtuYW1lOiAnTScsIHZhbHVlOiAxZTYsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ0cnOiB7bmFtZTogJ0cnLCB2YWx1ZTogMWU5LCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICdUJzoge25hbWU6ICdUJywgdmFsdWU6IDFlMTIsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ1AnOiB7bmFtZTogJ1AnLCB2YWx1ZTogMWUxNSwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnRSc6IHtuYW1lOiAnRScsIHZhbHVlOiAxZTE4LCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICdaJzoge25hbWU6ICdaJywgdmFsdWU6IDFlMjEsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ1knOiB7bmFtZTogJ1knLCB2YWx1ZTogMWUyNCwgc2NpZW50aWZpYzogdHJ1ZX0sXG5cbiAgICAgICdkJzoge25hbWU6ICdkJywgdmFsdWU6IDFlLTEsIHNjaWVudGlmaWM6IGZhbHNlfSxcbiAgICAgICdjJzoge25hbWU6ICdjJywgdmFsdWU6IDFlLTIsIHNjaWVudGlmaWM6IGZhbHNlfSxcbiAgICAgICdtJzoge25hbWU6ICdtJywgdmFsdWU6IDFlLTMsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ3UnOiB7bmFtZTogJ3UnLCB2YWx1ZTogMWUtNiwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnbic6IHtuYW1lOiAnbicsIHZhbHVlOiAxZS05LCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICdwJzoge25hbWU6ICdwJywgdmFsdWU6IDFlLTEyLCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICdmJzoge25hbWU6ICdmJywgdmFsdWU6IDFlLTE1LCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICdhJzoge25hbWU6ICdhJywgdmFsdWU6IDFlLTE4LCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICd6Jzoge25hbWU6ICd6JywgdmFsdWU6IDFlLTIxLCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICd5Jzoge25hbWU6ICd5JywgdmFsdWU6IDFlLTI0LCBzY2llbnRpZmljOiB0cnVlfVxuICAgIH0sXG4gICAgTE9ORzoge1xuICAgICAgJyc6IHtuYW1lOiAnJywgdmFsdWU6IDEsIHNjaWVudGlmaWM6IHRydWV9LFxuXG4gICAgICAnZGVjYSc6IHtuYW1lOiAnZGVjYScsIHZhbHVlOiAxZTEsIHNjaWVudGlmaWM6IGZhbHNlfSxcbiAgICAgICdoZWN0byc6IHtuYW1lOiAnaGVjdG8nLCB2YWx1ZTogMWUyLCBzY2llbnRpZmljOiBmYWxzZX0sXG4gICAgICAna2lsbyc6IHtuYW1lOiAna2lsbycsIHZhbHVlOiAxZTMsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ21lZ2EnOiB7bmFtZTogJ21lZ2EnLCB2YWx1ZTogMWU2LCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICdnaWdhJzoge25hbWU6ICdnaWdhJywgdmFsdWU6IDFlOSwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAndGVyYSc6IHtuYW1lOiAndGVyYScsIHZhbHVlOiAxZTEyLCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICdwZXRhJzoge25hbWU6ICdwZXRhJywgdmFsdWU6IDFlMTUsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ2V4YSc6IHtuYW1lOiAnZXhhJywgdmFsdWU6IDFlMTgsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ3pldHRhJzoge25hbWU6ICd6ZXR0YScsIHZhbHVlOiAxZTIxLCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICd5b3R0YSc6IHtuYW1lOiAneW90dGEnLCB2YWx1ZTogMWUyNCwgc2NpZW50aWZpYzogdHJ1ZX0sXG5cbiAgICAgICdkZWNpJzoge25hbWU6ICdkZWNpJywgdmFsdWU6IDFlLTEsIHNjaWVudGlmaWM6IGZhbHNlfSxcbiAgICAgICdjZW50aSc6IHtuYW1lOiAnY2VudGknLCB2YWx1ZTogMWUtMiwgc2NpZW50aWZpYzogZmFsc2V9LFxuICAgICAgJ21pbGxpJzoge25hbWU6ICdtaWxsaScsIHZhbHVlOiAxZS0zLCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICdtaWNybyc6IHtuYW1lOiAnbWljcm8nLCB2YWx1ZTogMWUtNiwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnbmFubyc6IHtuYW1lOiAnbmFubycsIHZhbHVlOiAxZS05LCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICdwaWNvJzoge25hbWU6ICdwaWNvJywgdmFsdWU6IDFlLTEyLCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICdmZW10byc6IHtuYW1lOiAnZmVtdG8nLCB2YWx1ZTogMWUtMTUsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ2F0dG8nOiB7bmFtZTogJ2F0dG8nLCB2YWx1ZTogMWUtMTgsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ3plcHRvJzoge25hbWU6ICd6ZXB0bycsIHZhbHVlOiAxZS0yMSwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAneW9jdG8nOiB7bmFtZTogJ3lvY3RvJywgdmFsdWU6IDFlLTI0LCBzY2llbnRpZmljOiB0cnVlfVxuICAgIH0sXG4gICAgU1FVQVJFRDoge1xuICAgICAgJyc6IHtuYW1lOiAnJywgdmFsdWU6IDEsIHNjaWVudGlmaWM6IHRydWV9LFxuXG4gICAgICAnZGEnOiB7bmFtZTogJ2RhJywgdmFsdWU6IDFlMiwgc2NpZW50aWZpYzogZmFsc2V9LFxuICAgICAgJ2gnOiB7bmFtZTogJ2gnLCB2YWx1ZTogMWU0LCBzY2llbnRpZmljOiBmYWxzZX0sXG4gICAgICAnayc6IHtuYW1lOiAnaycsIHZhbHVlOiAxZTYsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ00nOiB7bmFtZTogJ00nLCB2YWx1ZTogMWUxMiwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnRyc6IHtuYW1lOiAnRycsIHZhbHVlOiAxZTE4LCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICdUJzoge25hbWU6ICdUJywgdmFsdWU6IDFlMjQsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ1AnOiB7bmFtZTogJ1AnLCB2YWx1ZTogMWUzMCwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnRSc6IHtuYW1lOiAnRScsIHZhbHVlOiAxZTM2LCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICdaJzoge25hbWU6ICdaJywgdmFsdWU6IDFlNDIsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ1knOiB7bmFtZTogJ1knLCB2YWx1ZTogMWU0OCwgc2NpZW50aWZpYzogdHJ1ZX0sXG5cbiAgICAgICdkJzoge25hbWU6ICdkJywgdmFsdWU6IDFlLTIsIHNjaWVudGlmaWM6IGZhbHNlfSxcbiAgICAgICdjJzoge25hbWU6ICdjJywgdmFsdWU6IDFlLTQsIHNjaWVudGlmaWM6IGZhbHNlfSxcbiAgICAgICdtJzoge25hbWU6ICdtJywgdmFsdWU6IDFlLTYsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ3UnOiB7bmFtZTogJ3UnLCB2YWx1ZTogMWUtMTIsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ24nOiB7bmFtZTogJ24nLCB2YWx1ZTogMWUtMTgsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ3AnOiB7bmFtZTogJ3AnLCB2YWx1ZTogMWUtMjQsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ2YnOiB7bmFtZTogJ2YnLCB2YWx1ZTogMWUtMzAsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ2EnOiB7bmFtZTogJ2EnLCB2YWx1ZTogMWUtMzYsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ3onOiB7bmFtZTogJ3onLCB2YWx1ZTogMWUtNDIsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ3knOiB7bmFtZTogJ3knLCB2YWx1ZTogMWUtNDgsIHNjaWVudGlmaWM6IHRydWV9XG4gICAgfSxcbiAgICBDVUJJQzoge1xuICAgICAgJyc6IHtuYW1lOiAnJywgdmFsdWU6IDEsIHNjaWVudGlmaWM6IHRydWV9LFxuXG4gICAgICAnZGEnOiB7bmFtZTogJ2RhJywgdmFsdWU6IDFlMywgc2NpZW50aWZpYzogZmFsc2V9LFxuICAgICAgJ2gnOiB7bmFtZTogJ2gnLCB2YWx1ZTogMWU2LCBzY2llbnRpZmljOiBmYWxzZX0sXG4gICAgICAnayc6IHtuYW1lOiAnaycsIHZhbHVlOiAxZTksIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ00nOiB7bmFtZTogJ00nLCB2YWx1ZTogMWUxOCwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnRyc6IHtuYW1lOiAnRycsIHZhbHVlOiAxZTI3LCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICdUJzoge25hbWU6ICdUJywgdmFsdWU6IDFlMzYsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ1AnOiB7bmFtZTogJ1AnLCB2YWx1ZTogMWU0NSwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnRSc6IHtuYW1lOiAnRScsIHZhbHVlOiAxZTU0LCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICdaJzoge25hbWU6ICdaJywgdmFsdWU6IDFlNjMsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ1knOiB7bmFtZTogJ1knLCB2YWx1ZTogMWU3Miwgc2NpZW50aWZpYzogdHJ1ZX0sXG5cbiAgICAgICdkJzoge25hbWU6ICdkJywgdmFsdWU6IDFlLTMsIHNjaWVudGlmaWM6IGZhbHNlfSxcbiAgICAgICdjJzoge25hbWU6ICdjJywgdmFsdWU6IDFlLTYsIHNjaWVudGlmaWM6IGZhbHNlfSxcbiAgICAgICdtJzoge25hbWU6ICdtJywgdmFsdWU6IDFlLTksIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ3UnOiB7bmFtZTogJ3UnLCB2YWx1ZTogMWUtMTgsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ24nOiB7bmFtZTogJ24nLCB2YWx1ZTogMWUtMjcsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ3AnOiB7bmFtZTogJ3AnLCB2YWx1ZTogMWUtMzYsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ2YnOiB7bmFtZTogJ2YnLCB2YWx1ZTogMWUtNDUsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ2EnOiB7bmFtZTogJ2EnLCB2YWx1ZTogMWUtNTQsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ3onOiB7bmFtZTogJ3onLCB2YWx1ZTogMWUtNjMsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ3knOiB7bmFtZTogJ3knLCB2YWx1ZTogMWUtNzIsIHNjaWVudGlmaWM6IHRydWV9XG4gICAgfSxcbiAgICBCSU5BUllfU0hPUlQ6IHtcbiAgICAgICcnOiB7bmFtZTogJycsIHZhbHVlOiAxLCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICdrJzoge25hbWU6ICdrJywgdmFsdWU6IDFlMywgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnTSc6IHtuYW1lOiAnTScsIHZhbHVlOiAxZTYsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ0cnOiB7bmFtZTogJ0cnLCB2YWx1ZTogMWU5LCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICdUJzoge25hbWU6ICdUJywgdmFsdWU6IDFlMTIsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ1AnOiB7bmFtZTogJ1AnLCB2YWx1ZTogMWUxNSwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnRSc6IHtuYW1lOiAnRScsIHZhbHVlOiAxZTE4LCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICdaJzoge25hbWU6ICdaJywgdmFsdWU6IDFlMjEsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ1knOiB7bmFtZTogJ1knLCB2YWx1ZTogMWUyNCwgc2NpZW50aWZpYzogdHJ1ZX0sXG5cbiAgICAgICdLaSc6IHtuYW1lOiAnS2knLCB2YWx1ZTogMTAyNCwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnTWknOiB7bmFtZTogJ01pJywgdmFsdWU6IE1hdGgucG93KDEwMjQsIDIpLCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICdHaSc6IHtuYW1lOiAnR2knLCB2YWx1ZTogTWF0aC5wb3coMTAyNCwgMyksIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ1RpJzoge25hbWU6ICdUaScsIHZhbHVlOiBNYXRoLnBvdygxMDI0LCA0KSwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnUGknOiB7bmFtZTogJ1BpJywgdmFsdWU6IE1hdGgucG93KDEwMjQsIDUpLCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICdFaSc6IHtuYW1lOiAnRWknLCB2YWx1ZTogTWF0aC5wb3coMTAyNCwgNiksIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ1ppJzoge25hbWU6ICdaaScsIHZhbHVlOiBNYXRoLnBvdygxMDI0LCA3KSwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnWWknOiB7bmFtZTogJ1lpJywgdmFsdWU6IE1hdGgucG93KDEwMjQsIDgpLCBzY2llbnRpZmljOiB0cnVlfVxuICAgIH0sXG4gICAgQklOQVJZX0xPTkc6IHtcbiAgICAgICcnOiB7bmFtZTogJycsIHZhbHVlOiAxLCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICdraWxvJzoge25hbWU6ICdraWxvJywgdmFsdWU6IDFlMywgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnbWVnYSc6IHtuYW1lOiAnbWVnYScsIHZhbHVlOiAxZTYsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ2dpZ2EnOiB7bmFtZTogJ2dpZ2EnLCB2YWx1ZTogMWU5LCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICd0ZXJhJzoge25hbWU6ICd0ZXJhJywgdmFsdWU6IDFlMTIsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ3BldGEnOiB7bmFtZTogJ3BldGEnLCB2YWx1ZTogMWUxNSwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnZXhhJzoge25hbWU6ICdleGEnLCB2YWx1ZTogMWUxOCwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnemV0dGEnOiB7bmFtZTogJ3pldHRhJywgdmFsdWU6IDFlMjEsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ3lvdHRhJzoge25hbWU6ICd5b3R0YScsIHZhbHVlOiAxZTI0LCBzY2llbnRpZmljOiB0cnVlfSxcblxuICAgICAgJ2tpYmknOiB7bmFtZTogJ2tpYmknLCB2YWx1ZTogMTAyNCwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnbWViaSc6IHtuYW1lOiAnbWViaScsIHZhbHVlOiBNYXRoLnBvdygxMDI0LCAyKSwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnZ2liaSc6IHtuYW1lOiAnZ2liaScsIHZhbHVlOiBNYXRoLnBvdygxMDI0LCAzKSwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAndGViaSc6IHtuYW1lOiAndGViaScsIHZhbHVlOiBNYXRoLnBvdygxMDI0LCA0KSwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAncGViaSc6IHtuYW1lOiAncGViaScsIHZhbHVlOiBNYXRoLnBvdygxMDI0LCA1KSwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnZXhpJzoge25hbWU6ICdleGknLCB2YWx1ZTogTWF0aC5wb3coMTAyNCwgNiksIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ3plYmknOiB7bmFtZTogJ3plYmknLCB2YWx1ZTogTWF0aC5wb3coMTAyNCwgNyksIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ3lvYmknOiB7bmFtZTogJ3lvYmknLCB2YWx1ZTogTWF0aC5wb3coMTAyNCwgOCksIHNjaWVudGlmaWM6IHRydWV9XG4gICAgfSxcbiAgICBCVFU6IHtcbiAgICAgICcnOiAgIHtuYW1lOiAnJywgICB2YWx1ZTogMSwgICBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICdNTSc6IHtuYW1lOiAnTU0nLCB2YWx1ZTogMWU2LCBzY2llbnRpZmljOiB0cnVlfVxuICAgIH1cbiAgfTtcblxuICAvLyBBZGQgYSBwcmVmaXggbGlzdCBmb3IgYm90aCBzaG9ydCBhbmQgbG9uZyBwcmVmaXhlcyAoZm9yIG9obSBpbiBwYXJ0aWN1bGFyLCBzaW5jZSBNb2htIGFuZCBtZWdhb2htIGFyZSBib3RoIGFjY2VwdGFibGUpOlxuICBQUkVGSVhFUy5TSE9SVExPTkcgPSB7fTtcbiAgZm9yICh2YXIga2V5IGluIFBSRUZJWEVTLlNIT1JUKSB7XG4gICAgaWYoUFJFRklYRVMuU0hPUlQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgUFJFRklYRVMuU0hPUlRMT05HW2tleV0gPSBQUkVGSVhFUy5TSE9SVFtrZXldO1xuICAgIH1cbiAgfVxuICBmb3IgKHZhciBrZXkgaW4gUFJFRklYRVMuTE9ORykge1xuICAgIGlmKFBSRUZJWEVTLkxPTkcuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgUFJFRklYRVMuU0hPUlRMT05HW2tleV0gPSBQUkVGSVhFUy5MT05HW2tleV07XG4gICAgfVxuICB9XG5cbiAgLyogSW50ZXJuYWxseSwgZWFjaCB1bml0IGlzIHJlcHJlc2VudGVkIGJ5IGEgdmFsdWUgYW5kIGEgZGltZW5zaW9uIGFycmF5LiBUaGUgZWxlbWVudHMgb2YgdGhlIGRpbWVuc2lvbnMgYXJyYXkgaGF2ZSB0aGUgZm9sbG93aW5nIG1lYW5pbmc6XG4gICAqIEluZGV4ICBEaW1lbnNpb25cbiAgICogLS0tLS0gIC0tLS0tLS0tLVxuICAgKiAgIDAgICAgTGVuZ3RoXG4gICAqICAgMSAgICBNYXNzXG4gICAqICAgMiAgICBUaW1lXG4gICAqICAgMyAgICBDdXJyZW50XG4gICAqICAgNCAgICBUZW1wZXJhdHVyZVxuICAgKiAgIDUgICAgTHVtaW5vdXMgaW50ZW5zaXR5XG4gICAqICAgNiAgICBBbW91bnQgb2Ygc3Vic3RhbmNlXG4gICAqICAgNyAgICBBbmdsZVxuICAgKiAgIDggICAgQml0IChkaWdpdGFsKVxuICAgKiBGb3IgZXhhbXBsZSwgdGhlIHVuaXQgXCIyOTguMTUgS1wiIGlzIGEgcHVyZSB0ZW1wZXJhdHVyZSBhbmQgd291bGQgaGF2ZSBhIHZhbHVlIG9mIDI5OC4xNSBhbmQgYSBkaW1lbnNpb24gYXJyYXkgb2YgWzAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDBdLiBUaGUgdW5pdCBcIjEgY2FsIC8gKGdtIMKwQylcIiBjYW4gYmUgd3JpdHRlbiBpbiB0ZXJtcyBvZiB0aGUgOSBmdW5kYW1lbnRhbCBkaW1lbnNpb25zIGFzIFtsZW5ndGheMl0gLyAoW3RpbWVeMl0gKiBbdGVtcGVyYXR1cmVdKSwgYW5kIHdvdWxkIGEgdmFsdWUgb2YgKGFmdGVyIGNvbnZlcnNpb24gdG8gU0kpIDQxODQuMCBhbmQgYSBkaW1lbnNpb25zIGFycmF5IG9mIFsyLCAwLCAtMiwgMCwgLTEsIDAsIDAsIDAsIDBdLlxuICAgKlxuICAgKi9cblxuICB2YXIgQkFTRV9ESU1FTlNJT05TID0gW1wiTUFTU1wiLCBcIkxFTkdUSFwiLCBcIlRJTUVcIiwgXCJDVVJSRU5UXCIsIFwiVEVNUEVSQVRVUkVcIiwgXCJMVU1JTk9VU19JTlRFTlNJVFlcIiwgXCJBTU9VTlRfT0ZfU1VCU1RBTkNFXCIsIFwiQU5HTEVcIiwgXCJCSVRcIl07XG5cbiAgdmFyIEJBU0VfVU5JVFMgPSB7XG4gICAgTk9ORToge1xuICAgICAgZGltZW5zaW9uczogWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdXG4gICAgfSxcbiAgICBNQVNTOiB7XG4gICAgICBkaW1lbnNpb25zOiBbMSwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF1cbiAgICB9LFxuICAgIExFTkdUSDoge1xuICAgICAgZGltZW5zaW9uczogWzAsIDEsIDAsIDAsIDAsIDAsIDAsIDAsIDBdXG4gICAgfSxcbiAgICBUSU1FOiB7XG4gICAgICBkaW1lbnNpb25zOiBbMCwgMCwgMSwgMCwgMCwgMCwgMCwgMCwgMF1cbiAgICB9LFxuICAgIENVUlJFTlQ6IHtcbiAgICAgIGRpbWVuc2lvbnM6IFswLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAwXVxuICAgIH0sXG4gICAgVEVNUEVSQVRVUkU6IHtcbiAgICAgIGRpbWVuc2lvbnM6IFswLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwXVxuICAgIH0sXG4gICAgTFVNSU5PVVNfSU5URU5TSVRZOiB7XG4gICAgICBkaW1lbnNpb25zOiBbMCwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMF1cbiAgICB9LFxuICAgIEFNT1VOVF9PRl9TVUJTVEFOQ0U6IHtcbiAgICAgIGRpbWVuc2lvbnM6IFswLCAwLCAwLCAwLCAwLCAwLCAxLCAwLCAwXVxuICAgIH0sXG5cbiAgICBGT1JDRToge1xuICAgICAgZGltZW5zaW9uczogWzEsIDEsIC0yLCAwLCAwLCAwLCAwLCAwLCAwXVxuICAgIH0sXG4gICAgU1VSRkFDRToge1xuICAgICAgZGltZW5zaW9uczogWzAsIDIsIDAsIDAsIDAsIDAsIDAsIDAsIDBdXG4gICAgfSxcbiAgICBWT0xVTUU6IHtcbiAgICAgIGRpbWVuc2lvbnM6IFswLCAzLCAwLCAwLCAwLCAwLCAwLCAwLCAwXVxuICAgIH0sXG4gICAgRU5FUkdZOiB7XG4gICAgICBkaW1lbnNpb25zOiBbMSwgMiwgLTIsIDAsIDAsIDAsIDAsIDAsIDBdXG4gICAgfSxcbiAgICBQT1dFUjoge1xuICAgICAgZGltZW5zaW9uczogWzEsIDIsIC0zLCAwLCAwLCAwLCAwLCAwLCAwXVxuICAgIH0sXG4gICAgUFJFU1NVUkU6IHtcbiAgICAgIGRpbWVuc2lvbnM6IFsxLCAtMSwgLTIsIDAsIDAsIDAsIDAsIDAsIDBdXG4gICAgfSxcblxuICAgIEVMRUNUUklDX0NIQVJHRToge1xuICAgICAgZGltZW5zaW9uczogWzAsIDAsIDEsIDEsIDAsIDAsIDAsIDAsIDBdXG4gICAgfSxcbiAgICBFTEVDVFJJQ19DQVBBQ0lUQU5DRToge1xuICAgICAgZGltZW5zaW9uczogWy0xLCAtMiwgNCwgMiwgMCwgMCwgMCwgMCwgMF1cbiAgICB9LFxuICAgIEVMRUNUUklDX1BPVEVOVElBTDoge1xuICAgICAgZGltZW5zaW9uczogWzEsIDIsIC0zLCAtMSwgMCwgMCwgMCwgMCwgMF1cbiAgICB9LFxuICAgIEVMRUNUUklDX1JFU0lTVEFOQ0U6IHtcbiAgICAgIGRpbWVuc2lvbnM6IFsxLCAyLCAtMywgLTIsIDAsIDAsIDAsIDAsIDBdXG4gICAgfSxcbiAgICBFTEVDVFJJQ19JTkRVQ1RBTkNFOiB7XG4gICAgICBkaW1lbnNpb25zOiBbMSwgMiwgLTIsIC0yLCAwLCAwLCAwLCAwLCAwXVxuICAgIH0sXG4gICAgRUxFQ1RSSUNfQ09ORFVDVEFOQ0U6IHtcbiAgICAgIGRpbWVuc2lvbnM6IFstMSwgLTIsIDMsIDIsIDAsIDAsIDAsIDAsIDBdXG4gICAgfSxcbiAgICBNQUdORVRJQ19GTFVYOiB7XG4gICAgICBkaW1lbnNpb25zOiBbMSwgMiwgLTIsIC0xLCAwLCAwLCAwLCAwLCAwXVxuICAgIH0sXG4gICAgTUFHTkVUSUNfRkxVWF9ERU5TSVRZOiB7XG4gICAgICBkaW1lbnNpb25zOiBbMSwgMCwgLTIsIC0xLCAwLCAwLCAwLCAwLCAwXVxuICAgIH0sXG5cbiAgICBGUkVRVUVOQ1k6IHtcbiAgICAgIGRpbWVuc2lvbnM6IFswLCAwLCAtMSwgMCwgMCwgMCwgMCwgMCwgMF1cbiAgICB9LFxuICAgIEFOR0xFOiB7XG4gICAgICBkaW1lbnNpb25zOiBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMSwgMF1cbiAgICB9LFxuICAgIEJJVDoge1xuICAgICAgZGltZW5zaW9uczogWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDFdXG4gICAgfVxuICB9O1xuXG4gIGZvcih2YXIga2V5IGluIEJBU0VfVU5JVFMpIHtcbiAgICBCQVNFX1VOSVRTW2tleV0ua2V5ID0ga2V5O1xuICB9XG5cbiAgdmFyIEJBU0VfVU5JVF9OT05FID0ge307XG5cbiAgdmFyIFVOSVRfTk9ORSA9IHtuYW1lOiAnJywgYmFzZTogQkFTRV9VTklUX05PTkUsIHZhbHVlOiAxLCBvZmZzZXQ6IDAsIGRpbWVuc2lvbnM6IFswLDAsMCwwLDAsMCwwLDAsMF19O1xuXG4gIHZhciBVTklUUyA9IHtcbiAgICAvLyBsZW5ndGhcbiAgICBtZXRlcjoge1xuICAgICAgbmFtZTogJ21ldGVyJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuTEVOR1RILFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLkxPTkcsXG4gICAgICB2YWx1ZTogMSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgaW5jaDoge1xuICAgICAgbmFtZTogJ2luY2gnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5MRU5HVEgsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAwLjAyNTQsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIGZvb3Q6IHtcbiAgICAgIG5hbWU6ICdmb290JyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuTEVOR1RILFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMC4zMDQ4LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICB5YXJkOiB7XG4gICAgICBuYW1lOiAneWFyZCcsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkxFTkdUSCxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDAuOTE0NCxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgbWlsZToge1xuICAgICAgbmFtZTogJ21pbGUnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5MRU5HVEgsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAxNjA5LjM0NCxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgbGluazoge1xuICAgICAgbmFtZTogJ2xpbmsnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5MRU5HVEgsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAwLjIwMTE2OCxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgcm9kOiB7XG4gICAgICBuYW1lOiAncm9kJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuTEVOR1RILFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogNS4wMjkyMTAsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIGNoYWluOiB7XG4gICAgICBuYW1lOiAnY2hhaW4nLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5MRU5HVEgsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAyMC4xMTY4LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBhbmdzdHJvbToge1xuICAgICAgbmFtZTogJ2FuZ3N0cm9tJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuTEVOR1RILFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMWUtMTAsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuXG4gICAgbToge1xuICAgICAgbmFtZTogJ20nLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5MRU5HVEgsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuU0hPUlQsXG4gICAgICB2YWx1ZTogMSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgJ2luJzoge1xuICAgICAgbmFtZTogJ2luJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuTEVOR1RILFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMC4wMjU0LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBmdDoge1xuICAgICAgbmFtZTogJ2Z0JyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuTEVOR1RILFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMC4zMDQ4LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICB5ZDoge1xuICAgICAgbmFtZTogJ3lkJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuTEVOR1RILFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMC45MTQ0LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBtaToge1xuICAgICAgbmFtZTogJ21pJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuTEVOR1RILFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMTYwOS4zNDQsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIGxpOiB7XG4gICAgICBuYW1lOiAnbGknLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5MRU5HVEgsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAwLjIwMTE2OCxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgcmQ6IHtcbiAgICAgIG5hbWU6ICdyZCcsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkxFTkdUSCxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDUuMDI5MjEwLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBjaDoge1xuICAgICAgbmFtZTogJ2NoJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuTEVOR1RILFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMjAuMTE2OCxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgbWlsOiB7XG4gICAgICBuYW1lOiAnbWlsJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuTEVOR1RILFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMC4wMDAwMjU0LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSwgLy8gMS8xMDAwIGluY2hcblxuICAgIC8vIFN1cmZhY2VcbiAgICBtMjoge1xuICAgICAgbmFtZTogJ20yJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuU1VSRkFDRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5TUVVBUkVELFxuICAgICAgdmFsdWU6IDEsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIHNxaW46IHtcbiAgICAgIG5hbWU6ICdzcWluJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuU1VSRkFDRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDAuMDAwNjQ1MTYsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LCAvLyA2NDUuMTYgbW0yXG4gICAgc3FmdDoge1xuICAgICAgbmFtZTogJ3NxZnQnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5TVVJGQUNFLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMC4wOTI5MDMwNCxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sIC8vIDAuMDkyOTAzMDQgbTJcbiAgICBzcXlkOiB7XG4gICAgICBuYW1lOiAnc3F5ZCcsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlNVUkZBQ0UsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAwLjgzNjEyNzM2LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSwgLy8gMC44MzYxMjczNiBtMlxuICAgIHNxbWk6IHtcbiAgICAgIG5hbWU6ICdzcW1pJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuU1VSRkFDRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDI1ODk5ODguMTEwMzM2LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSwgLy8gMi41ODk5ODgxMTAzMzYga20yXG4gICAgc3FyZDoge1xuICAgICAgbmFtZTogJ3NxcmQnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5TVVJGQUNFLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMjUuMjkyOTUsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LCAvLyAyNS4yOTI5NSBtMlxuICAgIHNxY2g6IHtcbiAgICAgIG5hbWU6ICdzcWNoJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuU1VSRkFDRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDQwNC42ODczLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSwgLy8gNDA0LjY4NzMgbTJcbiAgICBzcW1pbDoge1xuICAgICAgbmFtZTogJ3NxbWlsJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuU1VSRkFDRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDYuNDUxNmUtMTAsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LCAvLyA2LjQ1MTYgKiAxMF4tMTAgbTJcbiAgICBhY3JlOiB7XG4gICAgICBuYW1lOiAnYWNyZScsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlNVUkZBQ0UsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiA0MDQ2Ljg2LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSwgLy8gNDA0Ni44NiBtMlxuICAgIGhlY3RhcmU6IHtcbiAgICAgIG5hbWU6ICdoZWN0YXJlJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuU1VSRkFDRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDEwMDAwLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSwgLy8gMTAwMDAgbTJcblxuICAgIC8vIFZvbHVtZVxuICAgIG0zOiB7XG4gICAgICBuYW1lOiAnbTMnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5WT0xVTUUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuQ1VCSUMsXG4gICAgICB2YWx1ZTogMSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgTDoge1xuICAgICAgbmFtZTogJ0wnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5WT0xVTUUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuU0hPUlQsXG4gICAgICB2YWx1ZTogMC4wMDEsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LCAvLyBsaXRyZVxuICAgIGw6IHtcbiAgICAgIG5hbWU6ICdsJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuVk9MVU1FLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLlNIT1JULFxuICAgICAgdmFsdWU6IDAuMDAxLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSwgLy8gbGl0cmVcbiAgICBsaXRyZToge1xuICAgICAgbmFtZTogJ2xpdHJlJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuVk9MVU1FLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLkxPTkcsXG4gICAgICB2YWx1ZTogMC4wMDEsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIGN1aW46IHtcbiAgICAgIG5hbWU6ICdjdWluJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuVk9MVU1FLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMS42Mzg3MDY0ZS01LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSwgLy8gMS42Mzg3MDY0ZS01IG0zXG4gICAgY3VmdDoge1xuICAgICAgbmFtZTogJ2N1ZnQnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5WT0xVTUUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAwLjAyODMxNjg0NjU5MixcbiAgICAgIG9mZnNldDogMFxuICAgIH0sIC8vIDI4LjMxNiA4NDYgNTkyIExcbiAgICBjdXlkOiB7XG4gICAgICBuYW1lOiAnY3V5ZCcsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlZPTFVNRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDAuNzY0NTU0ODU3OTg0LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSwgLy8gNzY0LjU1NCA4NTcgOTg0IExcbiAgICB0ZWFzcG9vbjoge1xuICAgICAgbmFtZTogJ3RlYXNwb29uJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuVk9MVU1FLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMC4wMDAwMDUsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LCAvLyA1IG1MXG4gICAgdGFibGVzcG9vbjoge1xuICAgICAgbmFtZTogJ3RhYmxlc3Bvb24nLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5WT0xVTUUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAwLjAwMDAxNSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sIC8vIDE1IG1MXG4gICAgLy97bmFtZTogJ2N1cCcsIGJhc2U6IEJBU0VfVU5JVFMuVk9MVU1FLCBwcmVmaXhlczogUFJFRklYRVMuTk9ORSwgdmFsdWU6IDAuMDAwMjQwLCBvZmZzZXQ6IDB9LCAvLyAyNDAgbUwgIC8vIG5vdCBwb3NzaWJsZSwgd2UgaGF2ZSBhbHJlYWR5IGFub3RoZXIgY3VwXG4gICAgZHJvcDoge1xuICAgICAgbmFtZTogJ2Ryb3AnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5WT0xVTUUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiA1ZS04LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSwgIC8vIDAuMDUgbUwgPSA1ZS04IG0zXG4gICAgZ3R0OiB7XG4gICAgICBuYW1lOiAnZ3R0JyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuVk9MVU1FLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogNWUtOCxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sICAvLyAwLjA1IG1MID0gNWUtOCBtM1xuXG4gICAgLy8gTGlxdWlkIHZvbHVtZVxuICAgIG1pbmltOiB7XG4gICAgICBuYW1lOiAnbWluaW0nLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5WT0xVTUUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAwLjAwMDAwMDA2MTYxMTUyLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSwgLy8gMC4wNjE2MTE1MiBtTFxuICAgIGZsdWlkZHJhbToge1xuICAgICAgbmFtZTogJ2ZsdWlkZHJhbScsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlZPTFVNRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDAuMDAwMDAzNjk2NjkxMSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sICAvLyAzLjY5NjY5MSBtTFxuICAgIGZsdWlkb3VuY2U6IHtcbiAgICAgIG5hbWU6ICdmbHVpZG91bmNlJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuVk9MVU1FLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMC4wMDAwMjk1NzM1MyxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sIC8vIDI5LjU3MzUzIG1MXG4gICAgZ2lsbDoge1xuICAgICAgbmFtZTogJ2dpbGwnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5WT0xVTUUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAwLjAwMDExODI5NDEsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LCAvLyAxMTguMjk0MSBtTFxuICAgIGNjOiB7XG4gICAgICBuYW1lOiAnY2MnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5WT0xVTUUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAxZS02LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSwgLy8gMWUtNiBMXG4gICAgY3VwOiB7XG4gICAgICBuYW1lOiAnY3VwJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuVk9MVU1FLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMC4wMDAyMzY1ODgyLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSwgLy8gMjM2LjU4ODIgbUxcbiAgICBwaW50OiB7XG4gICAgICBuYW1lOiAncGludCcsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlZPTFVNRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDAuMDAwNDczMTc2NSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sIC8vIDQ3My4xNzY1IG1MXG4gICAgcXVhcnQ6IHtcbiAgICAgIG5hbWU6ICdxdWFydCcsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlZPTFVNRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDAuMDAwOTQ2MzUyOSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sIC8vIDk0Ni4zNTI5IG1MXG4gICAgZ2FsbG9uOiB7XG4gICAgICBuYW1lOiAnZ2FsbG9uJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuVk9MVU1FLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMC4wMDM3ODU0MTIsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LCAvLyAzLjc4NTQxMiBMXG4gICAgYmVlcmJhcnJlbDoge1xuICAgICAgbmFtZTogJ2JlZXJiYXJyZWwnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5WT0xVTUUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAwLjExNzM0NzgsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LCAvLyAxMTcuMzQ3OCBMXG4gICAgb2lsYmFycmVsOiB7XG4gICAgICBuYW1lOiAnb2lsYmFycmVsJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuVk9MVU1FLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMC4xNTg5ODczLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSwgLy8gMTU4Ljk4NzMgTFxuICAgIGhvZ3NoZWFkOiB7XG4gICAgICBuYW1lOiAnaG9nc2hlYWQnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5WT0xVTUUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAwLjIzODQ4MTAsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LCAvLyAyMzguNDgxMCBMXG5cbiAgICAvL3tuYW1lOiAnbWluJywgYmFzZTogQkFTRV9VTklUUy5WT0xVTUUsIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLCB2YWx1ZTogMC4wMDAwMDAwNjE2MTE1Miwgb2Zmc2V0OiAwfSwgLy8gMC4wNjE2MTE1MiBtTCAvLyBtaW4gaXMgYWxyZWFkeSBpbiB1c2UgYXMgbWludXRlXG4gICAgZmxkcjoge1xuICAgICAgbmFtZTogJ2ZsZHInLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5WT0xVTUUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAwLjAwMDAwMzY5NjY5MTEsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LCAgLy8gMy42OTY2OTEgbUxcbiAgICBmbG96OiB7XG4gICAgICBuYW1lOiAnZmxveicsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlZPTFVNRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDAuMDAwMDI5NTczNTMsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LCAvLyAyOS41NzM1MyBtTFxuICAgIGdpOiB7XG4gICAgICBuYW1lOiAnZ2knLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5WT0xVTUUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAwLjAwMDExODI5NDEsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LCAvLyAxMTguMjk0MSBtTFxuICAgIGNwOiB7XG4gICAgICBuYW1lOiAnY3AnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5WT0xVTUUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAwLjAwMDIzNjU4ODIsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LCAvLyAyMzYuNTg4MiBtTFxuICAgIHB0OiB7XG4gICAgICBuYW1lOiAncHQnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5WT0xVTUUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAwLjAwMDQ3MzE3NjUsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LCAvLyA0NzMuMTc2NSBtTFxuICAgIHF0OiB7XG4gICAgICBuYW1lOiAncXQnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5WT0xVTUUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAwLjAwMDk0NjM1MjksXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LCAvLyA5NDYuMzUyOSBtTFxuICAgIGdhbDoge1xuICAgICAgbmFtZTogJ2dhbCcsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlZPTFVNRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDAuMDAzNzg1NDEyLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSwgLy8gMy43ODU0MTIgTFxuICAgIGJibDoge1xuICAgICAgbmFtZTogJ2JibCcsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlZPTFVNRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDAuMTE3MzQ3OCxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sIC8vIDExNy4zNDc4IExcbiAgICBvYmw6IHtcbiAgICAgIG5hbWU6ICdvYmwnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5WT0xVTUUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAwLjE1ODk4NzMsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LCAvLyAxNTguOTg3MyBMXG4gICAgLy97bmFtZTogJ2hvZ3NoZWFkJywgYmFzZTogQkFTRV9VTklUUy5WT0xVTUUsIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLCB2YWx1ZTogMC4yMzg0ODEwLCBvZmZzZXQ6IDB9LCAvLyAyMzguNDgxMCBMIC8vIFRPRE86IGhoP1xuXG4gICAgLy8gTWFzc1xuICAgIGc6IHtcbiAgICAgIG5hbWU6ICdnJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuTUFTUyxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5TSE9SVCxcbiAgICAgIHZhbHVlOiAwLjAwMSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgZ3JhbToge1xuICAgICAgbmFtZTogJ2dyYW0nLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5NQVNTLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLkxPTkcsXG4gICAgICB2YWx1ZTogMC4wMDEsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuXG4gICAgdG9uOiB7XG4gICAgICBuYW1lOiAndG9uJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuTUFTUyxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5TSE9SVCxcbiAgICAgIHZhbHVlOiA5MDcuMTg0NzQsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIHRvbm5lOiB7XG4gICAgICBuYW1lOiAndG9ubmUnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5NQVNTLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLlNIT1JULFxuICAgICAgdmFsdWU6IDEwMDAsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuXG4gICAgZ3JhaW46IHtcbiAgICAgIG5hbWU6ICdncmFpbicsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLk1BU1MsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiA2NC43OTg5MWUtNixcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgZHJhbToge1xuICAgICAgbmFtZTogJ2RyYW0nLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5NQVNTLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMS43NzE4NDUxOTUzMTI1ZS0zLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBvdW5jZToge1xuICAgICAgbmFtZTogJ291bmNlJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuTUFTUyxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDI4LjM0OTUyMzEyNWUtMyxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgcG91bmRtYXNzOiB7XG4gICAgICBuYW1lOiAncG91bmRtYXNzJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuTUFTUyxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDQ1My41OTIzN2UtMyxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgaHVuZHJlZHdlaWdodDoge1xuICAgICAgbmFtZTogJ2h1bmRyZWR3ZWlnaHQnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5NQVNTLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogNDUuMzU5MjM3LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBzdGljazoge1xuICAgICAgbmFtZTogJ3N0aWNrJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuTUFTUyxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDExNWUtMyxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgc3RvbmU6IHtcbiAgICAgIG5hbWU6ICdzdG9uZScsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLk1BU1MsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiA2LjM1MDI5MzE4LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcblxuICAgIGdyOiB7XG4gICAgICBuYW1lOiAnZ3InLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5NQVNTLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogNjQuNzk4OTFlLTYsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIGRyOiB7XG4gICAgICBuYW1lOiAnZHInLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5NQVNTLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMS43NzE4NDUxOTUzMTI1ZS0zLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBvejoge1xuICAgICAgbmFtZTogJ296JyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuTUFTUyxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDI4LjM0OTUyMzEyNWUtMyxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgbGJtOiB7XG4gICAgICBuYW1lOiAnbGJtJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuTUFTUyxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDQ1My41OTIzN2UtMyxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgY3d0OiB7XG4gICAgICBuYW1lOiAnY3d0JyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuTUFTUyxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDQ1LjM1OTIzNyxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG5cbiAgICAvLyBUaW1lXG4gICAgczoge1xuICAgICAgbmFtZTogJ3MnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5USU1FLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLlNIT1JULFxuICAgICAgdmFsdWU6IDEsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIG1pbjoge1xuICAgICAgbmFtZTogJ21pbicsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlRJTUUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiA2MCxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgaDoge1xuICAgICAgbmFtZTogJ2gnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5USU1FLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMzYwMCxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgc2Vjb25kOiB7XG4gICAgICBuYW1lOiAnc2Vjb25kJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuVElNRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5MT05HLFxuICAgICAgdmFsdWU6IDEsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIHNlYzoge1xuICAgICAgbmFtZTogJ3NlYycsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlRJTUUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTE9ORyxcbiAgICAgIHZhbHVlOiAxLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBtaW51dGU6IHtcbiAgICAgIG5hbWU6ICdtaW51dGUnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5USU1FLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogNjAsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIGhvdXI6IHtcbiAgICAgIG5hbWU6ICdob3VyJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuVElNRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDM2MDAsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIGRheToge1xuICAgICAgbmFtZTogJ2RheScsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlRJTUUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiA4NjQwMCxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgd2Vlazoge1xuICAgICAgbmFtZTogJ3dlZWsnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5USU1FLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogNyo4NjQwMCxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgbW9udGg6IHtcbiAgICAgIG5hbWU6ICdtb250aCcsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlRJTUUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAyNjI5ODAwLCAvLzEvMTJ0aCBvZiBKdWxpYW4geWVhclxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICB5ZWFyOiB7XG4gICAgICBuYW1lOiAneWVhcicsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlRJTUUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAzMTU1NzYwMCwgLy9KdWxpYW4geWVhclxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBkZWNhZGU6IHtcbiAgICAgIG5hbWU6ICd5ZWFyJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuVElNRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDMxNTU3NjAwMCwgLy9KdWxpYW4gZGVjYWRlXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIGNlbnR1cnk6IHtcbiAgICAgIG5hbWU6ICdjZW50dXJ5JyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuVElNRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDMxNTU3NjAwMDAsIC8vSnVsaWFuIGNlbnR1cnlcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgbWlsbGVubml1bToge1xuICAgICAgbmFtZTogJ21pbGxlbm5pdW0nLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5USU1FLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMzE1NTc2MDAwMDAsIC8vSnVsaWFuIG1pbGxlbm5pdW1cbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG5cbiAgICAvLyBGcmVxdWVuY3lcbiAgICBoZXJ0ejoge1xuICAgICAgbmFtZTogJ0hlcnR6JyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuRlJFUVVFTkNZLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLkxPTkcsXG4gICAgICB2YWx1ZTogMSxcbiAgICAgIG9mZnNldDogMCxcbiAgICAgIHJlY2lwcm9jYWw6IHRydWVcbiAgICB9LFxuICAgIEh6OiB7XG4gICAgICBuYW1lOiAnSHonLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5GUkVRVUVOQ1ksXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuU0hPUlQsXG4gICAgICB2YWx1ZTogMSxcbiAgICAgIG9mZnNldDogMCxcbiAgICAgIHJlY2lwcm9jYWw6IHRydWVcbiAgICB9LFxuXG4gICAgLy8gQW5nbGVcbiAgICByYWQ6IHtcbiAgICAgIG5hbWU6ICdyYWQnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5BTkdMRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDEsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIC8vIGRlZyA9IHJhZCAvICgyKnBpKSAqIDM2MCA9IHJhZCAvIDAuMDE3NDUzMjkyNTE5OTQzMjk1NzY5MjM2OTA3Njg0ODg4XG4gICAgZGVnOiB7XG4gICAgICBuYW1lOiAnZGVnJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuQU5HTEUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiBudWxsLCAvLyB3aWxsIGJlIGZpbGxlZCBpbiBieSBjYWxjdWxhdGVBbmdsZVZhbHVlcygpXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIC8vIGdyYWQgPSByYWQgLyAoMipwaSkgKiA0MDAgID0gcmFkIC8gMC4wMTU3MDc5NjMyNjc5NDg5NjYxOTIzMTMyMTY5MTYzOTlcbiAgICBncmFkOiB7XG4gICAgICBuYW1lOiAnZ3JhZCcsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkFOR0xFLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogbnVsbCwgLy8gd2lsbCBiZSBmaWxsZWQgaW4gYnkgY2FsY3VsYXRlQW5nbGVWYWx1ZXMoKVxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICAvLyBjeWNsZSA9IHJhZCAvICgyKnBpKSA9IHJhZCAvIDYuMjgzMTg1MzA3MTc5NTg2NDc2OTI1Mjg2NzY2NTc5M1xuICAgIGN5Y2xlOiB7XG4gICAgICBuYW1lOiAnY3ljbGUnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5BTkdMRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IG51bGwsIC8vIHdpbGwgYmUgZmlsbGVkIGluIGJ5IGNhbGN1bGF0ZUFuZ2xlVmFsdWVzKClcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgLy8gYXJjc2VjID0gcmFkIC8gKDM2MDAgKiAoMzYwIC8gMiAqIHBpKSkgPSByYWQgLyAwLjAwMDAwNDg0ODEzNjgxMTA5NTM1OTkzNTg5OTE0MTAyMzU3OTVcbiAgICBhcmNzZWM6IHtcbiAgICAgIG5hbWU6ICdhcmNzZWMnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5BTkdMRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IG51bGwsIC8vIHdpbGwgYmUgZmlsbGVkIGluIGJ5IGNhbGN1bGF0ZUFuZ2xlVmFsdWVzKClcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgLy8gYXJjbWluID0gcmFkIC8gKDYwICogKDM2MCAvIDIgKiBwaSkpID0gcmFkIC8gMC4wMDAyOTA4ODgyMDg2NjU3MjE1OTYxNTM5NDg0NjE0MTQ3N1xuICAgIGFyY21pbjoge1xuICAgICAgbmFtZTogJ2FyY21pbicsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkFOR0xFLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogbnVsbCwgLy8gd2lsbCBiZSBmaWxsZWQgaW4gYnkgY2FsY3VsYXRlQW5nbGVWYWx1ZXMoKVxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBcbiAgICAvLyBFbGVjdHJpYyBjdXJyZW50XG4gICAgQToge1xuICAgICAgbmFtZTogJ0EnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5DVVJSRU5ULFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLlNIT1JULFxuICAgICAgdmFsdWU6IDEsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIGFtcGVyZToge1xuICAgICAgbmFtZTogJ2FtcGVyZScsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkNVUlJFTlQsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTE9ORyxcbiAgICAgIHZhbHVlOiAxLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcblxuICAgIC8vIFRlbXBlcmF0dXJlXG4gICAgLy8gSyhDKSA9IMKwQyArIDI3My4xNVxuICAgIC8vIEsoRikgPSAowrBGICsgNDU5LjY3KSAvIDEuOFxuICAgIC8vIEsoUikgPSDCsFIgLyAxLjhcbiAgICBLOiB7XG4gICAgICBuYW1lOiAnSycsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlRFTVBFUkFUVVJFLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgZGVnQzoge1xuICAgICAgbmFtZTogJ2RlZ0MnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5URU1QRVJBVFVSRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDEsXG4gICAgICBvZmZzZXQ6IDI3My4xNVxuICAgIH0sXG4gICAgZGVnRjoge1xuICAgICAgbmFtZTogJ2RlZ0YnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5URU1QRVJBVFVSRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDEgLyAxLjgsXG4gICAgICBvZmZzZXQ6IDQ1OS42N1xuICAgIH0sXG4gICAgZGVnUjoge1xuICAgICAgbmFtZTogJ2RlZ1InLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5URU1QRVJBVFVSRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDEgLyAxLjgsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIGtlbHZpbjoge1xuICAgICAgbmFtZTogJ2tlbHZpbicsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlRFTVBFUkFUVVJFLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgY2Vsc2l1czoge1xuICAgICAgbmFtZTogJ2NlbHNpdXMnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5URU1QRVJBVFVSRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDEsXG4gICAgICBvZmZzZXQ6IDI3My4xNVxuICAgIH0sXG4gICAgZmFocmVuaGVpdDoge1xuICAgICAgbmFtZTogJ2ZhaHJlbmhlaXQnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5URU1QRVJBVFVSRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDEgLyAxLjgsXG4gICAgICBvZmZzZXQ6IDQ1OS42N1xuICAgIH0sXG4gICAgcmFua2luZToge1xuICAgICAgbmFtZTogJ3JhbmtpbmUnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5URU1QRVJBVFVSRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDEgLyAxLjgsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuXG4gICAgLy8gYW1vdW50IG9mIHN1YnN0YW5jZVxuICAgIG1vbDoge1xuICAgICAgbmFtZTogJ21vbCcsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkFNT1VOVF9PRl9TVUJTVEFOQ0UsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuU0hPUlQsXG4gICAgICB2YWx1ZTogMSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgbW9sZToge1xuICAgICAgbmFtZTogJ21vbGUnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5BTU9VTlRfT0ZfU1VCU1RBTkNFLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLkxPTkcsXG4gICAgICB2YWx1ZTogMSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG5cbiAgICAvLyBsdW1pbm91cyBpbnRlbnNpdHlcbiAgICBjZDoge1xuICAgICAgbmFtZTogJ2NkJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuTFVNSU5PVVNfSU5URU5TSVRZLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgY2FuZGVsYToge1xuICAgICAgbmFtZTogJ2NhbmRlbGEnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5MVU1JTk9VU19JTlRFTlNJVFksXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAxLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICAvLyBUT0RPOiB1bml0cyBTVEVSQURJQU5cbiAgICAvL3tuYW1lOiAnc3InLCBiYXNlOiBCQVNFX1VOSVRTLlNURVJBRElBTiwgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsIHZhbHVlOiAxLCBvZmZzZXQ6IDB9LFxuICAgIC8ve25hbWU6ICdzdGVyYWRpYW4nLCBiYXNlOiBCQVNFX1VOSVRTLlNURVJBRElBTiwgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsIHZhbHVlOiAxLCBvZmZzZXQ6IDB9LFxuXG4gICAgLy8gRm9yY2VcbiAgICBOOiB7XG4gICAgICBuYW1lOiAnTicsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkZPUkNFLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLlNIT1JULFxuICAgICAgdmFsdWU6IDEsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIG5ld3Rvbjoge1xuICAgICAgbmFtZTogJ25ld3RvbicsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkZPUkNFLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLkxPTkcsXG4gICAgICB2YWx1ZTogMSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgZHluOiB7XG4gICAgICBuYW1lOiAnZHluJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuRk9SQ0UsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuU0hPUlQsXG4gICAgICB2YWx1ZTogMC4wMDAwMSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgZHluZToge1xuICAgICAgbmFtZTogJ2R5bmUnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5GT1JDRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5MT05HLFxuICAgICAgdmFsdWU6IDAuMDAwMDEsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIGxiZjoge1xuICAgICAgbmFtZTogJ2xiZicsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkZPUkNFLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogNC40NDgyMjE2MTUyNjA1LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBwb3VuZGZvcmNlOiB7XG4gICAgICBuYW1lOiAncG91bmRmb3JjZScsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkZPUkNFLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogNC40NDgyMjE2MTUyNjA1LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBraXA6IHtcbiAgICAgIG5hbWU6ICdraXAnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5GT1JDRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5MT05HLFxuICAgICAgdmFsdWU6IDQ0NDguMjIxNixcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG5cdFxuICAgIC8vIEVuZXJneVxuICAgIEo6IHtcbiAgICAgIG5hbWU6ICdKJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuRU5FUkdZLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLlNIT1JULFxuICAgICAgdmFsdWU6IDEsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIGpvdWxlOiB7XG4gICAgICBuYW1lOiAnam91bGUnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5FTkVSR1ksXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuU0hPUlQsXG4gICAgICB2YWx1ZTogMSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgZXJnOiB7XG4gICAgICBuYW1lOiAnZXJnJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuRU5FUkdZLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMWUtNSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgV2g6IHtcbiAgICAgIG5hbWU6ICdXaCcsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkVORVJHWSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5TSE9SVCxcbiAgICAgIHZhbHVlOiAzNjAwLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBCVFU6IHtcbiAgICAgIG5hbWU6ICdCVFUnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5FTkVSR1ksXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuQlRVLFxuICAgICAgdmFsdWU6IDEwNTUuMDU1ODUyNjIsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIGVWOiB7XG4gICAgICBuYW1lOiAnZVYnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5FTkVSR1ksXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuU0hPUlQsXG4gICAgICB2YWx1ZTogMS42MDIxNzY1NjVlLTE5LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBlbGVjdHJvbnZvbHQ6IHtcbiAgICAgIG5hbWU6ICdlbGVjdHJvbnZvbHQnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5FTkVSR1ksXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTE9ORyxcbiAgICAgIHZhbHVlOiAxLjYwMjE3NjU2NWUtMTksXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuXG5cbiAgICAvLyBQb3dlclxuICAgIFc6IHtcbiAgICAgIG5hbWU6ICdXJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuUE9XRVIsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuU0hPUlQsXG4gICAgICB2YWx1ZTogMSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgd2F0dDoge1xuICAgICAgbmFtZTogJ1cnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5QT1dFUixcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5MT05HLFxuICAgICAgdmFsdWU6IDEsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIGhwOiB7XG4gICAgICBuYW1lOiAnaHAnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5QT1dFUixcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDc0NS42OTk4NzE1Mzg2LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcblxuICAgIC8vIEVsZWN0cmljYWwgcG93ZXIgdW5pdHNcbiAgICBWQVI6IHtcbiAgICAgIG5hbWU6ICdWQVInLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5QT1dFUixcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5TSE9SVCxcbiAgICAgIHZhbHVlOiBDb21wbGV4LkksXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIFxuICAgIFZBOiB7XG4gICAgICBuYW1lOiAnVkEnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5QT1dFUixcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5TSE9SVCxcbiAgICAgIHZhbHVlOiAxLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcblxuICAgIC8vIFByZXNzdXJlXG4gICAgUGE6IHtcbiAgICAgIG5hbWU6ICdQYScsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlBSRVNTVVJFLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLlNIT1JULFxuICAgICAgdmFsdWU6IDEsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIHBzaToge1xuICAgICAgbmFtZTogJ3BzaScsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlBSRVNTVVJFLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogNjg5NC43NTcyOTI3NjQ1OSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgYXRtOiB7XG4gICAgICBuYW1lOiAnYXRtJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuUFJFU1NVUkUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAxMDEzMjUsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIGJhcjoge1xuICAgICAgbmFtZTogJ2JhcicsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlBSRVNTVVJFLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMTAwMDAwLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICB0b3JyOiB7XG4gICAgICBuYW1lOiAndG9ycicsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlBSRVNTVVJFLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMTMzLjMyMixcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgbW1IZzoge1xuICAgICAgbmFtZTogJ21tSGcnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5QUkVTU1VSRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDEzMy4zMjIsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIG1tSDJPOiB7XG4gICAgICBuYW1lOiAnbW1IMk8nLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5QUkVTU1VSRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDkuODA2NjUsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIGNtSDJPOiB7XG4gICAgICBuYW1lOiAnY21IMk8nLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5QUkVTU1VSRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDk4LjA2NjUsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuXG4gICAgLy8gRWxlY3RyaWMgY2hhcmdlXG4gICAgY291bG9tYjoge1xuICAgICAgbmFtZTogJ2NvdWxvbWInLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5FTEVDVFJJQ19DSEFSR0UsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTE9ORyxcbiAgICAgIHZhbHVlOiAxLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBDOiB7XG4gICAgICBuYW1lOiAnQycsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkVMRUNUUklDX0NIQVJHRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5TSE9SVCxcbiAgICAgIHZhbHVlOiAxLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICAvLyBFbGVjdHJpYyBjYXBhY2l0YW5jZVxuICAgIGZhcmFkOiB7XG4gICAgICBuYW1lOiAnZmFyYWQnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5FTEVDVFJJQ19DQVBBQ0lUQU5DRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5MT05HLFxuICAgICAgdmFsdWU6IDEsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIEY6IHtcbiAgICAgIG5hbWU6ICdGJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuRUxFQ1RSSUNfQ0FQQUNJVEFOQ0UsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuU0hPUlQsXG4gICAgICB2YWx1ZTogMSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgLy8gRWxlY3RyaWMgcG90ZW50aWFsXG4gICAgdm9sdDoge1xuICAgICAgbmFtZTogJ3ZvbHQnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5FTEVDVFJJQ19QT1RFTlRJQUwsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTE9ORyxcbiAgICAgIHZhbHVlOiAxLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBWOiB7XG4gICAgICBuYW1lOiAnVicsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkVMRUNUUklDX1BPVEVOVElBTCxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5TSE9SVCxcbiAgICAgIHZhbHVlOiAxLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICAvLyBFbGVjdHJpYyByZXNpc3RhbmNlXG4gICAgb2htOiB7XG4gICAgICBuYW1lOiAnb2htJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuRUxFQ1RSSUNfUkVTSVNUQU5DRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5TSE9SVExPTkcsICAgIC8vIEJvdGggTW9obSBhbmQgbWVnYW9obSBhcmUgYWNjZXB0YWJsZVxuICAgICAgdmFsdWU6IDEsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIC8qXG4gICAgICogVW5pY29kZSBicmVha3MgaW4gYnJvd3NlcnMgaWYgY2hhcnNldCBpcyBub3Qgc3BlY2lmaWVkXG4gICAgzqk6IHtcbiAgICAgIG5hbWU6ICfOqScsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkVMRUNUUklDX1JFU0lTVEFOQ0UsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuU0hPUlQsXG4gICAgICB2YWx1ZTogMSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgKi9cbiAgICAvLyBFbGVjdHJpYyBpbmR1Y3RhbmNlXG4gICAgaGVucnk6IHtcbiAgICAgIG5hbWU6ICdoZW5yeScsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkVMRUNUUklDX0lORFVDVEFOQ0UsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTE9ORyxcbiAgICAgIHZhbHVlOiAxLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBIOiB7XG4gICAgICBuYW1lOiAnSCcsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkVMRUNUUklDX0lORFVDVEFOQ0UsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuU0hPUlQsXG4gICAgICB2YWx1ZTogMSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgLy8gRWxlY3RyaWMgY29uZHVjdGFuY2VcbiAgICBzaWVtZW5zOiB7XG4gICAgICBuYW1lOiAnc2llbWVucycsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkVMRUNUUklDX0NPTkRVQ1RBTkNFLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLkxPTkcsXG4gICAgICB2YWx1ZTogMSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgUzoge1xuICAgICAgbmFtZTogJ1MnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5FTEVDVFJJQ19DT05EVUNUQU5DRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5TSE9SVCxcbiAgICAgIHZhbHVlOiAxLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICAvLyBNYWduZXRpYyBmbHV4XG4gICAgd2ViZXI6IHtcbiAgICAgIG5hbWU6ICd3ZWJlcicsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLk1BR05FVElDX0ZMVVgsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTE9ORyxcbiAgICAgIHZhbHVlOiAxLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBXYjoge1xuICAgICAgbmFtZTogJ1diJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuTUFHTkVUSUNfRkxVWCxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5TSE9SVCxcbiAgICAgIHZhbHVlOiAxLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICAvLyBNYWduZXRpYyBmbHV4IGRlbnNpdHlcbiAgICB0ZXNsYToge1xuICAgICAgbmFtZTogJ3Rlc2xhJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuTUFHTkVUSUNfRkxVWF9ERU5TSVRZLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLkxPTkcsXG4gICAgICB2YWx1ZTogMSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgVDoge1xuICAgICAgbmFtZTogJ1QnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5NQUdORVRJQ19GTFVYX0RFTlNJVFksXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuU0hPUlQsXG4gICAgICB2YWx1ZTogMSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG5cbiAgICAvLyBCaW5hcnlcbiAgICBiOiB7XG4gICAgICBuYW1lOiAnYicsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkJJVCxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5CSU5BUllfU0hPUlQsXG4gICAgICB2YWx1ZTogMSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgYml0czoge1xuICAgICAgbmFtZTogJ2JpdHMnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5CSVQsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuQklOQVJZX0xPTkcsXG4gICAgICB2YWx1ZTogMSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgQjoge1xuICAgICAgbmFtZTogJ0InLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5CSVQsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuQklOQVJZX1NIT1JULFxuICAgICAgdmFsdWU6IDgsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIGJ5dGVzOiB7XG4gICAgICBuYW1lOiAnYnl0ZXMnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5CSVQsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuQklOQVJZX0xPTkcsXG4gICAgICB2YWx1ZTogOCxcbiAgICAgIG9mZnNldDogMFxuICAgIH1cbiAgfTtcblxuICAvLyBhbGlhc2VzIChmb3JtZXJseSBwbHVyYWxzKVxuICB2YXIgQUxJQVNFUyA9IHtcbiAgICBtZXRlcnM6ICdtZXRlcicsXG4gICAgaW5jaGVzOiAnaW5jaCcsXG4gICAgZmVldDogJ2Zvb3QnLFxuICAgIHlhcmRzOiAneWFyZCcsXG4gICAgbWlsZXM6ICdtaWxlJyxcbiAgICBsaW5rczogJ2xpbmsnLFxuICAgIHJvZHM6ICdyb2QnLFxuICAgIGNoYWluczogJ2NoYWluJyxcbiAgICBhbmdzdHJvbXM6ICdhbmdzdHJvbScsXG5cbiAgICBsdDogJ2wnLFxuICAgIGxpdHJlczogJ2xpdHJlJyxcbiAgICBsaXRlcjogJ2xpdHJlJyxcbiAgICBsaXRlcnM6ICdsaXRyZScsXG4gICAgdGVhc3Bvb25zOiAndGVhc3Bvb24nLFxuICAgIHRhYmxlc3Bvb25zOiAndGFibGVzcG9vbicsXG4gICAgbWluaW1zOiAnbWluaW0nLFxuICAgIGZsdWlkZHJhbXM6ICdmbHVpZGRyYW0nLFxuICAgIGZsdWlkb3VuY2VzOiAnZmx1aWRvdW5jZScsXG4gICAgZ2lsbHM6ICdnaWxsJyxcbiAgICBjdXBzOiAnY3VwJyxcbiAgICBwaW50czogJ3BpbnQnLFxuICAgIHF1YXJ0czogJ3F1YXJ0JyxcbiAgICBnYWxsb25zOiAnZ2FsbG9uJyxcbiAgICBiZWVyYmFycmVsczogJ2JlZXJiYXJyZWwnLFxuICAgIG9pbGJhcnJlbHM6ICdvaWxiYXJyZWwnLFxuICAgIGhvZ3NoZWFkczogJ2hvZ3NoZWFkJyxcbiAgICBndHRzOiAnZ3R0JyxcblxuICAgIGdyYW1zOiAnZ3JhbScsXG4gICAgdG9uczogJ3RvbicsXG4gICAgdG9ubmVzOiAndG9ubmUnLFxuICAgIGdyYWluczogJ2dyYWluJyxcbiAgICBkcmFtczogJ2RyYW0nLFxuICAgIG91bmNlczogJ291bmNlJyxcbiAgICBwb3VuZG1hc3NlczogJ3BvdW5kbWFzcycsXG4gICAgaHVuZHJlZHdlaWdodHM6ICdodW5kcmVkd2VpZ2h0JyxcbiAgICBzdGlja3M6ICdzdGljaycsXG4gICAgbGI6ICdsYm0nLFxuICAgIGxiczogJ2xibScsXG5cdFxuICAgIGtpcHM6ICdraXAnLFxuXG4gICAgYWNyZXM6ICdhY3JlJyxcbiAgICBoZWN0YXJlczogJ2hlY3RhcmUnLFxuICAgIHNxZmVldDogJ3NxZnQnLFxuICAgIHNxeWFyZDogJ3NxeWQnLFxuICAgIHNxbWlsZTogJ3NxbWknLFxuICAgIHNxbWlsZXM6ICdzcW1pJyxcblxuICAgIG1taGc6ICdtbUhnJyxcbiAgICBtbWgybzogJ21tSDJPJyxcbiAgICBjbWgybzogJ2NtSDJPJyxcblxuICAgIHNlY29uZHM6ICdzZWNvbmQnLFxuICAgIHNlY3M6ICdzZWNvbmQnLFxuICAgIG1pbnV0ZXM6ICdtaW51dGUnLFxuICAgIG1pbnM6ICdtaW51dGUnLFxuICAgIGhvdXJzOiAnaG91cicsXG4gICAgaHI6ICdob3VyJyxcbiAgICBocnM6ICdob3VyJyxcbiAgICBkYXlzOiAnZGF5JyxcblxuICAgIGhlcnR6OiAnaGVydHonLFxuXG4gICAgcmFkaWFuczogJ3JhZCcsXG4gICAgZGVncmVlOiAnZGVnJyxcbiAgICBkZWdyZWVzOiAnZGVnJyxcbiAgICBncmFkaWFuOiAnZ3JhZCcsXG4gICAgZ3JhZGlhbnM6ICdncmFkJyxcbiAgICBjeWNsZXM6ICdjeWNsZScsXG4gICAgYXJjc2Vjb25kOiAnYXJjc2VjJyxcbiAgICBhcmNzZWNvbmRzOiAnYXJjc2VjJyxcbiAgICBhcmNtaW51dGU6ICdhcmNtaW4nLFxuICAgIGFyY21pbnV0ZXM6ICdhcmNtaW4nLFxuXG4gICAgQlRVczogJ0JUVScsXG4gICAgd2F0dHM6ICd3YXR0JyxcbiAgICBqb3VsZXM6ICdqb3VsZScsXG5cbiAgICBhbXBlcmVzOiAnYW1wZXJlJyxcbiAgICBjb3Vsb21iczogJ2NvdWxvbWInLFxuICAgIHZvbHRzOiAndm9sdCcsXG4gICAgb2htczogJ29obScsXG4gICAgZmFyYWRzOiAnZmFyYWQnLFxuICAgIHdlYmVyczogJ3dlYmVyJyxcbiAgICB0ZXNsYXM6ICd0ZXNsYScsXG4gICAgZWxlY3Ryb252b2x0czogJ2VsZWN0cm9udm9sdCcsXG4gICAgbW9sZXM6ICdtb2xlJ1xuXG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgdmFsdWVzIGZvciB0aGUgYW5nbGUgdW5pdHMuXG4gICAqIFZhbHVlIGlzIGNhbGN1bGF0ZWQgYXMgbnVtYmVyIG9yIEJpZ051bWJlciBkZXBlbmRpbmcgb24gdGhlIGNvbmZpZ3VyYXRpb25cbiAgICogQHBhcmFtIHt7bnVtYmVyOiAnbnVtYmVyJyB8ICdCaWdOdW1iZXInfX0gY29uZmlnXG4gICAqL1xuICBmdW5jdGlvbiBjYWxjdWxhdGVBbmdsZVZhbHVlcyAoY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZy5udW1iZXIgPT09ICdCaWdOdW1iZXInKSB7XG4gICAgICB2YXIgcGkgPSBjb25zdGFudHMucGkodHlwZS5CaWdOdW1iZXIpO1xuICAgICAgVU5JVFMucmFkLnZhbHVlID0gbmV3IHR5cGUuQmlnTnVtYmVyKDEpO1xuICAgICAgVU5JVFMuZGVnLnZhbHVlID0gcGkuZGl2KDE4MCk7ICAgICAgICAvLyAyICogcGkgLyAzNjA7XG4gICAgICBVTklUUy5ncmFkLnZhbHVlID0gcGkuZGl2KDIwMCk7ICAgICAgIC8vIDIgKiBwaSAvIDQwMDtcbiAgICAgIFVOSVRTLmN5Y2xlLnZhbHVlID0gcGkudGltZXMoMik7ICAgICAgLy8gMiAqIHBpXG4gICAgICBVTklUUy5hcmNzZWMudmFsdWUgPSBwaS5kaXYoNjQ4MDAwKTsgIC8vIDIgKiBwaSAvIDM2MCAvIDM2MDBcbiAgICAgIFVOSVRTLmFyY21pbi52YWx1ZSA9IHBpLmRpdigxMDgwMCk7ICAgLy8gMiAqIHBpIC8gMzYwIC8gNjBcbiAgICB9XG4gICAgZWxzZSB7IC8vIG51bWJlclxuICAgICAgVU5JVFMucmFkLnZhbHVlID0gMTtcbiAgICAgIFVOSVRTLmRlZy52YWx1ZSA9IE1hdGguUEkgLyAxODA7ICAgICAgICAvLyAyICogcGkgLyAzNjA7XG4gICAgICBVTklUUy5ncmFkLnZhbHVlID0gTWF0aC5QSSAvIDIwMDsgICAgICAgLy8gMiAqIHBpIC8gNDAwO1xuICAgICAgVU5JVFMuY3ljbGUudmFsdWUgPSBNYXRoLlBJICogMjsgICAgICAgIC8vIDIgKiBwaVxuICAgICAgVU5JVFMuYXJjc2VjLnZhbHVlID0gTWF0aC5QSSAvIDY0ODAwMDsgIC8vIDIgKiBwaSAvIDM2MCAvIDM2MDA7XG4gICAgICBVTklUUy5hcmNtaW4udmFsdWUgPSBNYXRoLlBJIC8gMTA4MDA7ICAgLy8gMiAqIHBpIC8gMzYwIC8gNjA7XG4gICAgfVxuICB9XG5cbiAgLy8gYXBwbHkgdGhlIGFuZ2xlIHZhbHVlcyBub3dcbiAgY2FsY3VsYXRlQW5nbGVWYWx1ZXMoY29uZmlnKTtcblxuICAvLyByZWNhbGN1bGF0ZSB0aGUgdmFsdWVzIG9uIGNoYW5nZSBvZiBjb25maWd1cmF0aW9uXG4gIG1hdGgub24oJ2NvbmZpZycsIGZ1bmN0aW9uIChjdXJyLCBwcmV2KSB7XG4gICAgaWYgKGN1cnIubnVtYmVyICE9PSBwcmV2Lm51bWJlcikge1xuICAgICAgY2FsY3VsYXRlQW5nbGVWYWx1ZXMoY3Vycik7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQSB1bml0IHN5c3RlbSBpcyBhIHNldCBvZiBkaW1lbnNpb25hbGx5IGluZGVwZW5kZW50IGJhc2UgdW5pdHMgcGx1cyBhIHNldCBvZiBkZXJpdmVkIHVuaXRzLCBmb3JtZWQgYnkgbXVsdGlwbGljYXRpb24gYW5kIGRpdmlzaW9uIG9mIHRoZSBiYXNlIHVuaXRzLCB0aGF0IGFyZSBieSBjb252ZW50aW9uIHVzZWQgd2l0aCB0aGUgdW5pdCBzeXN0ZW0uXG4gICAqIEEgdXNlciBwZXJoYXBzIGNvdWxkIGlzc3VlIGEgY29tbWFuZCB0byBzZWxlY3QgYSBwcmVmZXJyZWQgdW5pdCBzeXN0ZW0sIG9yIHVzZSB0aGUgZGVmYXVsdCAoc2VlIGJlbG93KS5cbiAgICogQXV0byB1bml0IHN5c3RlbTogVGhlIGRlZmF1bHQgdW5pdCBzeXN0ZW0gaXMgdXBkYXRlZCBvbiB0aGUgZmx5IGFueXRpbWUgYSB1bml0IGlzIHBhcnNlZC4gVGhlIGNvcnJlc3BvbmRpbmcgdW5pdCBpbiB0aGUgZGVmYXVsdCB1bml0IHN5c3RlbSBpcyB1cGRhdGVkLCBzbyB0aGF0IGFuc3dlcnMgYXJlIGdpdmVuIGluIHRoZSBzYW1lIHVuaXRzIHRoZSB1c2VyIHN1cHBsaWVzLlxuICAgKi9cbiAgdmFyIFVOSVRfU1lTVEVNUyA9IHtcbiAgICBzaToge1xuICAgICAgLy8gQmFzZSB1bml0c1xuICAgICAgTk9ORTogICAgICAgICAgICAgICAgICB7dW5pdDogVU5JVF9OT05FLCBwcmVmaXg6IFBSRUZJWEVTLk5PTkVbJyddfSxcbiAgICAgIExFTkdUSDogICAgICAgICAgICAgICAge3VuaXQ6IFVOSVRTLm0sICAgcHJlZml4OiBQUkVGSVhFUy5TSE9SVFsnJ119LFxuICAgICAgTUFTUzogICAgICAgICAgICAgICAgICB7dW5pdDogVU5JVFMuZywgICBwcmVmaXg6IFBSRUZJWEVTLlNIT1JUWydrJ119LCBcbiAgICAgIFRJTUU6ICAgICAgICAgICAgICAgICAge3VuaXQ6IFVOSVRTLnMsICAgcHJlZml4OiBQUkVGSVhFUy5TSE9SVFsnJ119LCBcbiAgICAgIENVUlJFTlQ6ICAgICAgICAgICAgICAge3VuaXQ6IFVOSVRTLkEsICAgcHJlZml4OiBQUkVGSVhFUy5TSE9SVFsnJ119LCBcbiAgICAgIFRFTVBFUkFUVVJFOiAgICAgICAgICAge3VuaXQ6IFVOSVRTLkssICAgcHJlZml4OiBQUkVGSVhFUy5TSE9SVFsnJ119LCBcbiAgICAgIExVTUlOT1VTX0lOVEVOU0lUWTogICAge3VuaXQ6IFVOSVRTLmNkLCAgcHJlZml4OiBQUkVGSVhFUy5TSE9SVFsnJ119LCBcbiAgICAgIEFNT1VOVF9PRl9TVUJTVEFOQ0U6ICAge3VuaXQ6IFVOSVRTLm1vbCwgcHJlZml4OiBQUkVGSVhFUy5TSE9SVFsnJ119LCBcbiAgICAgIEFOR0xFOiAgICAgICAgICAgICAgICAge3VuaXQ6IFVOSVRTLnJhZCwgcHJlZml4OiBQUkVGSVhFUy5TSE9SVFsnJ119LCBcbiAgICAgIEJJVDogICAgICAgICAgICAgICAgICAge3VuaXQ6IFVOSVRTLmJpdCwgcHJlZml4OiBQUkVGSVhFUy5TSE9SVFsnJ119LCBcblxuICAgICAgLy8gRGVyaXZlZCB1bml0c1xuICAgICAgRk9SQ0U6ICAgICAgICAgICAgICAgICB7dW5pdDogVU5JVFMuTiwgICBwcmVmaXg6IFBSRUZJWEVTLlNIT1JUWycnXX0sIFxuICAgICAgRU5FUkdZOiAgICAgICAgICAgICAgICB7dW5pdDogVU5JVFMuSiwgICBwcmVmaXg6IFBSRUZJWEVTLlNIT1JUWycnXX0sXG4gICAgICBQT1dFUjogICAgICAgICAgICAgICAgIHt1bml0OiBVTklUUy5XLCAgIHByZWZpeDogUFJFRklYRVMuU0hPUlRbJyddfSxcbiAgICAgIFBSRVNTVVJFOiAgICAgICAgICAgICAge3VuaXQ6IFVOSVRTLlBhLCAgcHJlZml4OiBQUkVGSVhFUy5TSE9SVFsnJ119LFxuICAgICAgRUxFQ1RSSUNfQ0hBUkdFOiAgICAgICB7dW5pdDogVU5JVFMuQywgICBwcmVmaXg6IFBSRUZJWEVTLlNIT1JUWycnXX0sXG4gICAgICBFTEVDVFJJQ19DQVBBQ0lUQU5DRTogIHt1bml0OiBVTklUUy5GLCAgIHByZWZpeDogUFJFRklYRVMuU0hPUlRbJyddfSxcbiAgICAgIEVMRUNUUklDX1BPVEVOVElBTDogICAge3VuaXQ6IFVOSVRTLlYsICAgcHJlZml4OiBQUkVGSVhFUy5TSE9SVFsnJ119LFxuICAgICAgRUxFQ1RSSUNfUkVTSVNUQU5DRTogICB7dW5pdDogVU5JVFMub2htLCBwcmVmaXg6IFBSRUZJWEVTLlNIT1JUWycnXX0sXG4gICAgICBFTEVDVFJJQ19JTkRVQ1RBTkNFOiAgIHt1bml0OiBVTklUUy5ILCAgIHByZWZpeDogUFJFRklYRVMuU0hPUlRbJyddfSxcbiAgICAgIEVMRUNUUklDX0NPTkRVQ1RBTkNFOiAge3VuaXQ6IFVOSVRTLlMsICAgcHJlZml4OiBQUkVGSVhFUy5TSE9SVFsnJ119LFxuICAgICAgTUFHTkVUSUNfRkxVWDogICAgICAgICB7dW5pdDogVU5JVFMuV2IsICBwcmVmaXg6IFBSRUZJWEVTLlNIT1JUWycnXX0sXG4gICAgICBNQUdORVRJQ19GTFVYX0RFTlNJVFk6IHt1bml0OiBVTklUUy5ULCAgIHByZWZpeDogUFJFRklYRVMuU0hPUlRbJyddfSxcbiAgICAgIEZSRVFVRU5DWTogICAgICAgICAgICAge3VuaXQ6IFVOSVRTLkh6LCAgcHJlZml4OiBQUkVGSVhFUy5TSE9SVFsnJ119XG4gICAgfVxuICB9O1xuXG4gIC8vIENsb25lIHRvIGNyZWF0ZSB0aGUgb3RoZXIgdW5pdCBzeXN0ZW1zXG4gIFVOSVRfU1lTVEVNUy5jZ3MgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KFVOSVRfU1lTVEVNUy5zaSkpO1xuICBVTklUX1NZU1RFTVMuY2dzLkxFTkdUSCA9IHt1bml0OiBVTklUUy5tLCAgIHByZWZpeDogUFJFRklYRVMuU0hPUlRbJ2MnXX07XG4gIFVOSVRfU1lTVEVNUy5jZ3MuTUFTUyA9ICAge3VuaXQ6IFVOSVRTLmcsICAgcHJlZml4OiBQUkVGSVhFUy5TSE9SVFsnJ119O1xuICBVTklUX1NZU1RFTVMuY2dzLkZPUkNFID0gIHt1bml0OiBVTklUUy5keW4sIHByZWZpeDogUFJFRklYRVMuU0hPUlRbJyddfTtcbiAgVU5JVF9TWVNURU1TLmNncy5FTkVSR1kgPSB7dW5pdDogVU5JVFMuZXJnLCBwcmVmaXg6IFBSRUZJWEVTLk5PTkVbJyddfTtcbiAgLy8gdGhlcmUgYXJlIHdob2xseSA0IHVuaXF1ZSBjZ3Mgc3lzdGVtcyBmb3IgZWxlY3RyaWNpdHkgYW5kIG1hZ25ldGlzbSxcbiAgLy8gc28gbGV0J3Mgbm90IHdvcnJ5IGFib3V0IGl0IHVubGVzcyBzb21lYm9keSBjb21wbGFpbnNcbiAgXG4gIFVOSVRfU1lTVEVNUy51cyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoVU5JVF9TWVNURU1TLnNpKSk7XG4gIFVOSVRfU1lTVEVNUy51cy5MRU5HVEggPSAgICAgIHt1bml0OiBVTklUUy5mdCwgICBwcmVmaXg6IFBSRUZJWEVTLk5PTkVbJyddfTtcbiAgVU5JVF9TWVNURU1TLnVzLk1BU1MgPSAgICAgICAge3VuaXQ6IFVOSVRTLmxibSwgIHByZWZpeDogUFJFRklYRVMuTk9ORVsnJ119O1xuICBVTklUX1NZU1RFTVMudXMuVEVNUEVSQVRVUkUgPSB7dW5pdDogVU5JVFMuZGVnRiwgcHJlZml4OiBQUkVGSVhFUy5OT05FWycnXX07XG4gIFVOSVRfU1lTVEVNUy51cy5GT1JDRSA9ICAgICAgIHt1bml0OiBVTklUUy5sYmYsICBwcmVmaXg6IFBSRUZJWEVTLk5PTkVbJyddfTtcbiAgVU5JVF9TWVNURU1TLnVzLkVORVJHWSA9ICAgICAge3VuaXQ6IFVOSVRTLkJUVSwgIHByZWZpeDogUFJFRklYRVMuQlRVWycnXX07XG4gIFVOSVRfU1lTVEVNUy51cy5QT1dFUiA9ICAgICAgIHt1bml0OiBVTklUUy5ocCwgICBwcmVmaXg6IFBSRUZJWEVTLk5PTkVbJyddfTtcbiAgVU5JVF9TWVNURU1TLnVzLlBSRVNTVVJFID0gICAge3VuaXQ6IFVOSVRTLnBzaSwgIHByZWZpeDogUFJFRklYRVMuTk9ORVsnJ119O1xuXG4gIC8vIEFkZCBhZGRpdGlvbmFsIHVuaXQgc3lzdGVtcyBoZXJlLlxuXG5cblxuICAvLyBDaG9vc2UgYSB1bml0IHN5c3RlbSB0byBzZWVkIHRoZSBhdXRvIHVuaXQgc3lzdGVtLlxuICBVTklUX1NZU1RFTVMuYXV0byA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoVU5JVF9TWVNURU1TLnNpKSk7XG5cbiAgLy8gU2V0IHRoZSBjdXJyZW50IHVuaXQgc3lzdGVtXG4gIHZhciBjdXJyZW50VW5pdFN5c3RlbSA9IFVOSVRfU1lTVEVNUy5hdXRvO1xuXG4gIC8qKlxuICAgKiBTZXQgYSB1bml0IHN5c3RlbSBmb3IgZm9ybWF0dGluZyBkZXJpdmVkIHVuaXRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdIFRoZSBuYW1lIG9mIHRoZSB1bml0IHN5c3RlbS5cbiAgICovXG4gIFVuaXQuc2V0VW5pdFN5c3RlbSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBpZihVTklUX1NZU1RFTVMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGN1cnJlbnRVbml0U3lzdGVtID0gVU5JVF9TWVNURU1TW25hbWVdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5pdCBzeXN0ZW0gJyArIG5hbWUgKyAnIGRvZXMgbm90IGV4aXN0LiBDaG9pY2VzIGFyZTogJyArIE9iamVjdC5rZXlzKFVOSVRfU1lTVEVNUykuam9pbignLCAnKSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGN1cnJlbnQgdW5pdCBzeXN0ZW0uXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGN1cnJlbnQgdW5pdCBzeXN0ZW0uXG4gICAqL1xuICBVbml0LmdldFVuaXRTeXN0ZW0gPSBmdW5jdGlvbigpIHtcbiAgICBmb3IodmFyIGtleSBpbiBVTklUX1NZU1RFTVMpIHtcbiAgICAgIGlmKFVOSVRfU1lTVEVNU1trZXldID09PSBjdXJyZW50VW5pdFN5c3RlbSkge1xuICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydGVycyB0byBjb252ZXJ0IGZyb20gbnVtYmVyIHRvIGFuIG90aGVyIG51bWVyaWMgdHlwZSBsaWtlIEJpZ051bWJlclxuICAgKiBvciBGcmFjdGlvblxuICAgKi9cbiAgVW5pdC50eXBlQ29udmVydGVycyA9IHtcbiAgICBCaWdOdW1iZXI6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gbmV3IHR5cGUuQmlnTnVtYmVyKHggKyAnJyk7IC8vIHN0cmluZ2lmeSB0byBwcmV2ZW50IGNvbnN0cnVjdG9yIGVycm9yXG4gICAgfSxcblxuICAgIEZyYWN0aW9uOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIG5ldyB0eXBlLkZyYWN0aW9uKHgpO1xuICAgIH0sXG5cbiAgICBDb21wbGV4OiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfSxcblxuICAgIG51bWJlcjogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlldmUgdGhlIHJpZ2h0IGNvbnZlcnRvciBmdW5jdGlvbiBjb3JyZXNwb25kaW5nIHdpdGggdGhlIHR5cGVcbiAgICogb2YgcHJvdmlkZWQgZXhhbXBsZVZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAgIEEgc3RyaW5nICdudW1iZXInLCAnQmlnTnVtYmVyJywgb3IgJ0ZyYWN0aW9uJ1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIEluIGNhc2Ugb2YgYW4gdW5rbm93biB0eXBlLFxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICovXG4gIFVuaXQuX2dldE51bWJlckNvbnZlcnRlciA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgaWYgKCFVbml0LnR5cGVDb252ZXJ0ZXJzW3R5cGVdKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbnN1cHBvcnRlZCB0eXBlIFwiJyArIHR5cGUgKyAnXCInKTtcbiAgICB9XG5cbiAgICByZXR1cm4gVW5pdC50eXBlQ29udmVydGVyc1t0eXBlXTtcbiAgfTtcblxuICAvLyBBZGQgZGltZW5zaW9ucyB0byBlYWNoIGJ1aWx0LWluIHVuaXRcbiAgZm9yICh2YXIga2V5IGluIFVOSVRTKSB7XG4gICAgdmFyIHVuaXQgPSBVTklUU1trZXldO1xuICAgIHVuaXQuZGltZW5zaW9ucyA9IHVuaXQuYmFzZS5kaW1lbnNpb25zO1xuICB9ICAgIFxuXG4gIC8vIENyZWF0ZSBhbGlhc2VzXG4gIGZvciAodmFyIG5hbWUgaW4gQUxJQVNFUykge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICh3ZSBjYW5ub3QgcmVhbGx5IHRlc3QgbmV4dCBzdGF0ZW1lbnQpICovXG4gICAgaWYgKEFMSUFTRVMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHZhciB1bml0ID0gVU5JVFNbQUxJQVNFU1tuYW1lXV07XG4gICAgICB2YXIgYWxpYXMgPSBPYmplY3QuY3JlYXRlKHVuaXQpO1xuICAgICAgYWxpYXMubmFtZSA9IG5hbWU7XG4gICAgICBVTklUU1tuYW1lXSA9IGFsaWFzO1xuICAgIH1cbiAgfVxuXG4gIFVuaXQuUFJFRklYRVMgPSBQUkVGSVhFUztcbiAgVW5pdC5CQVNFX1VOSVRTID0gQkFTRV9VTklUUztcbiAgVW5pdC5VTklUUyA9IFVOSVRTO1xuICBVbml0LlVOSVRfU1lTVEVNUyA9IFVOSVRfU1lTVEVNUztcblxuICByZXR1cm4gVW5pdDtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ1VuaXQnO1xuZXhwb3J0cy5wYXRoID0gJ3R5cGUnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbmV4cG9ydHMubWF0aCA9IHRydWU7IC8vIHJlcXVlc3QgYWNjZXNzIHRvIHRoZSBtYXRoIG5hbWVzcGFjZVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVlcE1hcCA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vZGVlcE1hcCcpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSB1bml0LiBEZXBlbmRpbmcgb24gdGhlIHBhc3NlZCBhcmd1bWVudHMsIHRoZSBmdW5jdGlvblxuICAgKiB3aWxsIGNyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IG1hdGgudHlwZS5Vbml0IG9iamVjdC5cbiAgICogV2hlbiBhIG1hdHJpeCBpcyBwcm92aWRlZCwgYWxsIGVsZW1lbnRzIHdpbGwgYmUgY29udmVydGVkIHRvIHVuaXRzLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgICBtYXRoLnVuaXQodW5pdCA6IHN0cmluZylcbiAgICogICAgIG1hdGgudW5pdCh2YWx1ZSA6IG51bWJlciwgdW5pdCA6IHN0cmluZylcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIHZhciBhID0gbWF0aC51bml0KDUsICdjbScpOyAgICAvLyByZXR1cm5zIFVuaXQgNTAgbW1cbiAgICogICAgdmFyIGIgPSBtYXRoLnVuaXQoJzIzIGtnJyk7ICAgIC8vIHJldHVybnMgVW5pdCAyMyBrZ1xuICAgKiAgICBhLnRvKCdtJyk7ICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBVbml0IDAuMDUgbVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgYmlnbnVtYmVyLCBib29sZWFuLCBjb21wbGV4LCBpbmRleCwgbWF0cml4LCBudW1iZXIsIHN0cmluZ1xuICAgKlxuICAgKiBAcGFyYW0geyogfCBBcnJheSB8IE1hdHJpeH0gYXJncyAgIEEgbnVtYmVyIGFuZCB1bml0LlxuICAgKiBAcmV0dXJuIHtVbml0IHwgQXJyYXkgfCBNYXRyaXh9ICAgIFRoZSBjcmVhdGVkIHVuaXRcbiAgICovXG5cbiAgdmFyIHVuaXQgPSB0eXBlZCgndW5pdCcsIHtcbiAgICAnVW5pdCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5jbG9uZSgpO1xuICAgIH0sXG5cbiAgICAnc3RyaW5nJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICh0eXBlLlVuaXQuaXNWYWx1ZWxlc3NVbml0KHgpKSB7XG4gICAgICAgIHJldHVybiBuZXcgdHlwZS5Vbml0KG51bGwsIHgpOyAvLyBhIHB1cmUgdW5pdFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHlwZS5Vbml0LnBhcnNlKHgpOyAvLyBhIHVuaXQgd2l0aCB2YWx1ZSwgbGlrZSAnNWNtJ1xuICAgIH0sXG5cbiAgICAnbnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb24gfCBDb21wbGV4LCBzdHJpbmcnOiBmdW5jdGlvbiAodmFsdWUsIHVuaXQpIHtcbiAgICAgIHJldHVybiBuZXcgdHlwZS5Vbml0KHZhbHVlLCB1bml0KTtcbiAgICB9LFxuXG4gICAgJ0FycmF5IHwgTWF0cml4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBkZWVwTWFwKHgsIHVuaXQpO1xuICAgIH1cbiAgfSk7XG5cbiAgdW5pdC50b1RleCA9IHtcbiAgICAxOiAnXFxcXGxlZnQoJHthcmdzWzBdfVxcXFxyaWdodCknLFxuICAgIDI6ICdcXFxcbGVmdChcXFxcbGVmdCgke2FyZ3NbMF19XFxcXHJpZ2h0KSR7YXJnc1sxXX1cXFxccmlnaHQpJ1xuICB9O1xuXG4gIHJldHVybiB1bml0O1xufVxuXG5leHBvcnRzLm5hbWUgPSAndW5pdCc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBbXG4gIC8vIHR5cGVcbiAgcmVxdWlyZSgnLi9Vbml0JyksXG5cbiAgLy8gY29uc3RydWN0aW9uIGZ1bmN0aW9uXG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vdW5pdCcpLFxuXG4gIC8vIHBoeXNpY2FsIGNvbnN0YW50c1xuICByZXF1aXJlKCcuL3BoeXNpY2FsQ29uc3RhbnRzJylcbl07XG4iLCJ2YXIgbGF6eSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdCcpLmxhenk7XG5cblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCwgbWF0aCkge1xuXG4gIC8vIGhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgYSB1bml0IHdpdGggYSBmaXhlZCBwcmVmaXhcbiAgZnVuY3Rpb24gZml4ZWRVbml0KHN0cikge1xuICAgIHZhciB1bml0ID0gdHlwZS5Vbml0LnBhcnNlKHN0cik7XG4gICAgdW5pdC5maXhQcmVmaXggPSB0cnVlO1xuICAgIHJldHVybiB1bml0O1xuICB9XG5cbiAgLy8gU291cmNlOiBodHRwOi8vd3d3Lndpa2l3YW5kLmNvbS9lbi9QaHlzaWNhbF9jb25zdGFudFxuXG4gIC8vIFVuaXZlcnNhbCBjb25zdGFudHNcbiAgbGF6eShtYXRoLCAnc3BlZWRPZkxpZ2h0JywgICAgICAgICBmdW5jdGlvbiAoKSB7cmV0dXJuIGZpeGVkVW5pdCgnMjk5NzkyNDU4IG0gc14tMScpfSk7XG4gIGxhenkobWF0aCwgJ2dyYXZpdGF0aW9uQ29uc3RhbnQnLCAgZnVuY3Rpb24gKCkge3JldHVybiBmaXhlZFVuaXQoJzYuNjczODQ4MGUtMTEgbV4zIGtnXi0xIHNeLTInKX0pO1xuICBsYXp5KG1hdGgsICdwbGFuY2tDb25zdGFudCcsICAgICAgIGZ1bmN0aW9uICgpIHtyZXR1cm4gZml4ZWRVbml0KCc2LjYyNjA2OTMxMWUtMzQgSiBzJyl9KTtcbiAgbGF6eShtYXRoLCAncmVkdWNlZFBsYW5ja0NvbnN0YW50JyxmdW5jdGlvbiAoKSB7cmV0dXJuIGZpeGVkVW5pdCgnMS4wNTQ1NzE3MjY0N2UtMzQgSiBzJyl9KTtcblxuICAvLyBFbGVjdHJvbWFnbmV0aWMgY29uc3RhbnRzXG4gIGxhenkobWF0aCwgJ21hZ25ldGljQ29uc3RhbnQnLCAgICAgICAgICBmdW5jdGlvbiAoKSB7cmV0dXJuIGZpeGVkVW5pdCgnMS4yNTY2MzcwNjE0ZS02IE4gQV4tMicpfSk7XG4gIGxhenkobWF0aCwgJ2VsZWN0cmljQ29uc3RhbnQnLCAgICAgICAgICBmdW5jdGlvbiAoKSB7cmV0dXJuIGZpeGVkVW5pdCgnOC44NTQxODc4MTdlLTEyIEYgbV4tMScpfSk7XG4gIGxhenkobWF0aCwgJ3ZhY3V1bUltcGVkYW5jZScsICAgICAgICAgICBmdW5jdGlvbiAoKSB7cmV0dXJuIGZpeGVkVW5pdCgnMzc2LjczMDMxMzQ2MSBvaG0nKX0pO1xuICBsYXp5KG1hdGgsICdjb3Vsb21iJywgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge3JldHVybiBmaXhlZFVuaXQoJzguOTg3NTUxNzg3MzY4MTc2NGU5IE4gbV4yIENeLTInKX0pO1xuICBsYXp5KG1hdGgsICdlbGVtZW50YXJ5Q2hhcmdlJywgICAgICAgICAgZnVuY3Rpb24gKCkge3JldHVybiBmaXhlZFVuaXQoJzEuNjAyMTc2NTY1MzVlLTE5IEMnKX0pO1xuICBsYXp5KG1hdGgsICdib2hyTWFnbmV0b24nLCAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge3JldHVybiBmaXhlZFVuaXQoJzkuMjc0MDA5NjgyMGUtMjQgSiBUXi0xJyl9KTtcbiAgbGF6eShtYXRoLCAnY29uZHVjdGFuY2VRdWFudHVtJywgICAgICAgIGZ1bmN0aW9uICgpIHtyZXR1cm4gZml4ZWRVbml0KCc3Ljc0ODA5MTczNDYyNWUtNSBTJyl9KTtcbiAgbGF6eShtYXRoLCAnaW52ZXJzZUNvbmR1Y3RhbmNlUXVhbnR1bScsIGZ1bmN0aW9uICgpIHtyZXR1cm4gZml4ZWRVbml0KCcxMjkwNi40MDM3MjE3NDIgb2htJyl9KTtcbiAgbGF6eShtYXRoLCAnbWFnbmV0aWNGbHV4UXVhbnR1bScsICAgICAgIGZ1bmN0aW9uICgpIHtyZXR1cm4gZml4ZWRVbml0KCcyLjA2NzgzMzc1ODQ2ZS0xNSBXYicpfSk7XG4gIGxhenkobWF0aCwgJ251Y2xlYXJNYWduZXRvbicsICAgICAgICAgICBmdW5jdGlvbiAoKSB7cmV0dXJuIGZpeGVkVW5pdCgnNS4wNTA3ODM1MzExZS0yNyBKIFReLTEnKX0pO1xuICBsYXp5KG1hdGgsICdrbGl0emluZycsICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge3JldHVybiBmaXhlZFVuaXQoJzI1ODEyLjgwNzQ0MzQ4NCBvaG0nKX0pO1xuICAvL2xhenkobWF0aCwgJ2pvc2VwaHNvbicsICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7cmV0dXJuIGZpeGVkVW5pdCgnNC44MzU5Nzg3MDExZS0xNCBIeiBWXi0xJyl9KTsgIC8vIFRPRE86IHN1cHBvcnQgZm9yIEh6IG5lZWRlZFxuXG4gIC8vIEF0b21pYyBhbmQgbnVjbGVhciBjb25zdGFudHNcbiAgbGF6eShtYXRoLCAnYm9oclJhZGl1cycsICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7cmV0dXJuIGZpeGVkVW5pdCgnNS4yOTE3NzIxMDkyMTdlLTExIG0nKX0pO1xuICBsYXp5KG1hdGgsICdjbGFzc2ljYWxFbGVjdHJvblJhZGl1cycsIGZ1bmN0aW9uICgpIHtyZXR1cm4gZml4ZWRVbml0KCcyLjgxNzk0MDMyNjcyN2UtMTUgbScpfSk7XG4gIGxhenkobWF0aCwgJ2VsZWN0cm9uTWFzcycsICAgICAgICAgICAgZnVuY3Rpb24gKCkge3JldHVybiBmaXhlZFVuaXQoJzkuMTA5MzgyOTE0MGUtMzEga2cnKX0pO1xuICBsYXp5KG1hdGgsICdmZXJtaUNvdXBsaW5nJywgICAgICAgICAgIGZ1bmN0aW9uICgpIHtyZXR1cm4gZml4ZWRVbml0KCcxLjE2NjM2NDVlLTUgR2VWXi0yJyl9KTtcbiAgbGF6eShtYXRoLCAnZmluZVN0cnVjdHVyZScsICAgICAgICAgICBmdW5jdGlvbiAoKSB7cmV0dXJuIDcuMjk3MzUyNTY5ODI0ZS0zfSk7XG4gIGxhenkobWF0aCwgJ2hhcnRyZWVFbmVyZ3knLCAgICAgICAgICAgZnVuY3Rpb24gKCkge3JldHVybiBmaXhlZFVuaXQoJzQuMzU5NzQ0MzQxOWUtMTggSicpfSk7XG4gIGxhenkobWF0aCwgJ3Byb3Rvbk1hc3MnLCAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge3JldHVybiBmaXhlZFVuaXQoJzEuNjcyNjIxNzc3NzRlLTI3IGtnJyl9KTtcbiAgbGF6eShtYXRoLCAnZGV1dGVyb25NYXNzJywgICAgICAgICAgICBmdW5jdGlvbiAoKSB7cmV0dXJuIGZpeGVkVW5pdCgnMy4zNDM1ODMwOTI2ZS0yNyBrZycpfSk7XG4gIGxhenkobWF0aCwgJ25ldXRyb25NYXNzJywgICAgICAgICAgICAgZnVuY3Rpb24gKCkge3JldHVybiBmaXhlZFVuaXQoJzEuNjc0OTI3MTYxM2UtMjcga2cnKX0pO1xuICBsYXp5KG1hdGgsICdxdWFudHVtT2ZDaXJjdWxhdGlvbicsICAgIGZ1bmN0aW9uICgpIHtyZXR1cm4gZml4ZWRVbml0KCczLjYzNjk0NzU1MjAyNGUtNCBtXjIgc14tMScpfSk7XG4gIGxhenkobWF0aCwgJ3J5ZGJlcmcnLCAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge3JldHVybiBmaXhlZFVuaXQoJzEwOTczNzMxLjU2ODUzOTU1IG1eLTEnKX0pO1xuICBsYXp5KG1hdGgsICd0aG9tc29uQ3Jvc3NTZWN0aW9uJywgICAgIGZ1bmN0aW9uICgpIHtyZXR1cm4gZml4ZWRVbml0KCc2LjY1MjQ1ODczNDEzZS0yOSBtXjInKX0pO1xuICBsYXp5KG1hdGgsICd3ZWFrTWl4aW5nQW5nbGUnLCAgICAgICAgIGZ1bmN0aW9uICgpIHtyZXR1cm4gMC4yMjIzMjF9KTtcbiAgbGF6eShtYXRoLCAnZWZpbW92RmFjdG9yJywgICAgICAgICAgICBmdW5jdGlvbiAoKSB7cmV0dXJuIDIyLjd9KTtcblxuICAvLyBQaHlzaWNvLWNoZW1pY2FsIGNvbnN0YW50c1xuICBsYXp5KG1hdGgsICdhdG9taWNNYXNzJywgICAgICAgICAgZnVuY3Rpb24gKCkge3JldHVybiBmaXhlZFVuaXQoJzEuNjYwNTM4OTIxNzNlLTI3IGtnJyl9KTtcbiAgbGF6eShtYXRoLCAnYXZvZ2Fkcm8nLCAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtyZXR1cm4gZml4ZWRVbml0KCc2LjAyMjE0MTI5MjdlMjMgbW9sXi0xJyl9KTtcbiAgbGF6eShtYXRoLCAnYm9sdHptYW5uJywgICAgICAgICAgIGZ1bmN0aW9uICgpIHtyZXR1cm4gZml4ZWRVbml0KCcxLjM4MDY0ODgxM2UtMjMgSiBLXi0xJyl9KTtcbiAgbGF6eShtYXRoLCAnZmFyYWRheScsICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtyZXR1cm4gZml4ZWRVbml0KCc5NjQ4NS4zMzY1MjEgQyBtb2xeLTEnKX0pO1xuICBsYXp5KG1hdGgsICdmaXJzdFJhZGlhdGlvbicsICAgICAgZnVuY3Rpb24gKCkge3JldHVybiBmaXhlZFVuaXQoJzMuNzQxNzcxNTMxN2UtMTYgVyBtXjInKX0pO1xuICAvLyBsYXp5KG1hdGgsICdzcGVjdHJhbFJhZGlhbmNlJywgICBmdW5jdGlvbiAoKSB7cmV0dXJuIGZpeGVkVW5pdCgnMS4xOTEwNDI4Njk1M2UtMTYgVyBtXjIgc3JeLTEnKX0pOyAvLyBUT0RPIHNwZWN0cmFsUmFkaWFuY2VcbiAgbGF6eShtYXRoLCAnbG9zY2htaWR0JywgICAgICAgICAgIGZ1bmN0aW9uICgpIHtyZXR1cm4gZml4ZWRVbml0KCcyLjY4Njc4MDUyNGUyNSBtXi0zJyl9KTtcbiAgbGF6eShtYXRoLCAnZ2FzQ29uc3RhbnQnLCAgICAgICAgIGZ1bmN0aW9uICgpIHtyZXR1cm4gZml4ZWRVbml0KCc4LjMxNDQ2MjE3NSBKIEteLTEgbW9sXi0xJyl9KTtcbiAgbGF6eShtYXRoLCAnbW9sYXJQbGFuY2tDb25zdGFudCcsIGZ1bmN0aW9uICgpIHtyZXR1cm4gZml4ZWRVbml0KCczLjk5MDMxMjcxNzYyOGUtMTAgSiBzIG1vbF4tMScpfSk7XG4gIGxhenkobWF0aCwgJ21vbGFyVm9sdW1lJywgICAgICAgICBmdW5jdGlvbiAoKSB7cmV0dXJuIGZpeGVkVW5pdCgnMi4yNDEzOTY4MjBlLTEwIG1eMyBtb2xeLTEnKX0pO1xuICBsYXp5KG1hdGgsICdzYWNrdXJUZXRyb2RlJywgICAgICAgZnVuY3Rpb24gKCkge3JldHVybiAtMS4xNjQ4NzA4MjN9KTtcbiAgbGF6eShtYXRoLCAnc2Vjb25kUmFkaWF0aW9uJywgICAgIGZ1bmN0aW9uICgpIHtyZXR1cm4gZml4ZWRVbml0KCcxLjQzODc3NzAxM2UtMiBtIEsnKX0pO1xuICBsYXp5KG1hdGgsICdzdGVmYW5Cb2x0em1hbm4nLCAgICAgZnVuY3Rpb24gKCkge3JldHVybiBmaXhlZFVuaXQoJzUuNjcwMzczMjFlLTggVyBtXi0yIEteLTQnKX0pO1xuICBsYXp5KG1hdGgsICd3aWVuRGlzcGxhY2VtZW50JywgICAgZnVuY3Rpb24gKCkge3JldHVybiBmaXhlZFVuaXQoJzIuODk3NzcyMTI2ZS0zIG0gSycpfSk7XG5cbiAgLy8gQWRvcHRlZCB2YWx1ZXNcbiAgbGF6eShtYXRoLCAnbW9sYXJNYXNzJywgICAgICAgICBmdW5jdGlvbiAoKSB7cmV0dXJuIGZpeGVkVW5pdCgnMWUtMyBrZyBtb2xeLTEnKX0pO1xuICBsYXp5KG1hdGgsICdtb2xhck1hc3NDMTInLCAgICAgIGZ1bmN0aW9uICgpIHtyZXR1cm4gZml4ZWRVbml0KCcxLjJlLTIga2cgbW9sXi0xJyl9KTtcbiAgbGF6eShtYXRoLCAnZ3Jhdml0eScsICAgICAgICAgICBmdW5jdGlvbiAoKSB7cmV0dXJuIGZpeGVkVW5pdCgnOS44MDY2NSBtIHNeLTInKX0pO1xuICAvLyBhdG0gaXMgZGVmaW5lZCBpbiBVbml0LmpzXG5cbiAgLy8gTmF0dXJhbCB1bml0c1xuICBsYXp5KG1hdGgsICdwbGFuY2tMZW5ndGgnLCAgICAgIGZ1bmN0aW9uICgpIHtyZXR1cm4gZml4ZWRVbml0KCcxLjYxNjE5OTk3ZS0zNSBtJyl9KTtcbiAgbGF6eShtYXRoLCAncGxhbmNrTWFzcycsICAgICAgICBmdW5jdGlvbiAoKSB7cmV0dXJuIGZpeGVkVW5pdCgnMi4xNzY1MTEzZS04IGtnJyl9KTtcbiAgbGF6eShtYXRoLCAncGxhbmNrVGltZScsICAgICAgICBmdW5jdGlvbiAoKSB7cmV0dXJuIGZpeGVkVW5pdCgnNS4zOTEwNjMyZS00NCBzJyl9KTtcbiAgbGF6eShtYXRoLCAncGxhbmNrQ2hhcmdlJywgICAgICBmdW5jdGlvbiAoKSB7cmV0dXJuIGZpeGVkVW5pdCgnMS44NzU1NDU5NTY0MWUtMTggQycpfSk7XG4gIGxhenkobWF0aCwgJ3BsYW5ja1RlbXBlcmF0dXJlJywgZnVuY3Rpb24gKCkge3JldHVybiBmaXhlZFVuaXQoJzEuNDE2ODMzODVlKzMyIEsnKX0pO1xuXG59XG5cbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG5leHBvcnRzLmxhenkgPSBmYWxzZTsgIC8vIG5vIGxhenkgbG9hZGluZyBvZiBjb25zdGFudHMsIHRoZSBjb25zdGFudHMgdGhlbXNlbHZlcyBhcmUgbGF6eSB3aGVuIG5lZWRlZFxuZXhwb3J0cy5tYXRoID0gdHJ1ZTsgICAvLyByZXF1ZXN0IGFjY2VzcyB0byB0aGUgbWF0aCBuYW1lc3BhY2VcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBGb3JtYXQgYSBudW1iZXIgdXNpbmcgbWV0aG9kcyB0b1ByZWNpc2lvbiwgdG9GaXhlZCwgdG9FeHBvbmVudGlhbC5cbiAqIEBwYXJhbSB7bnVtYmVyIHwgc3RyaW5nfSB2YWx1ZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE51bWJlckZvcm1hdHRlciAodmFsdWUpIHtcbiAgLy8gcGFyc2UgdGhlIGlucHV0IHZhbHVlXG4gIHZhciBtYXRjaCA9IFN0cmluZyh2YWx1ZSkudG9Mb3dlckNhc2UoKS5tYXRjaCgvXjAqPygtPykoXFxkK1xcLj9cXGQqKShlKFsrLV0/XFxkKykpPyQvKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignSW52YWxpZCBudW1iZXInKTtcbiAgfVxuXG4gIHZhciBzaWduICAgICAgICAgPSBtYXRjaFsxXTtcbiAgdmFyIGNvZWZmaWNpZW50cyA9IG1hdGNoWzJdO1xuICB2YXIgZXhwb25lbnQgICAgID0gcGFyc2VGbG9hdChtYXRjaFs0XSB8fCAnMCcpO1xuXG4gIHZhciBkb3QgPSBjb2VmZmljaWVudHMuaW5kZXhPZignLicpO1xuICBleHBvbmVudCArPSAoZG90ICE9PSAtMSkgPyAoZG90IC0gMSkgOiAoY29lZmZpY2llbnRzLmxlbmd0aCAtIDEpO1xuXG4gIHRoaXMuc2lnbiA9IHNpZ247XG4gIHRoaXMuY29lZmZpY2llbnRzID0gY29lZmZpY2llbnRzXG4gICAgICAucmVwbGFjZSgnLicsICcnKSAgLy8gcmVtb3ZlIHRoZSBkb3QgKG11c3QgYmUgcmVtb3ZlZCBiZWZvcmUgcmVtb3ZpbmcgbGVhZGluZyB6ZXJvcylcbiAgICAgIC5yZXBsYWNlKC9eMCovLCBmdW5jdGlvbiAoemVyb3MpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGxlYWRpbmcgemVyb3MsIGFkZCB0aGVpciBjb3VudCB0byB0aGUgZXhwb25lbnRcbiAgICAgICAgZXhwb25lbnQgLT0gemVyb3MubGVuZ3RoO1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9KVxuICAgICAgLnJlcGxhY2UoLzAqJC8sICcnKSAvLyByZW1vdmUgdHJhaWxpbmcgemVyb3NcbiAgICAgIC5zcGxpdCgnJylcbiAgICAgIC5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGQpO1xuICAgICAgfSk7XG5cbiAgaWYgKHRoaXMuY29lZmZpY2llbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMuY29lZmZpY2llbnRzLnB1c2goMCk7XG4gICAgZXhwb25lbnQrKztcbiAgfVxuXG4gIHRoaXMuZXhwb25lbnQgPSBleHBvbmVudDtcbn1cblxuXG4vKipcbiAqIEZvcm1hdCBhIG51bWJlciB3aXRoIGVuZ2luZWVyaW5nIG5vdGF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249MF0gICAgICAgIE9wdGlvbmFsIG51bWJlciBvZiBkZWNpbWFscyBhZnRlciB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNpbWFsIHBvaW50LiBaZXJvIGJ5IGRlZmF1bHQuXG4gKi9cbk51bWJlckZvcm1hdHRlci5wcm90b3R5cGUudG9FbmdpbmVlcmluZyA9IGZ1bmN0aW9uKHByZWNpc2lvbikge1xuICB2YXIgcm91bmRlZCA9IHRoaXMucm91bmREaWdpdHMocHJlY2lzaW9uKTtcblxuICB2YXIgZSA9IHJvdW5kZWQuZXhwb25lbnQ7XG4gIHZhciBjID0gcm91bmRlZC5jb2VmZmljaWVudHM7XG5cbiAgLy8gZmluZCBuZWFyZXN0IGxvd2VyIG11bHRpcGxlIG9mIDMgZm9yIGV4cG9uZW50XG4gIHZhciBuZXdFeHAgPSBlICUgMyA9PT0gMCA/IGUgOiAoZSA8IDAgPyAoZSAtIDMpIC0gKGUgJSAzKSA6IGUgLSAoZSAlIDMpKTtcblxuICAvLyBjb25jYXRlbmF0ZSBjb2VmZmljaWVudHMgd2l0aCBuZWNlc3NhcnkgemVyb3NcbiAgdmFyIHNpZ25pZmljYW5kc0RpZmYgPSBlID49IDAgPyBlIDogTWF0aC5hYnMobmV3RXhwKTtcblxuICAvLyBhZGQgemVyb3MgaWYgbmVjZXNzYXJ5IChmb3IgZXg6IDFlKzgpXG4gIGlmIChjLmxlbmd0aCAtIDEgPCBzaWduaWZpY2FuZHNEaWZmKSBjID0gYy5jb25jYXQoemVyb3Moc2lnbmlmaWNhbmRzRGlmZiAtIChjLmxlbmd0aCAtIDEpKSk7XG5cbiAgLy8gZmluZCBkaWZmZXJlbmNlIGluIGV4cG9uZW50c1xuICB2YXIgZXhwRGlmZiA9IE1hdGguYWJzKGUgLSBuZXdFeHApO1xuXG4gIHZhciBkZWNpbWFsSWR4ID0gMTtcbiAgdmFyIHN0ciA9ICcnO1xuXG4gIC8vIHB1c2ggZGVjaW1hbCBpbmRleCBvdmVyIGJ5IGV4cERpZmYgdGltZXNcbiAgd2hpbGUgKC0tZXhwRGlmZiA+PSAwKSBkZWNpbWFsSWR4Kys7XG5cbiAgLy8gaWYgYWxsIGNvZWZmaWNpZW50IHZhbHVlcyBhcmUgemVybyBhZnRlciB0aGUgZGVjaW1hbCBwb2ludCwgZG9uJ3QgYWRkIGEgZGVjaW1hbCB2YWx1ZS4gXG4gIC8vIG90aGVyd2lzZSBjb25jYXQgd2l0aCB0aGUgcmVzdCBvZiB0aGUgY29lZmZpY2llbnRzXG4gIHZhciBkZWNpbWFscyA9IGMuc2xpY2UoZGVjaW1hbElkeCkuam9pbignJyk7XG4gIHZhciBkZWNpbWFsVmFsID0gZGVjaW1hbHMubWF0Y2goL1sxLTldLykgPyAoJy4nICsgZGVjaW1hbHMpIDogJyc7XG5cbiAgc3RyID0gYy5zbGljZSgwLCBkZWNpbWFsSWR4KS5qb2luKCcnKSArIGRlY2ltYWxWYWw7XG5cbiAgc3RyICs9ICdlJyArIChlID49IDAgPyAnKycgOiAnJykgKyBuZXdFeHAudG9TdHJpbmcoKTtcbiAgcmV0dXJuIHJvdW5kZWQuc2lnbiArIHN0cjtcbn1cblxuLyoqXG4gKiBGb3JtYXQgYSBudW1iZXIgd2l0aCBmaXhlZCBub3RhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uPTBdICAgICAgICBPcHRpb25hbCBudW1iZXIgb2YgZGVjaW1hbHMgYWZ0ZXIgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjaW1hbCBwb2ludC4gWmVybyBieSBkZWZhdWx0LlxuICovXG5OdW1iZXJGb3JtYXR0ZXIucHJvdG90eXBlLnRvRml4ZWQgPSBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XG4gIHZhciByb3VuZGVkID0gdGhpcy5yb3VuZERpZ2l0cyh0aGlzLmV4cG9uZW50ICsgMSArIChwcmVjaXNpb24gfHwgMCkpO1xuICB2YXIgYyA9IHJvdW5kZWQuY29lZmZpY2llbnRzO1xuICB2YXIgcCA9IHJvdW5kZWQuZXhwb25lbnQgKyAxOyAvLyBleHBvbmVudCBtYXkgaGF2ZSBjaGFuZ2VkXG5cbiAgLy8gYXBwZW5kIHplcm9zIGlmIG5lZWRlZFxuICB2YXIgcHAgPSBwICsgKHByZWNpc2lvbiB8fCAwKTtcbiAgaWYgKGMubGVuZ3RoIDwgcHApIHtcbiAgICBjID0gYy5jb25jYXQoemVyb3MocHAgLSBjLmxlbmd0aCkpO1xuICB9XG5cbiAgLy8gcHJlcGVuZCB6ZXJvcyBpZiBuZWVkZWRcbiAgaWYgKHAgPCAwKSB7XG4gICAgYyA9IHplcm9zKC1wICsgMSkuY29uY2F0KGMpO1xuICAgIHAgPSAxO1xuICB9XG5cbiAgLy8gaW5zZXJ0IGEgZG90IGlmIG5lZWRlZFxuICBpZiAocHJlY2lzaW9uKSB7XG4gICAgYy5zcGxpY2UocCwgMCwgKHAgPT09IDApID8gJzAuJyA6ICcuJyk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5zaWduICsgYy5qb2luKCcnKTtcbn07XG5cbi8qKlxuICogRm9ybWF0IGEgbnVtYmVyIGluIGV4cG9uZW50aWFsIG5vdGF0aW9uLiBMaWtlICcxLjIzZSs1JywgJzIuM2UrMCcsICczLjUwMGUtMydcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uXSAgTnVtYmVyIG9mIGRpZ2l0cyBpbiBmb3JtYXR0ZWQgb3V0cHV0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBub3QgcHJvdmlkZWQsIHRoZSBtYXhpbXVtIGF2YWlsYWJsZSBkaWdpdHNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgdXNlZC5cbiAqL1xuTnVtYmVyRm9ybWF0dGVyLnByb3RvdHlwZS50b0V4cG9uZW50aWFsID0gZnVuY3Rpb24gKHByZWNpc2lvbikge1xuICAvLyByb3VuZCBpZiBuZWVkZWQsIGVsc2UgY3JlYXRlIGEgY2xvbmVcbiAgdmFyIHJvdW5kZWQgPSBwcmVjaXNpb24gPyB0aGlzLnJvdW5kRGlnaXRzKHByZWNpc2lvbikgOiB0aGlzLmNsb25lKCk7XG4gIHZhciBjID0gcm91bmRlZC5jb2VmZmljaWVudHM7XG4gIHZhciBlID0gcm91bmRlZC5leHBvbmVudDtcblxuICAvLyBhcHBlbmQgemVyb3MgaWYgbmVlZGVkXG4gIGlmIChjLmxlbmd0aCA8IHByZWNpc2lvbikge1xuICAgIGMgPSBjLmNvbmNhdCh6ZXJvcyhwcmVjaXNpb24gLSBjLmxlbmd0aCkpO1xuICB9XG5cbiAgLy8gZm9ybWF0IGFzIGBDLkNDQ2UrRUVFYCBvciBgQy5DQ0NlLUVFRWBcbiAgdmFyIGZpcnN0ID0gYy5zaGlmdCgpO1xuICByZXR1cm4gdGhpcy5zaWduICsgZmlyc3QgKyAoYy5sZW5ndGggPiAwID8gKCcuJyArIGMuam9pbignJykpIDogJycpICtcbiAgICAgICdlJyArIChlID49IDAgPyAnKycgOiAnJykgKyBlO1xufTtcblxuLyoqXG4gKiBGb3JtYXQgYSBudW1iZXIgd2l0aCBhIGNlcnRhaW4gcHJlY2lzaW9uXG4gKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbj11bmRlZmluZWRdIE9wdGlvbmFsIG51bWJlciBvZiBkaWdpdHMuXG4gKiBAcGFyYW0ge3tsb3dlcjogbnVtYmVyIHwgdW5kZWZpbmVkLCB1cHBlcjogbnVtYmVyIHwgdW5kZWZpbmVkfX0gW29wdGlvbnNdXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJ5IGRlZmF1bHQ6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXIgPSAxZS0zIChleGNsKVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyID0gMWUrNSAoaW5jbClcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuTnVtYmVyRm9ybWF0dGVyLnByb3RvdHlwZS50b1ByZWNpc2lvbiA9IGZ1bmN0aW9uKHByZWNpc2lvbiwgb3B0aW9ucykge1xuICAvLyBkZXRlcm1pbmUgbG93ZXIgYW5kIHVwcGVyIGJvdW5kIGZvciBleHBvbmVudGlhbCBub3RhdGlvbi5cbiAgdmFyIGxvd2VyID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5sb3dlciAhPT0gdW5kZWZpbmVkKSA/IG9wdGlvbnMubG93ZXIgOiAxZS0zO1xuICB2YXIgdXBwZXIgPSAob3B0aW9ucyAmJiBvcHRpb25zLnVwcGVyICE9PSB1bmRlZmluZWQpID8gb3B0aW9ucy51cHBlciA6IDFlKzU7XG5cbiAgdmFyIGFicyA9IE1hdGguYWJzKE1hdGgucG93KDEwLCB0aGlzLmV4cG9uZW50KSk7XG4gIGlmIChhYnMgPCBsb3dlciB8fCBhYnMgPj0gdXBwZXIpIHtcbiAgICAvLyBleHBvbmVudGlhbCBub3RhdGlvblxuICAgIHJldHVybiB0aGlzLnRvRXhwb25lbnRpYWwocHJlY2lzaW9uKTtcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgcm91bmRlZCA9IHByZWNpc2lvbiA/IHRoaXMucm91bmREaWdpdHMocHJlY2lzaW9uKSA6IHRoaXMuY2xvbmUoKTtcbiAgICB2YXIgYyA9IHJvdW5kZWQuY29lZmZpY2llbnRzO1xuICAgIHZhciBlID0gcm91bmRlZC5leHBvbmVudDtcblxuICAgIC8vIGFwcGVuZCB0cmFpbGluZyB6ZXJvc1xuICAgIGlmIChjLmxlbmd0aCA8IHByZWNpc2lvbikge1xuICAgICAgYyA9IGMuY29uY2F0KHplcm9zKHByZWNpc2lvbiAtIGMubGVuZ3RoKSk7XG4gICAgfVxuXG4gICAgLy8gYXBwZW5kIHRyYWlsaW5nIHplcm9zXG4gICAgLy8gVE9ETzogc2ltcGxpZnkgdGhlIG5leHQgc3RhdGVtZW50XG4gICAgYyA9IGMuY29uY2F0KHplcm9zKGUgLSBjLmxlbmd0aCArIDEgK1xuICAgICAgICAoYy5sZW5ndGggPCBwcmVjaXNpb24gPyBwcmVjaXNpb24gLSBjLmxlbmd0aCA6IDApKSk7XG5cbiAgICAvLyBwcmVwZW5kIHplcm9zXG4gICAgYyA9IHplcm9zKC1lKS5jb25jYXQoYyk7XG5cbiAgICB2YXIgZG90ID0gZSA+IDAgPyBlIDogMDtcbiAgICBpZiAoZG90IDwgYy5sZW5ndGggLSAxKSB7XG4gICAgICBjLnNwbGljZShkb3QgKyAxLCAwLCAnLicpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNpZ24gKyBjLmpvaW4oJycpO1xuICB9XG59O1xuXG4vKipcbiAqIENyZXRlIGEgY2xvbmUgb2YgdGhlIE51bWJlckZvcm1hdHRlclxuICogQHJldHVybiB7TnVtYmVyRm9ybWF0dGVyfSBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIE51bWJlckZvcm1hdHRlclxuICovXG5OdW1iZXJGb3JtYXR0ZXIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY2xvbmUgPSBuZXcgTnVtYmVyRm9ybWF0dGVyKCcwJyk7XG4gIGNsb25lLnNpZ24gPSB0aGlzLnNpZ247XG4gIGNsb25lLmNvZWZmaWNpZW50cyA9IHRoaXMuY29lZmZpY2llbnRzLnNsaWNlKDApO1xuICBjbG9uZS5leHBvbmVudCA9IHRoaXMuZXhwb25lbnQ7XG4gIHJldHVybiBjbG9uZTtcbn07XG5cbi8qKlxuICogUm91bmQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgYSBudW1iZXIgKlxuICogQHBhcmFtIHtudW1iZXJ9IHByZWNpc2lvbiAgQSBwb3NpdGl2ZSBpbnRlZ2VyXG4gKiBAcmV0dXJuIHtOdW1iZXJGb3JtYXR0ZXJ9ICBSZXR1cm5zIGEgbmV3IE51bWJlckZvcm1hdHRlciB3aXRoIHRoZSByb3VuZGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWdpdHNcbiAqL1xuTnVtYmVyRm9ybWF0dGVyLnByb3RvdHlwZS5yb3VuZERpZ2l0cyA9IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcbiAgdmFyIHJvdW5kZWQgPSB0aGlzLmNsb25lKCk7XG4gIHZhciBjID0gcm91bmRlZC5jb2VmZmljaWVudHM7XG5cbiAgLy8gcHJlcGVuZCB6ZXJvcyBpZiBuZWVkZWRcbiAgd2hpbGUgKHByZWNpc2lvbiA8PSAwKSB7XG4gICAgYy51bnNoaWZ0KDApO1xuICAgIHJvdW5kZWQuZXhwb25lbnQrKztcbiAgICBwcmVjaXNpb24rKztcbiAgfVxuXG4gIGlmIChjLmxlbmd0aCA+IHByZWNpc2lvbikge1xuICAgIHZhciByZW1vdmVkID0gYy5zcGxpY2UocHJlY2lzaW9uLCBjLmxlbmd0aCAtIHByZWNpc2lvbik7XG5cbiAgICBpZiAocmVtb3ZlZFswXSA+PSA1KSB7XG4gICAgICB2YXIgaSA9IHByZWNpc2lvbiAtIDE7XG4gICAgICBjW2ldKys7XG4gICAgICB3aGlsZSAoY1tpXSA9PT0gMTApIHtcbiAgICAgICAgYy5wb3AoKTtcbiAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICBjLnVuc2hpZnQoMCk7XG4gICAgICAgICAgcm91bmRlZC5leHBvbmVudCsrO1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBpLS07XG4gICAgICAgIGNbaV0rKztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcm91bmRlZDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuIGFycmF5IGZpbGxlZCB3aXRoIHplcm9zLlxuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHplcm9zKGxlbmd0aCkge1xuICB2YXIgYXJyID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBhcnIucHVzaCgwKTtcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE51bWJlckZvcm1hdHRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG51bWJlciA9IHJlcXVpcmUoJy4vbnVtYmVyJyk7XG52YXIgc3RyaW5nID0gcmVxdWlyZSgnLi9zdHJpbmcnKTtcbnZhciBvYmplY3QgPSByZXF1aXJlKCcuL29iamVjdCcpO1xudmFyIHR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xuXG52YXIgRGltZW5zaW9uRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci9EaW1lbnNpb25FcnJvcicpO1xudmFyIEluZGV4RXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci9JbmRleEVycm9yJyk7XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBzaXplIG9mIGEgbXVsdGkgZGltZW5zaW9uYWwgYXJyYXkuXG4gKiBUaGlzIGZ1bmN0aW9uIGNoZWNrcyB0aGUgc2l6ZSBvZiB0aGUgZmlyc3QgZW50cnksIGl0IGRvZXMgbm90IHZhbGlkYXRlXG4gKiB3aGV0aGVyIGFsbCBkaW1lbnNpb25zIG1hdGNoLiAodXNlIGZ1bmN0aW9uIGB2YWxpZGF0ZWAgZm9yIHRoYXQpXG4gKiBAcGFyYW0ge0FycmF5fSB4XG4gKiBAUmV0dXJuIHtOdW1iZXJbXX0gc2l6ZVxuICovXG5leHBvcnRzLnNpemUgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgcyA9IFtdO1xuXG4gIHdoaWxlIChBcnJheS5pc0FycmF5KHgpKSB7XG4gICAgcy5wdXNoKHgubGVuZ3RoKTtcbiAgICB4ID0geFswXTtcbiAgfVxuXG4gIHJldHVybiBzO1xufTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSB2YWxpZGF0ZSB3aGV0aGVyIGVhY2ggZWxlbWVudCBpbiBhIG11bHRpIGRpbWVuc2lvbmFsIGFycmF5XG4gKiBoYXMgYSBzaXplIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3ZpZGVkIHNpemUgYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSAgICBBcnJheSB0byBiZSB2YWxpZGF0ZWRcbiAqIEBwYXJhbSB7bnVtYmVyW119IHNpemUgIEFycmF5IHdpdGggdGhlIHNpemUgb2YgZWFjaCBkaW1lbnNpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBkaW0gICBDdXJyZW50IGRpbWVuc2lvblxuICogQHRocm93cyBEaW1lbnNpb25FcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX3ZhbGlkYXRlKGFycmF5LCBzaXplLCBkaW0pIHtcbiAgdmFyIGk7XG4gIHZhciBsZW4gPSBhcnJheS5sZW5ndGg7XG5cbiAgaWYgKGxlbiAhPSBzaXplW2RpbV0pIHtcbiAgICB0aHJvdyBuZXcgRGltZW5zaW9uRXJyb3IobGVuLCBzaXplW2RpbV0pO1xuICB9XG5cbiAgaWYgKGRpbSA8IHNpemUubGVuZ3RoIC0gMSkge1xuICAgIC8vIHJlY3Vyc2l2ZWx5IHZhbGlkYXRlIGVhY2ggY2hpbGQgYXJyYXlcbiAgICB2YXIgZGltTmV4dCA9IGRpbSArIDE7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBhcnJheVtpXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShjaGlsZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IERpbWVuc2lvbkVycm9yKHNpemUubGVuZ3RoIC0gMSwgc2l6ZS5sZW5ndGgsICc8Jyk7XG4gICAgICB9XG4gICAgICBfdmFsaWRhdGUoYXJyYXlbaV0sIHNpemUsIGRpbU5leHQpO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyBsYXN0IGRpbWVuc2lvbi4gbm9uZSBvZiB0aGUgY2hpbGRzIG1heSBiZSBhbiBhcnJheVxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXlbaV0pKSB7XG4gICAgICAgIHRocm93IG5ldyBEaW1lbnNpb25FcnJvcihzaXplLmxlbmd0aCArIDEsIHNpemUubGVuZ3RoLCAnPicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFZhbGlkYXRlIHdoZXRoZXIgZWFjaCBlbGVtZW50IGluIGEgbXVsdGkgZGltZW5zaW9uYWwgYXJyYXkgaGFzXG4gKiBhIHNpemUgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvdmlkZWQgc2l6ZSBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5ICAgIEFycmF5IHRvIGJlIHZhbGlkYXRlZFxuICogQHBhcmFtIHtudW1iZXJbXX0gc2l6ZSAgQXJyYXkgd2l0aCB0aGUgc2l6ZSBvZiBlYWNoIGRpbWVuc2lvblxuICogQHRocm93cyBEaW1lbnNpb25FcnJvclxuICovXG5leHBvcnRzLnZhbGlkYXRlID0gZnVuY3Rpb24oYXJyYXksIHNpemUpIHtcbiAgdmFyIGlzU2NhbGFyID0gKHNpemUubGVuZ3RoID09IDApO1xuICBpZiAoaXNTY2FsYXIpIHtcbiAgICAvLyBzY2FsYXJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnJheSkpIHtcbiAgICAgIHRocm93IG5ldyBEaW1lbnNpb25FcnJvcihhcnJheS5sZW5ndGgsIDApO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyBhcnJheVxuICAgIF92YWxpZGF0ZShhcnJheSwgc2l6ZSwgMCk7XG4gIH1cbn07XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIGluZGV4IGlzIGFuIGludGVnZXIgbnVtYmVyIHdpdGggaW5kZXggPj0gMCBhbmQgaW5kZXggPCBsZW5ndGhcbiAqIHdoZW4gbGVuZ3RoIGlzIHByb3ZpZGVkXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggICAgWmVyby1iYXNlZCBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIExlbmd0aCBvZiB0aGUgYXJyYXlcbiAqL1xuZXhwb3J0cy52YWxpZGF0ZUluZGV4ID0gZnVuY3Rpb24oaW5kZXgsIGxlbmd0aCkge1xuICBpZiAoIW51bWJlci5pc051bWJlcihpbmRleCkgfHwgIW51bWJlci5pc0ludGVnZXIoaW5kZXgpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW5kZXggbXVzdCBiZSBhbiBpbnRlZ2VyICh2YWx1ZTogJyArIGluZGV4ICsgJyknKTtcbiAgfVxuICBpZiAoaW5kZXggPCAwIHx8ICh0eXBlb2YgbGVuZ3RoID09PSAnbnVtYmVyJyAmJiBpbmRleCA+PSBsZW5ndGgpKSB7XG4gICAgdGhyb3cgbmV3IEluZGV4RXJyb3IoaW5kZXgsIGxlbmd0aCk7XG4gIH1cbn07XG5cbi8vIGEgY29uc3RhbnQgdXNlZCB0byBzcGVjaWZ5IGFuIHVuZGVmaW5lZCBkZWZhdWx0VmFsdWVcbmV4cG9ydHMuVU5JTklUSUFMSVpFRCA9IHt9O1xuXG4vKipcbiAqIFJlc2l6ZSBhIG11bHRpIGRpbWVuc2lvbmFsIGFycmF5LiBUaGUgcmVzaXplZCBhcnJheSBpcyByZXR1cm5lZC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5ICAgICAgICAgQXJyYXkgdG8gYmUgcmVzaXplZFxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gc2l6ZSBBcnJheSB3aXRoIHRoZSBzaXplIG9mIGVhY2ggZGltZW5zaW9uXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWU9MF0gIFZhbHVlIHRvIGJlIGZpbGxlZCBpbiBpbiBuZXcgZW50cmllcyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgemVybyBieSBkZWZhdWx0LiBUbyBsZWF2ZSBuZXcgZW50cmllcyB1bmRlZmluZWQsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpZnkgYXJyYXkuVU5JTklUSUFMSVpFRCBhcyBkZWZhdWx0VmFsdWVcbiAqIEByZXR1cm4ge0FycmF5fSBhcnJheSAgICAgICAgIFRoZSByZXNpemVkIGFycmF5XG4gKi9cbmV4cG9ydHMucmVzaXplID0gZnVuY3Rpb24oYXJyYXksIHNpemUsIGRlZmF1bHRWYWx1ZSkge1xuICAvLyBUT0RPOiBhZGQgc3VwcG9ydCBmb3Igc2NhbGFycywgaGF2aW5nIHNpemU9W10gP1xuXG4gIC8vIGNoZWNrIHRoZSB0eXBlIG9mIHRoZSBhcmd1bWVudHNcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSB8fCAhQXJyYXkuaXNBcnJheShzaXplKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5IGV4cGVjdGVkJyk7XG4gIH1cbiAgaWYgKHNpemUubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXNpemluZyB0byBzY2FsYXIgaXMgbm90IHN1cHBvcnRlZCcpO1xuICB9XG5cbiAgLy8gY2hlY2sgd2hldGhlciBzaXplIGNvbnRhaW5zIHBvc2l0aXZlIGludGVnZXJzXG4gIHNpemUuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoIW51bWJlci5pc051bWJlcih2YWx1ZSkgfHwgIW51bWJlci5pc0ludGVnZXIodmFsdWUpIHx8IHZhbHVlIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzaXplLCBtdXN0IGNvbnRhaW4gcG9zaXRpdmUgaW50ZWdlcnMgJyArXG4gICAgICAgICAgJyhzaXplOiAnICsgc3RyaW5nLmZvcm1hdChzaXplKSArICcpJyk7XG4gICAgfVxuICB9KTtcblxuICAvLyByZWN1cnNpdmVseSByZXNpemUgdGhlIGFycmF5XG4gIHZhciBfZGVmYXVsdFZhbHVlID0gKGRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkKSA/IGRlZmF1bHRWYWx1ZSA6IDA7XG4gIF9yZXNpemUoYXJyYXksIHNpemUsIDAsIF9kZWZhdWx0VmFsdWUpO1xuXG4gIHJldHVybiBhcnJheTtcbn07XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgcmVzaXplIGEgbXVsdGkgZGltZW5zaW9uYWwgYXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5ICAgICAgICAgQXJyYXkgdG8gYmUgcmVzaXplZFxuICogQHBhcmFtIHtudW1iZXJbXX0gc2l6ZSAgICAgICBBcnJheSB3aXRoIHRoZSBzaXplIG9mIGVhY2ggZGltZW5zaW9uXG4gKiBAcGFyYW0ge251bWJlcn0gZGltICAgICAgICAgIEN1cnJlbnQgZGltZW5zaW9uXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdICAgIFZhbHVlIHRvIGJlIGZpbGxlZCBpbiBpbiBuZXcgZW50cmllcyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkIGJ5IGRlZmF1bHQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfcmVzaXplIChhcnJheSwgc2l6ZSwgZGltLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIGk7XG4gIHZhciBlbGVtO1xuICB2YXIgb2xkTGVuID0gYXJyYXkubGVuZ3RoO1xuICB2YXIgbmV3TGVuID0gc2l6ZVtkaW1dO1xuICB2YXIgbWluTGVuID0gTWF0aC5taW4ob2xkTGVuLCBuZXdMZW4pO1xuXG4gIC8vIGFwcGx5IG5ldyBsZW5ndGhcbiAgYXJyYXkubGVuZ3RoID0gbmV3TGVuO1xuXG4gIGlmIChkaW0gPCBzaXplLmxlbmd0aCAtIDEpIHtcbiAgICAvLyBub24tbGFzdCBkaW1lbnNpb25cbiAgICB2YXIgZGltTmV4dCA9IGRpbSArIDE7XG5cbiAgICAvLyByZXNpemUgZXhpc3RpbmcgY2hpbGQgYXJyYXlzXG4gICAgZm9yIChpID0gMDsgaSA8IG1pbkxlbjsgaSsrKSB7XG4gICAgICAvLyByZXNpemUgY2hpbGQgYXJyYXlcbiAgICAgIGVsZW0gPSBhcnJheVtpXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShlbGVtKSkge1xuICAgICAgICBlbGVtID0gW2VsZW1dOyAvLyBhZGQgYSBkaW1lbnNpb25cbiAgICAgICAgYXJyYXlbaV0gPSBlbGVtO1xuICAgICAgfVxuICAgICAgX3Jlc2l6ZShlbGVtLCBzaXplLCBkaW1OZXh0LCBkZWZhdWx0VmFsdWUpO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBuZXcgY2hpbGQgYXJyYXlzXG4gICAgZm9yIChpID0gbWluTGVuOyBpIDwgbmV3TGVuOyBpKyspIHtcbiAgICAgIC8vIGdldCBjaGlsZCBhcnJheVxuICAgICAgZWxlbSA9IFtdO1xuICAgICAgYXJyYXlbaV0gPSBlbGVtO1xuXG4gICAgICAvLyByZXNpemUgbmV3IGNoaWxkIGFycmF5XG4gICAgICBfcmVzaXplKGVsZW0sIHNpemUsIGRpbU5leHQsIGRlZmF1bHRWYWx1ZSk7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIC8vIGxhc3QgZGltZW5zaW9uXG5cbiAgICAvLyByZW1vdmUgZGltZW5zaW9ucyBvZiBleGlzdGluZyB2YWx1ZXNcbiAgICBmb3IgKGkgPSAwOyBpIDwgbWluTGVuOyBpKyspIHtcbiAgICAgIHdoaWxlIChBcnJheS5pc0FycmF5KGFycmF5W2ldKSkge1xuICAgICAgICBhcnJheVtpXSA9IGFycmF5W2ldWzBdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKGRlZmF1bHRWYWx1ZSAhPT0gZXhwb3J0cy5VTklOSVRJQUxJWkVEKSB7XG4gICAgICAvLyBmaWxsIG5ldyBlbGVtZW50cyB3aXRoIHRoZSBkZWZhdWx0IHZhbHVlXG4gICAgICBmb3IgKGkgPSBtaW5MZW47IGkgPCBuZXdMZW47IGkrKykge1xuICAgICAgICBhcnJheVtpXSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBTcXVlZXplIGEgbXVsdGkgZGltZW5zaW9uYWwgYXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBbc2l6ZV1cbiAqIEByZXR1cm5zIHtBcnJheX0gcmV0dXJucyB0aGUgYXJyYXkgaXRzZWxmXG4gKi9cbmV4cG9ydHMuc3F1ZWV6ZSA9IGZ1bmN0aW9uKGFycmF5LCBzaXplKSB7XG4gIHZhciBzID0gc2l6ZSB8fCBleHBvcnRzLnNpemUoYXJyYXkpO1xuXG4gIC8vIHNxdWVlemUgb3V0ZXIgZGltZW5zaW9uc1xuICB3aGlsZSAoQXJyYXkuaXNBcnJheShhcnJheSkgJiYgYXJyYXkubGVuZ3RoID09PSAxKSB7XG4gICAgYXJyYXkgPSBhcnJheVswXTtcbiAgICBzLnNoaWZ0KCk7XG4gIH1cblxuICAvLyBmaW5kIHRoZSBmaXJzdCBkaW1lbnNpb24gdG8gYmUgc3F1ZWV6ZWRcbiAgdmFyIGRpbXMgPSBzLmxlbmd0aDtcbiAgd2hpbGUgKHNbZGltcyAtIDFdID09PSAxKSB7XG4gICAgZGltcy0tO1xuICB9XG5cbiAgLy8gc3F1ZWV6ZSBpbm5lciBkaW1lbnNpb25zXG4gIGlmIChkaW1zIDwgcy5sZW5ndGgpIHtcbiAgICBhcnJheSA9IF9zcXVlZXplKGFycmF5LCBkaW1zLCAwKTtcbiAgICBzLmxlbmd0aCA9IGRpbXM7XG4gIH1cblxuICByZXR1cm4gYXJyYXk7XG59O1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHNxdWVlemUgYSBtdWx0aSBkaW1lbnNpb25hbCBhcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaW1zIFJlcXVpcmVkIG51bWJlciBvZiBkaW1lbnNpb25zXG4gKiBAcGFyYW0ge251bWJlcn0gZGltICBDdXJyZW50IGRpbWVuc2lvblxuICogQHJldHVybnMge0FycmF5IHwgKn0gUmV0dXJucyB0aGUgc3F1ZWV6ZWQgYXJyYXlcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9zcXVlZXplIChhcnJheSwgZGltcywgZGltKSB7XG4gIHZhciBpLCBpaTtcblxuICBpZiAoZGltIDwgZGltcykge1xuICAgIHZhciBuZXh0ID0gZGltICsgMTtcbiAgICBmb3IgKGkgPSAwLCBpaSA9IGFycmF5Lmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGFycmF5W2ldID0gX3NxdWVlemUoYXJyYXlbaV0sIGRpbXMsIG5leHQpO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICB3aGlsZSAoQXJyYXkuaXNBcnJheShhcnJheSkpIHtcbiAgICAgIGFycmF5ID0gYXJyYXlbMF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIFVuc3F1ZWV6ZSBhIG11bHRpIGRpbWVuc2lvbmFsIGFycmF5OiBhZGQgZGltZW5zaW9ucyB3aGVuIG1pc3NpbmdcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gKiBAcGFyYW0ge251bWJlcn0gZGltcyAgICAgRGVzaXJlZCBudW1iZXIgb2YgZGltZW5zaW9ucyBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3V0ZXJdICBOdW1iZXIgb2Ygb3V0ZXIgZGltZW5zaW9ucyB0byBiZSBhZGRlZFxuICogQHBhcmFtIHtBcnJheX0gW3NpemVdICAgIEN1cnJlbnQgc2l6ZSBvZiBhcnJheVxuICogQHJldHVybnMge0FycmF5fSByZXR1cm5zIHRoZSBhcnJheSBpdHNlbGZcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMudW5zcXVlZXplID0gZnVuY3Rpb24oYXJyYXksIGRpbXMsIG91dGVyLCBzaXplKSB7XG4gIHZhciBzID0gc2l6ZSB8fCBleHBvcnRzLnNpemUoYXJyYXkpO1xuXG4gIC8vIHVuc3F1ZWV6ZSBvdXRlciBkaW1lbnNpb25zXG4gIGlmIChvdXRlcikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0ZXI7IGkrKykge1xuICAgICAgYXJyYXkgPSBbYXJyYXldO1xuICAgICAgcy51bnNoaWZ0KDEpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHVuc3F1ZWV6ZSBpbm5lciBkaW1lbnNpb25zXG4gIGFycmF5ID0gX3Vuc3F1ZWV6ZShhcnJheSwgZGltcywgMCk7XG4gIHdoaWxlIChzLmxlbmd0aCA8IGRpbXMpIHtcbiAgICBzLnB1c2goMSk7XG4gIH1cblxuICByZXR1cm4gYXJyYXk7XG59O1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHVuc3F1ZWV6ZSBhIG11bHRpIGRpbWVuc2lvbmFsIGFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IGRpbXMgUmVxdWlyZWQgbnVtYmVyIG9mIGRpbWVuc2lvbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaW0gIEN1cnJlbnQgZGltZW5zaW9uXG4gKiBAcmV0dXJucyB7QXJyYXkgfCAqfSBSZXR1cm5zIHRoZSBzcXVlZXplZCBhcnJheVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX3Vuc3F1ZWV6ZSAoYXJyYXksIGRpbXMsIGRpbSkge1xuICB2YXIgaSwgaWk7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgdmFyIG5leHQgPSBkaW0gKyAxO1xuICAgIGZvciAoaSA9IDAsIGlpID0gYXJyYXkubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgYXJyYXlbaV0gPSBfdW5zcXVlZXplKGFycmF5W2ldLCBkaW1zLCBuZXh0KTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgZm9yICh2YXIgZCA9IGRpbTsgZCA8IGRpbXM7IGQrKykge1xuICAgICAgYXJyYXkgPSBbYXJyYXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhcnJheTtcbn1cbi8qKlxuICogRmxhdHRlbiBhIG11bHRpIGRpbWVuc2lvbmFsIGFycmF5LCBwdXQgYWxsIGVsZW1lbnRzIGluIGEgb25lIGRpbWVuc2lvbmFsXG4gKiBhcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgICBBIG11bHRpIGRpbWVuc2lvbmFsIGFycmF5XG4gKiBAcmV0dXJuIHtBcnJheX0gICAgICAgIFRoZSBmbGF0dGVuZWQgYXJyYXkgKDEgZGltZW5zaW9uYWwpXG4gKi9cbmV4cG9ydHMuZmxhdHRlbiA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShhcnJheSkpIHtcbiAgICAvL2lmIG5vdCBhbiBhcnJheSwgcmV0dXJuIGFzIGlzXG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG4gIHZhciBmbGF0ID0gW107XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbiBjYWxsYmFjayh2YWx1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdmFsdWUuZm9yRWFjaChjYWxsYmFjayk7ICAvL3RyYXZlcnNlIHRocm91Z2ggc3ViLWFycmF5cyByZWN1cnNpdmVseVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZsYXQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZmxhdDtcbn07XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIGFuIG9iamVjdCBpcyBhbiBhcnJheVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn0gaXNBcnJheVxuICovXG5leHBvcnRzLmlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuIiwidmFyIGJpdHdpc2UgPSByZXF1aXJlKCcuL2JpdHdpc2UnKTtcblxuLyoqXG4gKiBCaXR3aXNlIGFuZCBmb3IgQmlnbnVtYmVyc1xuICpcbiAqIFNwZWNpYWwgQ2FzZXM6XG4gKiAgIE4gJiAgbiA9ICBOXG4gKiAgIG4gJiAgMCA9ICAwXG4gKiAgIG4gJiAtMSA9ICBuXG4gKiAgIG4gJiAgbiA9ICBuXG4gKiAgIEkgJiAgSSA9ICBJXG4gKiAgLUkgJiAtSSA9IC1JXG4gKiAgIEkgJiAtSSA9ICAwXG4gKiAgIEkgJiAgbiA9ICBuXG4gKiAgIEkgJiAtbiA9ICBJXG4gKiAgLUkgJiAgbiA9ICAwXG4gKiAgLUkgJiAtbiA9IC1JXG4gKlxuICogQHBhcmFtIHtCaWdOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7QmlnTnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtCaWdOdW1iZXJ9IFJlc3VsdCBvZiBgeGAgJiBgeWAsIGlzIGZ1bGx5IHByZWNpc2VcbiAqIEBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYml0QW5kKHgsIHkpIHtcbiAgaWYgKCh4LmlzRmluaXRlKCkgJiYgIXguaXNJbnRlZ2VyKCkpIHx8ICh5LmlzRmluaXRlKCkgJiYgIXkuaXNJbnRlZ2VyKCkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnRlZ2VycyBleHBlY3RlZCBpbiBmdW5jdGlvbiBiaXRBbmQnKTtcbiAgfVxuXG4gIHZhciBCaWdOdW1iZXIgPSB4LmNvbnN0cnVjdG9yO1xuICBpZiAoeC5pc05hTigpIHx8IHkuaXNOYU4oKSkge1xuICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XG4gIH1cblxuICBpZiAoeC5pc1plcm8oKSB8fCB5LmVxKC0xKSB8fCB4LmVxKHkpKSB7XG4gICAgcmV0dXJuIHg7XG4gIH1cbiAgaWYgKHkuaXNaZXJvKCkgfHwgeC5lcSgtMSkpIHtcbiAgICByZXR1cm4geTtcbiAgfVxuXG4gIGlmICgheC5pc0Zpbml0ZSgpIHx8ICF5LmlzRmluaXRlKCkpIHtcbiAgICBpZiAoIXguaXNGaW5pdGUoKSAmJiAheS5pc0Zpbml0ZSgpKSB7XG4gICAgICBpZiAoeC5pc05lZ2F0aXZlKCkgPT0geS5pc05lZ2F0aXZlKCkpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEJpZ051bWJlcigwKTtcbiAgICB9XG4gICAgaWYgKCF4LmlzRmluaXRlKCkpIHtcbiAgICAgIGlmICh5LmlzTmVnYXRpdmUoKSkge1xuICAgICAgICByZXR1cm4geDtcbiAgICAgIH1cbiAgICAgIGlmICh4LmlzTmVnYXRpdmUoKSkge1xuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcigwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB5O1xuICAgIH1cbiAgICBpZiAoIXkuaXNGaW5pdGUoKSkge1xuICAgICAgaWYgKHguaXNOZWdhdGl2ZSgpKSB7XG4gICAgICAgIHJldHVybiB5O1xuICAgICAgfVxuICAgICAgaWYgKHkuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9XG4gIHJldHVybiBiaXR3aXNlKHgsIHksIGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhICYgYiB9KTtcbn07XG4iLCIvKipcbiAqIEJpdHdpc2Ugbm90XG4gKiBAcGFyYW0ge0JpZ051bWJlcn0gdmFsdWVcbiAqIEByZXR1cm4ge0JpZ051bWJlcn0gUmVzdWx0IG9mIH5geGAsIGZ1bGx5IHByZWNpc2VcbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYml0Tm90ICh4KSB7XG4gIGlmICh4LmlzRmluaXRlKCkgJiYgIXguaXNJbnRlZ2VyKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludGVnZXIgZXhwZWN0ZWQgaW4gZnVuY3Rpb24gYml0Tm90Jyk7XG4gIH1cblxuICB2YXIgQmlnTnVtYmVyID0geC5jb25zdHJ1Y3RvcjtcbiAgdmFyIHByZXZQcmVjID0gQmlnTnVtYmVyLnByZWNpc2lvbjtcbiAgQmlnTnVtYmVyLmNvbmZpZyh7cHJlY2lzaW9uOiAxRTl9KTtcblxuICB2YXIgeCA9IHgucGx1cyhuZXcgQmlnTnVtYmVyKDEpKTtcbiAgeC5zID0gLXgucyB8fCBudWxsO1xuXG4gIEJpZ051bWJlci5jb25maWcoe3ByZWNpc2lvbjogcHJldlByZWN9KTtcbiAgcmV0dXJuIHg7XG59O1xuIiwidmFyIGJpdHdpc2UgPSByZXF1aXJlKCcuL2JpdHdpc2UnKTtcblxuLyoqXG4gKiBCaXR3aXNlIE9SIGZvciBCaWdOdW1iZXJzXG4gKlxuICogU3BlY2lhbCBDYXNlczpcbiAqICAgTiB8ICBuID0gIE5cbiAqICAgbiB8ICAwID0gIG5cbiAqICAgbiB8IC0xID0gLTFcbiAqICAgbiB8ICBuID0gIG5cbiAqICAgSSB8ICBJID0gIElcbiAqICAtSSB8IC1JID0gLUlcbiAqICAgSSB8IC1uID0gLTFcbiAqICAgSSB8IC1JID0gLTFcbiAqICAgSSB8ICBuID0gIElcbiAqICAtSSB8ICBuID0gLUlcbiAqICAtSSB8IC1uID0gLW5cbiAqXG4gKiBAcGFyYW0ge0JpZ051bWJlcn0geFxuICogQHBhcmFtIHtCaWdOdW1iZXJ9IHlcbiAqIEByZXR1cm4ge0JpZ051bWJlcn0gUmVzdWx0IG9mIGB4YCB8IGB5YCwgZnVsbHkgcHJlY2lzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpdE9yICh4LCB5KSB7XG4gIGlmICgoeC5pc0Zpbml0ZSgpICYmICF4LmlzSW50ZWdlcigpKSB8fCAoeS5pc0Zpbml0ZSgpICYmICF5LmlzSW50ZWdlcigpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW50ZWdlcnMgZXhwZWN0ZWQgaW4gZnVuY3Rpb24gYml0T3InKTtcbiAgfVxuXG4gIHZhciBCaWdOdW1iZXIgPSB4LmNvbnN0cnVjdG9yO1xuICBpZiAoeC5pc05hTigpIHx8IHkuaXNOYU4oKSkge1xuICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XG4gIH1cblxuICB2YXIgbmVnT25lID0gbmV3IEJpZ051bWJlcigtMSk7XG4gIGlmICh4LmlzWmVybygpIHx8IHkuZXEobmVnT25lKSB8fCB4LmVxKHkpKSB7XG4gICAgcmV0dXJuIHk7XG4gIH1cbiAgaWYgKHkuaXNaZXJvKCkgfHwgeC5lcShuZWdPbmUpKSB7XG4gICAgcmV0dXJuIHg7XG4gIH1cblxuICBpZiAoIXguaXNGaW5pdGUoKSB8fCAheS5pc0Zpbml0ZSgpKSB7XG4gICAgaWYgKCgheC5pc0Zpbml0ZSgpICYmICF4LmlzTmVnYXRpdmUoKSAmJiB5LmlzTmVnYXRpdmUoKSkgfHxcbiAgICAgICAgKHguaXNOZWdhdGl2ZSgpICYmICF5LmlzTmVnYXRpdmUoKSAmJiAheS5pc0Zpbml0ZSgpKSkge1xuICAgICAgcmV0dXJuIG5lZ09uZTtcbiAgICB9XG4gICAgaWYgKHguaXNOZWdhdGl2ZSgpICYmIHkuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICByZXR1cm4geC5pc0Zpbml0ZSgpID8geCA6IHk7XG4gICAgfVxuICAgIHJldHVybiB4LmlzRmluaXRlKCkgPyB5IDogeDtcbiAgfVxuXG4gIHJldHVybiBiaXR3aXNlKHgsIHksIGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhIHwgYiB9KTtcbn07XG4iLCJ2YXIgYml0d2lzZSA9IHJlcXVpcmUoJy4vYml0d2lzZScpO1xudmFyIGJpdE5vdCA9IHJlcXVpcmUoJy4vYml0Tm90Jyk7XG5cbi8qKlxuICogQml0d2lzZSBYT1IgZm9yIEJpZ051bWJlcnNcbiAqXG4gKiBTcGVjaWFsIENhc2VzOlxuICogICBOIF4gIG4gPSAgTlxuICogICBuIF4gIDAgPSAgblxuICogICBuIF4gIG4gPSAgMFxuICogICBuIF4gLTEgPSB+blxuICogICBJIF4gIG4gPSAgSVxuICogICBJIF4gLW4gPSAtSVxuICogICBJIF4gLUkgPSAtMVxuICogIC1JIF4gIG4gPSAtSVxuICogIC1JIF4gLW4gPSAgSVxuICpcbiAqIEBwYXJhbSB7QmlnTnVtYmVyfSB4XG4gKiBAcGFyYW0ge0JpZ051bWJlcn0geVxuICogQHJldHVybiB7QmlnTnVtYmVyfSBSZXN1bHQgb2YgYHhgIF4gYHlgLCBmdWxseSBwcmVjaXNlXG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpdFhvcih4LCB5KSB7XG4gIGlmICgoeC5pc0Zpbml0ZSgpICYmICF4LmlzSW50ZWdlcigpKSB8fCAoeS5pc0Zpbml0ZSgpICYmICF5LmlzSW50ZWdlcigpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW50ZWdlcnMgZXhwZWN0ZWQgaW4gZnVuY3Rpb24gYml0WG9yJyk7XG4gIH1cblxuICB2YXIgQmlnTnVtYmVyID0geC5jb25zdHJ1Y3RvcjtcbiAgaWYgKHguaXNOYU4oKSB8fCB5LmlzTmFOKCkpIHtcbiAgICByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xuICB9XG4gIGlmICh4LmlzWmVybygpKSB7XG4gICAgcmV0dXJuIHk7XG4gIH1cbiAgaWYgKHkuaXNaZXJvKCkpIHtcbiAgICByZXR1cm4geDtcbiAgfVxuXG4gIGlmICh4LmVxKHkpKSB7XG4gICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoMCk7XG4gIH1cblxuICB2YXIgbmVnT25lID0gbmV3IEJpZ051bWJlcigtMSk7XG4gIGlmICh4LmVxKG5lZ09uZSkpIHtcbiAgICByZXR1cm4gYml0Tm90KHkpO1xuICB9XG4gIGlmICh5LmVxKG5lZ09uZSkpIHtcbiAgICByZXR1cm4gYml0Tm90KHgpO1xuICB9XG5cbiAgaWYgKCF4LmlzRmluaXRlKCkgfHwgIXkuaXNGaW5pdGUoKSkge1xuICAgIGlmICgheC5pc0Zpbml0ZSgpICYmICF5LmlzRmluaXRlKCkpIHtcbiAgICAgIHJldHVybiBuZWdPbmU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKHguaXNOZWdhdGl2ZSgpID09IHkuaXNOZWdhdGl2ZSgpXG4gICAgICAgID8gIEluZmluaXR5XG4gICAgICAgIDogLUluZmluaXR5KTtcbiAgfVxuICByZXR1cm4gYml0d2lzZSh4LCB5LCBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSBeIGIgfSk7XG59O1xuIiwidmFyIGJpdE5vdCA9IHJlcXVpcmUoJy4vYml0Tm90Jyk7XG5cbi8qKlxuICogQXBwbGllcyBiaXR3aXNlIGZ1bmN0aW9uIHRvIG51bWJlcnNcbiAqIEBwYXJhbSB7QmlnTnVtYmVyfSB4XG4gKiBAcGFyYW0ge0JpZ051bWJlcn0geVxuICogQHBhcmFtIHtmdW5jdGlvbiAoYSwgYil9IGZ1bmNcbiAqIEByZXR1cm4ge0JpZ051bWJlcn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiaXR3aXNlKHgsIHksIGZ1bmMpIHtcbiAgdmFyIEJpZ051bWJlciA9IHguY29uc3RydWN0b3I7XG5cbiAgdmFyIHhCaXRzLCB5Qml0cztcbiAgdmFyIHhTaWduID0gKyh4LnMgPCAwKTtcbiAgdmFyIHlTaWduID0gKyh5LnMgPCAwKTtcbiAgaWYgKHhTaWduKSB7XG4gICAgeEJpdHMgPSBkZWNDb2VmZmljaWVudFRvQmluYXJ5U3RyaW5nKGJpdE5vdCh4KSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4Qml0cy5sZW5ndGg7ICsraSkge1xuICAgICAgeEJpdHNbaV0gXj0gMTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgeEJpdHMgPSBkZWNDb2VmZmljaWVudFRvQmluYXJ5U3RyaW5nKHgpO1xuICB9XG4gIGlmICh5U2lnbikge1xuICAgIHlCaXRzID0gZGVjQ29lZmZpY2llbnRUb0JpbmFyeVN0cmluZyhiaXROb3QoeSkpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeUJpdHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHlCaXRzW2ldIF49IDE7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHlCaXRzID0gZGVjQ29lZmZpY2llbnRUb0JpbmFyeVN0cmluZyh5KTtcbiAgfVxuXG4gIHZhciBtaW5CaXRzLCBtYXhCaXRzLCBtaW5TaWduO1xuICBpZiAoeEJpdHMubGVuZ3RoIDw9IHlCaXRzLmxlbmd0aCkge1xuICAgIG1pbkJpdHMgPSB4Qml0cztcbiAgICBtYXhCaXRzID0geUJpdHM7XG4gICAgbWluU2lnbiA9IHhTaWduO1xuICB9IGVsc2Uge1xuICAgIG1pbkJpdHMgPSB5Qml0cztcbiAgICBtYXhCaXRzID0geEJpdHM7XG4gICAgbWluU2lnbiA9IHlTaWduO1xuICB9XG5cbiAgdmFyIHNob3J0TGVuID0gbWluQml0cy5sZW5ndGg7XG4gIHZhciBsb25nTGVuID0gbWF4Qml0cy5sZW5ndGg7XG4gIHZhciBleHBGdW5jVmFsID0gZnVuYyh4U2lnbiwgeVNpZ24pIF4gMTtcbiAgdmFyIG91dFZhbCA9IG5ldyBCaWdOdW1iZXIoZXhwRnVuY1ZhbCBeIDEpO1xuICB2YXIgdHdvUG93ZXIgPSBuZXcgQmlnTnVtYmVyKDEpO1xuICB2YXIgdHdvID0gbmV3IEJpZ051bWJlcigyKTtcblxuICB2YXIgcHJldlByZWMgPSBCaWdOdW1iZXIucHJlY2lzaW9uO1xuICBCaWdOdW1iZXIuY29uZmlnKHtwcmVjaXNpb246IDFFOX0pO1xuXG4gIHdoaWxlIChzaG9ydExlbiA+IDApIHtcbiAgICBpZiAoZnVuYyhtaW5CaXRzWy0tc2hvcnRMZW5dLCBtYXhCaXRzWy0tbG9uZ0xlbl0pID09IGV4cEZ1bmNWYWwpIHtcbiAgICAgIG91dFZhbCA9IG91dFZhbC5wbHVzKHR3b1Bvd2VyKTtcbiAgICB9XG4gICAgdHdvUG93ZXIgPSB0d29Qb3dlci50aW1lcyh0d28pO1xuICB9XG4gIHdoaWxlIChsb25nTGVuID4gMCkge1xuICAgIGlmIChmdW5jKG1pblNpZ24sIG1heEJpdHNbLS1sb25nTGVuXSkgPT0gZXhwRnVuY1ZhbCkge1xuICAgICAgb3V0VmFsID0gb3V0VmFsLnBsdXModHdvUG93ZXIpO1xuICAgIH1cbiAgICB0d29Qb3dlciA9IHR3b1Bvd2VyLnRpbWVzKHR3byk7XG4gIH1cblxuICBCaWdOdW1iZXIuY29uZmlnKHtwcmVjaXNpb246IHByZXZQcmVjfSk7XG5cbiAgaWYgKGV4cEZ1bmNWYWwgPT0gMCkge1xuICAgIG91dFZhbC5zID0gLW91dFZhbC5zO1xuICB9XG4gIHJldHVybiBvdXRWYWw7XG59O1xuXG4vKiBFeHRyYWN0ZWQgZnJvbSBkZWNpbWFsLmpzLCBhbmQgZWRpdGVkIHRvIHNwZWNpYWxpemUuICovXG5mdW5jdGlvbiBkZWNDb2VmZmljaWVudFRvQmluYXJ5U3RyaW5nICh4KSB7XG4gIC8vIENvbnZlcnQgdG8gc3RyaW5nXG4gIHZhciBhID0geC5kOyAvLyBhcnJheSB3aXRoIGRpZ2l0c1xuICB2YXIgciA9IGFbMF0gKyAnJztcblxuICBmb3IgKHZhciBpID0gMTsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcyA9IGFbaV0gKyAnJztcbiAgICBmb3IgKHZhciB6ID0gNyAtIHMubGVuZ3RoOyB6LS07ICkge1xuICAgICAgcyA9ICcwJyArIHM7XG4gICAgfVxuXG4gICAgciArPSBzO1xuICB9XG5cbiAgdmFyIGo7XG4gIGZvciAoaiA9IHIubGVuZ3RoIC0gMTsgci5jaGFyQXQoaikgPT0gJzAnOyAtLWopO1xuXG4gIHZhciB4ZSA9IHguZTtcbiAgdmFyIHN0ciA9IHIuc2xpY2UoMCwgaiArIDEgfHwgMSk7XG4gIHZhciBzdHJMID0gc3RyLmxlbmd0aDtcbiAgaWYgKHhlID4gMCkge1xuICAgIGlmICgrK3hlID4gc3RyTCkge1xuICAgICAgLy8gQXBwZW5kIHplcm9zLlxuICAgICAgZm9yICh4ZSAtPSBzdHJMOyB4ZS0tOyBzdHIgKz0gJzAnKTtcbiAgICB9IGVsc2UgaWYgKHhlIDwgc3RyTCkge1xuICAgICAgc3RyID0gc3RyLnNsaWNlKDAsIHhlKSArICcuJyArIHN0ci5zbGljZSh4ZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ29udmVydCBmcm9tIGJhc2UgMTAgKGRlY2ltYWwpIHRvIGJhc2UgMlxuICB2YXIgYXJyID0gWzBdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICkge1xuICAgIGZvciAodmFyIGFyckwgPSBhcnIubGVuZ3RoOyBhcnJMLS07IGFyclthcnJMXSAqPSAxMCk7XG5cbiAgICBhcnJbMF0gKz0gc3RyLmNoYXJBdChpKyspIDw8IDA7ICAvLyBjb252ZXJ0IHRvIGludFxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgYXJyLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAoYXJyW2pdID4gMSkge1xuICAgICAgICBpZiAoYXJyW2ogKyAxXSA9PSBudWxsKSB7XG4gICAgICAgICAgYXJyW2ogKyAxXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBhcnJbaiArIDFdICs9IGFycltqXSA+PiAxO1xuICAgICAgICBhcnJbal0gJj0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXJyLnJldmVyc2UoKTtcbn1cbiIsInZhciBtZW1vaXplID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24nKS5tZW1vaXplO1xuXG4vKipcbiAqIENhbGN1bGF0ZSBCaWdOdW1iZXIgZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gQmlnTnVtYmVyICAgQmlnTnVtYmVyIGNvbnN0cnVjdG9yXG4gKiBAcmV0dXJucyB7QmlnTnVtYmVyfSBSZXR1cm5zIGVcbiAqL1xuZXhwb3J0cy5lID0gbWVtb2l6ZShmdW5jdGlvbiAoQmlnTnVtYmVyKSB7XG4gIHJldHVybiBuZXcgQmlnTnVtYmVyKDEpLmV4cCgpO1xufSwgaGFzaGVyKTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgQmlnTnVtYmVyIGdvbGRlbiByYXRpbywgcGhpID0gKDErc3FydCg1KSkvMlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQmlnTnVtYmVyICAgQmlnTnVtYmVyIGNvbnN0cnVjdG9yXG4gKiBAcmV0dXJucyB7QmlnTnVtYmVyfSBSZXR1cm5zIHBoaVxuICovXG5leHBvcnRzLnBoaSA9IG1lbW9pemUoZnVuY3Rpb24gKEJpZ051bWJlcikge1xuICByZXR1cm4gbmV3IEJpZ051bWJlcigxKS5wbHVzKG5ldyBCaWdOdW1iZXIoNSkuc3FydCgpKS5kaXYoMik7XG59LCBoYXNoZXIpO1xuXG4vKipcbiAqIENhbGN1bGF0ZSBCaWdOdW1iZXIgcGkuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBCaWdOdW1iZXIgICBCaWdOdW1iZXIgY29uc3RydWN0b3JcbiAqIEByZXR1cm5zIHtCaWdOdW1iZXJ9IFJldHVybnMgcGlcbiAqL1xuZXhwb3J0cy5waSA9IG1lbW9pemUoZnVuY3Rpb24gKEJpZ051bWJlcikge1xuICByZXR1cm4gcGkgPSBCaWdOdW1iZXIuYWNvcygtMSk7XG59LCBoYXNoZXIpO1xuXG4vKipcbiAqIENhbGN1bGF0ZSBCaWdOdW1iZXIgdGF1LCB0YXUgPSAyICogcGlcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IEJpZ051bWJlciAgIEJpZ051bWJlciBjb25zdHJ1Y3RvclxuICogQHJldHVybnMge0JpZ051bWJlcn0gUmV0dXJucyB0YXVcbiAqL1xuZXhwb3J0cy50YXUgPSBtZW1vaXplKGZ1bmN0aW9uIChCaWdOdW1iZXIpIHtcbiAgcmV0dXJuIGV4cG9ydHMucGkoQmlnTnVtYmVyKS50aW1lcygyKTtcbn0sIGhhc2hlcik7XG5cbi8qKlxuICogQ3JlYXRlIGEgaGFzaCBmb3IgYSBCaWdOdW1iZXIgY29uc3RydWN0b3IgZnVuY3Rpb24uIFRoZSBjcmVhdGVkIGhhcyBpc1xuICogdGhlIGNvbmZpZ3VyZWQgcHJlY2lzaW9uXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzICAgICAgICAgU3VwcG9zZWQgdG8gY29udGFpbiBhIHNpbmdsZSBlbnRyeSB3aXRoXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBCaWdOdW1iZXIgY29uc3RydWN0b3JcbiAqIEByZXR1cm4ge251bWJlcn0gcHJlY2lzaW9uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBoYXNoZXIgKGFyZ3MpIHtcbiAgcmV0dXJuIGFyZ3NbMF0ucHJlY2lzaW9uO1xufVxuIiwiLyoqXG4gKiBDb252ZXJ0IGEgQmlnTnVtYmVyIHRvIGEgZm9ybWF0dGVkIHN0cmluZyByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBTeW50YXg6XG4gKlxuICogICAgZm9ybWF0KHZhbHVlKVxuICogICAgZm9ybWF0KHZhbHVlLCBvcHRpb25zKVxuICogICAgZm9ybWF0KHZhbHVlLCBwcmVjaXNpb24pXG4gKiAgICBmb3JtYXQodmFsdWUsIGZuKVxuICpcbiAqIFdoZXJlOlxuICpcbiAqICAgIHtudW1iZXJ9IHZhbHVlICAgVGhlIHZhbHVlIHRvIGJlIGZvcm1hdHRlZFxuICogICAge09iamVjdH0gb3B0aW9ucyBBbiBvYmplY3Qgd2l0aCBmb3JtYXR0aW5nIG9wdGlvbnMuIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICB7c3RyaW5nfSBub3RhdGlvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgTnVtYmVyIG5vdGF0aW9uLiBDaG9vc2UgZnJvbTpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICdmaXhlZCcgICAgICAgICAgQWx3YXlzIHVzZSByZWd1bGFyIG51bWJlciBub3RhdGlvbi5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRm9yIGV4YW1wbGUgJzEyMy40MCcgYW5kICcxNDAwMDAwMCdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICdleHBvbmVudGlhbCcgICAgQWx3YXlzIHVzZSBleHBvbmVudGlhbCBub3RhdGlvbi5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRm9yIGV4YW1wbGUgJzEuMjM0ZSsyJyBhbmQgJzEuNGUrNydcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICdhdXRvJyAoZGVmYXVsdCkgUmVndWxhciBudW1iZXIgbm90YXRpb24gZm9yIG51bWJlcnNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGF2aW5nIGFuIGFic29sdXRlIHZhbHVlIGJldHdlZW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGxvd2VyYCBhbmQgYHVwcGVyYCBib3VuZHMsIGFuZCB1c2VzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9uZW50aWFsIG5vdGF0aW9uIGVsc2V3aGVyZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTG93ZXIgYm91bmQgaXMgaW5jbHVkZWQsIHVwcGVyIGJvdW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIGV4Y2x1ZGVkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGb3IgZXhhbXBsZSAnMTIzLjQnIGFuZCAnMS40ZTcnLlxuICogICAgICAgICAgICAgICAgICAgICB7bnVtYmVyfSBwcmVjaXNpb24gICBBIG51bWJlciBiZXR3ZWVuIDAgYW5kIDE2IHRvIHJvdW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBkaWdpdHMgb2YgdGhlIG51bWJlci5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW4gY2FzZSBvZiBub3RhdGlvbnMgJ2V4cG9uZW50aWFsJyBhbmRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2F1dG8nLCBgcHJlY2lzaW9uYCBkZWZpbmVzIHRoZSB0b3RhbFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIHJldHVybmVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCBpcyB1bmRlZmluZWQgYnkgZGVmYXVsdC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW4gY2FzZSBvZiBub3RhdGlvbiAnZml4ZWQnLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgcHJlY2lzaW9uYCBkZWZpbmVzIHRoZSBudW1iZXIgb2ZcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmlmaWNhbnQgZGlnaXRzIGFmdGVyIHRoZSBkZWNpbWFsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50LCBhbmQgaXMgMCBieSBkZWZhdWx0LlxuICogICAgICAgICAgICAgICAgICAgICB7T2JqZWN0fSBleHBvbmVudGlhbCBBbiBvYmplY3QgY29udGFpbmluZyB0d28gcGFyYW1ldGVycyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge251bWJlcn0gbG93ZXIgYW5kIHtudW1iZXJ9IHVwcGVyLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VkIGJ5IG5vdGF0aW9uICdhdXRvJyB0byBkZXRlcm1pbmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlbiB0byByZXR1cm4gZXhwb25lbnRpYWwgbm90YXRpb24uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgdmFsdWVzIGFyZSBgbG93ZXI9MWUtM2AgYW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGB1cHBlcj0xZTVgLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPbmx5IGFwcGxpY2FibGUgZm9yIG5vdGF0aW9uIGBhdXRvYC5cbiAqICAgIHtGdW5jdGlvbn0gZm4gICAgQSBjdXN0b20gZm9ybWF0dGluZyBmdW5jdGlvbi4gQ2FuIGJlIHVzZWQgdG8gb3ZlcnJpZGUgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgIGJ1aWx0LWluIG5vdGF0aW9ucy4gRnVuY3Rpb24gYGZuYCBpcyBjYWxsZWQgd2l0aCBgdmFsdWVgIGFzXG4gKiAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlciBhbmQgbXVzdCByZXR1cm4gYSBzdHJpbmcuIElzIHVzZWZ1bCBmb3IgZXhhbXBsZSB0b1xuICogICAgICAgICAgICAgICAgICAgICBmb3JtYXQgYWxsIHZhbHVlcyBpbnNpZGUgYSBtYXRyaXggaW4gYSBwYXJ0aWN1bGFyIHdheS5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICBmb3JtYXQoNi40KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzYuNCdcbiAqICAgIGZvcm1hdCgxMjQwMDAwKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAnMS4yNGU2J1xuICogICAgZm9ybWF0KDEvMyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICcwLjMzMzMzMzMzMzMzMzMzMzMnXG4gKiAgICBmb3JtYXQoMS8zLCAzKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzAuMzMzJ1xuICogICAgZm9ybWF0KDIxMzg1LCAyKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICcyMTAwMCdcbiAqICAgIGZvcm1hdCgxMi4wNzEsIHtub3RhdGlvbjogJ2ZpeGVkJ30pOyAgICAgICAgICAgICAgICAvLyAnMTInXG4gKiAgICBmb3JtYXQoMi4zLCAgICB7bm90YXRpb246ICdmaXhlZCcsIHByZWNpc2lvbjogMn0pOyAgLy8gJzIuMzAnXG4gKiAgICBmb3JtYXQoNTIuOCwgICB7bm90YXRpb246ICdleHBvbmVudGlhbCd9KTsgICAgICAgICAgLy8gJzUuMjhlKzEnXG4gKlxuICogQHBhcmFtIHtCaWdOdW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge09iamVjdCB8IEZ1bmN0aW9uIHwgbnVtYmVyfSBbb3B0aW9uc11cbiAqIEByZXR1cm4ge3N0cmluZ30gc3RyIFRoZSBmb3JtYXR0ZWQgdmFsdWVcbiAqL1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gaGFuZGxlIGZvcm1hdCh2YWx1ZSwgZm4pXG4gICAgcmV0dXJuIG9wdGlvbnModmFsdWUpO1xuICB9XG5cbiAgLy8gaGFuZGxlIHNwZWNpYWwgY2FzZXNcbiAgaWYgKCF2YWx1ZS5pc0Zpbml0ZSgpKSB7XG4gICAgcmV0dXJuIHZhbHVlLmlzTmFOKCkgPyAnTmFOJyA6ICh2YWx1ZS5ndCgwKSA/ICdJbmZpbml0eScgOiAnLUluZmluaXR5Jyk7XG4gIH1cblxuICAvLyBkZWZhdWx0IHZhbHVlcyBmb3Igb3B0aW9uc1xuICB2YXIgbm90YXRpb24gPSAnYXV0byc7XG4gIHZhciBwcmVjaXNpb24gPSB1bmRlZmluZWQ7XG5cbiAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGRldGVybWluZSBub3RhdGlvbiBmcm9tIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucy5ub3RhdGlvbikge1xuICAgICAgbm90YXRpb24gPSBvcHRpb25zLm5vdGF0aW9uO1xuICAgIH1cblxuICAgIC8vIGRldGVybWluZSBwcmVjaXNpb24gZnJvbSBvcHRpb25zXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJykge1xuICAgICAgcHJlY2lzaW9uID0gb3B0aW9ucztcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0aW9ucy5wcmVjaXNpb24pIHtcbiAgICAgIHByZWNpc2lvbiA9IG9wdGlvbnMucHJlY2lzaW9uO1xuICAgIH1cbiAgfVxuXG4gIC8vIGhhbmRsZSB0aGUgdmFyaW91cyBub3RhdGlvbnNcbiAgc3dpdGNoIChub3RhdGlvbikge1xuICAgIGNhc2UgJ2ZpeGVkJzpcbiAgICAgIHJldHVybiBleHBvcnRzLnRvRml4ZWQodmFsdWUsIHByZWNpc2lvbik7XG5cbiAgICBjYXNlICdleHBvbmVudGlhbCc6XG4gICAgICByZXR1cm4gZXhwb3J0cy50b0V4cG9uZW50aWFsKHZhbHVlLCBwcmVjaXNpb24pO1xuXG4gICAgY2FzZSAnYXV0byc6XG4gICAgICAvLyBkZXRlcm1pbmUgbG93ZXIgYW5kIHVwcGVyIGJvdW5kIGZvciBleHBvbmVudGlhbCBub3RhdGlvbi5cbiAgICAgIC8vIFRPRE86IGltcGxlbWVudCBzdXBwb3J0IGZvciB1cHBlciBhbmQgbG93ZXIgdG8gYmUgQmlnTnVtYmVycyB0aGVtc2VsdmVzXG4gICAgICB2YXIgbG93ZXIgPSAxZS0zO1xuICAgICAgdmFyIHVwcGVyID0gMWU1O1xuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5leHBvbmVudGlhbCkge1xuICAgICAgICBpZiAob3B0aW9ucy5leHBvbmVudGlhbC5sb3dlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbG93ZXIgPSBvcHRpb25zLmV4cG9uZW50aWFsLmxvd2VyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmV4cG9uZW50aWFsLnVwcGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB1cHBlciA9IG9wdGlvbnMuZXhwb25lbnRpYWwudXBwZXI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gYWRqdXN0IHRoZSBjb25maWd1cmF0aW9uIG9mIHRoZSBCaWdOdW1iZXIgY29uc3RydWN0b3IgKHllYWgsIHRoaXMgaXMgcXVpdGUgdHJpY2t5Li4uKVxuICAgICAgdmFyIG9sZENvbmZpZyA9IHtcbiAgICAgICAgdG9FeHBOZWc6IHZhbHVlLmNvbnN0cnVjdG9yLnRvRXhwTmVnLFxuICAgICAgICB0b0V4cFBvczogdmFsdWUuY29uc3RydWN0b3IudG9FeHBQb3NcbiAgICAgIH07XG5cbiAgICAgIHZhbHVlLmNvbnN0cnVjdG9yLmNvbmZpZyh7XG4gICAgICAgIHRvRXhwTmVnOiBNYXRoLnJvdW5kKE1hdGgubG9nKGxvd2VyKSAvIE1hdGguTE4xMCksXG4gICAgICAgIHRvRXhwUG9zOiBNYXRoLnJvdW5kKE1hdGgubG9nKHVwcGVyKSAvIE1hdGguTE4xMClcbiAgICAgIH0pO1xuXG4gICAgICAvLyBoYW5kbGUgc3BlY2lhbCBjYXNlIHplcm9cbiAgICAgIGlmICh2YWx1ZS5pc1plcm8oKSkgcmV0dXJuICcwJztcblxuICAgICAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IHRvIG91dHB1dCBleHBvbmVudGlhbCBub3RhdGlvblxuICAgICAgdmFyIHN0cjtcbiAgICAgIHZhciBhYnMgPSB2YWx1ZS5hYnMoKTtcbiAgICAgIGlmIChhYnMuZ3RlKGxvd2VyKSAmJiBhYnMubHQodXBwZXIpKSB7XG4gICAgICAgIC8vIG5vcm1hbCBudW1iZXIgbm90YXRpb25cbiAgICAgICAgc3RyID0gdmFsdWUudG9TaWduaWZpY2FudERpZ2l0cyhwcmVjaXNpb24pLnRvRml4ZWQoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBleHBvbmVudGlhbCBub3RhdGlvblxuICAgICAgICBzdHIgPSBleHBvcnRzLnRvRXhwb25lbnRpYWwodmFsdWUsIHByZWNpc2lvbik7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB6ZXJvcyBhZnRlciB0aGUgZGVjaW1hbCBwb2ludFxuICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oKFxcLlxcZCo/KSgwKykpKCR8ZSkvLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkaWdpdHMgPSBhcmd1bWVudHNbMl07XG4gICAgICAgIHZhciBlID0gYXJndW1lbnRzWzRdO1xuICAgICAgICByZXR1cm4gKGRpZ2l0cyAhPT0gJy4nKSA/IGRpZ2l0cyArIGUgOiBlO1xuICAgICAgfSk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG5vdGF0aW9uIFwiJyArIG5vdGF0aW9uICsgJ1wiLiAnICtcbiAgICAgICAgICAnQ2hvb3NlIFwiYXV0b1wiLCBcImV4cG9uZW50aWFsXCIsIG9yIFwiZml4ZWRcIi4nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBGb3JtYXQgYSBudW1iZXIgaW4gZXhwb25lbnRpYWwgbm90YXRpb24uIExpa2UgJzEuMjNlKzUnLCAnMi4zZSswJywgJzMuNTAwZS0zJ1xuICogQHBhcmFtIHtCaWdOdW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbl0gIE51bWJlciBvZiBkaWdpdHMgaW4gZm9ybWF0dGVkIG91dHB1dC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgbm90IHByb3ZpZGVkLCB0aGUgbWF4aW11bSBhdmFpbGFibGUgZGlnaXRzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIHVzZWQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBzdHJcbiAqL1xuZXhwb3J0cy50b0V4cG9uZW50aWFsID0gZnVuY3Rpb24gKHZhbHVlLCBwcmVjaXNpb24pIHtcbiAgaWYgKHByZWNpc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvRXhwb25lbnRpYWwocHJlY2lzaW9uIC0gMSk7IC8vIE5vdGUgdGhlIG9mZnNldCBvZiBvbmVcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWUudG9FeHBvbmVudGlhbCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEZvcm1hdCBhIG51bWJlciB3aXRoIGZpeGVkIG5vdGF0aW9uLlxuICogQHBhcmFtIHtCaWdOdW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbj0wXSAgICAgICAgT3B0aW9uYWwgbnVtYmVyIG9mIGRlY2ltYWxzIGFmdGVyIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY2ltYWwgcG9pbnQuIFplcm8gYnkgZGVmYXVsdC5cbiAqL1xuZXhwb3J0cy50b0ZpeGVkID0gZnVuY3Rpb24gKHZhbHVlLCBwcmVjaXNpb24pIHtcbiAgcmV0dXJuIHZhbHVlLnRvRml4ZWQocHJlY2lzaW9uIHx8IDApO1xuICAvLyBOb3RlOiB0aGUgKHByZWNpc2lvbiB8fCAwKSBpcyBuZWVkZWQgYXMgdGhlIHRvRml4ZWQgb2YgQmlnTnVtYmVyIGhhcyBhblxuICAvLyB1bmRlZmluZWQgZGVmYXVsdCBwcmVjaXNpb24gaW5zdGVhZCBvZiAwLlxufTtcbiIsIlxuLyoqXG4gKiBCaXR3aXNlIGxlZnQgc2hpZnRcbiAqXG4gKiBTcGVjaWFsIENhc2VzOlxuICogIG4gPDwgLW4gPSBOXG4gKiAgbiA8PCAgTiA9IE5cbiAqICBOIDw8ICBuID0gTlxuICogIG4gPDwgIDAgPSBuXG4gKiAgMCA8PCAgbiA9IDBcbiAqICBJIDw8ICBJID0gTlxuICogIEkgPDwgIG4gPSBJXG4gKiAgbiA8PCAgSSA9IElcbiAqXG4gKiBAcGFyYW0ge0JpZ051bWJlcn0geFxuICogQHBhcmFtIHtCaWdOdW1iZXJ9IHlcbiAqIEByZXR1cm4ge0JpZ051bWJlcn0gUmVzdWx0IG9mIGB4YCA8PCBgeWBcbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbGVmdFNoaWZ0ICh4LCB5KSB7XG4gIGlmICgoeC5pc0Zpbml0ZSgpICYmICF4LmlzSW50ZWdlcigpKSB8fCAoeS5pc0Zpbml0ZSgpICYmICF5LmlzSW50ZWdlcigpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW50ZWdlcnMgZXhwZWN0ZWQgaW4gZnVuY3Rpb24gbGVmdFNoaWZ0Jyk7XG4gIH1cblxuICB2YXIgQmlnTnVtYmVyID0geC5jb25zdHJ1Y3RvcjtcbiAgaWYgKHguaXNOYU4oKSB8fCB5LmlzTmFOKCkgfHwgKHkuaXNOZWdhdGl2ZSgpICYmICF5LmlzWmVybygpKSkge1xuICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XG4gIH1cbiAgaWYgKHguaXNaZXJvKCkgfHwgeS5pc1plcm8oKSkge1xuICAgIHJldHVybiB4O1xuICB9XG4gIGlmICgheC5pc0Zpbml0ZSgpICYmICF5LmlzRmluaXRlKCkpIHtcbiAgICByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xuICB9XG5cbiAgLy8gTWF0aC5wb3coMiwgeSkgaXMgZnVsbHkgcHJlY2lzZSBmb3IgeSA8IDU1LCBhbmQgZmFzdFxuICBpZiAoeS5sdCg1NSkpIHtcbiAgICByZXR1cm4geC50aW1lcyhNYXRoLnBvdygyLCB5LnRvTnVtYmVyKCkpICsgJycpO1xuICB9XG4gIHJldHVybiB4LnRpbWVzKG5ldyBCaWdOdW1iZXIoMikucG93KHkpKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29tcGFyZXMgdHdvIEJpZ051bWJlcnMuXG4gKiBAcGFyYW0ge0JpZ051bWJlcn0geCAgICAgICBGaXJzdCB2YWx1ZSB0byBjb21wYXJlXG4gKiBAcGFyYW0ge0JpZ051bWJlcn0geSAgICAgICBTZWNvbmQgdmFsdWUgdG8gY29tcGFyZVxuICogQHBhcmFtIHtudW1iZXJ9IFtlcHNpbG9uXSAgVGhlIG1heGltdW0gcmVsYXRpdmUgZGlmZmVyZW5jZSBiZXR3ZWVuIHggYW5kIHlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIGVwc2lsb24gaXMgdW5kZWZpbmVkIG9yIG51bGwsIHRoZSBmdW5jdGlvbiB3aWxsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXN0IHdoZXRoZXIgeCBhbmQgeSBhcmUgZXhhY3RseSBlcXVhbC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IHdoZXRoZXIgdGhlIHR3byBudW1iZXJzIGFyZSBuZWFybHkgZXF1YWxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBuZWFybHlFcXVhbCh4LCB5LCBlcHNpbG9uKSB7XG4gIC8vIGlmIGVwc2lsb24gaXMgbnVsbCBvciB1bmRlZmluZWQsIHRlc3Qgd2hldGhlciB4IGFuZCB5IGFyZSBleGFjdGx5IGVxdWFsXG4gIGlmIChlcHNpbG9uID09IG51bGwpIHtcbiAgICByZXR1cm4geC5lcSh5KTtcbiAgfVxuXG5cbiAgLy8gdXNlIFwiPT1cIiBvcGVyYXRvciwgaGFuZGxlcyBpbmZpbml0aWVzXG4gIGlmICh4LmVxKHkpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBOYU5cbiAgaWYgKHguaXNOYU4oKSB8fCB5LmlzTmFOKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBhdCB0aGlzIHBvaW50IHggYW5kIHkgc2hvdWxkIGJlIGZpbml0ZVxuICBpZih4LmlzRmluaXRlKCkgJiYgeS5pc0Zpbml0ZSgpKSB7XG4gICAgLy8gY2hlY2sgbnVtYmVycyBhcmUgdmVyeSBjbG9zZSwgbmVlZGVkIHdoZW4gY29tcGFyaW5nIG51bWJlcnMgbmVhciB6ZXJvXG4gICAgdmFyIGRpZmYgPSB4Lm1pbnVzKHkpLmFicygpO1xuICAgIGlmIChkaWZmLmlzWmVybygpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyB1c2UgcmVsYXRpdmUgZXJyb3JcbiAgICAgIHZhciBtYXggPSB4LmNvbnN0cnVjdG9yLm1heCh4LmFicygpLCB5LmFicygpKTtcbiAgICAgIHJldHVybiBkaWZmLmx0ZShtYXgudGltZXMoZXBzaWxvbikpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEluZmluaXRlIGFuZCBOdW1iZXIgb3IgbmVnYXRpdmUgSW5maW5pdGUgYW5kIHBvc2l0aXZlIEluZmluaXRlIGNhc2VzXG4gIHJldHVybiBmYWxzZTtcbn07XG4iLCIvKlxuICogU3BlY2lhbCBDYXNlczpcbiAqICAgbiA+PiAtbiA9ICBOXG4gKiAgIG4gPj4gIE4gPSAgTlxuICogICBOID4+ICBuID0gIE5cbiAqICAgSSA+PiAgSSA9ICBOXG4gKiAgIG4gPj4gIDAgPSAgblxuICogICBJID4+ICBuID0gIElcbiAqICAtSSA+PiAgbiA9IC1JXG4gKiAgLUkgPj4gIEkgPSAtSVxuICogICBuID4+ICBJID0gIElcbiAqICAtbiA+PiAgSSA9IC0xXG4gKiAgIDAgPj4gIG4gPSAgMFxuICpcbiAqIEBwYXJhbSB7QmlnTnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtCaWdOdW1iZXJ9IHZhbHVlXG4gKiBAcmV0dXJuIHtCaWdOdW1iZXJ9IFJlc3VsdCBvZiBgeGAgPj4gYHlgXG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJpZ2h0QXJpdGhTaGlmdCAoeCwgeSkge1xuICBpZiAoKHguaXNGaW5pdGUoKSAmJiAheC5pc0ludGVnZXIoKSkgfHwgKHkuaXNGaW5pdGUoKSAmJiAheS5pc0ludGVnZXIoKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludGVnZXJzIGV4cGVjdGVkIGluIGZ1bmN0aW9uIHJpZ2h0QXJpdGhTaGlmdCcpO1xuICB9XG5cbiAgdmFyIEJpZ051bWJlciA9IHguY29uc3RydWN0b3I7XG4gIGlmICh4LmlzTmFOKCkgfHwgeS5pc05hTigpIHx8ICh5LmlzTmVnYXRpdmUoKSAmJiAheS5pc1plcm8oKSkpIHtcbiAgICByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xuICB9XG4gIGlmICh4LmlzWmVybygpIHx8IHkuaXNaZXJvKCkpIHtcbiAgICByZXR1cm4geDtcbiAgfVxuICBpZiAoIXkuaXNGaW5pdGUoKSkge1xuICAgIGlmICh4LmlzTmVnYXRpdmUoKSkge1xuICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoLTEpO1xuICAgIH1cbiAgICBpZiAoIXguaXNGaW5pdGUoKSkge1xuICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoMCk7XG4gIH1cblxuICAvLyBNYXRoLnBvdygyLCB5KSBpcyBmdWxseSBwcmVjaXNlIGZvciB5IDwgNTUsIGFuZCBmYXN0XG4gIGlmICh5Lmx0KDU1KSkge1xuICAgIHJldHVybiB4LmRpdihNYXRoLnBvdygyLCB5LnRvTnVtYmVyKCkpICsgJycpLmZsb29yKCk7XG4gIH1cbiAgcmV0dXJuIHguZGl2KG5ldyBCaWdOdW1iZXIoMikucG93KHkpKS5mbG9vcigpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgdmFsdWUgaXMgYSBib29sZWFuXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtib29sZWFufSBpc0Jvb2xlYW5cbiAqL1xuZXhwb3J0cy5pc0Jvb2xlYW4gPSBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdib29sZWFuJztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0NvbGxlY3Rpb24gPSByZXF1aXJlKCcuL2lzQ29sbGVjdGlvbicpO1xuXG4vKipcbiAqIFRlc3Qgd2hldGhlciBhbiBhcnJheSBjb250YWlucyBjb2xsZWN0aW9uc1xuICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgd2hlbiB0aGUgYXJyYXkgY29udGFpbnMgb25lIG9yIG11bHRpcGxlXG4gKiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbnMgKEFycmF5cyBvciBNYXRyaWNlcykuIFJldHVybnMgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvbnRhaW5zQ29sbGVjdGlvbnMgKGFycmF5KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaXNDb2xsZWN0aW9uKGFycmF5W2ldKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgbG9vcCBvdmVyIGFsbCBlbGVtZW50cyBpbiBhIGdpdmVuIG11bHRpIGRpbWVuc2lvbmFsIGFycmF5XG4gKiBhbmQgaW52b2tlIHRoZSBjYWxsYmFjayBvbiBlYWNoIG9mIHRoZSBlbGVtZW50cy5cbiAqIEBwYXJhbSB7QXJyYXkgfCBNYXRyaXh9IGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAgICAgVGhlIGNhbGxiYWNrIG1ldGhvZCBpcyBpbnZva2VkIHdpdGggb25lXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyOiB0aGUgY3VycmVudCBlbGVtZW50IGluIHRoZSBhcnJheVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZXBGb3JFYWNoIChhcnJheSwgY2FsbGJhY2spIHtcbiAgaWYgKGFycmF5ICYmIGFycmF5LmlzTWF0cml4ID09PSB0cnVlKSB7XG4gICAgYXJyYXkgPSBhcnJheS52YWx1ZU9mKCk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgaWkgPSBhcnJheS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaV07XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGRlZXBGb3JFYWNoKHZhbHVlLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2FsbGJhY2sodmFsdWUpO1xuICAgIH1cbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBFeGVjdXRlIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBlbGVtZW50IHdpc2UgZm9yIGVhY2ggZWxlbWVudCBpbiBhcnJheSBhbmQgYW55XG4gKiBuZXN0ZWQgYXJyYXlcbiAqIFJldHVybnMgYW4gYXJyYXkgd2l0aCB0aGUgcmVzdWx0c1xuICogQHBhcmFtIHtBcnJheSB8IE1hdHJpeH0gYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrICAgVGhlIGNhbGxiYWNrIGlzIGNhbGxlZCB3aXRoIHR3byBwYXJhbWV0ZXJzOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTEgYW5kIHZhbHVlMiwgd2hpY2ggY29udGFpbiB0aGUgY3VycmVudFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50IG9mIGJvdGggYXJyYXlzLlxuICogQHBhcmFtIHtib29sZWFufSBbc2tpcFplcm9zXSBJbnZva2UgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIG5vbi16ZXJvIHZhbHVlcyBvbmx5LlxuICpcbiAqIEByZXR1cm4ge0FycmF5IHwgTWF0cml4fSByZXNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWVwTWFwKGFycmF5LCBjYWxsYmFjaywgc2tpcFplcm9zKSB7XG4gIGlmIChhcnJheSAmJiAodHlwZW9mIGFycmF5Lm1hcCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAvLyBUT0RPOiByZXBsYWNlIGFycmF5Lm1hcCB3aXRoIGEgZm9yIGxvb3AgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZVxuICAgIHJldHVybiBhcnJheS5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBkZWVwTWFwKHgsIGNhbGxiYWNrLCBza2lwWmVyb3MpO1xuICAgIH0pO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBjYWxsYmFjayhhcnJheSk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIGEgdmFsdWUgaXMgYSBjb2xsZWN0aW9uOiBhbiBBcnJheSBvciBNYXRyaXhcbiAqIEBwYXJhbSB7Kn0geFxuICogQHJldHVybnMge2Jvb2xlYW59IGlzQ29sbGVjdGlvblxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQ29sbGVjdGlvbiAoeCkge1xuICByZXR1cm4gKEFycmF5LmlzQXJyYXkoeCkgfHwgKHggJiYgeC5pc01hdHJpeCA9PT0gdHJ1ZSkpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFycmF5U2l6ZSA9IHJlcXVpcmUoJy4uL2FycmF5Jykuc2l6ZTtcbnZhciBJbmRleEVycm9yID0gcmVxdWlyZSgnLi4vLi4vZXJyb3IvSW5kZXhFcnJvcicpO1xuXG4vKipcbiAqIFJlZHVjZSBhIGdpdmVuIG1hdHJpeCBvciBhcnJheSB0byBhIG5ldyBtYXRyaXggb3JcbiAqIGFycmF5IHdpdGggb25lIGxlc3MgZGltZW5zaW9uLCBhcHBseWluZyB0aGUgZ2l2ZW5cbiAqIGNhbGxiYWNrIGluIHRoZSBzZWxlY3RlZCBkaW1lbnNpb24uXG4gKiBAcGFyYW0ge0FycmF5IHwgTWF0cml4fSBtYXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaW1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtBcnJheSB8IE1hdHJpeH0gcmVzXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obWF0LCBkaW0sIGNhbGxiYWNrKSB7XG4gIHZhciBzaXplID0gQXJyYXkuaXNBcnJheShtYXQpID8gYXJyYXlTaXplKG1hdCkgOiBtYXQuc2l6ZSgpO1xuICBpZiAoZGltIDwgMCB8fCAoZGltID49IHNpemUubGVuZ3RoKSkge1xuICAgIC8vIFRPRE86IHdvdWxkIGJlIG1vcmUgY2xlYXIgd2hlbiB0aHJvd2luZyBhIERpbWVuc2lvbkVycm9yIGhlcmVcbiAgICB0aHJvdyBuZXcgSW5kZXhFcnJvcihkaW0sIHNpemUubGVuZ3RoKTtcbiAgfVxuXG4gIGlmIChtYXQgJiYgbWF0LmlzTWF0cml4ID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIG1hdC5jcmVhdGUoX3JlZHVjZShtYXQudmFsdWVPZigpLCBkaW0sIGNhbGxiYWNrKSk7XG4gIH1lbHNlIHtcbiAgICByZXR1cm4gX3JlZHVjZShtYXQsIGRpbSwgY2FsbGJhY2spO1xuICB9XG59O1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHJlZHVjZSBhIG1hdHJpeFxuICogQHBhcmFtIHtBcnJheX0gbWF0XG4gKiBAcGFyYW0ge251bWJlcn0gZGltXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge0FycmF5fSByZXRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9yZWR1Y2UobWF0LCBkaW0sIGNhbGxiYWNrKXtcbiAgdmFyIGksIHJldCwgdmFsLCB0cmFuO1xuXG4gIGlmKGRpbTw9MCl7XG4gICAgaWYoICFBcnJheS5pc0FycmF5KG1hdFswXSkgKXtcbiAgICAgIHZhbCA9IG1hdFswXTtcbiAgICAgIGZvcihpPTE7IGk8bWF0Lmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFsID0gY2FsbGJhY2sodmFsLCBtYXRbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9ZWxzZXtcbiAgICAgIHRyYW4gPSBfc3dpdGNoKG1hdCk7XG4gICAgICByZXQgPSBbXTtcbiAgICAgIGZvcihpPTA7IGk8dHJhbi5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHJldFtpXSA9IF9yZWR1Y2UodHJhbltpXSwgZGltLTEsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9ZWxzZXtcbiAgICByZXQgPSBbXTtcbiAgICBmb3IoaT0wOyBpPG1hdC5sZW5ndGg7IGkrKyl7XG4gICAgICByZXRbaV0gPSBfcmVkdWNlKG1hdFtpXSwgZGltLTEsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxufVxuXG4vKipcbiAqIFRyYW5zcG9zZSBhIG1hdHJpeFxuICogQHBhcmFtIHtBcnJheX0gbWF0XG4gKiBAcmV0dXJucyB7QXJyYXl9IHJldFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX3N3aXRjaChtYXQpe1xuICB2YXIgSSA9IG1hdC5sZW5ndGg7XG4gIHZhciBKID0gbWF0WzBdLmxlbmd0aDtcbiAgdmFyIGksIGo7XG4gIHZhciByZXQgPSBbXTtcbiAgZm9yKCBqPTA7IGo8SjsgaisrKSB7XG4gICAgdmFyIHRtcCA9IFtdO1xuICAgIGZvciggaT0wOyBpPEk7IGkrKykge1xuICAgICAgdG1wLnB1c2gobWF0W2ldW2pdKTtcbiAgICB9XG4gICAgcmV0LnB1c2godG1wKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNjYXR0ZXIoYSwgaiwgdywgeCwgdSwgbWFyaywgYywgZiwgaW52ZXJzZSwgdXBkYXRlLCB2YWx1ZSkge1xuICAvLyBhIGFycmF5c1xuICB2YXIgYXZhbHVlcyA9IGEuX3ZhbHVlcztcbiAgdmFyIGFpbmRleCA9IGEuX2luZGV4O1xuICB2YXIgYXB0ciA9IGEuX3B0cjtcbiAgLy8gYyBhcnJheXNcbiAgdmFyIGNpbmRleCA9IGMuX2luZGV4O1xuXG4gIC8vIHZhcnNcbiAgdmFyIGssIGswLCBrMSwgaTtcblxuICAvLyBjaGVjayB3ZSBuZWVkIHRvIHByb2Nlc3MgdmFsdWVzIChwYXR0ZXJuIG1hdHJpeClcbiAgaWYgKHgpIHtcbiAgICAvLyB2YWx1ZXMgaW4galxuICAgIGZvciAoazAgPSBhcHRyW2pdLCBrMSA9IGFwdHJbaiArIDFdLCBrID0gazA7IGsgPCBrMTsgaysrKSB7XG4gICAgICAvLyByb3dcbiAgICAgIGkgPSBhaW5kZXhba107XG4gICAgICAvLyBjaGVjayB2YWx1ZSBleGlzdHMgaW4gY3VycmVudCBqXG4gICAgICBpZiAod1tpXSAhPT0gbWFyaykge1xuICAgICAgICAvLyBpIGlzIG5ldyBlbnRyeSBpbiBqXG4gICAgICAgIHdbaV0gPSBtYXJrO1xuICAgICAgICAvLyBhZGQgaSB0byBwYXR0ZXJuIG9mIENcbiAgICAgICAgY2luZGV4LnB1c2goaSk7XG4gICAgICAgIC8vIHgoaSkgPSBBLCBjaGVjayB3ZSBuZWVkIHRvIGNhbGwgZnVuY3Rpb24gdGhpcyB0aW1lXG4gICAgICAgIGlmICh1cGRhdGUpIHtcbiAgICAgICAgICAvLyBjb3B5IHZhbHVlIHRvIHdvcmtzcGFjZSBjYWxsaW5nIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgICAgeFtpXSA9IGludmVyc2UgPyBmKGF2YWx1ZXNba10sIHZhbHVlKSA6IGYodmFsdWUsIGF2YWx1ZXNba10pO1xuICAgICAgICAgIC8vIGZ1bmN0aW9uIHdhcyBjYWxsZWQgb24gY3VycmVudCByb3dcbiAgICAgICAgICB1W2ldID0gbWFyaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBjb3B5IHZhbHVlIHRvIHdvcmtzcGFjZVxuICAgICAgICAgIHhbaV0gPSBhdmFsdWVzW2tdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gaSBleGlzdHMgaW4gQyBhbHJlYWR5XG4gICAgICAgIHhbaV0gPSBpbnZlcnNlID8gZihhdmFsdWVzW2tdLCB4W2ldKSA6IGYoeFtpXSwgYXZhbHVlc1trXSk7XG4gICAgICAgIC8vIGZ1bmN0aW9uIHdhcyBjYWxsZWQgb24gY3VycmVudCByb3dcbiAgICAgICAgdVtpXSA9IG1hcms7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIC8vIHZhbHVlcyBpbiBqXG4gICAgZm9yIChrMCA9IGFwdHJbal0sIGsxID0gYXB0cltqICsgMV0sIGsgPSBrMDsgayA8IGsxOyBrKyspIHtcbiAgICAgIC8vIHJvd1xuICAgICAgaSA9IGFpbmRleFtrXTtcbiAgICAgIC8vIGNoZWNrIHZhbHVlIGV4aXN0cyBpbiBjdXJyZW50IGpcbiAgICAgIGlmICh3W2ldICE9PSBtYXJrKSB7XG4gICAgICAgIC8vIGkgaXMgbmV3IGVudHJ5IGluIGpcbiAgICAgICAgd1tpXSA9IG1hcms7XG4gICAgICAgIC8vIGFkZCBpIHRvIHBhdHRlcm4gb2YgQ1xuICAgICAgICBjaW5kZXgucHVzaChpKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBpbmRpY2F0ZSBmdW5jdGlvbiB3YXMgY2FsbGVkIG9uIGN1cnJlbnQgcm93XG4gICAgICAgIHVbaV0gPSBtYXJrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbiIsInZhciBFbWl0dGVyID0gcmVxdWlyZSgndGlueS1lbWl0dGVyJyk7XG5cbi8qKlxuICogRXh0ZW5kIGdpdmVuIG9iamVjdCB3aXRoIGVtaXR0ZXIgZnVuY3Rpb25zIGBvbmAsIGBvZmZgLCBgb25jZWAsIGBlbWl0YFxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fSBvYmpcbiAqL1xuZXhwb3J0cy5taXhpbiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgLy8gY3JlYXRlIGV2ZW50IGVtaXR0ZXJcbiAgdmFyIGVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xuXG4gIC8vIGJpbmQgbWV0aG9kcyB0byBvYmogKHdlIGRvbid0IHdhbnQgdG8gZXhwb3NlIHRoZSBlbWl0dGVyLmUgQXJyYXkuLi4pXG4gIG9iai5vbiAgID0gZW1pdHRlci5vbi5iaW5kKGVtaXR0ZXIpO1xuICBvYmoub2ZmICA9IGVtaXR0ZXIub2ZmLmJpbmQoZW1pdHRlcik7XG4gIG9iai5vbmNlID0gZW1pdHRlci5vbmNlLmJpbmQoZW1pdHRlcik7XG4gIG9iai5lbWl0ID0gZW1pdHRlci5lbWl0LmJpbmQoZW1pdHRlcik7XG5cbiAgcmV0dXJuIG9iajtcbn07XG4iLCIvLyBmdW5jdGlvbiB1dGlsc1xuXG4vKlxuICogTWVtb2l6ZSBhIGdpdmVuIGZ1bmN0aW9uIGJ5IGNhY2hpbmcgdGhlIGNvbXB1dGVkIHJlc3VsdC5cbiAqIFRoZSBjYWNoZSBvZiBhIG1lbW9pemVkIGZ1bmN0aW9uIGNhbiBiZSBjbGVhcmVkIGJ5IGRlbGV0aW5nIHRoZSBgY2FjaGVgXG4gKiBwcm9wZXJ0eSBvZiB0aGUgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gICAgICAgICAgICAgICAgICAgICBUaGUgZnVuY3Rpb24gdG8gYmUgbWVtb2l6ZWQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE11c3QgYmUgYSBwdXJlIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbihhcmdzOiBBcnJheSl9IFtoYXNoZXJdICBBIGN1c3RvbSBoYXNoIGJ1aWxkZXIuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElzIEpTT04uc3RyaW5naWZ5IGJ5IGRlZmF1bHQuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gICAgICAgICAgICAgICAgICAgICAgIFJldHVybnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uXG4gKi9cbmV4cG9ydHMubWVtb2l6ZSA9IGZ1bmN0aW9uKGZuLCBoYXNoZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9pemUoKSB7XG4gICAgaWYgKHR5cGVvZiBtZW1vaXplLmNhY2hlICE9PSAnb2JqZWN0Jykge1xuICAgICAgbWVtb2l6ZS5jYWNoZSA9IHt9O1xuICAgIH1cblxuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgdmFyIGhhc2ggPSBoYXNoZXIgPyBoYXNoZXIoYXJncykgOiBKU09OLnN0cmluZ2lmeShhcmdzKTtcbiAgICBpZiAoIShoYXNoIGluIG1lbW9pemUuY2FjaGUpKSB7XG4gICAgICByZXR1cm4gbWVtb2l6ZS5jYWNoZVtoYXNoXSA9IGZuLmFwcGx5KGZuLCBhcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lbW9pemUuY2FjaGVbaGFzaF07XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmFycmF5ID0gcmVxdWlyZSgnLi9hcnJheScpO1xuZXhwb3J0c1snYm9vbGVhbiddID0gcmVxdWlyZSgnLi9ib29sZWFuJyk7XG5leHBvcnRzWydmdW5jdGlvbiddID0gcmVxdWlyZSgnLi9mdW5jdGlvbicpO1xuZXhwb3J0cy5udW1iZXIgPSByZXF1aXJlKCcuL251bWJlcicpO1xuZXhwb3J0cy5vYmplY3QgPSByZXF1aXJlKCcuL29iamVjdCcpO1xuZXhwb3J0cy5zdHJpbmcgPSByZXF1aXJlKCcuL3N0cmluZycpO1xuZXhwb3J0cy50eXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcbmV4cG9ydHMuZW1pdHRlciA9IHJlcXVpcmUoJy4vZW1pdHRlcicpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLnN5bWJvbHMgPSB7XG4gIC8vIEdSRUVLIExFVFRFUlNcbiAgQWxwaGE6ICdBJywgICAgIGFscGhhOiAnXFxcXGFscGhhJyxcbiAgQmV0YTogJ0InLCAgICAgIGJldGE6ICdcXFxcYmV0YScsXG4gIEdhbW1hOiAnXFxcXEdhbW1hJywgICAgZ2FtbWE6ICdcXFxcZ2FtbWEnLFxuICBEZWx0YTogJ1xcXFxEZWx0YScsICAgIGRlbHRhOiAnXFxcXGRlbHRhJyxcbiAgRXBzaWxvbjogJ0UnLCAgIGVwc2lsb246ICdcXFxcZXBzaWxvbicsICB2YXJlcHNpbG9uOiAnXFxcXHZhcmVwc2lsb24nLFxuICBaZXRhOiAnWicsICAgICAgemV0YTogJ1xcXFx6ZXRhJyxcbiAgRXRhOiAnSCcsICAgICAgIGV0YTogJ1xcXFxldGEnLFxuICBUaGV0YTogJ1xcXFxUaGV0YScsICAgIHRoZXRhOiAnXFxcXHRoZXRhJywgICAgdmFydGhldGE6ICdcXFxcdmFydGhldGEnLFxuICBJb3RhOiAnSScsICAgICAgaW90YTogJ1xcXFxpb3RhJyxcbiAgS2FwcGE6ICdLJywgICAgIGthcHBhOiAnXFxcXGthcHBhJywgICAgdmFya2FwcGE6ICdcXFxcdmFya2FwcGEnLFxuICBMYW1iZGE6ICdcXFxcTGFtYmRhJywgICBsYW1iZGE6ICdcXFxcbGFtYmRhJyxcbiAgTXU6ICdNJywgICAgICAgIG11OiAnXFxcXG11JyxcbiAgTnU6ICdOJywgICAgICAgIG51OiAnXFxcXG51JyxcbiAgWGk6ICdcXFxcWGknLCAgICAgICB4aTogJ1xcXFx4aScsXG4gIE9taWNyb246ICdPJywgICBvbWljcm9uOiAnbycsXG4gIFBpOiAnXFxcXFBpJywgICAgICAgcGk6ICdcXFxccGknLCAgICAgICB2YXJwaTogJ1xcXFx2YXJwaScsXG4gIFJobzogJ1AnLCAgICAgICByaG86ICdcXFxccmhvJywgICAgICB2YXJyaG86ICdcXFxcdmFycmhvJyxcbiAgU2lnbWE6ICdcXFxcU2lnbWEnLCAgICBzaWdtYTogJ1xcXFxzaWdtYScsICAgIHZhcnNpZ21hOiAnXFxcXHZhcnNpZ21hJyxcbiAgVGF1OiAnVCcsICAgICAgIHRhdTogJ1xcXFx0YXUnLFxuICBVcHNpbG9uOiAnXFxcXFVwc2lsb24nLCAgdXBzaWxvbjogJ1xcXFx1cHNpbG9uJyxcbiAgUGhpOiAnXFxcXFBoaScsICAgICAgcGhpOiAnXFxcXHBoaScsICAgICAgdmFycGhpOiAnXFxcXHZhcnBoaScsXG4gIENoaTogJ1gnLCAgICAgICBjaGk6ICdcXFxcY2hpJyxcbiAgUHNpOiAnXFxcXFBzaScsICAgICAgcHNpOiAnXFxcXHBzaScsXG4gIE9tZWdhOiAnXFxcXE9tZWdhJywgICAgb21lZ2E6ICdcXFxcb21lZ2EnLFxuICAvL2xvZ2ljXG4gICd0cnVlJzogJ1xcXFxtYXRocm17VHJ1ZX0nLFxuICAnZmFsc2UnOiAnXFxcXG1hdGhybXtGYWxzZX0nLFxuICAvL290aGVyXG4gIGk6ICdpJywgLy9UT0RPIHVzZSBcXGkgPz9cbiAgaW5mOiAnXFxcXGluZnR5JyxcbiAgSW5mOiAnXFxcXGluZnR5JyxcbiAgaW5maW5pdHk6ICdcXFxcaW5mdHknLFxuICBJbmZpbml0eTogJ1xcXFxpbmZ0eScsXG4gIG9vOiAnXFxcXGluZnR5JyxcbiAgbGltOiAnXFxcXGxpbScsXG4gICd1bmRlZmluZWQnOiAnXFxcXG1hdGhiZns/fSdcbn07XG5cbmV4cG9ydHMub3BlcmF0b3JzID0ge1xuICAndHJhbnNwb3NlJzogJ15cXFxcdG9wJyxcbiAgJ2ZhY3RvcmlhbCc6ICchJyxcbiAgJ3Bvdyc6ICdeJyxcbiAgJ2RvdFBvdyc6ICcuXlxcXFx3ZWRnZScsIC8vVE9ETyBmaW5kIGlkZWFsIHNvbHV0aW9uXG4gICd1bmFyeVBsdXMnOiAnKycsXG4gICd1bmFyeU1pbnVzJzogJy0nLFxuICAnYml0Tm90JzogJ34nLCAvL1RPRE8gZmluZCBpZGVhbCBzb2x1dGlvblxuICAnbm90JzogJ1xcXFxuZWcnLFxuICAnbXVsdGlwbHknOiAnXFxcXGNkb3QnLFxuICAnZGl2aWRlJzogJ1xcXFxmcmFjJywgLy9UT0RPIGhvdyB0byBoYW5kbGUgdGhhdCBwcm9wZXJseT9cbiAgJ2RvdE11bHRpcGx5JzogJy5cXFxcY2RvdCcsIC8vVE9ETyBmaW5kIGlkZWFsIHNvbHV0aW9uXG4gICdkb3REaXZpZGUnOiAnLjonLCAvL1RPRE8gZmluZCBpZGVhbCBzb2x1dGlvblxuICAnbW9kJzogJ1xcXFxtb2QnLFxuICAnYWRkJzogJysnLFxuICAnc3VidHJhY3QnOiAnLScsXG4gICd0byc6ICdcXFxccmlnaHRhcnJvdycsXG4gICdsZWZ0U2hpZnQnOiAnPDwnLFxuICAncmlnaHRBcml0aFNoaWZ0JzogJz4+JyxcbiAgJ3JpZ2h0TG9nU2hpZnQnOiAnPj4+JyxcbiAgJ2VxdWFsJzogJz0nLFxuICAndW5lcXVhbCc6ICdcXFxcbmVxJyxcbiAgJ3NtYWxsZXInOiAnPCcsXG4gICdsYXJnZXInOiAnPicsXG4gICdzbWFsbGVyRXEnOiAnXFxcXGxlcScsXG4gICdsYXJnZXJFcSc6ICdcXFxcZ2VxJyxcbiAgJ2JpdEFuZCc6ICdcXFxcJicsXG4gICdiaXRYb3InOiAnXFxcXHVuZGVybGluZXt8fScsXG4gICdiaXRPcic6ICd8JyxcbiAgJ2FuZCc6ICdcXFxcd2VkZ2UnLFxuICAneG9yJzogJ1xcXFx2ZWViYXInLFxuICAnb3InOiAnXFxcXHZlZSdcbn07XG5cbmV4cG9ydHMuZGVmYXVsdFRlbXBsYXRlID0gJ1xcXFxtYXRocm17JHtuYW1lfX1cXFxcbGVmdCgke2FyZ3N9XFxcXHJpZ2h0KSc7XG5cbnZhciB1bml0cyA9IHtcbiAgZGVnOiAnXlxcXFxjaXJjJ1xufTtcblxuLy9AcGFyYW0ge3N0cmluZ30gbmFtZVxuLy9AcGFyYW0ge2Jvb2xlYW59IGlzVW5pdFxuZXhwb3J0cy50b1N5bWJvbCA9IGZ1bmN0aW9uIChuYW1lLCBpc1VuaXQpIHtcbiAgaXNVbml0ID0gdHlwZW9mIGlzVW5pdCA9PT0gJ3VuZGVmaW5lZCcgPyBmYWxzZSA6IGlzVW5pdDtcbiAgaWYgKGlzVW5pdCkge1xuICAgIGlmICh1bml0cy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgcmV0dXJuIHVuaXRzW25hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gJ1xcXFxtYXRocm17JyArIG5hbWUgKyAnfSc7XG4gIH1cblxuICBpZiAoZXhwb3J0cy5zeW1ib2xzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuc3ltYm9sc1tuYW1lXTtcbiAgfVxuICBlbHNlIGlmIChuYW1lLmluZGV4T2YoJ18nKSAhPT0gLTEpIHtcbiAgICAvL3N5bWJvbCB3aXRoIGluZGV4IChlZy4gYWxwaGFfMSlcbiAgICB2YXIgaW5kZXggPSBuYW1lLmluZGV4T2YoJ18nKTtcbiAgICByZXR1cm4gZXhwb3J0cy50b1N5bWJvbChuYW1lLnN1YnN0cmluZygwLCBpbmRleCkpICsgJ197J1xuICAgICAgKyBleHBvcnRzLnRvU3ltYm9sKG5hbWUuc3Vic3RyaW5nKGluZGV4ICsgMSkpICsgJ30nO1xuICB9XG4gIHJldHVybiBuYW1lO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIE51bWJlckZvcm1hdHRlciA9IHJlcXVpcmUoJy4vTnVtYmVyRm9ybWF0dGVyJyk7XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIHZhbHVlIGlzIGEgbnVtYmVyXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtib29sZWFufSBpc051bWJlclxuICovXG5leHBvcnRzLmlzTnVtYmVyID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcic7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGEgbnVtYmVyIGlzIGludGVnZXJcbiAqIEBwYXJhbSB7bnVtYmVyIHwgYm9vbGVhbn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59IGlzSW50ZWdlclxuICovXG5leHBvcnRzLmlzSW50ZWdlciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc0Zpbml0ZSh2YWx1ZSlcbiAgICAgID8gKHZhbHVlID09IE1hdGgucm91bmQodmFsdWUpKVxuICAgICAgOiBmYWxzZTtcbiAgLy8gTm90ZTogd2UgdXNlID09LCBub3QgPT09LCBhcyB3ZSBjYW4gaGF2ZSBCb29sZWFucyBhcyB3ZWxsXG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgc2lnbiBvZiBhIG51bWJlclxuICogQHBhcmFtIHtudW1iZXJ9IHhcbiAqIEByZXR1cm5zIHsqfVxuICovXG5leHBvcnRzLnNpZ24gPSBmdW5jdGlvbih4KSB7XG4gIGlmICh4ID4gMCkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIGVsc2UgaWYgKHggPCAwKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYSBudW1iZXIgdG8gYSBmb3JtYXR0ZWQgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIFN5bnRheDpcbiAqXG4gKiAgICBmb3JtYXQodmFsdWUpXG4gKiAgICBmb3JtYXQodmFsdWUsIG9wdGlvbnMpXG4gKiAgICBmb3JtYXQodmFsdWUsIHByZWNpc2lvbilcbiAqICAgIGZvcm1hdCh2YWx1ZSwgZm4pXG4gKlxuICogV2hlcmU6XG4gKlxuICogICAge251bWJlcn0gdmFsdWUgICBUaGUgdmFsdWUgdG8gYmUgZm9ybWF0dGVkXG4gKiAgICB7T2JqZWN0fSBvcHRpb25zIEFuIG9iamVjdCB3aXRoIGZvcm1hdHRpbmcgb3B0aW9ucy4gQXZhaWxhYmxlIG9wdGlvbnM6XG4gKiAgICAgICAgICAgICAgICAgICAgIHtzdHJpbmd9IG5vdGF0aW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICBOdW1iZXIgbm90YXRpb24uIENob29zZSBmcm9tOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgJ2ZpeGVkJyAgICAgICAgICBBbHdheXMgdXNlIHJlZ3VsYXIgbnVtYmVyIG5vdGF0aW9uLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGb3IgZXhhbXBsZSAnMTIzLjQwJyBhbmQgJzE0MDAwMDAwJ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgJ2V4cG9uZW50aWFsJyAgICBBbHdheXMgdXNlIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGb3IgZXhhbXBsZSAnMS4yMzRlKzInIGFuZCAnMS40ZSs3J1xuICogICAgICAgICAgICAgICAgICAgICAgICAgJ2VuZ2luZWVyaW5nJyAgICBBbHdheXMgdXNlIGVuZ2luZWVyaW5nIG5vdGF0aW9uLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGb3IgZXhhbXBsZSAnMTIzLjRlKzAgYW5kIDE0LjBlKzYnXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAnYXV0bycgKGRlZmF1bHQpIFJlZ3VsYXIgbnVtYmVyIG5vdGF0aW9uIGZvciBudW1iZXJzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhdmluZyBhbiBhYnNvbHV0ZSB2YWx1ZSBiZXR3ZWVuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBsb3dlcmAgYW5kIGB1cHBlcmAgYm91bmRzLCBhbmQgdXNlc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBvbmVudGlhbCBub3RhdGlvbiBlbHNld2hlcmUuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIExvd2VyIGJvdW5kIGlzIGluY2x1ZGVkLCB1cHBlciBib3VuZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBleGNsdWRlZC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRm9yIGV4YW1wbGUgJzEyMy40JyBhbmQgJzEuNGU3Jy5cbiAqICAgICAgICAgICAgICAgICAgICAge251bWJlcn0gcHJlY2lzaW9uICAgQSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxNiB0byByb3VuZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgZGlnaXRzIG9mIHRoZSBudW1iZXIuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEluIGNhc2Ugb2Ygbm90YXRpb25zICdleHBvbmVudGlhbCcgYW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdhdXRvJywgYHByZWNpc2lvbmAgZGVmaW5lcyB0aGUgdG90YWxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyByZXR1cm5lZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgaXMgdW5kZWZpbmVkIGJ5IGRlZmF1bHQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEluIGNhc2Ugb2Ygbm90YXRpb24gJ2ZpeGVkJyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYHByZWNpc2lvbmAgZGVmaW5lcyB0aGUgbnVtYmVyIG9mXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25pZmljYW50IGRpZ2l0cyBhZnRlciB0aGUgZGVjaW1hbFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludCwgYW5kIGlzIDAgYnkgZGVmYXVsdC5cbiAqICAgICAgICAgICAgICAgICAgICAge09iamVjdH0gZXhwb25lbnRpYWwgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdHdvIHBhcmFtZXRlcnMsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtudW1iZXJ9IGxvd2VyIGFuZCB7bnVtYmVyfSB1cHBlcixcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlZCBieSBub3RhdGlvbiAnYXV0bycgdG8gZGV0ZXJtaW5lXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZW4gdG8gcmV0dXJuIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IHZhbHVlcyBhcmUgYGxvd2VyPTFlLTNgIGFuZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgdXBwZXI9MWU1YC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT25seSBhcHBsaWNhYmxlIGZvciBub3RhdGlvbiBgYXV0b2AuXG4gKiAgICB7RnVuY3Rpb259IGZuICAgIEEgY3VzdG9tIGZvcm1hdHRpbmcgZnVuY3Rpb24uIENhbiBiZSB1c2VkIHRvIG92ZXJyaWRlIHRoZVxuICogICAgICAgICAgICAgICAgICAgICBidWlsdC1pbiBub3RhdGlvbnMuIEZ1bmN0aW9uIGBmbmAgaXMgY2FsbGVkIHdpdGggYHZhbHVlYCBhc1xuICogICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXIgYW5kIG11c3QgcmV0dXJuIGEgc3RyaW5nLiBJcyB1c2VmdWwgZm9yIGV4YW1wbGUgdG9cbiAqICAgICAgICAgICAgICAgICAgICAgZm9ybWF0IGFsbCB2YWx1ZXMgaW5zaWRlIGEgbWF0cml4IGluIGEgcGFydGljdWxhciB3YXkuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgZm9ybWF0KDYuNCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICc2LjQnXG4gKiAgICBmb3JtYXQoMTI0MDAwMCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzEuMjRlNidcbiAqICAgIGZvcm1hdCgxLzMpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAnMC4zMzMzMzMzMzMzMzMzMzMzJ1xuICogICAgZm9ybWF0KDEvMywgMyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICcwLjMzMydcbiAqICAgIGZvcm1hdCgyMTM4NSwgMik7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAnMjEwMDAnXG4gKiAgICBmb3JtYXQoMTIuMDcxLCB7bm90YXRpb246ICdmaXhlZCd9KTsgICAgICAgICAgICAgICAgLy8gJzEyJ1xuICogICAgZm9ybWF0KDIuMywgICAge25vdGF0aW9uOiAnZml4ZWQnLCBwcmVjaXNpb246IDJ9KTsgIC8vICcyLjMwJ1xuICogICAgZm9ybWF0KDUyLjgsICAge25vdGF0aW9uOiAnZXhwb25lbnRpYWwnfSk7ICAgICAgICAgIC8vICc1LjI4ZSsxJ1xuICogICAgZm9ybWF0KDEyMzQ1Njc4LCB7bm90YXRpb246ICdlbmdpbmVlcmluZyd9KTsgICAgICAgIC8vICcxMi4zNDU2NzhlKzYnXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge09iamVjdCB8IEZ1bmN0aW9uIHwgbnVtYmVyfSBbb3B0aW9uc11cbiAqIEByZXR1cm4ge3N0cmluZ30gc3RyIFRoZSBmb3JtYXR0ZWQgdmFsdWVcbiAqL1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbih2YWx1ZSwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBoYW5kbGUgZm9ybWF0KHZhbHVlLCBmbilcbiAgICByZXR1cm4gb3B0aW9ucyh2YWx1ZSk7XG4gIH1cblxuICAvLyBoYW5kbGUgc3BlY2lhbCBjYXNlc1xuICBpZiAodmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgcmV0dXJuICdJbmZpbml0eSc7XG4gIH1cbiAgZWxzZSBpZiAodmFsdWUgPT09IC1JbmZpbml0eSkge1xuICAgIHJldHVybiAnLUluZmluaXR5JztcbiAgfVxuICBlbHNlIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICByZXR1cm4gJ05hTic7XG4gIH1cblxuICAvLyBkZWZhdWx0IHZhbHVlcyBmb3Igb3B0aW9uc1xuICB2YXIgbm90YXRpb24gPSAnYXV0byc7XG4gIHZhciBwcmVjaXNpb24gPSB1bmRlZmluZWQ7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICAvLyBkZXRlcm1pbmUgbm90YXRpb24gZnJvbSBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMubm90YXRpb24pIHtcbiAgICAgIG5vdGF0aW9uID0gb3B0aW9ucy5ub3RhdGlvbjtcbiAgICB9XG5cbiAgICAvLyBkZXRlcm1pbmUgcHJlY2lzaW9uIGZyb20gb3B0aW9uc1xuICAgIGlmIChleHBvcnRzLmlzTnVtYmVyKG9wdGlvbnMpKSB7XG4gICAgICBwcmVjaXNpb24gPSBvcHRpb25zO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcHRpb25zLnByZWNpc2lvbikge1xuICAgICAgcHJlY2lzaW9uID0gb3B0aW9ucy5wcmVjaXNpb247XG4gICAgfVxuICB9XG5cbiAgLy8gaGFuZGxlIHRoZSB2YXJpb3VzIG5vdGF0aW9uc1xuICBzd2l0Y2ggKG5vdGF0aW9uKSB7XG4gICAgY2FzZSAnZml4ZWQnOlxuICAgICAgcmV0dXJuIGV4cG9ydHMudG9GaXhlZCh2YWx1ZSwgcHJlY2lzaW9uKTtcblxuICAgIGNhc2UgJ2V4cG9uZW50aWFsJzpcbiAgICAgIHJldHVybiBleHBvcnRzLnRvRXhwb25lbnRpYWwodmFsdWUsIHByZWNpc2lvbik7XG5cbiAgICBjYXNlICdlbmdpbmVlcmluZyc6XG4gICAgICByZXR1cm4gZXhwb3J0cy50b0VuZ2luZWVyaW5nKHZhbHVlLCBwcmVjaXNpb24pO1xuXG4gICAgY2FzZSAnYXV0byc6XG4gICAgICByZXR1cm4gZXhwb3J0c1xuICAgICAgICAgIC50b1ByZWNpc2lvbih2YWx1ZSwgcHJlY2lzaW9uLCBvcHRpb25zICYmIG9wdGlvbnMuZXhwb25lbnRpYWwpXG5cbiAgICAgICAgICAvLyByZW1vdmUgdHJhaWxpbmcgemVyb3MgYWZ0ZXIgdGhlIGRlY2ltYWwgcG9pbnRcbiAgICAgICAgICAucmVwbGFjZSgvKChcXC5cXGQqPykoMCspKSgkfGUpLywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRpZ2l0cyA9IGFyZ3VtZW50c1syXTtcbiAgICAgICAgICAgIHZhciBlID0gYXJndW1lbnRzWzRdO1xuICAgICAgICAgICAgcmV0dXJuIChkaWdpdHMgIT09ICcuJykgPyBkaWdpdHMgKyBlIDogZTtcbiAgICAgICAgICB9KTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbm90YXRpb24gXCInICsgbm90YXRpb24gKyAnXCIuICcgK1xuICAgICAgICAgICdDaG9vc2UgXCJhdXRvXCIsIFwiZXhwb25lbnRpYWxcIiwgb3IgXCJmaXhlZFwiLicpO1xuICB9XG59O1xuXG4vKipcbiAqIEZvcm1hdCBhIG51bWJlciBpbiBleHBvbmVudGlhbCBub3RhdGlvbi4gTGlrZSAnMS4yM2UrNScsICcyLjNlKzAnLCAnMy41MDBlLTMnXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uXSAgTnVtYmVyIG9mIGRpZ2l0cyBpbiBmb3JtYXR0ZWQgb3V0cHV0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBub3QgcHJvdmlkZWQsIHRoZSBtYXhpbXVtIGF2YWlsYWJsZSBkaWdpdHNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgdXNlZC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IHN0clxuICovXG5leHBvcnRzLnRvRXhwb25lbnRpYWwgPSBmdW5jdGlvbih2YWx1ZSwgcHJlY2lzaW9uKSB7XG4gIHJldHVybiBuZXcgTnVtYmVyRm9ybWF0dGVyKHZhbHVlKS50b0V4cG9uZW50aWFsKHByZWNpc2lvbik7XG59O1xuXG4vKipcbiAqIEZvcm1hdCBhIG51bWJlciBpbiBlbmdpbmVlcmluZyBub3RhdGlvbi4gTGlrZSAnMS4yM2UrNicsICcyLjNlKzAnLCAnMy41MDBlLTMnXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uXSAgTnVtYmVyIG9mIGRpZ2l0cyBpbiBmb3JtYXR0ZWQgb3V0cHV0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBub3QgcHJvdmlkZWQsIHRoZSBtYXhpbXVtIGF2YWlsYWJsZSBkaWdpdHNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgdXNlZC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IHN0clxuICovXG5leHBvcnRzLnRvRW5naW5lZXJpbmcgPSBmdW5jdGlvbih2YWx1ZSwgcHJlY2lzaW9uKSB7XG4gIHJldHVybiBuZXcgTnVtYmVyRm9ybWF0dGVyKHZhbHVlKS50b0VuZ2luZWVyaW5nKHByZWNpc2lvbik7XG59O1xuXG4vKipcbiAqIEZvcm1hdCBhIG51bWJlciB3aXRoIGZpeGVkIG5vdGF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbj0wXSAgICAgICAgT3B0aW9uYWwgbnVtYmVyIG9mIGRlY2ltYWxzIGFmdGVyIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY2ltYWwgcG9pbnQuIFplcm8gYnkgZGVmYXVsdC5cbiAqL1xuZXhwb3J0cy50b0ZpeGVkID0gZnVuY3Rpb24odmFsdWUsIHByZWNpc2lvbikge1xuICByZXR1cm4gbmV3IE51bWJlckZvcm1hdHRlcih2YWx1ZSkudG9GaXhlZChwcmVjaXNpb24pO1xufTtcblxuLyoqXG4gKiBGb3JtYXQgYSBudW1iZXIgd2l0aCBhIGNlcnRhaW4gcHJlY2lzaW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uPXVuZGVmaW5lZF0gT3B0aW9uYWwgbnVtYmVyIG9mIGRpZ2l0cy5cbiAqIEBwYXJhbSB7e2xvd2VyOiBudW1iZXIsIHVwcGVyOiBudW1iZXJ9fSBbb3B0aW9uc10gIEJ5IGRlZmF1bHQ6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb3dlciA9IDFlLTMgKGV4Y2wpXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlciA9IDFlKzUgKGluY2wpXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydHMudG9QcmVjaXNpb24gPSBmdW5jdGlvbih2YWx1ZSwgcHJlY2lzaW9uLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgTnVtYmVyRm9ybWF0dGVyKHZhbHVlKS50b1ByZWNpc2lvbihwcmVjaXNpb24sIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBDb3VudCB0aGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBvZiBhIG51bWJlci5cbiAqXG4gKiBGb3IgZXhhbXBsZTpcbiAqICAgMi4zNCByZXR1cm5zIDNcbiAqICAgMC4wMDM0IHJldHVybnMgMlxuICogICAxMjAuNWUrMzAgcmV0dXJucyA0XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGRpZ2l0cyAgIE51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHNcbiAqL1xuZXhwb3J0cy5kaWdpdHMgPSBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWVcbiAgICAgIC50b0V4cG9uZW50aWFsKClcbiAgICAgIC5yZXBsYWNlKC9lLiokLywgJycpICAgICAgICAgIC8vIHJlbW92ZSBleHBvbmVudGlhbCBub3RhdGlvblxuICAgICAgLnJlcGxhY2UoIC9eMFxcLj8wKnxcXC4vLCAnJykgICAvLyByZW1vdmUgZGVjaW1hbCBwb2ludCBhbmQgbGVhZGluZyB6ZXJvc1xuICAgICAgLmxlbmd0aFxufTtcblxuLyoqXG4gKiBNaW5pbXVtIG51bWJlciBhZGRlZCB0byBvbmUgdGhhdCBtYWtlcyB0aGUgcmVzdWx0IGRpZmZlcmVudCB0aGFuIG9uZVxuICovXG5leHBvcnRzLkRCTF9FUFNJTE9OID0gTnVtYmVyLkVQU0lMT04gfHwgMi4yMjA0NDYwNDkyNTAzMTMwODA4NDcyNjMzMzYxODE2RS0xNjtcblxuLyoqXG4gKiBDb21wYXJlcyB0d28gZmxvYXRpbmcgcG9pbnQgbnVtYmVycy5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4ICAgICAgICAgIEZpcnN0IHZhbHVlIHRvIGNvbXBhcmVcbiAqIEBwYXJhbSB7bnVtYmVyfSB5ICAgICAgICAgIFNlY29uZCB2YWx1ZSB0byBjb21wYXJlXG4gKiBAcGFyYW0ge251bWJlcn0gW2Vwc2lsb25dICBUaGUgbWF4aW11bSByZWxhdGl2ZSBkaWZmZXJlbmNlIGJldHdlZW4geCBhbmQgeVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgZXBzaWxvbiBpcyB1bmRlZmluZWQgb3IgbnVsbCwgdGhlIGZ1bmN0aW9uIHdpbGxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlc3Qgd2hldGhlciB4IGFuZCB5IGFyZSBleGFjdGx5IGVxdWFsLlxuICogQHJldHVybiB7Ym9vbGVhbn0gd2hldGhlciB0aGUgdHdvIG51bWJlcnMgYXJlIG5lYXJseSBlcXVhbFxuKi9cbmV4cG9ydHMubmVhcmx5RXF1YWwgPSBmdW5jdGlvbih4LCB5LCBlcHNpbG9uKSB7XG4gIC8vIGlmIGVwc2lsb24gaXMgbnVsbCBvciB1bmRlZmluZWQsIHRlc3Qgd2hldGhlciB4IGFuZCB5IGFyZSBleGFjdGx5IGVxdWFsXG4gIGlmIChlcHNpbG9uID09IG51bGwpIHtcbiAgICByZXR1cm4geCA9PSB5O1xuICB9XG5cbiAgLy8gdXNlIFwiPT1cIiBvcGVyYXRvciwgaGFuZGxlcyBpbmZpbml0aWVzXG4gIGlmICh4ID09IHkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIE5hTlxuICBpZiAoaXNOYU4oeCkgfHwgaXNOYU4oeSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBhdCB0aGlzIHBvaW50IHggYW5kIHkgc2hvdWxkIGJlIGZpbml0ZVxuICBpZihpc0Zpbml0ZSh4KSAmJiBpc0Zpbml0ZSh5KSkge1xuICAgIC8vIGNoZWNrIG51bWJlcnMgYXJlIHZlcnkgY2xvc2UsIG5lZWRlZCB3aGVuIGNvbXBhcmluZyBudW1iZXJzIG5lYXIgemVyb1xuICAgIHZhciBkaWZmID0gTWF0aC5hYnMoeCAtIHkpO1xuICAgIGlmIChkaWZmIDwgZXhwb3J0cy5EQkxfRVBTSUxPTikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gdXNlIHJlbGF0aXZlIGVycm9yXG4gICAgICByZXR1cm4gZGlmZiA8PSBNYXRoLm1heChNYXRoLmFicyh4KSwgTWF0aC5hYnMoeSkpICogZXBzaWxvbjtcbiAgICB9XG4gIH1cblxuICAvLyBJbmZpbml0ZSBhbmQgTnVtYmVyIG9yIG5lZ2F0aXZlIEluZmluaXRlIGFuZCBwb3NpdGl2ZSBJbmZpbml0ZSBjYXNlc1xuICByZXR1cm4gZmFsc2U7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENsb25lIGFuIG9iamVjdFxuICpcbiAqICAgICBjbG9uZSh4KVxuICpcbiAqIENhbiBjbG9uZSBhbnkgcHJpbWl0aXZlIHR5cGUsIGFycmF5LCBhbmQgb2JqZWN0LlxuICogSWYgeCBoYXMgYSBmdW5jdGlvbiBjbG9uZSwgdGhpcyBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgdG8gY2xvbmUgdGhlIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0geyp9IHhcbiAqIEByZXR1cm4geyp9IGNsb25lXG4gKi9cbmV4cG9ydHMuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSh4KSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHg7XG5cbiAgLy8gaW1tdXRhYmxlIHByaW1pdGl2ZSB0eXBlc1xuICBpZiAodHlwZSA9PT0gJ251bWJlcicgfHwgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB4ID09PSBudWxsIHx8IHggPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB4O1xuICB9XG5cbiAgLy8gdXNlIGNsb25lIGZ1bmN0aW9uIG9mIHRoZSBvYmplY3Qgd2hlbiBhdmFpbGFibGVcbiAgaWYgKHR5cGVvZiB4LmNsb25lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHguY2xvbmUoKTtcbiAgfVxuXG4gIC8vIGFycmF5XG4gIGlmIChBcnJheS5pc0FycmF5KHgpKSB7XG4gICAgcmV0dXJuIHgubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGNsb25lKHZhbHVlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmICh4IGluc3RhbmNlb2YgTnVtYmVyKSAgICByZXR1cm4gbmV3IE51bWJlcih4LnZhbHVlT2YoKSk7XG4gIGlmICh4IGluc3RhbmNlb2YgU3RyaW5nKSAgICByZXR1cm4gbmV3IFN0cmluZyh4LnZhbHVlT2YoKSk7XG4gIGlmICh4IGluc3RhbmNlb2YgQm9vbGVhbikgICByZXR1cm4gbmV3IEJvb2xlYW4oeC52YWx1ZU9mKCkpO1xuICBpZiAoeCBpbnN0YW5jZW9mIERhdGUpICAgICAgcmV0dXJuIG5ldyBEYXRlKHgudmFsdWVPZigpKTtcbiAgaWYgKHggJiYgeC5pc0JpZ051bWJlciA9PT0gdHJ1ZSkgcmV0dXJuIHg7IC8vIGJpZ251bWJlcnMgYXJlIGltbXV0YWJsZVxuICBpZiAoeCBpbnN0YW5jZW9mIFJlZ0V4cCkgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjbG9uZSAnICsgeCk7ICAvLyBUT0RPOiBjbG9uZSBhIFJlZ0V4cFxuXG4gIC8vIG9iamVjdFxuICB2YXIgbSA9IHt9O1xuICBmb3IgKHZhciBrZXkgaW4geCkge1xuICAgIGlmICh4Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIG1ba2V5XSA9IGNsb25lKHhba2V5XSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtO1xufTtcblxuLyoqXG4gKiBFeHRlbmQgb2JqZWN0IGEgd2l0aCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYlxuICogQHBhcmFtIHtPYmplY3R9IGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBiXG4gKiBAcmV0dXJuIHtPYmplY3R9IGFcbiAqL1xuZXhwb3J0cy5leHRlbmQgPSBmdW5jdGlvbihhLCBiKSB7XG4gIGZvciAodmFyIHByb3AgaW4gYikge1xuICAgIGlmIChiLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICBhW3Byb3BdID0gYltwcm9wXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGE7XG59O1xuXG4vKipcbiAqIERlZXAgZXh0ZW5kIGFuIG9iamVjdCBhIHdpdGggdGhlIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGJcbiAqIEBwYXJhbSB7T2JqZWN0fSBhXG4gKiBAcGFyYW0ge09iamVjdH0gYlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZXhwb3J0cy5kZWVwRXh0ZW5kID0gZnVuY3Rpb24gZGVlcEV4dGVuZCAoYSwgYikge1xuICAvLyBUT0RPOiBhZGQgc3VwcG9ydCBmb3IgQXJyYXlzIHRvIGRlZXBFeHRlbmRcbiAgaWYgKEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgZGVlcEV4dGVuZCcpO1xuICB9XG5cbiAgZm9yICh2YXIgcHJvcCBpbiBiKSB7XG4gICAgaWYgKGIuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgIGlmIChiW3Byb3BdICYmIGJbcHJvcF0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICBpZiAoYVtwcm9wXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYVtwcm9wXSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChhW3Byb3BdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICBkZWVwRXh0ZW5kKGFbcHJvcF0sIGJbcHJvcF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGFbcHJvcF0gPSBiW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYltwcm9wXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXlzIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IGRlZXBFeHRlbmQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFbcHJvcF0gPSBiW3Byb3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYTtcbn07XG5cbi8qKlxuICogRGVlcCB0ZXN0IGVxdWFsaXR5IG9mIGFsbCBmaWVsZHMgaW4gdHdvIHBhaXJzIG9mIGFycmF5cyBvciBvYmplY3RzLlxuICogQHBhcmFtIHtBcnJheSB8IE9iamVjdH0gYVxuICogQHBhcmFtIHtBcnJheSB8IE9iamVjdH0gYlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuZGVlcEVxdWFsID0gZnVuY3Rpb24gZGVlcEVxdWFsIChhLCBiKSB7XG4gIHZhciBwcm9wLCBpLCBsZW47XG4gIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgbGVuID0gYS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKCFleHBvcnRzLmRlZXBFcXVhbChhW2ldLCBiW2ldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShiKSB8fCAhKGIgaW5zdGFuY2VvZiBPYmplY3QpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yIChwcm9wIGluIGEpIHtcbiAgICAgIC8vbm9pbnNwZWN0aW9uIEpTVW5maWx0ZXJlZEZvckluTG9vcFxuICAgICAgaWYgKCFleHBvcnRzLmRlZXBFcXVhbChhW3Byb3BdLCBiW3Byb3BdKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAocHJvcCBpbiBiKSB7XG4gICAgICAvL25vaW5zcGVjdGlvbiBKU1VuZmlsdGVyZWRGb3JJbkxvb3BcbiAgICAgIGlmICghZXhwb3J0cy5kZWVwRXF1YWwoYVtwcm9wXSwgYltwcm9wXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gKHR5cGVvZiBhID09PSB0eXBlb2YgYikgJiYgKGEgPT0gYik7XG4gIH1cbn07XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIHRoZSBjdXJyZW50IEphdmFTY3JpcHQgZW5naW5lIHN1cHBvcnRzIE9iamVjdC5kZWZpbmVQcm9wZXJ0eVxuICogQHJldHVybnMge2Jvb2xlYW59IHJldHVybnMgdHJ1ZSBpZiBzdXBwb3J0ZWRcbiAqL1xuZXhwb3J0cy5jYW5EZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gdGVzdCBuZWVkZWQgZm9yIGJyb2tlbiBJRTggaW1wbGVtZW50YXRpb25cbiAgdHJ5IHtcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICd4JywgeyBnZXQ6IGZ1bmN0aW9uICgpIHt9IH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7fVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQXR0YWNoIGEgbGF6eSBsb2FkaW5nIHByb3BlcnR5IHRvIGEgY29uc3RhbnQuXG4gKiBUaGUgZ2l2ZW4gZnVuY3Rpb24gYGZuYCBpcyBjYWxsZWQgb25jZSB3aGVuIHRoZSBwcm9wZXJ0eSBpcyBmaXJzdCByZXF1ZXN0ZWQuXG4gKiBPbiBvbGRlciBicm93c2VycyAoPElFOCksIHRoZSBmdW5jdGlvbiB3aWxsIGZhbGwgYmFjayB0byBkaXJlY3QgZXZhbHVhdGlvblxuICogb2YgdGhlIHByb3BlcnRpZXMgdmFsdWUuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0ICAgT2JqZWN0IHdoZXJlIHRvIGFkZCB0aGUgcHJvcGVydHlcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wICAgICBQcm9wZXJ0eSBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgICAgRnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBwcm9wZXJ0eSB2YWx1ZS4gQ2FsbGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aG91dCBhcmd1bWVudHMuXG4gKi9cbmV4cG9ydHMubGF6eSA9IGZ1bmN0aW9uIChvYmplY3QsIHByb3AsIGZuKSB7XG4gIGlmIChleHBvcnRzLmNhbkRlZmluZVByb3BlcnR5KCkpIHtcbiAgICB2YXIgX3VuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIHZhciBfdmFsdWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcCwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdW5pbml0aWFsaXplZCkge1xuICAgICAgICAgIF92YWx1ZSA9IGZuKCk7XG4gICAgICAgICAgX3VuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3ZhbHVlO1xuICAgICAgfSxcblxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgIF91bmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICB9LFxuXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gZmFsbCBiYWNrIHRvIGltbWVkaWF0ZSBldmFsdWF0aW9uXG4gICAgb2JqZWN0W3Byb3BdID0gZm4oKTtcbiAgfVxufTtcblxuLyoqXG4gKiBUcmF2ZXJzZSBhIHBhdGggaW50byBhbiBvYmplY3QuXG4gKiBXaGVuIGEgbmFtZXNwYWNlIGlzIG1pc3NpbmcsIGl0IHdpbGwgYmUgY3JlYXRlZFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggICBBIGRvdCBzZXBhcmF0ZWQgc3RyaW5nIGxpa2UgJ25hbWUuc3BhY2UnXG4gKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIG9iamVjdCBhdCB0aGUgZW5kIG9mIHRoZSBwYXRoXG4gKi9cbmV4cG9ydHMudHJhdmVyc2UgPSBmdW5jdGlvbihvYmplY3QsIHBhdGgpIHtcbiAgdmFyIG9iaiA9IG9iamVjdDtcblxuICBpZiAocGF0aCkge1xuICAgIHZhciBuYW1lcyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgaWYgKCEobmFtZSBpbiBvYmopKSB7XG4gICAgICAgIG9ialtuYW1lXSA9IHt9O1xuICAgICAgfVxuICAgICAgb2JqID0gb2JqW25hbWVdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG4vKipcbiAqIFRlc3Qgd2hldGhlciBhbiBvYmplY3QgaXMgYSBmYWN0b3J5LiBhIGZhY3RvcnkgaGFzIGZpZWxkczpcbiAqXG4gKiAtIGZhY3Rvcnk6IGZ1bmN0aW9uICh0eXBlOiBPYmplY3QsIGNvbmZpZzogT2JqZWN0LCBsb2FkOiBmdW5jdGlvbiwgdHlwZWQ6IGZ1bmN0aW9uIFssIG1hdGg6IE9iamVjdF0pICAgKHJlcXVpcmVkKVxuICogLSBuYW1lOiBzdHJpbmcgKG9wdGlvbmFsKVxuICogLSBwYXRoOiBzdHJpbmcgICAgQSBkb3Qgc2VwYXJhdGVkIHBhdGggKG9wdGlvbmFsKVxuICogLSBtYXRoOiBib29sZWFuICAgSWYgdHJ1ZSAoZmFsc2UgYnkgZGVmYXVsdCksIHRoZSBtYXRoIG5hbWVzcGFjZSBpcyBwYXNzZWRcbiAqICAgICAgICAgICAgICAgICAgIGFzIGZpZnRoIGFyZ3VtZW50IG9mIHRoZSBmYWN0b3J5IGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHsqfSBvYmplY3RcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnRzLmlzRmFjdG9yeSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0LmZhY3RvcnkgPT09ICdmdW5jdGlvbic7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZm9ybWF0TnVtYmVyID0gcmVxdWlyZSgnLi9udW1iZXInKS5mb3JtYXQ7XG52YXIgZm9ybWF0QmlnTnVtYmVyID0gcmVxdWlyZSgnLi9iaWdudW1iZXIvZm9ybWF0dGVyJykuZm9ybWF0O1xuXG4vKipcbiAqIFRlc3Qgd2hldGhlciB2YWx1ZSBpcyBhIHN0cmluZ1xuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn0gaXNTdHJpbmdcbiAqL1xuZXhwb3J0cy5pc1N0cmluZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIHRleHQgZW5kcyB3aXRoIGEgY2VydGFpbiBzdHJpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHBhcmFtIHtzdHJpbmd9IHNlYXJjaFxuICovXG5leHBvcnRzLmVuZHNXaXRoID0gZnVuY3Rpb24odGV4dCwgc2VhcmNoKSB7XG4gIHZhciBzdGFydCA9IHRleHQubGVuZ3RoIC0gc2VhcmNoLmxlbmd0aDtcbiAgdmFyIGVuZCA9IHRleHQubGVuZ3RoO1xuICByZXR1cm4gKHRleHQuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpID09PSBzZWFyY2gpO1xufTtcblxuLyoqXG4gKiBGb3JtYXQgYSB2YWx1ZSBvZiBhbnkgdHlwZSBpbnRvIGEgc3RyaW5nLlxuICpcbiAqIFVzYWdlOlxuICogICAgIG1hdGguZm9ybWF0KHZhbHVlKVxuICogICAgIG1hdGguZm9ybWF0KHZhbHVlLCBwcmVjaXNpb24pXG4gKlxuICogV2hlbiB2YWx1ZSBpcyBhIGZ1bmN0aW9uOlxuICpcbiAqIC0gV2hlbiB0aGUgZnVuY3Rpb24gaGFzIGEgcHJvcGVydHkgYHN5bnRheGAsIGl0IHJldHVybnMgdGhpc1xuICogICBzeW50YXggZGVzY3JpcHRpb24uXG4gKiAtIEluIG90aGVyIGNhc2VzLCBhIHN0cmluZyBgJ2Z1bmN0aW9uJ2AgaXMgcmV0dXJuZWQuXG4gKlxuICogV2hlbiBgdmFsdWVgIGlzIGFuIE9iamVjdDpcbiAqXG4gKiAtIFdoZW4gdGhlIG9iamVjdCBjb250YWlucyBhIHByb3BlcnR5IGBmb3JtYXRgIGJlaW5nIGEgZnVuY3Rpb24sIHRoaXNcbiAqICAgZnVuY3Rpb24gaXMgaW52b2tlZCBhcyBgdmFsdWUuZm9ybWF0KG9wdGlvbnMpYCBhbmQgdGhlIHJlc3VsdCBpcyByZXR1cm5lZC5cbiAqIC0gV2hlbiB0aGUgb2JqZWN0IGhhcyBpdHMgb3duIGB0b1N0cmluZ2AgbWV0aG9kLCB0aGlzIG1ldGhvZCBpcyBpbnZva2VkXG4gKiAgIGFuZCB0aGUgcmVzdWx0IGlzIHJldHVybmVkLlxuICogLSBJbiBvdGhlciBjYXNlcyB0aGUgZnVuY3Rpb24gd2lsbCBsb29wIG92ZXIgYWxsIG9iamVjdCBwcm9wZXJ0aWVzIGFuZFxuICogICByZXR1cm4gSlNPTiBvYmplY3Qgbm90YXRpb24gbGlrZSAne1wiYVwiOiAyLCBcImJcIjogM30nLlxuICpcbiAqIEV4YW1wbGUgdXNhZ2U6XG4gKiAgICAgbWF0aC5mb3JtYXQoMi83KTsgICAgICAgICAgICAgICAgLy8gJzAuMjg1NzE0Mjg1NzE0Mjg1NydcbiAqICAgICBtYXRoLmZvcm1hdChtYXRoLnBpLCAzKTsgICAgICAgICAvLyAnMy4xNCdcbiAqICAgICBtYXRoLmZvcm1hdChuZXcgQ29tcGxleCgyLCAzKSk7ICAvLyAnMiArIDNpJ1xuICogICAgIG1hdGguZm9ybWF0KCdoZWxsbycpOyAgICAgICAgICAgIC8vICdcImhlbGxvXCInXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSAgICAgICAgICAgICBWYWx1ZSB0byBiZSBzdHJpbmdpZmllZFxuICogQHBhcmFtIHtPYmplY3QgfCBudW1iZXIgfCBGdW5jdGlvbn0gW29wdGlvbnNdICBGb3JtYXR0aW5nIG9wdGlvbnMuIFNlZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaWIvdXRpbHMvbnVtYmVyOmZvcm1hdCBmb3IgYVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbiBvZiB0aGUgYXZhaWxhYmxlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHN0clxuICovXG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKHZhbHVlLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGZvcm1hdE51bWJlcih2YWx1ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAodmFsdWUgJiYgdmFsdWUuaXNCaWdOdW1iZXIgPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm9ybWF0QmlnTnVtYmVyKHZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSAmJiB2YWx1ZS5pc0ZyYWN0aW9uID09PSB0cnVlKSB7XG4gICAgaWYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZnJhY3Rpb24gIT09ICdkZWNpbWFsJykge1xuICAgICAgLy8gb3V0cHV0IGFzIHJhdGlvLCBsaWtlICcxLzMnXG4gICAgICByZXR1cm4gKHZhbHVlLnMgKiB2YWx1ZS5uKSArICcvJyArIHZhbHVlLmQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gb3V0cHV0IGFzIGRlY2ltYWwsIGxpa2UgJzAuKDMpJ1xuICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZvcm1hdEFycmF5KHZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmIChleHBvcnRzLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHJldHVybiAnXCInICsgdmFsdWUgKyAnXCInO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB2YWx1ZS5zeW50YXggPyBTdHJpbmcodmFsdWUuc3ludGF4KSA6ICdmdW5jdGlvbic7XG4gIH1cblxuICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgIGlmICh0eXBlb2YgdmFsdWUuZm9ybWF0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdmFsdWUuZm9ybWF0KG9wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZSAmJiB2YWx1ZS50b1N0cmluZygpICE9PSB7fS50b1N0cmluZygpKSB7XG4gICAgICAvLyB0aGlzIG9iamVjdCBoYXMgYSBub24tbmF0aXZlIHRvU3RyaW5nIG1ldGhvZCwgdXNlIHRoYXQgb25lXG4gICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgZW50cmllcyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICBlbnRyaWVzLnB1c2goJ1wiJyArIGtleSArICdcIjogJyArIGV4cG9ydHMuZm9ybWF0KHZhbHVlW2tleV0sIG9wdGlvbnMpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gJ3snICsgZW50cmllcy5qb2luKCcsICcpICsgJ30nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBTdHJpbmcodmFsdWUpO1xufTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSBmb3JtYXQgYW4gbi1kaW1lbnNpb25hbCBtYXRyaXhcbiAqIEV4YW1wbGUgb3V0cHV0OiBcIltbMSwgMl0sIFszLCA0XV1cIlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0IHwgbnVtYmVyIHwgRnVuY3Rpb259IFtvcHRpb25zXSAgRm9ybWF0dGluZyBvcHRpb25zLiBTZWVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGliL3V0aWxzL251bWJlcjpmb3JtYXQgZm9yIGFcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gb2YgdGhlIGF2YWlsYWJsZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLlxuICogQHJldHVybnMge3N0cmluZ30gc3RyXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdEFycmF5IChhcnJheSwgb3B0aW9ucykge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnJheSkpIHtcbiAgICB2YXIgc3RyID0gJ1snO1xuICAgIHZhciBsZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGkgIT0gMCkge1xuICAgICAgICBzdHIgKz0gJywgJztcbiAgICAgIH1cbiAgICAgIHN0ciArPSBmb3JtYXRBcnJheShhcnJheVtpXSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0ciArPSAnXSc7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gZXhwb3J0cy5mb3JtYXQoYXJyYXksIG9wdGlvbnMpO1xuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lIHRoZSB0eXBlIG9mIGEgdmFyaWFibGVcbiAqXG4gKiAgICAgdHlwZSh4KVxuICpcbiAqIFRoZSBmb2xsb3dpbmcgdHlwZXMgYXJlIHJlY29nbml6ZWQ6XG4gKlxuICogICAgICd1bmRlZmluZWQnXG4gKiAgICAgJ251bGwnXG4gKiAgICAgJ2Jvb2xlYW4nXG4gKiAgICAgJ251bWJlcidcbiAqICAgICAnc3RyaW5nJ1xuICogICAgICdBcnJheSdcbiAqICAgICAnRnVuY3Rpb24nXG4gKiAgICAgJ0RhdGUnXG4gKiAgICAgJ1JlZ0V4cCdcbiAqICAgICAnT2JqZWN0J1xuICpcbiAqIEBwYXJhbSB7Kn0geFxuICogQHJldHVybiB7c3RyaW5nfSBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSB0eXBlLiBQcmltaXRpdmUgdHlwZXMgYXJlIGxvd2VyIGNhc2UsXG4gKiAgICAgICAgICAgICAgICAgIG5vbi1wcmltaXRpdmUgdHlwZXMgYXJlIHVwcGVyLWNhbWVsLWNhc2UuXG4gKiAgICAgICAgICAgICAgICAgIEZvciBleGFtcGxlICdudW1iZXInLCAnc3RyaW5nJywgJ0FycmF5JywgJ0RhdGUnLlxuICovXG5leHBvcnRzLnR5cGUgPSBmdW5jdGlvbih4KSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHg7XG5cbiAgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKHggPT09IG51bGwpICAgICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgIGlmICh4IGluc3RhbmNlb2YgQm9vbGVhbikgcmV0dXJuICdib29sZWFuJztcbiAgICBpZiAoeCBpbnN0YW5jZW9mIE51bWJlcikgIHJldHVybiAnbnVtYmVyJztcbiAgICBpZiAoeCBpbnN0YW5jZW9mIFN0cmluZykgIHJldHVybiAnc3RyaW5nJztcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh4KSkgICAgIHJldHVybiAnQXJyYXknO1xuICAgIGlmICh4IGluc3RhbmNlb2YgRGF0ZSkgICAgcmV0dXJuICdEYXRlJztcbiAgICBpZiAoeCBpbnN0YW5jZW9mIFJlZ0V4cCkgIHJldHVybiAnUmVnRXhwJztcblxuICAgIHJldHVybiAnT2JqZWN0JztcbiAgfVxuXG4gIGlmICh0eXBlID09PSAnZnVuY3Rpb24nKSAgICByZXR1cm4gJ0Z1bmN0aW9uJztcblxuICByZXR1cm4gdHlwZTtcbn07XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIGEgdmFsdWUgaXMgYSBzY2FsYXJcbiAqIEBwYXJhbSB4XG4gKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgd2hlbiB4IGlzIGEgc2NhbGFyLCByZXR1cm5zIGZhbHNlIHdoZW5cbiAqICAgICAgICAgICAgICAgICAgIHggaXMgYSBNYXRyaXggb3IgQXJyYXkuXG4gKi9cbmV4cG9ydHMuaXNTY2FsYXIgPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4gISgoeCAmJiB4LmlzTWF0cml4KSB8fCBBcnJheS5pc0FycmF5KHgpKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9ICczLjEuMyc7XG4vLyBOb3RlOiBUaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgd2hlbiBidWlsZGluZyBtYXRoLmpzLlxuLy8gQ2hhbmdlcyBtYWRlIGluIHRoaXMgZmlsZSB3aWxsIGJlIG92ZXJ3cml0dGVuLlxuIiwiLyoqXG4gKiBAbGljZW5zZSBDb21wbGV4LmpzIHYyLjAuMSAxMS8wMi8yMDE2XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LCBSb2JlcnQgRWlzZWxlIChyb2JlcnRAeGFyZy5vcmcpXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgb3IgR1BMIFZlcnNpb24gMiBsaWNlbnNlcy5cbiAqKi9cblxuLyoqXG4gKlxuICogVGhpcyBjbGFzcyBhbGxvd3MgdGhlIG1hbmlwaWxhdGlvbiBvZiBjb21wbGV4IG51bWJlcnMuXG4gKiBZb3UgY2FuIHBhc3MgYSBjb21wbGV4IG51bWJlciBpbiBkaWZmZXJlbnQgZm9ybWF0cy4gRWl0aGVyIGFzIG9iamVjdCwgZG91YmxlLCBzdHJpbmcgb3IgdHdvIGludGVnZXIgcGFyYW1ldGVycy5cbiAqXG4gKiBPYmplY3QgZm9ybVxuICogeyByZTogPHJlYWw+LCBpbTogPGltYWdpbmFyeT4gfVxuICogeyBhcmc6IDxhbmdsZT4sIGFiczogPHJhZGl1cz4gfVxuICogeyBwaGk6IDxhbmdsZT4sIHI6IDxyYWRpdXM+IH1cbiAqXG4gKiBEb3VibGUgZm9ybVxuICogOTkuMyAtIFNpbmdsZSBkb3VibGUgdmFsdWVcbiAqXG4gKiBTdHJpbmcgZm9ybVxuICogXCIyMy4xMzM3XCIgLSBTaW1wbGUgcmVhbCBudW1iZXJcbiAqIFwiMTUrM2lcIiAtIGEgc2ltcGxlIGNvbXBsZXggbnVtYmVyXG4gKiBcIjMtaVwiIC0gYSBzaW1wbGUgY29tcGxleCBudW1iZXJcbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIHZhciBjID0gbmV3IENvbXBsZXgoXCI5OS4zKzhpXCIpO1xuICogYy5tdWwoe3I6IDMsIGk6IDl9KS5kaXYoNC45KS5zdWIoMywgMik7XG4gKlxuICovXG5cbihmdW5jdGlvbihyb290KSB7XG5cbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIFAgPSB7J3JlJzogMCwgJ2ltJzogMH07XG5cbiAgTWF0aC5jb3NoID0gTWF0aC5jb3NoIHx8IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gKE1hdGguZXhwKHgpICsgTWF0aC5leHAoLXgpKSAqIDAuNTtcbiAgfTtcblxuICBNYXRoLnNpbmggPSBNYXRoLnNpbmggfHwgZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiAoTWF0aC5leHAoeCkgLSBNYXRoLmV4cCgteCkpICogMC41O1xuICB9O1xuXG4gIHZhciBwYXJzZXJfZXhpdCA9IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IFN5bnRheEVycm9yKFwiSW52YWxpZCBQYXJhbVwiKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyBsb2coc3FydChhXjIrYl4yKSkgaW4gYSB3YXkgdG8gYXZvaWQgb3ZlcmZsb3dzXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBiXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBmdW5jdGlvbiBsb2dIeXBvdChhLCBiKSB7XG5cbiAgICB2YXIgX2EgPSBNYXRoLmFicyhhKTtcbiAgICB2YXIgX2IgPSBNYXRoLmFicyhiKTtcblxuICAgIGlmIChhID09PSAwKSB7XG4gICAgICByZXR1cm4gTWF0aC5sb2coX2IpO1xuICAgIH1cblxuICAgIGlmIChiID09PSAwKSB7XG4gICAgICByZXR1cm4gTWF0aC5sb2coX2EpO1xuICAgIH1cblxuICAgIGlmIChfYSA8IDMwMDAgJiYgX2IgPCAzMDAwKSB7XG4gICAgICByZXR1cm4gTWF0aC5sb2coYSAqIGEgKyBiICogYikgKiAwLjU7XG4gICAgfVxuXG4gICAgLyogSSBnb3QgNCBpZGVhcyB0byBjb21wdXRlIHRoaXMgcHJvcGVydHkgd2l0aG91dCBvdmVyZmxvdzpcbiAgICAgKlxuICAgICAqIFRlc3RpbmcgMTAwMDAwMCB0aW1lcyB3aXRoIHJhbmRvbSBzYW1wbGVzIGZvciBhLGIg4oiIIFsxLCAxMDAwMDAwMDAwXSBhZ2FpbnN0IGEgYmlnIGRlY2ltYWwgbGlicmFyeSB0byBnZXQgYW4gZXJyb3IgZXN0aW1hdGVcbiAgICAgKlxuICAgICAqIDEuIE9ubHkgZWxpbWluYXRlIHRoZSBzcXVhcmUgcm9vdDogKE9WRVJBTEwgRVJST1I6IDMuOTEyMjQ4MzAzMDk1MTExNmUtMTEpXG5cbiAgICAgTWF0aC5sb2coYSAqIGEgKyBiICogYikgLyAyXG5cbiAgICAgKlxuICAgICAqXG4gICAgICogMi4gVHJ5IHRvIHVzZSB0aGUgbm9uLW92ZXJmbG93aW5nIHB5dGhhZ29yYXM6IChPVkVSQUxMIEVSUk9SOiA4Ljg4OTc2MDAzOTIxMDE1OWUtMTApXG5cbiAgICAgdmFyIGZuID0gZnVuY3Rpb24oYSwgYikge1xuICAgICBhID0gTWF0aC5hYnMoYSk7XG4gICAgIGIgPSBNYXRoLmFicyhiKTtcbiAgICAgdmFyIHQgPSBNYXRoLm1pbihhLCBiKTtcbiAgICAgYSA9IE1hdGgubWF4KGEsIGIpO1xuICAgICB0ID0gdCAvIGE7XG5cbiAgICAgcmV0dXJuIE1hdGgubG9nKGEpICsgTWF0aC5sb2coMSArIHQgKiB0KSAvIDI7XG4gICAgIH07XG5cbiAgICAgKiAzLiBBYnVzZSB0aGUgaWRlbnRpdHkgY29zKGF0YW4oeS94KSA9IHggLyBzcXJ0KHheMit5XjIpOiAoT1ZFUkFMTCBFUlJPUjogMy40NzgwMTc4NzM3MDM3MjA0ZS0xMClcblxuICAgICBNYXRoLmxvZyhhIC8gTWF0aC5jb3MoTWF0aC5hdGFuMihiLCBhKSkpXG5cbiAgICAgKiA0LiBVc2UgMy4gYW5kIGFwcGx5IGxvZyBydWxlczogKE9WRVJBTEwgRVJST1I6IDEuMjAxNDA4NzUwMjYyMDg5NmUtOSlcblxuICAgICBNYXRoLmxvZyhhKSAtIE1hdGgubG9nKE1hdGguY29zKE1hdGguYXRhbjIoYiwgYSkpKVxuXG4gICAgICovXG5cbiAgICByZXR1cm4gTWF0aC5sb2coYSAvIE1hdGguY29zKE1hdGguYXRhbjIoYiwgYSkpKTtcbiAgfVxuXG4gIHZhciBwYXJzZSA9IGZ1bmN0aW9uKGEsIGIpIHtcblxuICAgIGlmIChhID09PSB1bmRlZmluZWQgfHwgYSA9PT0gbnVsbCkge1xuICAgICAgUFtcInJlXCJdID1cbiAgICAgIFBbXCJpbVwiXSA9IDA7XG4gICAgfSBlbHNlIGlmIChiICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIFBbXCJyZVwiXSA9IGE7XG4gICAgICBQW1wiaW1cIl0gPSBiO1xuICAgIH0gZWxzZSBzd2l0Y2ggKHR5cGVvZiBhKSB7XG5cbiAgICAgIGNhc2UgXCJvYmplY3RcIjpcblxuICAgICAgICBpZiAoXCJpbVwiIGluIGEgJiYgXCJyZVwiIGluIGEpIHtcbiAgICAgICAgICBQW1wicmVcIl0gPSBhW1wicmVcIl07XG4gICAgICAgICAgUFtcImltXCJdID0gYVtcImltXCJdO1xuICAgICAgICB9IGVsc2UgaWYgKFwiYWJzXCIgaW4gYSAmJiBcImFyZ1wiIGluIGEpIHtcbiAgICAgICAgICBQW1wicmVcIl0gPSBhW1wiYWJzXCJdICogTWF0aC5jb3MoYVtcImFyZ1wiXSk7XG4gICAgICAgICAgUFtcImltXCJdID0gYVtcImFic1wiXSAqIE1hdGguc2luKGFbXCJhcmdcIl0pO1xuICAgICAgICB9IGVsc2UgaWYgKFwiclwiIGluIGEgJiYgXCJwaGlcIiBpbiBhKSB7XG4gICAgICAgICAgUFtcInJlXCJdID0gYVtcInJcIl0gKiBNYXRoLmNvcyhhW1wicGhpXCJdKTtcbiAgICAgICAgICBQW1wiaW1cIl0gPSBhW1wiclwiXSAqIE1hdGguc2luKGFbXCJwaGlcIl0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcnNlcl9leGl0KCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJzdHJpbmdcIjpcblxuICAgICAgICBQW1wiaW1cIl0gPSAvKiB2b2lkICovXG4gICAgICAgIFBbXCJyZVwiXSA9IDA7XG5cbiAgICAgICAgdmFyIHRva2VucyA9IGEubWF0Y2goL1xcZCtcXC4/XFxkKmVbKy1dP1xcZCt8XFxkK1xcLj9cXGQqfFxcLlxcZCt8Li9nKTtcbiAgICAgICAgdmFyIHBsdXMgPSAxO1xuICAgICAgICB2YXIgbWludXMgPSAwO1xuXG4gICAgICAgIGlmICh0b2tlbnMgPT09IG51bGwpIHtcbiAgICAgICAgICBwYXJzZXJfZXhpdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICAgIHZhciBjID0gdG9rZW5zW2ldO1xuXG4gICAgICAgICAgaWYgKGMgPT09ICcgJyB8fCBjID09PSAnXFx0JyB8fCBjID09PSAnXFxuJykge1xuICAgICAgICAgICAgLyogdm9pZCAqL1xuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJysnKSB7XG4gICAgICAgICAgICBwbHVzKys7XG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnLScpIHtcbiAgICAgICAgICAgIG1pbnVzKys7XG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnaScgfHwgYyA9PT0gJ0knKSB7XG5cbiAgICAgICAgICAgIGlmIChwbHVzICsgbWludXMgPT09IDApIHtcbiAgICAgICAgICAgICAgcGFyc2VyX2V4aXQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRva2Vuc1tpICsgMV0gIT09ICcgJyAmJiAhaXNOYU4odG9rZW5zW2kgKyAxXSkpIHtcbiAgICAgICAgICAgICAgUFtcImltXCJdKz0gcGFyc2VGbG9hdCgobWludXMgJSAyID8gXCItXCIgOiBcIlwiKSArIHRva2Vuc1tpICsgMV0pO1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBQW1wiaW1cIl0rPSBwYXJzZUZsb2F0KChtaW51cyAlIDIgPyBcIi1cIiA6IFwiXCIpICsgXCIxXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGx1cyA9IG1pbnVzID0gMDtcblxuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGlmIChwbHVzICsgbWludXMgPT09IDAgfHwgaXNOYU4oYykpIHtcbiAgICAgICAgICAgICAgcGFyc2VyX2V4aXQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRva2Vuc1tpICsgMV0gPT09ICdpJyB8fCB0b2tlbnNbaSArIDFdID09PSAnSScpIHtcbiAgICAgICAgICAgICAgUFtcImltXCJdKz0gcGFyc2VGbG9hdCgobWludXMgJSAyID8gXCItXCIgOiBcIlwiKSArIGMpO1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBQW1wicmVcIl0rPSBwYXJzZUZsb2F0KChtaW51cyAlIDIgPyBcIi1cIiA6IFwiXCIpICsgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwbHVzID0gbWludXMgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0aWxsIHNvbWV0aGluZyBvbiB0aGUgc3RhY2tcbiAgICAgICAgaWYgKHBsdXMgKyBtaW51cyA+IDApIHtcbiAgICAgICAgICBwYXJzZXJfZXhpdCgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgIFBbXCJpbVwiXSA9IDA7XG4gICAgICAgIFBbXCJyZVwiXSA9IGE7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBwYXJzZXJfZXhpdCgpO1xuICAgIH1cblxuICAgIGlmIChpc05hTihQW1wicmVcIl0pIHx8IGlzTmFOKFBbXCJpbVwiXSkpIHtcbiAgICAgIC8vIElmIGEgY2FsY3VsYXRpb24gaXMgTmFOLCB3ZSB0cmVhdCBpdCBhcyBOYU4gYW5kIGRvbid0IHRocm93XG4gICAgICAvL3BhcnNlcl9leGl0KCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAqL1xuICBmdW5jdGlvbiBDb21wbGV4KGEsIGIpIHtcblxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDb21wbGV4KSkge1xuICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KGEsIGIpO1xuICAgIH1cblxuICAgIHBhcnNlKGEsIGIpOyAvLyBtdXRhdGVzIFBcblxuICAgIHRoaXNbXCJyZVwiXSA9IFBbXCJyZVwiXTtcbiAgICB0aGlzW1wiaW1cIl0gPSBQW1wiaW1cIl07XG4gIH1cblxuICBDb21wbGV4LnByb3RvdHlwZSA9IHtcblxuICAgIFwicmVcIjogMCxcbiAgICBcImltXCI6IDAsXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBzaWduIG9mIGEgY29tcGxleCBudW1iZXJcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgICAqL1xuICAgIFwic2lnblwiOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIGFicyA9IHRoaXNbXCJhYnNcIl0oKTtcblxuICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgICAgICAgICB0aGlzW1wicmVcIl0gLyBhYnMsXG4gICAgICAgICAgICAgIHRoaXNbXCJpbVwiXSAvIGFicyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgdHdvIGNvbXBsZXggbnVtYmVyc1xuICAgICAqXG4gICAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAgICovXG4gICAgXCJhZGRcIjogZnVuY3Rpb24oYSwgYikge1xuXG4gICAgICBwYXJzZShhLCBiKTsgLy8gbXV0YXRlcyBQXG5cbiAgICAgIHJldHVybiBuZXcgQ29tcGxleChcbiAgICAgICAgICAgICAgdGhpc1tcInJlXCJdICsgUFtcInJlXCJdLFxuICAgICAgICAgICAgICB0aGlzW1wiaW1cIl0gKyBQW1wiaW1cIl0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgdHdvIGNvbXBsZXggbnVtYmVyc1xuICAgICAqXG4gICAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAgICovXG4gICAgXCJzdWJcIjogZnVuY3Rpb24oYSwgYikge1xuXG4gICAgICBwYXJzZShhLCBiKTsgLy8gbXV0YXRlcyBQXG5cbiAgICAgIHJldHVybiBuZXcgQ29tcGxleChcbiAgICAgICAgICAgICAgdGhpc1tcInJlXCJdIC0gUFtcInJlXCJdLFxuICAgICAgICAgICAgICB0aGlzW1wiaW1cIl0gLSBQW1wiaW1cIl0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWVzIHR3byBjb21wbGV4IG51bWJlcnNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgICAqL1xuICAgIFwibXVsXCI6IGZ1bmN0aW9uKGEsIGIpIHtcblxuICAgICAgcGFyc2UoYSwgYik7IC8vIG11dGF0ZXMgUFxuXG4gICAgICAvLyBCZXNpZGVzIHRoZSBhZGRpdGlvbi9zdWJ0cmFjdGlvbiwgdGhpcyBoZWxwcyBoYXZpbmcgYSBzb2x1dGlvbiBmb3IgcmF0aW9uYWwgSW5maW5pdHlcbiAgICAgIGlmIChQWydpbSddID09PSAwICYmIHRoaXNbJ2ltJ10gPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KHRoaXNbJ3JlJ10gKiBQWydyZSddLCAwKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgICAgICAgICB0aGlzW1wicmVcIl0gKiBQW1wicmVcIl0gLSB0aGlzW1wiaW1cIl0gKiBQW1wiaW1cIl0sXG4gICAgICAgICAgICAgIHRoaXNbXCJyZVwiXSAqIFBbXCJpbVwiXSArIHRoaXNbXCJpbVwiXSAqIFBbXCJyZVwiXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERpdmlkZXMgdHdvIGNvbXBsZXggbnVtYmVyc1xuICAgICAqXG4gICAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAgICovXG4gICAgXCJkaXZcIjogZnVuY3Rpb24oYSwgYikge1xuXG4gICAgICBwYXJzZShhLCBiKTsgLy8gbXV0YXRlcyBQXG5cbiAgICAgIGEgPSB0aGlzW1wicmVcIl07XG4gICAgICBiID0gdGhpc1tcImltXCJdO1xuXG4gICAgICB2YXIgYyA9IFBbXCJyZVwiXTtcbiAgICAgIHZhciBkID0gUFtcImltXCJdO1xuICAgICAgdmFyIHQsIHg7XG5cbiAgICAgIC8vIERpdmlzb3IgaXMgemVyb1xuICAgICAgaWYgKDAgPT09IGMgJiYgMCA9PT0gZCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICAgICAgICAgICAgKGEgIT09IDApID8gKGEgLyAwKSA6IDAsXG4gICAgICAgICAgICAgICAgKGIgIT09IDApID8gKGIgLyAwKSA6IDApO1xuICAgICAgfVxuXG4gICAgICAvLyBEaXZpc29yIGlzIHJhdGlvbmFsXG4gICAgICBpZiAoMCA9PT0gZCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgoYSAvIGMsIGIgLyBjKTtcbiAgICAgIH1cblxuICAgICAgaWYgKE1hdGguYWJzKGMpIDwgTWF0aC5hYnMoZCkpIHtcblxuICAgICAgICB4ID0gYyAvIGQ7XG4gICAgICAgIHQgPSBjICogeCArIGQ7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgICAgICAgICAgIChhICogeCArIGIpIC8gdCxcbiAgICAgICAgICAgICAgICAoYiAqIHggLSBhKSAvIHQpO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHggPSBkIC8gYztcbiAgICAgICAgdCA9IGQgKiB4ICsgYztcblxuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICAgICAgICAgICAgKGEgKyBiICogeCkgLyB0LFxuICAgICAgICAgICAgICAgIChiIC0gYSAqIHgpIC8gdCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgcG93ZXIgb2YgdHdvIGNvbXBsZXggbnVtYmVyc1xuICAgICAqXG4gICAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAgICovXG4gICAgXCJwb3dcIjogZnVuY3Rpb24oYSwgYikge1xuXG4gICAgICBwYXJzZShhLCBiKTsgLy8gbXV0YXRlcyBQXG5cbiAgICAgIGEgPSB0aGlzW1wicmVcIl07XG4gICAgICBiID0gdGhpc1tcImltXCJdO1xuXG4gICAgICBpZiAoYSA9PT0gMCAmJiBiID09PSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcGxleCgwLCAwKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFyZyA9IE1hdGguYXRhbjIoYiwgYSk7XG4gICAgICB2YXIgbG9oID0gbG9nSHlwb3QoYSwgYik7XG5cbiAgICAgIGlmIChQW1wiaW1cIl0gPT09IDApIHtcblxuICAgICAgICBpZiAoYiA9PT0gMCAmJiBhID49IDApIHtcblxuICAgICAgICAgIHJldHVybiBuZXcgQ29tcGxleChNYXRoLnBvdyhhLCBQW1wicmVcIl0pLCAwKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGEgPT09IDApIHtcblxuICAgICAgICAgIHN3aXRjaCAoUFtcInJlXCJdICUgNCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgoTWF0aC5wb3coYiwgUFtcInJlXCJdKSwgMCk7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGxleCgwLCBNYXRoLnBvdyhiLCBQW1wicmVcIl0pKTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KC1NYXRoLnBvdyhiLCBQW1wicmVcIl0pLCAwKTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KDAsIC1NYXRoLnBvdyhiLCBQW1wicmVcIl0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyogSSBjb3VsZG5cInQgZmluZCBhIGdvb2QgZm9ybXVsYSwgc28gaGVyZSBpcyBhIGRlcml2YXRpb24gYW5kIG9wdGltaXphdGlvblxuICAgICAgICpcbiAgICAgICAqIHpfMV56XzIgPSAoYSArIGJpKV4oYyArIGRpKVxuICAgICAgICogICAgICAgICA9IGV4cCgoYyArIGRpKSAqIGxvZyhhICsgYmkpXG4gICAgICAgKiAgICAgICAgID0gcG93KGFeMiArIGJeMiwgKGMgKyBkaSkgLyAyKSAqIGV4cChpKGMgKyBkaSlhdGFuMihiLCBhKSlcbiAgICAgICAqID0+Li4uXG4gICAgICAgKiBSZSA9IChwb3coYV4yICsgYl4yLCBjIC8gMikgKiBleHAoLWQgKiBhdGFuMihiLCBhKSkpICogY29zKGQgKiBsb2coYV4yICsgYl4yKSAvIDIgKyBjICogYXRhbjIoYiwgYSkpXG4gICAgICAgKiBJbSA9IChwb3coYV4yICsgYl4yLCBjIC8gMikgKiBleHAoLWQgKiBhdGFuMihiLCBhKSkpICogc2luKGQgKiBsb2coYV4yICsgYl4yKSAvIDIgKyBjICogYXRhbjIoYiwgYSkpXG4gICAgICAgKlxuICAgICAgICogPT4uLi5cbiAgICAgICAqIFJlID0gZXhwKGMgKiBsb2coc3FydChhXjIgKyBiXjIpKSAtIGQgKiBhdGFuMihiLCBhKSkgKiBjb3MoZCAqIGxvZyhzcXJ0KGFeMiArIGJeMikpICsgYyAqIGF0YW4yKGIsIGEpKVxuICAgICAgICogSW0gPSBleHAoYyAqIGxvZyhzcXJ0KGFeMiArIGJeMikpIC0gZCAqIGF0YW4yKGIsIGEpKSAqIHNpbihkICogbG9nKHNxcnQoYV4yICsgYl4yKSkgKyBjICogYXRhbjIoYiwgYSkpXG4gICAgICAgKlxuICAgICAgICogPT5cbiAgICAgICAqIFJlID0gZXhwKGMgKiBsb2dzcTIgLSBkICogYXJnKHpfMSkpICogY29zKGQgKiBsb2dzcTIgKyBjICogYXJnKHpfMSkpXG4gICAgICAgKiBJbSA9IGV4cChjICogbG9nc3EyIC0gZCAqIGFyZyh6XzEpKSAqIHNpbihkICogbG9nc3EyICsgYyAqIGFyZyh6XzEpKVxuICAgICAgICpcbiAgICAgICAqL1xuXG4gICAgICBhID0gTWF0aC5leHAoUFtcInJlXCJdICogbG9oIC0gUFtcImltXCJdICogYXJnKTtcbiAgICAgIGIgPSBQW1wiaW1cIl0gKiBsb2ggKyBQW1wicmVcIl0gKiBhcmc7XG4gICAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICAgICAgICAgIGEgKiBNYXRoLmNvcyhiKSxcbiAgICAgICAgICAgICAgYSAqIE1hdGguc2luKGIpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBjb21wbGV4IHNxdWFyZSByb290XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICAgKi9cbiAgICBcInNxcnRcIjogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBhID0gdGhpc1tcInJlXCJdO1xuICAgICAgdmFyIGIgPSB0aGlzW1wiaW1cIl07XG4gICAgICB2YXIgciA9IHRoaXNbXCJhYnNcIl0oKTtcblxuICAgICAgdmFyIHJlLCBpbTtcblxuICAgICAgaWYgKGEgPj0gMCAmJiBiID09PSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcGxleChNYXRoLnNxcnQoYSksIDApO1xuICAgICAgfVxuXG4gICAgICBpZiAoYSA+PSAwKSB7XG4gICAgICAgIHJlID0gMC41ICogTWF0aC5zcXJ0KDIuMCAqIChyICsgYSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmUgPSBNYXRoLmFicyhiKSAvIE1hdGguc3FydCgyICogKHIgLSBhKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhIDw9IDApIHtcbiAgICAgICAgaW0gPSAwLjUgKiBNYXRoLnNxcnQoMi4wICogKHIgLSBhKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbSA9IE1hdGguYWJzKGIpIC8gTWF0aC5zcXJ0KDIgKiAociArIGEpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KHJlLCBiID49IDAgPyBpbSA6IC1pbSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgY29tcGxleCBleHBvbmVudFxuICAgICAqXG4gICAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAgICovXG4gICAgXCJleHBcIjogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciB0bXAgPSBNYXRoLmV4cCh0aGlzW1wicmVcIl0pO1xuXG4gICAgICBpZiAodGhpc1tcImltXCJdID09PSAwKSB7XG4gICAgICAgIC8vcmV0dXJuIG5ldyBDb21wbGV4KHRtcCwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICAgICAgICAgIHRtcCAqIE1hdGguY29zKHRoaXNbXCJpbVwiXSksXG4gICAgICAgICAgICAgIHRtcCAqIE1hdGguc2luKHRoaXNbXCJpbVwiXSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIG5hdHVyYWwgbG9nXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICAgKi9cbiAgICBcImxvZ1wiOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIGEgPSB0aGlzW1wicmVcIl07XG4gICAgICB2YXIgYiA9IHRoaXNbXCJpbVwiXTtcbiAgICAgIFxuICAgICAgaWYgKGIgPT09IDAgJiYgYSA+IDApIHtcbiAgICAgICAgLy9yZXR1cm4gbmV3IENvbXBsZXgoTWF0aC5sb2coYSksIDApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICAgICAgICAgIGxvZ0h5cG90KGEsIGIpLFxuICAgICAgICAgICAgICBNYXRoLmF0YW4yKGIsIGEpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBtYWduaXR1cmUgb2YgdGhlIGNvbXBsZXggbnVtYmVyXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIFwiYWJzXCI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgYSA9IE1hdGguYWJzKHRoaXNbXCJyZVwiXSk7XG4gICAgICB2YXIgYiA9IE1hdGguYWJzKHRoaXNbXCJpbVwiXSk7XG5cbiAgICAgIGlmIChhIDwgMzAwMCAmJiBiIDwgMzAwMCkge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYSA8IGIpIHtcbiAgICAgICAgYSA9IGI7XG4gICAgICAgIGIgPSB0aGlzW1wicmVcIl0gLyB0aGlzW1wiaW1cIl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiID0gdGhpc1tcImltXCJdIC8gdGhpc1tcInJlXCJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGEgKiBNYXRoLnNxcnQoMSArIGIgKiBiKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBhbmdsZSBvZiB0aGUgY29tcGxleCBudW1iZXJcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgXCJhcmdcIjogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHJldHVybiBNYXRoLmF0YW4yKHRoaXNbXCJpbVwiXSwgdGhpc1tcInJlXCJdKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBzaW5lIG9mIHRoZSBjb21wbGV4IG51bWJlclxuICAgICAqXG4gICAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAgICovXG4gICAgXCJzaW5cIjogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBhID0gdGhpc1tcInJlXCJdO1xuICAgICAgdmFyIGIgPSB0aGlzW1wiaW1cIl07XG5cbiAgICAgIHJldHVybiBuZXcgQ29tcGxleChcbiAgICAgICAgICAgICAgTWF0aC5zaW4oYSkgKiBNYXRoLmNvc2goYiksXG4gICAgICAgICAgICAgIE1hdGguY29zKGEpICogTWF0aC5zaW5oKGIpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBjb3NpbmVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgICAqL1xuICAgIFwiY29zXCI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgYSA9IHRoaXNbXCJyZVwiXTtcbiAgICAgIHZhciBiID0gdGhpc1tcImltXCJdO1xuXG4gICAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICAgICAgICAgIE1hdGguY29zKGEpICogTWF0aC5jb3NoKGIpLFxuICAgICAgICAgICAgIC1NYXRoLnNpbihhKSAqIE1hdGguc2luaChiKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgdGFuZ2VudFxuICAgICAqXG4gICAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAgICovXG4gICAgXCJ0YW5cIjogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBhID0gMiAqIHRoaXNbXCJyZVwiXTtcbiAgICAgIHZhciBiID0gMiAqIHRoaXNbXCJpbVwiXTtcbiAgICAgIHZhciBkID0gTWF0aC5jb3MoYSkgKyBNYXRoLmNvc2goYik7XG5cbiAgICAgIHJldHVybiBuZXcgQ29tcGxleChcbiAgICAgICAgICAgICAgTWF0aC5zaW4oYSkgLyBkLFxuICAgICAgICAgICAgICBNYXRoLnNpbmgoYikgLyBkKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBjb3RhbmdlbnRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgICAqL1xuICAgIFwiY290XCI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgYSA9IDIgKiB0aGlzW1wicmVcIl07XG4gICAgICB2YXIgYiA9IDIgKiB0aGlzW1wiaW1cIl07XG4gICAgICB2YXIgZCA9IE1hdGguY29zKGEpIC0gTWF0aC5jb3NoKGIpO1xuXG4gICAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICAgICAgICAgLU1hdGguc2luKGEpIC8gZCxcbiAgICAgICAgICAgICAgTWF0aC5zaW5oKGIpIC8gZCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgc2VjYW50XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICAgKi9cbiAgICBcInNlY1wiOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIGEgPSB0aGlzW1wicmVcIl07XG4gICAgICB2YXIgYiA9IHRoaXNbXCJpbVwiXTtcbiAgICAgIHZhciBkID0gMC41ICogTWF0aC5jb3NoKDIgKiBiKSArIDAuNSAqIE1hdGguY29zKDIgKiBhKTtcblxuICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgICAgICAgICBNYXRoLmNvcyhhKSAqIE1hdGguY29zaChiKSAvIGQsXG4gICAgICAgICAgICAgIE1hdGguc2luKGEpICogTWF0aC5zaW5oKGIpIC8gZCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgY29zZWNhbnNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgICAqL1xuICAgIFwiY3NjXCI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgYSA9IHRoaXNbXCJyZVwiXTtcbiAgICAgIHZhciBiID0gdGhpc1tcImltXCJdO1xuICAgICAgdmFyIGQgPSAwLjUgKiBNYXRoLmNvc2goMiAqIGIpIC0gMC41ICogTWF0aC5jb3MoMiAqIGEpO1xuXG4gICAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICAgICAgICAgIE1hdGguc2luKGEpICogTWF0aC5jb3NoKGIpIC8gZCxcbiAgICAgICAgICAgICAtTWF0aC5jb3MoYSkgKiBNYXRoLnNpbmgoYikgLyBkKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBjb21wbGV4IGFyY3VzIHNpbnVzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICAgKi9cbiAgICBcImFzaW5cIjogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBhID0gdGhpc1tcInJlXCJdO1xuICAgICAgdmFyIGIgPSB0aGlzW1wiaW1cIl07XG5cbiAgICAgIHZhciB0MSA9IG5ldyBDb21wbGV4KFxuICAgICAgICAgICAgICAgYiAqIGIgLSBhICogYSArIDEsXG4gICAgICAgICAgICAgIC0yICogYSAqIGIpWydzcXJ0J10oKTtcblxuICAgICAgdmFyIHQyID0gbmV3IENvbXBsZXgoXG4gICAgICAgICAgICAgIHQxWydyZSddIC0gYixcbiAgICAgICAgICAgICAgdDFbJ2ltJ10gKyBhKVsnbG9nJ10oKTtcblxuICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KHQyWydpbSddLCAtdDJbJ3JlJ10pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGNvbXBsZXggYXJjdXMgY29zaW51c1xuICAgICAqXG4gICAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAgICovXG4gICAgXCJhY29zXCI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgYSA9IHRoaXNbXCJyZVwiXTtcbiAgICAgIHZhciBiID0gdGhpc1tcImltXCJdO1xuXG4gICAgICB2YXIgdDEgPSBuZXcgQ29tcGxleChcbiAgICAgICAgICAgICAgIGIgKiBiIC0gYSAqIGEgKyAxLFxuICAgICAgICAgICAgICAtMiAqIGEgKiBiKVsnc3FydCddKCk7XG5cbiAgICAgIHZhciB0MiA9IG5ldyBDb21wbGV4KFxuICAgICAgICAgICAgICB0MVtcInJlXCJdIC0gYixcbiAgICAgICAgICAgICAgdDFbXCJpbVwiXSArIGEpWydsb2cnXSgpO1xuXG4gICAgICByZXR1cm4gbmV3IENvbXBsZXgoTWF0aC5QSSAvIDIgLSB0MltcImltXCJdLCB0MltcInJlXCJdKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBjb21wbGV4IGFyY3VzIHRhbmdlbnRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgICAqL1xuICAgIFwiYXRhblwiOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIGEgPSB0aGlzW1wicmVcIl07XG4gICAgICB2YXIgYiA9IHRoaXNbXCJpbVwiXTtcblxuICAgICAgaWYgKGEgPT09IDApIHtcblxuICAgICAgICBpZiAoYiA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiBuZXcgQ29tcGxleCgwLCBJbmZpbml0eSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYiA9PT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgoMCwgLUluZmluaXR5KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZCA9IGEgKiBhICsgKDEuMCAtIGIpICogKDEuMCAtIGIpO1xuXG4gICAgICB2YXIgdDEgPSBuZXcgQ29tcGxleChcbiAgICAgICAgICAgICAgKDEgLSBiICogYiAtIGEgKiBhKSAvIGQsXG4gICAgICAgICAgICAgIC0yICogYSAvIGQpLmxvZygpO1xuXG4gICAgICByZXR1cm4gbmV3IENvbXBsZXgoLTAuNSAqIHQxW1wiaW1cIl0sIDAuNSAqIHQxW1wicmVcIl0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGNvbXBsZXggYXJjdXMgY290YW5nZW50XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICAgKi9cbiAgICBcImFjb3RcIjogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBhID0gdGhpc1tcInJlXCJdO1xuICAgICAgdmFyIGIgPSB0aGlzW1wiaW1cIl07XG5cbiAgICAgIGlmIChiID09PSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcGxleChNYXRoLmF0YW4yKDEsIGEpLCAwKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGQgPSBhICogYSArIGIgKiBiO1xuICAgICAgcmV0dXJuIChkICE9PSAwKVxuICAgICAgICAgICAgICA/IG5ldyBDb21wbGV4KFxuICAgICAgICAgICAgICAgICAgICAgIGEgLyBkLFxuICAgICAgICAgICAgICAgICAgICAgLWIgLyBkKS5hdGFuKClcbiAgICAgICAgICAgICAgOiBuZXcgQ29tcGxleChcbiAgICAgICAgICAgICAgICAgICAgICAoYSAhPT0gMCkgPyBhIC8gMCA6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgKGIgIT09IDApID8tYiAvIDAgOiAwKS5hdGFuKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgY29tcGxleCBhcmN1cyBzZWNhbnRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgICAqL1xuICAgIFwiYXNlY1wiOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIGEgPSB0aGlzW1wicmVcIl07XG4gICAgICB2YXIgYiA9IHRoaXNbXCJpbVwiXTtcblxuICAgICAgaWYgKGEgPT09IDAgJiYgYiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgoMCwgSW5maW5pdHkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZCA9IGEgKiBhICsgYiAqIGI7XG4gICAgICByZXR1cm4gKGQgIT09IDApXG4gICAgICAgICAgICAgID8gbmV3IENvbXBsZXgoXG4gICAgICAgICAgICAgICAgICAgICAgYSAvIGQsXG4gICAgICAgICAgICAgICAgICAgICAgLWIgLyBkKS5hY29zKClcbiAgICAgICAgICAgICAgOiBuZXcgQ29tcGxleChcbiAgICAgICAgICAgICAgICAgICAgICAoYSAhPT0gMCkgPyBhIC8gMCA6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgKGIgIT09IDApID8tYiAvIDAgOiAwKS5hY29zKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgY29tcGxleCBhcmN1cyBjb3NlY2Fuc1xuICAgICAqXG4gICAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAgICovXG4gICAgXCJhY3NjXCI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgYSA9IHRoaXNbXCJyZVwiXTtcbiAgICAgIHZhciBiID0gdGhpc1tcImltXCJdO1xuXG4gICAgICBpZiAoYSA9PT0gMCAmJiBiID09PSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcGxleChNYXRoLlBJIC8gMiwgSW5maW5pdHkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZCA9IGEgKiBhICsgYiAqIGI7XG4gICAgICByZXR1cm4gKGQgIT09IDApXG4gICAgICAgICAgICAgID8gbmV3IENvbXBsZXgoXG4gICAgICAgICAgICAgICAgICAgICAgYSAvIGQsXG4gICAgICAgICAgICAgICAgICAgICAtYiAvIGQpLmFzaW4oKVxuICAgICAgICAgICAgICA6IG5ldyBDb21wbGV4KFxuICAgICAgICAgICAgICAgICAgICAgIChhICE9PSAwKSA/IGEgLyAwIDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAoYiAhPT0gMCkgPy1iIC8gMCA6IDApLmFzaW4oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBjb21wbGV4IHNpbmhcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgICAqL1xuICAgIFwic2luaFwiOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIGEgPSB0aGlzW1wicmVcIl07XG4gICAgICB2YXIgYiA9IHRoaXNbXCJpbVwiXTtcblxuICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgICAgICAgICBNYXRoLnNpbmgoYSkgKiBNYXRoLmNvcyhiKSxcbiAgICAgICAgICAgICAgTWF0aC5jb3NoKGEpICogTWF0aC5zaW4oYikpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGNvbXBsZXggY29zaFxuICAgICAqXG4gICAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAgICovXG4gICAgXCJjb3NoXCI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgYSA9IHRoaXNbXCJyZVwiXTtcbiAgICAgIHZhciBiID0gdGhpc1tcImltXCJdO1xuXG4gICAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICAgICAgICAgIE1hdGguY29zaChhKSAqIE1hdGguY29zKGIpLFxuICAgICAgICAgICAgICBNYXRoLnNpbmgoYSkgKiBNYXRoLnNpbihiKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgY29tcGxleCB0YW5oXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICAgKi9cbiAgICBcInRhbmhcIjogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBhID0gMiAqIHRoaXNbXCJyZVwiXTtcbiAgICAgIHZhciBiID0gMiAqIHRoaXNbXCJpbVwiXTtcbiAgICAgIHZhciBkID0gTWF0aC5jb3NoKGEpICsgTWF0aC5jb3MoYik7XG5cbiAgICAgIHJldHVybiBuZXcgQ29tcGxleChcbiAgICAgICAgICAgICAgTWF0aC5zaW5oKGEpIC8gZCxcbiAgICAgICAgICAgICAgTWF0aC5zaW4oYikgLyBkKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBjb21wbGV4IGNvdGhcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgICAqL1xuICAgIFwiY290aFwiOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIGEgPSAyICogdGhpc1tcInJlXCJdO1xuICAgICAgdmFyIGIgPSAyICogdGhpc1tcImltXCJdO1xuICAgICAgdmFyIGQgPSBNYXRoLmNvc2goYSkgLSBNYXRoLmNvcyhiKTtcblxuICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgICAgICAgICBNYXRoLnNpbmgoYSkgLyBkLFxuICAgICAgICAgICAgIC1NYXRoLnNpbihiKSAvIGQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGNvbXBsZXggY290aFxuICAgICAqXG4gICAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAgICovXG4gICAgXCJjc2NoXCI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgYSA9IHRoaXNbXCJyZVwiXTtcbiAgICAgIHZhciBiID0gdGhpc1tcImltXCJdO1xuICAgICAgdmFyIGQgPSBNYXRoLmNvcygyICogYikgLSBNYXRoLmNvc2goMiAqIGEpO1xuXG4gICAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICAgICAgIC0yICogTWF0aC5zaW5oKGEpICogTWF0aC5jb3MoYikgLyBkLCBcbiAgICAgICAgICAgIDIgKiBNYXRoLmNvc2goYSkgKiBNYXRoLnNpbihiKSAvIGQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGNvbXBsZXggc2VjaFxuICAgICAqXG4gICAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAgICovXG4gICAgXCJzZWNoXCI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgYSA9IHRoaXNbXCJyZVwiXTtcbiAgICAgIHZhciBiID0gdGhpc1tcImltXCJdO1xuICAgICAgdmFyIGQgPSBNYXRoLmNvcygyICogYikgKyBNYXRoLmNvc2goMiAqIGEpO1xuXG4gICAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICAgICAgICAgIDIgKiBNYXRoLmNvc2goYSkgKiBNYXRoLmNvcyhiKSAvIGQsIFxuICAgICAgICAgICAgIC0yICogTWF0aC5zaW5oKGEpICogTWF0aC5zaW4oYikgLyBkKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBjb21wbGV4IGFzaW5oXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICAgKi9cbiAgICBcImFzaW5oXCI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgdG1wID0gdGhpc1tcImltXCJdO1xuICAgICAgdGhpc1tcImltXCJdID0gLXRoaXNbXCJyZVwiXTtcbiAgICAgIHRoaXNbXCJyZVwiXSA9IHRtcDtcbiAgICAgIHZhciByZXMgPSB0aGlzW1wiYXNpblwiXSgpO1xuXG4gICAgICB0aGlzW1wicmVcIl0gPSAtdGhpc1tcImltXCJdO1xuICAgICAgdGhpc1tcImltXCJdID0gdG1wO1xuICAgICAgdG1wID0gcmVzW1wicmVcIl07XG5cbiAgICAgIHJlc1tcInJlXCJdID0gLXJlc1tcImltXCJdO1xuICAgICAgcmVzW1wiaW1cIl0gPSB0bXA7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGNvbXBsZXggYXNpbmhcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgICAqL1xuICAgIFwiYWNvc2hcIjogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciB0bXA7XG4gICAgICB2YXIgcmVzID0gdGhpc1tcImFjb3NcIl0oKTtcbiAgICAgIGlmIChyZXNbXCJpbVwiXSA8PSAwKSB7XG4gICAgICAgIHRtcCA9IHJlc1tcInJlXCJdO1xuICAgICAgICByZXNbXCJyZVwiXSA9IC1yZXNbXCJpbVwiXTtcbiAgICAgICAgcmVzW1wiaW1cIl0gPSB0bXA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0bXAgPSByZXNbXCJpbVwiXTtcbiAgICAgICAgcmVzW1wiaW1cIl0gPSAtcmVzW1wicmVcIl07XG4gICAgICAgIHJlc1tcInJlXCJdID0gdG1wO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBjb21wbGV4IGF0YW5oXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICAgKi9cbiAgICBcImF0YW5oXCI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgYSA9IHRoaXNbXCJyZVwiXTtcbiAgICAgIHZhciBiID0gdGhpc1tcImltXCJdO1xuXG4gICAgICB2YXIgbm9JTSA9IGEgPiAxICYmIGIgPT09IDA7XG4gICAgICB2YXIgb25lTWludXMgPSAxIC0gYTtcbiAgICAgIHZhciBvbmVQbHVzID0gMSArIGE7XG4gICAgICB2YXIgZCA9IG9uZU1pbnVzICogb25lTWludXMgKyBiICogYjtcblxuICAgICAgdmFyIHggPSAoZCAhPT0gMClcbiAgICAgICAgICAgICAgPyBuZXcgQ29tcGxleChcbiAgICAgICAgICAgICAgICAgICAgICAob25lUGx1cyAqIG9uZU1pbnVzIC0gYiAqIGIpIC8gZCxcbiAgICAgICAgICAgICAgICAgICAgICAoYiAqIG9uZU1pbnVzICsgb25lUGx1cyAqIGIpIC8gZClcbiAgICAgICAgICAgICAgOiBuZXcgQ29tcGxleChcbiAgICAgICAgICAgICAgICAgICAgICAoYSAhPT0gLTEpID8gKGEgLyAwKSA6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgKGIgIT09IDApID8gKGIgLyAwKSA6IDApO1xuXG4gICAgICB2YXIgdGVtcCA9IHhbXCJyZVwiXTtcbiAgICAgIHhbXCJyZVwiXSA9IGxvZ0h5cG90KHhbXCJyZVwiXSwgeFtcImltXCJdKSAvIDI7XG4gICAgICB4W1wiaW1cIl0gPSBNYXRoLmF0YW4yKHhbXCJpbVwiXSwgdGVtcCkgLyAyO1xuICAgICAgaWYgKG5vSU0pIHtcbiAgICAgICAgeFtcImltXCJdID0gLXhbXCJpbVwiXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGNvbXBsZXggYWNvdGhcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgICAqL1xuICAgIFwiYWNvdGhcIjogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBhID0gdGhpc1tcInJlXCJdO1xuICAgICAgdmFyIGIgPSB0aGlzW1wiaW1cIl07XG5cbiAgICAgIGlmIChhID09PSAwICYmIGIgPT09IDApIHtcblxuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgoMCwgTWF0aC5QSSAvIDIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZCA9IGEgKiBhICsgYiAqIGI7XG4gICAgICByZXR1cm4gKGQgIT09IDApXG4gICAgICAgICAgICAgID8gbmV3IENvbXBsZXgoXG4gICAgICAgICAgICAgICAgICAgICAgYSAvIGQsXG4gICAgICAgICAgICAgICAgICAgICAtYiAvIGQpLmF0YW5oKClcbiAgICAgICAgICAgICAgOiBuZXcgQ29tcGxleChcbiAgICAgICAgICAgICAgICAgICAgICAoYSAhPT0gMCkgPyBhIC8gMCA6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgKGIgIT09IDApID8tYiAvIDAgOiAwKS5hdGFuaCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGNvbXBsZXggYWNzY2hcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgICAqL1xuICAgIFwiYWNzY2hcIjogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBhID0gdGhpc1tcInJlXCJdO1xuICAgICAgdmFyIGIgPSB0aGlzW1wiaW1cIl07XG5cbiAgICAgIGlmIChiID09PSAwKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgICAgICAgICAgIChhICE9PSAwKVxuICAgICAgICAgICAgICAgID8gTWF0aC5sb2coYSArIE1hdGguc3FydChhICogYSArIDEpKVxuICAgICAgICAgICAgICAgIDogSW5maW5pdHksIDApO1xuICAgICAgfVxuXG4gICAgICB2YXIgZCA9IGEgKiBhICsgYiAqIGI7XG4gICAgICByZXR1cm4gKGQgIT09IDApXG4gICAgICAgICAgICAgID8gbmV3IENvbXBsZXgoXG4gICAgICAgICAgICAgICAgICAgICAgYSAvIGQsXG4gICAgICAgICAgICAgICAgICAgICAgLWIgLyBkKS5hc2luaCgpXG4gICAgICAgICAgICAgIDogbmV3IENvbXBsZXgoXG4gICAgICAgICAgICAgICAgICAgICAgKGEgIT09IDApID8gYSAvIDAgOiAwLFxuICAgICAgICAgICAgICAgICAgICAgIChiICE9PSAwKSA/LWIgLyAwIDogMCkuYXNpbmgoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBjb21wbGV4IGFzZWNoXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICAgKi9cbiAgICBcImFzZWNoXCI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgYSA9IHRoaXNbXCJyZVwiXTtcbiAgICAgIHZhciBiID0gdGhpc1tcImltXCJdO1xuXG4gICAgICBpZiAoYSA9PT0gMCAmJiBiID09PSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcGxleChJbmZpbml0eSwgMCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkID0gYSAqIGEgKyBiICogYjtcbiAgICAgIHJldHVybiAoZCAhPT0gMClcbiAgICAgICAgICAgICAgPyBuZXcgQ29tcGxleChcbiAgICAgICAgICAgICAgICAgICAgICBhIC8gZCxcbiAgICAgICAgICAgICAgICAgICAgIC1iIC8gZCkuYWNvc2goKVxuICAgICAgICAgICAgICA6IG5ldyBDb21wbGV4KFxuICAgICAgICAgICAgICAgICAgICAgIChhICE9PSAwKSA/IGEgLyAwIDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAoYiAhPT0gMCkgPy1iIC8gMCA6IDApLmFjb3NoKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgY29tcGxleCBpbnZlcnNlIDEvelxuICAgICAqXG4gICAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAgICovXG4gICAgXCJpbnZlcnNlXCI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgYSA9IHRoaXNbXCJyZVwiXTtcbiAgICAgIHZhciBiID0gdGhpc1tcImltXCJdO1xuXG4gICAgICB2YXIgZCA9IGEgKiBhICsgYiAqIGI7XG5cbiAgICAgIHJldHVybiBuZXcgQ29tcGxleChcbiAgICAgICAgICAgICAgYSAhPT0gMCA/IGEgLyBkIDogMCxcbiAgICAgICAgICAgICAgYiAhPT0gMCA/LWIgLyBkIDogMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbXBsZXggY29uanVnYXRlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICAgKi9cbiAgICBcImNvbmp1Z2F0ZVwiOiBmdW5jdGlvbigpIHtcblxuICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KHRoaXNbXCJyZVwiXSwgLXRoaXNbXCJpbVwiXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5lZ2F0ZWQgY29tcGxleCBudW1iZXJcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgICAqL1xuICAgIFwibmVnXCI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICByZXR1cm4gbmV3IENvbXBsZXgoLXRoaXNbXCJyZVwiXSwgLXRoaXNbXCJpbVwiXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlaWxzIHRoZSBhY3R1YWwgY29tcGxleCBudW1iZXJcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgICAqL1xuICAgIFwiY2VpbFwiOiBmdW5jdGlvbihwbGFjZXMpIHtcblxuICAgICAgcGxhY2VzID0gTWF0aC5wb3coMTAsIHBsYWNlcyB8fCAwKTtcblxuICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgICAgICAgICBNYXRoLmNlaWwodGhpc1tcInJlXCJdICogcGxhY2VzKSAvIHBsYWNlcyxcbiAgICAgICAgICAgICAgTWF0aC5jZWlsKHRoaXNbXCJpbVwiXSAqIHBsYWNlcykgLyBwbGFjZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGbG9vcnMgdGhlIGFjdHVhbCBjb21wbGV4IG51bWJlclxuICAgICAqXG4gICAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAgICovXG4gICAgXCJmbG9vclwiOiBmdW5jdGlvbihwbGFjZXMpIHtcblxuICAgICAgcGxhY2VzID0gTWF0aC5wb3coMTAsIHBsYWNlcyB8fCAwKTtcblxuICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgICAgICAgICBNYXRoLmZsb29yKHRoaXNbXCJyZVwiXSAqIHBsYWNlcykgLyBwbGFjZXMsXG4gICAgICAgICAgICAgIE1hdGguZmxvb3IodGhpc1tcImltXCJdICogcGxhY2VzKSAvIHBsYWNlcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlaWxzIHRoZSBhY3R1YWwgY29tcGxleCBudW1iZXJcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgICAqL1xuICAgIFwicm91bmRcIjogZnVuY3Rpb24ocGxhY2VzKSB7XG5cbiAgICAgIHBsYWNlcyA9IE1hdGgucG93KDEwLCBwbGFjZXMgfHwgMCk7XG5cbiAgICAgIHJldHVybiBuZXcgQ29tcGxleChcbiAgICAgICAgICAgICAgTWF0aC5yb3VuZCh0aGlzW1wicmVcIl0gKiBwbGFjZXMpIC8gcGxhY2VzLFxuICAgICAgICAgICAgICBNYXRoLnJvdW5kKHRoaXNbXCJpbVwiXSAqIHBsYWNlcykgLyBwbGFjZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb21wYXJlcyB0d28gY29tcGxleCBudW1iZXJzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBcImVxdWFsc1wiOiBmdW5jdGlvbihhLCBiKSB7XG5cbiAgICAgIHBhcnNlKGEsIGIpOyAvLyBtdXRhdGVzIFBcblxuICAgICAgcmV0dXJuIE1hdGguYWJzKFBbXCJyZVwiXSAtIHRoaXNbXCJyZVwiXSkgPD0gQ29tcGxleFtcIkVQU0lMT05cIl0gJiZcbiAgICAgICAgICAgICBNYXRoLmFicyhQW1wiaW1cIl0gLSB0aGlzW1wiaW1cIl0pIDw9IENvbXBsZXhbXCJFUFNJTE9OXCJdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbG9uZXMgdGhlIGFjdHVhbCBvYmplY3RcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgICAqL1xuICAgIFwiY2xvbmVcIjogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHJldHVybiBuZXcgQ29tcGxleCh0aGlzW1wicmVcIl0sIHRoaXNbXCJpbVwiXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgYSBzdHJpbmcgb2YgdGhlIGFjdHVhbCBjb21wbGV4IG51bWJlclxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBcInRvU3RyaW5nXCI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgYSA9IHRoaXNbXCJyZVwiXTtcbiAgICAgIHZhciBiID0gdGhpc1tcImltXCJdO1xuICAgICAgdmFyIHJldCA9IFwiXCI7XG5cbiAgICAgIGlmIChpc05hTihhKSB8fCBpc05hTihiKSkge1xuICAgICAgICByZXR1cm4gXCJOYU5cIjtcbiAgICAgIH1cblxuICAgICAgaWYgKGEgIT09IDApIHtcbiAgICAgICAgcmV0Kz0gYTtcbiAgICAgIH1cblxuICAgICAgaWYgKGIgIT09IDApIHtcblxuICAgICAgICBpZiAoYSAhPT0gMCkge1xuICAgICAgICAgIHJldCs9IGIgPCAwID8gXCIgLSBcIiA6IFwiICsgXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoYiA8IDApIHtcbiAgICAgICAgICByZXQrPSBcIi1cIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGIgPSBNYXRoLmFicyhiKTtcblxuICAgICAgICBpZiAoMSAhPT0gYikge1xuICAgICAgICAgIHJldCs9IGI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0Kz0gXCJpXCI7XG4gICAgICB9XG5cbiAgICAgIGlmICghcmV0KVxuICAgICAgICByZXR1cm4gXCIwXCI7XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFjdHVhbCBudW1iZXIgYXMgYSB2ZWN0b3JcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBcInRvVmVjdG9yXCI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICByZXR1cm4gW3RoaXNbXCJyZVwiXSwgdGhpc1tcImltXCJdXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYWN0dWFsIHJlYWwgdmFsdWUgb2YgdGhlIGN1cnJlbnQgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfG51bGx9XG4gICAgICovXG4gICAgXCJ2YWx1ZU9mXCI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICBpZiAodGhpc1tcImltXCJdID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzW1wicmVcIl07XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBjb21wbGV4IG51bWJlciBpcyBub3QgYSBudW1iZXJcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzTmFOOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBpc05hTih0aGlzWydyZSddKSB8fCBpc05hTih0aGlzWydpbSddKTtcbiAgICB9XG4gIH07XG5cbiAgQ29tcGxleFtcIlpFUk9cIl0gPSBuZXcgQ29tcGxleCgwLCAwKTtcbiAgQ29tcGxleFtcIk9ORVwiXSA9IG5ldyBDb21wbGV4KDEsIDApO1xuICBDb21wbGV4W1wiSVwiXSA9IG5ldyBDb21wbGV4KDAsIDEpO1xuICBDb21wbGV4W1wiUElcIl0gPSBuZXcgQ29tcGxleChNYXRoLlBJLCAwKTtcbiAgQ29tcGxleFtcIkVcIl0gPSBuZXcgQ29tcGxleChNYXRoLkUsIDApO1xuICBDb21wbGV4WydFUFNJTE9OJ10gPSAxZS0xNjtcblxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZVtcImFtZFwiXSkge1xuICAgIGRlZmluZShbXSwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gQ29tcGxleDtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuICAgIG1vZHVsZVtcImV4cG9ydHNcIl0gPSBDb21wbGV4O1xuICB9IGVsc2Uge1xuICAgIHJvb3RbXCJDb21wbGV4XCJdID0gQ29tcGxleDtcbiAgfVxuICBcbn0pKHRoaXMpO1xuIiwiLyohIGRlY2ltYWwuanMgdjUuMC42IGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2RlY2ltYWwuanMvTElDRU5DRSAqL1xyXG47KGZ1bmN0aW9uIChnbG9iYWxTY29wZSkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG4gIC8qXHJcbiAgICogIGRlY2ltYWwuanMgdjUuMC42XHJcbiAgICogIEFuIGFyYml0cmFyeS1wcmVjaXNpb24gRGVjaW1hbCB0eXBlIGZvciBKYXZhU2NyaXB0LlxyXG4gICAqICBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9kZWNpbWFsLmpzXHJcbiAgICogIENvcHlyaWdodCAoYykgMjAxNiBNaWNoYWVsIE1jbGF1Z2hsaW4gPE04Y2g4OGxAZ21haWwuY29tPlxyXG4gICAqICBNSVQgRXhwYXQgTGljZW5jZVxyXG4gICAqL1xyXG5cclxuXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gIEVESVRBQkxFIERFRkFVTFRTICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cclxuXHJcblxyXG4gICAgLy8gVGhlIG1heGltdW0gZXhwb25lbnQgbWFnbml0dWRlLlxyXG4gICAgLy8gVGhlIGxpbWl0IG9uIHRoZSB2YWx1ZSBvZiBgdG9FeHBOZWdgLCBgdG9FeHBQb3NgLCBgbWluRWAgYW5kIGBtYXhFYC5cclxuICB2YXIgRVhQX0xJTUlUID0gOWUxNSwgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byA5ZTE1XHJcblxyXG4gICAgLy8gVGhlIGxpbWl0IG9uIHRoZSB2YWx1ZSBvZiBgcHJlY2lzaW9uYCwgYW5kIG9uIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgYXJndW1lbnQgdG9cclxuICAgIC8vIGB0b0RlY2ltYWxQbGFjZXNgLCBgdG9FeHBvbmVudGlhbGAsIGB0b0ZpeGVkYCwgYHRvUHJlY2lzaW9uYCBhbmQgYHRvU2lnbmlmaWNhbnREaWdpdHNgLlxyXG4gICAgTUFYX0RJR0lUUyA9IDFlOSwgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIDFlOVxyXG5cclxuICAgIC8vIFRoZSBiYXNlIDg4IGFscGhhYmV0IHVzZWQgYnkgYHRvSlNPTmAgYW5kIGBmcm9tSlNPTmAuXHJcbiAgICAvLyA3IHByaW50YWJsZSBBU0NJSSBjaGFyYWN0ZXJzIG9taXR0ZWQgKHNwYWNlKSBcXCBcIiAmICcgPCA+XHJcbiAgICBOVU1FUkFMUyA9ICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWiEjJCUoKSorLC0uLzo7PT9AW11eX2B7fH1+JyxcclxuXHJcbiAgICAvLyBUaGUgbmF0dXJhbCBsb2dhcml0aG0gb2YgMTAgKDEwMjUgZGlnaXRzKS5cclxuICAgIExOMTAgPSAnMi4zMDI1ODUwOTI5OTQwNDU2ODQwMTc5OTE0NTQ2ODQzNjQyMDc2MDExMDE0ODg2Mjg3NzI5NzYwMzMzMjc5MDA5Njc1NzI2MDk2NzczNTI0ODAyMzU5OTcyMDUwODk1OTgyOTgzNDE5Njc3ODQwNDIyODYyNDg2MzM0MDk1MjU0NjUwODI4MDY3NTY2NjYyODczNjkwOTg3ODE2ODk0ODI5MDcyMDgzMjU1NTQ2ODA4NDM3OTk4OTQ4MjYyMzMxOTg1MjgzOTM1MDUzMDg5NjUzNzc3MzI2Mjg4NDYxNjMzNjYyMjIyODc2OTgyMTk4ODY3NDY1NDM2Njc0NzQ0MDQyNDMyNzQzNjUxNTUwNDg5MzQzMTQ5MzkzOTE0Nzk2MTk0MDQ0MDAyMjIxMDUxMDE3MTQxNzQ4MDAzNjg4MDg0MDEyNjQ3MDgwNjg1NTY3NzQzMjE2MjI4MzU1MjIwMTE0ODA0NjYzNzE1NjU5MTIxMzczNDUwNzQ3ODU2OTQ3NjgzNDYzNjE2NzkyMTAxODA2NDQ1MDcwNjQ4MDAwMjc3NTAyNjg0OTE2NzQ2NTUwNTg2ODU2OTM1NjczNDIwNjcwNTgxMTM2NDI5MjI0NTU0NDA1NzU4OTI1NzI0MjA4MjQxMzE0Njk1Njg5MDE2NzU4OTQwMjU2Nzc2MzExMzU2OTE5MjkyMDMzMzc2NTg3MTQxNjYwMjMwMTA1NzAzMDg5NjM0NTcyMDc1NDQwMzcwODQ3NDY5OTQwMTY4MjY5MjgyODA4NDgxMTg0Mjg5MzE0ODQ4NTI0OTQ4NjQ0ODcxOTI3ODA5Njc2MjcxMjc1Nzc1Mzk3MDI3NjY4NjA1OTUyNDk2NzE2Njc0MTgzNDg1NzA0NDIyNTA3MTk3OTY1MDA0NzE0OTUxMDUwNDkyMjE0Nzc2NTY3NjM2OTM4NjYyOTc2OTc5NTIyMTEwNzE4MjY0NTQ5NzM0NzcyNjYyNDI1NzA5NDI5MzIyNTgyNzk4NTAyNTg1NTA5Nzg1MjY1MzgzMjA3NjA2NzI2MzE3MTY0MzA5NTA1OTk1MDg3ODA3NTIzNzEwMzMzMTAxMTk3ODU3NTQ3MzMxNTQxNDIxODA4NDI3NTQzODYzNTkxNzc4MTE3MDU0MzA5ODI3NDgyMzg1MDQ1NjQ4MDE5MDk1NjEwMjk5MjkxODI0MzE4MjM3NTI1MzU3NzA5NzUwNTM5NTY1MTg3Njk3NTEwMzc0OTcwODg4NjkyMTgwMjA1MTg5MzM5NTA3MjM4NTM5MjA1MTQ0NjM0MTk3MjY1Mjg3Mjg2OTY1MTEwODYyNTcxNDkyMTk4ODQ5OTc4NzQ4ODczNzcxMzQ1Njg2MjA5MTY3MDU4JyxcclxuXHJcbiAgICAvLyBQaSAoMTAyNSBkaWdpdHMpLlxyXG4gICAgUEkgPSAnMy4xNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDMzODMyNzk1MDI4ODQxOTcxNjkzOTkzNzUxMDU4MjA5NzQ5NDQ1OTIzMDc4MTY0MDYyODYyMDg5OTg2MjgwMzQ4MjUzNDIxMTcwNjc5ODIxNDgwODY1MTMyODIzMDY2NDcwOTM4NDQ2MDk1NTA1ODIyMzE3MjUzNTk0MDgxMjg0ODExMTc0NTAyODQxMDI3MDE5Mzg1MjExMDU1NTk2NDQ2MjI5NDg5NTQ5MzAzODE5NjQ0Mjg4MTA5NzU2NjU5MzM0NDYxMjg0NzU2NDgyMzM3ODY3ODMxNjUyNzEyMDE5MDkxNDU2NDg1NjY5MjM0NjAzNDg2MTA0NTQzMjY2NDgyMTMzOTM2MDcyNjAyNDkxNDEyNzM3MjQ1ODcwMDY2MDYzMTU1ODgxNzQ4ODE1MjA5MjA5NjI4MjkyNTQwOTE3MTUzNjQzNjc4OTI1OTAzNjAwMTEzMzA1MzA1NDg4MjA0NjY1MjEzODQxNDY5NTE5NDE1MTE2MDk0MzMwNTcyNzAzNjU3NTk1OTE5NTMwOTIxODYxMTczODE5MzI2MTE3OTMxMDUxMTg1NDgwNzQ0NjIzNzk5NjI3NDk1NjczNTE4ODU3NTI3MjQ4OTEyMjc5MzgxODMwMTE5NDkxMjk4MzM2NzMzNjI0NDA2NTY2NDMwODYwMjEzOTQ5NDYzOTUyMjQ3MzcxOTA3MDIxNzk4NjA5NDM3MDI3NzA1MzkyMTcxNzYyOTMxNzY3NTIzODQ2NzQ4MTg0Njc2Njk0MDUxMzIwMDA1NjgxMjcxNDUyNjM1NjA4Mjc3ODU3NzEzNDI3NTc3ODk2MDkxNzM2MzcxNzg3MjE0Njg0NDA5MDEyMjQ5NTM0MzAxNDY1NDk1ODUzNzEwNTA3OTIyNzk2ODkyNTg5MjM1NDIwMTk5NTYxMTIxMjkwMjE5NjA4NjQwMzQ0MTgxNTk4MTM2Mjk3NzQ3NzEzMDk5NjA1MTg3MDcyMTEzNDk5OTk5OTgzNzI5NzgwNDk5NTEwNTk3MzE3MzI4MTYwOTYzMTg1OTUwMjQ0NTk0NTUzNDY5MDgzMDI2NDI1MjIzMDgyNTMzNDQ2ODUwMzUyNjE5MzExODgxNzEwMTAwMDMxMzc4Mzg3NTI4ODY1ODc1MzMyMDgzODE0MjA2MTcxNzc2NjkxNDczMDM1OTgyNTM0OTA0Mjg3NTU0Njg3MzExNTk1NjI4NjM4ODIzNTM3ODc1OTM3NTE5NTc3ODE4NTc3ODA1MzIxNzEyMjY4MDY2MTMwMDE5Mjc4NzY2MTExOTU5MDkyMTY0MjAxOTg5MzgwOTUyNTcyMDEwNjU0ODU4NjMyNzg5JyxcclxuXHJcblxyXG4gICAgLy8gVGhlIGluaXRpYWwgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzIG9mIHRoZSBEZWNpbWFsIGNvbnN0cnVjdG9yLlxyXG4gICAgRGVjaW1hbCA9IHtcclxuXHJcbiAgICAgIC8vIFRoZXNlIHZhbHVlcyBtdXN0IGJlIGludGVnZXJzIHdpdGhpbiB0aGUgc3RhdGVkIHJhbmdlcyAoaW5jbHVzaXZlKS5cclxuICAgICAgLy8gTW9zdCBvZiB0aGVzZSB2YWx1ZXMgY2FuIGJlIGNoYW5nZWQgZHVyaW5nIHJ1bi10aW1lIHVzaW5nIGBEZWNpbWFsLmNvbmZpZ2AuXHJcblxyXG4gICAgICAvLyBUaGUgbWF4aW11bSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIG9mIHRoZSByZXN1bHQgb2YgYSBjYWxjdWxhdGlvbiBvciBiYXNlIGNvbnZlcnNpb24uXHJcbiAgICAgIC8vIEUuZy4gYERlY2ltYWwuY29uZmlnKHsgcHJlY2lzaW9uOiAyMCB9KTtgXHJcbiAgICAgIHByZWNpc2lvbjogMjAsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEgdG8gTUFYX0RJR0lUU1xyXG5cclxuICAgICAgLy8gVGhlIHJvdW5kaW5nIG1vZGUgdXNlZCB3aGVuIHJvdW5kaW5nIHRvIGBwcmVjaXNpb25gLlxyXG4gICAgICAvL1xyXG4gICAgICAvLyBST1VORF9VUCAgICAgICAgIDAgQXdheSBmcm9tIHplcm8uXHJcbiAgICAgIC8vIFJPVU5EX0RPV04gICAgICAgMSBUb3dhcmRzIHplcm8uXHJcbiAgICAgIC8vIFJPVU5EX0NFSUwgICAgICAgMiBUb3dhcmRzICtJbmZpbml0eS5cclxuICAgICAgLy8gUk9VTkRfRkxPT1IgICAgICAzIFRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgICAvLyBST1VORF9IQUxGX1VQICAgIDQgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHVwLlxyXG4gICAgICAvLyBST1VORF9IQUxGX0RPV04gIDUgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIGRvd24uXHJcbiAgICAgIC8vIFJPVU5EX0hBTEZfRVZFTiAgNiBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyBldmVuIG5laWdoYm91ci5cclxuICAgICAgLy8gUk9VTkRfSEFMRl9DRUlMICA3IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzICtJbmZpbml0eS5cclxuICAgICAgLy8gUk9VTkRfSEFMRl9GTE9PUiA4IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzIC1JbmZpbml0eS5cclxuICAgICAgLy9cclxuICAgICAgLy8gRS5nLlxyXG4gICAgICAvLyBgRGVjaW1hbC5yb3VuZGluZyA9IDQ7YFxyXG4gICAgICAvLyBgRGVjaW1hbC5yb3VuZGluZyA9IERlY2ltYWwuUk9VTkRfSEFMRl9VUDtgXHJcbiAgICAgIHJvdW5kaW5nOiA0LCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOFxyXG5cclxuICAgICAgLy8gVGhlIG1vZHVsbyBtb2RlIHVzZWQgd2hlbiBjYWxjdWxhdGluZyB0aGUgbW9kdWx1czogYSBtb2Qgbi5cclxuICAgICAgLy8gVGhlIHF1b3RpZW50IChxID0gYSAvIG4pIGlzIGNhbGN1bGF0ZWQgYWNjb3JkaW5nIHRvIHRoZSBjb3JyZXNwb25kaW5nIHJvdW5kaW5nIG1vZGUuXHJcbiAgICAgIC8vIFRoZSByZW1haW5kZXIgKHIpIGlzIGNhbGN1bGF0ZWQgYXM6IHIgPSBhIC0gbiAqIHEuXHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIFVQICAgICAgICAgMCBUaGUgcmVtYWluZGVyIGlzIHBvc2l0aXZlIGlmIHRoZSBkaXZpZGVuZCBpcyBuZWdhdGl2ZSwgZWxzZSBpcyBuZWdhdGl2ZS5cclxuICAgICAgLy8gRE9XTiAgICAgICAxIFRoZSByZW1haW5kZXIgaGFzIHRoZSBzYW1lIHNpZ24gYXMgdGhlIGRpdmlkZW5kIChKYXZhU2NyaXB0ICUpLlxyXG4gICAgICAvLyBGTE9PUiAgICAgIDMgVGhlIHJlbWFpbmRlciBoYXMgdGhlIHNhbWUgc2lnbiBhcyB0aGUgZGl2aXNvciAoUHl0aG9uICUpLlxyXG4gICAgICAvLyBIQUxGX0VWRU4gIDYgVGhlIElFRUUgNzU0IHJlbWFpbmRlciBmdW5jdGlvbi5cclxuICAgICAgLy8gRVVDTElEICAgICA5IEV1Y2xpZGlhbiBkaXZpc2lvbi4gcSA9IHNpZ24obikgKiBmbG9vcihhIC8gYWJzKG4pKS4gQWx3YXlzIHBvc2l0aXZlLlxyXG4gICAgICAvL1xyXG4gICAgICAvLyBUcnVuY2F0ZWQgZGl2aXNpb24gKDEpLCBmbG9vcmVkIGRpdmlzaW9uICgzKSwgdGhlIElFRUUgNzU0IHJlbWFpbmRlciAoNiksIGFuZCBFdWNsaWRpYW5cclxuICAgICAgLy8gZGl2aXNpb24gKDkpIGFyZSBjb21tb25seSB1c2VkIGZvciB0aGUgbW9kdWx1cyBvcGVyYXRpb24uIFRoZSBvdGhlciByb3VuZGluZyBtb2RlcyBjYW4gYWxzb1xyXG4gICAgICAvLyBiZSB1c2VkLCBidXQgdGhleSBtYXkgbm90IGdpdmUgdXNlZnVsIHJlc3VsdHMuXHJcbiAgICAgIG1vZHVsbzogMSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOVxyXG5cclxuICAgICAgLy8gVGhlIGV4cG9uZW50IHZhbHVlIGF0IGFuZCBiZW5lYXRoIHdoaWNoIGB0b1N0cmluZ2AgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgLy8gSmF2YVNjcmlwdCBudW1iZXJzOiAtN1xyXG4gICAgICB0b0V4cE5lZzogLTcsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIC1FWFBfTElNSVRcclxuXHJcbiAgICAgIC8vIFRoZSBleHBvbmVudCB2YWx1ZSBhdCBhbmQgYWJvdmUgd2hpY2ggYHRvU3RyaW5nYCByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICAvLyBKYXZhU2NyaXB0IG51bWJlcnM6IDIxXHJcbiAgICAgIHRvRXhwUG9zOiAgMjEsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gRVhQX0xJTUlUXHJcblxyXG4gICAgICAvLyBUaGUgbWluaW11bSBleHBvbmVudCB2YWx1ZSwgYmVuZWF0aCB3aGljaCB1bmRlcmZsb3cgdG8gemVybyBvY2N1cnMuXHJcbiAgICAgIC8vIEphdmFTY3JpcHQgbnVtYmVyczogLTMyNCAgKDVlLTMyNClcclxuICAgICAgbWluRTogLUVYUF9MSU1JVCwgICAgICAgICAgICAgICAgICAgICAgLy8gLTEgdG8gLUVYUF9MSU1JVFxyXG5cclxuICAgICAgLy8gVGhlIG1heGltdW0gZXhwb25lbnQgdmFsdWUsIGFib3ZlIHdoaWNoIG92ZXJmbG93IHRvIEluZmluaXR5IG9jY3Vycy5cclxuICAgICAgLy8gSmF2YVNjcmlwdCBudW1iZXJzOiAzMDggICgxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOClcclxuICAgICAgbWF4RTogRVhQX0xJTUlULCAgICAgICAgICAgICAgICAgICAgICAgLy8gMSB0byBFWFBfTElNSVRcclxuXHJcbiAgICAgIC8vIFdoZXRoZXIgdG8gdXNlIGNyeXB0b2dyYXBoaWNhbGx5LXNlY3VyZSByYW5kb20gbnVtYmVyIGdlbmVyYXRpb24sIGlmIGF2YWlsYWJsZS5cclxuICAgICAgY3J5cHRvOiB2b2lkIDAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1ZS9mYWxzZS91bmRlZmluZWRcclxuICAgIH0sXHJcblxyXG5cclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFTkQgT0YgRURJVEFCTEUgREVGQVVMVFMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xyXG5cclxuXHJcbiAgICBpbmV4YWN0LCBub0NvbmZsaWN0LCBxdWFkcmFudCxcclxuICAgIGNyeXB0b09iamVjdCA9IHR5cGVvZiBjcnlwdG8gIT0gJ3VuZGVmaW5lZCcgPyBjcnlwdG8gOiBudWxsLFxyXG4gICAgZXh0ZXJuYWwgPSB0cnVlLFxyXG5cclxuICAgIGRlY2ltYWxFcnJvciA9ICdbRGVjaW1hbEVycm9yXSAnLFxyXG4gICAgaW52YWxpZEFyZ3VtZW50ID0gZGVjaW1hbEVycm9yICsgJ0ludmFsaWQgYXJndW1lbnQ6ICcsXHJcbiAgICBwcmVjaXNpb25MaW1pdEV4Y2VlZGVkID0gZGVjaW1hbEVycm9yICsgJ1ByZWNpc2lvbiBsaW1pdCBleGNlZWRlZCcsXHJcblxyXG4gICAgbWF0aGZsb29yID0gTWF0aC5mbG9vcixcclxuICAgIG1hdGhwb3cgPSBNYXRoLnBvdyxcclxuXHJcbiAgICBpc0JpbmFyeSA9IC9eMGIoWzAxXSsoXFwuWzAxXSopP3xcXC5bMDFdKykocFsrLV0/XFxkKyk/JC9pLFxyXG4gICAgaXNIZXggPSAvXjB4KFswLTlhLWZdKyhcXC5bMC05YS1mXSopP3xcXC5bMC05YS1mXSspKHBbKy1dP1xcZCspPyQvaSxcclxuICAgIGlzT2N0YWwgPSAvXjBvKFswLTddKyhcXC5bMC03XSopP3xcXC5bMC03XSspKHBbKy1dP1xcZCspPyQvaSxcclxuICAgIGlzRGVjaW1hbCA9IC9eKFxcZCsoXFwuXFxkKik/fFxcLlxcZCspKGVbKy1dP1xcZCspPyQvaSxcclxuXHJcbiAgICBCQVNFID0gMWU3LFxyXG4gICAgTE9HX0JBU0UgPSA3LFxyXG4gICAgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTEsXHJcblxyXG4gICAgTE4xMF9QUkVDSVNJT04gPSBMTjEwLmxlbmd0aCAtIDEsXHJcbiAgICBQSV9QUkVDSVNJT04gPSBQSS5sZW5ndGggLSAxLFxyXG5cclxuICAgIC8vIERlY2ltYWwucHJvdG90eXBlIG9iamVjdFxyXG4gICAgUCA9IHt9O1xyXG5cclxuXHJcbiAgLy8gRGVjaW1hbCBwcm90b3R5cGUgbWV0aG9kc1xyXG5cclxuXHJcbiAgLypcclxuICAgKiAgYWJzb2x1dGVWYWx1ZSAgICAgICAgICAgICBhYnNcclxuICAgKiAgY2VpbFxyXG4gICAqICBjb21wYXJlZFRvICAgICAgICAgICAgICAgIGNtcFxyXG4gICAqICBjb3NpbmUgICAgICAgICAgICAgICAgICAgIGNvc1xyXG4gICAqICBjdWJlUm9vdCAgICAgICAgICAgICAgICAgIGNicnRcclxuICAgKiAgZGVjaW1hbFBsYWNlcyAgICAgICAgICAgICBkcFxyXG4gICAqICBkaXZpZGVkQnkgICAgICAgICAgICAgICAgIGRpdlxyXG4gICAqICBkaXZpZGVkVG9JbnRlZ2VyQnkgICAgICAgIGRpdlRvSW50XHJcbiAgICogIGVxdWFscyAgICAgICAgICAgICAgICAgICAgZXFcclxuICAgKiAgZmxvb3JcclxuICAgKiAgZ3JlYXRlclRoYW4gICAgICAgICAgICAgICBndFxyXG4gICAqICBncmVhdGVyVGhhbk9yRXF1YWxUbyAgICAgIGd0ZVxyXG4gICAqICBoeXBlcmJvbGljQ29zaW5lICAgICAgICAgIGNvc2hcclxuICAgKiAgaHlwZXJib2xpY1NpbmUgICAgICAgICAgICBzaW5oXHJcbiAgICogIGh5cGVyYm9saWNUYW5nZW50ICAgICAgICAgdGFuaFxyXG4gICAqICBpbnZlcnNlQ29zaW5lICAgICAgICAgICAgIGFjb3NcclxuICAgKiAgaW52ZXJzZUh5cGVyYm9saWNDb3NpbmUgICBhY29zaFxyXG4gICAqICBpbnZlcnNlSHlwZXJib2xpY1NpbmUgICAgIGFzaW5oXHJcbiAgICogIGludmVyc2VIeXBlcmJvbGljVGFuZ2VudCAgYXRhbmhcclxuICAgKiAgaW52ZXJzZVNpbmUgICAgICAgICAgICAgICBhc2luXHJcbiAgICogIGludmVyc2VUYW5nZW50ICAgICAgICAgICAgYXRhblxyXG4gICAqICBpc0Zpbml0ZVxyXG4gICAqICBpc0ludGVnZXIgICAgICAgICAgICAgICAgIGlzSW50XHJcbiAgICogIGlzTmFOXHJcbiAgICogIGlzTmVnYXRpdmUgICAgICAgICAgICAgICAgaXNOZWdcclxuICAgKiAgaXNQb3NpdGl2ZSAgICAgICAgICAgICAgICBpc1Bvc1xyXG4gICAqICBpc1plcm9cclxuICAgKiAgbGVzc1RoYW4gICAgICAgICAgICAgICAgICBsdFxyXG4gICAqICBsZXNzVGhhbk9yRXF1YWxUbyAgICAgICAgIGx0ZVxyXG4gICAqICBsb2dhcml0aG0gICAgICAgICAgICAgICAgIGxvZ1xyXG4gICAqICBbbWF4aW11bV0gICAgICAgICAgICAgICAgIFttYXhdXHJcbiAgICogIFttaW5pbXVtXSAgICAgICAgICAgICAgICAgW21pbl1cclxuICAgKiAgbWludXMgICAgICAgICAgICAgICAgICAgICBzdWJcclxuICAgKiAgbW9kdWxvICAgICAgICAgICAgICAgICAgICBtb2RcclxuICAgKiAgbmF0dXJhbEV4cG9uZW50aWFsICAgICAgICBleHBcclxuICAgKiAgbmF0dXJhbExvZ2FyaXRobSAgICAgICAgICBsblxyXG4gICAqICBuZWdhdGVkICAgICAgICAgICAgICAgICAgIG5lZ1xyXG4gICAqICBwbHVzICAgICAgICAgICAgICAgICAgICAgIGFkZFxyXG4gICAqICBwcmVjaXNpb24gICAgICAgICAgICAgICAgIHNkXHJcbiAgICogIHJvdW5kXHJcbiAgICogIHNpbmUgICAgICAgICAgICAgICAgICAgICAgc2luXHJcbiAgICogIHNxdWFyZVJvb3QgICAgICAgICAgICAgICAgc3FydFxyXG4gICAqICB0YW5nZW50ICAgICAgICAgICAgICAgICAgIHRhblxyXG4gICAqICB0aW1lcyAgICAgICAgICAgICAgICAgICAgIG11bFxyXG4gICAqICB0b0JpbmFyeVxyXG4gICAqICB0b0RlY2ltYWxQbGFjZXMgICAgICAgICAgIHRvRFBcclxuICAgKiAgdG9FeHBvbmVudGlhbFxyXG4gICAqICB0b0ZpeGVkXHJcbiAgICogIHRvRnJhY3Rpb25cclxuICAgKiAgdG9IZXhhZGVjaW1hbCAgICAgICAgICAgICB0b0hleFxyXG4gICAqICB0b0pTT05cclxuICAgKiAgdG9OZWFyZXN0XHJcbiAgICogIHRvTnVtYmVyXHJcbiAgICogIHRvT2N0YWxcclxuICAgKiAgdG9Qb3dlciAgICAgICAgICAgICAgICAgICBwb3dcclxuICAgKiAgdG9QcmVjaXNpb25cclxuICAgKiAgdG9TaWduaWZpY2FudERpZ2l0cyAgICAgICB0b1NEXHJcbiAgICogIHRvU3RyaW5nXHJcbiAgICogIHRydW5jYXRlZCAgICAgICAgICAgICAgICAgdHJ1bmNcclxuICAgKiAgdmFsdWVPZlxyXG4gICAqL1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsLlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5hYnNvbHV0ZVZhbHVlID0gUC5hYnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgeCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpO1xyXG4gICAgaWYgKHgucyA8IDApIHgucyA9IDE7XHJcbiAgICByZXR1cm4gZmluYWxpc2UoeCk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCByb3VuZGVkIHRvIGEgd2hvbGUgbnVtYmVyIGluIHRoZVxyXG4gICAqIGRpcmVjdGlvbiBvZiBwb3NpdGl2ZSBJbmZpbml0eS5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAuY2VpbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBmaW5hbGlzZShuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKSwgdGhpcy5lICsgMSwgMik7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuXHJcbiAgICogICAxICAgIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaXMgZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZSBvZiBgeWAsXHJcbiAgICogIC0xICAgIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaXMgbGVzcyB0aGFuIHRoZSB2YWx1ZSBvZiBgeWAsXHJcbiAgICogICAwICAgIGlmIHRoZXkgaGF2ZSB0aGUgc2FtZSB2YWx1ZSxcclxuICAgKiAgIE5hTiAgaWYgdGhlIHZhbHVlIG9mIGVpdGhlciBEZWNpbWFsIGlzIE5hTi5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAuY29tcGFyZWRUbyA9IFAuY21wID0gZnVuY3Rpb24gKHkpIHtcclxuICAgIHZhciBpLCBqLCB4ZEwsIHlkTCxcclxuICAgICAgeCA9IHRoaXMsXHJcbiAgICAgIHhkID0geC5kLFxyXG4gICAgICB5ZCA9ICh5ID0gbmV3IHguY29uc3RydWN0b3IoeSkpLmQsXHJcbiAgICAgIHhzID0geC5zLFxyXG4gICAgICB5cyA9IHkucztcclxuXHJcbiAgICAvLyBFaXRoZXIgTmFOIG9yIMKxSW5maW5pdHk/XHJcbiAgICBpZiAoIXhkIHx8ICF5ZCkge1xyXG4gICAgICByZXR1cm4gIXhzIHx8ICF5cyA/IE5hTiA6IHhzICE9PSB5cyA/IHhzIDogeGQgPT09IHlkID8gMCA6ICF4ZCBeIHhzIDwgMCA/IDEgOiAtMTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBFaXRoZXIgemVybz9cclxuICAgIGlmICgheGRbMF0gfHwgIXlkWzBdKSByZXR1cm4geGRbMF0gPyB4cyA6IHlkWzBdID8gLXlzIDogMDtcclxuXHJcbiAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICBpZiAoeHMgIT09IHlzKSByZXR1cm4geHM7XHJcblxyXG4gICAgLy8gQ29tcGFyZSBleHBvbmVudHMuXHJcbiAgICBpZiAoeC5lICE9PSB5LmUpIHJldHVybiB4LmUgPiB5LmUgXiB4cyA8IDAgPyAxIDogLTE7XHJcblxyXG4gICAgeGRMID0geGQubGVuZ3RoO1xyXG4gICAgeWRMID0geWQubGVuZ3RoO1xyXG5cclxuICAgIC8vIENvbXBhcmUgZGlnaXQgYnkgZGlnaXQuXHJcbiAgICBmb3IgKGkgPSAwLCBqID0geGRMIDwgeWRMID8geGRMIDogeWRMOyBpIDwgajsgKytpKSB7XHJcbiAgICAgIGlmICh4ZFtpXSAhPT0geWRbaV0pIHJldHVybiB4ZFtpXSA+IHlkW2ldIF4geHMgPCAwID8gMSA6IC0xO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENvbXBhcmUgbGVuZ3Rocy5cclxuICAgIHJldHVybiB4ZEwgPT09IHlkTCA/IDAgOiB4ZEwgPiB5ZEwgXiB4cyA8IDAgPyAxIDogLTE7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGNvc2luZSBvZiB0aGUgdmFsdWUgaW4gcmFkaWFucyBvZiB0aGlzIERlY2ltYWwuXHJcbiAgICpcclxuICAgKiBEb21haW46IFstSW5maW5pdHksIEluZmluaXR5XVxyXG4gICAqIFJhbmdlOiBbLTEsIDFdXHJcbiAgICpcclxuICAgKiBjb3MoMCkgICAgICAgICA9IDFcclxuICAgKiBjb3MoLTApICAgICAgICA9IDFcclxuICAgKiBjb3MoSW5maW5pdHkpICA9IE5hTlxyXG4gICAqIGNvcygtSW5maW5pdHkpID0gTmFOXHJcbiAgICogY29zKE5hTikgICAgICAgPSBOYU5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAuY29zaW5lID0gUC5jb3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgcHIsIHJtLFxyXG4gICAgICB4ID0gdGhpcyxcclxuICAgICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gICAgaWYgKCF4LmQpIHJldHVybiBuZXcgQ3RvcihOYU4pO1xyXG5cclxuICAgIC8vIGNvcygwKSA9IGNvcygtMCkgPSAxXHJcbiAgICBpZiAoIXguZFswXSkgcmV0dXJuIG5ldyBDdG9yKDEpO1xyXG5cclxuICAgIHByID0gQ3Rvci5wcmVjaXNpb247XHJcbiAgICBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgICBDdG9yLnByZWNpc2lvbiA9IHByICsgTWF0aC5tYXgoeC5lLCB4LnNkKCkpICsgTE9HX0JBU0U7XHJcbiAgICBDdG9yLnJvdW5kaW5nID0gMTtcclxuXHJcbiAgICB4ID0gY29zaW5lKEN0b3IsIHRvTGVzc1RoYW5IYWxmUGkoQ3RvciwgeCkpO1xyXG5cclxuICAgIEN0b3IucHJlY2lzaW9uID0gcHI7XHJcbiAgICBDdG9yLnJvdW5kaW5nID0gcm07XHJcblxyXG4gICAgcmV0dXJuIGZpbmFsaXNlKHF1YWRyYW50ID09IDIgfHwgcXVhZHJhbnQgPT0gMyA/IHgubmVnKCkgOiB4LCBwciwgcm0sIHRydWUpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGN1YmUgcm9vdCBvZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsLCByb3VuZGVkIHRvXHJcbiAgICogYHByZWNpc2lvbmAgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqICBjYnJ0KDApICA9ICAwXHJcbiAgICogIGNicnQoLTApID0gLTBcclxuICAgKiAgY2JydCgxKSAgPSAgMVxyXG4gICAqICBjYnJ0KC0xKSA9IC0xXHJcbiAgICogIGNicnQoTikgID0gIE5cclxuICAgKiAgY2JydCgtSSkgPSAtSVxyXG4gICAqICBjYnJ0KEkpICA9ICBJXHJcbiAgICpcclxuICAgKiBNYXRoLmNicnQoeCkgPSAoeCA8IDAgPyAtTWF0aC5wb3coLXgsIDEvMykgOiBNYXRoLnBvdyh4LCAxLzMpKVxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5jdWJlUm9vdCA9IFAuY2JydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBlLCBtLCBuLCByLCByZXAsIHMsIHNkLCB0LCB0MywgdDNwbHVzeCxcclxuICAgICAgeCA9IHRoaXMsXHJcbiAgICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICAgIGlmICgheC5pc0Zpbml0ZSgpIHx8IHguaXNaZXJvKCkpIHJldHVybiBuZXcgQ3Rvcih4KTtcclxuICAgIGV4dGVybmFsID0gZmFsc2U7XHJcblxyXG4gICAgLy8gSW5pdGlhbCBlc3RpbWF0ZS5cclxuICAgIHMgPSB4LnMgKiBNYXRoLnBvdyh4LnMgKiB4LCAxIC8gMyk7XHJcblxyXG4gICAgIC8vIE1hdGguY2JydCB1bmRlcmZsb3cvb3ZlcmZsb3c/XHJcbiAgICAgLy8gUGFzcyB4IHRvIE1hdGgucG93IGFzIGludGVnZXIsIHRoZW4gYWRqdXN0IHRoZSBleHBvbmVudCBvZiB0aGUgcmVzdWx0LlxyXG4gICAgaWYgKCFzIHx8IE1hdGguYWJzKHMpID09IDEgLyAwKSB7XHJcbiAgICAgIG4gPSBkaWdpdHNUb1N0cmluZyh4LmQpO1xyXG4gICAgICBlID0geC5lO1xyXG5cclxuICAgICAgLy8gQWRqdXN0IG4gZXhwb25lbnQgc28gaXQgaXMgYSBtdWx0aXBsZSBvZiAzIGF3YXkgZnJvbSB4IGV4cG9uZW50LlxyXG4gICAgICBpZiAocyA9IChlIC0gbi5sZW5ndGggKyAxKSAlIDMpIG4gKz0gKHMgPT0gMSB8fCBzID09IC0yID8gJzAnIDogJzAwJyk7XHJcbiAgICAgIHMgPSBNYXRoLnBvdyhuLCAxIC8gMyk7XHJcblxyXG4gICAgICAvLyBSYXJlbHksIGUgbWF5IGJlIG9uZSBsZXNzIHRoYW4gdGhlIHJlc3VsdCBleHBvbmVudCB2YWx1ZS5cclxuICAgICAgZSA9IG1hdGhmbG9vcigoZSArIDEpIC8gMykgLSAoZSAlIDMgPT0gKGUgPCAwID8gLTEgOiAyKSk7XHJcblxyXG4gICAgICBpZiAocyA9PSAxIC8gMCkge1xyXG4gICAgICAgIG4gPSAnNWUnICsgZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBuID0gcy50b0V4cG9uZW50aWFsKCk7XHJcbiAgICAgICAgbiA9IG4uc2xpY2UoMCwgbi5pbmRleE9mKCdlJykgKyAxKSArIGU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHIgPSBuZXcgQ3RvcihuKTtcclxuICAgICAgci5zID0geC5zO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgciA9IG5ldyBDdG9yKHMudG9TdHJpbmcoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgc2QgPSAoZSA9IEN0b3IucHJlY2lzaW9uKSArIDM7XHJcblxyXG4gICAgLy8gSGFsbGV5J3MgbWV0aG9kLlxyXG4gICAgLy8gVE9ETz8gQ29tcGFyZSBOZXd0b24ncyBtZXRob2QuXHJcbiAgICBmb3IgKDs7KSB7XHJcbiAgICAgIHQgPSByO1xyXG4gICAgICB0MyA9IHQudGltZXModCkudGltZXModCk7XHJcbiAgICAgIHQzcGx1c3ggPSB0My5wbHVzKHgpO1xyXG4gICAgICByID0gZGl2aWRlKHQzcGx1c3gucGx1cyh4KS50aW1lcyh0KSwgdDNwbHVzeC5wbHVzKHQzKSwgc2QgKyAyLCAxKTtcclxuXHJcbiAgICAgIC8vIFRPRE8/IFJlcGxhY2Ugd2l0aCBmb3ItbG9vcCBhbmQgY2hlY2tSb3VuZGluZ0RpZ2l0cy5cclxuICAgICAgaWYgKGRpZ2l0c1RvU3RyaW5nKHQuZCkuc2xpY2UoMCwgc2QpID09PSAobiA9IGRpZ2l0c1RvU3RyaW5nKHIuZCkpLnNsaWNlKDAsIHNkKSkge1xyXG4gICAgICAgIG4gPSBuLnNsaWNlKHNkIC0gMywgc2QgKyAxKTtcclxuXHJcbiAgICAgICAgLy8gVGhlIDR0aCByb3VuZGluZyBkaWdpdCBtYXkgYmUgaW4gZXJyb3IgYnkgLTEgc28gaWYgdGhlIDQgcm91bmRpbmcgZGlnaXRzIGFyZSA5OTk5IG9yIDQ5OTlcclxuICAgICAgICAvLyAsIGkuZS4gYXBwcm9hY2hpbmcgYSByb3VuZGluZyBib3VuZGFyeSwgY29udGludWUgdGhlIGl0ZXJhdGlvbi5cclxuICAgICAgICBpZiAobiA9PSAnOTk5OScgfHwgIXJlcCAmJiBuID09ICc0OTk5Jykge1xyXG5cclxuICAgICAgICAgIC8vIE9uIHRoZSBmaXJzdCBpdGVyYXRpb24gb25seSwgY2hlY2sgdG8gc2VlIGlmIHJvdW5kaW5nIHVwIGdpdmVzIHRoZSBleGFjdCByZXN1bHQgYXMgdGhlXHJcbiAgICAgICAgICAvLyBuaW5lcyBtYXkgaW5maW5pdGVseSByZXBlYXQuXHJcbiAgICAgICAgICBpZiAoIXJlcCkge1xyXG4gICAgICAgICAgICBmaW5hbGlzZSh0LCBlICsgMSwgMCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodC50aW1lcyh0KS50aW1lcyh0KS5lcSh4KSkge1xyXG4gICAgICAgICAgICAgIHIgPSB0O1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgc2QgKz0gNDtcclxuICAgICAgICAgIHJlcCA9IDE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAvLyBJZiB0aGUgcm91bmRpbmcgZGlnaXRzIGFyZSBudWxsLCAwezAsNH0gb3IgNTB7MCwzfSwgY2hlY2sgZm9yIGFuIGV4YWN0IHJlc3VsdC5cclxuICAgICAgICAgIC8vIElmIG5vdCwgdGhlbiB0aGVyZSBhcmUgZnVydGhlciBkaWdpdHMgYW5kIG0gd2lsbCBiZSB0cnV0aHkuXHJcbiAgICAgICAgICBpZiAoIStuIHx8ICErbi5zbGljZSgxKSAmJiBuLmNoYXJBdCgwKSA9PSAnNScpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFRydW5jYXRlIHRvIHRoZSBmaXJzdCByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICAgICAgZmluYWxpc2UociwgZSArIDEsIDEpO1xyXG4gICAgICAgICAgICBtID0gIXIudGltZXMocikudGltZXMocikuZXEoeCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZXh0ZXJuYWwgPSB0cnVlO1xyXG5cclxuICAgIHJldHVybiBmaW5hbGlzZShyLCBlLCBDdG9yLnJvdW5kaW5nLCBtKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBvZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsLlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5kZWNpbWFsUGxhY2VzID0gUC5kcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB3LFxyXG4gICAgICBkID0gdGhpcy5kLFxyXG4gICAgICBuID0gTmFOO1xyXG5cclxuICAgIGlmIChkKSB7XHJcbiAgICAgIHcgPSBkLmxlbmd0aCAtIDE7XHJcbiAgICAgIG4gPSAodyAtIG1hdGhmbG9vcih0aGlzLmUgLyBMT0dfQkFTRSkpICogTE9HX0JBU0U7XHJcblxyXG4gICAgICAvLyBTdWJ0cmFjdCB0aGUgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zIG9mIHRoZSBsYXN0IHdvcmQuXHJcbiAgICAgIHcgPSBkW3ddO1xyXG4gICAgICBpZiAodykgZm9yICg7IHcgJSAxMCA9PSAwOyB3IC89IDEwKSBuLS07XHJcbiAgICAgIGlmIChuIDwgMCkgbiA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG47XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogIG4gLyAwID0gSVxyXG4gICAqICBuIC8gTiA9IE5cclxuICAgKiAgbiAvIEkgPSAwXHJcbiAgICogIDAgLyBuID0gMFxyXG4gICAqICAwIC8gMCA9IE5cclxuICAgKiAgMCAvIE4gPSBOXHJcbiAgICogIDAgLyBJID0gMFxyXG4gICAqICBOIC8gbiA9IE5cclxuICAgKiAgTiAvIDAgPSBOXHJcbiAgICogIE4gLyBOID0gTlxyXG4gICAqICBOIC8gSSA9IE5cclxuICAgKiAgSSAvIG4gPSBJXHJcbiAgICogIEkgLyAwID0gSVxyXG4gICAqICBJIC8gTiA9IE5cclxuICAgKiAgSSAvIEkgPSBOXHJcbiAgICpcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGRpdmlkZWQgYnkgYHlgLCByb3VuZGVkIHRvXHJcbiAgICogYHByZWNpc2lvbmAgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAuZGl2aWRlZEJ5ID0gUC5kaXYgPSBmdW5jdGlvbiAoeSkge1xyXG4gICAgcmV0dXJuIGRpdmlkZSh0aGlzLCBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih5KSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGludGVnZXIgcGFydCBvZiBkaXZpZGluZyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsXHJcbiAgICogYnkgdGhlIHZhbHVlIG9mIGB5YCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5kaXZpZGVkVG9JbnRlZ2VyQnkgPSBQLmRpdlRvSW50ID0gZnVuY3Rpb24gKHkpIHtcclxuICAgIHZhciB4ID0gdGhpcyxcclxuICAgICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcbiAgICByZXR1cm4gZmluYWxpc2UoZGl2aWRlKHgsIG5ldyBDdG9yKHkpLCAwLCAxLCAxKSwgQ3Rvci5wcmVjaXNpb24sIEN0b3Iucm91bmRpbmcpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaXMgZXF1YWwgdG8gdGhlIHZhbHVlIG9mIGB5YCwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAuZXF1YWxzID0gUC5lcSA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5jbXAoeSkgPT09IDA7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCByb3VuZGVkIHRvIGEgd2hvbGUgbnVtYmVyIGluIHRoZVxyXG4gICAqIGRpcmVjdGlvbiBvZiBuZWdhdGl2ZSBJbmZpbml0eS5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAuZmxvb3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gZmluYWxpc2UobmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyksIHRoaXMuZSArIDEsIDMpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaXMgZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZSBvZiBgeWAsIG90aGVyd2lzZSByZXR1cm5cclxuICAgKiBmYWxzZS5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAuZ3JlYXRlclRoYW4gPSBQLmd0ID0gZnVuY3Rpb24gKHkpIHtcclxuICAgIHJldHVybiB0aGlzLmNtcCh5KSA+IDA7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHZhbHVlIG9mIGB5YCxcclxuICAgKiBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5ncmVhdGVyVGhhbk9yRXF1YWxUbyA9IFAuZ3RlID0gZnVuY3Rpb24gKHkpIHtcclxuICAgIHZhciBrID0gdGhpcy5jbXAoeSk7XHJcbiAgICByZXR1cm4gayA9PSAxIHx8IGsgPT09IDA7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGh5cGVyYm9saWMgY29zaW5lIG9mIHRoZSB2YWx1ZSBpbiByYWRpYW5zIG9mIHRoaXNcclxuICAgKiBEZWNpbWFsLlxyXG4gICAqXHJcbiAgICogRG9tYWluOiBbLUluZmluaXR5LCBJbmZpbml0eV1cclxuICAgKiBSYW5nZTogWzEsIEluZmluaXR5XVxyXG4gICAqXHJcbiAgICogY29zaCh4KSA9IDEgKyB4XjIvMiEgKyB4XjQvNCEgKyB4XjYvNiEgKyAuLi5cclxuICAgKlxyXG4gICAqIGNvc2goMCkgICAgICAgICA9IDFcclxuICAgKiBjb3NoKC0wKSAgICAgICAgPSAxXHJcbiAgICogY29zaChJbmZpbml0eSkgID0gSW5maW5pdHlcclxuICAgKiBjb3NoKC1JbmZpbml0eSkgPSBJbmZpbml0eVxyXG4gICAqIGNvc2goTmFOKSAgICAgICA9IE5hTlxyXG4gICAqXHJcbiAgICogIHggICAgICAgIHRpbWUgdGFrZW4gKG1zKSAgIHJlc3VsdFxyXG4gICAqIDEwMDAgICAgICA5ICAgICAgICAgICAgICAgICA5Ljg1MDM1NTU3MDA4NTIzNDk2OTRlKzQzM1xyXG4gICAqIDEwMDAwICAgICAyNSAgICAgICAgICAgICAgICA0LjQwMzQwOTExMjgzMTQ2MDc5MzZlKzQzNDJcclxuICAgKiAxMDAwMDAgICAgMTcxICAgICAgICAgICAgICAgMS40MDMzMzE2ODAyMTMwNjE1ODk3ZSs0MzQyOVxyXG4gICAqIDEwMDAwMDAgICAzODE3ICAgICAgICAgICAgICAxLjUxNjYwNzY5ODQwMTA0Mzc3MjVlKzQzNDI5NFxyXG4gICAqIDEwMDAwMDAwICBhYmFuZG9uZWQgYWZ0ZXIgMiBtaW51dGUgd2FpdFxyXG4gICAqXHJcbiAgICogVE9ETz8gQ29tcGFyZSBwZXJmb3JtYW5jZSBvZiBjb3NoKHgpID0gMC41ICogKGV4cCh4KSArIGV4cCgteCkpXHJcbiAgICpcclxuICAgKi9cclxuICBQLmh5cGVyYm9saWNDb3NpbmUgPSBQLmNvc2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgaywgbiwgcHIsIHJtLCBsZW4sXHJcbiAgICAgIHggPSB0aGlzLFxyXG4gICAgICBDdG9yID0geC5jb25zdHJ1Y3RvcixcclxuICAgICAgb25lID0gbmV3IEN0b3IoMSk7XHJcblxyXG4gICAgaWYgKCF4LmlzRmluaXRlKCkpIHJldHVybiBuZXcgQ3Rvcih4LnMgPyAxIC8gMCA6IE5hTik7XHJcbiAgICBpZiAoeC5pc1plcm8oKSkgcmV0dXJuIG9uZTtcclxuXHJcbiAgICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG4gICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gICAgQ3Rvci5wcmVjaXNpb24gPSBwciArIE1hdGgubWF4KHguZSwgeC5zZCgpKSArIDQ7XHJcbiAgICBDdG9yLnJvdW5kaW5nID0gMTtcclxuICAgIGxlbiA9IHguZC5sZW5ndGg7XHJcblxyXG4gICAgLy8gQXJndW1lbnQgcmVkdWN0aW9uOiBjb3MoNHgpID0gMSAtIDhjb3NeMih4KSArIDhjb3NeNCh4KSArIDFcclxuICAgIC8vIGkuZS4gY29zKHgpID0gMSAtIGNvc14yKHgvNCkoOCAtIDhjb3NeMih4LzQpKVxyXG5cclxuICAgIC8vIEVzdGltYXRlIHRoZSBvcHRpbXVtIG51bWJlciBvZiB0aW1lcyB0byB1c2UgdGhlIGFyZ3VtZW50IHJlZHVjdGlvbi5cclxuICAgIC8vIFRPRE8/IEVzdGltYXRpb24gcmV1c2VkIGZyb20gY29zaW5lKCkgYW5kIG1heSBub3QgYmUgb3B0aW1hbCBoZXJlLlxyXG4gICAgaWYgKGxlbiA8IDMyKSB7XHJcbiAgICAgIGsgPSBNYXRoLmNlaWwobGVuIC8gMyk7XHJcbiAgICAgIG4gPSBNYXRoLnBvdyg0LCAtaykudG9TdHJpbmcoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGsgPSAxNjtcclxuICAgICAgbiA9ICcyLjMyODMwNjQzNjUzODY5NjI4OTA2MjVlLTEwJztcclxuICAgIH1cclxuXHJcbiAgICB4ID0gdGF5bG9yU2VyaWVzKEN0b3IsIDEsIHgudGltZXMobiksIG5ldyBDdG9yKDEpLCB0cnVlKTtcclxuXHJcbiAgICAvLyBSZXZlcnNlIGFyZ3VtZW50IHJlZHVjdGlvblxyXG4gICAgdmFyIGNvc2gyX3gsXHJcbiAgICAgIGkgPSBrLFxyXG4gICAgICBkOCA9IG5ldyBDdG9yKDgpO1xyXG4gICAgZm9yICg7IGktLTspIHtcclxuICAgICAgY29zaDJfeCA9IHgudGltZXMoeCk7XHJcbiAgICAgIHggPSBvbmUubWludXMoY29zaDJfeC50aW1lcyhkOC5taW51cyhjb3NoMl94LnRpbWVzKGQ4KSkpKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmluYWxpc2UoeCwgQ3Rvci5wcmVjaXNpb24gPSBwciwgQ3Rvci5yb3VuZGluZyA9IHJtLCB0cnVlKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgaHlwZXJib2xpYyBzaW5lIG9mIHRoZSB2YWx1ZSBpbiByYWRpYW5zIG9mIHRoaXNcclxuICAgKiBEZWNpbWFsLlxyXG4gICAqXHJcbiAgICogRG9tYWluOiBbLUluZmluaXR5LCBJbmZpbml0eV1cclxuICAgKiBSYW5nZTogWy1JbmZpbml0eSwgSW5maW5pdHldXHJcbiAgICpcclxuICAgKiBzaW5oKHgpID0geCArIHheMy8zISArIHheNS81ISArIHheNy83ISArIC4uLlxyXG4gICAqXHJcbiAgICogc2luaCgwKSAgICAgICAgID0gMFxyXG4gICAqIHNpbmgoLTApICAgICAgICA9IC0wXHJcbiAgICogc2luaChJbmZpbml0eSkgID0gSW5maW5pdHlcclxuICAgKiBzaW5oKC1JbmZpbml0eSkgPSAtSW5maW5pdHlcclxuICAgKiBzaW5oKE5hTikgICAgICAgPSBOYU5cclxuICAgKlxyXG4gICAqIHggICAgICAgIHRpbWUgdGFrZW4gKG1zKVxyXG4gICAqIDEwICAgICAgIDIgbXNcclxuICAgKiAxMDAgICAgICA1IG1zXHJcbiAgICogMTAwMCAgICAgMTQgbXNcclxuICAgKiAxMDAwMCAgICA4MiBtc1xyXG4gICAqIDEwMDAwMCAgIDg4NiBtcyAgICAgICAgICAgIDEuNDAzMzMxNjgwMjEzMDYxNTg5N2UrNDM0MjlcclxuICAgKiAyMDAwMDAgICAyNjEzIG1zXHJcbiAgICogMzAwMDAwICAgNTQwNyBtc1xyXG4gICAqIDQwMDAwMCAgIDg4MjQgbXNcclxuICAgKiA1MDAwMDAgICAxMzAyNiBtcyAgICAgICAgICA4LjcwODA2NDM2MTI3MTgwODQxMjllKzIxNzE0NlxyXG4gICAqIDEwMDAwMDAgIDQ4NTQzIG1zXHJcbiAgICpcclxuICAgKiBUT0RPPyBDb21wYXJlIHBlcmZvcm1hbmNlIG9mIHNpbmgoeCkgPSAwLjUgKiAoZXhwKHgpIC0gZXhwKC14KSlcclxuICAgKlxyXG4gICAqL1xyXG4gIFAuaHlwZXJib2xpY1NpbmUgPSBQLnNpbmggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgaywgcHIsIHJtLCBsZW4sXHJcbiAgICAgIHggPSB0aGlzLFxyXG4gICAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgICBpZiAoIXguaXNGaW5pdGUoKSB8fCB4LmlzWmVybygpKSByZXR1cm4gbmV3IEN0b3IoeCk7XHJcblxyXG4gICAgcHIgPSBDdG9yLnByZWNpc2lvbjtcclxuICAgIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICAgIEN0b3IucHJlY2lzaW9uID0gcHIgKyBNYXRoLm1heCh4LmUsIHguc2QoKSkgKyA0O1xyXG4gICAgQ3Rvci5yb3VuZGluZyA9IDE7XHJcbiAgICBsZW4gPSB4LmQubGVuZ3RoO1xyXG5cclxuICAgIGlmIChsZW4gPCAzKSB7XHJcbiAgICAgIHggPSB0YXlsb3JTZXJpZXMoQ3RvciwgMiwgeCwgeCwgdHJ1ZSk7XHJcbiAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgLy8gQWx0ZXJuYXRpdmUgYXJndW1lbnQgcmVkdWN0aW9uOiBzaW5oKDN4KSA9IHNpbmgoeCkoMyArIDRzaW5oXjIoeCkpXHJcbiAgICAgIC8vIGkuZS4gc2luaCh4KSA9IHNpbmgoeC8zKSgzICsgNHNpbmheMih4LzMpKVxyXG4gICAgICAvLyAzIG11bHRpcGxpY2F0aW9ucyBhbmQgMSBhZGRpdGlvblxyXG5cclxuICAgICAgLy8gQXJndW1lbnQgcmVkdWN0aW9uOiBzaW5oKDV4KSA9IHNpbmgoeCkoNSArIHNpbmheMih4KSgyMCArIDE2c2luaF4yKHgpKSlcclxuICAgICAgLy8gaS5lLiBzaW5oKHgpID0gc2luaCh4LzUpKDUgKyBzaW5oXjIoeC81KSgyMCArIDE2c2luaF4yKHgvNSkpKVxyXG4gICAgICAvLyA0IG11bHRpcGxpY2F0aW9ucyBhbmQgMiBhZGRpdGlvbnNcclxuXHJcbiAgICAgIC8vIEVzdGltYXRlIHRoZSBvcHRpbXVtIG51bWJlciBvZiB0aW1lcyB0byB1c2UgdGhlIGFyZ3VtZW50IHJlZHVjdGlvbi5cclxuICAgICAgayA9IDEuNCAqIE1hdGguc3FydChsZW4pO1xyXG4gICAgICBrID0gayA+IDE2ID8gMTYgOiBrIHwgMDtcclxuXHJcbiAgICAgIHggPSB4LnRpbWVzKE1hdGgucG93KDUsIC1rKSk7XHJcblxyXG4gICAgICB4ID0gdGF5bG9yU2VyaWVzKEN0b3IsIDIsIHgsIHgsIHRydWUpO1xyXG5cclxuICAgICAgLy8gUmV2ZXJzZSBhcmd1bWVudCByZWR1Y3Rpb25cclxuICAgICAgdmFyIHNpbmgyX3gsXHJcbiAgICAgICAgZDUgPSBuZXcgQ3Rvcig1KSxcclxuICAgICAgICBkMTYgPSBuZXcgQ3RvcigxNiksXHJcbiAgICAgICAgZDIwID0gbmV3IEN0b3IoMjApO1xyXG4gICAgICBmb3IgKDsgay0tOykge1xyXG4gICAgICAgIHNpbmgyX3ggPSB4LnRpbWVzKHgpO1xyXG4gICAgICAgIHggPSB4LnRpbWVzKGQ1LnBsdXMoc2luaDJfeC50aW1lcyhkMTYudGltZXMoc2luaDJfeCkucGx1cyhkMjApKSkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcclxuICAgIEN0b3Iucm91bmRpbmcgPSBybTtcclxuXHJcbiAgICByZXR1cm4gZmluYWxpc2UoeCwgcHIsIHJtLCB0cnVlKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgaHlwZXJib2xpYyB0YW5nZW50IG9mIHRoZSB2YWx1ZSBpbiByYWRpYW5zIG9mIHRoaXNcclxuICAgKiBEZWNpbWFsLlxyXG4gICAqXHJcbiAgICogRG9tYWluOiBbLUluZmluaXR5LCBJbmZpbml0eV1cclxuICAgKiBSYW5nZTogWy0xLCAxXVxyXG4gICAqXHJcbiAgICogdGFuaCh4KSA9IHNpbmgoeCkgLyBjb3NoKHgpXHJcbiAgICpcclxuICAgKiB0YW5oKDApICAgICAgICAgPSAwXHJcbiAgICogdGFuaCgtMCkgICAgICAgID0gLTBcclxuICAgKiB0YW5oKEluZmluaXR5KSAgPSAxXHJcbiAgICogdGFuaCgtSW5maW5pdHkpID0gLTFcclxuICAgKiB0YW5oKE5hTikgICAgICAgPSBOYU5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAuaHlwZXJib2xpY1RhbmdlbnQgPSBQLnRhbmggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgcHIsIHJtLFxyXG4gICAgICB4ID0gdGhpcyxcclxuICAgICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gICAgaWYgKCF4LmlzRmluaXRlKCkpIHJldHVybiBuZXcgQ3Rvcih4LnMpO1xyXG4gICAgaWYgKHguaXNaZXJvKCkpIHJldHVybiBuZXcgQ3Rvcih4KTtcclxuXHJcbiAgICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG4gICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gICAgQ3Rvci5wcmVjaXNpb24gPSBwciArIDc7XHJcbiAgICBDdG9yLnJvdW5kaW5nID0gMTtcclxuXHJcbiAgICByZXR1cm4gZGl2aWRlKHguc2luaCgpLCB4LmNvc2goKSwgQ3Rvci5wcmVjaXNpb24gPSBwciwgQ3Rvci5yb3VuZGluZyA9IHJtKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgYXJjY29zaW5lIChpbnZlcnNlIGNvc2luZSkgaW4gcmFkaWFucyBvZiB0aGUgdmFsdWUgb2ZcclxuICAgKiB0aGlzIERlY2ltYWwuXHJcbiAgICpcclxuICAgKiBEb21haW46IFstMSwgMV1cclxuICAgKiBSYW5nZTogWzAsIHBpXVxyXG4gICAqXHJcbiAgICogYWNvcyh4KSA9IHBpLzIgLSBhc2luKHgpXHJcbiAgICpcclxuICAgKiBhY29zKDApICAgICAgID0gcGkvMlxyXG4gICAqIGFjb3MoLTApICAgICAgPSBwaS8yXHJcbiAgICogYWNvcygxKSAgICAgICA9IDBcclxuICAgKiBhY29zKC0xKSAgICAgID0gcGlcclxuICAgKiBhY29zKDEvMikgICAgID0gcGkvM1xyXG4gICAqIGFjb3MoLTEvMikgICAgPSAyKnBpLzNcclxuICAgKiBhY29zKHx4fCA+IDEpID0gTmFOXHJcbiAgICogYWNvcyhOYU4pICAgICA9IE5hTlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5pbnZlcnNlQ29zaW5lID0gUC5hY29zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGhhbGZQaSxcclxuICAgICAgeCA9IHRoaXMsXHJcbiAgICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yLFxyXG4gICAgICBrID0geC5hYnMoKS5jbXAoMSksXHJcbiAgICAgIHByID0gQ3Rvci5wcmVjaXNpb24sXHJcbiAgICAgIHJtID0gQ3Rvci5yb3VuZGluZztcclxuXHJcbiAgICBpZiAoayAhPT0gLTEpIHtcclxuICAgICAgcmV0dXJuIGsgPT09IDBcclxuICAgICAgICAvLyB8eHwgaXMgMVxyXG4gICAgICAgID8geC5pc05lZygpID8gZ2V0UGkoQ3RvciwgcHIsIHJtKSA6IG5ldyBDdG9yKDApXHJcbiAgICAgICAgLy8gfHh8ID4gMSBvciB4IGlzIE5hTlxyXG4gICAgICAgIDogbmV3IEN0b3IoTmFOKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoeC5pc1plcm8oKSkgcmV0dXJuIGdldFBpKEN0b3IsIHByICsgNCwgcm0pLnRpbWVzKDAuNSk7XHJcblxyXG4gICAgLy8gVE9ETz8gU3BlY2lhbCBjYXNlIGFjb3MoMC41KSA9IHBpLzMgYW5kIGFjb3MoLTAuNSkgPSAyKnBpLzNcclxuXHJcbiAgICBDdG9yLnByZWNpc2lvbiA9IHByICsgNjtcclxuICAgIEN0b3Iucm91bmRpbmcgPSAxO1xyXG5cclxuICAgIHggPSB4LmFzaW4oKTtcclxuICAgIGhhbGZQaSA9IGdldFBpKEN0b3IsIHByICsgNCwgcm0pLnRpbWVzKDAuNSk7XHJcblxyXG4gICAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcclxuICAgIEN0b3Iucm91bmRpbmcgPSBybTtcclxuXHJcbiAgICByZXR1cm4gaGFsZlBpLm1pbnVzKHgpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBpbnZlcnNlIG9mIHRoZSBoeXBlcmJvbGljIGNvc2luZSBpbiByYWRpYW5zIG9mIHRoZVxyXG4gICAqIHZhbHVlIG9mIHRoaXMgRGVjaW1hbC5cclxuICAgKlxyXG4gICAqIERvbWFpbjogWzEsIEluZmluaXR5XVxyXG4gICAqIFJhbmdlOiBbMCwgSW5maW5pdHldXHJcbiAgICpcclxuICAgKiBhY29zaCh4KSA9IGxuKHggKyBzcXJ0KHheMiAtIDEpKVxyXG4gICAqXHJcbiAgICogYWNvc2goeCA8IDEpICAgICA9IE5hTlxyXG4gICAqIGFjb3NoKE5hTikgICAgICAgPSBOYU5cclxuICAgKiBhY29zaChJbmZpbml0eSkgID0gSW5maW5pdHlcclxuICAgKiBhY29zaCgtSW5maW5pdHkpID0gTmFOXHJcbiAgICogYWNvc2goMCkgICAgICAgICA9IE5hTlxyXG4gICAqIGFjb3NoKC0wKSAgICAgICAgPSBOYU5cclxuICAgKiBhY29zaCgxKSAgICAgICAgID0gMFxyXG4gICAqIGFjb3NoKC0xKSAgICAgICAgPSBOYU5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAuaW52ZXJzZUh5cGVyYm9saWNDb3NpbmUgPSBQLmFjb3NoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHByLCBybSxcclxuICAgICAgeCA9IHRoaXMsXHJcbiAgICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICAgIGlmICh4Lmx0ZSgxKSkgcmV0dXJuIG5ldyBDdG9yKHguZXEoMSkgPyAwIDogTmFOKTtcclxuICAgIGlmICgheC5pc0Zpbml0ZSgpKSByZXR1cm4gbmV3IEN0b3IoeCk7XHJcblxyXG4gICAgcHIgPSBDdG9yLnByZWNpc2lvbjtcclxuICAgIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICAgIEN0b3IucHJlY2lzaW9uID0gcHIgKyBNYXRoLm1heChNYXRoLmFicyh4LmUpLCB4LnNkKCkpICsgNDtcclxuICAgIEN0b3Iucm91bmRpbmcgPSAxO1xyXG4gICAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuXHJcbiAgICB4ID0geC50aW1lcyh4KS5taW51cygxKS5zcXJ0KCkucGx1cyh4KTtcclxuXHJcbiAgICBleHRlcm5hbCA9IHRydWU7XHJcbiAgICBDdG9yLnByZWNpc2lvbiA9IHByO1xyXG4gICAgQ3Rvci5yb3VuZGluZyA9IHJtO1xyXG5cclxuICAgIHJldHVybiB4LmxuKCk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGludmVyc2Ugb2YgdGhlIGh5cGVyYm9saWMgc2luZSBpbiByYWRpYW5zIG9mIHRoZSB2YWx1ZVxyXG4gICAqIG9mIHRoaXMgRGVjaW1hbC5cclxuICAgKlxyXG4gICAqIERvbWFpbjogWy1JbmZpbml0eSwgSW5maW5pdHldXHJcbiAgICogUmFuZ2U6IFstSW5maW5pdHksIEluZmluaXR5XVxyXG4gICAqXHJcbiAgICogYXNpbmgoeCkgPSBsbih4ICsgc3FydCh4XjIgKyAxKSlcclxuICAgKlxyXG4gICAqIGFzaW5oKE5hTikgICAgICAgPSBOYU5cclxuICAgKiBhc2luaChJbmZpbml0eSkgID0gSW5maW5pdHlcclxuICAgKiBhc2luaCgtSW5maW5pdHkpID0gLUluZmluaXR5XHJcbiAgICogYXNpbmgoMCkgICAgICAgICA9IDBcclxuICAgKiBhc2luaCgtMCkgICAgICAgID0gLTBcclxuICAgKlxyXG4gICAqL1xyXG4gIFAuaW52ZXJzZUh5cGVyYm9saWNTaW5lID0gUC5hc2luaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBwciwgcm0sXHJcbiAgICAgIHggPSB0aGlzLFxyXG4gICAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgICBpZiAoIXguaXNGaW5pdGUoKSB8fCB4LmlzWmVybygpKSByZXR1cm4gbmV3IEN0b3IoeCk7XHJcblxyXG4gICAgcHIgPSBDdG9yLnByZWNpc2lvbjtcclxuICAgIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICAgIEN0b3IucHJlY2lzaW9uID0gcHIgKyAyICogTWF0aC5tYXgoTWF0aC5hYnMoeC5lKSwgeC5zZCgpKSArIDY7XHJcbiAgICBDdG9yLnJvdW5kaW5nID0gMTtcclxuICAgIGV4dGVybmFsID0gZmFsc2U7XHJcblxyXG4gICAgeCA9IHgudGltZXMoeCkucGx1cygxKS5zcXJ0KCkucGx1cyh4KTtcclxuXHJcbiAgICBleHRlcm5hbCA9IHRydWU7XHJcbiAgICBDdG9yLnByZWNpc2lvbiA9IHByO1xyXG4gICAgQ3Rvci5yb3VuZGluZyA9IHJtO1xyXG5cclxuICAgIHJldHVybiB4LmxuKCk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGludmVyc2Ugb2YgdGhlIGh5cGVyYm9saWMgdGFuZ2VudCBpbiByYWRpYW5zIG9mIHRoZVxyXG4gICAqIHZhbHVlIG9mIHRoaXMgRGVjaW1hbC5cclxuICAgKlxyXG4gICAqIERvbWFpbjogWy0xLCAxXVxyXG4gICAqIFJhbmdlOiBbLUluZmluaXR5LCBJbmZpbml0eV1cclxuICAgKlxyXG4gICAqIGF0YW5oKHgpID0gMC41ICogbG4oKDEgKyB4KSAvICgxIC0geCkpXHJcbiAgICpcclxuICAgKiBhdGFuaCh8eHwgPiAxKSAgID0gTmFOXHJcbiAgICogYXRhbmgoTmFOKSAgICAgICA9IE5hTlxyXG4gICAqIGF0YW5oKEluZmluaXR5KSAgPSBOYU5cclxuICAgKiBhdGFuaCgtSW5maW5pdHkpID0gTmFOXHJcbiAgICogYXRhbmgoMCkgICAgICAgICA9IDBcclxuICAgKiBhdGFuaCgtMCkgICAgICAgID0gLTBcclxuICAgKiBhdGFuaCgxKSAgICAgICAgID0gSW5maW5pdHlcclxuICAgKiBhdGFuaCgtMSkgICAgICAgID0gLUluZmluaXR5XHJcbiAgICpcclxuICAgKi9cclxuICBQLmludmVyc2VIeXBlcmJvbGljVGFuZ2VudCA9IFAuYXRhbmggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgcHIsIHJtLCB3cHIsIHhzZCxcclxuICAgICAgeCA9IHRoaXMsXHJcbiAgICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICAgIGlmICgheC5pc0Zpbml0ZSgpKSByZXR1cm4gbmV3IEN0b3IoTmFOKTtcclxuICAgIGlmICh4LmUgPj0gMCkgcmV0dXJuIG5ldyBDdG9yKHguYWJzKCkuZXEoMSkgPyB4LnMgLyAwIDogeC5pc1plcm8oKSA/IHggOiBOYU4pO1xyXG5cclxuICAgIHByID0gQ3Rvci5wcmVjaXNpb247XHJcbiAgICBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgICB4c2QgPSB4LnNkKCk7XHJcblxyXG4gICAgaWYgKE1hdGgubWF4KHhzZCwgcHIpIDwgMiAqIC14LmUgLSAxKSByZXR1cm4gZmluYWxpc2UobmV3IEN0b3IoeCksIHByLCBybSwgdHJ1ZSk7XHJcblxyXG4gICAgQ3Rvci5wcmVjaXNpb24gPSB3cHIgPSB4c2QgLSB4LmU7XHJcblxyXG4gICAgeCA9IGRpdmlkZSh4LnBsdXMoMSksIG5ldyBDdG9yKDEpLm1pbnVzKHgpLCB3cHIgKyBwciwgMSk7XHJcblxyXG4gICAgQ3Rvci5wcmVjaXNpb24gPSBwciArIDQ7XHJcbiAgICBDdG9yLnJvdW5kaW5nID0gMTtcclxuXHJcbiAgICB4ID0geC5sbigpO1xyXG5cclxuICAgIEN0b3IucHJlY2lzaW9uID0gcHI7XHJcbiAgICBDdG9yLnJvdW5kaW5nID0gcm07XHJcblxyXG4gICAgcmV0dXJuIHgudGltZXMoMC41KTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgYXJjc2luZSAoaW52ZXJzZSBzaW5lKSBpbiByYWRpYW5zIG9mIHRoZSB2YWx1ZSBvZiB0aGlzXHJcbiAgICogRGVjaW1hbC5cclxuICAgKlxyXG4gICAqIERvbWFpbjogWy1JbmZpbml0eSwgSW5maW5pdHldXHJcbiAgICogUmFuZ2U6IFstcGkvMiwgcGkvMl1cclxuICAgKlxyXG4gICAqIGFzaW4oeCkgPSAyKmF0YW4oeC8oMSArIHNxcnQoMSAtIHheMikpKVxyXG4gICAqXHJcbiAgICogYXNpbigwKSAgICAgICA9IDBcclxuICAgKiBhc2luKC0wKSAgICAgID0gLTBcclxuICAgKiBhc2luKDEvMikgICAgID0gcGkvNlxyXG4gICAqIGFzaW4oLTEvMikgICAgPSAtcGkvNlxyXG4gICAqIGFzaW4oMSkgICAgICAgPSBwaS8yXHJcbiAgICogYXNpbigtMSkgICAgICA9IC1waS8yXHJcbiAgICogYXNpbih8eHwgPiAxKSA9IE5hTlxyXG4gICAqIGFzaW4oTmFOKSAgICAgPSBOYU5cclxuICAgKlxyXG4gICAqIFRPRE8/IENvbXBhcmUgcGVyZm9ybWFuY2Ugb2YgVGF5bG9yIHNlcmllcy5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAuaW52ZXJzZVNpbmUgPSBQLmFzaW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgaGFsZlBpLCBrLFxyXG4gICAgICBwciwgcm0sXHJcbiAgICAgIHggPSB0aGlzLFxyXG4gICAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgICBpZiAoeC5pc1plcm8oKSkgcmV0dXJuIG5ldyBDdG9yKHgpO1xyXG5cclxuICAgIGsgPSB4LmFicygpLmNtcCgxKTtcclxuICAgIHByID0gQ3Rvci5wcmVjaXNpb247XHJcbiAgICBybSA9IEN0b3Iucm91bmRpbmc7XHJcblxyXG4gICAgaWYgKGsgIT09IC0xKSB7XHJcblxyXG4gICAgICAvLyB8eHwgaXMgMVxyXG4gICAgICBpZiAoayA9PT0gMCkge1xyXG4gICAgICAgIGhhbGZQaSA9IGdldFBpKEN0b3IsIHByICsgNCwgcm0pLnRpbWVzKDAuNSk7XHJcbiAgICAgICAgaGFsZlBpLnMgPSB4LnM7XHJcbiAgICAgICAgcmV0dXJuIGhhbGZQaTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gfHh8ID4gMSBvciB4IGlzIE5hTlxyXG4gICAgICByZXR1cm4gbmV3IEN0b3IoTmFOKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUT0RPPyBTcGVjaWFsIGNhc2UgYXNpbigxLzIpID0gcGkvNiBhbmQgYXNpbigtMS8yKSA9IC1waS82XHJcblxyXG4gICAgQ3Rvci5wcmVjaXNpb24gPSBwciArIDY7XHJcbiAgICBDdG9yLnJvdW5kaW5nID0gMTtcclxuXHJcbiAgICB4ID0geC5kaXYobmV3IEN0b3IoMSkubWludXMoeC50aW1lcyh4KSkuc3FydCgpLnBsdXMoMSkpLmF0YW4oKTtcclxuXHJcbiAgICBDdG9yLnByZWNpc2lvbiA9IHByO1xyXG4gICAgQ3Rvci5yb3VuZGluZyA9IHJtO1xyXG5cclxuICAgIHJldHVybiB4LnRpbWVzKDIpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBhcmN0YW5nZW50IChpbnZlcnNlIHRhbmdlbnQpIGluIHJhZGlhbnMgb2YgdGhlIHZhbHVlXHJcbiAgICogb2YgdGhpcyBEZWNpbWFsLlxyXG4gICAqXHJcbiAgICogRG9tYWluOiBbLUluZmluaXR5LCBJbmZpbml0eV1cclxuICAgKiBSYW5nZTogWy1waS8yLCBwaS8yXVxyXG4gICAqXHJcbiAgICogYXRhbih4KSA9IHggLSB4XjMvMyArIHheNS81IC0geF43LzcgKyAuLi5cclxuICAgKlxyXG4gICAqIGF0YW4oMCkgICAgICAgICA9IDBcclxuICAgKiBhdGFuKC0wKSAgICAgICAgPSAtMFxyXG4gICAqIGF0YW4oMSkgICAgICAgICA9IHBpLzRcclxuICAgKiBhdGFuKC0xKSAgICAgICAgPSAtcGkvNFxyXG4gICAqIGF0YW4oSW5maW5pdHkpICA9IHBpLzJcclxuICAgKiBhdGFuKC1JbmZpbml0eSkgPSAtcGkvMlxyXG4gICAqIGF0YW4oTmFOKSAgICAgICA9IE5hTlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5pbnZlcnNlVGFuZ2VudCA9IFAuYXRhbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBpLCBqLCBrLCBuLCBweCwgdCwgciwgd3ByLCB4MixcclxuICAgICAgeCA9IHRoaXMsXHJcbiAgICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yLFxyXG4gICAgICBwciA9IEN0b3IucHJlY2lzaW9uLFxyXG4gICAgICBybSA9IEN0b3Iucm91bmRpbmc7XHJcblxyXG4gICAgaWYgKCF4LmlzRmluaXRlKCkpIHtcclxuICAgICAgaWYgKCF4LnMpIHJldHVybiBuZXcgQ3RvcihOYU4pO1xyXG4gICAgICBpZiAocHIgKyA0IDw9IFBJX1BSRUNJU0lPTikge1xyXG4gICAgICAgIHIgPSBnZXRQaShDdG9yLCBwciArIDQsIHJtKS50aW1lcygwLjUpO1xyXG4gICAgICAgIHIucyA9IHgucztcclxuICAgICAgICByZXR1cm4gcjtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmICh4LmlzWmVybygpKSB7XHJcbiAgICAgIHJldHVybiBuZXcgQ3Rvcih4KTtcclxuICAgIH0gZWxzZSBpZiAoeC5hYnMoKS5lcSgxKSAmJiBwciArIDQgPD0gUElfUFJFQ0lTSU9OKSB7XHJcbiAgICAgIHIgPSBnZXRQaShDdG9yLCBwciArIDQsIHJtKS50aW1lcygwLjI1KTtcclxuICAgICAgci5zID0geC5zO1xyXG4gICAgICByZXR1cm4gcjtcclxuICAgIH1cclxuXHJcbiAgICBDdG9yLnByZWNpc2lvbiA9IHdwciA9IHByICsgMTA7XHJcbiAgICBDdG9yLnJvdW5kaW5nID0gMTtcclxuXHJcbiAgICAvLyBUT0RPPyBpZiAoeCA+PSAxICYmIHByIDw9IFBJX1BSRUNJU0lPTikgYXRhbih4KSA9IGhhbGZQaSAqIHgucyAtIGF0YW4oMSAvIHgpO1xyXG5cclxuICAgIC8vIEFyZ3VtZW50IHJlZHVjdGlvblxyXG4gICAgLy8gRW5zdXJlIHx4fCA8IDAuNDJcclxuICAgIC8vIGF0YW4oeCkgPSAyICogYXRhbih4IC8gKDEgKyBzcXJ0KDEgKyB4XjIpKSlcclxuXHJcbiAgICBrID0gTWF0aC5taW4oMjgsIHdwciAvIExPR19CQVNFICsgMiB8IDApO1xyXG5cclxuICAgIGZvciAoaSA9IGs7IGk7IC0taSkgeCA9IHguZGl2KHgudGltZXMoeCkucGx1cygxKS5zcXJ0KCkucGx1cygxKSk7XHJcblxyXG4gICAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuXHJcbiAgICBqID0gTWF0aC5jZWlsKHdwciAvIExPR19CQVNFKTtcclxuICAgIG4gPSAxO1xyXG4gICAgeDIgPSB4LnRpbWVzKHgpO1xyXG4gICAgciA9IG5ldyBDdG9yKHgpO1xyXG4gICAgcHggPSB4O1xyXG5cclxuICAgIC8vIGF0YW4oeCkgPSB4IC0geF4zLzMgKyB4XjUvNSAtIHheNy83ICsgLi4uXHJcbiAgICBmb3IgKDsgaSAhPT0gLTE7KSB7XHJcbiAgICAgIHB4ID0gcHgudGltZXMoeDIpO1xyXG4gICAgICB0ID0gci5taW51cyhweC5kaXYobiArPSAyKSk7XHJcblxyXG4gICAgICBweCA9IHB4LnRpbWVzKHgyKTtcclxuICAgICAgciA9IHQucGx1cyhweC5kaXYobiArPSAyKSk7XHJcblxyXG4gICAgICBpZiAoci5kW2pdICE9PSB2b2lkIDApIGZvciAoaSA9IGo7IHIuZFtpXSA9PT0gdC5kW2ldICYmIGktLTspO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChrKSByID0gci50aW1lcygyIDw8IChrIC0gMSkpO1xyXG5cclxuICAgIGV4dGVybmFsID0gdHJ1ZTtcclxuXHJcbiAgICByZXR1cm4gZmluYWxpc2UociwgQ3Rvci5wcmVjaXNpb24gPSBwciwgQ3Rvci5yb3VuZGluZyA9IHJtLCB0cnVlKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGlzIGEgZmluaXRlIG51bWJlciwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAuaXNGaW5pdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gISF0aGlzLmQ7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpcyBhbiBpbnRlZ2VyLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5pc0ludGVnZXIgPSBQLmlzSW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuICEhdGhpcy5kICYmIG1hdGhmbG9vcih0aGlzLmUgLyBMT0dfQkFTRSkgPiB0aGlzLmQubGVuZ3RoIC0gMjtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGlzIE5hTiwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAuaXNOYU4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gIXRoaXMucztcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGlzIG5lZ2F0aXZlLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5pc05lZ2F0aXZlID0gUC5pc05lZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLnMgPCAwO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaXMgcG9zaXRpdmUsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICpcclxuICAgKi9cclxuICBQLmlzUG9zaXRpdmUgPSBQLmlzUG9zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucyA+IDA7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpcyAwIG9yIC0wLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5pc1plcm8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gISF0aGlzLmQgJiYgdGhpcy5kWzBdID09PSAwO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaXMgbGVzcyB0aGFuIGB5YCwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAubGVzc1RoYW4gPSBQLmx0ID0gZnVuY3Rpb24gKHkpIHtcclxuICAgIHJldHVybiB0aGlzLmNtcCh5KSA8IDA7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYHlgLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5sZXNzVGhhbk9yRXF1YWxUbyA9IFAubHRlID0gZnVuY3Rpb24gKHkpIHtcclxuICAgIHJldHVybiB0aGlzLmNtcCh5KSA8IDE7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRoZSBsb2dhcml0aG0gb2YgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCB0byB0aGUgc3BlY2lmaWVkIGJhc2UsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmBcclxuICAgKiBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gICAqXHJcbiAgICogSWYgbm8gYmFzZSBpcyBzcGVjaWZpZWQsIHJldHVybiBsb2dbMTBdKGFyZykuXHJcbiAgICpcclxuICAgKiBsb2dbYmFzZV0oYXJnKSA9IGxuKGFyZykgLyBsbihiYXNlKVxyXG4gICAqXHJcbiAgICogVGhlIHJlc3VsdCB3aWxsIGFsd2F5cyBiZSBjb3JyZWN0bHkgcm91bmRlZCBpZiB0aGUgYmFzZSBvZiB0aGUgbG9nIGlzIDEwLCBhbmQgJ2FsbW9zdCBhbHdheXMnXHJcbiAgICogb3RoZXJ3aXNlOlxyXG4gICAqXHJcbiAgICogRGVwZW5kaW5nIG9uIHRoZSByb3VuZGluZyBtb2RlLCB0aGUgcmVzdWx0IG1heSBiZSBpbmNvcnJlY3RseSByb3VuZGVkIGlmIHRoZSBmaXJzdCBmaWZ0ZWVuXHJcbiAgICogcm91bmRpbmcgZGlnaXRzIGFyZSBbNDldOTk5OTk5OTk5OTk5OTkgb3IgWzUwXTAwMDAwMDAwMDAwMDAwLiBJbiB0aGF0IGNhc2UsIHRoZSBtYXhpbXVtIGVycm9yXHJcbiAgICogYmV0d2VlbiB0aGUgcmVzdWx0IGFuZCB0aGUgY29ycmVjdGx5IHJvdW5kZWQgcmVzdWx0IHdpbGwgYmUgb25lIHVscCAodW5pdCBpbiB0aGUgbGFzdCBwbGFjZSkuXHJcbiAgICpcclxuICAgKiBsb2dbLWJdKGEpICAgICAgID0gTmFOXHJcbiAgICogbG9nWzBdKGEpICAgICAgICA9IE5hTlxyXG4gICAqIGxvZ1sxXShhKSAgICAgICAgPSBOYU5cclxuICAgKiBsb2dbTmFOXShhKSAgICAgID0gTmFOXHJcbiAgICogbG9nW0luZmluaXR5XShhKSA9IE5hTlxyXG4gICAqIGxvZ1tiXSgwKSAgICAgICAgPSAtSW5maW5pdHlcclxuICAgKiBsb2dbYl0oLTApICAgICAgID0gLUluZmluaXR5XHJcbiAgICogbG9nW2JdKC1hKSAgICAgICA9IE5hTlxyXG4gICAqIGxvZ1tiXSgxKSAgICAgICAgPSAwXHJcbiAgICogbG9nW2JdKEluZmluaXR5KSA9IEluZmluaXR5XHJcbiAgICogbG9nW2JdKE5hTikgICAgICA9IE5hTlxyXG4gICAqXHJcbiAgICogW2Jhc2VdIHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IFRoZSBiYXNlIG9mIHRoZSBsb2dhcml0aG0uXHJcbiAgICpcclxuICAgKi9cclxuICBQLmxvZ2FyaXRobSA9IFAubG9nID0gZnVuY3Rpb24gKGJhc2UpIHtcclxuICAgIHZhciBpc0Jhc2UxMCwgZCwgZGVub21pbmF0b3IsIGssIGluZiwgbnVtLCBzZCwgcixcclxuICAgICAgYXJnID0gdGhpcyxcclxuICAgICAgQ3RvciA9IGFyZy5jb25zdHJ1Y3RvcixcclxuICAgICAgcHIgPSBDdG9yLnByZWNpc2lvbixcclxuICAgICAgcm0gPSBDdG9yLnJvdW5kaW5nLFxyXG4gICAgICBndWFyZCA9IDU7XHJcblxyXG4gICAgLy8gRGVmYXVsdCBiYXNlIGlzIDEwLlxyXG4gICAgaWYgKGJhc2UgPT0gbnVsbCkge1xyXG4gICAgICBiYXNlID0gbmV3IEN0b3IoMTApO1xyXG4gICAgICBpc0Jhc2UxMCA9IHRydWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBiYXNlID0gbmV3IEN0b3IoYmFzZSk7XHJcbiAgICAgIGQgPSBiYXNlLmQ7XHJcblxyXG4gICAgICAvLyBSZXR1cm4gTmFOIGlmIGJhc2UgaXMgbmVnYXRpdmUsIG9yIG5vbi1maW5pdGUsIG9yIGlzIDAgb3IgMS5cclxuICAgICAgaWYgKGJhc2UucyA8IDAgfHwgIWQgfHwgIWRbMF0gfHwgYmFzZS5lcSgxKSkgcmV0dXJuIG5ldyBDdG9yKE5hTik7XHJcblxyXG4gICAgICBpc0Jhc2UxMCA9IGJhc2UuZXEoMTApO1xyXG4gICAgfVxyXG5cclxuICAgIGQgPSBhcmcuZDtcclxuXHJcbiAgICAvLyBJcyBhcmcgbmVnYXRpdmUsIG5vbi1maW5pdGUsIDAgb3IgMT9cclxuICAgIGlmIChhcmcucyA8IDAgfHwgIWQgfHwgIWRbMF0gfHwgYXJnLmVxKDEpKSB7XHJcbiAgICAgIHJldHVybiBuZXcgQ3RvcihkICYmICFkWzBdID8gLTEgLyAwIDogYXJnLnMgIT0gMSA/IE5hTiA6IGQgPyAwIDogMSAvIDApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRoZSByZXN1bHQgd2lsbCBoYXZlIGEgbm9uLXRlcm1pbmF0aW5nIGRlY2ltYWwgZXhwYW5zaW9uIGlmIGJhc2UgaXMgMTAgYW5kIGFyZyBpcyBub3QgYW5cclxuICAgIC8vIGludGVnZXIgcG93ZXIgb2YgMTAuXHJcbiAgICBpZiAoaXNCYXNlMTApIHtcclxuICAgICAgaWYgKGQubGVuZ3RoID4gMSkge1xyXG4gICAgICAgIGluZiA9IHRydWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZm9yIChrID0gZFswXTsgayAlIDEwID09PSAwOykgayAvPSAxMDtcclxuICAgICAgICBpbmYgPSBrICE9PSAxO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuICAgIHNkID0gcHIgKyBndWFyZDtcclxuICAgIG51bSA9IG5hdHVyYWxMb2dhcml0aG0oYXJnLCBzZCk7XHJcbiAgICBkZW5vbWluYXRvciA9IGlzQmFzZTEwID8gZ2V0TG4xMChDdG9yLCBzZCArIDEwKSA6IG5hdHVyYWxMb2dhcml0aG0oYmFzZSwgc2QpO1xyXG5cclxuICAgIC8vIFRoZSByZXN1bHQgd2lsbCBoYXZlIDUgcm91bmRpbmcgZGlnaXRzLlxyXG4gICAgciA9IGRpdmlkZShudW0sIGRlbm9taW5hdG9yLCBzZCwgMSk7XHJcblxyXG4gICAgLy8gSWYgYXQgYSByb3VuZGluZyBib3VuZGFyeSwgaS5lLiB0aGUgcmVzdWx0J3Mgcm91bmRpbmcgZGlnaXRzIGFyZSBbNDldOTk5OSBvciBbNTBdMDAwMCxcclxuICAgIC8vIGNhbGN1bGF0ZSAxMCBmdXJ0aGVyIGRpZ2l0cy5cclxuICAgIC8vXHJcbiAgICAvLyBJZiB0aGUgcmVzdWx0IGlzIGtub3duIHRvIGhhdmUgYW4gaW5maW5pdGUgZGVjaW1hbCBleHBhbnNpb24sIHJlcGVhdCB0aGlzIHVudGlsIGl0IGlzIGNsZWFyXHJcbiAgICAvLyB0aGF0IHRoZSByZXN1bHQgaXMgYWJvdmUgb3IgYmVsb3cgdGhlIGJvdW5kYXJ5LiBPdGhlcndpc2UsIGlmIGFmdGVyIGNhbGN1bGF0aW5nIHRoZSAxMFxyXG4gICAgLy8gZnVydGhlciBkaWdpdHMsIHRoZSBsYXN0IDE0IGFyZSBuaW5lcywgcm91bmQgdXAgYW5kIGFzc3VtZSB0aGUgcmVzdWx0IGlzIGV4YWN0LlxyXG4gICAgLy8gQWxzbyBhc3N1bWUgdGhlIHJlc3VsdCBpcyBleGFjdCBpZiB0aGUgbGFzdCAxNCBhcmUgemVyby5cclxuICAgIC8vXHJcbiAgICAvLyBFeGFtcGxlIG9mIGEgcmVzdWx0IHRoYXQgd2lsbCBiZSBpbmNvcnJlY3RseSByb3VuZGVkOlxyXG4gICAgLy8gbG9nWzEwNDg1NzZdKDQ1MDM1OTk2MjczNzA1MDIpID0gMi42MDAwMDAwMDAwMDAwMDAwOTYxMDI3OTUxMTQ0NDc0Ni4uLlxyXG4gICAgLy8gVGhlIGFib3ZlIHJlc3VsdCBjb3JyZWN0bHkgcm91bmRlZCB1c2luZyBST1VORF9DRUlMIHRvIDEgZGVjaW1hbCBwbGFjZSBzaG91bGQgYmUgMi43LCBidXQgaXRcclxuICAgIC8vIHdpbGwgYmUgZ2l2ZW4gYXMgMi42IGFzIHRoZXJlIGFyZSAxNSB6ZXJvcyBpbW1lZGlhdGVseSBhZnRlciB0aGUgcmVxdWVzdGVkIGRlY2ltYWwgcGxhY2UsIHNvXHJcbiAgICAvLyB0aGUgZXhhY3QgcmVzdWx0IHdvdWxkIGJlIGFzc3VtZWQgdG8gYmUgMi42LCB3aGljaCByb3VuZGVkIHVzaW5nIFJPVU5EX0NFSUwgdG8gMSBkZWNpbWFsXHJcbiAgICAvLyBwbGFjZSBpcyBzdGlsbCAyLjYuXHJcbiAgICBpZiAoY2hlY2tSb3VuZGluZ0RpZ2l0cyhyLmQsIGsgPSBwciwgcm0pKSB7XHJcblxyXG4gICAgICBkbyB7XHJcbiAgICAgICAgc2QgKz0gMTA7XHJcbiAgICAgICAgbnVtID0gbmF0dXJhbExvZ2FyaXRobShhcmcsIHNkKTtcclxuICAgICAgICBkZW5vbWluYXRvciA9IGlzQmFzZTEwID8gZ2V0TG4xMChDdG9yLCBzZCArIDEwKSA6IG5hdHVyYWxMb2dhcml0aG0oYmFzZSwgc2QpO1xyXG4gICAgICAgIHIgPSBkaXZpZGUobnVtLCBkZW5vbWluYXRvciwgc2QsIDEpO1xyXG5cclxuICAgICAgICBpZiAoIWluZikge1xyXG5cclxuICAgICAgICAgIC8vIENoZWNrIGZvciAxNCBuaW5lcyBmcm9tIHRoZSAybmQgcm91bmRpbmcgZGlnaXQsIGFzIHRoZSBmaXJzdCBtYXkgYmUgNC5cclxuICAgICAgICAgIGlmICgrZGlnaXRzVG9TdHJpbmcoci5kKS5zbGljZShrICsgMSwgayArIDE1KSArIDEgPT0gMWUxNCkge1xyXG4gICAgICAgICAgICByID0gZmluYWxpc2UociwgcHIgKyAxLCAwKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH0gd2hpbGUgKGNoZWNrUm91bmRpbmdEaWdpdHMoci5kLCBrICs9IDEwLCBybSkpO1xyXG4gICAgfVxyXG5cclxuICAgIGV4dGVybmFsID0gdHJ1ZTtcclxuXHJcbiAgICByZXR1cm4gZmluYWxpc2UociwgcHIsIHJtKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgbWF4aW11bSBvZiB0aGUgYXJndW1lbnRzIGFuZCB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsLlxyXG4gICAqXHJcbiAgICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAgICpcclxuICBQLm1heCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmNhbGwoYXJndW1lbnRzLCB0aGlzKTtcclxuICAgIHJldHVybiBtYXhPck1pbih0aGlzLmNvbnN0cnVjdG9yLCBhcmd1bWVudHMsICdsdCcpO1xyXG4gIH07XHJcbiAgICovXHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBtaW5pbXVtIG9mIHRoZSBhcmd1bWVudHMgYW5kIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwuXHJcbiAgICpcclxuICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICAgKlxyXG4gIFAubWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgQXJyYXkucHJvdG90eXBlLnB1c2guY2FsbChhcmd1bWVudHMsIHRoaXMpO1xyXG4gICAgcmV0dXJuIG1heE9yTWluKHRoaXMuY29uc3RydWN0b3IsIGFyZ3VtZW50cywgJ2d0Jyk7XHJcbiAgfTtcclxuICAgKi9cclxuXHJcblxyXG4gIC8qXHJcbiAgICogIG4gLSAwID0gblxyXG4gICAqICBuIC0gTiA9IE5cclxuICAgKiAgbiAtIEkgPSAtSVxyXG4gICAqICAwIC0gbiA9IC1uXHJcbiAgICogIDAgLSAwID0gMFxyXG4gICAqICAwIC0gTiA9IE5cclxuICAgKiAgMCAtIEkgPSAtSVxyXG4gICAqICBOIC0gbiA9IE5cclxuICAgKiAgTiAtIDAgPSBOXHJcbiAgICogIE4gLSBOID0gTlxyXG4gICAqICBOIC0gSSA9IE5cclxuICAgKiAgSSAtIG4gPSBJXHJcbiAgICogIEkgLSAwID0gSVxyXG4gICAqICBJIC0gTiA9IE5cclxuICAgKiAgSSAtIEkgPSBOXHJcbiAgICpcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIG1pbnVzIGB5YCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYFxyXG4gICAqIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAgICpcclxuICAgKi9cclxuICBQLm1pbnVzID0gUC5zdWIgPSBmdW5jdGlvbiAoeSkge1xyXG4gICAgdmFyIGQsIGUsIGksIGosIGssIGxlbiwgcHIsIHJtLCB4ZCwgeGUsIHhMVHksIHlkLFxyXG4gICAgICB4ID0gdGhpcyxcclxuICAgICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gICAgeSA9IG5ldyBDdG9yKHkpO1xyXG5cclxuICAgIC8vIElmIGVpdGhlciBpcyBub3QgZmluaXRlLi4uXHJcbiAgICBpZiAoIXguZCB8fCAheS5kKSB7XHJcblxyXG4gICAgICAvLyBSZXR1cm4gTmFOIGlmIGVpdGhlciBpcyBOYU4uXHJcbiAgICAgIGlmICgheC5zIHx8ICF5LnMpIHkgPSBuZXcgQ3RvcihOYU4pO1xyXG5cclxuICAgICAgLy8gUmV0dXJuIHkgbmVnYXRlZCBpZiB4IGlzIGZpbml0ZSBhbmQgeSBpcyDCsUluZmluaXR5LlxyXG4gICAgICBlbHNlIGlmICh4LmQpIHkucyA9IC15LnM7XHJcblxyXG4gICAgICAvLyBSZXR1cm4geCBpZiB5IGlzIGZpbml0ZSBhbmQgeCBpcyDCsUluZmluaXR5LlxyXG4gICAgICAvLyBSZXR1cm4geCBpZiBib3RoIGFyZSDCsUluZmluaXR5IHdpdGggZGlmZmVyZW50IHNpZ25zLlxyXG4gICAgICAvLyBSZXR1cm4gTmFOIGlmIGJvdGggYXJlIMKxSW5maW5pdHkgd2l0aCB0aGUgc2FtZSBzaWduLlxyXG4gICAgICBlbHNlIHkgPSBuZXcgQ3Rvcih5LmQgfHwgeC5zICE9PSB5LnMgPyB4IDogTmFOKTtcclxuXHJcbiAgICAgIHJldHVybiB5O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIHNpZ25zIGRpZmZlci4uLlxyXG4gICAgaWYgKHgucyAhPSB5LnMpIHtcclxuICAgICAgeS5zID0gLXkucztcclxuICAgICAgcmV0dXJuIHgucGx1cyh5KTtcclxuICAgIH1cclxuXHJcbiAgICB4ZCA9IHguZDtcclxuICAgIHlkID0geS5kO1xyXG4gICAgcHIgPSBDdG9yLnByZWNpc2lvbjtcclxuICAgIHJtID0gQ3Rvci5yb3VuZGluZztcclxuXHJcbiAgICAvLyBJZiBlaXRoZXIgaXMgemVyby4uLlxyXG4gICAgaWYgKCF4ZFswXSB8fCAheWRbMF0pIHtcclxuXHJcbiAgICAgIC8vIFJldHVybiB5IG5lZ2F0ZWQgaWYgeCBpcyB6ZXJvIGFuZCB5IGlzIG5vbi16ZXJvLlxyXG4gICAgICBpZiAoeWRbMF0pIHkucyA9IC15LnM7XHJcblxyXG4gICAgICAvLyBSZXR1cm4geCBpZiB5IGlzIHplcm8gYW5kIHggaXMgbm9uLXplcm8uXHJcbiAgICAgIGVsc2UgaWYgKHhkWzBdKSB5ID0gbmV3IEN0b3IoeCk7XHJcblxyXG4gICAgICAvLyBSZXR1cm4gemVybyBpZiBib3RoIGFyZSB6ZXJvLlxyXG4gICAgICAvLyBGcm9tIElFRUUgNzU0ICgyMDA4KSA2LjM6IDAgLSAwID0gLTAgLSAtMCA9IC0wIHdoZW4gcm91bmRpbmcgdG8gLUluZmluaXR5LlxyXG4gICAgICBlbHNlIHJldHVybiBuZXcgQ3RvcihybSA9PT0gMyA/IC0wIDogMCk7XHJcblxyXG4gICAgICByZXR1cm4gZXh0ZXJuYWwgPyBmaW5hbGlzZSh5LCBwciwgcm0pIDogeTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB4IGFuZCB5IGFyZSBmaW5pdGUsIG5vbi16ZXJvIG51bWJlcnMgd2l0aCB0aGUgc2FtZSBzaWduLlxyXG5cclxuICAgIC8vIENhbGN1bGF0ZSBiYXNlIDFlNyBleHBvbmVudHMuXHJcbiAgICBlID0gbWF0aGZsb29yKHkuZSAvIExPR19CQVNFKTtcclxuICAgIHhlID0gbWF0aGZsb29yKHguZSAvIExPR19CQVNFKTtcclxuXHJcbiAgICB4ZCA9IHhkLnNsaWNlKCk7XHJcbiAgICBrID0geGUgLSBlO1xyXG5cclxuICAgIC8vIElmIGJhc2UgMWU3IGV4cG9uZW50cyBkaWZmZXIuLi5cclxuICAgIGlmIChrKSB7XHJcbiAgICAgIHhMVHkgPSBrIDwgMDtcclxuXHJcbiAgICAgIGlmICh4TFR5KSB7XHJcbiAgICAgICAgZCA9IHhkO1xyXG4gICAgICAgIGsgPSAtaztcclxuICAgICAgICBsZW4gPSB5ZC5sZW5ndGg7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZCA9IHlkO1xyXG4gICAgICAgIGUgPSB4ZTtcclxuICAgICAgICBsZW4gPSB4ZC5sZW5ndGg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE51bWJlcnMgd2l0aCBtYXNzaXZlbHkgZGlmZmVyZW50IGV4cG9uZW50cyB3b3VsZCByZXN1bHQgaW4gYSB2ZXJ5IGhpZ2ggbnVtYmVyIG9mXHJcbiAgICAgIC8vIHplcm9zIG5lZWRpbmcgdG8gYmUgcHJlcGVuZGVkLCBidXQgdGhpcyBjYW4gYmUgYXZvaWRlZCB3aGlsZSBzdGlsbCBlbnN1cmluZyBjb3JyZWN0XHJcbiAgICAgIC8vIHJvdW5kaW5nIGJ5IGxpbWl0aW5nIHRoZSBudW1iZXIgb2YgemVyb3MgdG8gYE1hdGguY2VpbChwciAvIExPR19CQVNFKSArIDJgLlxyXG4gICAgICBpID0gTWF0aC5tYXgoTWF0aC5jZWlsKHByIC8gTE9HX0JBU0UpLCBsZW4pICsgMjtcclxuXHJcbiAgICAgIGlmIChrID4gaSkge1xyXG4gICAgICAgIGsgPSBpO1xyXG4gICAgICAgIGQubGVuZ3RoID0gMTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUHJlcGVuZCB6ZXJvcyB0byBlcXVhbGlzZSBleHBvbmVudHMuXHJcbiAgICAgIGQucmV2ZXJzZSgpO1xyXG4gICAgICBmb3IgKGkgPSBrOyBpLS07KSBkLnB1c2goMCk7XHJcbiAgICAgIGQucmV2ZXJzZSgpO1xyXG5cclxuICAgIC8vIEJhc2UgMWU3IGV4cG9uZW50cyBlcXVhbC5cclxuICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAvLyBDaGVjayBkaWdpdHMgdG8gZGV0ZXJtaW5lIHdoaWNoIGlzIHRoZSBiaWdnZXIgbnVtYmVyLlxyXG5cclxuICAgICAgaSA9IHhkLmxlbmd0aDtcclxuICAgICAgbGVuID0geWQubGVuZ3RoO1xyXG4gICAgICB4TFR5ID0gaSA8IGxlbjtcclxuICAgICAgaWYgKHhMVHkpIGxlbiA9IGk7XHJcblxyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBpZiAoeGRbaV0gIT0geWRbaV0pIHtcclxuICAgICAgICAgIHhMVHkgPSB4ZFtpXSA8IHlkW2ldO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBrID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoeExUeSkge1xyXG4gICAgICBkID0geGQ7XHJcbiAgICAgIHhkID0geWQ7XHJcbiAgICAgIHlkID0gZDtcclxuICAgICAgeS5zID0gLXkucztcclxuICAgIH1cclxuXHJcbiAgICBsZW4gPSB4ZC5sZW5ndGg7XHJcblxyXG4gICAgLy8gQXBwZW5kIHplcm9zIHRvIGB4ZGAgaWYgc2hvcnRlci5cclxuICAgIC8vIERvbid0IGFkZCB6ZXJvcyB0byBgeWRgIGlmIHNob3J0ZXIgYXMgc3VidHJhY3Rpb24gb25seSBuZWVkcyB0byBzdGFydCBhdCBgeWRgIGxlbmd0aC5cclxuICAgIGZvciAoaSA9IHlkLmxlbmd0aCAtIGxlbjsgaSA+IDA7IC0taSkgeGRbbGVuKytdID0gMDtcclxuXHJcbiAgICAvLyBTdWJ0cmFjdCB5ZCBmcm9tIHhkLlxyXG4gICAgZm9yIChpID0geWQubGVuZ3RoOyBpID4gazspIHtcclxuXHJcbiAgICAgIGlmICh4ZFstLWldIDwgeWRbaV0pIHtcclxuICAgICAgICBmb3IgKGogPSBpOyBqICYmIHhkWy0tal0gPT09IDA7KSB4ZFtqXSA9IEJBU0UgLSAxO1xyXG4gICAgICAgIC0teGRbal07XHJcbiAgICAgICAgeGRbaV0gKz0gQkFTRTtcclxuICAgICAgfVxyXG5cclxuICAgICAgeGRbaV0gLT0geWRbaV07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgZm9yICg7IHhkWy0tbGVuXSA9PT0gMDspIHhkLnBvcCgpO1xyXG5cclxuICAgIC8vIFJlbW92ZSBsZWFkaW5nIHplcm9zIGFuZCBhZGp1c3QgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICBmb3IgKDsgeGRbMF0gPT09IDA7IHhkLnNoaWZ0KCkpIC0tZTtcclxuXHJcbiAgICAvLyBaZXJvP1xyXG4gICAgaWYgKCF4ZFswXSkgcmV0dXJuIG5ldyBDdG9yKHJtID09PSAzID8gLTAgOiAwKTtcclxuXHJcbiAgICB5LmQgPSB4ZDtcclxuICAgIHkuZSA9IGdldEJhc2UxMEV4cG9uZW50KHhkLCBlKTtcclxuXHJcbiAgICByZXR1cm4gZXh0ZXJuYWwgPyBmaW5hbGlzZSh5LCBwciwgcm0pIDogeTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiAgIG4gJSAwID0gIE5cclxuICAgKiAgIG4gJSBOID0gIE5cclxuICAgKiAgIG4gJSBJID0gIG5cclxuICAgKiAgIDAgJSBuID0gIDBcclxuICAgKiAgLTAgJSBuID0gLTBcclxuICAgKiAgIDAgJSAwID0gIE5cclxuICAgKiAgIDAgJSBOID0gIE5cclxuICAgKiAgIDAgJSBJID0gIDBcclxuICAgKiAgIE4gJSBuID0gIE5cclxuICAgKiAgIE4gJSAwID0gIE5cclxuICAgKiAgIE4gJSBOID0gIE5cclxuICAgKiAgIE4gJSBJID0gIE5cclxuICAgKiAgIEkgJSBuID0gIE5cclxuICAgKiAgIEkgJSAwID0gIE5cclxuICAgKiAgIEkgJSBOID0gIE5cclxuICAgKiAgIEkgJSBJID0gIE5cclxuICAgKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgbW9kdWxvIGB5YCwgcm91bmRlZCB0b1xyXG4gICAqIGBwcmVjaXNpb25gIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAgICpcclxuICAgKiBUaGUgcmVzdWx0IGRlcGVuZHMgb24gdGhlIG1vZHVsbyBtb2RlLlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5tb2R1bG8gPSBQLm1vZCA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgICB2YXIgcSxcclxuICAgICAgeCA9IHRoaXMsXHJcbiAgICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICAgIHkgPSBuZXcgQ3Rvcih5KTtcclxuXHJcbiAgICAvLyBSZXR1cm4gTmFOIGlmIHggaXMgwrFJbmZpbml0eSBvciBOYU4sIG9yIHkgaXMgTmFOIG9yIMKxMC5cclxuICAgIGlmICgheC5kIHx8ICF5LnMgfHwgeS5kICYmICF5LmRbMF0pIHJldHVybiBuZXcgQ3RvcihOYU4pO1xyXG5cclxuICAgIC8vIFJldHVybiB4IGlmIHkgaXMgwrFJbmZpbml0eSBvciB4IGlzIMKxMC5cclxuICAgIGlmICgheS5kIHx8IHguZCAmJiAheC5kWzBdKSB7XHJcbiAgICAgIHJldHVybiBmaW5hbGlzZShuZXcgQ3Rvcih4KSwgQ3Rvci5wcmVjaXNpb24sIEN0b3Iucm91bmRpbmcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFByZXZlbnQgcm91bmRpbmcgb2YgaW50ZXJtZWRpYXRlIGNhbGN1bGF0aW9ucy5cclxuICAgIGV4dGVybmFsID0gZmFsc2U7XHJcblxyXG4gICAgaWYgKEN0b3IubW9kdWxvID09IDkpIHtcclxuXHJcbiAgICAgIC8vIEV1Y2xpZGlhbiBkaXZpc2lvbjogcSA9IHNpZ24oeSkgKiBmbG9vcih4IC8gYWJzKHkpKVxyXG4gICAgICAvLyByZXN1bHQgPSB4IC0gcSAqIHkgICAgd2hlcmUgIDAgPD0gcmVzdWx0IDwgYWJzKHkpXHJcbiAgICAgIHEgPSBkaXZpZGUoeCwgeS5hYnMoKSwgMCwgMywgMSk7XHJcbiAgICAgIHEucyAqPSB5LnM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBxID0gZGl2aWRlKHgsIHksIDAsIEN0b3IubW9kdWxvLCAxKTtcclxuICAgIH1cclxuXHJcbiAgICBxID0gcS50aW1lcyh5KTtcclxuXHJcbiAgICBleHRlcm5hbCA9IHRydWU7XHJcblxyXG4gICAgcmV0dXJuIHgubWludXMocSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIG5hdHVyYWwgZXhwb25lbnRpYWwgb2YgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCxcclxuICAgKiBpLmUuIHRoZSBiYXNlIGUgcmFpc2VkIHRvIHRoZSBwb3dlciB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gXHJcbiAgICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAubmF0dXJhbEV4cG9uZW50aWFsID0gUC5leHAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gbmF0dXJhbEV4cG9uZW50aWFsKHRoaXMpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBuYXR1cmFsIGxvZ2FyaXRobSBvZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsLFxyXG4gICAqIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAubmF0dXJhbExvZ2FyaXRobSA9IFAubG4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gbmF0dXJhbExvZ2FyaXRobSh0aGlzKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIG5lZ2F0ZWQsIGkuZS4gYXMgaWYgbXVsdGlwbGllZCBieVxyXG4gICAqIC0xLlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5uZWdhdGVkID0gUC5uZWcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgeCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpO1xyXG4gICAgeC5zID0gLXgucztcclxuICAgIHJldHVybiBmaW5hbGlzZSh4KTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiAgbiArIDAgPSBuXHJcbiAgICogIG4gKyBOID0gTlxyXG4gICAqICBuICsgSSA9IElcclxuICAgKiAgMCArIG4gPSBuXHJcbiAgICogIDAgKyAwID0gMFxyXG4gICAqICAwICsgTiA9IE5cclxuICAgKiAgMCArIEkgPSBJXHJcbiAgICogIE4gKyBuID0gTlxyXG4gICAqICBOICsgMCA9IE5cclxuICAgKiAgTiArIE4gPSBOXHJcbiAgICogIE4gKyBJID0gTlxyXG4gICAqICBJICsgbiA9IElcclxuICAgKiAgSSArIDAgPSBJXHJcbiAgICogIEkgKyBOID0gTlxyXG4gICAqICBJICsgSSA9IElcclxuICAgKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgcGx1cyBgeWAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmBcclxuICAgKiBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5wbHVzID0gUC5hZGQgPSBmdW5jdGlvbiAoeSkge1xyXG4gICAgdmFyIGNhcnJ5LCBkLCBlLCBpLCBrLCBsZW4sIHByLCBybSwgeGQsIHlkLFxyXG4gICAgICB4ID0gdGhpcyxcclxuICAgICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gICAgeSA9IG5ldyBDdG9yKHkpO1xyXG5cclxuICAgIC8vIElmIGVpdGhlciBpcyBub3QgZmluaXRlLi4uXHJcbiAgICBpZiAoIXguZCB8fCAheS5kKSB7XHJcblxyXG4gICAgICAvLyBSZXR1cm4gTmFOIGlmIGVpdGhlciBpcyBOYU4uXHJcbiAgICAgIGlmICgheC5zIHx8ICF5LnMpIHkgPSBuZXcgQ3RvcihOYU4pO1xyXG5cclxuICAgICAgLy8gUmV0dXJuIHggaWYgeSBpcyBmaW5pdGUgYW5kIHggaXMgwrFJbmZpbml0eS5cclxuICAgICAgLy8gUmV0dXJuIHggaWYgYm90aCBhcmUgwrFJbmZpbml0eSB3aXRoIHRoZSBzYW1lIHNpZ24uXHJcbiAgICAgIC8vIFJldHVybiBOYU4gaWYgYm90aCBhcmUgwrFJbmZpbml0eSB3aXRoIGRpZmZlcmVudCBzaWducy5cclxuICAgICAgLy8gUmV0dXJuIHkgaWYgeCBpcyBmaW5pdGUgYW5kIHkgaXMgwrFJbmZpbml0eS5cclxuICAgICAgZWxzZSBpZiAoIXguZCkgeSA9IG5ldyBDdG9yKHkuZCB8fCB4LnMgPT09IHkucyA/IHggOiBOYU4pO1xyXG5cclxuICAgICAgcmV0dXJuIHk7XHJcbiAgICB9XHJcblxyXG4gICAgIC8vIElmIHNpZ25zIGRpZmZlci4uLlxyXG4gICAgaWYgKHgucyAhPSB5LnMpIHtcclxuICAgICAgeS5zID0gLXkucztcclxuICAgICAgcmV0dXJuIHgubWludXMoeSk7XHJcbiAgICB9XHJcblxyXG4gICAgeGQgPSB4LmQ7XHJcbiAgICB5ZCA9IHkuZDtcclxuICAgIHByID0gQ3Rvci5wcmVjaXNpb247XHJcbiAgICBybSA9IEN0b3Iucm91bmRpbmc7XHJcblxyXG4gICAgLy8gSWYgZWl0aGVyIGlzIHplcm8uLi5cclxuICAgIGlmICgheGRbMF0gfHwgIXlkWzBdKSB7XHJcblxyXG4gICAgICAvLyBSZXR1cm4geCBpZiB5IGlzIHplcm8uXHJcbiAgICAgIC8vIFJldHVybiB5IGlmIHkgaXMgbm9uLXplcm8uXHJcbiAgICAgIGlmICgheWRbMF0pIHkgPSBuZXcgQ3Rvcih4KTtcclxuXHJcbiAgICAgIHJldHVybiBleHRlcm5hbCA/IGZpbmFsaXNlKHksIHByLCBybSkgOiB5O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHggYW5kIHkgYXJlIGZpbml0ZSwgbm9uLXplcm8gbnVtYmVycyB3aXRoIHRoZSBzYW1lIHNpZ24uXHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIGJhc2UgMWU3IGV4cG9uZW50cy5cclxuICAgIGsgPSBtYXRoZmxvb3IoeC5lIC8gTE9HX0JBU0UpO1xyXG4gICAgZSA9IG1hdGhmbG9vcih5LmUgLyBMT0dfQkFTRSk7XHJcblxyXG4gICAgeGQgPSB4ZC5zbGljZSgpO1xyXG4gICAgaSA9IGsgLSBlO1xyXG5cclxuICAgIC8vIElmIGJhc2UgMWU3IGV4cG9uZW50cyBkaWZmZXIuLi5cclxuICAgIGlmIChpKSB7XHJcblxyXG4gICAgICBpZiAoaSA8IDApIHtcclxuICAgICAgICBkID0geGQ7XHJcbiAgICAgICAgaSA9IC1pO1xyXG4gICAgICAgIGxlbiA9IHlkLmxlbmd0aDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBkID0geWQ7XHJcbiAgICAgICAgZSA9IGs7XHJcbiAgICAgICAgbGVuID0geGQubGVuZ3RoO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBMaW1pdCBudW1iZXIgb2YgemVyb3MgcHJlcGVuZGVkIHRvIG1heChjZWlsKHByIC8gTE9HX0JBU0UpLCBsZW4pICsgMS5cclxuICAgICAgayA9IE1hdGguY2VpbChwciAvIExPR19CQVNFKTtcclxuICAgICAgbGVuID0gayA+IGxlbiA/IGsgKyAxIDogbGVuICsgMTtcclxuXHJcbiAgICAgIGlmIChpID4gbGVuKSB7XHJcbiAgICAgICAgaSA9IGxlbjtcclxuICAgICAgICBkLmxlbmd0aCA9IDE7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFByZXBlbmQgemVyb3MgdG8gZXF1YWxpc2UgZXhwb25lbnRzLiBOb3RlOiBGYXN0ZXIgdG8gdXNlIHJldmVyc2UgdGhlbiBkbyB1bnNoaWZ0cy5cclxuICAgICAgZC5yZXZlcnNlKCk7XHJcbiAgICAgIGZvciAoOyBpLS07KSBkLnB1c2goMCk7XHJcbiAgICAgIGQucmV2ZXJzZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGxlbiA9IHhkLmxlbmd0aDtcclxuICAgIGkgPSB5ZC5sZW5ndGg7XHJcblxyXG4gICAgLy8gSWYgeWQgaXMgbG9uZ2VyIHRoYW4geGQsIHN3YXAgeGQgYW5kIHlkIHNvIHhkIHBvaW50cyB0byB0aGUgbG9uZ2VyIGFycmF5LlxyXG4gICAgaWYgKGxlbiAtIGkgPCAwKSB7XHJcbiAgICAgIGkgPSBsZW47XHJcbiAgICAgIGQgPSB5ZDtcclxuICAgICAgeWQgPSB4ZDtcclxuICAgICAgeGQgPSBkO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE9ubHkgc3RhcnQgYWRkaW5nIGF0IHlkLmxlbmd0aCAtIDEgYXMgdGhlIGZ1cnRoZXIgZGlnaXRzIG9mIHhkIGNhbiBiZSBsZWZ0IGFzIHRoZXkgYXJlLlxyXG4gICAgZm9yIChjYXJyeSA9IDA7IGk7KSB7XHJcbiAgICAgIGNhcnJ5ID0gKHhkWy0taV0gPSB4ZFtpXSArIHlkW2ldICsgY2FycnkpIC8gQkFTRSB8IDA7XHJcbiAgICAgIHhkW2ldICU9IEJBU0U7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNhcnJ5KSB7XHJcbiAgICAgIHhkLnVuc2hpZnQoY2FycnkpO1xyXG4gICAgICArK2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgLy8gTm8gbmVlZCB0byBjaGVjayBmb3IgemVybywgYXMgK3ggKyAreSAhPSAwICYmIC14ICsgLXkgIT0gMFxyXG4gICAgZm9yIChsZW4gPSB4ZC5sZW5ndGg7IHhkWy0tbGVuXSA9PSAwOykgeGQucG9wKCk7XHJcblxyXG4gICAgeS5kID0geGQ7XHJcbiAgICB5LmUgPSBnZXRCYXNlMTBFeHBvbmVudCh4ZCwgZSk7XHJcblxyXG4gICAgcmV0dXJuIGV4dGVybmFsID8gZmluYWxpc2UoeSwgcHIsIHJtKSA6IHk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIG9mIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwuXHJcbiAgICpcclxuICAgKiBbel0ge2Jvb2xlYW58bnVtYmVyfSBXaGV0aGVyIHRvIGNvdW50IGludGVnZXItcGFydCB0cmFpbGluZyB6ZXJvczogdHJ1ZSwgZmFsc2UsIDEgb3IgMC5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAucHJlY2lzaW9uID0gUC5zZCA9IGZ1bmN0aW9uICh6KSB7XHJcbiAgICB2YXIgayxcclxuICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgaWYgKHogIT09IHZvaWQgMCAmJiB6ICE9PSAhIXogJiYgeiAhPT0gMSAmJiB6ICE9PSAwKSB0aHJvdyBFcnJvcihpbnZhbGlkQXJndW1lbnQgKyB6KTtcclxuXHJcbiAgICBpZiAoeC5kKSB7XHJcbiAgICAgIGsgPSBnZXRQcmVjaXNpb24oeC5kKTtcclxuICAgICAgaWYgKHogJiYgeC5lICsgMSA+IGspIGsgPSB4LmUgKyAxO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgayA9IE5hTjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaztcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIHJvdW5kZWQgdG8gYSB3aG9sZSBudW1iZXIgdXNpbmdcclxuICAgKiByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAgICpcclxuICAgKi9cclxuICBQLnJvdW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHggPSB0aGlzLFxyXG4gICAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgICByZXR1cm4gZmluYWxpc2UobmV3IEN0b3IoeCksIHguZSArIDEsIEN0b3Iucm91bmRpbmcpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBzaW5lIG9mIHRoZSB2YWx1ZSBpbiByYWRpYW5zIG9mIHRoaXMgRGVjaW1hbC5cclxuICAgKlxyXG4gICAqIERvbWFpbjogWy1JbmZpbml0eSwgSW5maW5pdHldXHJcbiAgICogUmFuZ2U6IFstMSwgMV1cclxuICAgKlxyXG4gICAqIHNpbih4KSA9IHggLSB4XjMvMyEgKyB4XjUvNSEgLSAuLi5cclxuICAgKlxyXG4gICAqIHNpbigwKSAgICAgICAgID0gMFxyXG4gICAqIHNpbigtMCkgICAgICAgID0gLTBcclxuICAgKiBzaW4oSW5maW5pdHkpICA9IE5hTlxyXG4gICAqIHNpbigtSW5maW5pdHkpID0gTmFOXHJcbiAgICogc2luKE5hTikgICAgICAgPSBOYU5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAuc2luZSA9IFAuc2luID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHByLCBybSxcclxuICAgICAgeCA9IHRoaXMsXHJcbiAgICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICAgIGlmICgheC5pc0Zpbml0ZSgpKSByZXR1cm4gbmV3IEN0b3IoTmFOKTtcclxuICAgIGlmICh4LmlzWmVybygpKSByZXR1cm4gbmV3IEN0b3IoeCk7XHJcblxyXG4gICAgcHIgPSBDdG9yLnByZWNpc2lvbjtcclxuICAgIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICAgIEN0b3IucHJlY2lzaW9uID0gcHIgKyBNYXRoLm1heCh4LmUsIHguc2QoKSkgKyBMT0dfQkFTRTtcclxuICAgIEN0b3Iucm91bmRpbmcgPSAxO1xyXG5cclxuICAgIHggPSBzaW5lKEN0b3IsIHRvTGVzc1RoYW5IYWxmUGkoQ3RvciwgeCkpO1xyXG5cclxuICAgIEN0b3IucHJlY2lzaW9uID0gcHI7XHJcbiAgICBDdG9yLnJvdW5kaW5nID0gcm07XHJcblxyXG4gICAgcmV0dXJuIGZpbmFsaXNlKHF1YWRyYW50ID4gMiA/IHgubmVnKCkgOiB4LCBwciwgcm0sIHRydWUpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBzcXVhcmUgcm9vdCBvZiB0aGlzIERlY2ltYWwsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmBcclxuICAgKiBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gICAqXHJcbiAgICogIHNxcnQoLW4pID0gIE5cclxuICAgKiAgc3FydChOKSAgPSAgTlxyXG4gICAqICBzcXJ0KC1JKSA9ICBOXHJcbiAgICogIHNxcnQoSSkgID0gIElcclxuICAgKiAgc3FydCgwKSAgPSAgMFxyXG4gICAqICBzcXJ0KC0wKSA9IC0wXHJcbiAgICpcclxuICAgKi9cclxuICBQLnNxdWFyZVJvb3QgPSBQLnNxcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgbSwgbiwgc2QsIHIsIHJlcCwgdCxcclxuICAgICAgeCA9IHRoaXMsXHJcbiAgICAgIGQgPSB4LmQsXHJcbiAgICAgIGUgPSB4LmUsXHJcbiAgICAgIHMgPSB4LnMsXHJcbiAgICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICAgIC8vIE5lZ2F0aXZlL05hTi9JbmZpbml0eS96ZXJvP1xyXG4gICAgaWYgKHMgIT09IDEgfHwgIWQgfHwgIWRbMF0pIHtcclxuICAgICAgcmV0dXJuIG5ldyBDdG9yKCFzIHx8IHMgPCAwICYmICghZCB8fCBkWzBdKSA/IE5hTiA6IGQgPyB4IDogMSAvIDApO1xyXG4gICAgfVxyXG5cclxuICAgIGV4dGVybmFsID0gZmFsc2U7XHJcblxyXG4gICAgLy8gSW5pdGlhbCBlc3RpbWF0ZS5cclxuICAgIHMgPSBNYXRoLnNxcnQoK3gpO1xyXG5cclxuICAgIC8vIE1hdGguc3FydCB1bmRlcmZsb3cvb3ZlcmZsb3c/XHJcbiAgICAvLyBQYXNzIHggdG8gTWF0aC5zcXJ0IGFzIGludGVnZXIsIHRoZW4gYWRqdXN0IHRoZSBleHBvbmVudCBvZiB0aGUgcmVzdWx0LlxyXG4gICAgaWYgKHMgPT0gMCB8fCBzID09IDEgLyAwKSB7XHJcbiAgICAgIG4gPSBkaWdpdHNUb1N0cmluZyhkKTtcclxuXHJcbiAgICAgIGlmICgobi5sZW5ndGggKyBlKSAlIDIgPT0gMCkgbiArPSAnMCc7XHJcbiAgICAgIHMgPSBNYXRoLnNxcnQobik7XHJcbiAgICAgIGUgPSBtYXRoZmxvb3IoKGUgKyAxKSAvIDIpIC0gKGUgPCAwIHx8IGUgJSAyKTtcclxuXHJcbiAgICAgIGlmIChzID09IDEgLyAwKSB7XHJcbiAgICAgICAgbiA9ICcxZScgKyBlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG4gPSBzLnRvRXhwb25lbnRpYWwoKTtcclxuICAgICAgICBuID0gbi5zbGljZSgwLCBuLmluZGV4T2YoJ2UnKSArIDEpICsgZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgciA9IG5ldyBDdG9yKG4pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgciA9IG5ldyBDdG9yKHMudG9TdHJpbmcoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgc2QgPSAoZSA9IEN0b3IucHJlY2lzaW9uKSArIDM7XHJcblxyXG4gICAgLy8gTmV3dG9uLVJhcGhzb24gaXRlcmF0aW9uLlxyXG4gICAgZm9yICg7Oykge1xyXG4gICAgICB0ID0gcjtcclxuICAgICAgciA9IHQucGx1cyhkaXZpZGUoeCwgdCwgc2QgKyAyLCAxKSkudGltZXMoMC41KTtcclxuXHJcbiAgICAgIC8vIFRPRE8/IFJlcGxhY2Ugd2l0aCBmb3ItbG9vcCBhbmQgY2hlY2tSb3VuZGluZ0RpZ2l0cy5cclxuICAgICAgaWYgKGRpZ2l0c1RvU3RyaW5nKHQuZCkuc2xpY2UoMCwgc2QpID09PSAobiA9IGRpZ2l0c1RvU3RyaW5nKHIuZCkpLnNsaWNlKDAsIHNkKSkge1xyXG4gICAgICAgIG4gPSBuLnNsaWNlKHNkIC0gMywgc2QgKyAxKTtcclxuXHJcbiAgICAgICAgLy8gVGhlIDR0aCByb3VuZGluZyBkaWdpdCBtYXkgYmUgaW4gZXJyb3IgYnkgLTEgc28gaWYgdGhlIDQgcm91bmRpbmcgZGlnaXRzIGFyZSA5OTk5IG9yXHJcbiAgICAgICAgLy8gNDk5OSwgaS5lLiBhcHByb2FjaGluZyBhIHJvdW5kaW5nIGJvdW5kYXJ5LCBjb250aW51ZSB0aGUgaXRlcmF0aW9uLlxyXG4gICAgICAgIGlmIChuID09ICc5OTk5JyB8fCAhcmVwICYmIG4gPT0gJzQ5OTknKSB7XHJcblxyXG4gICAgICAgICAgLy8gT24gdGhlIGZpcnN0IGl0ZXJhdGlvbiBvbmx5LCBjaGVjayB0byBzZWUgaWYgcm91bmRpbmcgdXAgZ2l2ZXMgdGhlIGV4YWN0IHJlc3VsdCBhcyB0aGVcclxuICAgICAgICAgIC8vIG5pbmVzIG1heSBpbmZpbml0ZWx5IHJlcGVhdC5cclxuICAgICAgICAgIGlmICghcmVwKSB7XHJcbiAgICAgICAgICAgIGZpbmFsaXNlKHQsIGUgKyAxLCAwKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0LnRpbWVzKHQpLmVxKHgpKSB7XHJcbiAgICAgICAgICAgICAgciA9IHQ7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBzZCArPSA0O1xyXG4gICAgICAgICAgcmVwID0gMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIC8vIElmIHRoZSByb3VuZGluZyBkaWdpdHMgYXJlIG51bGwsIDB7MCw0fSBvciA1MHswLDN9LCBjaGVjayBmb3IgYW4gZXhhY3QgcmVzdWx0LlxyXG4gICAgICAgICAgLy8gSWYgbm90LCB0aGVuIHRoZXJlIGFyZSBmdXJ0aGVyIGRpZ2l0cyBhbmQgbSB3aWxsIGJlIHRydXRoeS5cclxuICAgICAgICAgIGlmICghK24gfHwgIStuLnNsaWNlKDEpICYmIG4uY2hhckF0KDApID09ICc1Jykge1xyXG5cclxuICAgICAgICAgICAgLy8gVHJ1bmNhdGUgdG8gdGhlIGZpcnN0IHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgICAgICBmaW5hbGlzZShyLCBlICsgMSwgMSk7XHJcbiAgICAgICAgICAgIG0gPSAhci50aW1lcyhyKS5lcSh4KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBleHRlcm5hbCA9IHRydWU7XHJcblxyXG4gICAgcmV0dXJuIGZpbmFsaXNlKHIsIGUsIEN0b3Iucm91bmRpbmcsIG0pO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSB0YW5nZW50IG9mIHRoZSB2YWx1ZSBpbiByYWRpYW5zIG9mIHRoaXMgRGVjaW1hbC5cclxuICAgKlxyXG4gICAqIERvbWFpbjogWy1JbmZpbml0eSwgSW5maW5pdHldXHJcbiAgICogUmFuZ2U6IFstSW5maW5pdHksIEluZmluaXR5XVxyXG4gICAqXHJcbiAgICogdGFuKDApICAgICAgICAgPSAwXHJcbiAgICogdGFuKC0wKSAgICAgICAgPSAtMFxyXG4gICAqIHRhbihJbmZpbml0eSkgID0gTmFOXHJcbiAgICogdGFuKC1JbmZpbml0eSkgPSBOYU5cclxuICAgKiB0YW4oTmFOKSAgICAgICA9IE5hTlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC50YW5nZW50ID0gUC50YW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgcHIsIHJtLFxyXG4gICAgICB4ID0gdGhpcyxcclxuICAgICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gICAgaWYgKCF4LmlzRmluaXRlKCkpIHJldHVybiBuZXcgQ3RvcihOYU4pO1xyXG4gICAgaWYgKHguaXNaZXJvKCkpIHJldHVybiBuZXcgQ3Rvcih4KTtcclxuXHJcbiAgICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG4gICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gICAgQ3Rvci5wcmVjaXNpb24gPSBwciArIDEwO1xyXG4gICAgQ3Rvci5yb3VuZGluZyA9IDE7XHJcblxyXG4gICAgeCA9IHguc2luKCk7XHJcbiAgICB4LnMgPSAxO1xyXG4gICAgeCA9IGRpdmlkZSh4LCBuZXcgQ3RvcigxKS5taW51cyh4LnRpbWVzKHgpKS5zcXJ0KCksIHByICsgMTAsIDApO1xyXG5cclxuICAgIEN0b3IucHJlY2lzaW9uID0gcHI7XHJcbiAgICBDdG9yLnJvdW5kaW5nID0gcm07XHJcblxyXG4gICAgcmV0dXJuIGZpbmFsaXNlKHF1YWRyYW50ID09IDIgfHwgcXVhZHJhbnQgPT0gNCA/IHgubmVnKCkgOiB4LCBwciwgcm0sIHRydWUpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqICBuICogMCA9IDBcclxuICAgKiAgbiAqIE4gPSBOXHJcbiAgICogIG4gKiBJID0gSVxyXG4gICAqICAwICogbiA9IDBcclxuICAgKiAgMCAqIDAgPSAwXHJcbiAgICogIDAgKiBOID0gTlxyXG4gICAqICAwICogSSA9IE5cclxuICAgKiAgTiAqIG4gPSBOXHJcbiAgICogIE4gKiAwID0gTlxyXG4gICAqICBOICogTiA9IE5cclxuICAgKiAgTiAqIEkgPSBOXHJcbiAgICogIEkgKiBuID0gSVxyXG4gICAqICBJICogMCA9IE5cclxuICAgKiAgSSAqIE4gPSBOXHJcbiAgICogIEkgKiBJID0gSVxyXG4gICAqXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhpcyBEZWNpbWFsIHRpbWVzIGB5YCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYCBzaWduaWZpY2FudFxyXG4gICAqIGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAgICpcclxuICAgKi9cclxuICBQLnRpbWVzID0gUC5tdWwgPSBmdW5jdGlvbiAoeSkge1xyXG4gICAgdmFyIGNhcnJ5LCBlLCBpLCBrLCByLCByTCwgdCwgeGRMLCB5ZEwsXHJcbiAgICAgIHggPSB0aGlzLFxyXG4gICAgICBDdG9yID0geC5jb25zdHJ1Y3RvcixcclxuICAgICAgeGQgPSB4LmQsXHJcbiAgICAgIHlkID0gKHkgPSBuZXcgQ3Rvcih5KSkuZDtcclxuXHJcbiAgICB5LnMgKj0geC5zO1xyXG5cclxuICAgICAvLyBJZiBlaXRoZXIgaXMgTmFOLCDCsUluZmluaXR5IG9yIMKxMC4uLlxyXG4gICAgaWYgKCF4ZCB8fCAheGRbMF0gfHwgIXlkIHx8ICF5ZFswXSkge1xyXG5cclxuICAgICAgcmV0dXJuIG5ldyBDdG9yKCF5LnMgfHwgeGQgJiYgIXhkWzBdICYmICF5ZCB8fCB5ZCAmJiAheWRbMF0gJiYgIXhkXHJcblxyXG4gICAgICAgIC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIGlzIE5hTi5cclxuICAgICAgICAvLyBSZXR1cm4gTmFOIGlmIHggaXMgwrEwIGFuZCB5IGlzIMKxSW5maW5pdHksIG9yIHkgaXMgwrEwIGFuZCB4IGlzIMKxSW5maW5pdHkuXHJcbiAgICAgICAgPyBOYU5cclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIMKxSW5maW5pdHkgaWYgZWl0aGVyIGlzIMKxSW5maW5pdHkuXHJcbiAgICAgICAgLy8gUmV0dXJuIMKxMCBpZiBlaXRoZXIgaXMgwrEwLlxyXG4gICAgICAgIDogIXhkIHx8ICF5ZCA/IHkucyAvIDAgOiB5LnMgKiAwKTtcclxuICAgIH1cclxuXHJcbiAgICBlID0gbWF0aGZsb29yKHguZSAvIExPR19CQVNFKSArIG1hdGhmbG9vcih5LmUgLyBMT0dfQkFTRSk7XHJcbiAgICB4ZEwgPSB4ZC5sZW5ndGg7XHJcbiAgICB5ZEwgPSB5ZC5sZW5ndGg7XHJcblxyXG4gICAgLy8gRW5zdXJlIHhkIHBvaW50cyB0byB0aGUgbG9uZ2VyIGFycmF5LlxyXG4gICAgaWYgKHhkTCA8IHlkTCkge1xyXG4gICAgICByID0geGQ7XHJcbiAgICAgIHhkID0geWQ7XHJcbiAgICAgIHlkID0gcjtcclxuICAgICAgckwgPSB4ZEw7XHJcbiAgICAgIHhkTCA9IHlkTDtcclxuICAgICAgeWRMID0gckw7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSW5pdGlhbGlzZSB0aGUgcmVzdWx0IGFycmF5IHdpdGggemVyb3MuXHJcbiAgICByID0gW107XHJcbiAgICByTCA9IHhkTCArIHlkTDtcclxuICAgIGZvciAoaSA9IHJMOyBpLS07KSByLnB1c2goMCk7XHJcblxyXG4gICAgLy8gTXVsdGlwbHkhXHJcbiAgICBmb3IgKGkgPSB5ZEw7IC0taSA+PSAwOykge1xyXG4gICAgICBjYXJyeSA9IDA7XHJcbiAgICAgIGZvciAoayA9IHhkTCArIGk7IGsgPiBpOykge1xyXG4gICAgICAgIHQgPSByW2tdICsgeWRbaV0gKiB4ZFtrIC0gaSAtIDFdICsgY2Fycnk7XHJcbiAgICAgICAgcltrLS1dID0gdCAlIEJBU0UgfCAwO1xyXG4gICAgICAgIGNhcnJ5ID0gdCAvIEJBU0UgfCAwO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByW2tdID0gKHJba10gKyBjYXJyeSkgJSBCQVNFIHwgMDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICBmb3IgKDsgIXJbLS1yTF07KSByLnBvcCgpO1xyXG5cclxuICAgIGlmIChjYXJyeSkgKytlO1xyXG4gICAgZWxzZSByLnNoaWZ0KCk7XHJcblxyXG4gICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgZm9yIChpID0gci5sZW5ndGg7ICFyWy0taV07KSByLnBvcCgpO1xyXG5cclxuICAgIHkuZCA9IHI7XHJcbiAgICB5LmUgPSBnZXRCYXNlMTBFeHBvbmVudChyLCBlKTtcclxuXHJcbiAgICByZXR1cm4gZXh0ZXJuYWwgPyBmaW5hbGlzZSh5LCBDdG9yLnByZWNpc2lvbiwgQ3Rvci5yb3VuZGluZykgOiB5O1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpbiBiYXNlIDIsIHJvdW5kIHRvIGBzZGAgc2lnbmlmaWNhbnRcclxuICAgKiBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm1gLlxyXG4gICAqXHJcbiAgICogSWYgdGhlIG9wdGlvbmFsIGBzZGAgYXJndW1lbnQgaXMgcHJlc2VudCB0aGVuIHJldHVybiBiaW5hcnkgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICpcclxuICAgKiBbc2RdIHtudW1iZXJ9IFNpZ25pZmljYW50IGRpZ2l0cy4gSW50ZWdlciwgMSB0byBNQVhfRElHSVRTIGluY2x1c2l2ZS5cclxuICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICpcclxuICAgKi9cclxuICBQLnRvQmluYXJ5ID0gZnVuY3Rpb24gKHNkLCBybSkge1xyXG4gICAgcmV0dXJuIHRvU3RyaW5nQmluYXJ5KHRoaXMsIDIsIHNkLCBybSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCByb3VuZGVkIHRvIGEgbWF4aW11bSBvZiBgZHBgXHJcbiAgICogZGVjaW1hbCBwbGFjZXMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm1gIG9yIGByb3VuZGluZ2AgaWYgYHJtYCBpcyBvbWl0dGVkLlxyXG4gICAqXHJcbiAgICogSWYgYGRwYCBpcyBvbWl0dGVkLCByZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsLlxyXG4gICAqXHJcbiAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVhfRElHSVRTIGluY2x1c2l2ZS5cclxuICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICpcclxuICAgKi9cclxuICBQLnRvRGVjaW1hbFBsYWNlcyA9IFAudG9EUCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICAgIHZhciB4ID0gdGhpcyxcclxuICAgICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gICAgeCA9IG5ldyBDdG9yKHgpO1xyXG4gICAgaWYgKGRwID09PSB2b2lkIDApIHJldHVybiB4O1xyXG5cclxuICAgIGNoZWNrSW50MzIoZHAsIDAsIE1BWF9ESUdJVFMpO1xyXG5cclxuICAgIGlmIChybSA9PT0gdm9pZCAwKSBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgICBlbHNlIGNoZWNrSW50MzIocm0sIDAsIDgpO1xyXG5cclxuICAgIHJldHVybiBmaW5hbGlzZSh4LCBkcCArIHguZSArIDEsIHJtKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaW4gZXhwb25lbnRpYWwgbm90YXRpb24gcm91bmRlZCB0b1xyXG4gICAqIGBkcGAgZml4ZWQgZGVjaW1hbCBwbGFjZXMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gICAqXHJcbiAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVhfRElHSVRTIGluY2x1c2l2ZS5cclxuICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICpcclxuICAgKi9cclxuICBQLnRvRXhwb25lbnRpYWwgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICB2YXIgc3RyLFxyXG4gICAgICB4ID0gdGhpcyxcclxuICAgICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gICAgaWYgKGRwID09PSB2b2lkIDApIHtcclxuICAgICAgc3RyID0gZmluaXRlVG9TdHJpbmcoeCwgdHJ1ZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjaGVja0ludDMyKGRwLCAwLCBNQVhfRElHSVRTKTtcclxuXHJcbiAgICAgIGlmIChybSA9PT0gdm9pZCAwKSBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgICAgIGVsc2UgY2hlY2tJbnQzMihybSwgMCwgOCk7XHJcblxyXG4gICAgICB4ID0gZmluYWxpc2UobmV3IEN0b3IoeCksIGRwICsgMSwgcm0pO1xyXG4gICAgICBzdHIgPSBmaW5pdGVUb1N0cmluZyh4LCB0cnVlLCBkcCArIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB4LmlzTmVnKCkgJiYgIXguaXNaZXJvKCkgPyAnLScgKyBzdHIgOiBzdHI7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGluIG5vcm1hbCAoZml4ZWQtcG9pbnQpIG5vdGF0aW9uIHRvXHJcbiAgICogYGRwYCBmaXhlZCBkZWNpbWFsIHBsYWNlcyBhbmQgcm91bmRlZCB1c2luZyByb3VuZGluZyBtb2RlIGBybWAgb3IgYHJvdW5kaW5nYCBpZiBgcm1gIGlzXHJcbiAgICogb21pdHRlZC5cclxuICAgKlxyXG4gICAqIEFzIHdpdGggSmF2YVNjcmlwdCBudW1iZXJzLCAoLTApLnRvRml4ZWQoMCkgaXMgJzAnLCBidXQgZS5nLiAoLTAuMDAwMDEpLnRvRml4ZWQoMCkgaXMgJy0wJy5cclxuICAgKlxyXG4gICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYX0RJR0lUUyBpbmNsdXNpdmUuXHJcbiAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAqXHJcbiAgICogKC0wKS50b0ZpeGVkKDApIGlzICcwJywgYnV0ICgtMC4xKS50b0ZpeGVkKDApIGlzICctMCcuXHJcbiAgICogKC0wKS50b0ZpeGVkKDEpIGlzICcwLjAnLCBidXQgKC0wLjAxKS50b0ZpeGVkKDEpIGlzICctMC4wJy5cclxuICAgKiAoLTApLnRvRml4ZWQoMykgaXMgJzAuMDAwJy5cclxuICAgKiAoLTAuNSkudG9GaXhlZCgwKSBpcyAnLTAnLlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC50b0ZpeGVkID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gICAgdmFyIHN0ciwgeSxcclxuICAgICAgeCA9IHRoaXMsXHJcbiAgICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICAgIGlmIChkcCA9PT0gdm9pZCAwKSB7XHJcbiAgICAgIHN0ciA9IGZpbml0ZVRvU3RyaW5nKHgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY2hlY2tJbnQzMihkcCwgMCwgTUFYX0RJR0lUUyk7XHJcblxyXG4gICAgICBpZiAocm0gPT09IHZvaWQgMCkgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gICAgICBlbHNlIGNoZWNrSW50MzIocm0sIDAsIDgpO1xyXG5cclxuICAgICAgeSA9IGZpbmFsaXNlKG5ldyBDdG9yKHgpLCBkcCArIHguZSArIDEsIHJtKTtcclxuICAgICAgc3RyID0gZmluaXRlVG9TdHJpbmcoeSwgZmFsc2UsIGRwICsgeS5lICsgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gYWRkIHRoZSBtaW51cyBzaWduIGxvb2sgYXQgdGhlIHZhbHVlIGJlZm9yZSBpdCB3YXMgcm91bmRlZCxcclxuICAgIC8vIGkuZS4gbG9vayBhdCBgeGAgcmF0aGVyIHRoYW4gYHlgLlxyXG4gICAgcmV0dXJuIHguaXNOZWcoKSAmJiAheC5pc1plcm8oKSA/ICctJyArIHN0ciA6IHN0cjtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYW4gYXJyYXkgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgYXMgYSBzaW1wbGUgZnJhY3Rpb24gd2l0aCBhbiBpbnRlZ2VyXHJcbiAgICogbnVtZXJhdG9yIGFuZCBhbiBpbnRlZ2VyIGRlbm9taW5hdG9yLlxyXG4gICAqXHJcbiAgICogVGhlIGRlbm9taW5hdG9yIHdpbGwgYmUgYSBwb3NpdGl2ZSBub24temVybyB2YWx1ZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHNwZWNpZmllZCBtYXhpbXVtXHJcbiAgICogZGVub21pbmF0b3IuIElmIGEgbWF4aW11bSBkZW5vbWluYXRvciBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgZGVub21pbmF0b3Igd2lsbCBiZSB0aGUgbG93ZXN0XHJcbiAgICogdmFsdWUgbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgbnVtYmVyIGV4YWN0bHkuXHJcbiAgICpcclxuICAgKiBbbWF4RF0ge251bWJlcnxzdHJpbmd8RGVjaW1hbH0gTWF4aW11bSBkZW5vbWluYXRvci4gSW50ZWdlciA+PSAxIGFuZCA8IEluZmluaXR5LlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC50b0ZyYWN0aW9uID0gZnVuY3Rpb24gKG1heEQpIHtcclxuICAgIHZhciBkLCBkMCwgZDEsIGQyLCBlLCBrLCBuLCBuMCwgbjEsIHByLCBxLCByLFxyXG4gICAgICB4ID0gdGhpcyxcclxuICAgICAgeGQgPSB4LmQsXHJcbiAgICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICAgIGlmICgheGQpIHJldHVybiBuZXcgQ3Rvcih4KTtcclxuXHJcbiAgICBuMSA9IGQwID0gbmV3IEN0b3IoMSk7XHJcbiAgICBkMSA9IG4wID0gbmV3IEN0b3IoMCk7XHJcblxyXG4gICAgZCA9IG5ldyBDdG9yKGQxKTtcclxuICAgIGUgPSBkLmUgPSBnZXRQcmVjaXNpb24oeGQpIC0geC5lIC0gMTtcclxuICAgIGsgPSBlICUgTE9HX0JBU0U7XHJcbiAgICBkLmRbMF0gPSBtYXRocG93KDEwLCBrIDwgMCA/IExPR19CQVNFICsgayA6IGspO1xyXG5cclxuICAgIGlmIChtYXhEID09IG51bGwpIHtcclxuXHJcbiAgICAgIC8vIGQgaXMgMTAqKmUsIHRoZSBtaW5pbXVtIG1heC1kZW5vbWluYXRvciBuZWVkZWQuXHJcbiAgICAgIG1heEQgPSBlID4gMCA/IGQgOiBuMTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG4gPSBuZXcgQ3RvcihtYXhEKTtcclxuICAgICAgaWYgKCFuLmlzSW50KCkgfHwgbi5sdChuMSkpIHRocm93IEVycm9yKGludmFsaWRBcmd1bWVudCArIG4pO1xyXG4gICAgICBtYXhEID0gbi5ndChkKSA/IChlID4gMCA/IGQgOiBuMSkgOiBuO1xyXG4gICAgfVxyXG5cclxuICAgIGV4dGVybmFsID0gZmFsc2U7XHJcbiAgICBuID0gbmV3IEN0b3IoZGlnaXRzVG9TdHJpbmcoeGQpKTtcclxuICAgIHByID0gQ3Rvci5wcmVjaXNpb247XHJcbiAgICBDdG9yLnByZWNpc2lvbiA9IGUgPSB4ZC5sZW5ndGggKiBMT0dfQkFTRSAqIDI7XHJcblxyXG4gICAgZm9yICg7OykgIHtcclxuICAgICAgcSA9IGRpdmlkZShuLCBkLCAwLCAxLCAxKTtcclxuICAgICAgZDIgPSBkMC5wbHVzKHEudGltZXMoZDEpKTtcclxuICAgICAgaWYgKGQyLmNtcChtYXhEKSA9PSAxKSBicmVhaztcclxuICAgICAgZDAgPSBkMTtcclxuICAgICAgZDEgPSBkMjtcclxuICAgICAgZDIgPSBuMTtcclxuICAgICAgbjEgPSBuMC5wbHVzKHEudGltZXMoZDIpKTtcclxuICAgICAgbjAgPSBkMjtcclxuICAgICAgZDIgPSBkO1xyXG4gICAgICBkID0gbi5taW51cyhxLnRpbWVzKGQyKSk7XHJcbiAgICAgIG4gPSBkMjtcclxuICAgIH1cclxuXHJcbiAgICBkMiA9IGRpdmlkZShtYXhELm1pbnVzKGQwKSwgZDEsIDAsIDEsIDEpO1xyXG4gICAgbjAgPSBuMC5wbHVzKGQyLnRpbWVzKG4xKSk7XHJcbiAgICBkMCA9IGQwLnBsdXMoZDIudGltZXMoZDEpKTtcclxuICAgIG4wLnMgPSBuMS5zID0geC5zO1xyXG5cclxuICAgIC8vIERldGVybWluZSB3aGljaCBmcmFjdGlvbiBpcyBjbG9zZXIgdG8geCwgbjAvZDAgb3IgbjEvZDE/XHJcbiAgICByID0gZGl2aWRlKG4xLCBkMSwgZSwgMSkubWludXMoeCkuYWJzKCkuY21wKGRpdmlkZShuMCwgZDAsIGUsIDEpLm1pbnVzKHgpLmFicygpKSA8IDFcclxuICAgICAgICA/IFtuMSwgZDFdIDogW24wLCBkMF07XHJcblxyXG4gICAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcclxuICAgIGV4dGVybmFsID0gdHJ1ZTtcclxuXHJcbiAgICByZXR1cm4gcjtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaW4gYmFzZSAxNiwgcm91bmQgdG8gYHNkYCBzaWduaWZpY2FudFxyXG4gICAqIGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGBybWAuXHJcbiAgICpcclxuICAgKiBJZiB0aGUgb3B0aW9uYWwgYHNkYCBhcmd1bWVudCBpcyBwcmVzZW50IHRoZW4gcmV0dXJuIGJpbmFyeSBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgKlxyXG4gICAqIFtzZF0ge251bWJlcn0gU2lnbmlmaWNhbnQgZGlnaXRzLiBJbnRlZ2VyLCAxIHRvIE1BWF9ESUdJVFMgaW5jbHVzaXZlLlxyXG4gICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAudG9IZXhhZGVjaW1hbCA9IFAudG9IZXggPSBmdW5jdGlvbiAoc2QsIHJtKSB7XHJcbiAgICByZXR1cm4gdG9TdHJpbmdCaW5hcnkodGhpcywgMTYsIHNkLCBybSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXhhY3QgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGluIGEgY29tcGFjdCBiYXNlLTg4IGJhc2VkIGZvcm1hdC5cclxuICAgKlxyXG4gICAqIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBvZiB0aGUgc3RyaW5nIHdpbGwgYWx3YXlzIGJlIGVxdWFsIHRvIG9yIGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mXHJcbiAgICogY2hhcmFjdGVycyByZXR1cm5lZCBieSBgdG9TdHJpbmdgIG9yIGB0b0V4cG9uZW50aWFsYCAtIHVzdWFsbHkganVzdCBvdmVyIGhhbGYgYXMgbWFueS5cclxuICAgKlxyXG4gICAqIFRoZSBvcmlnaW5hbCBEZWNpbWFsIHZhbHVlIGNhbiBiZSByZWNyZWF0ZWQgYnkgcGFzc2luZyB0aGUgc3RyaW5nIHRvIGBEZWNpbWFsLmZyb21KU09OYC5cclxuICAgKlxyXG4gICAqIEJhc2UgODggYWxwaGFiZXQ6XHJcbiAgICogMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVohIyQlKCkqKywtLi86Oz0/QFtdXl9ge3x9flxyXG4gICAqXHJcbiAgICogVGhlIGZvbGxvd2luZyA3IHByaW50YWJsZSBBU0NJSSBjaGFyYWN0ZXJzIGFyZSBub3QgdXNlZFxyXG4gICAqIChzcGFjZSkgXFwgXCIgJiAnIDwgPlxyXG4gICAqIHNvIHRoZSByZXR1cm4gdmFsdWUgaXMgc2FmZSBmb3Igc3RyaW5ncywgSFRNTCwgSlNPTiwgYW5kIFhNTC5cclxuICAgKlxyXG4gICAqICAgICAwICAgMCAgICAgZyAgMTYgICAgdyAgMzIgICAgTSAgNDggICAgJCAgNjQgICAgXSAgODBcclxuICAgKiAgICAgMSAgIDEgICAgIGggIDE3ICAgIHggIDMzICAgIE4gIDQ5ICAgICUgIDY1ICAgIF4gIDgxXHJcbiAgICogICAgIDIgICAyICAgICBpICAxOCAgICB5ICAzNCAgICBPICA1MCAgICAoICA2NiAgICBfICA4MlxyXG4gICAqICAgICAzICAgMyAgICAgaiAgMTkgICAgeiAgMzUgICAgUCAgNTEgICAgKSAgNjcgICAgYCAgODNcclxuICAgKiAgICAgNCAgIDQgICAgIGsgIDIwICAgIEEgIDM2ICAgIFEgIDUyICAgICogIDY4ICAgIHsgIDg0XHJcbiAgICogICAgIDUgICA1ICAgICBsICAyMSAgICBCICAzNyAgICBSICA1MyAgICArICA2OSAgICB8ICA4NVxyXG4gICAqICAgICA2ICAgNiAgICAgbSAgMjIgICAgQyAgMzggICAgUyAgNTQgICAgLCAgNzAgICAgfSAgODZcclxuICAgKiAgICAgNyAgIDcgICAgIG4gIDIzICAgIEQgIDM5ICAgIFQgIDU1ICAgIC0gIDcxICAgIH4gIDg3XHJcbiAgICogICAgIDggICA4ICAgICBvICAyNCAgICBFICA0MCAgICBVICA1NiAgICAuICA3MlxyXG4gICAqICAgICA5ICAgOSAgICAgcCAgMjUgICAgRiAgNDEgICAgViAgNTcgICAgLyAgNzNcclxuICAgKiAgICAgYSAgMTAgICAgIHEgIDI2ICAgIEcgIDQyICAgIFcgIDU4ICAgIDogIDc0XHJcbiAgICogICAgIGIgIDExICAgICByICAyNyAgICBIICA0MyAgICBYICA1OSAgICA7ICA3NVxyXG4gICAqICAgICBjICAxMiAgICAgcyAgMjggICAgSSAgNDQgICAgWSAgNjAgICAgPSAgNzZcclxuICAgKiAgICAgZCAgMTMgICAgIHQgIDI5ICAgIEogIDQ1ICAgIFogIDYxICAgID8gIDc3XHJcbiAgICogICAgIGUgIDE0ICAgICB1ICAzMCAgICBLICA0NiAgICAhICA2MiAgICBAICA3OFxyXG4gICAqICAgICBmICAxNSAgICAgdiAgMzEgICAgTCAgNDcgICAgIyAgNjMgICAgWyAgNzlcclxuICAgKlxyXG4gICAqIElmIHRoZSByZXR1cm4gdmFsdWUgaXMganVzdCBvbmUgY2hhcmFjdGVyLCBpdCByZXByZXNlbnRzOlxyXG4gICAqIDAtODEgIFtbMCwgNDBdWy0wLCAtNDBdXVxyXG4gICAqIDgyICAgIC1JbmZpbml0eVxyXG4gICAqIDgzICAgICtJbmZpbml0eVxyXG4gICAqIDg0ICAgIE5hTlxyXG4gICAqIDg1LTg3IGZyZWVcclxuICAgKlxyXG4gICAqICAgNjQgMzIgMTYgIDggIDQgIDIgIDFcclxuICAgKiAgICAxICAwICAxICAwICAxICAxICAxID0gODdcclxuICAgKlxyXG4gICAqL1xyXG4gICBQLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBhcnIsIGUsIGksIGssIGxlbiwgbiwgciwgc3RyLFxyXG4gICAgICB4ID0gdGhpcyxcclxuICAgICAgaXNOZWcgPSB4LnMgPCAwO1xyXG5cclxuICAgIC8vIC1JbmZpbml0eS9JbmZpbml0eS9OYU4uXHJcbiAgICBpZiAoIXguZCkgcmV0dXJuIE5VTUVSQUxTLmNoYXJBdCh4LnMgPyBpc05lZyA/IDgyIDogODMgOiA4NCk7XHJcbiAgICBlID0geC5lO1xyXG5cclxuICAgIC8vIFNtYWxsIGludGVnZXIuXHJcbiAgICBpZiAoeC5kLmxlbmd0aCA9PT0gMSAmJiBlIDwgNCAmJiBlID49IDApIHtcclxuICAgICAgbiA9IHguZFswXTtcclxuXHJcbiAgICAgIGlmIChuIDwgMjg1Nykge1xyXG5cclxuICAgICAgICAvLyBPbmUgY2hhcmFjdGVyLlxyXG4gICAgICAgIC8vIFtbMCwgNDBdWy0wLCAtNDBdXVxyXG4gICAgICAgIGlmIChuIDwgNDEpIHJldHVybiBOVU1FUkFMUy5jaGFyQXQoaXNOZWcgPyBuICsgNDEgOiBuKTtcclxuXHJcbiAgICAgICAgLy8gVHdvIGNoYXJhY3RlcnMuIEhpZ2ggYml0IG9mIGZpcnN0IGNoYXJhY3RlciB1bnNldC5cclxuICAgICAgICAvLyAwWFhYWFhYXHJcbiAgICAgICAgLy8gNjMqODggKyA4NyA9IDU2MzEgPSA1NjMyIHZhbHVlcywgNTYzMi8yID0gMjgxNlxyXG4gICAgICAgIC8vIFtbMCwgMjgxNV1bMjgxNiwgNTYzMV1dICAoMjgxNiAqIDIgPSA1NjMyIHZhbHVlcylcclxuICAgICAgICAvLyBbWzAsIDI4MTVdWy0wLCAtMjgxNV1dXHJcbiAgICAgICAgLy8gW1s0MSwgMjg1Nl1bLTQxLCAtMjg1Nl1dXHJcbiAgICAgICAgbiAtPSA0MTtcclxuICAgICAgICBpZiAoaXNOZWcpIG4gKz0gMjgxNjtcclxuICAgICAgICBrID0gbiAvIDg4IHwgMDtcclxuXHJcbiAgICAgICAgcmV0dXJuIE5VTUVSQUxTLmNoYXJBdChrKSArIE5VTUVSQUxTLmNoYXJBdChuIC0gayAqIDg4KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHN0ciA9IGRpZ2l0c1RvU3RyaW5nKHguZCk7XHJcbiAgICByID0gJyc7XHJcblxyXG4gICAgLy8gVmFsdWVzIHdpdGggYSBzbWFsbCBleHBvbmVudC4gU2V0IGhpZ2ggYml0LlxyXG4gICAgLy8gUG9zaXRpdmUgdmFsdWU6IDEwMFhYWFhcclxuICAgIC8vIDEgMCAwIHtleHBvbmVudCBbMCwgMTVdIC0+IFstNywgOF19XHJcbiAgICBpZiAoIWlzTmVnICYmIGUgPD0gOCAmJiBlID49IC03KSB7XHJcbiAgICAgIGsgPSA2NCArIGUgKyA3O1xyXG5cclxuICAgIC8vIE5lZ2F0aXZlIHZhbHVlOiAxMDEwWFhYXHJcbiAgICAvLyAxIDAgMSAwIHtleHBvbmVudCBbMCwgN10gLT4gWy0zLCA0XX1cclxuICAgIH0gZWxzZSBpZiAoaXNOZWcgJiYgZSA8PSA0ICYmIGUgPj0gLTMpIHtcclxuICAgICAgayA9IDY0ICsgMTYgKyBlICsgMztcclxuXHJcbiAgICAvLyBJbnRlZ2VyIHdpdGhvdXQgdHJhaWxpbmcgemVyb3M6IDBYMDAwMDBcclxuICAgIC8vIDAge2lzIG5lZ2F0aXZlfSAwIDAgMCAwIDBcclxuICAgIH0gZWxzZSBpZiAoc3RyLmxlbmd0aCA9PT0gZSArIDEpIHtcclxuICAgICAgayA9IDMyICogaXNOZWc7XHJcblxyXG4gICAgLy8gQWxsIHJlbWFpbmluZyB2YWx1ZXM6IDBYWFhYWFhcclxuICAgIC8vIFJlc3VsdCB3aWxsIGhhdmUgYXQgbGVhc3QgMyBjaGFyYWN0ZXJzLlxyXG4gICAgLy8gMCB7aXMgbmVnYXRpdmV9IHtpcyBleHBvbmVudCBuZWdhdGl2ZX0ge2V4cG9uZW50IGNoYXJhY3RlciBjb3VudCBbMSwgMTVdfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgayA9IDMyICogaXNOZWcgKyAxNiAqIChlIDwgMCk7XHJcbiAgICAgIGUgPSBNYXRoLmFicyhlKTtcclxuXHJcbiAgICAgIC8vIE9uZSBjaGFyYWN0ZXIgdG8gcmVwcmVzZW50IHRoZSBleHBvbmVudC5cclxuICAgICAgaWYgKGUgPCA4OCkgIHtcclxuICAgICAgICBrICs9IDE7XHJcbiAgICAgICAgciA9IE5VTUVSQUxTLmNoYXJBdChlKTtcclxuXHJcbiAgICAgIC8vIFR3byBjaGFyYWN0ZXJzIHRvIHJlcHJlc2VudCB0aGUgZXhwb25lbnQuXHJcbiAgICAgIC8vIDg3Kjg4ICsgODcgPSA3NzQzXHJcbiAgICAgIH0gZWxzZSBpZiAoZSA8IDc3NDQpIHtcclxuICAgICAgICBrICs9IDI7XHJcbiAgICAgICAgbiA9IGUgLyA4OCB8IDA7XHJcbiAgICAgICAgciA9IE5VTUVSQUxTLmNoYXJBdChuKSArIE5VTUVSQUxTLmNoYXJBdChlIC0gbiAqIDg4KTtcclxuXHJcbiAgICAgIC8vIE1vcmUgdGhhbiB0d28gY2hhcmFjdGVycyB0byByZXByZXNlbnQgdGhlIGV4cG9uZW50LlxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGFyciA9IGNvbnZlcnRCYXNlKFN0cmluZyhlKSwgMTAsIDg4KTtcclxuICAgICAgICBsZW4gPSBhcnIubGVuZ3RoO1xyXG4gICAgICAgIGsgKz0gbGVuO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykgciArPSBOVU1FUkFMUy5jaGFyQXQoYXJyW2ldKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEF0IHRoaXMgcG9pbnQgciBjb250YWlucyB0aGUgY2hhcmFjdGVycyBpbiBiYXNlIDg4IHJlcHJlc2VudGluZyB0aGUgZXhwb25lbnQgdmFsdWUuXHJcbiAgICAvLyBQcmVwZW5kIHRoZSBmaXJzdCBjaGFyYWN0ZXIsIHdoaWNoIGRlc2NyaWJlcyB0aGUgc2lnbiwgdGhlIGV4cG9uZW50IHNpZ24sIGFuZCB0aGUgbnVtYmVyIG9mXHJcbiAgICAvLyBjaGFyYWN0ZXJzIHRoYXQgZm9sbG93IHdoaWNoIHJlcHJlc2VudCB0aGUgZXhwb25lbnQgdmFsdWUuXHJcbiAgICByID0gTlVNRVJBTFMuY2hhckF0KGspICsgcjtcclxuICAgIGFyciA9IGNvbnZlcnRCYXNlKHN0ciwgMTAsIDg4KTtcclxuICAgIGxlbiA9IGFyci5sZW5ndGg7XHJcblxyXG4gICAgLy8gQWRkIHRoZSBiYXNlIDg4IGNoYXJhY3RlcnMgdGhhdCByZXByZXNlbnQgdGhlIHNpZ25pZmljYW5kLlxyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSByICs9IE5VTUVSQUxTLmNoYXJBdChhcnJbaV0pO1xyXG5cclxuICAgIHJldHVybiByO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybnMgYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgbmVhcmVzdCBtdWx0aXBsZSBvZiB0aGUgbWFnbml0dWRlIG9mIGB5YCB0byB0aGUgdmFsdWVcclxuICAgKiBvZiB0aGlzIERlY2ltYWwuXHJcbiAgICpcclxuICAgKiBJZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGlzIGVxdWlkaXN0YW50IGZyb20gdHdvIG11bHRpcGxlcyBvZiBgeWAsIHRoZSByb3VuZGluZyBtb2RlIGBybWAsXHJcbiAgICogb3IgYERlY2ltYWwucm91bmRpbmdgIGlmIGBybWAgaXMgb21pdHRlZCwgZGV0ZXJtaW5lcyB0aGUgZGlyZWN0aW9uIG9mIHRoZSBuZWFyZXN0IG11bHRpcGxlLlxyXG4gICAqXHJcbiAgICogSW4gdGhlIGNvbnRleHQgb2YgdGhpcyBtZXRob2QsIHJvdW5kaW5nIG1vZGUgNCAoUk9VTkRfSEFMRl9VUCkgaXMgdGhlIHNhbWUgYXMgcm91bmRpbmcgbW9kZSAwXHJcbiAgICogKFJPVU5EX1VQKSwgYW5kIHNvIG9uLlxyXG4gICAqXHJcbiAgICogVGhlIHJldHVybiB2YWx1ZSB3aWxsIGFsd2F5cyBoYXZlIHRoZSBzYW1lIHNpZ24gYXMgdGhpcyBEZWNpbWFsLCB1bmxlc3MgZWl0aGVyIHRoaXMgRGVjaW1hbFxyXG4gICAqIG9yIGB5YCBpcyBOYU4sIGluIHdoaWNoIGNhc2UgdGhlIHJldHVybiB2YWx1ZSB3aWxsIGJlIGFsc28gYmUgTmFOLlxyXG4gICAqXHJcbiAgICogVGhlIHJldHVybiB2YWx1ZSBpcyBub3QgYWZmZWN0ZWQgYnkgdGhlIHZhbHVlIG9mIGBwcmVjaXNpb25gLlxyXG4gICAqXHJcbiAgICogeSB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfSBUaGUgbWFnbml0dWRlIHRvIHJvdW5kIHRvIGEgbXVsdGlwbGUgb2YuXHJcbiAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAqXHJcbiAgICogJ3RvTmVhcmVzdCgpIHJvdW5kaW5nIG1vZGUgbm90IGFuIGludGVnZXI6IHtybX0nXHJcbiAgICogJ3RvTmVhcmVzdCgpIHJvdW5kaW5nIG1vZGUgb3V0IG9mIHJhbmdlOiB7cm19J1xyXG4gICAqXHJcbiAgICovXHJcbiAgUC50b05lYXJlc3QgPSBmdW5jdGlvbiAoeSwgcm0pIHtcclxuICAgIHZhciB4ID0gdGhpcyxcclxuICAgICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gICAgeCA9IG5ldyBDdG9yKHgpO1xyXG5cclxuICAgIGlmICh5ID09IG51bGwpIHtcclxuXHJcbiAgICAgIC8vIElmIHggaXMgbm90IGZpbml0ZSwgcmV0dXJuIHguXHJcbiAgICAgIGlmICgheC5kKSByZXR1cm4geDtcclxuXHJcbiAgICAgIHkgPSBuZXcgQ3RvcigxKTtcclxuICAgICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgeSA9IG5ldyBDdG9yKHkpO1xyXG4gICAgICBpZiAocm0gIT09IHZvaWQgMCkgY2hlY2tJbnQzMihybSwgMCwgOCk7XHJcblxyXG4gICAgICAvLyBJZiB4IGlzIG5vdCBmaW5pdGUsIHJldHVybiB4IGlmIHkgaXMgbm90IE5hTiwgZWxzZSBOYU4uXHJcbiAgICAgIGlmICgheC5kKSByZXR1cm4geS5zID8geCA6IHk7XHJcblxyXG4gICAgICAvLyBJZiB5IGlzIG5vdCBmaW5pdGUsIHJldHVybiBJbmZpbml0eSB3aXRoIHRoZSBzaWduIG9mIHggaWYgeSBpcyBJbmZpbml0eSwgZWxzZSBOYU4uXHJcbiAgICAgIGlmICgheS5kKSB7XHJcbiAgICAgICAgaWYgKHkucykgeS5zID0geC5zO1xyXG4gICAgICAgIHJldHVybiB5O1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgeSBpcyBub3QgemVybywgY2FsY3VsYXRlIHRoZSBuZWFyZXN0IG11bHRpcGxlIG9mIHkgdG8geC5cclxuICAgIGlmICh5LmRbMF0pIHtcclxuICAgICAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuICAgICAgaWYgKHJtIDwgNCkgcm0gPSBbNCwgNSwgNywgOF1bcm1dO1xyXG4gICAgICB4ID0gZGl2aWRlKHgsIHksIDAsIHJtLCAxKS50aW1lcyh5KTtcclxuICAgICAgZXh0ZXJuYWwgPSB0cnVlO1xyXG4gICAgICBmaW5hbGlzZSh4KTtcclxuXHJcbiAgICAvLyBJZiB5IGlzIHplcm8sIHJldHVybiB6ZXJvIHdpdGggdGhlIHNpZ24gb2YgeC5cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHkucyA9IHgucztcclxuICAgICAgeCA9IHk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHg7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgY29udmVydGVkIHRvIGEgbnVtYmVyIHByaW1pdGl2ZS5cclxuICAgKiBaZXJvIGtlZXBzIGl0cyBzaWduLlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC50b051bWJlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiArdGhpcztcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaW4gYmFzZSA4LCByb3VuZCB0byBgc2RgIHNpZ25pZmljYW50XHJcbiAgICogZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJtYC5cclxuICAgKlxyXG4gICAqIElmIHRoZSBvcHRpb25hbCBgc2RgIGFyZ3VtZW50IGlzIHByZXNlbnQgdGhlbiByZXR1cm4gYmluYXJ5IGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAqXHJcbiAgICogW3NkXSB7bnVtYmVyfSBTaWduaWZpY2FudCBkaWdpdHMuIEludGVnZXIsIDEgdG8gTUFYX0RJR0lUUyBpbmNsdXNpdmUuXHJcbiAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC50b09jdGFsID0gZnVuY3Rpb24gKHNkLCBybSkge1xyXG4gICAgcmV0dXJuIHRvU3RyaW5nQmluYXJ5KHRoaXMsIDgsIHNkLCBybSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCByYWlzZWQgdG8gdGhlIHBvd2VyIGB5YCwgcm91bmRlZFxyXG4gICAqIHRvIGBwcmVjaXNpb25gIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAgICpcclxuICAgKiBFQ01BU2NyaXB0IGNvbXBsaWFudC5cclxuICAgKlxyXG4gICAqICAgcG93KHgsIE5hTikgICAgICAgICAgICAgICAgICAgICAgICAgICA9IE5hTlxyXG4gICAqICAgcG93KHgsIMKxMCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxXHJcblxyXG4gICAqICAgcG93KE5hTiwgbm9uLXplcm8pICAgICAgICAgICAgICAgICAgICA9IE5hTlxyXG4gICAqICAgcG93KGFicyh4KSA+IDEsICtJbmZpbml0eSkgICAgICAgICAgICA9ICtJbmZpbml0eVxyXG4gICAqICAgcG93KGFicyh4KSA+IDEsIC1JbmZpbml0eSkgICAgICAgICAgICA9ICswXHJcbiAgICogICBwb3coYWJzKHgpID09IDEsIMKxSW5maW5pdHkpICAgICAgICAgICA9IE5hTlxyXG4gICAqICAgcG93KGFicyh4KSA8IDEsICtJbmZpbml0eSkgICAgICAgICAgICA9ICswXHJcbiAgICogICBwb3coYWJzKHgpIDwgMSwgLUluZmluaXR5KSAgICAgICAgICAgID0gK0luZmluaXR5XHJcbiAgICogICBwb3coK0luZmluaXR5LCB5ID4gMCkgICAgICAgICAgICAgICAgID0gK0luZmluaXR5XHJcbiAgICogICBwb3coK0luZmluaXR5LCB5IDwgMCkgICAgICAgICAgICAgICAgID0gKzBcclxuICAgKiAgIHBvdygtSW5maW5pdHksIG9kZCBpbnRlZ2VyID4gMCkgICAgICAgPSAtSW5maW5pdHlcclxuICAgKiAgIHBvdygtSW5maW5pdHksIGV2ZW4gaW50ZWdlciA+IDApICAgICAgPSArSW5maW5pdHlcclxuICAgKiAgIHBvdygtSW5maW5pdHksIG9kZCBpbnRlZ2VyIDwgMCkgICAgICAgPSAtMFxyXG4gICAqICAgcG93KC1JbmZpbml0eSwgZXZlbiBpbnRlZ2VyIDwgMCkgICAgICA9ICswXHJcbiAgICogICBwb3coKzAsIHkgPiAwKSAgICAgICAgICAgICAgICAgICAgICAgID0gKzBcclxuICAgKiAgIHBvdygrMCwgeSA8IDApICAgICAgICAgICAgICAgICAgICAgICAgPSArSW5maW5pdHlcclxuICAgKiAgIHBvdygtMCwgb2RkIGludGVnZXIgPiAwKSAgICAgICAgICAgICAgPSAtMFxyXG4gICAqICAgcG93KC0wLCBldmVuIGludGVnZXIgPiAwKSAgICAgICAgICAgICA9ICswXHJcbiAgICogICBwb3coLTAsIG9kZCBpbnRlZ2VyIDwgMCkgICAgICAgICAgICAgID0gLUluZmluaXR5XHJcbiAgICogICBwb3coLTAsIGV2ZW4gaW50ZWdlciA8IDApICAgICAgICAgICAgID0gK0luZmluaXR5XHJcbiAgICogICBwb3coZmluaXRlIHggPCAwLCBmaW5pdGUgbm9uLWludGVnZXIpID0gTmFOXHJcbiAgICpcclxuICAgKiBGb3Igbm9uLWludGVnZXIgb3IgdmVyeSBsYXJnZSBleHBvbmVudHMgcG93KHgsIHkpIGlzIGNhbGN1bGF0ZWQgdXNpbmdcclxuICAgKlxyXG4gICAqICAgeF55ID0gZXhwKHkqbG4oeCkpXHJcbiAgICpcclxuICAgKiBBc3N1bWluZyB0aGUgZmlyc3QgMTUgcm91bmRpbmcgZGlnaXRzIGFyZSBlYWNoIGVxdWFsbHkgbGlrZWx5IHRvIGJlIGFueSBkaWdpdCAwLTksIHRoZVxyXG4gICAqIHByb2JhYmlsaXR5IG9mIGFuIGluY29ycmVjdGx5IHJvdW5kZWQgcmVzdWx0XHJcbiAgICogUChbNDldOXsxNH0gfCBbNTBdMHsxNH0pID0gMiAqIDAuMiAqIDEwXi0xNCA9IDRlLTE1ID0gMS8yLjVlKzE0XHJcbiAgICogaS5lLiAxIGluIDI1MCwwMDAsMDAwLDAwMCwwMDBcclxuICAgKlxyXG4gICAqIElmIGEgcmVzdWx0IGlzIGluY29ycmVjdGx5IHJvdW5kZWQgdGhlIG1heGltdW0gZXJyb3Igd2lsbCBiZSAxIHVscCAodW5pdCBpbiBsYXN0IHBsYWNlKS5cclxuICAgKlxyXG4gICAqIHkge251bWJlcnxzdHJpbmd8RGVjaW1hbH0gVGhlIHBvd2VyIHRvIHdoaWNoIHRvIHJhaXNlIHRoaXMgRGVjaW1hbC5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAudG9Qb3dlciA9IFAucG93ID0gZnVuY3Rpb24gKHkpIHtcclxuICAgIHZhciBlLCBrLCBwciwgciwgcm0sIHNpZ24sIHlJc0ludCxcclxuICAgICAgeCA9IHRoaXMsXHJcbiAgICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yLFxyXG4gICAgICB5biA9ICsoeSA9IG5ldyBDdG9yKHkpKTtcclxuXHJcbiAgICAvLyBFaXRoZXIgwrFJbmZpbml0eSwgTmFOIG9yIMKxMD9cclxuICAgIGlmICgheC5kIHx8ICF5LmQgfHwgIXguZFswXSB8fCAheS5kWzBdKSByZXR1cm4gIG5ldyBDdG9yKG1hdGhwb3coK3gsIHluKSk7XHJcblxyXG4gICAgeCA9IG5ldyBDdG9yKHgpO1xyXG5cclxuICAgIGlmICh4LmVxKDEpKSByZXR1cm4geDtcclxuXHJcbiAgICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG4gICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG5cclxuICAgIGlmICh5LmVxKDEpKSByZXR1cm4gZmluYWxpc2UoeCwgcHIsIHJtKTtcclxuXHJcbiAgICBlID0gbWF0aGZsb29yKHkuZSAvIExPR19CQVNFKTtcclxuICAgIGsgPSB5LmQubGVuZ3RoIC0gMTtcclxuICAgIHlJc0ludCA9IGUgPj0gaztcclxuICAgIHNpZ24gPSB4LnM7XHJcblxyXG4gICAgaWYgKCF5SXNJbnQpIHtcclxuICAgICAgaWYgKHNpZ24gPCAwKSByZXR1cm4gbmV3IEN0b3IoTmFOKTtcclxuXHJcbiAgICAvLyBJZiB5IGlzIGEgc21hbGwgaW50ZWdlciB1c2UgdGhlICdleHBvbmVudGlhdGlvbiBieSBzcXVhcmluZycgYWxnb3JpdGhtLlxyXG4gICAgfSBlbHNlIGlmICgoayA9IHluIDwgMCA/IC15biA6IHluKSA8PSBNQVhfU0FGRV9JTlRFR0VSKSB7XHJcbiAgICAgIHIgPSBpbnRQb3coQ3RvciwgeCwgaywgcHIpO1xyXG4gICAgICByZXR1cm4geS5zIDwgMCA/IG5ldyBDdG9yKDEpLmRpdihyKSA6IGZpbmFsaXNlKHIsIHByLCBybSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVzdWx0IGlzIG5lZ2F0aXZlIGlmIHggaXMgbmVnYXRpdmUgYW5kIHRoZSBsYXN0IGRpZ2l0IG9mIGludGVnZXIgeSBpcyBvZGQuXHJcbiAgICBzaWduID0gc2lnbiA8IDAgJiYgeS5kW01hdGgubWF4KGUsIGspXSAmIDEgPyAtMSA6IDE7XHJcblxyXG4gICAgLy8gRXN0aW1hdGUgcmVzdWx0IGV4cG9uZW50LlxyXG4gICAgLy8geF55ID0gMTBeZSwgIHdoZXJlIGUgPSB5ICogbG9nMTAoeClcclxuICAgIC8vIGxvZzEwKHgpID0gbG9nMTAoeF9zaWduaWZpY2FuZCkgKyB4X2V4cG9uZW50XHJcbiAgICAvLyBsb2cxMCh4X3NpZ25pZmljYW5kKSA9IGxuKHhfc2lnbmlmaWNhbmQpIC8gbG4oMTApXHJcbiAgICBrID0gbWF0aHBvdygreCwgeW4pO1xyXG4gICAgZSA9IGsgPT0gMCB8fCAhaXNGaW5pdGUoaylcclxuICAgICAgPyBtYXRoZmxvb3IoeW4gKiAoTWF0aC5sb2coJzAuJyArIGRpZ2l0c1RvU3RyaW5nKHguZCkpIC8gTWF0aC5MTjEwICsgeC5lICsgMSkpXHJcbiAgICAgIDogbmV3IEN0b3IoayArICcnKS5lO1xyXG5cclxuICAgIC8vIEVzdGltYXRlIG1heSBiZSBpbmNvcnJlY3QgZS5nLiB4OiAwLjk5OTk5OTk5OTk5OTk5OTk5OSwgeTogMi4yOSwgZTogMCwgci5lOiAtMS5cclxuXHJcbiAgICAvLyBPdmVyZmxvdy91bmRlcmZsb3c/XHJcbiAgICBpZiAoZSA+IEN0b3IubWF4RSArIDEgfHwgZSA8IEN0b3IubWluRSAtIDEpIHJldHVybiBuZXcgQ3RvcihlID4gMCA/IHNpZ24gLyAwIDogMCk7XHJcblxyXG4gICAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuICAgIEN0b3Iucm91bmRpbmcgPSB4LnMgPSAxO1xyXG5cclxuICAgIC8vIEVzdGltYXRlIHRoZSBleHRyYSBndWFyZCBkaWdpdHMgbmVlZGVkIHRvIGVuc3VyZSBmaXZlIGNvcnJlY3Qgcm91bmRpbmcgZGlnaXRzIGZyb21cclxuICAgIC8vIG5hdHVyYWxMb2dhcml0aG0oeCkuIEV4YW1wbGUgb2YgZmFpbHVyZSB3aXRob3V0IHRoZXNlIGV4dHJhIGRpZ2l0cyAocHJlY2lzaW9uOiAxMCk6XHJcbiAgICAvLyBuZXcgRGVjaW1hbCgyLjMyNDU2KS5wb3coJzIwODc5ODc0MzY1MzQ1NjYuNDY0MTEnKVxyXG4gICAgLy8gc2hvdWxkIGJlIDEuMTYyMzc3ODIzZSs3NjQ5MTQ5MDUxNzM4MTUsIGJ1dCBpcyAxLjE2MjM1NTgyM2UrNzY0OTE0OTA1MTczODE1XHJcbiAgICBrID0gTWF0aC5taW4oMTIsIChlICsgJycpLmxlbmd0aCk7XHJcblxyXG4gICAgLy8gciA9IHheeSA9IGV4cCh5KmxuKHgpKVxyXG4gICAgciA9IG5hdHVyYWxFeHBvbmVudGlhbCh5LnRpbWVzKG5hdHVyYWxMb2dhcml0aG0oeCwgcHIgKyBrKSksIHByKTtcclxuXHJcbiAgICAvLyBUcnVuY2F0ZSB0byB0aGUgcmVxdWlyZWQgcHJlY2lzaW9uIHBsdXMgZml2ZSByb3VuZGluZyBkaWdpdHMuXHJcbiAgICByID0gZmluYWxpc2UociwgcHIgKyA1LCAxKTtcclxuXHJcbiAgICAvLyBJZiB0aGUgcm91bmRpbmcgZGlnaXRzIGFyZSBbNDldOTk5OSBvciBbNTBdMDAwMCBpbmNyZWFzZSB0aGUgcHJlY2lzaW9uIGJ5IDEwIGFuZCByZWNhbGN1bGF0ZVxyXG4gICAgLy8gdGhlIHJlc3VsdC5cclxuICAgIGlmIChjaGVja1JvdW5kaW5nRGlnaXRzKHIuZCwgcHIsIHJtKSkge1xyXG4gICAgICBlID0gcHIgKyAxMDtcclxuXHJcbiAgICAgIC8vIFRydW5jYXRlIHRvIHRoZSBpbmNyZWFzZWQgcHJlY2lzaW9uIHBsdXMgZml2ZSByb3VuZGluZyBkaWdpdHMuXHJcbiAgICAgIHIgPSBmaW5hbGlzZShuYXR1cmFsRXhwb25lbnRpYWwoeS50aW1lcyhuYXR1cmFsTG9nYXJpdGhtKHgsIGUgKyBrKSksIGUpLCBlICsgNSwgMSk7XHJcblxyXG4gICAgICAvLyBDaGVjayBmb3IgMTQgbmluZXMgZnJvbSB0aGUgMm5kIHJvdW5kaW5nIGRpZ2l0ICh0aGUgZmlyc3Qgcm91bmRpbmcgZGlnaXQgbWF5IGJlIDQgb3IgOSkuXHJcbiAgICAgIGlmICgrZGlnaXRzVG9TdHJpbmcoci5kKS5zbGljZShwciArIDEsIHByICsgMTUpICsgMSA9PSAxZTE0KSB7XHJcbiAgICAgICAgciA9IGZpbmFsaXNlKHIsIHByICsgMSwgMCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByLnMgPSBzaWduO1xyXG4gICAgZXh0ZXJuYWwgPSB0cnVlO1xyXG4gICAgQ3Rvci5yb3VuZGluZyA9IHJtO1xyXG5cclxuICAgIHJldHVybiBmaW5hbGlzZShyLCBwciwgcm0pO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCByb3VuZGVkIHRvIGBzZGAgc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAgICogdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gICAqXHJcbiAgICogUmV0dXJuIGV4cG9uZW50aWFsIG5vdGF0aW9uIGlmIGBzZGAgaXMgbGVzcyB0aGFuIHRoZSBudW1iZXIgb2YgZGlnaXRzIG5lY2Vzc2FyeSB0byByZXByZXNlbnRcclxuICAgKiB0aGUgaW50ZWdlciBwYXJ0IG9mIHRoZSB2YWx1ZSBpbiBub3JtYWwgbm90YXRpb24uXHJcbiAgICpcclxuICAgKiBbc2RdIHtudW1iZXJ9IFNpZ25pZmljYW50IGRpZ2l0cy4gSW50ZWdlciwgMSB0byBNQVhfRElHSVRTIGluY2x1c2l2ZS5cclxuICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICpcclxuICAgKi9cclxuICBQLnRvUHJlY2lzaW9uID0gZnVuY3Rpb24gKHNkLCBybSkge1xyXG4gICAgdmFyIHN0cixcclxuICAgICAgeCA9IHRoaXMsXHJcbiAgICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICAgIGlmIChzZCA9PT0gdm9pZCAwKSB7XHJcbiAgICAgIHN0ciA9IGZpbml0ZVRvU3RyaW5nKHgsIHguZSA8PSBDdG9yLnRvRXhwTmVnIHx8IHguZSA+PSBDdG9yLnRvRXhwUG9zKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNoZWNrSW50MzIoc2QsIDEsIE1BWF9ESUdJVFMpO1xyXG5cclxuICAgICAgaWYgKHJtID09PSB2b2lkIDApIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICAgICAgZWxzZSBjaGVja0ludDMyKHJtLCAwLCA4KTtcclxuXHJcbiAgICAgIHggPSBmaW5hbGlzZShuZXcgQ3Rvcih4KSwgc2QsIHJtKTtcclxuICAgICAgc3RyID0gZmluaXRlVG9TdHJpbmcoeCwgc2QgPD0geC5lIHx8IHguZSA8PSBDdG9yLnRvRXhwTmVnLCBzZCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHguaXNOZWcoKSAmJiAheC5pc1plcm8oKSA/ICctJyArIHN0ciA6IHN0cjtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIHJvdW5kZWQgdG8gYSBtYXhpbXVtIG9mIGBzZGBcclxuICAgKiBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm1gLCBvciB0byBgcHJlY2lzaW9uYCBhbmQgYHJvdW5kaW5nYCByZXNwZWN0aXZlbHkgaWZcclxuICAgKiBvbWl0dGVkLlxyXG4gICAqXHJcbiAgICogW3NkXSB7bnVtYmVyfSBTaWduaWZpY2FudCBkaWdpdHMuIEludGVnZXIsIDEgdG8gTUFYX0RJR0lUUyBpbmNsdXNpdmUuXHJcbiAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAqXHJcbiAgICogJ3RvU0QoKSBkaWdpdHMgb3V0IG9mIHJhbmdlOiB7c2R9J1xyXG4gICAqICd0b1NEKCkgZGlnaXRzIG5vdCBhbiBpbnRlZ2VyOiB7c2R9J1xyXG4gICAqICd0b1NEKCkgcm91bmRpbmcgbW9kZSBub3QgYW4gaW50ZWdlcjoge3JtfSdcclxuICAgKiAndG9TRCgpIHJvdW5kaW5nIG1vZGUgb3V0IG9mIHJhbmdlOiB7cm19J1xyXG4gICAqXHJcbiAgICovXHJcbiAgUC50b1NpZ25pZmljYW50RGlnaXRzID0gUC50b1NEID0gZnVuY3Rpb24gKHNkLCBybSkge1xyXG4gICAgdmFyIHggPSB0aGlzLFxyXG4gICAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgICBpZiAoc2QgPT09IHZvaWQgMCkge1xyXG4gICAgICBzZCA9IEN0b3IucHJlY2lzaW9uO1xyXG4gICAgICBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjaGVja0ludDMyKHNkLCAxLCBNQVhfRElHSVRTKTtcclxuXHJcbiAgICAgIGlmIChybSA9PT0gdm9pZCAwKSBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgICAgIGVsc2UgY2hlY2tJbnQzMihybSwgMCwgOCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZpbmFsaXNlKG5ldyBDdG9yKHgpLCBzZCwgcm0pO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbC5cclxuICAgKlxyXG4gICAqIFJldHVybiBleHBvbmVudGlhbCBub3RhdGlvbiBpZiB0aGlzIERlY2ltYWwgaGFzIGEgcG9zaXRpdmUgZXhwb25lbnQgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuXHJcbiAgICogYHRvRXhwUG9zYCwgb3IgYSBuZWdhdGl2ZSBleHBvbmVudCBlcXVhbCB0byBvciBsZXNzIHRoYW4gYHRvRXhwTmVnYC5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgeCA9IHRoaXMsXHJcbiAgICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yLFxyXG4gICAgICBzdHIgPSBmaW5pdGVUb1N0cmluZyh4LCB4LmUgPD0gQ3Rvci50b0V4cE5lZyB8fCB4LmUgPj0gQ3Rvci50b0V4cFBvcyk7XHJcblxyXG4gICAgcmV0dXJuIHguaXNOZWcoKSAmJiAheC5pc1plcm8oKSA/ICctJyArIHN0ciA6IHN0cjtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIHRydW5jYXRlZCB0byBhIHdob2xlIG51bWJlci5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAudHJ1bmNhdGVkID0gUC50cnVuYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBmaW5hbGlzZShuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKSwgdGhpcy5lICsgMSwgMSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsLlxyXG4gICAqIFVubGlrZSBgdG9TdHJpbmdgLCBuZWdhdGl2ZSB6ZXJvIHdpbGwgaW5jbHVkZSB0aGUgbWludXMgc2lnbi5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAudmFsdWVPZiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB4ID0gdGhpcyxcclxuICAgICAgQ3RvciA9IHguY29uc3RydWN0b3IsXHJcbiAgICAgIHN0ciA9IGZpbml0ZVRvU3RyaW5nKHgsIHguZSA8PSBDdG9yLnRvRXhwTmVnIHx8IHguZSA+PSBDdG9yLnRvRXhwUG9zKTtcclxuXHJcbiAgICByZXR1cm4geC5pc05lZygpID8gJy0nICsgc3RyIDogc3RyO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gIC8vIEFkZCBhbGlhc2VzIHRvIG1hdGNoIEJpZ0RlY2ltYWwgbWV0aG9kIG5hbWVzLlxyXG4gIC8vIFAuYWRkID0gUC5wbHVzO1xyXG4gIFAuc3VidHJhY3QgPSBQLm1pbnVzO1xyXG4gIFAubXVsdGlwbHkgPSBQLnRpbWVzO1xyXG4gIFAuZGl2aWRlID0gUC5kaXY7XHJcbiAgUC5yZW1haW5kZXIgPSBQLm1vZDtcclxuICBQLmNvbXBhcmVUbyA9IFAuY21wO1xyXG4gIFAubmVnYXRlID0gUC5uZWc7XHJcbiAgICovXHJcblxyXG5cclxuICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciBEZWNpbWFsLnByb3RvdHlwZSAoUCkgYW5kL29yIERlY2ltYWwgbWV0aG9kcywgYW5kIHRoZWlyIGNhbGxlcnMuXHJcblxyXG5cclxuICAvKlxyXG4gICAqICBkaWdpdHNUb1N0cmluZyAgICAgICAgICAgUC5jdWJlUm9vdCwgUC5sb2dhcml0aG0sIFAuc3F1YXJlUm9vdCwgUC50b0ZyYWN0aW9uLCBQLnRvSlNPTixcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFAudG9Qb3dlciwgZmluaXRlVG9TdHJpbmcsIG5hdHVyYWxFeHBvbmVudGlhbCwgbmF0dXJhbExvZ2FyaXRobVxyXG4gICAqICBjaGVja0ludDMyICAgICAgICAgICAgICAgUC50b0RlY2ltYWxQbGFjZXMsIFAudG9FeHBvbmVudGlhbCwgUC50b0ZpeGVkLCBQLnRvTmVhcmVzdCxcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFAudG9QcmVjaXNpb24sIFAudG9TaWduaWZpY2FudERpZ2l0cywgdG9TdHJpbmdCaW5hcnksIHJhbmRvbVxyXG4gICAqICBjaGVja1JvdW5kaW5nRGlnaXRzICAgICAgUC5sb2dhcml0aG0sIFAudG9Qb3dlciwgbmF0dXJhbEV4cG9uZW50aWFsLCBuYXR1cmFsTG9nYXJpdGhtXHJcbiAgICogIGNvbnZlcnRCYXNlICAgICAgICAgICAgICBQLnRvSlNPTiwgdG9TdHJpbmdCaW5hcnksIGZyb21KU09OLCBwYXJzZU90aGVyXHJcbiAgICogIGNvcyAgICAgICAgICAgICAgICAgICAgICBQLmNvc1xyXG4gICAqICBkaXZpZGUgICAgICAgICAgICAgICAgICAgUC5hdGFuaCwgUC5jdWJlUm9vdCwgUC5kaXZpZGVkQnksIFAuZGl2aWRlZFRvSW50ZWdlckJ5LFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgUC5sb2dhcml0aG0sIFAubW9kdWxvLCBQLnNxdWFyZVJvb3QsIFAudGFuLCBQLnRhbmgsIFAudG9GcmFjdGlvbixcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFAudG9OZWFyZXN0LCB0b1N0cmluZ0JpbmFyeSwgbmF0dXJhbEV4cG9uZW50aWFsLCBuYXR1cmFsTG9nYXJpdGhtLFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGF5bG9yU2VyaWVzLCBhdGFuMiwgcGFyc2VPdGhlclxyXG4gICAqICBmaW5hbGlzZSAgICAgICAgICAgICAgICAgUC5hYnNvbHV0ZVZhbHVlLCBQLmF0YW4sIFAuYXRhbmgsIFAuY2VpbCwgUC5jb3MsIFAuY29zaCxcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFAuY3ViZVJvb3QsIFAuZGl2aWRlZFRvSW50ZWdlckJ5LCBQLmZsb29yLCBQLmxvZ2FyaXRobSwgUC5taW51cyxcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFAubW9kdWxvLCBQLm5lZ2F0ZWQsIFAucGx1cywgUC5yb3VuZCwgUC5zaW4sIFAuc2luaCwgUC5zcXVhcmVSb290LFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgUC50YW4sIFAudGltZXMsIFAudG9EZWNpbWFsUGxhY2VzLCBQLnRvRXhwb25lbnRpYWwsIFAudG9GaXhlZCxcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFAudG9OZWFyZXN0LCBQLnRvUG93ZXIsIFAudG9QcmVjaXNpb24sIFAudG9TaWduaWZpY2FudERpZ2l0cyxcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFAudHJ1bmNhdGVkLCBkaXZpZGUsIGdldExuMTAsIGdldFBpLCBuYXR1cmFsRXhwb25lbnRpYWwsXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBuYXR1cmFsTG9nYXJpdGhtLCBjZWlsLCBmbG9vciwgcm91bmQsIHRydW5jXHJcbiAgICogIGZpbml0ZVRvU3RyaW5nICAgICAgICAgICBQLnRvRXhwb25lbnRpYWwsIFAudG9GaXhlZCwgUC50b1ByZWNpc2lvbiwgUC50b1N0cmluZywgUC52YWx1ZU9mLFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9TdHJpbmdCaW5hcnlcclxuICAgKiAgZ2V0QmFzZTEwRXhwb25lbnQgICAgICAgIFAubWludXMsIFAucGx1cywgUC50aW1lcywgcGFyc2VPdGhlclxyXG4gICAqICBnZXRMbjEwICAgICAgICAgICAgICAgICAgUC5sb2dhcml0aG0sIG5hdHVyYWxMb2dhcml0aG1cclxuICAgKiAgZ2V0UGkgICAgICAgICAgICAgICAgICAgIFAuYWNvcywgUC5hc2luLCBQLmF0YW4sIHRvTGVzc1RoYW5IYWxmUGksIGF0YW4yXHJcbiAgICogIGdldFByZWNpc2lvbiAgICAgICAgICAgICBQLnByZWNpc2lvbiwgUC50b0ZyYWN0aW9uXHJcbiAgICogIGdldFplcm9TdHJpbmcgICAgICAgICAgICBkaWdpdHNUb1N0cmluZywgZmluaXRlVG9TdHJpbmdcclxuICAgKiAgaW50UG93ICAgICAgICAgICAgICAgICAgIFAudG9Qb3dlciwgcGFyc2VPdGhlclxyXG4gICAqICBpc09kZCAgICAgICAgICAgICAgICAgICAgdG9MZXNzVGhhbkhhbGZQaVxyXG4gICAqICBtYXhPck1pbiAgICAgICAgICAgICAgICAgbWF4LCBtaW5cclxuICAgKiAgbmF0dXJhbEV4cG9uZW50aWFsICAgICAgIFAubmF0dXJhbEV4cG9uZW50aWFsLCBQLnRvUG93ZXJcclxuICAgKiAgbmF0dXJhbExvZ2FyaXRobSAgICAgICAgIFAuYWNvc2gsIFAuYXNpbmgsIFAuYXRhbmgsIFAubG9nYXJpdGhtLCBQLm5hdHVyYWxMb2dhcml0aG0sXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBQLnRvUG93ZXIsIG5hdHVyYWxFeHBvbmVudGlhbFxyXG4gICAqICBub25GaW5pdGVUb1N0cmluZyAgICAgICAgZmluaXRlVG9TdHJpbmcsIHRvU3RyaW5nQmluYXJ5XHJcbiAgICogIHBhcnNlRGVjaW1hbCAgICAgICAgICAgICBEZWNpbWFsXHJcbiAgICogIHBhcnNlT3RoZXIgICAgICAgICAgICAgICBEZWNpbWFsXHJcbiAgICogIHNpbiAgICAgICAgICAgICAgICAgICAgICBQLnNpblxyXG4gICAqICB0YXlsb3JTZXJpZXMgICAgICAgICAgICAgUC5jb3NoLCBQLnNpbmgsIGNvcywgc2luXHJcbiAgICogIHRvTGVzc1RoYW5IYWxmUGkgICAgICAgICBQLmNvcywgUC5zaW5cclxuICAgKiAgdG9TdHJpbmdCaW5hcnkgICAgICAgICAgIFAudG9CaW5hcnksIFAudG9IZXhhZGVjaW1hbCwgUC50b09jdGFsXHJcbiAgICogIHRydW5jYXRlICAgICAgICAgICAgICAgICBpbnRQb3dcclxuICAgKlxyXG4gICAqICBUaHJvd3M6ICAgICAgICAgICAgICAgICAgUC5sb2dhcml0aG0sIFAucHJlY2lzaW9uLCBQLnRvRnJhY3Rpb24sIGNoZWNrSW50MzIsIGdldExuMTAsIGdldFBpLFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF0dXJhbExvZ2FyaXRobSwgY29uZmlnLCBmcm9tSlNPTiwgcGFyc2VPdGhlciwgcmFuZG9tLCBEZWNpbWFsICAgICAgICAgICAqXHJcbiAgICovXHJcblxyXG5cclxuICBmdW5jdGlvbiBkaWdpdHNUb1N0cmluZyhkKSB7XHJcbiAgICB2YXIgaSwgaywgd3MsXHJcbiAgICAgIGluZGV4T2ZMYXN0V29yZCA9IGQubGVuZ3RoIC0gMSxcclxuICAgICAgc3RyID0gJycsXHJcbiAgICAgIHcgPSBkWzBdO1xyXG5cclxuICAgIGlmIChpbmRleE9mTGFzdFdvcmQgPiAwKSB7XHJcbiAgICAgIHN0ciArPSB3O1xyXG4gICAgICBmb3IgKGkgPSAxOyBpIDwgaW5kZXhPZkxhc3RXb3JkOyBpKyspIHtcclxuICAgICAgICB3cyA9IGRbaV0gKyAnJztcclxuICAgICAgICBrID0gTE9HX0JBU0UgLSB3cy5sZW5ndGg7XHJcbiAgICAgICAgaWYgKGspIHN0ciArPSBnZXRaZXJvU3RyaW5nKGspO1xyXG4gICAgICAgIHN0ciArPSB3cztcclxuICAgICAgfVxyXG5cclxuICAgICAgdyA9IGRbaV07XHJcbiAgICAgIHdzID0gdyArICcnO1xyXG4gICAgICBrID0gTE9HX0JBU0UgLSB3cy5sZW5ndGg7XHJcbiAgICAgIGlmIChrKSBzdHIgKz0gZ2V0WmVyb1N0cmluZyhrKTtcclxuICAgIH0gZWxzZSBpZiAodyA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gJzAnO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcyBvZiBsYXN0IHcuXHJcbiAgICBmb3IgKDsgdyAlIDEwID09PSAwOykgdyAvPSAxMDtcclxuXHJcbiAgICByZXR1cm4gc3RyICsgdztcclxuICB9XHJcblxyXG5cclxuICBmdW5jdGlvbiBjaGVja0ludDMyKGksIG1pbiwgbWF4KSB7XHJcbiAgICBpZiAoaSAhPT0gfn5pIHx8IGkgPCBtaW4gfHwgaSA+IG1heCkge1xyXG4gICAgICB0aHJvdyBFcnJvcihpbnZhbGlkQXJndW1lbnQgKyBpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIENoZWNrIDUgcm91bmRpbmcgZGlnaXRzIGlmIGByZXBlYXRpbmdgIGlzIG51bGwsIDQgb3RoZXJ3aXNlLlxyXG4gICAqIGByZXBlYXRpbmcgPT0gbnVsbGAgaWYgY2FsbGVyIGlzIGBsb2dgIG9yIGBwb3dgLFxyXG4gICAqIGByZXBlYXRpbmcgIT0gbnVsbGAgaWYgY2FsbGVyIGlzIGBuYXR1cmFsTG9nYXJpdGhtYCBvciBgbmF0dXJhbEV4cG9uZW50aWFsYC5cclxuICAgKi9cclxuICBmdW5jdGlvbiBjaGVja1JvdW5kaW5nRGlnaXRzKGQsIGksIHJtLCByZXBlYXRpbmcpIHtcclxuICAgIHZhciBkaSwgaywgciwgcmQ7XHJcblxyXG4gICAgLy8gR2V0IHRoZSBsZW5ndGggb2YgdGhlIGZpcnN0IHdvcmQgb2YgdGhlIGFycmF5IGQuXHJcbiAgICBmb3IgKGsgPSBkWzBdOyBrID49IDEwOyBrIC89IDEwKSAtLWk7XHJcblxyXG4gICAgLy8gSXMgdGhlIHJvdW5kaW5nIGRpZ2l0IGluIHRoZSBmaXJzdCB3b3JkIG9mIGQ/XHJcbiAgICBpZiAoLS1pIDwgMCkge1xyXG4gICAgICBpICs9IExPR19CQVNFO1xyXG4gICAgICBkaSA9IDA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBkaSA9IE1hdGguY2VpbCgoaSArIDEpIC8gTE9HX0JBU0UpO1xyXG4gICAgICBpICU9IExPR19CQVNFO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGkgaXMgdGhlIGluZGV4ICgwIC0gNikgb2YgdGhlIHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgLy8gRS5nLiBpZiB3aXRoaW4gdGhlIHdvcmQgMzQ4NzU2MyB0aGUgZmlyc3Qgcm91bmRpbmcgZGlnaXQgaXMgNSxcclxuICAgIC8vIHRoZW4gaSA9IDQsIGsgPSAxMDAwLCByZCA9IDM0ODc1NjMgJSAxMDAwID0gNTYzXHJcbiAgICBrID0gbWF0aHBvdygxMCwgTE9HX0JBU0UgLSBpKTtcclxuICAgIHJkID0gZFtkaV0gJSBrIHwgMDtcclxuXHJcbiAgICBpZiAocmVwZWF0aW5nID09IG51bGwpIHtcclxuICAgICAgaWYgKGkgPCAzKSB7XHJcbiAgICAgICAgaWYgKGkgPT0gMCkgcmQgPSByZCAvIDEwMCB8IDA7XHJcbiAgICAgICAgZWxzZSBpZiAoaSA9PSAxKSByZCA9IHJkIC8gMTAgfCAwO1xyXG4gICAgICAgIHIgPSBybSA8IDQgJiYgcmQgPT0gOTk5OTkgfHwgcm0gPiAzICYmIHJkID09IDQ5OTk5IHx8IHJkID09IDUwMDAwIHx8IHJkID09IDA7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgciA9IChybSA8IDQgJiYgcmQgKyAxID09IGsgfHwgcm0gPiAzICYmIHJkICsgMSA9PSBrIC8gMikgJiZcclxuICAgICAgICAgIChkW2RpICsgMV0gLyBrIC8gMTAwIHwgMCkgPT0gbWF0aHBvdygxMCwgaSAtIDIpIC0gMSB8fFxyXG4gICAgICAgICAgICAocmQgPT0gayAvIDIgfHwgcmQgPT0gMCkgJiYgKGRbZGkgKyAxXSAvIGsgLyAxMDAgfCAwKSA9PSAwO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAoaSA8IDQpIHtcclxuICAgICAgICBpZiAoaSA9PSAwKSByZCA9IHJkIC8gMTAwMCB8IDA7XHJcbiAgICAgICAgZWxzZSBpZiAoaSA9PSAxKSByZCA9IHJkIC8gMTAwIHwgMDtcclxuICAgICAgICBlbHNlIGlmIChpID09IDIpIHJkID0gcmQgLyAxMCB8IDA7XHJcbiAgICAgICAgciA9IChyZXBlYXRpbmcgfHwgcm0gPCA0KSAmJiByZCA9PSA5OTk5IHx8ICFyZXBlYXRpbmcgJiYgcm0gPiAzICYmIHJkID09IDQ5OTk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgciA9ICgocmVwZWF0aW5nIHx8IHJtIDwgNCkgJiYgcmQgKyAxID09IGsgfHxcclxuICAgICAgICAoIXJlcGVhdGluZyAmJiBybSA+IDMpICYmIHJkICsgMSA9PSBrIC8gMikgJiZcclxuICAgICAgICAgIChkW2RpICsgMV0gLyBrIC8gMTAwMCB8IDApID09IG1hdGhwb3coMTAsIGkgLSAzKSAtIDE7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcjtcclxuICB9XHJcblxyXG5cclxuICAvLyBDb252ZXJ0IHN0cmluZyBvZiBgYmFzZUluYCB0byBhbiBhcnJheSBvZiBudW1iZXJzIG9mIGBiYXNlT3V0YC5cclxuICAvLyBFZy4gY29udmVydEJhc2UoJzI1NScsIDEwLCAxNikgcmV0dXJucyBbMTUsIDE1XS5cclxuICAvLyBFZy4gY29udmVydEJhc2UoJ2ZmJywgMTYsIDEwKSByZXR1cm5zIFsyLCA1LCA1XS5cclxuICBmdW5jdGlvbiBjb252ZXJ0QmFzZShzdHIsIGJhc2VJbiwgYmFzZU91dCkge1xyXG4gICAgdmFyIGosXHJcbiAgICAgIGFyciA9IFswXSxcclxuICAgICAgYXJyTCxcclxuICAgICAgaSA9IDAsXHJcbiAgICAgIHN0ckwgPSBzdHIubGVuZ3RoO1xyXG5cclxuICAgIGZvciAoOyBpIDwgc3RyTDspIHtcclxuICAgICAgZm9yIChhcnJMID0gYXJyLmxlbmd0aDsgYXJyTC0tOykgYXJyW2FyckxdICo9IGJhc2VJbjtcclxuICAgICAgYXJyWzBdICs9IE5VTUVSQUxTLmluZGV4T2Yoc3RyLmNoYXJBdChpKyspKTtcclxuICAgICAgZm9yIChqID0gMDsgaiA8IGFyci5sZW5ndGg7IGorKykge1xyXG4gICAgICAgIGlmIChhcnJbal0gPiBiYXNlT3V0IC0gMSkge1xyXG4gICAgICAgICAgaWYgKGFycltqICsgMV0gPT09IHZvaWQgMCkgYXJyW2ogKyAxXSA9IDA7XHJcbiAgICAgICAgICBhcnJbaiArIDFdICs9IGFycltqXSAvIGJhc2VPdXQgfCAwO1xyXG4gICAgICAgICAgYXJyW2pdICU9IGJhc2VPdXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGFyci5yZXZlcnNlKCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBjb3MoeCkgPSAxIC0geF4yLzIhICsgeF40LzQhIC0gLi4uXHJcbiAgICogfHh8IDwgcGkvMlxyXG4gICAqXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gY29zaW5lKEN0b3IsIHgpIHtcclxuICAgIHZhciBrLCB5LFxyXG4gICAgICBsZW4gPSB4LmQubGVuZ3RoO1xyXG5cclxuICAgIC8vIEFyZ3VtZW50IHJlZHVjdGlvbjogY29zKDR4KSA9IDgqKGNvc140KHgpIC0gY29zXjIoeCkpICsgMVxyXG4gICAgLy8gaS5lLiBjb3MoeCkgPSA4Kihjb3NeNCh4LzQpIC0gY29zXjIoeC80KSkgKyAxXHJcblxyXG4gICAgLy8gRXN0aW1hdGUgdGhlIG9wdGltdW0gbnVtYmVyIG9mIHRpbWVzIHRvIHVzZSB0aGUgYXJndW1lbnQgcmVkdWN0aW9uLlxyXG4gICAgaWYgKGxlbiA8IDMyKSB7XHJcbiAgICAgIGsgPSBNYXRoLmNlaWwobGVuIC8gMyk7XHJcbiAgICAgIHkgPSBNYXRoLnBvdyg0LCAtaykudG9TdHJpbmcoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGsgPSAxNjtcclxuICAgICAgeSA9ICcyLjMyODMwNjQzNjUzODY5NjI4OTA2MjVlLTEwJztcclxuICAgIH1cclxuXHJcbiAgICBDdG9yLnByZWNpc2lvbiArPSBrO1xyXG5cclxuICAgIHggPSB0YXlsb3JTZXJpZXMoQ3RvciwgMSwgeC50aW1lcyh5KSwgbmV3IEN0b3IoMSkpO1xyXG5cclxuICAgIC8vIFJldmVyc2UgYXJndW1lbnQgcmVkdWN0aW9uXHJcbiAgICBmb3IgKHZhciBpID0gazsgaS0tOykge1xyXG4gICAgICB2YXIgY29zMnggPSB4LnRpbWVzKHgpO1xyXG4gICAgICB4ID0gY29zMngudGltZXMoY29zMngpLm1pbnVzKGNvczJ4KS50aW1lcyg4KS5wbHVzKDEpO1xyXG4gICAgfVxyXG5cclxuICAgIEN0b3IucHJlY2lzaW9uIC09IGs7XHJcblxyXG4gICAgcmV0dXJuIHg7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBQZXJmb3JtIGRpdmlzaW9uIGluIHRoZSBzcGVjaWZpZWQgYmFzZS5cclxuICAgKi9cclxuICB2YXIgZGl2aWRlID0gKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAvLyBBc3N1bWVzIG5vbi16ZXJvIHggYW5kIGssIGFuZCBoZW5jZSBub24temVybyByZXN1bHQuXHJcbiAgICBmdW5jdGlvbiBtdWx0aXBseUludGVnZXIoeCwgaywgYmFzZSkge1xyXG4gICAgICB2YXIgdGVtcCxcclxuICAgICAgICBjYXJyeSA9IDAsXHJcbiAgICAgICAgaSA9IHgubGVuZ3RoO1xyXG5cclxuICAgICAgZm9yICh4ID0geC5zbGljZSgpOyBpLS07KSB7XHJcbiAgICAgICAgdGVtcCA9IHhbaV0gKiBrICsgY2Fycnk7XHJcbiAgICAgICAgeFtpXSA9IHRlbXAgJSBiYXNlIHwgMDtcclxuICAgICAgICBjYXJyeSA9IHRlbXAgLyBiYXNlIHwgMDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGNhcnJ5KSB4LnVuc2hpZnQoY2FycnkpO1xyXG5cclxuICAgICAgcmV0dXJuIHg7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY29tcGFyZShhLCBiLCBhTCwgYkwpIHtcclxuICAgICAgdmFyIGksIHI7XHJcblxyXG4gICAgICBpZiAoYUwgIT0gYkwpIHtcclxuICAgICAgICByID0gYUwgPiBiTCA/IDEgOiAtMTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBmb3IgKGkgPSByID0gMDsgaSA8IGFMOyBpKyspIHtcclxuICAgICAgICAgIGlmIChhW2ldICE9IGJbaV0pIHtcclxuICAgICAgICAgICAgciA9IGFbaV0gPiBiW2ldID8gMSA6IC0xO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiByO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHN1YnRyYWN0KGEsIGIsIGFMLCBiYXNlKSB7XHJcbiAgICAgIHZhciBpID0gMDtcclxuXHJcbiAgICAgIC8vIFN1YnRyYWN0IGIgZnJvbSBhLlxyXG4gICAgICBmb3IgKDsgYUwtLTspIHtcclxuICAgICAgICBhW2FMXSAtPSBpO1xyXG4gICAgICAgIGkgPSBhW2FMXSA8IGJbYUxdID8gMSA6IDA7XHJcbiAgICAgICAgYVthTF0gPSBpICogYmFzZSArIGFbYUxdIC0gYlthTF07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKDsgIWFbMF0gJiYgYS5sZW5ndGggPiAxOykgYS5zaGlmdCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiAoeCwgeSwgcHIsIHJtLCBkcCwgYmFzZSkge1xyXG4gICAgICB2YXIgY21wLCBlLCBpLCBrLCBsb2dCYXNlLCBtb3JlLCBwcm9kLCBwcm9kTCwgcSwgcWQsIHJlbSwgcmVtTCwgcmVtMCwgc2QsIHQsIHhpLCB4TCwgeWQwLFxyXG4gICAgICAgIHlMLCB5eixcclxuICAgICAgICBDdG9yID0geC5jb25zdHJ1Y3RvcixcclxuICAgICAgICBzaWduID0geC5zID09IHkucyA/IDEgOiAtMSxcclxuICAgICAgICB4ZCA9IHguZCxcclxuICAgICAgICB5ZCA9IHkuZDtcclxuXHJcbiAgICAgIC8vIEVpdGhlciBOYU4sIEluZmluaXR5IG9yIDA/XHJcbiAgICAgIGlmICgheGQgfHwgIXhkWzBdIHx8ICF5ZCB8fCAheWRbMF0pIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBDdG9yKC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIE5hTiwgb3IgYm90aCBJbmZpbml0eSBvciAwLlxyXG4gICAgICAgICAgIXgucyB8fCAheS5zIHx8ICh4ZCA/IHlkICYmIHhkWzBdID09IHlkWzBdIDogIXlkKSA/IE5hTiA6XHJcblxyXG4gICAgICAgICAgLy8gUmV0dXJuIMKxMCBpZiB4IGlzIDAgb3IgeSBpcyDCsUluZmluaXR5LCBvciByZXR1cm4gwrFJbmZpbml0eSBhcyB5IGlzIDAuXHJcbiAgICAgICAgICB4ZCAmJiB4ZFswXSA9PSAwIHx8ICF5ZCA/IHNpZ24gKiAwIDogc2lnbiAvIDApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoYmFzZSkge1xyXG4gICAgICAgIGxvZ0Jhc2UgPSAxO1xyXG4gICAgICAgIGUgPSB4LmUgLSB5LmU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYmFzZSA9IEJBU0U7XHJcbiAgICAgICAgbG9nQmFzZSA9IExPR19CQVNFO1xyXG4gICAgICAgIGUgPSBtYXRoZmxvb3IoeC5lIC8gbG9nQmFzZSkgLSBtYXRoZmxvb3IoeS5lIC8gbG9nQmFzZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHlMID0geWQubGVuZ3RoO1xyXG4gICAgICB4TCA9IHhkLmxlbmd0aDtcclxuICAgICAgcSA9IG5ldyBDdG9yKHNpZ24pO1xyXG4gICAgICBxZCA9IHEuZCA9IFtdO1xyXG5cclxuICAgICAgLy8gUmVzdWx0IGV4cG9uZW50IG1heSBiZSBvbmUgbGVzcyB0aGFuIGUuXHJcbiAgICAgIC8vIFRoZSBkaWdpdCBhcnJheSBvZiBhIERlY2ltYWwgZnJvbSB0b1N0cmluZ0JpbmFyeSBtYXkgaGF2ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgZm9yIChpID0gMDsgeWRbaV0gPT0gKHhkW2ldIHx8IDApOyBpKyspO1xyXG5cclxuICAgICAgaWYgKHlkW2ldID4gKHhkW2ldIHx8IDApKSBlLS07XHJcblxyXG4gICAgICBpZiAocHIgPT0gbnVsbCkge1xyXG4gICAgICAgIHNkID0gcHIgPSBDdG9yLnByZWNpc2lvbjtcclxuICAgICAgICBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgICAgIH0gZWxzZSBpZiAoZHApIHtcclxuICAgICAgICBzZCA9IHByICsgKHguZSAtIHkuZSkgKyAxO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNkID0gcHI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzZCA8IDApIHtcclxuICAgICAgICBxZC5wdXNoKDEpO1xyXG4gICAgICAgIG1vcmUgPSB0cnVlO1xyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IHByZWNpc2lvbiBpbiBudW1iZXIgb2YgYmFzZSAxMCBkaWdpdHMgdG8gYmFzZSAxZTcgZGlnaXRzLlxyXG4gICAgICAgIHNkID0gc2QgLyBsb2dCYXNlICsgMiB8IDA7XHJcbiAgICAgICAgaSA9IDA7XHJcblxyXG4gICAgICAgIC8vIGRpdmlzb3IgPCAxZTdcclxuICAgICAgICBpZiAoeUwgPT0gMSkge1xyXG4gICAgICAgICAgayA9IDA7XHJcbiAgICAgICAgICB5ZCA9IHlkWzBdO1xyXG4gICAgICAgICAgc2QrKztcclxuXHJcbiAgICAgICAgICAvLyBrIGlzIHRoZSBjYXJyeS5cclxuICAgICAgICAgIGZvciAoOyAoaSA8IHhMIHx8IGspICYmIHNkLS07IGkrKykge1xyXG4gICAgICAgICAgICB0ID0gayAqIGJhc2UgKyAoeGRbaV0gfHwgMCk7XHJcbiAgICAgICAgICAgIHFkW2ldID0gdCAvIHlkIHwgMDtcclxuICAgICAgICAgICAgayA9IHQgJSB5ZCB8IDA7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgbW9yZSA9IGsgfHwgaSA8IHhMO1xyXG5cclxuICAgICAgICAvLyBkaXZpc29yID49IDFlN1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gTm9ybWFsaXNlIHhkIGFuZCB5ZCBzbyBoaWdoZXN0IG9yZGVyIGRpZ2l0IG9mIHlkIGlzID49IGJhc2UvMlxyXG4gICAgICAgICAgayA9IGJhc2UgLyAoeWRbMF0gKyAxKSB8IDA7XHJcblxyXG4gICAgICAgICAgaWYgKGsgPiAxKSB7XHJcbiAgICAgICAgICAgIHlkID0gbXVsdGlwbHlJbnRlZ2VyKHlkLCBrLCBiYXNlKTtcclxuICAgICAgICAgICAgeGQgPSBtdWx0aXBseUludGVnZXIoeGQsIGssIGJhc2UpO1xyXG4gICAgICAgICAgICB5TCA9IHlkLmxlbmd0aDtcclxuICAgICAgICAgICAgeEwgPSB4ZC5sZW5ndGg7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgeGkgPSB5TDtcclxuICAgICAgICAgIHJlbSA9IHhkLnNsaWNlKDAsIHlMKTtcclxuICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgIC8vIEFkZCB6ZXJvcyB0byBtYWtlIHJlbWFpbmRlciBhcyBsb25nIGFzIGRpdmlzb3IuXHJcbiAgICAgICAgICBmb3IgKDsgcmVtTCA8IHlMOykgcmVtW3JlbUwrK10gPSAwO1xyXG5cclxuICAgICAgICAgIHl6ID0geWQuc2xpY2UoKTtcclxuICAgICAgICAgIHl6LnVuc2hpZnQoMCk7XHJcbiAgICAgICAgICB5ZDAgPSB5ZFswXTtcclxuXHJcbiAgICAgICAgICBpZiAoeWRbMV0gPj0gYmFzZSAvIDIpICsreWQwO1xyXG5cclxuICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgayA9IDA7XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wYXJlIGRpdmlzb3IgYW5kIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgY21wID0gY29tcGFyZSh5ZCwgcmVtLCB5TCwgcmVtTCk7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBkaXZpc29yIDwgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBpZiAoY21wIDwgMCkge1xyXG5cclxuICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgdHJpYWwgZGlnaXQsIGsuXHJcbiAgICAgICAgICAgICAgcmVtMCA9IHJlbVswXTtcclxuICAgICAgICAgICAgICBpZiAoeUwgIT0gcmVtTCkgcmVtMCA9IHJlbTAgKiBiYXNlICsgKHJlbVsxXSB8fCAwKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gayB3aWxsIGJlIGhvdyBtYW55IHRpbWVzIHRoZSBkaXZpc29yIGdvZXMgaW50byB0aGUgY3VycmVudCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgayA9IHJlbTAgLyB5ZDAgfCAwO1xyXG5cclxuICAgICAgICAgICAgICAvLyAgQWxnb3JpdGhtOlxyXG4gICAgICAgICAgICAgIC8vICAxLiBwcm9kdWN0ID0gZGl2aXNvciAqIHRyaWFsIGRpZ2l0IChrKVxyXG4gICAgICAgICAgICAgIC8vICAyLiBpZiBwcm9kdWN0ID4gcmVtYWluZGVyOiBwcm9kdWN0IC09IGRpdmlzb3IsIGstLVxyXG4gICAgICAgICAgICAgIC8vICAzLiByZW1haW5kZXIgLT0gcHJvZHVjdFxyXG4gICAgICAgICAgICAgIC8vICA0LiBpZiBwcm9kdWN0IHdhcyA8IHJlbWFpbmRlciBhdCAyOlxyXG4gICAgICAgICAgICAgIC8vICAgIDUuIGNvbXBhcmUgbmV3IHJlbWFpbmRlciBhbmQgZGl2aXNvclxyXG4gICAgICAgICAgICAgIC8vICAgIDYuIElmIHJlbWFpbmRlciA+IGRpdmlzb3I6IHJlbWFpbmRlciAtPSBkaXZpc29yLCBrKytcclxuXHJcbiAgICAgICAgICAgICAgaWYgKGsgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoayA+PSBiYXNlKSBrID0gYmFzZSAtIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcHJvZHVjdCA9IGRpdmlzb3IgKiB0cmlhbCBkaWdpdC5cclxuICAgICAgICAgICAgICAgIHByb2QgPSBtdWx0aXBseUludGVnZXIoeWQsIGssIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbXBhcmUgcHJvZHVjdCBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgY21wID0gY29tcGFyZShwcm9kLCByZW0sIHByb2RMLCByZW1MKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBwcm9kdWN0ID4gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgaWYgKGNtcCA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgIGstLTtcclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSBwcm9kdWN0LlxyXG4gICAgICAgICAgICAgICAgICBzdWJ0cmFjdChwcm9kLCB5TCA8IHByb2RMID8geXogOiB5ZCwgcHJvZEwsIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gY21wIGlzIC0xLlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgayBpcyAwLCB0aGVyZSBpcyBubyBuZWVkIHRvIGNvbXBhcmUgeWQgYW5kIHJlbSBhZ2FpbiBiZWxvdywgc28gY2hhbmdlIGNtcCB0byAxXHJcbiAgICAgICAgICAgICAgICAvLyB0byBhdm9pZCBpdC4gSWYgayBpcyAxIHRoZXJlIGlzIGEgbmVlZCB0byBjb21wYXJlIHlkIGFuZCByZW0gYWdhaW4gYmVsb3cuXHJcbiAgICAgICAgICAgICAgICBpZiAoayA9PSAwKSBjbXAgPSBrID0gMTtcclxuICAgICAgICAgICAgICAgIHByb2QgPSB5ZC5zbGljZSgpO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICBpZiAocHJvZEwgPCByZW1MKSBwcm9kLnVuc2hpZnQoMCk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIFN1YnRyYWN0IHByb2R1Y3QgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgc3VidHJhY3QocmVtLCBwcm9kLCByZW1MLCBiYXNlKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gSWYgcHJvZHVjdCB3YXMgPCBwcmV2aW91cyByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgaWYgKGNtcCA9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29tcGFyZSBkaXZpc29yIGFuZCBuZXcgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgY21wID0gY29tcGFyZSh5ZCwgcmVtLCB5TCwgcmVtTCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgZGl2aXNvciA8IG5ldyByZW1haW5kZXIsIHN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICBpZiAoY21wIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgICBrKys7XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgICBzdWJ0cmFjdChyZW0sIHlMIDwgcmVtTCA/IHl6IDogeWQsIHJlbUwsIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY21wID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgaysrO1xyXG4gICAgICAgICAgICAgIHJlbSA9IFswXTtcclxuICAgICAgICAgICAgfSAgICAvLyBpZiBjbXAgPT09IDEsIGsgd2lsbCBiZSAwXHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgdGhlIG5leHQgZGlnaXQsIGssIHRvIHRoZSByZXN1bHQgYXJyYXkuXHJcbiAgICAgICAgICAgIHFkW2krK10gPSBrO1xyXG5cclxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIGlmIChjbXAgJiYgcmVtWzBdKSB7XHJcbiAgICAgICAgICAgICAgcmVtW3JlbUwrK10gPSB4ZFt4aV0gfHwgMDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZW0gPSBbeGRbeGldXTtcclxuICAgICAgICAgICAgICByZW1MID0gMTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIH0gd2hpbGUgKCh4aSsrIDwgeEwgfHwgcmVtWzBdICE9PSB2b2lkIDApICYmIHNkLS0pO1xyXG5cclxuICAgICAgICAgIG1vcmUgPSByZW1bMF0gIT09IHZvaWQgMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIExlYWRpbmcgemVybz9cclxuICAgICAgICBpZiAoIXFkWzBdKSBxZC5zaGlmdCgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBsb2dCYXNlIGlzIDEgd2hlbiBkaXZpZGUgaXMgYmVpbmcgdXNlZCBmb3IgYmFzZSBjb252ZXJzaW9uLlxyXG4gICAgICBpZiAobG9nQmFzZSA9PSAxKSB7XHJcbiAgICAgICAgcS5lID0gZTtcclxuICAgICAgICBpbmV4YWN0ID0gbW9yZTtcclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gVG8gY2FsY3VsYXRlIHEuZSwgZmlyc3QgZ2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHFkWzBdLlxyXG4gICAgICAgIGZvciAoaSA9IDEsIGsgPSBxZFswXTsgayA+PSAxMDsgayAvPSAxMCkgaSsrO1xyXG4gICAgICAgIHEuZSA9IGkgKyBlICogbG9nQmFzZSAtIDE7XHJcblxyXG4gICAgICAgIGZpbmFsaXNlKHEsIGRwID8gcHIgKyBxLmUgKyAxIDogcHIsIHJtLCBtb3JlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHE7XHJcbiAgICB9O1xyXG4gIH0pKCk7XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJvdW5kIGB4YCB0byBgc2RgIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGBybWAuXHJcbiAgICogQ2hlY2sgZm9yIG92ZXIvdW5kZXItZmxvdy5cclxuICAgKi9cclxuICAgZnVuY3Rpb24gZmluYWxpc2UoeCwgc2QsIHJtLCBpc1RydW5jYXRlZCkge1xyXG4gICAgdmFyIGRpZ2l0cywgaSwgaiwgaywgcmQsIHJvdW5kVXAsIHcsIHhkLCB4ZGksXHJcbiAgICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICAgIC8vIERvbid0IHJvdW5kIGlmIHNkIGlzIG51bGwgb3IgdW5kZWZpbmVkLlxyXG4gICAgb3V0OiBpZiAoc2QgIT0gbnVsbCkge1xyXG4gICAgICB4ZCA9IHguZDtcclxuXHJcbiAgICAgIC8vIEluZmluaXR5L05hTi5cclxuICAgICAgaWYgKCF4ZCkgcmV0dXJuIHg7XHJcblxyXG4gICAgICAvLyByZDogdGhlIHJvdW5kaW5nIGRpZ2l0LCBpLmUuIHRoZSBkaWdpdCBhZnRlciB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cC5cclxuICAgICAgLy8gdzogdGhlIHdvcmQgb2YgeGQgY29udGFpbmluZyByZCwgYSBiYXNlIDFlNyBudW1iZXIuXHJcbiAgICAgIC8vIHhkaTogdGhlIGluZGV4IG9mIHcgd2l0aGluIHhkLlxyXG4gICAgICAvLyBkaWdpdHM6IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHcuXHJcbiAgICAgIC8vIGk6IHdoYXQgd291bGQgYmUgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiB3IGlmIGFsbCB0aGUgbnVtYmVycyB3ZXJlIDcgZGlnaXRzIGxvbmcgKGkuZS4gaWZcclxuICAgICAgLy8gdGhleSBoYWQgbGVhZGluZyB6ZXJvcylcclxuICAgICAgLy8gajogaWYgPiAwLCB0aGUgYWN0dWFsIGluZGV4IG9mIHJkIHdpdGhpbiB3IChpZiA8IDAsIHJkIGlzIGEgbGVhZGluZyB6ZXJvKS5cclxuXHJcbiAgICAgIC8vIEdldCB0aGUgbGVuZ3RoIG9mIHRoZSBmaXJzdCB3b3JkIG9mIHRoZSBkaWdpdHMgYXJyYXkgeGQuXHJcbiAgICAgIGZvciAoZGlnaXRzID0gMSwgayA9IHhkWzBdOyBrID49IDEwOyBrIC89IDEwKSBkaWdpdHMrKztcclxuICAgICAgaSA9IHNkIC0gZGlnaXRzO1xyXG5cclxuICAgICAgLy8gSXMgdGhlIHJvdW5kaW5nIGRpZ2l0IGluIHRoZSBmaXJzdCB3b3JkIG9mIHhkP1xyXG4gICAgICBpZiAoaSA8IDApIHtcclxuICAgICAgICBpICs9IExPR19CQVNFO1xyXG4gICAgICAgIGogPSBzZDtcclxuICAgICAgICB3ID0geGRbeGRpID0gMF07XHJcblxyXG4gICAgICAgIC8vIEdldCB0aGUgcm91bmRpbmcgZGlnaXQgYXQgaW5kZXggaiBvZiB3LlxyXG4gICAgICAgIHJkID0gdyAvIG1hdGhwb3coMTAsIGRpZ2l0cyAtIGogLSAxKSAlIDEwIHwgMDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB4ZGkgPSBNYXRoLmNlaWwoKGkgKyAxKSAvIExPR19CQVNFKTtcclxuICAgICAgICBrID0geGQubGVuZ3RoO1xyXG4gICAgICAgIGlmICh4ZGkgPj0gaykge1xyXG4gICAgICAgICAgaWYgKGlzVHJ1bmNhdGVkKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBOZWVkZWQgYnkgYG5hdHVyYWxFeHBvbmVudGlhbGAsIGBuYXR1cmFsTG9nYXJpdGhtYCBhbmQgYHNxdWFyZVJvb3RgLlxyXG4gICAgICAgICAgICBmb3IgKDsgaysrIDw9IHhkaTspIHhkLnB1c2goMCk7XHJcbiAgICAgICAgICAgIHcgPSByZCA9IDA7XHJcbiAgICAgICAgICAgIGRpZ2l0cyA9IDE7XHJcbiAgICAgICAgICAgIGkgJT0gTE9HX0JBU0U7XHJcbiAgICAgICAgICAgIGogPSBpIC0gTE9HX0JBU0UgKyAxO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB3ID0gayA9IHhkW3hkaV07XHJcblxyXG4gICAgICAgICAgLy8gR2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHcuXHJcbiAgICAgICAgICBmb3IgKGRpZ2l0cyA9IDE7IGsgPj0gMTA7IGsgLz0gMTApIGRpZ2l0cysrO1xyXG5cclxuICAgICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgcmQgd2l0aGluIHcuXHJcbiAgICAgICAgICBpICU9IExPR19CQVNFO1xyXG5cclxuICAgICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgcmQgd2l0aGluIHcsIGFkanVzdGVkIGZvciBsZWFkaW5nIHplcm9zLlxyXG4gICAgICAgICAgLy8gVGhlIG51bWJlciBvZiBsZWFkaW5nIHplcm9zIG9mIHcgaXMgZ2l2ZW4gYnkgTE9HX0JBU0UgLSBkaWdpdHMuXHJcbiAgICAgICAgICBqID0gaSAtIExPR19CQVNFICsgZGlnaXRzO1xyXG5cclxuICAgICAgICAgIC8vIEdldCB0aGUgcm91bmRpbmcgZGlnaXQgYXQgaW5kZXggaiBvZiB3LlxyXG4gICAgICAgICAgcmQgPSBqIDwgMCA/IDAgOiB3IC8gbWF0aHBvdygxMCwgZGlnaXRzIC0gaiAtIDEpICUgMTAgfCAwO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQXJlIHRoZXJlIGFueSBub24temVybyBkaWdpdHMgYWZ0ZXIgdGhlIHJvdW5kaW5nIGRpZ2l0P1xyXG4gICAgICBpc1RydW5jYXRlZCA9IGlzVHJ1bmNhdGVkIHx8IHNkIDwgMCB8fFxyXG4gICAgICAgIHhkW3hkaSArIDFdICE9PSB2b2lkIDAgfHwgKGogPCAwID8gdyA6IHcgJSBtYXRocG93KDEwLCBkaWdpdHMgLSBqIC0gMSkpO1xyXG5cclxuICAgICAgLy8gVGhlIGV4cHJlc3Npb24gYHcgJSBtYXRocG93KDEwLCBkaWdpdHMgLSBqIC0gMSlgIHJldHVybnMgYWxsIHRoZSBkaWdpdHMgb2YgdyB0byB0aGUgcmlnaHRcclxuICAgICAgLy8gb2YgdGhlIGRpZ2l0IGF0IChsZWZ0LXRvLXJpZ2h0KSBpbmRleCBqLCBlLmcuIGlmIHcgaXMgOTA4NzE0IGFuZCBqIGlzIDIsIHRoZSBleHByZXNzaW9uXHJcbiAgICAgIC8vIHdpbGwgZ2l2ZSA3MTQuXHJcblxyXG4gICAgICByb3VuZFVwID0gcm0gPCA0XHJcbiAgICAgICAgPyAocmQgfHwgaXNUcnVuY2F0ZWQpICYmIChybSA9PSAwIHx8IHJtID09ICh4LnMgPCAwID8gMyA6IDIpKVxyXG4gICAgICAgIDogcmQgPiA1IHx8IHJkID09IDUgJiYgKHJtID09IDQgfHwgaXNUcnVuY2F0ZWQgfHwgcm0gPT0gNiAmJlxyXG5cclxuICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIGRpZ2l0IHRvIHRoZSBsZWZ0IG9mIHRoZSByb3VuZGluZyBkaWdpdCBpcyBvZGQuXHJcbiAgICAgICAgICAoKGkgPiAwID8gaiA+IDAgPyB3IC8gbWF0aHBvdygxMCwgZGlnaXRzIC0gaikgOiAwIDogeGRbeGRpIC0gMV0pICUgMTApICYgMSB8fFxyXG4gICAgICAgICAgICBybSA9PSAoeC5zIDwgMCA/IDggOiA3KSk7XHJcblxyXG4gICAgICBpZiAoc2QgPCAxIHx8ICF4ZFswXSkge1xyXG4gICAgICAgIHhkLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgaWYgKHJvdW5kVXApIHtcclxuXHJcbiAgICAgICAgICAvLyBDb252ZXJ0IHNkIHRvIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICAgICAgc2QgLT0geC5lICsgMTtcclxuXHJcbiAgICAgICAgICAvLyAxLCAwLjEsIDAuMDEsIDAuMDAxLCAwLjAwMDEgZXRjLlxyXG4gICAgICAgICAgeGRbMF0gPSBtYXRocG93KDEwLCAoTE9HX0JBU0UgLSBzZCAlIExPR19CQVNFKSAlIExPR19CQVNFKTtcclxuICAgICAgICAgIHguZSA9IC1zZCB8fCAwO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gWmVyby5cclxuICAgICAgICAgIHhkWzBdID0geC5lID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB4O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZW1vdmUgZXhjZXNzIGRpZ2l0cy5cclxuICAgICAgaWYgKGkgPT0gMCkge1xyXG4gICAgICAgIHhkLmxlbmd0aCA9IHhkaTtcclxuICAgICAgICBrID0gMTtcclxuICAgICAgICB4ZGktLTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB4ZC5sZW5ndGggPSB4ZGkgKyAxO1xyXG4gICAgICAgIGsgPSBtYXRocG93KDEwLCBMT0dfQkFTRSAtIGkpO1xyXG5cclxuICAgICAgICAvLyBFLmcuIDU2NzAwIGJlY29tZXMgNTYwMDAgaWYgNyBpcyB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgLy8gaiA+IDAgbWVhbnMgaSA+IG51bWJlciBvZiBsZWFkaW5nIHplcm9zIG9mIHcuXHJcbiAgICAgICAgeGRbeGRpXSA9IGogPiAwID8gKHcgLyBtYXRocG93KDEwLCBkaWdpdHMgLSBqKSAlIG1hdGhwb3coMTAsIGopIHwgMCkgKiBrIDogMDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHJvdW5kVXApIHtcclxuICAgICAgICBmb3IgKDs7KSB7XHJcblxyXG4gICAgICAgICAgLy8gSXMgdGhlIGRpZ2l0IHRvIGJlIHJvdW5kZWQgdXAgaW4gdGhlIGZpcnN0IHdvcmQgb2YgeGQ/XHJcbiAgICAgICAgICBpZiAoeGRpID09IDApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGkgd2lsbCBiZSB0aGUgbGVuZ3RoIG9mIHhkWzBdIGJlZm9yZSBrIGlzIGFkZGVkLlxyXG4gICAgICAgICAgICBmb3IgKGkgPSAxLCBqID0geGRbMF07IGogPj0gMTA7IGogLz0gMTApIGkrKztcclxuICAgICAgICAgICAgaiA9IHhkWzBdICs9IGs7XHJcbiAgICAgICAgICAgIGZvciAoayA9IDE7IGogPj0gMTA7IGogLz0gMTApIGsrKztcclxuXHJcbiAgICAgICAgICAgIC8vIGlmIGkgIT0gayB0aGUgbGVuZ3RoIGhhcyBpbmNyZWFzZWQuXHJcbiAgICAgICAgICAgIGlmIChpICE9IGspIHtcclxuICAgICAgICAgICAgICB4LmUrKztcclxuICAgICAgICAgICAgICBpZiAoeGRbMF0gPT0gQkFTRSkgeGRbMF0gPSAxO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHhkW3hkaV0gKz0gaztcclxuICAgICAgICAgICAgaWYgKHhkW3hkaV0gIT0gQkFTRSkgYnJlYWs7XHJcbiAgICAgICAgICAgIHhkW3hkaS0tXSA9IDA7XHJcbiAgICAgICAgICAgIGsgPSAxO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKGkgPSB4ZC5sZW5ndGg7IHhkWy0taV0gPT09IDA7KSB4ZC5wb3AoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZXh0ZXJuYWwpIHtcclxuXHJcbiAgICAgIC8vIE92ZXJmbG93P1xyXG4gICAgICBpZiAoeC5lID4gQ3Rvci5tYXhFKSB7XHJcblxyXG4gICAgICAgIC8vIEluZmluaXR5LlxyXG4gICAgICAgIHguZCA9IG51bGw7XHJcbiAgICAgICAgeC5lID0gTmFOO1xyXG5cclxuICAgICAgLy8gVW5kZXJmbG93P1xyXG4gICAgICB9IGVsc2UgaWYgKHguZSA8IEN0b3IubWluRSkge1xyXG5cclxuICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgIHguZSA9IDA7XHJcbiAgICAgICAgeC5kID0gWzBdO1xyXG4gICAgICAgIC8vIEN0b3IudW5kZXJmbG93ID0gdHJ1ZTtcclxuICAgICAgfSAvLyBlbHNlIEN0b3IudW5kZXJmbG93ID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHg7XHJcbiAgfVxyXG5cclxuXHJcbiAgZnVuY3Rpb24gZmluaXRlVG9TdHJpbmcoeCwgaXNFeHAsIHNkKSB7XHJcbiAgICBpZiAoIXguaXNGaW5pdGUoKSkgcmV0dXJuIG5vbkZpbml0ZVRvU3RyaW5nKHgpO1xyXG4gICAgdmFyIGssXHJcbiAgICAgIGUgPSB4LmUsXHJcbiAgICAgIHN0ciA9IGRpZ2l0c1RvU3RyaW5nKHguZCksXHJcbiAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgaWYgKGlzRXhwKSB7XHJcbiAgICAgIGlmIChzZCAmJiAoayA9IHNkIC0gbGVuKSA+IDApIHtcclxuICAgICAgICBzdHIgPSBzdHIuY2hhckF0KDApICsgJy4nICsgc3RyLnNsaWNlKDEpICsgZ2V0WmVyb1N0cmluZyhrKTtcclxuICAgICAgfSBlbHNlIGlmIChsZW4gPiAxKSB7XHJcbiAgICAgICAgc3RyID0gc3RyLmNoYXJBdCgwKSArICcuJyArIHN0ci5zbGljZSgxKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgc3RyID0gc3RyICsgKHguZSA8IDAgPyAnZScgOiAnZSsnKSArIHguZTtcclxuICAgIH0gZWxzZSBpZiAoZSA8IDApIHtcclxuICAgICAgc3RyID0gJzAuJyArIGdldFplcm9TdHJpbmcoLWUgLSAxKSArIHN0cjtcclxuICAgICAgaWYgKHNkICYmIChrID0gc2QgLSBsZW4pID4gMCkgc3RyICs9IGdldFplcm9TdHJpbmcoayk7XHJcbiAgICB9IGVsc2UgaWYgKGUgPj0gbGVuKSB7XHJcbiAgICAgIHN0ciArPSBnZXRaZXJvU3RyaW5nKGUgKyAxIC0gbGVuKTtcclxuICAgICAgaWYgKHNkICYmIChrID0gc2QgLSBlIC0gMSkgPiAwKSBzdHIgPSBzdHIgKyAnLicgKyBnZXRaZXJvU3RyaW5nKGspO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKChrID0gZSArIDEpIDwgbGVuKSBzdHIgPSBzdHIuc2xpY2UoMCwgaykgKyAnLicgKyBzdHIuc2xpY2Uoayk7XHJcbiAgICAgIGlmIChzZCAmJiAoayA9IHNkIC0gbGVuKSA+IDApIHtcclxuICAgICAgICBpZiAoZSArIDEgPT09IGxlbikgc3RyICs9ICcuJztcclxuICAgICAgICBzdHIgKz0gZ2V0WmVyb1N0cmluZyhrKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzdHI7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gQ2FsY3VsYXRlIHRoZSBiYXNlIDEwIGV4cG9uZW50IGZyb20gdGhlIGJhc2UgMWU3IGV4cG9uZW50LlxyXG4gIGZ1bmN0aW9uIGdldEJhc2UxMEV4cG9uZW50KGRpZ2l0cywgZSkge1xyXG5cclxuICAgIC8vIEZpcnN0IGdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiB0aGUgZmlyc3Qgd29yZCBvZiB0aGUgZGlnaXRzIGFycmF5LlxyXG4gICAgZm9yICh2YXIgaSA9IDEsIHcgPSBkaWdpdHNbMF07IHcgPj0gMTA7IHcgLz0gMTApIGkrKztcclxuICAgIHJldHVybiBpICsgZSAqIExPR19CQVNFIC0gMTtcclxuICB9XHJcblxyXG5cclxuICAgZnVuY3Rpb24gZ2V0TG4xMChDdG9yLCBzZCwgcHIpIHtcclxuICAgIGlmIChzZCA+IExOMTBfUFJFQ0lTSU9OKSB7XHJcblxyXG4gICAgICAvLyBSZXNldCBnbG9iYWwgc3RhdGUgaW4gY2FzZSB0aGUgZXhjZXB0aW9uIGlzIGNhdWdodC5cclxuICAgICAgZXh0ZXJuYWwgPSB0cnVlO1xyXG4gICAgICBpZiAocHIpIEN0b3IucHJlY2lzaW9uID0gcHI7XHJcbiAgICAgIHRocm93IEVycm9yKHByZWNpc2lvbkxpbWl0RXhjZWVkZWQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZpbmFsaXNlKG5ldyBDdG9yKExOMTApLCBzZCwgMSwgdHJ1ZSk7XHJcbiAgfVxyXG5cclxuXHJcbiAgZnVuY3Rpb24gZ2V0UGkoQ3Rvciwgc2QsIHJtKSB7XHJcbiAgICBpZiAoc2QgPiBQSV9QUkVDSVNJT04pIHRocm93IEVycm9yKHByZWNpc2lvbkxpbWl0RXhjZWVkZWQpO1xyXG4gICAgcmV0dXJuIGZpbmFsaXNlKG5ldyBDdG9yKFBJKSwgc2QsIHJtLCB0cnVlKTtcclxuICB9XHJcblxyXG5cclxuICBmdW5jdGlvbiBnZXRQcmVjaXNpb24oZGlnaXRzKSB7XHJcbiAgICB2YXIgdyA9IGRpZ2l0cy5sZW5ndGggLSAxLFxyXG4gICAgICBsZW4gPSB3ICogTE9HX0JBU0UgKyAxO1xyXG5cclxuICAgIHcgPSBkaWdpdHNbd107XHJcblxyXG4gICAgLy8gSWYgbm9uLXplcm8uLi5cclxuICAgIGlmICh3KSB7XHJcblxyXG4gICAgICAvLyBTdWJ0cmFjdCB0aGUgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zIG9mIHRoZSBsYXN0IHdvcmQuXHJcbiAgICAgIGZvciAoOyB3ICUgMTAgPT0gMDsgdyAvPSAxMCkgbGVuLS07XHJcblxyXG4gICAgICAvLyBBZGQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgdGhlIGZpcnN0IHdvcmQuXHJcbiAgICAgIGZvciAodyA9IGRpZ2l0c1swXTsgdyA+PSAxMDsgdyAvPSAxMCkgbGVuKys7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGxlbjtcclxuICB9XHJcblxyXG5cclxuICBmdW5jdGlvbiBnZXRaZXJvU3RyaW5nKGspIHtcclxuICAgIHZhciB6cyA9ICcnO1xyXG4gICAgZm9yICg7IGstLTspIHpzICs9ICcwJztcclxuICAgIHJldHVybiB6cztcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiBEZWNpbWFsIGB4YCB0byB0aGUgcG93ZXIgYG5gLCB3aGVyZSBgbmAgaXMgYW5cclxuICAgKiBpbnRlZ2VyIG9mIHR5cGUgbnVtYmVyLlxyXG4gICAqXHJcbiAgICogSW1wbGVtZW50cyAnZXhwb25lbnRpYXRpb24gYnkgc3F1YXJpbmcnLiBDYWxsZWQgYnkgYHBvd2AgYW5kIGBwYXJzZU90aGVyYC5cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGludFBvdyhDdG9yLCB4LCBuLCBwcikge1xyXG4gICAgdmFyIGlzVHJ1bmNhdGVkLFxyXG4gICAgICByID0gbmV3IEN0b3IoMSksXHJcblxyXG4gICAgICAvLyBNYXggbiBvZiA5MDA3MTk5MjU0NzQwOTkxIHRha2VzIDUzIGxvb3AgaXRlcmF0aW9ucy5cclxuICAgICAgLy8gTWF4aW11bSBkaWdpdHMgYXJyYXkgbGVuZ3RoOyBsZWF2ZXMgWzI4LCAzNF0gZ3VhcmQgZGlnaXRzLlxyXG4gICAgICBrID0gTWF0aC5jZWlsKHByIC8gTE9HX0JBU0UgKyA0KTtcclxuXHJcbiAgICBleHRlcm5hbCA9IGZhbHNlO1xyXG5cclxuICAgIGZvciAoOzspIHtcclxuICAgICAgaWYgKG4gJSAyKSB7XHJcbiAgICAgICAgciA9IHIudGltZXMoeCk7XHJcbiAgICAgICAgaWYgKHRydW5jYXRlKHIuZCwgaykpIGlzVHJ1bmNhdGVkID0gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbiA9IG1hdGhmbG9vcihuIC8gMik7XHJcbiAgICAgIGlmIChuID09PSAwKSB7XHJcblxyXG4gICAgICAgIC8vIFRvIGVuc3VyZSBjb3JyZWN0IHJvdW5kaW5nIHdoZW4gci5kIGlzIHRydW5jYXRlZCwgaW5jcmVtZW50IHRoZSBsYXN0IHdvcmQgaWYgaXQgaXMgemVyby5cclxuICAgICAgICBuID0gci5kLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgaWYgKGlzVHJ1bmNhdGVkICYmIHIuZFtuXSA9PT0gMCkgKytyLmRbbl07XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHggPSB4LnRpbWVzKHgpO1xyXG4gICAgICB0cnVuY2F0ZSh4LmQsIGspO1xyXG4gICAgfVxyXG5cclxuICAgIGV4dGVybmFsID0gdHJ1ZTtcclxuXHJcbiAgICByZXR1cm4gcjtcclxuICB9XHJcblxyXG5cclxuICBmdW5jdGlvbiBpc09kZChuKSB7XHJcbiAgICByZXR1cm4gbi5kW24uZC5sZW5ndGggLSAxXSAmIDE7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBIYW5kbGUgYG1heGAgYW5kIGBtaW5gLiBgbHRndGAgaXMgJ2x0JyBvciAnZ3QnLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIG1heE9yTWluKEN0b3IsIGFyZ3MsIGx0Z3QpIHtcclxuICAgIHZhciB5LFxyXG4gICAgICB4ID0gbmV3IEN0b3IoYXJnc1swXSksXHJcbiAgICAgIGkgPSAwO1xyXG5cclxuICAgIGZvciAoOyArK2kgPCBhcmdzLmxlbmd0aDspIHtcclxuICAgICAgeSA9IG5ldyBDdG9yKGFyZ3NbaV0pO1xyXG4gICAgICBpZiAoIXkucykge1xyXG4gICAgICAgIHggPSB5O1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9IGVsc2UgaWYgKHhbbHRndF0oeSkpIHtcclxuICAgICAgICB4ID0geTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB4O1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIG5hdHVyYWwgZXhwb25lbnRpYWwgb2YgYHhgIHJvdW5kZWQgdG8gYHNkYCBzaWduaWZpY2FudFxyXG4gICAqIGRpZ2l0cy5cclxuICAgKlxyXG4gICAqIFRheWxvci9NYWNsYXVyaW4gc2VyaWVzLlxyXG4gICAqXHJcbiAgICogZXhwKHgpID0geF4wLzAhICsgeF4xLzEhICsgeF4yLzIhICsgeF4zLzMhICsgLi4uXHJcbiAgICpcclxuICAgKiBBcmd1bWVudCByZWR1Y3Rpb246XHJcbiAgICogICBSZXBlYXQgeCA9IHggLyAzMiwgayArPSA1LCB1bnRpbCB8eHwgPCAwLjFcclxuICAgKiAgIGV4cCh4KSA9IGV4cCh4IC8gMl5rKV4oMl5rKVxyXG4gICAqXHJcbiAgICogUHJldmlvdXNseSwgdGhlIGFyZ3VtZW50IHdhcyBpbml0aWFsbHkgcmVkdWNlZCBieVxyXG4gICAqIGV4cCh4KSA9IGV4cChyKSAqIDEwXmsgIHdoZXJlIHIgPSB4IC0gayAqIGxuMTAsIGsgPSBmbG9vcih4IC8gbG4xMClcclxuICAgKiB0byBmaXJzdCBwdXQgciBpbiB0aGUgcmFuZ2UgWzAsIGxuMTBdLCBiZWZvcmUgZGl2aWRpbmcgYnkgMzIgdW50aWwgfHh8IDwgMC4xLCBidXQgdGhpcyB3YXNcclxuICAgKiBmb3VuZCB0byBiZSBzbG93ZXIgdGhhbiBqdXN0IGRpdmlkaW5nIHJlcGVhdGVkbHkgYnkgMzIgYXMgYWJvdmUuXHJcbiAgICpcclxuICAgKiBNYXggaW50ZWdlciBhcmd1bWVudDogZXhwKCcyMDcyMzI2NTgzNjk0NjQxMycpID0gNi4zZSs5MDAwMDAwMDAwMDAwMDAwXHJcbiAgICogTWluIGludGVnZXIgYXJndW1lbnQ6IGV4cCgnLTIwNzIzMjY1ODM2OTQ2NDExJykgPSAxLjJlLTkwMDAwMDAwMDAwMDAwMDBcclxuICAgKiAoTWF0aCBvYmplY3QgaW50ZWdlciBtaW4vbWF4OiBNYXRoLmV4cCg3MDkpID0gOC4yZSszMDcsIE1hdGguZXhwKC03NDUpID0gNWUtMzI0KVxyXG4gICAqXHJcbiAgICogIGV4cChJbmZpbml0eSkgID0gSW5maW5pdHlcclxuICAgKiAgZXhwKC1JbmZpbml0eSkgPSAwXHJcbiAgICogIGV4cChOYU4pICAgICAgID0gTmFOXHJcbiAgICogIGV4cCjCsTApICAgICAgICA9IDFcclxuICAgKlxyXG4gICAqICBleHAoeCkgaXMgbm9uLXRlcm1pbmF0aW5nIGZvciBhbnkgZmluaXRlLCBub24temVybyB4LlxyXG4gICAqXHJcbiAgICogIFRoZSByZXN1bHQgd2lsbCBhbHdheXMgYmUgY29ycmVjdGx5IHJvdW5kZWQuXHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBuYXR1cmFsRXhwb25lbnRpYWwoeCwgc2QpIHtcclxuICAgIHZhciBkZW5vbWluYXRvciwgZ3VhcmQsIGosIHBvdywgc3VtLCB0LCB3cHIsXHJcbiAgICAgIHJlcCA9IDAsXHJcbiAgICAgIGkgPSAwLFxyXG4gICAgICBrID0gMCxcclxuICAgICAgQ3RvciA9IHguY29uc3RydWN0b3IsXHJcbiAgICAgIHJtID0gQ3Rvci5yb3VuZGluZyxcclxuICAgICAgcHIgPSBDdG9yLnByZWNpc2lvbjtcclxuXHJcbiAgICAvLyAwL05hTi9JbmZpbml0eT9cclxuICAgIGlmICgheC5kIHx8ICF4LmRbMF0gfHwgeC5lID4gMTcpIHtcclxuXHJcbiAgICAgIHJldHVybiBuZXcgQ3Rvcih4LmRcclxuICAgICAgICA/ICF4LmRbMF0gPyAxIDogeC5zIDwgMCA/IDAgOiAxIC8gMFxyXG4gICAgICAgIDogeC5zID8geC5zIDwgMCA/IDAgOiB4IDogMCAvIDApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzZCA9PSBudWxsKSB7XHJcbiAgICAgIGV4dGVybmFsID0gZmFsc2U7XHJcbiAgICAgIHdwciA9IHByO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgd3ByID0gc2Q7XHJcbiAgICB9XHJcblxyXG4gICAgdCA9IG5ldyBDdG9yKDAuMDMxMjUpO1xyXG5cclxuICAgIC8vIHdoaWxlIGFicyh4KSA+PSAwLjFcclxuICAgIHdoaWxlICh4LmUgPiAtMikge1xyXG5cclxuICAgICAgLy8geCA9IHggLyAyXjVcclxuICAgICAgeCA9IHgudGltZXModCk7XHJcbiAgICAgIGsgKz0gNTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBVc2UgMiAqIGxvZzEwKDJeaykgKyA1IChlbXBpcmljYWxseSBkZXJpdmVkKSB0byBlc3RpbWF0ZSB0aGUgaW5jcmVhc2UgaW4gcHJlY2lzaW9uXHJcbiAgICAvLyBuZWNlc3NhcnkgdG8gZW5zdXJlIHRoZSBmaXJzdCA0IHJvdW5kaW5nIGRpZ2l0cyBhcmUgY29ycmVjdC5cclxuICAgIGd1YXJkID0gTWF0aC5sb2cobWF0aHBvdygyLCBrKSkgLyBNYXRoLkxOMTAgKiAyICsgNSB8IDA7XHJcbiAgICB3cHIgKz0gZ3VhcmQ7XHJcbiAgICBkZW5vbWluYXRvciA9IHBvdyA9IHN1bSA9IG5ldyBDdG9yKDEpO1xyXG4gICAgQ3Rvci5wcmVjaXNpb24gPSB3cHI7XHJcblxyXG4gICAgZm9yICg7Oykge1xyXG4gICAgICBwb3cgPSBmaW5hbGlzZShwb3cudGltZXMoeCksIHdwciwgMSk7XHJcbiAgICAgIGRlbm9taW5hdG9yID0gZGVub21pbmF0b3IudGltZXMoKytpKTtcclxuICAgICAgdCA9IHN1bS5wbHVzKGRpdmlkZShwb3csIGRlbm9taW5hdG9yLCB3cHIsIDEpKTtcclxuXHJcbiAgICAgIGlmIChkaWdpdHNUb1N0cmluZyh0LmQpLnNsaWNlKDAsIHdwcikgPT09IGRpZ2l0c1RvU3RyaW5nKHN1bS5kKS5zbGljZSgwLCB3cHIpKSB7XHJcbiAgICAgICAgaiA9IGs7XHJcbiAgICAgICAgd2hpbGUgKGotLSkgc3VtID0gZmluYWxpc2Uoc3VtLnRpbWVzKHN1bSksIHdwciwgMSk7XHJcblxyXG4gICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB0aGUgZmlyc3QgNCByb3VuZGluZyBkaWdpdHMgYXJlIFs0OV05OTkuXHJcbiAgICAgICAgLy8gSWYgc28sIHJlcGVhdCB0aGUgc3VtbWF0aW9uIHdpdGggYSBoaWdoZXIgcHJlY2lzaW9uLCBvdGhlcndpc2VcclxuICAgICAgICAvLyBlLmcuIHdpdGggcHJlY2lzaW9uOiAxOCwgcm91bmRpbmc6IDFcclxuICAgICAgICAvLyBleHAoMTguNDA0MjcyNDYyNTk1MDM0MDgzNTY3NzkzOTE5ODQzNzYxKSA9IDk4MzcyNTYwLjEyMjk5OTk5OTkgKHNob3VsZCBiZSA5ODM3MjU2MC4xMjMpXHJcbiAgICAgICAgLy8gYHdwciAtIGd1YXJkYCBpcyB0aGUgaW5kZXggb2YgZmlyc3Qgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgaWYgKHNkID09IG51bGwpIHtcclxuXHJcbiAgICAgICAgICBpZiAocmVwIDwgMyAmJiBjaGVja1JvdW5kaW5nRGlnaXRzKHN1bS5kLCB3cHIgLSBndWFyZCwgcm0sIHJlcCkpIHtcclxuICAgICAgICAgICAgQ3Rvci5wcmVjaXNpb24gPSB3cHIgKz0gMTA7XHJcbiAgICAgICAgICAgIGRlbm9taW5hdG9yID0gcG93ID0gdCA9IG5ldyBDdG9yKDEpO1xyXG4gICAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgICAgcmVwKys7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZmluYWxpc2Uoc3VtLCBDdG9yLnByZWNpc2lvbiA9IHByLCBybSwgZXh0ZXJuYWwgPSB0cnVlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcclxuICAgICAgICAgIHJldHVybiBzdW07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBzdW0gPSB0O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIG5hdHVyYWwgbG9nYXJpdGhtIG9mIGB4YCByb3VuZGVkIHRvIGBzZGAgc2lnbmlmaWNhbnRcclxuICAgKiBkaWdpdHMuXHJcbiAgICpcclxuICAgKiAgbG4oLW4pICAgICAgICA9IE5hTlxyXG4gICAqICBsbigwKSAgICAgICAgID0gLUluZmluaXR5XHJcbiAgICogIGxuKC0wKSAgICAgICAgPSAtSW5maW5pdHlcclxuICAgKiAgbG4oMSkgICAgICAgICA9IDBcclxuICAgKiAgbG4oSW5maW5pdHkpICA9IEluZmluaXR5XHJcbiAgICogIGxuKC1JbmZpbml0eSkgPSBOYU5cclxuICAgKiAgbG4oTmFOKSAgICAgICA9IE5hTlxyXG4gICAqXHJcbiAgICogIGxuKG4pIChuICE9IDEpIGlzIG5vbi10ZXJtaW5hdGluZy5cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIG5hdHVyYWxMb2dhcml0aG0oeSwgc2QpIHtcclxuICAgIHZhciBjLCBjMCwgZGVub21pbmF0b3IsIGUsIG51bWVyYXRvciwgcmVwLCBzdW0sIHQsIHdwciwgeDEsIHgyLFxyXG4gICAgICBuID0gMSxcclxuICAgICAgZ3VhcmQgPSAxMCxcclxuICAgICAgeCA9IHksXHJcbiAgICAgIHhkID0geC5kLFxyXG4gICAgICBDdG9yID0geC5jb25zdHJ1Y3RvcixcclxuICAgICAgcm0gPSBDdG9yLnJvdW5kaW5nLFxyXG4gICAgICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG5cclxuICAgIC8vIElzIHggbmVnYXRpdmUgb3IgSW5maW5pdHksIE5hTiwgMCBvciAxP1xyXG4gICAgaWYgKHgucyA8IDAgfHwgIXhkIHx8ICF4ZFswXSB8fCAheC5lICYmIHhkWzBdID09IDEgJiYgeGQubGVuZ3RoID09IDEpIHtcclxuICAgICAgcmV0dXJuIG5ldyBDdG9yKHhkICYmICF4ZFswXSA/IC0xIC8gMCA6IHgucyAhPSAxID8gTmFOIDogeGQgPyAwIDogeCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNkID09IG51bGwpIHtcclxuICAgICAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuICAgICAgd3ByID0gcHI7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB3cHIgPSBzZDtcclxuICAgIH1cclxuXHJcbiAgICBDdG9yLnByZWNpc2lvbiA9IHdwciArPSBndWFyZDtcclxuICAgIGMgPSBkaWdpdHNUb1N0cmluZyh4ZCk7XHJcbiAgICBjMCA9IGMuY2hhckF0KDApO1xyXG5cclxuICAgIGlmIChNYXRoLmFicyhlID0geC5lKSA8IDEuNWUxNSkge1xyXG5cclxuICAgICAgLy8gQXJndW1lbnQgcmVkdWN0aW9uLlxyXG4gICAgICAvLyBUaGUgc2VyaWVzIGNvbnZlcmdlcyBmYXN0ZXIgdGhlIGNsb3NlciB0aGUgYXJndW1lbnQgaXMgdG8gMSwgc28gdXNpbmdcclxuICAgICAgLy8gbG4oYV5iKSA9IGIgKiBsbihhKSwgICBsbihhKSA9IGxuKGFeYikgLyBiXHJcbiAgICAgIC8vIG11bHRpcGx5IHRoZSBhcmd1bWVudCBieSBpdHNlbGYgdW50aWwgdGhlIGxlYWRpbmcgZGlnaXRzIG9mIHRoZSBzaWduaWZpY2FuZCBhcmUgNywgOCwgOSxcclxuICAgICAgLy8gMTAsIDExLCAxMiBvciAxMywgcmVjb3JkaW5nIHRoZSBudW1iZXIgb2YgbXVsdGlwbGljYXRpb25zIHNvIHRoZSBzdW0gb2YgdGhlIHNlcmllcyBjYW5cclxuICAgICAgLy8gbGF0ZXIgYmUgZGl2aWRlZCBieSB0aGlzIG51bWJlciwgdGhlbiBzZXBhcmF0ZSBvdXQgdGhlIHBvd2VyIG9mIDEwIHVzaW5nXHJcbiAgICAgIC8vIGxuKGEqMTBeYikgPSBsbihhKSArIGIqbG4oMTApLlxyXG5cclxuICAgICAgLy8gbWF4IG4gaXMgMjEgKGdpdmVzIDAuOSwgMS4wIG9yIDEuMSkgKDllMTUgLyAyMSA9IDQuMmUxNCkuXHJcbiAgICAgIC8vd2hpbGUgKGMwIDwgOSAmJiBjMCAhPSAxIHx8IGMwID09IDEgJiYgYy5jaGFyQXQoMSkgPiAxKSB7XHJcbiAgICAgIC8vIG1heCBuIGlzIDYgKGdpdmVzIDAuNyAtIDEuMylcclxuICAgICAgd2hpbGUgKGMwIDwgNyAmJiBjMCAhPSAxIHx8IGMwID09IDEgJiYgYy5jaGFyQXQoMSkgPiAzKSB7XHJcbiAgICAgICAgeCA9IHgudGltZXMoeSk7XHJcbiAgICAgICAgYyA9IGRpZ2l0c1RvU3RyaW5nKHguZCk7XHJcbiAgICAgICAgYzAgPSBjLmNoYXJBdCgwKTtcclxuICAgICAgICBuKys7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGUgPSB4LmU7XHJcblxyXG4gICAgICBpZiAoYzAgPiAxKSB7XHJcbiAgICAgICAgeCA9IG5ldyBDdG9yKCcwLicgKyBjKTtcclxuICAgICAgICBlKys7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgeCA9IG5ldyBDdG9yKGMwICsgJy4nICsgYy5zbGljZSgxKSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAvLyBUaGUgYXJndW1lbnQgcmVkdWN0aW9uIG1ldGhvZCBhYm92ZSBtYXkgcmVzdWx0IGluIG92ZXJmbG93IGlmIHRoZSBhcmd1bWVudCB5IGlzIGEgbWFzc2l2ZVxyXG4gICAgICAvLyBudW1iZXIgd2l0aCBleHBvbmVudCA+PSAxNTAwMDAwMDAwMDAwMDAwICg5ZTE1IC8gNiA9IDEuNWUxNSksIHNvIGluc3RlYWQgcmVjYWxsIHRoaXNcclxuICAgICAgLy8gZnVuY3Rpb24gdXNpbmcgbG4oeCoxMF5lKSA9IGxuKHgpICsgZSpsbigxMCkuXHJcbiAgICAgIHQgPSBnZXRMbjEwKEN0b3IsIHdwciArIDIsIHByKS50aW1lcyhlICsgJycpO1xyXG4gICAgICB4ID0gbmF0dXJhbExvZ2FyaXRobShuZXcgQ3RvcihjMCArICcuJyArIGMuc2xpY2UoMSkpLCB3cHIgLSBndWFyZCkucGx1cyh0KTtcclxuICAgICAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcclxuXHJcbiAgICAgIHJldHVybiBzZCA9PSBudWxsID8gZmluYWxpc2UoeCwgcHIsIHJtLCBleHRlcm5hbCA9IHRydWUpIDogeDtcclxuICAgIH1cclxuXHJcbiAgICAvLyB4MSBpcyB4IHJlZHVjZWQgdG8gYSB2YWx1ZSBuZWFyIDEuXHJcbiAgICB4MSA9IHg7XHJcblxyXG4gICAgLy8gVGF5bG9yIHNlcmllcy5cclxuICAgIC8vIGxuKHkpID0gbG4oKDEgKyB4KS8oMSAtIHgpKSA9IDIoeCArIHheMy8zICsgeF41LzUgKyB4XjcvNyArIC4uLilcclxuICAgIC8vIHdoZXJlIHggPSAoeSAtIDEpLyh5ICsgMSkgICAgKHx4fCA8IDEpXHJcbiAgICBzdW0gPSBudW1lcmF0b3IgPSB4ID0gZGl2aWRlKHgubWludXMoMSksIHgucGx1cygxKSwgd3ByLCAxKTtcclxuICAgIHgyID0gZmluYWxpc2UoeC50aW1lcyh4KSwgd3ByLCAxKTtcclxuICAgIGRlbm9taW5hdG9yID0gMztcclxuXHJcbiAgICBmb3IgKDs7KSB7XHJcbiAgICAgIG51bWVyYXRvciA9IGZpbmFsaXNlKG51bWVyYXRvci50aW1lcyh4MiksIHdwciwgMSk7XHJcbiAgICAgIHQgPSBzdW0ucGx1cyhkaXZpZGUobnVtZXJhdG9yLCBuZXcgQ3RvcihkZW5vbWluYXRvciksIHdwciwgMSkpO1xyXG5cclxuICAgICAgaWYgKGRpZ2l0c1RvU3RyaW5nKHQuZCkuc2xpY2UoMCwgd3ByKSA9PT0gZGlnaXRzVG9TdHJpbmcoc3VtLmQpLnNsaWNlKDAsIHdwcikpIHtcclxuICAgICAgICBzdW0gPSBzdW0udGltZXMoMik7XHJcblxyXG4gICAgICAgIC8vIFJldmVyc2UgdGhlIGFyZ3VtZW50IHJlZHVjdGlvbi4gQ2hlY2sgdGhhdCBlIGlzIG5vdCAwIGJlY2F1c2UsIGJlc2lkZXMgcHJldmVudGluZyBhblxyXG4gICAgICAgIC8vIHVubmVjZXNzYXJ5IGNhbGN1bGF0aW9uLCAtMCArIDAgPSArMCBhbmQgdG8gZW5zdXJlIGNvcnJlY3Qgcm91bmRpbmcgLTAgbmVlZHMgdG8gc3RheSAtMC5cclxuICAgICAgICBpZiAoZSAhPT0gMCkgc3VtID0gc3VtLnBsdXMoZ2V0TG4xMChDdG9yLCB3cHIgKyAyLCBwcikudGltZXMoZSArICcnKSk7XHJcbiAgICAgICAgc3VtID0gZGl2aWRlKHN1bSwgbmV3IEN0b3IobiksIHdwciwgMSk7XHJcblxyXG4gICAgICAgIC8vIElzIHJtID4gMyBhbmQgdGhlIGZpcnN0IDQgcm91bmRpbmcgZGlnaXRzIDQ5OTksIG9yIHJtIDwgNCAob3IgdGhlIHN1bW1hdGlvbiBoYXNcclxuICAgICAgICAvLyBiZWVuIHJlcGVhdGVkIHByZXZpb3VzbHkpIGFuZCB0aGUgZmlyc3QgNCByb3VuZGluZyBkaWdpdHMgOTk5OT9cclxuICAgICAgICAvLyBJZiBzbywgcmVzdGFydCB0aGUgc3VtbWF0aW9uIHdpdGggYSBoaWdoZXIgcHJlY2lzaW9uLCBvdGhlcndpc2VcclxuICAgICAgICAvLyBlLmcuIHdpdGggcHJlY2lzaW9uOiAxMiwgcm91bmRpbmc6IDFcclxuICAgICAgICAvLyBsbigxMzU1MjAwMjguNjEyNjA5MTcxNDI2NTM4MTUzMykgPSAxOC43MjQ2Mjk5OTk5IHdoZW4gaXQgc2hvdWxkIGJlIDE4LjcyNDYzLlxyXG4gICAgICAgIC8vIGB3cHIgLSBndWFyZGAgaXMgdGhlIGluZGV4IG9mIGZpcnN0IHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgIGlmIChzZCA9PSBudWxsKSB7XHJcbiAgICAgICAgICBpZiAoY2hlY2tSb3VuZGluZ0RpZ2l0cyhzdW0uZCwgd3ByIC0gZ3VhcmQsIHJtLCByZXApKSB7XHJcbiAgICAgICAgICAgIEN0b3IucHJlY2lzaW9uID0gd3ByICs9IGd1YXJkO1xyXG4gICAgICAgICAgICB0ID0gbnVtZXJhdG9yID0geCA9IGRpdmlkZSh4MS5taW51cygxKSwgeDEucGx1cygxKSwgd3ByLCAxKTtcclxuICAgICAgICAgICAgeDIgPSBmaW5hbGlzZSh4LnRpbWVzKHgpLCB3cHIsIDEpO1xyXG4gICAgICAgICAgICBkZW5vbWluYXRvciA9IHJlcCA9IDE7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZmluYWxpc2Uoc3VtLCBDdG9yLnByZWNpc2lvbiA9IHByLCBybSwgZXh0ZXJuYWwgPSB0cnVlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcclxuICAgICAgICAgIHJldHVybiBzdW07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBzdW0gPSB0O1xyXG4gICAgICBkZW5vbWluYXRvciArPSAyO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG4gIC8vIMKxSW5maW5pdHksIE5hTi5cclxuICBmdW5jdGlvbiBub25GaW5pdGVUb1N0cmluZyh4KSB7XHJcbiAgICAvLyBVbnNpZ25lZC5cclxuICAgIHJldHVybiBTdHJpbmcoeC5zICogeC5zIC8gMCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBQYXJzZSB0aGUgdmFsdWUgb2YgYSBuZXcgRGVjaW1hbCBgeGAgZnJvbSBzdHJpbmcgYHN0cmAuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gcGFyc2VEZWNpbWFsKHgsIHN0cikge1xyXG4gICAgdmFyIGUsIGksIGxlbjtcclxuXHJcbiAgICAvLyBEZWNpbWFsIHBvaW50P1xyXG4gICAgaWYgKChlID0gc3RyLmluZGV4T2YoJy4nKSkgPiAtMSkgc3RyID0gc3RyLnJlcGxhY2UoJy4nLCAnJyk7XHJcblxyXG4gICAgLy8gRXhwb25lbnRpYWwgZm9ybT9cclxuICAgIGlmICgoaSA9IHN0ci5zZWFyY2goL2UvaSkpID4gMCkge1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIGV4cG9uZW50LlxyXG4gICAgICBpZiAoZSA8IDApIGUgPSBpO1xyXG4gICAgICBlICs9ICtzdHIuc2xpY2UoaSArIDEpO1xyXG4gICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIGkpO1xyXG4gICAgfSBlbHNlIGlmIChlIDwgMCkge1xyXG5cclxuICAgICAgLy8gSW50ZWdlci5cclxuICAgICAgZSA9IHN0ci5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIGxlYWRpbmcgemVyb3MuXHJcbiAgICBmb3IgKGkgPSAwOyBzdHIuY2hhckNvZGVBdChpKSA9PT0gNDg7IGkrKyk7XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgZm9yIChsZW4gPSBzdHIubGVuZ3RoOyBzdHIuY2hhckNvZGVBdChsZW4gLSAxKSA9PT0gNDg7IC0tbGVuKTtcclxuICAgIHN0ciA9IHN0ci5zbGljZShpLCBsZW4pO1xyXG5cclxuICAgIGlmIChzdHIpIHtcclxuICAgICAgbGVuIC09IGk7XHJcbiAgICAgIHguZSA9IGUgPSBlIC0gaSAtIDE7XHJcbiAgICAgIHguZCA9IFtdO1xyXG5cclxuICAgICAgLy8gVHJhbnNmb3JtIGJhc2VcclxuXHJcbiAgICAgIC8vIGUgaXMgdGhlIGJhc2UgMTAgZXhwb25lbnQuXHJcbiAgICAgIC8vIGkgaXMgd2hlcmUgdG8gc2xpY2Ugc3RyIHRvIGdldCB0aGUgZmlyc3Qgd29yZCBvZiB0aGUgZGlnaXRzIGFycmF5LlxyXG4gICAgICBpID0gKGUgKyAxKSAlIExPR19CQVNFO1xyXG4gICAgICBpZiAoZSA8IDApIGkgKz0gTE9HX0JBU0U7XHJcblxyXG4gICAgICBpZiAoaSA8IGxlbikge1xyXG4gICAgICAgIGlmIChpKSB4LmQucHVzaCgrc3RyLnNsaWNlKDAsIGkpKTtcclxuICAgICAgICBmb3IgKGxlbiAtPSBMT0dfQkFTRTsgaSA8IGxlbjspIHguZC5wdXNoKCtzdHIuc2xpY2UoaSwgaSArPSBMT0dfQkFTRSkpO1xyXG4gICAgICAgIHN0ciA9IHN0ci5zbGljZShpKTtcclxuICAgICAgICBpID0gTE9HX0JBU0UgLSBzdHIubGVuZ3RoO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGkgLT0gbGVuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IgKDsgaS0tOykgc3RyICs9ICcwJztcclxuICAgICAgeC5kLnB1c2goK3N0cik7XHJcblxyXG4gICAgICBpZiAoZXh0ZXJuYWwpIHtcclxuXHJcbiAgICAgICAgLy8gT3ZlcmZsb3c/XHJcbiAgICAgICAgaWYgKHguZSA+IHguY29uc3RydWN0b3IubWF4RSkge1xyXG5cclxuICAgICAgICAgIC8vIEluZmluaXR5LlxyXG4gICAgICAgICAgeC5kID0gbnVsbDtcclxuICAgICAgICAgIHguZSA9IE5hTjtcclxuXHJcbiAgICAgICAgLy8gVW5kZXJmbG93P1xyXG4gICAgICAgIH0gZWxzZSBpZiAoeC5lIDwgeC5jb25zdHJ1Y3Rvci5taW5FKSB7XHJcblxyXG4gICAgICAgICAgLy8gWmVyby5cclxuICAgICAgICAgIHguZSA9IDA7XHJcbiAgICAgICAgICB4LmQgPSBbMF07XHJcbiAgICAgICAgICAvLyB4LmNvbnN0cnVjdG9yLnVuZGVyZmxvdyA9IHRydWU7XHJcbiAgICAgICAgfSAvLyBlbHNlIHguY29uc3RydWN0b3IudW5kZXJmbG93ID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAvLyBaZXJvLlxyXG4gICAgICB4LmUgPSAwO1xyXG4gICAgICB4LmQgPSBbMF07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHg7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBQYXJzZSB0aGUgdmFsdWUgb2YgYSBuZXcgRGVjaW1hbCBgeGAgZnJvbSBhIHN0cmluZyBgc3RyYCwgd2hpY2ggaXMgbm90IGEgZGVjaW1hbCB2YWx1ZS5cclxuICAgKi9cclxuICBmdW5jdGlvbiBwYXJzZU90aGVyKHgsIHN0cikge1xyXG4gICAgdmFyIGJhc2UsIEN0b3IsIGRpdmlzb3IsIGksIGlzRmxvYXQsIGxlbiwgcCwgeGQsIHhlO1xyXG5cclxuICAgIGlmIChzdHIgPT09ICdJbmZpbml0eScgfHwgc3RyID09PSAnTmFOJykge1xyXG4gICAgICBpZiAoIStzdHIpIHgucyA9IE5hTjtcclxuICAgICAgeC5lID0gTmFOO1xyXG4gICAgICB4LmQgPSBudWxsO1xyXG4gICAgICByZXR1cm4geDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNIZXgudGVzdChzdHIpKSAge1xyXG4gICAgICBiYXNlID0gMTY7XHJcbiAgICAgIHN0ciA9IHN0ci50b0xvd2VyQ2FzZSgpO1xyXG4gICAgfSBlbHNlIGlmIChpc0JpbmFyeS50ZXN0KHN0cikpICB7XHJcbiAgICAgIGJhc2UgPSAyO1xyXG4gICAgfSBlbHNlIGlmIChpc09jdGFsLnRlc3Qoc3RyKSkgIHtcclxuICAgICAgYmFzZSA9IDg7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvdyBFcnJvcihpbnZhbGlkQXJndW1lbnQgKyBzdHIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElzIHRoZXJlIGEgYmluYXJ5IGV4cG9uZW50IHBhcnQ/XHJcbiAgICBpID0gc3RyLnNlYXJjaCgvcC9pKTtcclxuXHJcbiAgICBpZiAoaSA+IDApIHtcclxuICAgICAgcCA9ICtzdHIuc2xpY2UoaSArIDEpO1xyXG4gICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDIsIGkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc3RyID0gc3RyLnNsaWNlKDIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENvbnZlcnQgYHN0cmAgYXMgYW4gaW50ZWdlciB0aGVuIGRpdmlkZSB0aGUgcmVzdWx0IGJ5IGBiYXNlYCByYWlzZWQgdG8gYSBwb3dlciBzdWNoIHRoYXQgdGhlXHJcbiAgICAvLyBmcmFjdGlvbiBwYXJ0IHdpbGwgYmUgcmVzdG9yZWQuXHJcbiAgICBpID0gc3RyLmluZGV4T2YoJy4nKTtcclxuICAgIGlzRmxvYXQgPSBpID49IDA7XHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgICBpZiAoaXNGbG9hdCkge1xyXG4gICAgICBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuICAgICAgaSA9IGxlbiAtIGk7XHJcblxyXG4gICAgICAvLyBsb2dbMTBdKDE2KSA9IDEuMjA0MS4uLiAsIGxvZ1sxMF0oODgpID0gMS45NDQ0Li4uLlxyXG4gICAgICBkaXZpc29yID0gaW50UG93KEN0b3IsIG5ldyBDdG9yKGJhc2UpLCBpLCBpICogMik7XHJcbiAgICB9XHJcblxyXG4gICAgeGQgPSBjb252ZXJ0QmFzZShzdHIsIGJhc2UsIEJBU0UpO1xyXG4gICAgeGUgPSB4ZC5sZW5ndGggLSAxO1xyXG5cclxuICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgIGZvciAoaSA9IHhlOyB4ZFtpXSA9PT0gMDsgLS1pKSB4ZC5wb3AoKTtcclxuICAgIGlmIChpIDwgMCkgcmV0dXJuIG5ldyBDdG9yKHgucyAqIDApO1xyXG4gICAgeC5lID0gZ2V0QmFzZTEwRXhwb25lbnQoeGQsIHhlKTtcclxuICAgIHguZCA9IHhkO1xyXG4gICAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuXHJcbiAgICAvLyBBdCB3aGF0IHByZWNpc2lvbiB0byBwZXJmb3JtIHRoZSBkaXZpc2lvbiB0byBlbnN1cmUgZXhhY3QgY29udmVyc2lvbj9cclxuICAgIC8vIG1heERlY2ltYWxJbnRlZ2VyUGFydERpZ2l0Q291bnQgPSBjZWlsKGxvZ1sxMF0oYikgKiBvdGhlckJhc2VJbnRlZ2VyUGFydERpZ2l0Q291bnQpXHJcbiAgICAvLyBsb2dbMTBdKDIpID0gMC4zMDEwMywgbG9nWzEwXSg4KSA9IDAuOTAzMDksIGxvZ1sxMF0oMTYpID0gMS4yMDQxMlxyXG4gICAgLy8gRS5nLiBjZWlsKDEuMiAqIDMpID0gNCwgc28gdXAgdG8gNCBkZWNpbWFsIGRpZ2l0cyBhcmUgbmVlZGVkIHRvIHJlcHJlc2VudCAzIGhleCBpbnQgZGlnaXRzLlxyXG4gICAgLy8gbWF4RGVjaW1hbEZyYWN0aW9uUGFydERpZ2l0Q291bnQgPSB7SGV4OjR8T2N0OjN8QmluOjF9ICogb3RoZXJCYXNlRnJhY3Rpb25QYXJ0RGlnaXRDb3VudFxyXG4gICAgLy8gVGhlcmVmb3JlIHVzaW5nIDQgKiB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBzdHIgd2lsbCBhbHdheXMgYmUgZW5vdWdoLlxyXG4gICAgaWYgKGlzRmxvYXQpIHggPSBkaXZpZGUoeCwgZGl2aXNvciwgbGVuICogNCk7XHJcblxyXG4gICAgLy8gTXVsdGlwbHkgYnkgdGhlIGJpbmFyeSBleHBvbmVudCBwYXJ0IGlmIHByZXNlbnQuXHJcbiAgICBpZiAocCkgeCA9IHgudGltZXMoTWF0aC5hYnMocCkgPCA1NCA/IE1hdGgucG93KDIsIHApIDogRGVjaW1hbC5wb3coMiwgcCkpO1xyXG4gICAgZXh0ZXJuYWwgPSB0cnVlO1xyXG5cclxuICAgIHJldHVybiB4O1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogc2luKHgpID0geCAtIHheMy8zISArIHheNS81ISAtIC4uLlxyXG4gICAqIHx4fCA8IHBpLzJcclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHNpbmUoQ3RvciwgeCkge1xyXG4gICAgdmFyIGssXHJcbiAgICAgIGxlbiA9IHguZC5sZW5ndGg7XHJcblxyXG4gICAgaWYgKGxlbiA8IDMpIHJldHVybiB0YXlsb3JTZXJpZXMoQ3RvciwgMiwgeCwgeCk7XHJcblxyXG4gICAgLy8gQXJndW1lbnQgcmVkdWN0aW9uOiBzaW4oNXgpID0gMTYqc2luXjUoeCkgLSAyMCpzaW5eMyh4KSArIDUqc2luKHgpXHJcbiAgICAvLyBpLmUuIHNpbih4KSA9IDE2KnNpbl41KHgvNSkgLSAyMCpzaW5eMyh4LzUpICsgNSpzaW4oeC81KVxyXG4gICAgLy8gYW5kICBzaW4oeCkgPSBzaW4oeC81KSg1ICsgc2luXjIoeC81KSgxNnNpbl4yKHgvNSkgLSAyMCkpXHJcblxyXG4gICAgLy8gRXN0aW1hdGUgdGhlIG9wdGltdW0gbnVtYmVyIG9mIHRpbWVzIHRvIHVzZSB0aGUgYXJndW1lbnQgcmVkdWN0aW9uLlxyXG4gICAgayA9IDEuNCAqIE1hdGguc3FydChsZW4pO1xyXG4gICAgayA9IGsgPiAxNiA/IDE2IDogayB8IDA7XHJcblxyXG4gICAgLy8gTWF4IGsgYmVmb3JlIE1hdGgucG93IHByZWNpc2lvbiBsb3NzIGlzIDIyXHJcbiAgICB4ID0geC50aW1lcyhNYXRoLnBvdyg1LCAtaykpO1xyXG4gICAgeCA9IHRheWxvclNlcmllcyhDdG9yLCAyLCB4LCB4KTtcclxuXHJcbiAgICAvLyBSZXZlcnNlIGFyZ3VtZW50IHJlZHVjdGlvblxyXG4gICAgdmFyIHNpbjJfeCxcclxuICAgICAgZDUgPSBuZXcgQ3Rvcig1KSxcclxuICAgICAgZDE2ID0gbmV3IEN0b3IoMTYpLFxyXG4gICAgICBkMjAgPSBuZXcgQ3RvcigyMCk7XHJcbiAgICBmb3IgKDsgay0tOykge1xyXG4gICAgICBzaW4yX3ggPSB4LnRpbWVzKHgpO1xyXG4gICAgICB4ID0geC50aW1lcyhkNS5wbHVzKHNpbjJfeC50aW1lcyhkMTYudGltZXMoc2luMl94KS5taW51cyhkMjApKSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB4O1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIENhbGN1bGF0ZSBUYXlsb3Igc2VyaWVzIGZvciBgY29zYCwgYGNvc2hgLCBgc2luYCBhbmQgYHNpbmhgLlxyXG4gIGZ1bmN0aW9uIHRheWxvclNlcmllcyhDdG9yLCBuLCB4LCB5LCBpc0h5cGVyYm9saWMpIHtcclxuICAgIHZhciBqLCB0LCB1LCB4MixcclxuICAgICAgaSA9IDEsXHJcbiAgICAgIHByID0gQ3Rvci5wcmVjaXNpb24sXHJcbiAgICAgIGsgPSBNYXRoLmNlaWwocHIgLyBMT0dfQkFTRSk7XHJcblxyXG4gICAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuICAgIHgyID0geC50aW1lcyh4KTtcclxuICAgIHUgPSBuZXcgQ3Rvcih5KTtcclxuXHJcbiAgICBmb3IgKDs7KSB7XHJcbiAgICAgIHQgPSBkaXZpZGUodS50aW1lcyh4MiksIG5ldyBDdG9yKG4rKyAqIG4rKyksIHByLCAxKTtcclxuICAgICAgdSA9IGlzSHlwZXJib2xpYyA/IHkucGx1cyh0KSA6IHkubWludXModCk7XHJcbiAgICAgIHkgPSBkaXZpZGUodC50aW1lcyh4MiksIG5ldyBDdG9yKG4rKyAqIG4rKyksIHByLCAxKTtcclxuICAgICAgdCA9IHUucGx1cyh5KTtcclxuXHJcbiAgICAgIGlmICh0LmRba10gIT09IHZvaWQgMCkge1xyXG4gICAgICAgIGZvciAoaiA9IGs7IHQuZFtqXSA9PT0gdS5kW2pdICYmIGotLTspO1xyXG4gICAgICAgIGlmIChqID09IC0xKSBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgICAgaiA9IHU7XHJcbiAgICAgIHUgPSB5O1xyXG4gICAgICB5ID0gdDtcclxuICAgICAgdCA9IGo7XHJcbiAgICAgIGkrKztcclxuICAgIH1cclxuXHJcbiAgICBleHRlcm5hbCA9IHRydWU7XHJcbiAgICB0LmQubGVuZ3RoID0gayArIDE7XHJcblxyXG4gICAgcmV0dXJuIHQ7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gUmV0dXJuIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiBgeGAgcmVkdWNlZCB0byBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gaGFsZiBwaS5cclxuICBmdW5jdGlvbiB0b0xlc3NUaGFuSGFsZlBpKEN0b3IsIHgpIHtcclxuICAgIHZhciB0LFxyXG4gICAgICBpc05lZyA9IHgucyA8IDAsXHJcbiAgICAgIHBpID0gZ2V0UGkoQ3RvciwgQ3Rvci5wcmVjaXNpb24sIDEpLFxyXG4gICAgICBoYWxmUGkgPSBwaS50aW1lcygwLjUpO1xyXG5cclxuICAgIHggPSB4LmFicygpO1xyXG5cclxuICAgIGlmICh4Lmx0ZShoYWxmUGkpKSB7XHJcbiAgICAgIHF1YWRyYW50ID0gaXNOZWcgPyA0IDogMTtcclxuICAgICAgcmV0dXJuIHg7XHJcbiAgICB9XHJcblxyXG4gICAgdCA9IHguZGl2VG9JbnQocGkpO1xyXG5cclxuICAgIGlmICh0LmlzWmVybygpKSB7XHJcbiAgICAgIHF1YWRyYW50ID0gaXNOZWcgPyAzIDogMjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHggPSB4Lm1pbnVzKHQudGltZXMocGkpKTtcclxuXHJcbiAgICAgIC8vIDAgPD0geCA8IHBpXHJcbiAgICAgIGlmICh4Lmx0ZShoYWxmUGkpKSB7XHJcbiAgICAgICAgcXVhZHJhbnQgPSBpc09kZCh0KSA/IChpc05lZyA/IDIgOiAzKSA6IChpc05lZyA/IDQgOiAxKTtcclxuICAgICAgICByZXR1cm4geDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcXVhZHJhbnQgPSBpc09kZCh0KSA/IChpc05lZyA/IDEgOiA0KSA6IChpc05lZyA/IDMgOiAyKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geC5taW51cyhwaSkuYWJzKCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdGhlIHZhbHVlIG9mIERlY2ltYWwgYHhgIGFzIGEgc3RyaW5nIGluIGJhc2UgYGJhc2VPdXRgLlxyXG4gICAqXHJcbiAgICogSWYgdGhlIG9wdGlvbmFsIGBzZGAgYXJndW1lbnQgaXMgcHJlc2VudCBpbmNsdWRlIGEgYmluYXJ5IGV4cG9uZW50IHN1ZmZpeC5cclxuICAgKi9cclxuICBmdW5jdGlvbiB0b1N0cmluZ0JpbmFyeSh4LCBiYXNlT3V0LCBzZCwgcm0pIHtcclxuICAgIHZhciBiYXNlLCBlLCBpLCBrLCBsZW4sIHJvdW5kVXAsIHN0ciwgeGQsIHksXHJcbiAgICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yLFxyXG4gICAgICBpc0V4cCA9IHNkICE9PSB2b2lkIDA7XHJcblxyXG4gICAgaWYgKGlzRXhwKSB7XHJcbiAgICAgIGNoZWNrSW50MzIoc2QsIDEsIE1BWF9ESUdJVFMpO1xyXG4gICAgICBpZiAocm0gPT09IHZvaWQgMCkgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gICAgICBlbHNlIGNoZWNrSW50MzIocm0sIDAsIDgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc2QgPSBDdG9yLnByZWNpc2lvbjtcclxuICAgICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICgheC5pc0Zpbml0ZSgpKSB7XHJcbiAgICAgIHN0ciA9IG5vbkZpbml0ZVRvU3RyaW5nKHgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc3RyID0gZmluaXRlVG9TdHJpbmcoeCk7XHJcbiAgICAgIGkgPSBzdHIuaW5kZXhPZignLicpO1xyXG5cclxuICAgICAgLy8gVXNlIGV4cG9uZW50aWFsIG5vdGF0aW9uIGFjY29yZGluZyB0byBgdG9FeHBQb3NgIGFuZCBgdG9FeHBOZWdgPyBObywgYnV0IGlmIHJlcXVpcmVkOlxyXG4gICAgICAvLyBtYXhCaW5hcnlFeHBvbmVudCA9IGZsb29yKChkZWNpbWFsRXhwb25lbnQgKyAxKSAqIGxvZ1syXSgxMCkpXHJcbiAgICAgIC8vIG1pbkJpbmFyeUV4cG9uZW50ID0gZmxvb3IoZGVjaW1hbEV4cG9uZW50ICogbG9nWzJdKDEwKSlcclxuICAgICAgLy8gbG9nWzJdKDEwKSA9IDMuMzIxOTI4MDk0ODg3MzYyMzQ3ODcwMzE5NDI5NDg5MzkwMTc1ODY0XHJcblxyXG4gICAgICBpZiAoaXNFeHApIHtcclxuICAgICAgICBiYXNlID0gMjtcclxuICAgICAgICBpZiAoYmFzZU91dCA9PSAxNikge1xyXG4gICAgICAgICAgc2QgPSBzZCAqIDQgLSAzO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYmFzZU91dCA9PSA4KSB7XHJcbiAgICAgICAgICBzZCA9IHNkICogMyAtIDI7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGJhc2UgPSBiYXNlT3V0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDb252ZXJ0IHRoZSBudW1iZXIgYXMgYW4gaW50ZWdlciB0aGVuIGRpdmlkZSB0aGUgcmVzdWx0IGJ5IGl0cyBiYXNlIHJhaXNlZCB0byBhIHBvd2VyIHN1Y2hcclxuICAgICAgLy8gdGhhdCB0aGUgZnJhY3Rpb24gcGFydCB3aWxsIGJlIHJlc3RvcmVkLlxyXG5cclxuICAgICAgLy8gTm9uLWludGVnZXIuXHJcbiAgICAgIGlmIChpID49IDApIHtcclxuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuICAgICAgICB5ID0gbmV3IEN0b3IoMSk7XHJcbiAgICAgICAgeS5lID0gc3RyLmxlbmd0aCAtIGk7XHJcbiAgICAgICAgeS5kID0gY29udmVydEJhc2UoZmluaXRlVG9TdHJpbmcoeSksIDEwLCBiYXNlKTtcclxuICAgICAgICB5LmUgPSB5LmQubGVuZ3RoO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB4ZCA9IGNvbnZlcnRCYXNlKHN0ciwgMTAsIGJhc2UpO1xyXG4gICAgICBlID0gbGVuID0geGQubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKDsgeGRbLS1sZW5dID09IDA7KSB4ZC5wb3AoKTtcclxuXHJcbiAgICAgIGlmICgheGRbMF0pIHtcclxuICAgICAgICBzdHIgPSBpc0V4cCA/ICcwcCswJyA6ICcwJztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoaSA8IDApIHtcclxuICAgICAgICAgIGUtLTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeCA9IG5ldyBDdG9yKHgpO1xyXG4gICAgICAgICAgeC5kID0geGQ7XHJcbiAgICAgICAgICB4LmUgPSBlO1xyXG4gICAgICAgICAgeCA9IGRpdmlkZSh4LCB5LCBzZCwgcm0sIDAsIGJhc2UpO1xyXG4gICAgICAgICAgeGQgPSB4LmQ7XHJcbiAgICAgICAgICBlID0geC5lO1xyXG4gICAgICAgICAgcm91bmRVcCA9IGluZXhhY3Q7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUaGUgcm91bmRpbmcgZGlnaXQsIGkuZS4gdGhlIGRpZ2l0IGFmdGVyIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwLlxyXG4gICAgICAgIGkgPSB4ZFtzZF07XHJcbiAgICAgICAgayA9IGJhc2UgLyAyO1xyXG4gICAgICAgIHJvdW5kVXAgPSByb3VuZFVwIHx8IHhkW3NkICsgMV0gIT09IHZvaWQgMDtcclxuXHJcbiAgICAgICAgcm91bmRVcCA9IHJtIDwgNFxyXG4gICAgICAgICAgPyAoaSAhPT0gdm9pZCAwIHx8IHJvdW5kVXApICYmIChybSA9PT0gMCB8fCBybSA9PT0gKHgucyA8IDAgPyAzIDogMikpXHJcbiAgICAgICAgICA6IGkgPiBrIHx8IGkgPT09IGsgJiYgKHJtID09PSA0IHx8IHJvdW5kVXAgfHwgcm0gPT09IDYgJiYgeGRbc2QgLSAxXSAmIDEgfHxcclxuICAgICAgICAgICAgcm0gPT09ICh4LnMgPCAwID8gOCA6IDcpKTtcclxuXHJcbiAgICAgICAgeGQubGVuZ3RoID0gc2Q7XHJcblxyXG4gICAgICAgIGlmIChyb3VuZFVwKSB7XHJcblxyXG4gICAgICAgICAgLy8gUm91bmRpbmcgdXAgbWF5IG1lYW4gdGhlIHByZXZpb3VzIGRpZ2l0IGhhcyB0byBiZSByb3VuZGVkIHVwIGFuZCBzbyBvbi5cclxuICAgICAgICAgIGZvciAoOyArK3hkWy0tc2RdID4gYmFzZSAtIDE7KSB7XHJcbiAgICAgICAgICAgIHhkW3NkXSA9IDA7XHJcbiAgICAgICAgICAgIGlmICghc2QpIHtcclxuICAgICAgICAgICAgICArK2U7XHJcbiAgICAgICAgICAgICAgeGQudW5zaGlmdCgxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgIGZvciAobGVuID0geGQubGVuZ3RoOyAheGRbbGVuIC0gMV07IC0tbGVuKTtcclxuXHJcbiAgICAgICAgLy8gRS5nLiBbNCwgMTEsIDE1XSBiZWNvbWVzIDRiZi5cclxuICAgICAgICBmb3IgKGkgPSAwLCBzdHIgPSAnJzsgaSA8IGxlbjsgaSsrKSBzdHIgKz0gTlVNRVJBTFMuY2hhckF0KHhkW2ldKTtcclxuXHJcbiAgICAgICAgLy8gQWRkIGJpbmFyeSBleHBvbmVudCBzdWZmaXg/XHJcbiAgICAgICAgaWYgKGlzRXhwKSB7XHJcbiAgICAgICAgICBpZiAobGVuID4gMSkge1xyXG4gICAgICAgICAgICBpZiAoYmFzZU91dCA9PSAxNiB8fCBiYXNlT3V0ID09IDgpIHtcclxuICAgICAgICAgICAgICBpID0gYmFzZU91dCA9PSAxNiA/IDQgOiAzO1xyXG4gICAgICAgICAgICAgIGZvciAoLS1sZW47IGxlbiAlIGk7IGxlbisrKSBzdHIgKz0gJzAnO1xyXG4gICAgICAgICAgICAgIHhkID0gY29udmVydEJhc2Uoc3RyLCBiYXNlLCBiYXNlT3V0KTtcclxuICAgICAgICAgICAgICBmb3IgKGxlbiA9IHhkLmxlbmd0aDsgIXhkW2xlbiAtIDFdOyAtLWxlbik7XHJcblxyXG4gICAgICAgICAgICAgIC8vIHhkWzBdIHdpbGwgYWx3YXlzIGJlIGJlIDFcclxuICAgICAgICAgICAgICBmb3IgKGkgPSAxLCBzdHIgPSAnMS4nOyBpIDwgbGVuOyBpKyspIHN0ciArPSBOVU1FUkFMUy5jaGFyQXQoeGRbaV0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHN0ciA9IHN0ci5jaGFyQXQoMCkgKyAnLicgKyBzdHIuc2xpY2UoMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBzdHIgPSAgc3RyICsgKGUgPCAwID8gJ3AnIDogJ3ArJykgKyBlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZSA8IDApIHtcclxuICAgICAgICAgIGZvciAoOyArK2U7KSBzdHIgPSAnMCcgKyBzdHI7XHJcbiAgICAgICAgICBzdHIgPSAnMC4nICsgc3RyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpZiAoKytlID4gbGVuKSBmb3IgKGUgLT0gbGVuOyBlLS0gOykgc3RyICs9ICcwJztcclxuICAgICAgICAgIGVsc2UgaWYgKGUgPCBsZW4pIHN0ciA9IHN0ci5zbGljZSgwLCBlKSArICcuJyArIHN0ci5zbGljZShlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHN0ciA9IChiYXNlT3V0ID09IDE2ID8gJzB4JyA6IGJhc2VPdXQgPT0gMiA/ICcwYicgOiBiYXNlT3V0ID09IDggPyAnMG8nIDogJycpICsgc3RyO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB4LnMgPCAwID8gJy0nICsgc3RyIDogc3RyO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIERvZXMgbm90IHN0cmlwIHRyYWlsaW5nIHplcm9zLlxyXG4gIGZ1bmN0aW9uIHRydW5jYXRlKGFyciwgbGVuKSB7XHJcbiAgICBpZiAoYXJyLmxlbmd0aCA+IGxlbikge1xyXG4gICAgICBhcnIubGVuZ3RoID0gbGVuO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuICAvLyBEZWNpbWFsIG1ldGhvZHNcclxuXHJcblxyXG4gIC8qXHJcbiAgICogIGFic1xyXG4gICAqICBhY29zXHJcbiAgICogIGFjb3NoXHJcbiAgICogIGFkZFxyXG4gICAqICBhc2luXHJcbiAgICogIGFzaW5oXHJcbiAgICogIGF0YW5cclxuICAgKiAgYXRhbmhcclxuICAgKiAgYXRhbjJcclxuICAgKiAgY2JydFxyXG4gICAqICBjZWlsXHJcbiAgICogIGNsb25lXHJcbiAgICogIGNvbmZpZ1xyXG4gICAqICBjb3NcclxuICAgKiAgY29zaFxyXG4gICAqICBkaXZcclxuICAgKiAgZXhwXHJcbiAgICogIGZsb29yXHJcbiAgICogIGZyb21KU09OXHJcbiAgICogIGh5cG90XHJcbiAgICogIGxuXHJcbiAgICogIGxvZ1xyXG4gICAqICBsb2cyXHJcbiAgICogIGxvZzEwXHJcbiAgICogIG1heFxyXG4gICAqICBtaW5cclxuICAgKiAgbW9kXHJcbiAgICogIG11bFxyXG4gICAqICBwb3dcclxuICAgKiAgcmFuZG9tXHJcbiAgICogIHJvdW5kXHJcbiAgICogIHNpZ25cclxuICAgKiAgc2luXHJcbiAgICogIHNpbmhcclxuICAgKiAgc3FydFxyXG4gICAqICBzdWJcclxuICAgKiAgdGFuXHJcbiAgICogIHRhbmhcclxuICAgKiAgdHJ1bmNcclxuICAgKi9cclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIGB4YC5cclxuICAgKlxyXG4gICAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGFicyh4KSB7XHJcbiAgICByZXR1cm4gbmV3IHRoaXMoeCkuYWJzKCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgYXJjY29zaW5lIGluIHJhZGlhbnMgb2YgYHhgLlxyXG4gICAqXHJcbiAgICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gICAqXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gYWNvcyh4KSB7XHJcbiAgICByZXR1cm4gbmV3IHRoaXMoeCkuYWNvcygpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGludmVyc2Ugb2YgdGhlIGh5cGVyYm9saWMgY29zaW5lIG9mIGB4YCwgcm91bmRlZCB0b1xyXG4gICAqIGBwcmVjaXNpb25gIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAgICpcclxuICAgKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IEEgdmFsdWUgaW4gcmFkaWFucy5cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGFjb3NoKHgpIHtcclxuICAgIHJldHVybiBuZXcgdGhpcyh4KS5hY29zaCgpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHN1bSBvZiBgeGAgYW5kIGB5YCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYCBzaWduaWZpY2FudFxyXG4gICAqIGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAgICpcclxuICAgKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAgICogeSB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gICAqXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gYWRkKHgsIHkpIHtcclxuICAgIHJldHVybiBuZXcgdGhpcyh4KS5wbHVzKHkpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGFyY3NpbmUgaW4gcmFkaWFucyBvZiBgeGAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmBcclxuICAgKiBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gICAqXHJcbiAgICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gICAqXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gYXNpbih4KSB7XHJcbiAgICByZXR1cm4gbmV3IHRoaXMoeCkuYXNpbigpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGludmVyc2Ugb2YgdGhlIGh5cGVyYm9saWMgc2luZSBvZiBgeGAsIHJvdW5kZWQgdG9cclxuICAgKiBgcHJlY2lzaW9uYCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gICAqXHJcbiAgICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfSBBIHZhbHVlIGluIHJhZGlhbnMuXHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBhc2luaCh4KSB7XHJcbiAgICByZXR1cm4gbmV3IHRoaXMoeCkuYXNpbmgoKTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBhcmN0YW5nZW50IGluIHJhZGlhbnMgb2YgYHhgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gXHJcbiAgICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGF0YW4oeCkge1xyXG4gICAgcmV0dXJuIG5ldyB0aGlzKHgpLmF0YW4oKTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBpbnZlcnNlIG9mIHRoZSBoeXBlcmJvbGljIHRhbmdlbnQgb2YgYHhgLCByb3VuZGVkIHRvXHJcbiAgICogYHByZWNpc2lvbmAgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH0gQSB2YWx1ZSBpbiByYWRpYW5zLlxyXG4gICAqXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gYXRhbmgoeCkge1xyXG4gICAgcmV0dXJuIG5ldyB0aGlzKHgpLmF0YW5oKCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgYXJjdGFuZ2VudCBpbiByYWRpYW5zIG9mIGB5L3hgIGluIHRoZSByYW5nZSAtcGkgdG8gcGlcclxuICAgKiAoaW5jbHVzaXZlKSwgcm91bmRlZCB0byBgcHJlY2lzaW9uYCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gICAqXHJcbiAgICogRG9tYWluOiBbLUluZmluaXR5LCBJbmZpbml0eV1cclxuICAgKiBSYW5nZTogWy1waSwgcGldXHJcbiAgICpcclxuICAgKiB5IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IFRoZSB5LWNvb3JkaW5hdGUuXHJcbiAgICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfSBUaGUgeC1jb29yZGluYXRlLlxyXG4gICAqXHJcbiAgICogYXRhbjIowrEwLCAtMCkgICAgICAgICAgICAgICA9IMKxcGlcclxuICAgKiBhdGFuMijCsTAsICswKSAgICAgICAgICAgICAgID0gwrEwXHJcbiAgICogYXRhbjIowrEwLCAteCkgICAgICAgICAgICAgICA9IMKxcGkgZm9yIHggPiAwXHJcbiAgICogYXRhbjIowrEwLCB4KSAgICAgICAgICAgICAgICA9IMKxMCBmb3IgeCA+IDBcclxuICAgKiBhdGFuMigteSwgwrEwKSAgICAgICAgICAgICAgID0gLXBpLzIgZm9yIHkgPiAwXHJcbiAgICogYXRhbjIoeSwgwrEwKSAgICAgICAgICAgICAgICA9IHBpLzIgZm9yIHkgPiAwXHJcbiAgICogYXRhbjIowrF5LCAtSW5maW5pdHkpICAgICAgICA9IMKxcGkgZm9yIGZpbml0ZSB5ID4gMFxyXG4gICAqIGF0YW4yKMKxeSwgK0luZmluaXR5KSAgICAgICAgPSDCsTAgZm9yIGZpbml0ZSB5ID4gMFxyXG4gICAqIGF0YW4yKMKxSW5maW5pdHksIHgpICAgICAgICAgPSDCsXBpLzIgZm9yIGZpbml0ZSB4XHJcbiAgICogYXRhbjIowrFJbmZpbml0eSwgLUluZmluaXR5KSA9IMKxMypwaS80XHJcbiAgICogYXRhbjIowrFJbmZpbml0eSwgK0luZmluaXR5KSA9IMKxcGkvNFxyXG4gICAqIGF0YW4yKE5hTiwgeCkgPSBOYU5cclxuICAgKiBhdGFuMih5LCBOYU4pID0gTmFOXHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBhdGFuMih5LCB4KSB7XHJcbiAgICB5ID0gbmV3IHRoaXMoeSk7XHJcbiAgICB4ID0gbmV3IHRoaXMoeCk7XHJcbiAgICB2YXIgcixcclxuICAgICAgcHIgPSB0aGlzLnByZWNpc2lvbixcclxuICAgICAgcm0gPSB0aGlzLnJvdW5kaW5nLFxyXG4gICAgICB3cHIgPSBwciArIDQ7XHJcblxyXG4gICAgLy8gRWl0aGVyIE5hTlxyXG4gICAgaWYgKCF5LnMgfHwgIXgucykge1xyXG4gICAgICByID0gbmV3IHRoaXMoTmFOKTtcclxuXHJcbiAgICAvLyBCb3RoIMKxSW5maW5pdHlcclxuICAgIH0gZWxzZSBpZiAoIXkuZCAmJiAheC5kKSB7XHJcbiAgICAgIHIgPSBnZXRQaSh0aGlzLCB3cHIsIDEpLnRpbWVzKHgucyA+IDAgPyAwLjI1IDogMC43NSk7XHJcbiAgICAgIHIucyA9IHkucztcclxuXHJcbiAgICAvLyB4IGlzIMKxSW5maW5pdHkgb3IgeSBpcyDCsTBcclxuICAgIH0gZWxzZSBpZiAoIXguZCB8fCB5LmlzWmVybygpKSB7XHJcbiAgICAgIHIgPSB4LnMgPCAwID8gZ2V0UGkodGhpcywgcHIsIHJtKSA6IG5ldyB0aGlzKDApO1xyXG4gICAgICByLnMgPSB5LnM7XHJcblxyXG4gICAgLy8geSBpcyDCsUluZmluaXR5IG9yIHggaXMgwrEwXHJcbiAgICB9IGVsc2UgaWYgKCF5LmQgfHwgeC5pc1plcm8oKSkge1xyXG4gICAgICByID0gZ2V0UGkodGhpcywgd3ByLCAxKS50aW1lcygwLjUpO1xyXG4gICAgICByLnMgPSB5LnM7XHJcblxyXG4gICAgLy8gQm90aCBub24temVybyBhbmQgZmluaXRlXHJcbiAgICB9IGVsc2UgaWYgKHgucyA8IDApIHtcclxuICAgICAgdGhpcy5wcmVjaXNpb24gPSB3cHI7XHJcbiAgICAgIHRoaXMucm91bmRpbmcgPSAxO1xyXG4gICAgICByID0gdGhpcy5hdGFuKGRpdmlkZSh5LCB4LCB3cHIsIDEpKTtcclxuICAgICAgeCA9IGdldFBpKHRoaXMsIHdwciwgMSk7XHJcbiAgICAgIHRoaXMucHJlY2lzaW9uID0gcHI7XHJcbiAgICAgIHRoaXMucm91bmRpbmcgPSBybTtcclxuICAgICAgciA9IHkucyA8IDAgPyByLm1pbnVzKHgpIDogci5wbHVzKHgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgciA9IHRoaXMuYXRhbihkaXZpZGUoeSwgeCwgd3ByLCAxKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHI7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgY3ViZSByb290IG9mIGB4YCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYCBzaWduaWZpY2FudFxyXG4gICAqIGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAgICpcclxuICAgKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBjYnJ0KHgpIHtcclxuICAgIHJldHVybiBuZXcgdGhpcyh4KS5jYnJ0KCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyBgeGAgcm91bmRlZCB0byBhbiBpbnRlZ2VyIHVzaW5nIGBST1VORF9DRUlMYC5cclxuICAgKlxyXG4gICAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGNlaWwoeCkge1xyXG4gICAgcmV0dXJuIGZpbmFsaXNlKHggPSBuZXcgdGhpcyh4KSwgeC5lICsgMSwgMik7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBDb25maWd1cmUgZ2xvYmFsIHNldHRpbmdzIGZvciBhIERlY2ltYWwgY29uc3RydWN0b3IuXHJcbiAgICpcclxuICAgKiBgb2JqYCBpcyBhbiBvYmplY3Qgd2l0aCBvbmUgb3IgbW9yZSBvZiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMsXHJcbiAgICpcclxuICAgKiAgIHByZWNpc2lvbiAge251bWJlcn1cclxuICAgKiAgIHJvdW5kaW5nICAge251bWJlcn1cclxuICAgKiAgIHRvRXhwTmVnICAge251bWJlcn1cclxuICAgKiAgIHRvRXhwUG9zICAge251bWJlcn1cclxuICAgKiAgIG1heEUgICAgICAge251bWJlcn1cclxuICAgKiAgIG1pbkUgICAgICAge251bWJlcn1cclxuICAgKiAgIG1vZHVsbyAgICAge251bWJlcn1cclxuICAgKiAgIGNyeXB0byAgICAge2Jvb2xlYW58bnVtYmVyfHVuZGVmaW5lZH1cclxuICAgKlxyXG4gICAqIEUuZy4gRGVjaW1hbC5jb25maWcoeyBwcmVjaXNpb246IDIwLCByb3VuZGluZzogNCB9KVxyXG4gICAqXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gY29uZmlnKG9iaikge1xyXG4gICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHRocm93IEVycm9yKGRlY2ltYWxFcnJvciArICdPYmplY3QgZXhwZWN0ZWQnKTtcclxuICAgIHZhciBpLCBwLCB2LFxyXG4gICAgICBwcyA9IFtcclxuICAgICAgICAncHJlY2lzaW9uJywgMSwgTUFYX0RJR0lUUyxcclxuICAgICAgICAncm91bmRpbmcnLCAwLCA4LFxyXG4gICAgICAgICd0b0V4cE5lZycsIC1FWFBfTElNSVQsIDAsXHJcbiAgICAgICAgJ3RvRXhwUG9zJywgMCwgRVhQX0xJTUlULFxyXG4gICAgICAgICdtYXhFJywgMCwgRVhQX0xJTUlULFxyXG4gICAgICAgICdtaW5FJywgLUVYUF9MSU1JVCwgMCxcclxuICAgICAgICAnbW9kdWxvJywgMCwgOVxyXG4gICAgICBdO1xyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBwcy5sZW5ndGg7IGkgKz0gMykge1xyXG4gICAgICBpZiAoKHYgPSBvYmpbcCA9IHBzW2ldXSkgIT09IHZvaWQgMCkge1xyXG4gICAgICAgIGlmIChtYXRoZmxvb3IodikgPT09IHYgJiYgdiA+PSBwc1tpICsgMV0gJiYgdiA8PSBwc1tpICsgMl0pIHRoaXNbcF0gPSB2O1xyXG4gICAgICAgIGVsc2UgdGhyb3cgRXJyb3IoaW52YWxpZEFyZ3VtZW50ICsgcCArICc6ICcgKyB2KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdjcnlwdG8nKSkge1xyXG4gICAgICBpZiAoKHYgPSBvYmpbcF0pID09PSB2b2lkIDApIHtcclxuICAgICAgICB0aGlzW3BdID0gdjtcclxuICAgICAgfSBlbHNlIGlmICh2ID09PSB0cnVlIHx8IHYgPT09IGZhbHNlIHx8IHYgPT09IDAgfHwgdiA9PT0gMSkge1xyXG4gICAgICAgIHRoaXNbcF0gPSAhISh2ICYmIGNyeXB0b09iamVjdCAmJlxyXG4gICAgICAgICAgICAoY3J5cHRvT2JqZWN0LmdldFJhbmRvbVZhbHVlcyB8fCBjcnlwdG9PYmplY3QucmFuZG9tQnl0ZXMpKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBFcnJvcihpbnZhbGlkQXJndW1lbnQgKyBwICsgJzogJyArIHYpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgY29zaW5lIG9mIGB4YCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYCBzaWduaWZpY2FudFxyXG4gICAqIGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAgICpcclxuICAgKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IEEgdmFsdWUgaW4gcmFkaWFucy5cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGNvcyh4KSB7XHJcbiAgICByZXR1cm4gbmV3IHRoaXMoeCkuY29zKCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgaHlwZXJib2xpYyBjb3NpbmUgb2YgYHhgLCByb3VuZGVkIHRvIHByZWNpc2lvblxyXG4gICAqIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAgICpcclxuICAgKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IEEgdmFsdWUgaW4gcmFkaWFucy5cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGNvc2goeCkge1xyXG4gICAgcmV0dXJuIG5ldyB0aGlzKHgpLmNvc2goKTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgRGVjaW1hbCBjb25zdHJ1Y3RvciB3aXRoIHRoZSBzYW1lIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcyBhcyB0aGlzIERlY2ltYWxcclxuICAgKiBjb25zdHJ1Y3Rvci5cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGNsb25lKG9iaikge1xyXG4gICAgdmFyIGksIHAsIHBzO1xyXG5cclxuICAgIC8qXHJcbiAgICAgKiBUaGUgRGVjaW1hbCBjb25zdHJ1Y3RvciBhbmQgZXhwb3J0ZWQgZnVuY3Rpb24uXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCBpbnN0YW5jZS5cclxuICAgICAqXHJcbiAgICAgKiB2IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IEEgbnVtZXJpYyB2YWx1ZS5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIERlY2ltYWwodikge1xyXG4gICAgICB2YXIgZSwgaSwgdCxcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIC8vIERlY2ltYWwgY2FsbGVkIHdpdGhvdXQgbmV3LlxyXG4gICAgICBpZiAoISh4IGluc3RhbmNlb2YgRGVjaW1hbCkpIHJldHVybiBuZXcgRGVjaW1hbCh2KTtcclxuXHJcbiAgICAgIC8vIFJldGFpbiBhIHJlZmVyZW5jZSB0byB0aGlzIERlY2ltYWwgY29uc3RydWN0b3IsIGFuZCBzaGFkb3cgRGVjaW1hbC5wcm90b3R5cGUuY29uc3RydWN0b3JcclxuICAgICAgLy8gd2hpY2ggcG9pbnRzIHRvIE9iamVjdC5cclxuICAgICAgeC5jb25zdHJ1Y3RvciA9IERlY2ltYWw7XHJcblxyXG4gICAgICAvLyBEdXBsaWNhdGUuXHJcbiAgICAgIGlmICh2IGluc3RhbmNlb2YgRGVjaW1hbCkge1xyXG4gICAgICAgIHgucyA9IHYucztcclxuICAgICAgICB4LmUgPSB2LmU7XHJcbiAgICAgICAgeC5kID0gKHYgPSB2LmQpID8gdi5zbGljZSgpIDogdjtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHQgPSB0eXBlb2YgdjtcclxuXHJcbiAgICAgIGlmICh0ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIGlmICh2ID09PSAwKSB7XHJcbiAgICAgICAgICB4LnMgPSAxIC8gdiA8IDAgPyAtMSA6IDE7XHJcbiAgICAgICAgICB4LmUgPSAwO1xyXG4gICAgICAgICAgeC5kID0gWzBdO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHYgPCAwKSB7XHJcbiAgICAgICAgICB2ID0gLXY7XHJcbiAgICAgICAgICB4LnMgPSAtMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeC5zID0gMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZhc3QgcGF0aCBmb3Igc21hbGwgaW50ZWdlcnMuXHJcbiAgICAgICAgaWYgKHYgPT09IH5+diAmJiB2IDwgMWU3KSB7XHJcbiAgICAgICAgICBmb3IgKGUgPSAwLCBpID0gdjsgaSA+PSAxMDsgaSAvPSAxMCkgZSsrO1xyXG4gICAgICAgICAgeC5lID0gZTtcclxuICAgICAgICAgIHguZCA9IFt2XTtcclxuICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgLy8gSW5maW5pdHksIE5hTi5cclxuICAgICAgICB9IGVsc2UgaWYgKHYgKiAwICE9PSAwKSB7XHJcbiAgICAgICAgICBpZiAoIXYpIHgucyA9IE5hTjtcclxuICAgICAgICAgIHguZSA9IE5hTjtcclxuICAgICAgICAgIHguZCA9IG51bGw7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcGFyc2VEZWNpbWFsKHgsIHYudG9TdHJpbmcoKSk7XHJcblxyXG4gICAgICB9IGVsc2UgaWYgKHQgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgdGhyb3cgRXJyb3IoaW52YWxpZEFyZ3VtZW50ICsgdik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE1pbnVzIHNpZ24/XHJcbiAgICAgIGlmICh2LmNoYXJDb2RlQXQoMCkgPT09IDQ1KSB7XHJcbiAgICAgICAgdiA9IHYuc2xpY2UoMSk7XHJcbiAgICAgICAgeC5zID0gLTE7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgeC5zID0gMTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGlzRGVjaW1hbC50ZXN0KHYpID8gcGFyc2VEZWNpbWFsKHgsIHYpIDogcGFyc2VPdGhlcih4LCB2KTtcclxuICAgIH1cclxuXHJcbiAgICBEZWNpbWFsLnByb3RvdHlwZSA9IFA7XHJcblxyXG4gICAgRGVjaW1hbC5ST1VORF9VUCA9IDA7XHJcbiAgICBEZWNpbWFsLlJPVU5EX0RPV04gPSAxO1xyXG4gICAgRGVjaW1hbC5ST1VORF9DRUlMID0gMjtcclxuICAgIERlY2ltYWwuUk9VTkRfRkxPT1IgPSAzO1xyXG4gICAgRGVjaW1hbC5ST1VORF9IQUxGX1VQID0gNDtcclxuICAgIERlY2ltYWwuUk9VTkRfSEFMRl9ET1dOID0gNTtcclxuICAgIERlY2ltYWwuUk9VTkRfSEFMRl9FVkVOID0gNjtcclxuICAgIERlY2ltYWwuUk9VTkRfSEFMRl9DRUlMID0gNztcclxuICAgIERlY2ltYWwuUk9VTkRfSEFMRl9GTE9PUiA9IDg7XHJcbiAgICBEZWNpbWFsLkVVQ0xJRCA9IDk7XHJcblxyXG4gICAgRGVjaW1hbC5jb25maWcgPSBjb25maWc7XHJcbiAgICBEZWNpbWFsLmNsb25lID0gY2xvbmU7XHJcblxyXG4gICAgRGVjaW1hbC5hYnMgPSBhYnM7XHJcbiAgICBEZWNpbWFsLmFjb3MgPSBhY29zO1xyXG4gICAgRGVjaW1hbC5hY29zaCA9IGFjb3NoOyAgICAgICAgLy8gRVM2XHJcbiAgICBEZWNpbWFsLmFkZCA9IGFkZDtcclxuICAgIERlY2ltYWwuYXNpbiA9IGFzaW47XHJcbiAgICBEZWNpbWFsLmFzaW5oID0gYXNpbmg7ICAgICAgICAvLyBFUzZcclxuICAgIERlY2ltYWwuYXRhbiA9IGF0YW47XHJcbiAgICBEZWNpbWFsLmF0YW5oID0gYXRhbmg7ICAgICAgICAvLyBFUzZcclxuICAgIERlY2ltYWwuYXRhbjIgPSBhdGFuMjtcclxuICAgIERlY2ltYWwuY2JydCA9IGNicnQ7ICAgICAgICAgIC8vIEVTNlxyXG4gICAgRGVjaW1hbC5jZWlsID0gY2VpbDtcclxuICAgIERlY2ltYWwuY29zID0gY29zO1xyXG4gICAgRGVjaW1hbC5jb3NoID0gY29zaDsgICAgICAgICAgLy8gRVM2XHJcbiAgICBEZWNpbWFsLmRpdiA9IGRpdjtcclxuICAgIERlY2ltYWwuZXhwID0gZXhwO1xyXG4gICAgRGVjaW1hbC5mbG9vciA9IGZsb29yO1xyXG4gICAgRGVjaW1hbC5mcm9tSlNPTiA9IGZyb21KU09OO1xyXG4gICAgRGVjaW1hbC5oeXBvdCA9IGh5cG90OyAgICAgICAgLy8gRVM2XHJcbiAgICBEZWNpbWFsLmxuID0gbG47XHJcbiAgICBEZWNpbWFsLmxvZyA9IGxvZztcclxuICAgIERlY2ltYWwubG9nMTAgPSBsb2cxMDsgICAgICAgIC8vIEVTNlxyXG4gICAgRGVjaW1hbC5sb2cyID0gbG9nMjsgICAgICAgICAgLy8gRVM2XHJcbiAgICBEZWNpbWFsLm1heCA9IG1heDtcclxuICAgIERlY2ltYWwubWluID0gbWluO1xyXG4gICAgRGVjaW1hbC5tb2QgPSBtb2Q7XHJcbiAgICBEZWNpbWFsLm11bCA9IG11bDtcclxuICAgIERlY2ltYWwucG93ID0gcG93O1xyXG4gICAgRGVjaW1hbC5yYW5kb20gPSByYW5kb207XHJcbiAgICBEZWNpbWFsLnJvdW5kID0gcm91bmQ7XHJcbiAgICBEZWNpbWFsLnNpZ24gPSBzaWduOyAgICAgICAgICAvLyBFUzZcclxuICAgIERlY2ltYWwuc2luID0gc2luO1xyXG4gICAgRGVjaW1hbC5zaW5oID0gc2luaDsgICAgICAgICAgLy8gRVM2XHJcbiAgICBEZWNpbWFsLnNxcnQgPSBzcXJ0O1xyXG4gICAgRGVjaW1hbC5zdWIgPSBzdWI7XHJcbiAgICBEZWNpbWFsLnRhbiA9IHRhbjtcclxuICAgIERlY2ltYWwudGFuaCA9IHRhbmg7ICAgICAgICAgIC8vIEVTNlxyXG4gICAgRGVjaW1hbC50cnVuYyA9IHRydW5jOyAgICAgICAgLy8gRVM2XHJcblxyXG4gICAgaWYgKG9iaiA9PT0gdm9pZCAwKSBvYmogPSB7fTtcclxuICAgIGlmIChvYmopIHtcclxuICAgICAgcHMgPSBbJ3ByZWNpc2lvbicsICdyb3VuZGluZycsICd0b0V4cE5lZycsICd0b0V4cFBvcycsICdtYXhFJywgJ21pbkUnLCAnbW9kdWxvJywgJ2NyeXB0byddO1xyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcHMubGVuZ3RoOykgaWYgKCFvYmouaGFzT3duUHJvcGVydHkocCA9IHBzW2krK10pKSBvYmpbcF0gPSB0aGlzW3BdO1xyXG4gICAgfVxyXG5cclxuICAgIERlY2ltYWwuY29uZmlnKG9iaik7XHJcblxyXG4gICAgcmV0dXJuIERlY2ltYWw7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyBgeGAgZGl2aWRlZCBieSBgeWAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAgc2lnbmlmaWNhbnRcclxuICAgKiBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gICAqXHJcbiAgICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gICAqIHkge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGRpdih4LCB5KSB7XHJcbiAgICByZXR1cm4gbmV3IHRoaXMoeCkuZGl2KHkpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIG5hdHVyYWwgZXhwb25lbnRpYWwgb2YgYHhgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gXHJcbiAgICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH0gVGhlIHBvd2VyIHRvIHdoaWNoIHRvIHJhaXNlIHRoZSBiYXNlIG9mIHRoZSBuYXR1cmFsIGxvZy5cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGV4cCh4KSB7XHJcbiAgICByZXR1cm4gbmV3IHRoaXMoeCkuZXhwKCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyBgeGAgcm91bmQgdG8gYW4gaW50ZWdlciB1c2luZyBgUk9VTkRfRkxPT1JgLlxyXG4gICAqXHJcbiAgICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gICAqXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gZmxvb3IoeCkge1xyXG4gICAgcmV0dXJuIGZpbmFsaXNlKHggPSBuZXcgdGhpcyh4KSwgeC5lICsgMSwgMyk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCBmcm9tIGBzdHJgLCBhIHN0cmluZyB2YWx1ZSBjcmVhdGVkIGJ5IGB0b0pTT05gLlxyXG4gICAqXHJcbiAgICogQmFzZSA4OCBhbHBoYWJldDpcclxuICAgKiAwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWiEjJCUoKSorLC0uLzo7PT9AW11eX2B7fH1+XHJcbiAgICpcclxuICAgKiBJZiBgc3RyYCBpcyBqdXN0IG9uZSBjaGFyYWN0ZXI6XHJcbiAgICogMC04MSAgW1swLCA0MF1bLTAsIC00MF1dXHJcbiAgICogODIgICAgLUluZmluaXR5XHJcbiAgICogODMgICAgK0luZmluaXR5XHJcbiAgICogODQgICAgTmFOXHJcbiAgICpcclxuICAgKiAgIDY0IDMyIDE2ICA4ICA0ICAyICAxXHJcbiAgICogICAgMSAgMCAgMSAgMCAgMSAgMSAgMSA9IDg3XHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBmcm9tSlNPTihzdHIpIHtcclxuICAgIHZhciBlLCBpc05lZywgaywgbjtcclxuXHJcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycgfHwgIXN0cikgdGhyb3cgRXJyb3IoaW52YWxpZEFyZ3VtZW50ICsgc3RyKTtcclxuICAgIGsgPSBzdHIubGVuZ3RoO1xyXG4gICAgbiA9IE5VTUVSQUxTLmluZGV4T2Yoc3RyLmNoYXJBdCgwKSk7XHJcblxyXG4gICAgLy8gIFswLCA4MV0gLT4gW1swLCA0MF1bLTAsIC00MF1dXHJcbiAgICBpZiAoayA9PT0gMSkge1xyXG4gICAgICByZXR1cm4gbmV3IHRoaXMobiA+IDgxID8gWy0xIC8gMCwgMSAvIDAsIDAgLyAwXVtuIC0gODJdIDogbiA+IDQwID8gLShuIC0gNDEpIDogbik7XHJcbiAgICB9IGVsc2UgaWYgKG4gJiA2NCkge1xyXG4gICAgICBpc05lZyA9IG4gJiAxNjtcclxuXHJcbiAgICAgIC8vIGUgPSBpc05lZyA/IFstMywgNF0gOiBbLTcsIDhdXHJcbiAgICAgIGUgPSBpc05lZyA/IChuICYgNykgLSAzIDogKG4gJiAxNSkgLSA3O1xyXG4gICAgICBrID0gMTtcclxuICAgIH0gZWxzZSBpZiAoayA9PT0gMikge1xyXG4gICAgICBuID0gbiAqIDg4ICsgTlVNRVJBTFMuaW5kZXhPZihzdHIuY2hhckF0KDEpKTtcclxuXHJcbiAgICAgIC8vIFswLCA1NjMxXSAtPiBbWzAsIDI4MTVdWy0wLCAtMjgxNV1dIC0+IFtbNDEsIDI4NTZdWy00MSwgLTI4NTZdXVxyXG4gICAgICByZXR1cm4gbmV3IHRoaXMobiA+PSAyODE2ID8gLShuIC0gMjgxNikgLSA0MSA6IG4gKyA0MSk7XHJcbiAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgLy8gMFhYWFhYWFxyXG4gICAgICAvLyAwIHtpcyBuZWdhdGl2ZX0ge2lzIGV4cG9uZW50IG5lZ2F0aXZlfSB7ZXhwb25lbnQgZGlnaXQgY291bnQgWzAsIDE1XX1cclxuICAgICAgaXNOZWcgPSBuICYgMzI7XHJcblxyXG4gICAgICAvLyBIYXMgYW4gZXhwb25lbnQgYmVlbiBzcGVjaWZpZWQ/XHJcbiAgICAgIGlmIChuICYgMzEpIHtcclxuICAgICAgICBlID0gbiAmIDE1OyAgICAvLyBFeHBvbmVudCBjaGFyYWN0ZXIgY291bnQgWzEsIDE1XVxyXG4gICAgICAgIGsgPSBlICsgMTsgICAgIC8vIEluZGV4IG9mIGZpcnN0IGNoYXJhY3RlciBvZiB0aGUgc2lnbmlmaWNhbmQuXHJcblxyXG4gICAgICAgIGlmIChlID09PSAxKSAge1xyXG4gICAgICAgICAgZSA9IE5VTUVSQUxTLmluZGV4T2Yoc3RyLmNoYXJBdCgxKSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChlID09PSAyKSB7XHJcbiAgICAgICAgICBlID0gTlVNRVJBTFMuaW5kZXhPZihzdHIuY2hhckF0KDEpKSAqIDg4ICtcclxuICAgICAgICAgICAgTlVNRVJBTFMuaW5kZXhPZihzdHIuY2hhckF0KDIpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZSA9ICtjb252ZXJ0QmFzZShzdHIuc2xpY2UoMSwgayksIDg4LCAxMCkuam9pbignJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBOZWdhdGl2ZSBleHBvbmVudD9cclxuICAgICAgICBpZiAobiAmIDE2KSBlID0gLWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIEludGVnZXIgd2l0aG91dCB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICAvLyAwWDAwMDAwXHJcbiAgICAgICAgLy8gMCB7aXMgbmVnYXRpdmV9IDAgMCAwIDAgMFxyXG4gICAgICAgIHN0ciA9IGNvbnZlcnRCYXNlKHN0ci5zbGljZSgxKSwgODgsIDEwKS5qb2luKCcnKTtcclxuICAgICAgICByZXR1cm4gbmV3IHRoaXMoaXNOZWcgPyAnLScgKyBzdHIgOiBzdHIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc3RyID0gY29udmVydEJhc2Uoc3RyLnNsaWNlKGspLCA4OCwgMTApLmpvaW4oJycpO1xyXG4gICAgZSA9IGUgLSBzdHIubGVuZ3RoICsgMTtcclxuICAgIHN0ciA9IHN0ciArICdlJyArIGU7XHJcblxyXG4gICAgcmV0dXJuIG5ldyB0aGlzKGlzTmVnID8gJy0nICsgc3RyIDogc3RyKTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBzcXVhcmUgcm9vdCBvZiB0aGUgc3VtIG9mIHRoZSBzcXVhcmVzIG9mIHRoZSBhcmd1bWVudHMsXHJcbiAgICogcm91bmRlZCB0byBgcHJlY2lzaW9uYCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gICAqXHJcbiAgICogaHlwb3QoYSwgYiwgLi4uKSA9IHNxcnQoYV4yICsgYl4yICsgLi4uKVxyXG4gICAqXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gaHlwb3QoKSB7XHJcbiAgICB2YXIgaSwgbixcclxuICAgICAgdCA9IG5ldyB0aGlzKDApO1xyXG5cclxuICAgIGV4dGVybmFsID0gZmFsc2U7XHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7KSB7XHJcbiAgICAgIG4gPSBuZXcgdGhpcyhhcmd1bWVudHNbaSsrXSk7XHJcbiAgICAgIGlmICghbi5kKSB7XHJcbiAgICAgICAgaWYgKG4ucykge1xyXG4gICAgICAgICAgZXh0ZXJuYWwgPSB0cnVlO1xyXG4gICAgICAgICAgcmV0dXJuIG5ldyB0aGlzKDEgLyAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdCA9IG47XHJcbiAgICAgIH0gZWxzZSBpZiAodC5kKSB7XHJcbiAgICAgICAgdCA9IHQucGx1cyhuLnRpbWVzKG4pKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGV4dGVybmFsID0gdHJ1ZTtcclxuXHJcbiAgICByZXR1cm4gdC5zcXJ0KCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgbmF0dXJhbCBsb2dhcml0aG0gb2YgYHhgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gXHJcbiAgICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGxuKHgpIHtcclxuICAgIHJldHVybiBuZXcgdGhpcyh4KS5sbigpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGxvZyBvZiBgeGAgdG8gdGhlIGJhc2UgYHlgLCBvciB0byBiYXNlIDEwIGlmIG5vIGJhc2VcclxuICAgKiBpcyBzcGVjaWZpZWQsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqIGxvZ1t5XSh4KVxyXG4gICAqXHJcbiAgICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfSBUaGUgYXJndW1lbnQgb2YgdGhlIGxvZ2FyaXRobS5cclxuICAgKiB5IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IFRoZSBiYXNlIG9mIHRoZSBsb2dhcml0aG0uXHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBsb2coeCwgeSkge1xyXG4gICAgcmV0dXJuIG5ldyB0aGlzKHgpLmxvZyh5KTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBiYXNlIDIgbG9nYXJpdGhtIG9mIGB4YCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYFxyXG4gICAqIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAgICpcclxuICAgKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBsb2cyKHgpIHtcclxuICAgIHJldHVybiBuZXcgdGhpcyh4KS5sb2coMik7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgYmFzZSAxMCBsb2dhcml0aG0gb2YgYHhgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gXHJcbiAgICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGxvZzEwKHgpIHtcclxuICAgIHJldHVybiBuZXcgdGhpcyh4KS5sb2coMTApO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIG1heGltdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICAgKlxyXG4gICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gICAqXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gbWF4KCkge1xyXG4gICAgcmV0dXJuIG1heE9yTWluKHRoaXMsIGFyZ3VtZW50cywgJ2x0Jyk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgbWluaW11bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAqXHJcbiAgICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBtaW4oKSB7XHJcbiAgICByZXR1cm4gbWF4T3JNaW4odGhpcywgYXJndW1lbnRzLCAnZ3QnKTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIGB4YCBtb2R1bG8gYHlgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gIHNpZ25pZmljYW50IGRpZ2l0c1xyXG4gICAqIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICAgKiB5IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBtb2QoeCwgeSkge1xyXG4gICAgcmV0dXJuIG5ldyB0aGlzKHgpLm1vZCh5KTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIGB4YCBtdWx0aXBsaWVkIGJ5IGB5YCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYCBzaWduaWZpY2FudFxyXG4gICAqIGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAgICpcclxuICAgKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAgICogeSB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gICAqXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gbXVsKHgsIHkpIHtcclxuICAgIHJldHVybiBuZXcgdGhpcyh4KS5tdWwoeSk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyBgeGAgcmFpc2VkIHRvIHRoZSBwb3dlciBgeWAsIHJvdW5kZWQgdG8gcHJlY2lzaW9uXHJcbiAgICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH0gVGhlIGJhc2UuXHJcbiAgICogeSB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfSBUaGUgZXhwb25lbnQuXHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBwb3coeCwgeSkge1xyXG4gICAgcmV0dXJuIG5ldyB0aGlzKHgpLnBvdyh5KTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybnMgYSBuZXcgRGVjaW1hbCB3aXRoIGEgcmFuZG9tIHZhbHVlIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiAwIGFuZCBsZXNzIHRoYW4gMSwgYW5kIHdpdGhcclxuICAgKiBgc2RgLCBvciBgRGVjaW1hbC5wcmVjaXNpb25gIGlmIGBzZGAgaXMgb21pdHRlZCwgc2lnbmlmaWNhbnQgZGlnaXRzIChvciBsZXNzIGlmIHRyYWlsaW5nIHplcm9zXHJcbiAgICogYXJlIHByb2R1Y2VkKS5cclxuICAgKlxyXG4gICAqIFtzZF0ge251bWJlcn0gU2lnbmlmaWNhbnQgZGlnaXRzLiBJbnRlZ2VyLCAwIHRvIE1BWF9ESUdJVFMgaW5jbHVzaXZlLlxyXG4gICAqXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gcmFuZG9tKHNkKSB7XHJcbiAgICB2YXIgZCwgZSwgaywgbixcclxuICAgICAgaSA9IDAsXHJcbiAgICAgIHIgPSBuZXcgdGhpcygxKSxcclxuICAgICAgcmQgPSBbXTtcclxuXHJcbiAgICBpZiAoc2QgPT09IHZvaWQgMCkgc2QgPSB0aGlzLnByZWNpc2lvbjtcclxuICAgIGVsc2UgY2hlY2tJbnQzMihzZCwgMSwgTUFYX0RJR0lUUyk7XHJcblxyXG4gICAgayA9IE1hdGguY2VpbChzZCAvIExPR19CQVNFKTtcclxuXHJcbiAgICBpZiAodGhpcy5jcnlwdG8gPT09IGZhbHNlKSB7XHJcbiAgICAgIGZvciAoOyBpIDwgazspIHJkW2krK10gPSBNYXRoLnJhbmRvbSgpICogMWU3IHwgMDtcclxuXHJcbiAgICAvLyBCcm93c2VycyBzdXBwb3J0aW5nIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuXHJcbiAgICB9IGVsc2UgaWYgKGNyeXB0b09iamVjdCAmJiBjcnlwdG9PYmplY3QuZ2V0UmFuZG9tVmFsdWVzKSB7XHJcbiAgICAgIGQgPSBjcnlwdG9PYmplY3QuZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheShrKSk7XHJcblxyXG4gICAgICBmb3IgKDsgaSA8IGs7KSB7XHJcbiAgICAgICAgbiA9IGRbaV07XHJcblxyXG4gICAgICAgIC8vIDAgPD0gbiA8IDQyOTQ5NjcyOTZcclxuICAgICAgICAvLyBQcm9iYWJpbGl0eSBuID49IDQuMjllOSwgaXMgNDk2NzI5NiAvIDQyOTQ5NjcyOTYgPSAwLjAwMTE2ICgxIGluIDg2NSkuXHJcbiAgICAgICAgaWYgKG4gPj0gNC4yOWU5KSB7XHJcbiAgICAgICAgICBkW2ldID0gY3J5cHRvT2JqZWN0LmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoMSkpWzBdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gMCA8PSBuIDw9IDQyODk5OTk5OTlcclxuICAgICAgICAgIC8vIDAgPD0gKG4gJSAxZTcpIDw9IDk5OTk5OTlcclxuICAgICAgICAgIHJkW2krK10gPSBuICUgMWU3O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgIC8vIE5vZGUuanMgc3VwcG9ydGluZyBjcnlwdG8ucmFuZG9tQnl0ZXMuXHJcbiAgICB9IGVsc2UgaWYgKGNyeXB0b09iamVjdCAmJiBjcnlwdG9PYmplY3QucmFuZG9tQnl0ZXMpIHtcclxuXHJcbiAgICAgIC8vIGJ1ZmZlclxyXG4gICAgICBkID0gY3J5cHRvT2JqZWN0LnJhbmRvbUJ5dGVzKGsgKj0gNCk7XHJcblxyXG4gICAgICBmb3IgKDsgaSA8IGs7KSB7XHJcblxyXG4gICAgICAgIC8vIDAgPD0gbiA8IDIxNDc0ODM2NDhcclxuICAgICAgICBuID0gZFtpXSArIChkW2kgKyAxXSA8PCA4KSArIChkW2kgKyAyXSA8PCAxNikgKyAoKGRbaSArIDNdICYgMHg3ZikgPDwgMjQpO1xyXG5cclxuICAgICAgICAvLyBQcm9iYWJpbGl0eSBuID49IDIuMTRlOSwgaXMgNzQ4MzY0OCAvIDIxNDc0ODM2NDggPSAwLjAwMzUgKDEgaW4gMjg2KS5cclxuICAgICAgICBpZiAobiA+PSAyLjE0ZTkpIHtcclxuICAgICAgICAgIGNyeXB0b09iamVjdC5yYW5kb21CeXRlcyg0KS5jb3B5KGQsIGkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gMCA8PSBuIDw9IDIxMzk5OTk5OTlcclxuICAgICAgICAgIC8vIDAgPD0gKG4gJSAxZTcpIDw9IDk5OTk5OTlcclxuICAgICAgICAgIHJkLnB1c2gobiAlIDFlNyk7XHJcbiAgICAgICAgICBpICs9IDQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpID0gayAvIDQ7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuY3J5cHRvKSB7XHJcbiAgICAgIHRocm93IEVycm9yKGRlY2ltYWxFcnJvciArICdjcnlwdG8gdW5hdmFpbGFibGUnKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGZvciAoOyBpIDwgazspIHJkW2krK10gPSBNYXRoLnJhbmRvbSgpICogMWU3IHwgMDtcclxuICAgIH1cclxuXHJcbiAgICBrID0gcmRbLS1pXTtcclxuICAgIHNkICU9IExPR19CQVNFO1xyXG5cclxuICAgIC8vIENvbnZlcnQgdHJhaWxpbmcgZGlnaXRzIHRvIHplcm9zIGFjY29yZGluZyB0byBzZC5cclxuICAgIGlmIChrICYmIHNkKSB7XHJcbiAgICAgIG4gPSBtYXRocG93KDEwLCBMT0dfQkFTRSAtIHNkKTtcclxuICAgICAgcmRbaV0gPSAoayAvIG4gfCAwKSAqIG47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHdvcmRzIHdoaWNoIGFyZSB6ZXJvLlxyXG4gICAgZm9yICg7IHJkW2ldID09PSAwOyBpLS0pIHJkLnBvcCgpO1xyXG5cclxuICAgIC8vIFplcm8/XHJcbiAgICBpZiAoaSA8IDApIHtcclxuICAgICAgZSA9IDA7XHJcbiAgICAgIHJkID0gWzBdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZSA9IC0xO1xyXG5cclxuICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgd29yZHMgd2hpY2ggYXJlIHplcm8gYW5kIGFkanVzdCBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICAgICAgZm9yICg7IHJkWzBdID09PSAwOyBlIC09IExPR19CQVNFKSByZC5zaGlmdCgpO1xyXG5cclxuICAgICAgLy8gQ291bnQgdGhlIGRpZ2l0cyBvZiB0aGUgZmlyc3Qgd29yZCBvZiByZCB0byBkZXRlcm1pbmUgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgZm9yIChrID0gMSwgbiA9IHJkWzBdOyBuID49IDEwOyBuIC89IDEwKSBrKys7XHJcblxyXG4gICAgICAvLyBBZGp1c3QgdGhlIGV4cG9uZW50IGZvciBsZWFkaW5nIHplcm9zIG9mIHRoZSBmaXJzdCB3b3JkIG9mIHJkLlxyXG4gICAgICBpZiAoayA8IExPR19CQVNFKSBlIC09IExPR19CQVNFIC0gaztcclxuICAgIH1cclxuXHJcbiAgICByLmUgPSBlO1xyXG4gICAgci5kID0gcmQ7XHJcblxyXG4gICAgcmV0dXJuIHI7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyBgeGAgcm91bmRlZCB0byBhbiBpbnRlZ2VyIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqIFRvIGVtdWxhdGUgYE1hdGgucm91bmRgLCBzZXQgcm91bmRpbmcgdG8gNyAoUk9VTkRfSEFMRl9DRUlMKS5cclxuICAgKlxyXG4gICAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHJvdW5kKHgpIHtcclxuICAgIHJldHVybiBmaW5hbGlzZSh4ID0gbmV3IHRoaXMoeCksIHguZSArIDEsIHRoaXMucm91bmRpbmcpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuXHJcbiAgICogICAxICAgIGlmIHggPiAwLFxyXG4gICAqICAtMSAgICBpZiB4IDwgMCxcclxuICAgKiAgIDAgICAgaWYgeCBpcyAwLFxyXG4gICAqICAtMCAgICBpZiB4IGlzIC0wLFxyXG4gICAqICAgTmFOICBvdGhlcndpc2VcclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHNpZ24oeCkge1xyXG4gICAgeCA9IG5ldyB0aGlzKHgpO1xyXG4gICAgcmV0dXJuIHguZCA/ICh4LmRbMF0gPyB4LnMgOiAwICogeC5zKSA6IHgucyB8fCBOYU47XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgc2luZSBvZiBgeGAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAgc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAgICogdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gICAqXHJcbiAgICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfSBBIHZhbHVlIGluIHJhZGlhbnMuXHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBzaW4oeCkge1xyXG4gICAgcmV0dXJuIG5ldyB0aGlzKHgpLnNpbigpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGh5cGVyYm9saWMgc2luZSBvZiBgeGAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmBcclxuICAgKiBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gICAqXHJcbiAgICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfSBBIHZhbHVlIGluIHJhZGlhbnMuXHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBzaW5oKHgpIHtcclxuICAgIHJldHVybiBuZXcgdGhpcyh4KS5zaW5oKCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgc3F1YXJlIHJvb3Qgb2YgYHhgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gIHNpZ25pZmljYW50XHJcbiAgICogZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHNxcnQoeCkge1xyXG4gICAgcmV0dXJuIG5ldyB0aGlzKHgpLnNxcnQoKTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIGB4YCBtaW51cyBgeWAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAgc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAgICogdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gICAqXHJcbiAgICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gICAqIHkge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHN1Yih4LCB5KSB7XHJcbiAgICByZXR1cm4gbmV3IHRoaXMoeCkuc3ViKHkpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHRhbmdlbnQgb2YgYHhgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gIHNpZ25pZmljYW50XHJcbiAgICogZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH0gQSB2YWx1ZSBpbiByYWRpYW5zLlxyXG4gICAqXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gdGFuKHgpIHtcclxuICAgIHJldHVybiBuZXcgdGhpcyh4KS50YW4oKTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBoeXBlcmJvbGljIHRhbmdlbnQgb2YgYHhgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gXHJcbiAgICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH0gQSB2YWx1ZSBpbiByYWRpYW5zLlxyXG4gICAqXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gdGFuaCh4KSB7XHJcbiAgICByZXR1cm4gbmV3IHRoaXMoeCkudGFuaCgpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgYHhgIHRydW5jYXRlZCB0byBhbiBpbnRlZ2VyLlxyXG4gICAqXHJcbiAgICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gICAqXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gdHJ1bmMoeCkge1xyXG4gICAgcmV0dXJuIGZpbmFsaXNlKHggPSBuZXcgdGhpcyh4KSwgeC5lICsgMSwgMSk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gQ3JlYXRlIGFuZCBjb25maWd1cmUgaW5pdGlhbCBEZWNpbWFsIGNvbnN0cnVjdG9yLlxyXG4gIERlY2ltYWwgPSBjbG9uZShEZWNpbWFsKTtcclxuXHJcbiAgLy8gQ3JlYXRlIHRoZSBpbnRlcm5hbCBjb25zdGFudHMgZnJvbSB0aGVpciBzdHJpbmcgdmFsdWVzLlxyXG4gIExOMTAgPSBuZXcgRGVjaW1hbChMTjEwKTtcclxuICBQSSA9IG5ldyBEZWNpbWFsKFBJKTtcclxuXHJcblxyXG4gIC8vIEV4cG9ydC5cclxuXHJcblxyXG4gIC8vIEFNRC5cclxuICBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcclxuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBEZWNpbWFsO1xyXG4gICAgfSk7XHJcblxyXG4gIC8vIE5vZGUgYW5kIG90aGVyIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMuXHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IERlY2ltYWw7XHJcblxyXG4gICAgaWYgKCFjcnlwdG9PYmplY3QpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjcnlwdG9PYmplY3QgPSByZXF1aXJlKCdjcnknICsgJ3B0bycpO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgLy8gSWdub3JlLlxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gIC8vIEJyb3dzZXIuXHJcbiAgfSBlbHNlIHtcclxuICAgIGlmICghZ2xvYmFsU2NvcGUpIHtcclxuICAgICAgZ2xvYmFsU2NvcGUgPSB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmICYmIHNlbGYuc2VsZiA9PSBzZWxmXHJcbiAgICAgICAgPyBzZWxmIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcclxuICAgIH1cclxuXHJcbiAgICBub0NvbmZsaWN0ID0gZ2xvYmFsU2NvcGUuRGVjaW1hbDtcclxuICAgIERlY2ltYWwubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgZ2xvYmFsU2NvcGUuRGVjaW1hbCA9IG5vQ29uZmxpY3Q7XHJcbiAgICAgIHJldHVybiBEZWNpbWFsO1xyXG4gICAgfTtcclxuXHJcbiAgICBnbG9iYWxTY29wZS5EZWNpbWFsID0gRGVjaW1hbDtcclxuICB9XHJcbn0pKHRoaXMpO1xyXG4iLCIvKipcbiAqIEBsaWNlbnNlIEZyYWN0aW9uLmpzIHYzLjIuNSAwOS8wOS8yMDE1XG4gKiBodHRwOi8vd3d3Lnhhcmcub3JnLzIwMTQvMDMvcHJlY2lzZS1jYWxjdWxhdGlvbnMtaW4tamF2YXNjcmlwdC9cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUsIFJvYmVydCBFaXNlbGUgKHJvYmVydEB4YXJnLm9yZylcbiAqIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBvciBHUEwgVmVyc2lvbiAyIGxpY2Vuc2VzLlxuICoqL1xuXG5cbi8qKlxuICpcbiAqIFRoaXMgY2xhc3Mgb2ZmZXJzIHRoZSBwb3NzZWJpbGl0eSB0byBjYWxjdWxhdGUgZnJhY3Rpb25zLlxuICogWW91IGNhbiBwYXNzIGEgZnJhY3Rpb24gaW4gZGlmZmVyZW50IGZvcm1hdHMuIEVpdGhlciBhcyBhcnJheSwgYXMgZG91YmxlLCBhcyBzdHJpbmcgb3IgYXMgYW4gaW50ZWdlci5cbiAqXG4gKiBBcnJheS9PYmplY3QgZm9ybVxuICogWyAwID0+IDxub21pbmF0b3I+LCAxID0+IDxkZW5vbWluYXRvcj4gXVxuICogWyBuID0+IDxub21pbmF0b3I+LCBkID0+IDxkZW5vbWluYXRvcj4gXVxuICpcbiAqIEludGVnZXIgZm9ybVxuICogLSBTaW5nbGUgaW50ZWdlciB2YWx1ZVxuICpcbiAqIERvdWJsZSBmb3JtXG4gKiAtIFNpbmdsZSBkb3VibGUgdmFsdWVcbiAqXG4gKiBTdHJpbmcgZm9ybVxuICogMTIzLjQ1NiAtIGEgc2ltcGxlIGRvdWJsZVxuICogMTIzLzQ1NiAtIEEgc3RyaW5nIGZyYWN0aW9uXG4gKiAxMjMuJzQ1NicgLSBhIGRvdWJsZSB3aXRoIHJlcGVhdGluZyBkZWNpbWFsIHBsYWNlc1xuICogMTIzLig0NTYpIC0gc3lub255bVxuICogMTIzLjQ1JzYnIC0gYSBkb3VibGUgd2l0aCByZXBlYXRpbmcgbGFzdCBwbGFjZVxuICogMTIzLjQ1KDYpIC0gc3lub255bVxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogdmFyIGYgPSBuZXcgRnJhY3Rpb24oXCI5LjQnMzEnXCIpO1xuICogZi5tdWwoWy00LCAzXSkuZGl2KDQuOSk7XG4gKlxuICovXG5cbihmdW5jdGlvbihyb290KSB7XG5cbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgLy8gTWF4aW11bSBzZWFyY2ggZGVwdGggZm9yIGN5Y2xpYyByYXRpb25hbCBudW1iZXJzLiAyMDAwIHNob3VsZCBiZSBtb3JlIHRoYW4gZW5vdWdoLiBcbiAgLy8gRXhhbXBsZTogMS83ID0gMC4oMTQyODU3KSBoYXMgNiByZXBlYXRpbmcgZGVjaW1hbCBwbGFjZXMuXG4gIC8vIElmIE1BWF9DWUNMRV9MRU4gZ2V0cyByZWR1Y2VkLCBsb25nIGN5Y2xlcyB3aWxsIG5vdCBiZSBkZXRlY3RlZCBhbmQgdG9TdHJpbmcoKSBvbmx5IGdldHMgdGhlIGZpcnN0IDEwIGRpZ2l0c1xuICB2YXIgTUFYX0NZQ0xFX0xFTiA9IDIwMDA7XG5cbiAgLy8gUGFyc2VkIGRhdGEgdG8gYXZvaWQgY2FsbGluZyBcIm5ld1wiIGFsbCB0aGUgdGltZVxuICB2YXIgUCA9IHtcbiAgICBcInNcIjogMSxcbiAgICBcIm5cIjogMCxcbiAgICBcImRcIjogMVxuICB9O1xuXG4gIGZ1bmN0aW9uIGFzc2lnbihuLCBzKSB7XG5cbiAgICBpZiAoaXNOYU4obiA9IHBhcnNlSW50KG4sIDEwKSkpIHtcbiAgICAgIHRob3J3SW52YWxpZFBhcmFtKCk7XG4gICAgfVxuICAgIHJldHVybiBuICogcztcbiAgfVxuXG4gIGZ1bmN0aW9uIHRob3J3SW52YWxpZFBhcmFtKCkge1xuICAgIHRocm93IFwiSW52YWxpZCBQYXJhbVwiO1xuICB9XG5cbiAgdmFyIHBhcnNlID0gZnVuY3Rpb24ocDEsIHAyKSB7XG5cbiAgICB2YXIgbiA9IDAsIGQgPSAxLCBzID0gMTtcbiAgICB2YXIgdiA9IDAsIHcgPSAwLCB4ID0gMCwgeSA9IDEsIHogPSAxO1xuXG4gICAgdmFyIEEgPSAwLCBCID0gMTtcbiAgICB2YXIgQyA9IDEsIEQgPSAxO1xuXG4gICAgdmFyIE4gPSAxMDAwMDAwMDtcbiAgICB2YXIgTTtcblxuICAgIGlmIChwMSA9PT0gdW5kZWZpbmVkIHx8IHAxID09PSBudWxsKSB7XG4gICAgICAvKiB2b2lkICovXG4gICAgfSBlbHNlIGlmIChwMiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBuID0gcDE7XG4gICAgICBkID0gcDI7XG4gICAgICBzID0gbiAqIGQ7XG4gICAgfSBlbHNlXG4gICAgICBzd2l0Y2ggKHR5cGVvZiBwMSkge1xuXG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChcImRcIiBpbiBwMSAmJiBcIm5cIiBpbiBwMSkge1xuICAgICAgICAgICAgbiA9IHAxW1wiblwiXTtcbiAgICAgICAgICAgIGQgPSBwMVtcImRcIl07XG4gICAgICAgICAgICBpZiAoXCJzXCIgaW4gcDEpXG4gICAgICAgICAgICAgIG4qPSBwMVtcInNcIl07XG4gICAgICAgICAgfSBlbHNlIGlmICgwIGluIHAxKSB7XG4gICAgICAgICAgICBuID0gcDFbMF07XG4gICAgICAgICAgICBpZiAoMSBpbiBwMSlcbiAgICAgICAgICAgICAgZCA9IHAxWzFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aG9yd0ludmFsaWRQYXJhbSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzID0gbiAqIGQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHAxIDwgMCkge1xuICAgICAgICAgICAgcyA9IHAxO1xuICAgICAgICAgICAgcDEgPSAtcDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHAxICUgMSA9PT0gMCkge1xuICAgICAgICAgICAgbiA9IHAxO1xuICAgICAgICAgIH0gZWxzZSBpZiAocDEgPiAwKSB7IC8vIGNoZWNrIGZvciAhPSAwLCBzY2FsZSB3b3VsZCBiZWNvbWUgTmFOIChsb2coMCkpLCB3aGljaCBjb252ZXJnZXMgcmVhbGx5IHNsb3dcblxuICAgICAgICAgICAgaWYgKHAxID49IDEpIHtcbiAgICAgICAgICAgICAgeiA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKDEgKyBNYXRoLmxvZyhwMSkgLyBNYXRoLkxOMTApKTtcbiAgICAgICAgICAgICAgcDEvPSB6O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVc2luZyBGYXJleSBTZXF1ZW5jZXNcbiAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cuam9obmRjb29rLmNvbS9ibG9nLzIwMTAvMTAvMjAvYmVzdC1yYXRpb25hbC1hcHByb3hpbWF0aW9uL1xuXG4gICAgICAgICAgICB3aGlsZSAoQiA8PSBOICYmIEQgPD0gTikge1xuICAgICAgICAgICAgICBNID0gKEEgKyBDKSAvIChCICsgRCk7XG5cbiAgICAgICAgICAgICAgaWYgKHAxID09PSBNKSB7XG4gICAgICAgICAgICAgICAgaWYgKEIgKyBEIDw9IE4pIHtcbiAgICAgICAgICAgICAgICAgIG4gPSBBICsgQztcbiAgICAgICAgICAgICAgICAgIGQgPSBCICsgRDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEQgPiBCKSB7XG4gICAgICAgICAgICAgICAgICBuID0gQztcbiAgICAgICAgICAgICAgICAgIGQgPSBEO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBuID0gQTtcbiAgICAgICAgICAgICAgICAgIGQgPSBCO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgaWYgKHAxID4gTSkge1xuICAgICAgICAgICAgICAgICAgQSs9IEM7XG4gICAgICAgICAgICAgICAgICBCKz0gRDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgQys9IEE7XG4gICAgICAgICAgICAgICAgICBEKz0gQjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoQiA+IE4pIHtcbiAgICAgICAgICAgICAgICAgIG4gPSBDO1xuICAgICAgICAgICAgICAgICAgZCA9IEQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG4gPSBBO1xuICAgICAgICAgICAgICAgICAgZCA9IEI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuKj0gejtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTmFOKHAxKSB8fCBpc05hTihwMikpIHtcbiAgICAgICAgICAgIGQgPSBuID0gTmFOO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBCID0gcDEubWF0Y2goL1xcZCt8Li9nKTtcblxuICAgICAgICAgIGlmIChCW0FdID09PSAnLScpIHsvLyBDaGVjayBmb3IgbWludXMgc2lnbiBhdCB0aGUgYmVnaW5uaW5nXG4gICAgICAgICAgICBzID0gLTE7XG4gICAgICAgICAgICBBKys7XG4gICAgICAgICAgfSBlbHNlIGlmIChCW0FdID09PSAnKycpIHsvLyBDaGVjayBmb3IgcGx1cyBzaWduIGF0IHRoZSBiZWdpbm5pbmdcbiAgICAgICAgICAgIEErKztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoQi5sZW5ndGggPT09IEEgKyAxKSB7IC8vIENoZWNrIGlmIGl0J3MganVzdCBhIHNpbXBsZSBudW1iZXIgXCIxMjM0XCJcbiAgICAgICAgICAgIHcgPSBhc3NpZ24oQltBKytdLCBzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKEJbQSArIDFdID09PSAnLicgfHwgQltBXSA9PT0gJy4nKSB7IC8vIENoZWNrIGlmIGl0J3MgYSBkZWNpbWFsIG51bWJlclxuXG4gICAgICAgICAgICBpZiAoQltBXSAhPT0gJy4nKSB7IC8vIEhhbmRsZSAwLjUgYW5kIC41XG4gICAgICAgICAgICAgIHYgPSBhc3NpZ24oQltBKytdLCBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEErKztcblxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGRlY2ltYWwgcGxhY2VzXG4gICAgICAgICAgICBpZiAoQSArIDEgPT09IEIubGVuZ3RoIHx8IEJbQSArIDFdID09PSAnKCcgJiYgQltBICsgM10gPT09ICcpJyB8fCBCW0EgKyAxXSA9PT0gXCInXCIgJiYgQltBICsgM10gPT09IFwiJ1wiKSB7XG4gICAgICAgICAgICAgIHcgPSBhc3NpZ24oQltBXSwgcyk7XG4gICAgICAgICAgICAgIHkgPSBNYXRoLnBvdygxMCwgQltBXS5sZW5ndGgpO1xuICAgICAgICAgICAgICBBKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGZvciByZXBlYXRpbmcgcGxhY2VzXG4gICAgICAgICAgICBpZiAoQltBXSA9PT0gJygnICYmIEJbQSArIDJdID09PSAnKScgfHwgQltBXSA9PT0gXCInXCIgJiYgQltBICsgMl0gPT09IFwiJ1wiKSB7XG4gICAgICAgICAgICAgIHggPSBhc3NpZ24oQltBICsgMV0sIHMpO1xuICAgICAgICAgICAgICB6ID0gTWF0aC5wb3coMTAsIEJbQSArIDFdLmxlbmd0aCkgLSAxO1xuICAgICAgICAgICAgICBBKz0gMztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoQltBICsgMV0gPT09ICcvJyB8fCBCW0EgKyAxXSA9PT0gJzonKSB7IC8vIENoZWNrIGZvciBhIHNpbXBsZSBmcmFjdGlvbiBcIjEyMy80NTZcIiBvciBcIjEyMzo0NTZcIlxuICAgICAgICAgICAgdyA9IGFzc2lnbihCW0FdLCBzKTtcbiAgICAgICAgICAgIHkgPSBhc3NpZ24oQltBICsgMl0sIDEpO1xuICAgICAgICAgICAgQSs9IDM7XG4gICAgICAgICAgfSBlbHNlIGlmIChCW0EgKyAzXSA9PT0gJy8nICYmIEJbQSArIDFdID09PSAnICcpIHsgLy8gQ2hlY2sgZm9yIGEgY29tcGxleCBmcmFjdGlvbiBcIjEyMyAxLzJcIlxuICAgICAgICAgICAgdiA9IGFzc2lnbihCW0FdLCBzKTtcbiAgICAgICAgICAgIHcgPSBhc3NpZ24oQltBICsgMl0sIHMpO1xuICAgICAgICAgICAgeSA9IGFzc2lnbihCW0EgKyA0XSwgMSk7XG4gICAgICAgICAgICBBKz0gNTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoQi5sZW5ndGggPD0gQSkgeyAvLyBDaGVjayBmb3IgbW9yZSB0b2tlbnMgb24gdGhlIHN0YWNrXG4gICAgICAgICAgICBkID0geSAqIHo7XG4gICAgICAgICAgICBzID0gLyogdm9pZCAqL1xuICAgICAgICAgICAgICAgICAgICBuID0geCArIGQgKiB2ICsgeiAqIHc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKiBGYWxsIHRocm91Z2ggb24gZXJyb3IgKi9cbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRob3J3SW52YWxpZFBhcmFtKCk7XG4gICAgICB9XG5cbiAgICBpZiAoZCA9PT0gMCkge1xuICAgICAgdGhyb3cgXCJESVYvMFwiO1xuICAgIH1cblxuICAgIFBbXCJzXCJdID0gcyA8IDAgPyAtMSA6IDE7XG4gICAgUFtcIm5cIl0gPSBNYXRoLmFicyhuKTtcbiAgICBQW1wiZFwiXSA9IE1hdGguYWJzKGQpO1xuICB9O1xuXG4gIHZhciBtb2Rwb3cgPSBmdW5jdGlvbihiLCBlLCBtKSB7XG5cbiAgICBmb3IgKHZhciByID0gMTsgZSA+IDA7IGIgPSAoYiAqIGIpICUgbSwgZSA+Pj0gMSkge1xuXG4gICAgICBpZiAoZSAmIDEpIHtcbiAgICAgICAgciA9IChyICogYikgJSBtO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICB2YXIgY3ljbGVMZW4gPSBmdW5jdGlvbihuLCBkKSB7XG5cbiAgICBmb3IgKDsgZCAlIDIgPT09IDA7XG4gICAgICAgICAgICBkLz0gMikge31cblxuICAgIGZvciAoOyBkICUgNSA9PT0gMDtcbiAgICAgICAgICAgIGQvPSA1KSB7fVxuXG4gICAgaWYgKGQgPT09IDEpIC8vIENhdGNoIG5vbi1jeWNsaWMgbnVtYmVyc1xuICAgICAgcmV0dXJuIDA7XG5cbiAgICAvLyBJZiB3ZSB3b3VsZCBsaWtlIHRvIGNvbXB1dGUgcmVhbGx5IGxhcmdlIG51bWJlcnMgcXVpY2tlciwgd2UgY291bGQgbWFrZSB1c2Ugb2YgRmVybWF0J3MgbGl0dGxlIHRoZW9yZW06XG4gICAgLy8gMTBeKGQtMSkgJSBkID09IDFcbiAgICAvLyBIb3dldmVyLCB3ZSBkb24ndCBuZWVkIHN1Y2ggbGFyZ2UgbnVtYmVycyBhbmQgTUFYX0NZQ0xFX0xFTiBzaG91bGQgYmUgdGhlIGNhcHN0b25lLCBcbiAgICAvLyBhcyB3ZSB3YW50IHRvIHRyYW5zbGF0ZSB0aGUgbnVtYmVycyB0byBzdHJpbmdzLlxuXG4gICAgdmFyIHJlbSA9IDEwICUgZDtcblxuICAgIGZvciAodmFyIHQgPSAxOyByZW0gIT09IDE7IHQrKykge1xuICAgICAgcmVtID0gcmVtICogMTAgJSBkO1xuXG4gICAgICBpZiAodCA+IE1BWF9DWUNMRV9MRU4pXG4gICAgICAgIHJldHVybiAwOyAvLyBSZXR1cm5pbmcgMCBoZXJlIG1lYW5zIHRoYXQgd2UgZG9uJ3QgcHJpbnQgaXQgYXMgYSBjeWNsaWMgbnVtYmVyLiBJdCdzIGxpa2VseSB0aGF0IHRoZSBhbnN3ZXIgaXMgYGQtMWBcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH07XG5cbiAgdmFyIGN5Y2xlU3RhcnQgPSBmdW5jdGlvbihuLCBkLCBsZW4pIHtcblxuICAgIHZhciByZW0xID0gMTtcbiAgICB2YXIgcmVtMiA9IG1vZHBvdygxMCwgbGVuLCBkKTtcblxuICAgIGZvciAodmFyIHQgPSAwOyB0IDwgMzAwOyB0KyspIHsgLy8gcyA8IH5sb2cxMChOdW1iZXIuTUFYX1ZBTFVFKVxuICAgICAgLy8gU29sdmUgMTBecyA9PSAxMF4ocyt0KSAobW9kIGQpXG5cbiAgICAgIGlmIChyZW0xID09PSByZW0yKVxuICAgICAgICByZXR1cm4gdDtcblxuICAgICAgcmVtMSA9IHJlbTEgKiAxMCAlIGQ7XG4gICAgICByZW0yID0gcmVtMiAqIDEwICUgZDtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH07XG5cbiAgdmFyIGdjZCA9IGZ1bmN0aW9uKGEsIGIpIHtcblxuICAgIGlmICghYSkgcmV0dXJuIGI7XG4gICAgaWYgKCFiKSByZXR1cm4gYTtcblxuICAgIHdoaWxlICgxKSB7XG4gICAgICBhJT0gYjtcbiAgICAgIGlmICghYSkgcmV0dXJuIGI7XG4gICAgICBiJT0gYTtcbiAgICAgIGlmICghYikgcmV0dXJuIGE7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBNb2R1bGUgY29uc3RydWN0b3JcbiAgICpcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7bnVtYmVyfEZyYWN0aW9ufSBhXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gYlxuICAgKi9cbiAgZnVuY3Rpb24gRnJhY3Rpb24oYSwgYikge1xuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEZyYWN0aW9uKSkge1xuICAgICAgcmV0dXJuIG5ldyBGcmFjdGlvbihhLCBiKTtcbiAgICB9XG5cbiAgICBwYXJzZShhLCBiKTtcblxuICAgIGlmIChGcmFjdGlvblsnUkVEVUNFJ10pIHtcbiAgICAgIGEgPSBnY2QoUFtcImRcIl0sIFBbXCJuXCJdKTsgLy8gQWJ1c2UgYVxuICAgIH0gZWxzZSB7XG4gICAgICBhID0gMTtcbiAgICB9XG5cbiAgICB0aGlzW1wic1wiXSA9IFBbXCJzXCJdO1xuICAgIHRoaXNbXCJuXCJdID0gUFtcIm5cIl0gLyBhO1xuICAgIHRoaXNbXCJkXCJdID0gUFtcImRcIl0gLyBhO1xuICB9XG5cbiAgLyoqXG4gICAqIEJvb2xlYW4gZ2xvYmFsIHZhcmlhYmxlIHRvIGJlIGFibGUgdG8gZGlzYWJsZSBhdXRvbWF0aWMgcmVkdWN0aW9uIG9mIHRoZSBmcmFjdGlvblxuICAgKlxuICAgKi9cbiAgRnJhY3Rpb25bJ1JFRFVDRSddID0gMTtcblxuICBGcmFjdGlvbi5wcm90b3R5cGUgPSB7XG5cbiAgICBcInNcIjogMSxcbiAgICBcIm5cIjogMCxcbiAgICBcImRcIjogMSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGFic29sdXRlIHZhbHVlXG4gICAgICpcbiAgICAgKiBFeDogbmV3IEZyYWN0aW9uKC00KS5hYnMoKSA9PiA0XG4gICAgICoqL1xuICAgIFwiYWJzXCI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICByZXR1cm4gbmV3IEZyYWN0aW9uKHRoaXNbXCJuXCJdLCB0aGlzW1wiZFwiXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEludmVydHMgdGhlIHNpZ24gb2YgdGhlIGN1cnJlbnQgZnJhY3Rpb25cbiAgICAgKlxuICAgICAqIEV4OiBuZXcgRnJhY3Rpb24oLTQpLm5lZygpID0+IDRcbiAgICAgKiovXG4gICAgXCJuZWdcIjogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHJldHVybiBuZXcgRnJhY3Rpb24oLXRoaXNbXCJzXCJdICogdGhpc1tcIm5cIl0sIHRoaXNbXCJkXCJdKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyB0d28gcmF0aW9uYWwgbnVtYmVyc1xuICAgICAqXG4gICAgICogRXg6IG5ldyBGcmFjdGlvbih7bjogMiwgZDogM30pLmFkZChcIjE0LjlcIikgPT4gNDY3IC8gMzBcbiAgICAgKiovXG4gICAgXCJhZGRcIjogZnVuY3Rpb24oYSwgYikge1xuXG4gICAgICBwYXJzZShhLCBiKTtcbiAgICAgIHJldHVybiBuZXcgRnJhY3Rpb24oXG4gICAgICAgICAgICAgIHRoaXNbXCJzXCJdICogdGhpc1tcIm5cIl0gKiBQW1wiZFwiXSArIFBbXCJzXCJdICogdGhpc1tcImRcIl0gKiBQW1wiblwiXSxcbiAgICAgICAgICAgICAgdGhpc1tcImRcIl0gKiBQW1wiZFwiXVxuICAgICAgICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgdHdvIHJhdGlvbmFsIG51bWJlcnNcbiAgICAgKlxuICAgICAqIEV4OiBuZXcgRnJhY3Rpb24oe246IDIsIGQ6IDN9KS5hZGQoXCIxNC45XCIpID0+IC00MjcgLyAzMFxuICAgICAqKi9cbiAgICBcInN1YlwiOiBmdW5jdGlvbihhLCBiKSB7XG5cbiAgICAgIHBhcnNlKGEsIGIpO1xuICAgICAgcmV0dXJuIG5ldyBGcmFjdGlvbihcbiAgICAgICAgICAgICAgdGhpc1tcInNcIl0gKiB0aGlzW1wiblwiXSAqIFBbXCJkXCJdIC0gUFtcInNcIl0gKiB0aGlzW1wiZFwiXSAqIFBbXCJuXCJdLFxuICAgICAgICAgICAgICB0aGlzW1wiZFwiXSAqIFBbXCJkXCJdXG4gICAgICAgICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgdHdvIHJhdGlvbmFsIG51bWJlcnNcbiAgICAgKlxuICAgICAqIEV4OiBuZXcgRnJhY3Rpb24oXCItMTcuKDM0NSlcIikubXVsKDMpID0+IDU3NzYgLyAxMTFcbiAgICAgKiovXG4gICAgXCJtdWxcIjogZnVuY3Rpb24oYSwgYikge1xuXG4gICAgICBwYXJzZShhLCBiKTtcbiAgICAgIHJldHVybiBuZXcgRnJhY3Rpb24oXG4gICAgICAgICAgICAgIHRoaXNbXCJzXCJdICogUFtcInNcIl0gKiB0aGlzW1wiblwiXSAqIFBbXCJuXCJdLFxuICAgICAgICAgICAgICB0aGlzW1wiZFwiXSAqIFBbXCJkXCJdXG4gICAgICAgICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERpdmlkZXMgdHdvIHJhdGlvbmFsIG51bWJlcnNcbiAgICAgKlxuICAgICAqIEV4OiBuZXcgRnJhY3Rpb24oXCItMTcuKDM0NSlcIikuaW52ZXJzZSgpLmRpdigzKVxuICAgICAqKi9cbiAgICBcImRpdlwiOiBmdW5jdGlvbihhLCBiKSB7XG5cbiAgICAgIHBhcnNlKGEsIGIpO1xuICAgICAgcmV0dXJuIG5ldyBGcmFjdGlvbihcbiAgICAgICAgICAgICAgdGhpc1tcInNcIl0gKiBQW1wic1wiXSAqIHRoaXNbXCJuXCJdICogUFtcImRcIl0sXG4gICAgICAgICAgICAgIHRoaXNbXCJkXCJdICogUFtcIm5cIl1cbiAgICAgICAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xvbmVzIHRoZSBhY3R1YWwgb2JqZWN0XG4gICAgICpcbiAgICAgKiBFeDogbmV3IEZyYWN0aW9uKFwiLTE3LigzNDUpXCIpLmNsb25lKClcbiAgICAgKiovXG4gICAgXCJjbG9uZVwiOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgRnJhY3Rpb24odGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIG1vZHVsbyBvZiB0d28gcmF0aW9uYWwgbnVtYmVycyAtIGEgbW9yZSBwcmVjaXNlIGZtb2RcbiAgICAgKlxuICAgICAqIEV4OiBuZXcgRnJhY3Rpb24oJzQuKDMpJykubW9kKFs3LCA4XSkgPT4gKDEzLzMpICUgKDcvOCkgPSAoNS82KVxuICAgICAqKi9cbiAgICBcIm1vZFwiOiBmdW5jdGlvbihhLCBiKSB7XG5cbiAgICAgIGlmIChpc05hTih0aGlzWyduJ10pIHx8wqBpc05hTih0aGlzWydkJ10pKSB7XG4gICAgICAgIHJldHVybiBuZXcgRnJhY3Rpb24oTmFOKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbmV3IEZyYWN0aW9uKHRoaXNbXCJzXCJdICogdGhpc1tcIm5cIl0gJSB0aGlzW1wiZFwiXSwgMSk7XG4gICAgICB9XG5cbiAgICAgIHBhcnNlKGEsIGIpO1xuICAgICAgaWYgKDAgPT09IFBbXCJuXCJdICYmIDAgPT09IHRoaXNbXCJkXCJdKSB7XG4gICAgICAgIEZyYWN0aW9uKDAsIDApOyAvLyBUaHJvdyBkaXYvMFxuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgICogRmlyc3Qgc2lsbHkgYXR0ZW1wdCwga2luZGEgc2xvd1xuICAgICAgICpcbiAgICAgICByZXR1cm4gdGhhdFtcInN1YlwiXSh7XG4gICAgICAgXCJuXCI6IG51bVtcIm5cIl0gKiBNYXRoLmZsb29yKCh0aGlzLm4gLyB0aGlzLmQpIC8gKG51bS5uIC8gbnVtLmQpKSxcbiAgICAgICBcImRcIjogbnVtW1wiZFwiXSxcbiAgICAgICBcInNcIjogdGhpc1tcInNcIl1cbiAgICAgICB9KTsqL1xuXG4gICAgICAvKlxuICAgICAgICogTmV3IGF0dGVtcHQ6IGExIC8gYjEgPSBhMiAvIGIyICogcSArIHJcbiAgICAgICAqID0+IGIyICogYTEgPSBhMiAqIGIxICogcSArIGIxICogYjIgKiByXG4gICAgICAgKiA9PiAoYjIgKiBhMSAlIGEyICogYjEpIC8gKGIxICogYjIpXG4gICAgICAgKi9cbiAgICAgIHJldHVybiBuZXcgRnJhY3Rpb24oXG4gICAgICAgICAgICAgICh0aGlzW1wic1wiXSAqIFBbXCJkXCJdICogdGhpc1tcIm5cIl0pICUgKFBbXCJuXCJdICogdGhpc1tcImRcIl0pLFxuICAgICAgICAgICAgICBQW1wiZFwiXSAqIHRoaXNbXCJkXCJdXG4gICAgICAgICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGZyYWN0aW9uYWwgZ2NkIG9mIHR3byByYXRpb25hbCBudW1iZXJzXG4gICAgICpcbiAgICAgKiBFeDogbmV3IEZyYWN0aW9uKDUsOCkuZ2NkKDMsNykgPT4gMS81NlxuICAgICAqL1xuICAgIFwiZ2NkXCI6IGZ1bmN0aW9uKGEsIGIpIHtcblxuICAgICAgcGFyc2UoYSwgYik7XG5cbiAgICAgIC8vIGdjZChhIC8gYiwgYyAvIGQpID0gZ2NkKGEsIGMpIC8gbGNtKGIsIGQpXG5cbiAgICAgIHJldHVybiBuZXcgRnJhY3Rpb24oZ2NkKFBbXCJuXCJdLCB0aGlzW1wiblwiXSksIFBbXCJkXCJdICogdGhpc1tcImRcIl0gLyBnY2QoUFtcImRcIl0sIHRoaXNbXCJkXCJdKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGZyYWN0aW9uYWwgbGNtIG9mIHR3byByYXRpb25hbCBudW1iZXJzXG4gICAgICpcbiAgICAgKiBFeDogbmV3IEZyYWN0aW9uKDUsOCkubGNtKDMsNykgPT4gMTVcbiAgICAgKi9cbiAgICBcImxjbVwiOiBmdW5jdGlvbihhLCBiKSB7XG5cbiAgICAgIHBhcnNlKGEsIGIpO1xuXG4gICAgICAvLyBsY20oYSAvIGIsIGMgLyBkKSA9IGxjbShhLCBjKSAvIGdjZChiLCBkKVxuXG4gICAgICBpZiAoUFtcIm5cIl0gPT09IDAgJiYgdGhpc1tcIm5cIl0gPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGcmFjdGlvbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgRnJhY3Rpb24oUFtcIm5cIl0gKiB0aGlzW1wiblwiXSAvIGdjZChQW1wiblwiXSwgdGhpc1tcIm5cIl0pLCBnY2QoUFtcImRcIl0sIHRoaXNbXCJkXCJdKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGNlaWwgb2YgYSByYXRpb25hbCBudW1iZXJcbiAgICAgKlxuICAgICAqIEV4OiBuZXcgRnJhY3Rpb24oJzQuKDMpJykuY2VpbCgpID0+ICg1IC8gMSlcbiAgICAgKiovXG4gICAgXCJjZWlsXCI6IGZ1bmN0aW9uKHBsYWNlcykge1xuXG4gICAgICBwbGFjZXMgPSBNYXRoLnBvdygxMCwgcGxhY2VzIHx8IDApO1xuXG4gICAgICBpZiAoaXNOYU4odGhpc1tcIm5cIl0pIHx8IGlzTmFOKHRoaXNbXCJkXCJdKSkge1xuICAgICAgICByZXR1cm4gbmV3IEZyYWN0aW9uKE5hTik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEZyYWN0aW9uKE1hdGguY2VpbChwbGFjZXMgKiB0aGlzW1wic1wiXSAqIHRoaXNbXCJuXCJdIC8gdGhpc1tcImRcIl0pLCBwbGFjZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBmbG9vciBvZiBhIHJhdGlvbmFsIG51bWJlclxuICAgICAqXG4gICAgICogRXg6IG5ldyBGcmFjdGlvbignNC4oMyknKS5mbG9vcigpID0+ICg0IC8gMSlcbiAgICAgKiovXG4gICAgXCJmbG9vclwiOiBmdW5jdGlvbihwbGFjZXMpIHtcblxuICAgICAgcGxhY2VzID0gTWF0aC5wb3coMTAsIHBsYWNlcyB8fCAwKTtcblxuICAgICAgaWYgKGlzTmFOKHRoaXNbXCJuXCJdKSB8fCBpc05hTih0aGlzW1wiZFwiXSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGcmFjdGlvbihOYU4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBGcmFjdGlvbihNYXRoLmZsb29yKHBsYWNlcyAqIHRoaXNbXCJzXCJdICogdGhpc1tcIm5cIl0gLyB0aGlzW1wiZFwiXSksIHBsYWNlcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJvdW5kcyBhIHJhdGlvbmFsIG51bWJlcnNcbiAgICAgKlxuICAgICAqIEV4OiBuZXcgRnJhY3Rpb24oJzQuKDMpJykucm91bmQoKSA9PiAoNCAvIDEpXG4gICAgICoqL1xuICAgIFwicm91bmRcIjogZnVuY3Rpb24ocGxhY2VzKSB7XG5cbiAgICAgIHBsYWNlcyA9IE1hdGgucG93KDEwLCBwbGFjZXMgfHwgMCk7XG5cbiAgICAgIGlmIChpc05hTih0aGlzW1wiblwiXSkgfHwgaXNOYU4odGhpc1tcImRcIl0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgRnJhY3Rpb24oTmFOKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgRnJhY3Rpb24oTWF0aC5yb3VuZChwbGFjZXMgKiB0aGlzW1wic1wiXSAqIHRoaXNbXCJuXCJdIC8gdGhpc1tcImRcIl0pLCBwbGFjZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbnZlcnNlIG9mIHRoZSBmcmFjdGlvbiwgbWVhbnMgbnVtZXJhdG9yIGFuZCBkZW51bWVyYXRvciBhcmUgZXhjaGFuZ2VkXG4gICAgICpcbiAgICAgKiBFeDogbmV3IEZyYWN0aW9uKFstMywgNF0pLmludmVyc2UoKSA9PiAtNCAvIDNcbiAgICAgKiovXG4gICAgXCJpbnZlcnNlXCI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICByZXR1cm4gbmV3IEZyYWN0aW9uKHRoaXNbXCJzXCJdICogdGhpc1tcImRcIl0sIHRoaXNbXCJuXCJdKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgZnJhY3Rpb24gdG8gc29tZSBpbnRlZ2VyIGV4cG9uZW50XG4gICAgICpcbiAgICAgKiBFeDogbmV3IEZyYWN0aW9uKC0xLDIpLnBvdygtMykgPT4gLThcbiAgICAgKi9cbiAgICBcInBvd1wiOiBmdW5jdGlvbihtKSB7XG5cbiAgICAgIGlmIChtIDwgMCkge1xuICAgICAgICByZXR1cm4gbmV3IEZyYWN0aW9uKE1hdGgucG93KHRoaXNbJ3MnXSAqIHRoaXNbXCJkXCJdLC1tKSwgTWF0aC5wb3codGhpc1tcIm5cIl0sLW0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgRnJhY3Rpb24oTWF0aC5wb3codGhpc1sncyddICogdGhpc1tcIm5cIl0sIG0pLCBNYXRoLnBvdyh0aGlzW1wiZFwiXSwgbSkpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0d28gcmF0aW9uYWwgbnVtYmVycyBhcmUgdGhlIHNhbWVcbiAgICAgKlxuICAgICAqIEV4OiBuZXcgRnJhY3Rpb24oMTkuNikuZXF1YWxzKFs5OCwgNV0pO1xuICAgICAqKi9cbiAgICBcImVxdWFsc1wiOiBmdW5jdGlvbihhLCBiKSB7XG5cbiAgICAgIHBhcnNlKGEsIGIpO1xuICAgICAgcmV0dXJuIHRoaXNbXCJzXCJdICogdGhpc1tcIm5cIl0gKiBQW1wiZFwiXSA9PT0gUFtcInNcIl0gKiBQW1wiblwiXSAqIHRoaXNbXCJkXCJdOyAvLyBTYW1lIGFzIGNvbXBhcmUoKSA9PT0gMFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0d28gcmF0aW9uYWwgbnVtYmVycyBhcmUgdGhlIHNhbWVcbiAgICAgKlxuICAgICAqIEV4OiBuZXcgRnJhY3Rpb24oMTkuNikuZXF1YWxzKFs5OCwgNV0pO1xuICAgICAqKi9cbiAgICBcImNvbXBhcmVcIjogZnVuY3Rpb24oYSwgYikge1xuXG4gICAgICBwYXJzZShhLCBiKTtcbiAgICAgIHZhciB0ID0gKHRoaXNbXCJzXCJdICogdGhpc1tcIm5cIl0gKiBQW1wiZFwiXSAtIFBbXCJzXCJdICogUFtcIm5cIl0gKiB0aGlzW1wiZFwiXSk7XG4gICAgICByZXR1cm4gKDAgPCB0KSAtICh0IDwgMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHR3byByYXRpb25hbCBudW1iZXJzIGFyZSBkaXZpc2libGVcbiAgICAgKlxuICAgICAqIEV4OiBuZXcgRnJhY3Rpb24oMTkuNikuZGl2aXNpYmxlKDEuNSk7XG4gICAgICovXG4gICAgXCJkaXZpc2libGVcIjogZnVuY3Rpb24oYSwgYikge1xuXG4gICAgICBwYXJzZShhLCBiKTtcbiAgICAgIHJldHVybiAhKCEoUFtcIm5cIl0gKiB0aGlzW1wiZFwiXSkgfHwgKCh0aGlzW1wiblwiXSAqIFBbXCJkXCJdKSAlIChQW1wiblwiXSAqIHRoaXNbXCJkXCJdKSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZGVjaW1hbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZnJhY3Rpb25cbiAgICAgKlxuICAgICAqIEV4OiBuZXcgRnJhY3Rpb24oXCIxMDAuJzkxODIzJ1wiKS52YWx1ZU9mKCkgPT4gMTAwLjkxODIzOTE4MjM5MTgzXG4gICAgICoqL1xuICAgICd2YWx1ZU9mJzogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHJldHVybiB0aGlzW1wic1wiXSAqIHRoaXNbXCJuXCJdIC8gdGhpc1tcImRcIl07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmctZnJhY3Rpb24gcmVwcmVzZW50YXRpb24gb2YgYSBGcmFjdGlvbiBvYmplY3RcbiAgICAgKlxuICAgICAqIEV4OiBuZXcgRnJhY3Rpb24oXCIxLiczJ1wiKS50b0ZyYWN0aW9uKCkgPT4gXCI0IDEvM1wiXG4gICAgICoqL1xuICAgICd0b0ZyYWN0aW9uJzogZnVuY3Rpb24oZXhjbHVkZVdob2xlKSB7XG5cbiAgICAgIHZhciB3aG9sZSwgc3RyID0gXCJcIjtcbiAgICAgIHZhciBuID0gdGhpc1tcIm5cIl07XG4gICAgICB2YXIgZCA9IHRoaXNbXCJkXCJdO1xuICAgICAgaWYgKHRoaXNbXCJzXCJdIDwgMCkge1xuICAgICAgICBzdHIrPSAnLSc7XG4gICAgICB9XG5cbiAgICAgIGlmIChkID09PSAxKSB7XG4gICAgICAgIHN0cis9IG47XG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGlmIChleGNsdWRlV2hvbGUgJiYgKHdob2xlID0gTWF0aC5mbG9vcihuIC8gZCkpID4gMCkge1xuICAgICAgICAgIHN0cis9IHdob2xlO1xuICAgICAgICAgIHN0cis9IFwiIFwiO1xuICAgICAgICAgIG4lPSBkO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RyKz0gbjtcbiAgICAgICAgc3RyKz0gJy8nO1xuICAgICAgICBzdHIrPSBkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxhdGV4IHJlcHJlc2VudGF0aW9uIG9mIGEgRnJhY3Rpb24gb2JqZWN0XG4gICAgICpcbiAgICAgKiBFeDogbmV3IEZyYWN0aW9uKFwiMS4nMydcIikudG9MYXRleCgpID0+IFwiXFxmcmFjezR9ezN9XCJcbiAgICAgKiovXG4gICAgJ3RvTGF0ZXgnOiBmdW5jdGlvbihleGNsdWRlV2hvbGUpIHtcblxuICAgICAgdmFyIHdob2xlLCBzdHIgPSBcIlwiO1xuICAgICAgdmFyIG4gPSB0aGlzW1wiblwiXTtcbiAgICAgIHZhciBkID0gdGhpc1tcImRcIl07XG4gICAgICBpZiAodGhpc1tcInNcIl0gPCAwKSB7XG4gICAgICAgIHN0cis9ICctJztcbiAgICAgIH1cblxuICAgICAgaWYgKGQgPT09IDEpIHtcbiAgICAgICAgc3RyKz0gbjtcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgaWYgKGV4Y2x1ZGVXaG9sZSAmJiAod2hvbGUgPSBNYXRoLmZsb29yKG4gLyBkKSkgPiAwKSB7XG4gICAgICAgICAgc3RyKz0gd2hvbGU7XG4gICAgICAgICAgbiU9IGQ7XG4gICAgICAgIH1cblxuICAgICAgICBzdHIrPSBcIlxcXFxmcmFje1wiO1xuICAgICAgICBzdHIrPSBuO1xuICAgICAgICBzdHIrPSAnfXsnO1xuICAgICAgICBzdHIrPSBkO1xuICAgICAgICBzdHIrPSAnfSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGNvbnRpbnVlZCBmcmFjdGlvbiBlbGVtZW50c1xuICAgICAqIFxuICAgICAqIEV4OiBuZXcgRnJhY3Rpb24oXCI3LzhcIikudG9Db250aW51ZWQoKSA9PiBbMCwxLDddXG4gICAgICovXG4gICAgJ3RvQ29udGludWVkJzogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciB0O1xuICAgICAgdmFyIGEgPSB0aGlzWyduJ107XG4gICAgICB2YXIgYiA9IHRoaXNbJ2QnXTtcbiAgICAgIHZhciByZXMgPSBbXTtcblxuICAgICAgZG8ge1xuICAgICAgICByZXMucHVzaChNYXRoLmZsb29yKGEgLyBiKSk7XG4gICAgICAgIHQgPSBhICUgYjtcbiAgICAgICAgYSA9IGI7XG4gICAgICAgIGIgPSB0O1xuICAgICAgfSB3aGlsZSAoYSAhPT0gMSk7XG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBmcmFjdGlvbiB3aXRoIGFsbCBkaWdpdHNcbiAgICAgKlxuICAgICAqIEV4OiBuZXcgRnJhY3Rpb24oXCIxMDAuJzkxODIzJ1wiKS50b1N0cmluZygpID0+IFwiMTAwLig5MTgyMylcIlxuICAgICAqKi9cbiAgICAndG9TdHJpbmcnOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIGc7XG4gICAgICB2YXIgTiA9IHRoaXNbXCJuXCJdO1xuICAgICAgdmFyIEQgPSB0aGlzW1wiZFwiXTtcblxuICAgICAgaWYgKGlzTmFOKE4pIHx8IGlzTmFOKEQpKSB7XG4gICAgICAgIHJldHVybiBcIk5hTlwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoIUZyYWN0aW9uWydSRURVQ0UnXSkge1xuICAgICAgICBnID0gZ2NkKE4sIEQpO1xuICAgICAgICBOLz0gZztcbiAgICAgICAgRC89IGc7XG4gICAgICB9XG5cbiAgICAgIHZhciBwID0gU3RyaW5nKE4pLnNwbGl0KFwiXCIpOyAvLyBOdW1lcmF0b3IgY2hhcnNcbiAgICAgIHZhciB0ID0gMDsgLy8gVG1wIHZhclxuXG4gICAgICB2YXIgcmV0ID0gW350aGlzW1wic1wiXSA/IFwiXCIgOiBcIi1cIiwgXCJcIiwgXCJcIl07IC8vIFJldHVybiBhcnJheSwgWzBdIGlzIHplcm8gc2lnbiwgWzFdIGJlZm9yZSBjb21tYSwgWzJdIGFmdGVyXG4gICAgICB2YXIgemVyb3MgPSBcIlwiOyAvLyBDb2xsZWN0aW9uIHZhcmlhYmxlIGZvciB6ZXJvc1xuXG4gICAgICB2YXIgY3ljTGVuID0gY3ljbGVMZW4oTiwgRCk7IC8vIEN5Y2xlIGxlbmd0aFxuICAgICAgdmFyIGN5Y09mZiA9IGN5Y2xlU3RhcnQoTiwgRCwgY3ljTGVuKTsgLy8gQ3ljbGUgc3RhcnRcblxuICAgICAgdmFyIGogPSAtMTtcbiAgICAgIHZhciBuID0gMTsgLy8gc3RyIGluZGV4XG5cbiAgICAgIC8vIHJvdWdoIGVzdGltYXRlIHRvIGZpbGwgemVyb3NcbiAgICAgIHZhciBsZW5ndGggPSAxMCArIGN5Y0xlbiArIGN5Y09mZiArIHAubGVuZ3RoOyAvLyAxMCA9IGRlY2ltYWwgcGxhY2VzIHdoZW4gbm8gcmVwaXRhdGlvblxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrLCB0Kj0gMTApIHtcblxuICAgICAgICBpZiAoaSA8IHAubGVuZ3RoKSB7XG4gICAgICAgICAgdCs9IE51bWJlcihwW2ldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuID0gMjtcbiAgICAgICAgICBqKys7IC8vIFN0YXJ0IG5vdyA9PiBhZnRlciBjb21tYVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN5Y0xlbiA+IDApIHsgLy8gSWYgd2UgaGF2ZSBhIHJlcGVhdGluZyBwYXJ0XG4gICAgICAgICAgaWYgKGogPT09IGN5Y09mZikge1xuICAgICAgICAgICAgcmV0W25dKz0gemVyb3MgKyBcIihcIjtcbiAgICAgICAgICAgIHplcm9zID0gXCJcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGogPT09IGN5Y0xlbiArIGN5Y09mZikge1xuICAgICAgICAgICAgcmV0W25dKz0gemVyb3MgKyBcIilcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ID49IEQpIHtcbiAgICAgICAgICByZXRbbl0rPSB6ZXJvcyArICgodCAvIEQpIHwgMCk7IC8vIEZsdXNoIHplcm9zLCBBZGQgY3VycmVudCBkaWdpdFxuICAgICAgICAgIHplcm9zID0gXCJcIjtcbiAgICAgICAgICB0ID0gdCAlIEQ7XG4gICAgICAgIH0gZWxzZSBpZiAobiA+IDEpIHsgLy8gQWRkIHplcm9zIHRvIHRoZSB6ZXJvIGJ1ZmZlclxuICAgICAgICAgIHplcm9zKz0gXCIwXCI7XG4gICAgICAgIH0gZWxzZSBpZiAocmV0W25dKSB7IC8vIElmIGJlZm9yZSBjb21tYSwgYWRkIHplcm8gb25seSBpZiBhbHJlYWR5IHNvbWV0aGluZyB3YXMgYWRkZWRcbiAgICAgICAgICByZXRbbl0rPSBcIjBcIjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiBpdCdzIGVtcHR5LCBpdCdzIGEgbGVhZGluZyB6ZXJvIG9ubHlcbiAgICAgIHJldFswXSs9IHJldFsxXSB8fCBcIjBcIjtcblxuICAgICAgLy8gSWYgdGhlcmUgaXMgc29tZXRoaW5nIGFmdGVyIHRoZSBjb21tYSwgYWRkIHRoZSBjb21tYSBzaWduXG4gICAgICBpZiAocmV0WzJdKSB7XG4gICAgICAgIHJldHVybiByZXRbMF0gKyBcIi5cIiArIHJldFsyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXRbMF07XG4gICAgfVxuICB9O1xuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lW1wiYW1kXCJdKSB7XG4gICAgZGVmaW5lKFtdLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBGcmFjdGlvbjtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuICAgIG1vZHVsZVtcImV4cG9ydHNcIl0gPSBGcmFjdGlvbjtcbiAgfSBlbHNlIHtcbiAgICByb290WydGcmFjdGlvbiddID0gRnJhY3Rpb247XG4gIH1cblxufSkodGhpcyk7XG4iLCJmdW5jdGlvbiBFICgpIHtcblx0Ly8gS2VlcCB0aGlzIGVtcHR5IHNvIGl0J3MgZWFzaWVyIHRvIGluaGVyaXQgZnJvbVxuICAvLyAodmlhIGh0dHBzOi8vZ2l0aHViLmNvbS9saXBzbWFjayBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9zY290dGNvcmdhbi90aW55LWVtaXR0ZXIvaXNzdWVzLzMpXG59XG5cbkUucHJvdG90eXBlID0ge1xuXHRvbjogZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrLCBjdHgpIHtcbiAgICB2YXIgZSA9IHRoaXMuZSB8fCAodGhpcy5lID0ge30pO1xuXG4gICAgKGVbbmFtZV0gfHwgKGVbbmFtZV0gPSBbXSkpLnB1c2goe1xuICAgICAgZm46IGNhbGxiYWNrLFxuICAgICAgY3R4OiBjdHhcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIG9uY2U6IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaywgY3R4KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGZ1bmN0aW9uIGxpc3RlbmVyICgpIHtcbiAgICAgIHNlbGYub2ZmKG5hbWUsIGxpc3RlbmVyKTtcbiAgICAgIGNhbGxiYWNrLmFwcGx5KGN0eCwgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgbGlzdGVuZXIuXyA9IGNhbGxiYWNrXG4gICAgcmV0dXJuIHRoaXMub24obmFtZSwgbGlzdGVuZXIsIGN0eCk7XG4gIH0sXG5cbiAgZW1pdDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgZGF0YSA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICB2YXIgZXZ0QXJyID0gKCh0aGlzLmUgfHwgKHRoaXMuZSA9IHt9KSlbbmFtZV0gfHwgW10pLnNsaWNlKCk7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSBldnRBcnIubGVuZ3RoO1xuXG4gICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGV2dEFycltpXS5mbi5hcHBseShldnRBcnJbaV0uY3R4LCBkYXRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBvZmY6IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaykge1xuICAgIHZhciBlID0gdGhpcy5lIHx8ICh0aGlzLmUgPSB7fSk7XG4gICAgdmFyIGV2dHMgPSBlW25hbWVdO1xuICAgIHZhciBsaXZlRXZlbnRzID0gW107XG5cbiAgICBpZiAoZXZ0cyAmJiBjYWxsYmFjaykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGV2dHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGV2dHNbaV0uZm4gIT09IGNhbGxiYWNrICYmIGV2dHNbaV0uZm4uXyAhPT0gY2FsbGJhY2spXG4gICAgICAgICAgbGl2ZUV2ZW50cy5wdXNoKGV2dHNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlbW92ZSBldmVudCBmcm9tIHF1ZXVlIHRvIHByZXZlbnQgbWVtb3J5IGxlYWtcbiAgICAvLyBTdWdnZXN0ZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL2xhemRcbiAgICAvLyBSZWY6IGh0dHBzOi8vZ2l0aHViLmNvbS9zY290dGNvcmdhbi90aW55LWVtaXR0ZXIvY29tbWl0L2M2ZWJmYWE5YmM5NzNiMzNkMTEwYTg0YTMwNzc0MmI3Y2Y5NGM5NTMjY29tbWl0Y29tbWVudC01MDI0OTEwXG5cbiAgICAobGl2ZUV2ZW50cy5sZW5ndGgpXG4gICAgICA/IGVbbmFtZV0gPSBsaXZlRXZlbnRzXG4gICAgICA6IGRlbGV0ZSBlW25hbWVdO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRTtcbiIsIi8qKlxuICogdHlwZWQtZnVuY3Rpb25cbiAqXG4gKiBUeXBlIGNoZWNraW5nIGZvciBKYXZhU2NyaXB0IGZ1bmN0aW9uc1xuICpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9qb3NkZWpvbmcvdHlwZWQtZnVuY3Rpb25cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4oZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICBkZWZpbmUoW10sIGZhY3RvcnkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgIC8vIE9sZE5vZGUuIERvZXMgbm90IHdvcmsgd2l0aCBzdHJpY3QgQ29tbW9uSlMsIGJ1dFxuICAgIC8vIG9ubHkgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxuICAgIC8vIGxpa2UgT2xkTm9kZS5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBCcm93c2VyIGdsb2JhbHMgKHJvb3QgaXMgd2luZG93KVxuICAgIHdpbmRvdy50eXBlZCA9IGZhY3RvcnkoKTtcbiAgfVxufShmdW5jdGlvbiAoKSB7XG4gIC8vIGZhY3RvcnkgZnVuY3Rpb24gdG8gY3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHR5cGVkLWZ1bmN0aW9uXG4gIC8vIFRPRE86IGFsbG93IHBhc3NpbmcgY29uZmlndXJhdGlvbiwgdHlwZXMsIHRlc3RzIHZpYSB0aGUgZmFjdG9yeSBmdW5jdGlvblxuICBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgLyoqXG4gICAgICogR2V0IGEgdHlwZSB0ZXN0IGZ1bmN0aW9uIGZvciBhIHNwZWNpZmljIGRhdGEgdHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lICAgICAgICAgICAgICAgICAgIE5hbWUgb2YgYSBkYXRhIHR5cGUgbGlrZSAnbnVtYmVyJyBvciAnc3RyaW5nJ1xuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbihvYmo6ICopIDogYm9vbGVhbn0gIFJldHVybnMgYSB0eXBlIHRlc3RpbmcgZnVuY3Rpb24uXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhyb3dzIGFuIGVycm9yIGZvciBhbiB1bmtub3duIHR5cGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0VHlwZVRlc3QobmFtZSkge1xuICAgICAgdmFyIHRlc3Q7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkLnR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHR5cGVkLnR5cGVzW2ldO1xuICAgICAgICBpZiAoZW50cnkubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgIHRlc3QgPSBlbnRyeS50ZXN0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdGVzdCkge1xuICAgICAgICB2YXIgaGludDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHR5cGVkLnR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZW50cnkgPSB0eXBlZC50eXBlc1tpXTtcbiAgICAgICAgICBpZiAoZW50cnkubmFtZS50b0xvd2VyQ2FzZSgpID09IG5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgaGludCA9IGVudHJ5Lm5hbWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdHlwZSBcIicgKyBuYW1lICsgJ1wiJyArXG4gICAgICAgICAgICAoaGludCA/ICgnLiBEaWQgeW91IG1lYW4gXCInICsgaGludCArICdcIj8nKSA6ICcnKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGVzdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgZnVuY3Rpb24gbmFtZSBmcm9tIGEgc2V0IG9mIGZ1bmN0aW9ucywgYW5kIGNoZWNrXG4gICAgICogd2hldGhlciB0aGUgbmFtZSBvZiBhbGwgZnVuY3Rpb25zIG1hdGNoIChpZiBnaXZlbilcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxmdW5jdGlvbj59IGZuc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE5hbWUgKGZucykge1xuICAgICAgdmFyIG5hbWUgPSAnJztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGZuID0gZm5zW2ldO1xuXG4gICAgICAgIC8vIG1lcmdlIGZ1bmN0aW9uIG5hbWVcbiAgICAgICAgaWYgKGZuLm5hbWUgIT0gJycpIHtcbiAgICAgICAgICBpZiAobmFtZSA9PSAnJykge1xuICAgICAgICAgICAgbmFtZSA9IGZuLm5hbWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKG5hbWUgIT0gZm4ubmFtZSkge1xuICAgICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignRnVuY3Rpb24gbmFtZXMgZG8gbm90IG1hdGNoIChleHBlY3RlZDogJyArIG5hbWUgKyAnLCBhY3R1YWw6ICcgKyBmbi5uYW1lICsgJyknKTtcbiAgICAgICAgICAgIGVyci5kYXRhID0ge1xuICAgICAgICAgICAgICBhY3R1YWw6IGZuLm5hbWUsXG4gICAgICAgICAgICAgIGV4cGVjdGVkOiBuYW1lXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gQXJndW1lbnRzRXJyb3IuIENyZWF0ZXMgbWVzc2FnZXMgbGlrZTpcbiAgICAgKlxuICAgICAqICAgVW5leHBlY3RlZCB0eXBlIG9mIGFyZ3VtZW50IChleHBlY3RlZDogLi4uLCBhY3R1YWw6IC4uLiwgaW5kZXg6IC4uLilcbiAgICAgKiAgIFRvbyBmZXcgYXJndW1lbnRzIChleHBlY3RlZDogLi4uLCBpbmRleDogLi4uKVxuICAgICAqICAgVG9vIG1hbnkgYXJndW1lbnRzIChleHBlY3RlZDogLi4uLCBhY3R1YWw6IC4uLilcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmbiAgICAgICAgIEZ1bmN0aW9uIG5hbWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXJnQ291bnQgICBOdW1iZXIgb2YgYXJndW1lbnRzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4ICAgICAgQ3VycmVudCBhcmd1bWVudCBpbmRleFxuICAgICAqIEBwYXJhbSB7Kn0gYWN0dWFsICAgICAgICAgIEN1cnJlbnQgYXJndW1lbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2V4cGVjdGVkXSBBbiBvcHRpb25hbCwgY29tbWEgc2VwYXJhdGVkIHN0cmluZyB3aXRoXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQgdHlwZXMgb24gZ2l2ZW4gaW5kZXhcbiAgICAgKiBAZXh0ZW5kcyBFcnJvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUVycm9yKGZuLCBhcmdDb3VudCwgaW5kZXgsIGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgICAgIHZhciBhY3R1YWxUeXBlID0gZ2V0VHlwZU9mKGFjdHVhbCk7XG4gICAgICB2YXIgX2V4cGVjdGVkID0gZXhwZWN0ZWQgPyBleHBlY3RlZC5zcGxpdCgnLCcpIDogbnVsbDtcbiAgICAgIHZhciBfZm4gPSAoZm4gfHwgJ3VubmFtZWQnKTtcbiAgICAgIHZhciBhbnlUeXBlID0gX2V4cGVjdGVkICYmIGNvbnRhaW5zKF9leHBlY3RlZCwgJ2FueScpO1xuICAgICAgdmFyIG1lc3NhZ2U7XG4gICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgZm46IGZuLFxuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgICBleHBlY3RlZDogX2V4cGVjdGVkXG4gICAgICB9O1xuXG4gICAgICBpZiAoX2V4cGVjdGVkKSB7XG4gICAgICAgIGlmIChhcmdDb3VudCA+IGluZGV4ICYmICFhbnlUeXBlKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0eXBlXG4gICAgICAgICAgbWVzc2FnZSA9ICdVbmV4cGVjdGVkIHR5cGUgb2YgYXJndW1lbnQgaW4gZnVuY3Rpb24gJyArIF9mbiArXG4gICAgICAgICAgICAgICcgKGV4cGVjdGVkOiAnICsgX2V4cGVjdGVkLmpvaW4oJyBvciAnKSArICcsIGFjdHVhbDogJyArIGFjdHVhbFR5cGUgKyAnLCBpbmRleDogJyArIGluZGV4ICsgJyknO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIHRvbyBmZXcgYXJndW1lbnRzXG4gICAgICAgICAgbWVzc2FnZSA9ICdUb28gZmV3IGFyZ3VtZW50cyBpbiBmdW5jdGlvbiAnICsgX2ZuICtcbiAgICAgICAgICAgICAgJyAoZXhwZWN0ZWQ6ICcgKyBfZXhwZWN0ZWQuam9pbignIG9yICcpICsgJywgaW5kZXg6ICcgKyBpbmRleCArICcpJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIHRvbyBtYW55IGFyZ3VtZW50c1xuICAgICAgICBtZXNzYWdlID0gJ1RvbyBtYW55IGFyZ3VtZW50cyBpbiBmdW5jdGlvbiAnICsgX2ZuICtcbiAgICAgICAgICAgICcgKGV4cGVjdGVkOiAnICsgaW5kZXggKyAnLCBhY3R1YWw6ICcgKyBhcmdDb3VudCArICcpJ1xuICAgICAgfVxuXG4gICAgICB2YXIgZXJyID0gbmV3IFR5cGVFcnJvcihtZXNzYWdlKTtcbiAgICAgIGVyci5kYXRhID0gZGF0YTtcbiAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29sbGVjdGlvbiB3aXRoIGZ1bmN0aW9uIHJlZmVyZW5jZXMgKGxvY2FsIHNob3J0Y3V0cyB0byBmdW5jdGlvbnMpXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lPSdyZWZzJ10gIE9wdGlvbmFsIG5hbWUgZm9yIHRoZSByZWZzLCB1c2VkIHRvIGdlbmVyYXRlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEphdmFTY3JpcHQgY29kZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlZnMobmFtZSkge1xuICAgICAgdGhpcy5uYW1lID0gbmFtZSB8fCAncmVmcyc7XG4gICAgICB0aGlzLmNhdGVnb3JpZXMgPSB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBmdW5jdGlvbiByZWZlcmVuY2UuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NhdGVnb3J5PSdmbiddICAgIEEgZnVuY3Rpb24gY2F0ZWdvcnksIGxpa2UgJ2ZuJyBvciAnc2lnbmF0dXJlJ1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGZ1bmN0aW9uIG5hbWUsIGZvciBleGFtcGxlICdmbjAnIG9yICdzaWduYXR1cmUyJ1xuICAgICAqL1xuICAgIFJlZnMucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChmbiwgY2F0ZWdvcnkpIHtcbiAgICAgIHZhciBjYXQgPSBjYXRlZ29yeSB8fCAnZm4nO1xuICAgICAgaWYgKCF0aGlzLmNhdGVnb3JpZXNbY2F0XSkgdGhpcy5jYXRlZ29yaWVzW2NhdF0gPSBbXTtcblxuICAgICAgdmFyIGluZGV4ID0gdGhpcy5jYXRlZ29yaWVzW2NhdF0uaW5kZXhPZihmbik7XG4gICAgICBpZiAoaW5kZXggPT0gLTEpIHtcbiAgICAgICAgaW5kZXggPSB0aGlzLmNhdGVnb3JpZXNbY2F0XS5sZW5ndGg7XG4gICAgICAgIHRoaXMuY2F0ZWdvcmllc1tjYXRdLnB1c2goZm4pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2F0ICsgaW5kZXg7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBjb2RlIGxpbmVzIGZvciBhbGwgZnVuY3Rpb24gcmVmZXJlbmNlc1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvZGUgY29udGFpbmluZyBhbGwgZnVuY3Rpb24gcmVmZXJlbmNlc1xuICAgICAqL1xuICAgIFJlZnMucHJvdG90eXBlLnRvQ29kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjb2RlID0gW107XG4gICAgICB2YXIgcGF0aCA9IHRoaXMubmFtZSArICcuY2F0ZWdvcmllcyc7XG4gICAgICB2YXIgY2F0ZWdvcmllcyA9IHRoaXMuY2F0ZWdvcmllcztcblxuICAgICAgZm9yICh2YXIgY2F0IGluIGNhdGVnb3JpZXMpIHtcbiAgICAgICAgaWYgKGNhdGVnb3JpZXMuaGFzT3duUHJvcGVydHkoY2F0KSkge1xuICAgICAgICAgIHZhciBjYXRlZ29yeSA9IGNhdGVnb3JpZXNbY2F0XTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2F0ZWdvcnkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvZGUucHVzaCgndmFyICcgKyBjYXQgKyBpICsgJyA9ICcgKyBwYXRoICsgJ1tcXCcnICsgY2F0ICsgJ1xcJ11bJyArIGkgKyAnXTsnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvZGUuam9pbignXFxuJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gcGFyYW1ldGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBzdHJpbmdbXSB8IFBhcmFtfSB0eXBlcyAgICBBIHBhcmFtZXRlciB0eXBlIGxpa2UgJ3N0cmluZycsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbnVtYmVyIHwgYm9vbGVhbidcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt2YXJBcmdzPWZhbHNlXSAgICAgICAgICAgIFZhcmlhYmxlIGFyZ3VtZW50cyBpZiB0cnVlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gUGFyYW0odHlwZXMsIHZhckFyZ3MpIHtcbiAgICAgIC8vIHBhcnNlIHRoZSB0eXBlcywgY2FuIGJlIGEgc3RyaW5nIHdpdGggdHlwZXMgc2VwYXJhdGVkIGJ5IHBpcGUgY2hhcmFjdGVycyB8XG4gICAgICBpZiAodHlwZW9mIHR5cGVzID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBwYXJzZSB2YXJpYWJsZSBhcmd1bWVudHMgb3BlcmF0b3IgKGVsbGlwc2VzICcuLi5udW1iZXInKVxuICAgICAgICB2YXIgX3R5cGVzID0gdHlwZXMudHJpbSgpO1xuICAgICAgICB2YXIgX3ZhckFyZ3MgPSBfdHlwZXMuc3Vic3RyKDAsIDMpID09PSAnLi4uJztcbiAgICAgICAgaWYgKF92YXJBcmdzKSB7XG4gICAgICAgICAgX3R5cGVzID0gX3R5cGVzLnN1YnN0cigzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3R5cGVzID09PSAnJykge1xuICAgICAgICAgIHRoaXMudHlwZXMgPSBbJ2FueSddO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRoaXMudHlwZXMgPSBfdHlwZXMuc3BsaXQoJ3wnKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMudHlwZXNbaV0gPSB0aGlzLnR5cGVzW2ldLnRyaW0oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodHlwZXMpKSB7XG4gICAgICAgIHRoaXMudHlwZXMgPSB0eXBlcztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVzIGluc3RhbmNlb2YgUGFyYW0pIHtcbiAgICAgICAgcmV0dXJuIHR5cGVzLmNsb25lKCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdHJpbmcgb3IgQXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgIH1cblxuICAgICAgLy8gY2FuIGhvbGQgYSB0eXBlIHRvIHdoaWNoIHRvIGNvbnZlcnQgd2hlbiBoYW5kbGluZyB0aGlzIHBhcmFtZXRlclxuICAgICAgdGhpcy5jb252ZXJzaW9ucyA9IFtdO1xuICAgICAgLy8gVE9ETzogaW1wbGVtZW50IGJldHRlciBBUEkgZm9yIGNvbnZlcnNpb25zLCBiZSBhYmxlIHRvIGFkZCBjb252ZXJzaW9ucyB2aWEgY29uc3RydWN0b3IgKHN1cHBvcnQgYSBuZXcgdHlwZSBPYmplY3Q/KVxuXG4gICAgICAvLyB2YXJpYWJsZSBhcmd1bWVudHNcbiAgICAgIHRoaXMudmFyQXJncyA9IF92YXJBcmdzIHx8IHZhckFyZ3MgfHwgZmFsc2U7XG5cbiAgICAgIC8vIGNoZWNrIGZvciBhbnkgdHlwZSBhcmd1bWVudHNcbiAgICAgIHRoaXMuYW55VHlwZSA9IHRoaXMudHlwZXMuaW5kZXhPZignYW55JykgIT09IC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9yZGVyIFBhcmFtc1xuICAgICAqIGFueSB0eXBlICgnYW55Jykgd2lsbCBiZSBvcmRlcmVkIGxhc3QsIGFuZCBvYmplY3QgYXMgc2Vjb25kIGxhc3QgKGFzIG90aGVyXG4gICAgICogdHlwZXMgbWF5IGJlIGFuIG9iamVjdCBhcyB3ZWxsLCBsaWtlIEFycmF5KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW19IGFcbiAgICAgKiBAcGFyYW0ge1BhcmFtfSBiXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyAxIGlmIGEgPiBiLCAtMSBpZiBhIDwgYiwgYW5kIGVsc2UgMC5cbiAgICAgKi9cbiAgICBQYXJhbS5jb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIC8vIFRPRE86IHNpbXBsaWZ5IHBhcmFtZXRlciBjb21wYXJpc29uLCBpdCdzIGEgbWVzc1xuICAgICAgaWYgKGEuYW55VHlwZSkgcmV0dXJuIDE7XG4gICAgICBpZiAoYi5hbnlUeXBlKSByZXR1cm4gLTE7XG5cbiAgICAgIGlmIChjb250YWlucyhhLnR5cGVzLCAnT2JqZWN0JykpIHJldHVybiAxO1xuICAgICAgaWYgKGNvbnRhaW5zKGIudHlwZXMsICdPYmplY3QnKSkgcmV0dXJuIC0xO1xuXG4gICAgICBpZiAoYS5oYXNDb252ZXJzaW9ucygpKSB7XG4gICAgICAgIGlmIChiLmhhc0NvbnZlcnNpb25zKCkpIHtcbiAgICAgICAgICB2YXIgaSwgYWMsIGJjO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGEuY29udmVyc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhLmNvbnZlcnNpb25zW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgYWMgPSBhLmNvbnZlcnNpb25zW2ldO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYi5jb252ZXJzaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGIuY29udmVyc2lvbnNbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBiYyA9IGIuY29udmVyc2lvbnNbaV07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0eXBlZC5jb252ZXJzaW9ucy5pbmRleE9mKGFjKSAtIHR5cGVkLmNvbnZlcnNpb25zLmluZGV4T2YoYmMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKGIuaGFzQ29udmVyc2lvbnMoKSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBib3RoIHBhcmFtcyBoYXZlIG5vIGNvbnZlcnNpb25zXG4gICAgICAgICAgdmFyIGFpLCBiaTtcblxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0eXBlZC50eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHR5cGVkLnR5cGVzW2ldLm5hbWUgPT09IGEudHlwZXNbMF0pIHtcbiAgICAgICAgICAgICAgYWkgPSBpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdHlwZWQudHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0eXBlZC50eXBlc1tpXS5uYW1lID09PSBiLnR5cGVzWzBdKSB7XG4gICAgICAgICAgICAgIGJpID0gaTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGFpIC0gYmk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGVzdCB3aGV0aGVyIHRoaXMgcGFyYW1ldGVycyB0eXBlcyBvdmVybGFwIGFuIG90aGVyIHBhcmFtZXRlcnMgdHlwZXMuXG4gICAgICogQHBhcmFtIHtQYXJhbX0gb3RoZXJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgd2hlbiB0aGVyZSBhcmUgY29uZmxpY3RpbmcgdHlwZXNcbiAgICAgKi9cbiAgICBQYXJhbS5wcm90b3R5cGUub3ZlcmxhcHBpbmcgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoY29udGFpbnMob3RoZXIudHlwZXMsIHRoaXMudHlwZXNbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgY2xvbmUgb2YgdGhpcyBwYXJhbVxuICAgICAqIEByZXR1cm5zIHtQYXJhbX0gUmV0dXJucyBhIGNsb25lZCB2ZXJzaW9uIG9mIHRoaXMgcGFyYW1cbiAgICAgKi9cbiAgICBQYXJhbS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGFyYW0gPSBuZXcgUGFyYW0odGhpcy50eXBlcy5zbGljZSgpLCB0aGlzLnZhckFyZ3MpO1xuICAgICAgcGFyYW0uY29udmVyc2lvbnMgPSB0aGlzLmNvbnZlcnNpb25zLnNsaWNlKCk7XG4gICAgICByZXR1cm4gcGFyYW07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRlc3Qgd2hldGhlciB0aGlzIHBhcmFtZXRlciBjb250YWlucyBjb252ZXJzaW9uc1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIHBhcmFtZXRlciBjb250YWlucyBvbmUgb3JcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGUgY29udmVyc2lvbnMuXG4gICAgICovXG4gICAgUGFyYW0ucHJvdG90eXBlLmhhc0NvbnZlcnNpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udmVyc2lvbnMubGVuZ3RoID4gMDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGVzdHMgd2hldGhlciB0aGlzIHBhcmFtZXRlcnMgY29udGFpbnMgYW55IG9mIHRoZSBwcm92aWRlZCB0eXBlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlcyAgQSBNYXAgd2l0aCB0eXBlcywgbGlrZSB7J251bWJlcic6IHRydWV9XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59ICAgICBSZXR1cm5zIHRydWUgd2hlbiB0aGUgcGFyYW1ldGVyIGNvbnRhaW5zIGFueVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgb2YgdGhlIHByb3ZpZGVkIHR5cGVzXG4gICAgICovXG4gICAgUGFyYW0ucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKHR5cGVzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHR5cGVzW3RoaXMudHlwZXNbaV1dKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcGFyYW1zIHR5cGVzLCBsaWtlICdzdHJpbmcnIG9yXG4gICAgICogJ251bWJlciB8IGJvb2xlYW4nIG9yICcuLi5udW1iZXInXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbdG9Db252ZXJzaW9uXSAgIElmIHRydWUsIHRoZSByZXR1cm5lZCB0eXBlcyBzdHJpbmdcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbnMgdGhlIHR5cGVzIHdoZXJlIHRoZSBwYXJhbWV0ZXJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBjb252ZXJ0IHRvLiBJZiBmYWxzZSAoZGVmYXVsdClcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIFwiZnJvbVwiIHR5cGVzIGFyZSByZXR1cm5lZFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgUGFyYW0ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKHRvQ29udmVyc2lvbikge1xuICAgICAgdmFyIHR5cGVzID0gW107XG4gICAgICB2YXIga2V5cyA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvbnZlcnNpb24gPSB0aGlzLmNvbnZlcnNpb25zW2ldO1xuICAgICAgICB2YXIgdHlwZSA9IHRvQ29udmVyc2lvbiAmJiBjb252ZXJzaW9uID8gY29udmVyc2lvbi50byA6IHRoaXMudHlwZXNbaV07XG4gICAgICAgIGlmICghKHR5cGUgaW4ga2V5cykpIHtcbiAgICAgICAgICBrZXlzW3R5cGVdID0gdHJ1ZTtcbiAgICAgICAgICB0eXBlcy5wdXNoKHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAodGhpcy52YXJBcmdzID8gJy4uLicgOiAnJykgKyB0eXBlcy5qb2luKCd8Jyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gc2lnbmF0dXJlXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBzdHJpbmdbXSB8IFBhcmFtW119IHBhcmFtc1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5IHdpdGggdGhlIHR5cGUocykgb2YgZWFjaCBwYXJhbWV0ZXIsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgb3IgYSBjb21tYSBzZXBhcmF0ZWQgc3RyaW5nIHdpdGggdHlwZXNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgICBUaGUgYWN0dWFsIGZ1bmN0aW9uXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2lnbmF0dXJlKHBhcmFtcywgZm4pIHtcbiAgICAgIHZhciBfcGFyYW1zO1xuICAgICAgaWYgKHR5cGVvZiBwYXJhbXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIF9wYXJhbXMgPSAocGFyYW1zICE9PSAnJykgPyBwYXJhbXMuc3BsaXQoJywnKSA6IFtdO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwYXJhbXMpKSB7XG4gICAgICAgIF9wYXJhbXMgPSBwYXJhbXM7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdHJpbmcgb3IgQXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wYXJhbXMgPSBuZXcgQXJyYXkoX3BhcmFtcy5sZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJhbSA9IG5ldyBQYXJhbShfcGFyYW1zW2ldKTtcbiAgICAgICAgdGhpcy5wYXJhbXNbaV0gPSBwYXJhbTtcbiAgICAgICAgaWYgKGkgPT09IF9wYXJhbXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIC8vIHRoZSBsYXN0IGFyZ3VtZW50XG4gICAgICAgICAgdGhpcy52YXJBcmdzID0gcGFyYW0udmFyQXJncztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBub24tbGFzdCBhcmd1bWVudFxuICAgICAgICAgIGlmIChwYXJhbS52YXJBcmdzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1VuZXhwZWN0ZWQgdmFyaWFibGUgYXJndW1lbnRzIG9wZXJhdG9yIFwiLi4uXCInKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5mbiA9IGZuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGNsb25lIG9mIHRoaXMgc2lnbmF0dXJlXG4gICAgICogQHJldHVybnMge1NpZ25hdHVyZX0gUmV0dXJucyBhIGNsb25lZCB2ZXJzaW9uIG9mIHRoaXMgc2lnbmF0dXJlXG4gICAgICovXG4gICAgU2lnbmF0dXJlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHRoaXMucGFyYW1zLnNsaWNlKCksIHRoaXMuZm4pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFeHBhbmQgYSBzaWduYXR1cmU6IHNwbGl0IHBhcmFtcyB3aXRoIHVuaW9uIHR5cGVzIGluIHNlcGFyYXRlIHNpZ25hdHVyZXNcbiAgICAgKiBGb3IgZXhhbXBsZSBzcGxpdCBhIFNpZ25hdHVyZSBcInN0cmluZyB8IG51bWJlclwiIGludG8gdHdvIHNpZ25hdHVyZXMuXG4gICAgICogQHJldHVybiB7U2lnbmF0dXJlW119IFJldHVybnMgYW4gYXJyYXkgd2l0aCBzaWduYXR1cmVzIChhdCBsZWFzdCBvbmUpXG4gICAgICovXG4gICAgU2lnbmF0dXJlLnByb3RvdHlwZS5leHBhbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2lnbmF0dXJlcyA9IFtdO1xuXG4gICAgICBmdW5jdGlvbiByZWN1cnNlKHNpZ25hdHVyZSwgcGF0aCkge1xuICAgICAgICBpZiAocGF0aC5sZW5ndGggPCBzaWduYXR1cmUucGFyYW1zLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBpLCBuZXdQYXJhbSwgY29udmVyc2lvbjtcblxuICAgICAgICAgIHZhciBwYXJhbSA9IHNpZ25hdHVyZS5wYXJhbXNbcGF0aC5sZW5ndGhdO1xuICAgICAgICAgIGlmIChwYXJhbS52YXJBcmdzKSB7XG4gICAgICAgICAgICAvLyBhIHZhcmlhYmxlIGFyZ3VtZW50LiBkbyBub3Qgc3BsaXQgdGhlIHR5cGVzIGluIHRoZSBwYXJhbWV0ZXJcbiAgICAgICAgICAgIG5ld1BhcmFtID0gcGFyYW0uY2xvbmUoKTtcblxuICAgICAgICAgICAgLy8gYWRkIGNvbnZlcnNpb25zIHRvIHRoZSBwYXJhbWV0ZXJcbiAgICAgICAgICAgIC8vIHJlY3Vyc2UgZm9yIGFsbCBjb252ZXJzaW9uc1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHR5cGVkLmNvbnZlcnNpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGNvbnZlcnNpb24gPSB0eXBlZC5jb252ZXJzaW9uc1tpXTtcbiAgICAgICAgICAgICAgaWYgKCFjb250YWlucyhwYXJhbS50eXBlcywgY29udmVyc2lvbi5mcm9tKSAmJiBjb250YWlucyhwYXJhbS50eXBlcywgY29udmVyc2lvbi50bykpIHtcbiAgICAgICAgICAgICAgICB2YXIgaiA9IG5ld1BhcmFtLnR5cGVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBuZXdQYXJhbS50eXBlc1tqXSA9IGNvbnZlcnNpb24uZnJvbTtcbiAgICAgICAgICAgICAgICBuZXdQYXJhbS5jb252ZXJzaW9uc1tqXSA9IGNvbnZlcnNpb247XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVjdXJzZShzaWduYXR1cmUsIHBhdGguY29uY2F0KG5ld1BhcmFtKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gc3BsaXQgZWFjaCB0eXBlIGluIHRoZSBwYXJhbWV0ZXJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXJhbS50eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICByZWN1cnNlKHNpZ25hdHVyZSwgcGF0aC5jb25jYXQobmV3IFBhcmFtKHBhcmFtLnR5cGVzW2ldKSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByZWN1cnNlIGZvciBhbGwgY29udmVyc2lvbnNcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0eXBlZC5jb252ZXJzaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBjb252ZXJzaW9uID0gdHlwZWQuY29udmVyc2lvbnNbaV07XG4gICAgICAgICAgICAgIGlmICghY29udGFpbnMocGFyYW0udHlwZXMsIGNvbnZlcnNpb24uZnJvbSkgJiYgY29udGFpbnMocGFyYW0udHlwZXMsIGNvbnZlcnNpb24udG8pKSB7XG4gICAgICAgICAgICAgICAgbmV3UGFyYW0gPSBuZXcgUGFyYW0oY29udmVyc2lvbi5mcm9tKTtcbiAgICAgICAgICAgICAgICBuZXdQYXJhbS5jb252ZXJzaW9uc1swXSA9IGNvbnZlcnNpb247XG4gICAgICAgICAgICAgICAgcmVjdXJzZShzaWduYXR1cmUsIHBhdGguY29uY2F0KG5ld1BhcmFtKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc2lnbmF0dXJlcy5wdXNoKG5ldyBTaWduYXR1cmUocGF0aCwgc2lnbmF0dXJlLmZuKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVjdXJzZSh0aGlzLCBbXSk7XG5cbiAgICAgIHJldHVybiBzaWduYXR1cmVzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb21wYXJlIHR3byBzaWduYXR1cmVzLlxuICAgICAqXG4gICAgICogV2hlbiB0d28gcGFyYW1zIGFyZSBlcXVhbCBhbmQgY29udGFpbiBjb252ZXJzaW9ucywgdGhleSB3aWxsIGJlIHNvcnRlZFxuICAgICAqIGJ5IGxvd2VzdCBpbmRleCBvZiB0aGUgZmlyc3QgY29udmVyc2lvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1NpZ25hdHVyZX0gYVxuICAgICAqIEBwYXJhbSB7U2lnbmF0dXJlfSBiXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyAxIGlmIGEgPiBiLCAtMSBpZiBhIDwgYiwgYW5kIGVsc2UgMC5cbiAgICAgKi9cbiAgICBTaWduYXR1cmUuY29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICBpZiAoYS5wYXJhbXMubGVuZ3RoID4gYi5wYXJhbXMubGVuZ3RoKSByZXR1cm4gMTtcbiAgICAgIGlmIChhLnBhcmFtcy5sZW5ndGggPCBiLnBhcmFtcy5sZW5ndGgpIHJldHVybiAtMTtcblxuICAgICAgLy8gY291bnQgdGhlIG51bWJlciBvZiBjb252ZXJzaW9uc1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gYS5wYXJhbXMubGVuZ3RoOyAvLyBhIGFuZCBiIGhhdmUgZXF1YWwgYW1vdW50IG9mIHBhcmFtc1xuICAgICAgdmFyIGFjID0gMDtcbiAgICAgIHZhciBiYyA9IDA7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGEucGFyYW1zW2ldLmhhc0NvbnZlcnNpb25zKCkpIGFjKys7XG4gICAgICAgIGlmIChiLnBhcmFtc1tpXS5oYXNDb252ZXJzaW9ucygpKSBiYysrO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWMgPiBiYykgcmV0dXJuIDE7XG4gICAgICBpZiAoYWMgPCBiYykgcmV0dXJuIC0xO1xuXG4gICAgICAvLyBjb21wYXJlIHRoZSBvcmRlciBwZXIgcGFyYW1ldGVyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYS5wYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNtcCA9IFBhcmFtLmNvbXBhcmUoYS5wYXJhbXNbaV0sIGIucGFyYW1zW2ldKTtcbiAgICAgICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgICAgIHJldHVybiBjbXA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRlc3Qgd2hldGhlciBhbnkgb2YgdGhlIHNpZ25hdHVyZXMgcGFyYW1ldGVycyBoYXMgY29udmVyc2lvbnNcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgd2hlbiBhbnkgb2YgdGhlIHBhcmFtZXRlcnMgY29udGFpbnNcbiAgICAgKiAgICAgICAgICAgICAgICAgICBjb252ZXJzaW9ucy5cbiAgICAgKi9cbiAgICBTaWduYXR1cmUucHJvdG90eXBlLmhhc0NvbnZlcnNpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5wYXJhbXNbaV0uaGFzQ29udmVyc2lvbnMoKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRlc3Qgd2hldGhlciB0aGlzIHNpZ25hdHVyZSBzaG91bGQgYmUgaWdub3JlZC5cbiAgICAgKiBDaGVja3Mgd2hldGhlciBhbnkgb2YgdGhlIHBhcmFtZXRlcnMgY29udGFpbnMgYSB0eXBlIGxpc3RlZCBpblxuICAgICAqIHR5cGVkLmlnbm9yZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSB3aGVuIHRoZSBzaWduYXR1cmUgc2hvdWxkIGJlIGlnbm9yZWRcbiAgICAgKi9cbiAgICBTaWduYXR1cmUucHJvdG90eXBlLmlnbm9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGNyZWF0ZSBhIG1hcCB3aXRoIGlnbm9yZWQgdHlwZXNcbiAgICAgIHZhciB0eXBlcyA9IHt9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlZC5pZ25vcmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdHlwZXNbdHlwZWQuaWdub3JlW2ldXSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHRlc3Qgd2hldGhlciBhbnkgb2YgdGhlIHBhcmFtZXRlcnMgY29udGFpbnMgdGhpcyB0eXBlXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5wYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMucGFyYW1zW2ldLmNvbnRhaW5zKHR5cGVzKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgdGhlIGNvZGUgdG8gaW52b2tlIHRoaXMgc2lnbmF0dXJlXG4gICAgICogQHBhcmFtIHtSZWZzfSByZWZzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgY29kZVxuICAgICAqL1xuICAgIFNpZ25hdHVyZS5wcm90b3R5cGUudG9Db2RlID0gZnVuY3Rpb24gKHJlZnMsIHByZWZpeCkge1xuICAgICAgdmFyIGNvZGUgPSBbXTtcblxuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkodGhpcy5wYXJhbXMubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcmFtID0gdGhpcy5wYXJhbXNbaV07XG4gICAgICAgIHZhciBjb252ZXJzaW9uID0gcGFyYW0uY29udmVyc2lvbnNbMF07XG4gICAgICAgIGlmIChwYXJhbS52YXJBcmdzKSB7XG4gICAgICAgICAgYXJnc1tpXSA9ICd2YXJBcmdzJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb252ZXJzaW9uKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IHJlZnMuYWRkKGNvbnZlcnNpb24uY29udmVydCwgJ2NvbnZlcnQnKSArICcoYXJnJyArIGkgKyAnKSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYXJnc1tpXSA9ICdhcmcnICsgaTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcmVmID0gdGhpcy5mbiA/IHJlZnMuYWRkKHRoaXMuZm4sICdzaWduYXR1cmUnKSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgcmV0dXJuIHByZWZpeCArICdyZXR1cm4gJyArIHJlZiArICcoJyArIGFyZ3Muam9pbignLCAnKSArICcpOyAvLyBzaWduYXR1cmU6ICcgKyB0aGlzLnBhcmFtcy5qb2luKCcsICcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29kZS5qb2luKCdcXG4nKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzaWduYXR1cmVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIFNpZ25hdHVyZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbXMuam9pbignLCAnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQSBncm91cCBvZiBzaWduYXR1cmVzIHdpdGggdGhlIHNhbWUgcGFyYW1ldGVyIG9uIGdpdmVuIGluZGV4XG4gICAgICogQHBhcmFtIHtQYXJhbVtdfSBwYXRoXG4gICAgICogQHBhcmFtIHtTaWduYXR1cmV9IFtzaWduYXR1cmVdXG4gICAgICogQHBhcmFtIHtOb2RlW119IGNoaWxkc1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE5vZGUocGF0aCwgc2lnbmF0dXJlLCBjaGlsZHMpIHtcbiAgICAgIHRoaXMucGF0aCA9IHBhdGggfHwgW107XG4gICAgICB0aGlzLnBhcmFtID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdIHx8IG51bGw7XG4gICAgICB0aGlzLnNpZ25hdHVyZSA9IHNpZ25hdHVyZSB8fCBudWxsO1xuICAgICAgdGhpcy5jaGlsZHMgPSBjaGlsZHMgfHwgW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgY29kZSBmb3IgdGhpcyBncm91cCBvZiBzaWduYXR1cmVzXG4gICAgICogQHBhcmFtIHtSZWZzfSByZWZzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeFxuICAgICAqIEBwYXJhbSB7Tm9kZSB8IHVuZGVmaW5lZH0gW2FueVR5cGVdICBTaWJsaW5nIG9mIHRoaXMgbm9kZSB3aXRoIGFueSB0eXBlIHBhcmFtZXRlclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvZGUgYXMgc3RyaW5nXG4gICAgICovXG4gICAgTm9kZS5wcm90b3R5cGUudG9Db2RlID0gZnVuY3Rpb24gKHJlZnMsIHByZWZpeCwgYW55VHlwZSkge1xuICAgICAgLy8gVE9ETzogc3BsaXQgdGhpcyBmdW5jdGlvbiBpbiBtdWx0aXBsZSBmdW5jdGlvbnMsIGl0J3MgdG9vIGxhcmdlXG4gICAgICB2YXIgY29kZSA9IFtdO1xuXG4gICAgICBpZiAodGhpcy5wYXJhbSkge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLnBhdGgubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIGNvbnZlcnNpb24gPSB0aGlzLnBhcmFtLmNvbnZlcnNpb25zWzBdO1xuICAgICAgICB2YXIgY29tbWVudCA9ICcvLyB0eXBlOiAnICsgKGNvbnZlcnNpb24gP1xuICAgICAgICAgICAgICAgIChjb252ZXJzaW9uLmZyb20gKyAnIChjb252ZXJ0IHRvICcgKyBjb252ZXJzaW9uLnRvICsgJyknKSA6XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJhbSk7XG5cbiAgICAgICAgLy8gbm9uLXJvb3Qgbm9kZSAocGF0aCBpcyBub24tZW1wdHkpXG4gICAgICAgIGlmICh0aGlzLnBhcmFtLnZhckFyZ3MpIHtcbiAgICAgICAgICBpZiAodGhpcy5wYXJhbS5hbnlUeXBlKSB7XG4gICAgICAgICAgICAvLyB2YXJpYWJsZSBhcmd1bWVudHMgd2l0aCBhbnkgdHlwZVxuICAgICAgICAgICAgY29kZS5wdXNoKHByZWZpeCArICdpZiAoYXJndW1lbnRzLmxlbmd0aCA+ICcgKyBpbmRleCArICcpIHsnKTtcbiAgICAgICAgICAgIGNvZGUucHVzaChwcmVmaXggKyAnICB2YXIgdmFyQXJncyA9IFtdOycpO1xuICAgICAgICAgICAgY29kZS5wdXNoKHByZWZpeCArICcgIGZvciAodmFyIGkgPSAnICsgaW5kZXggKyAnOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7Jyk7XG4gICAgICAgICAgICBjb2RlLnB1c2gocHJlZml4ICsgJyAgICB2YXJBcmdzLnB1c2goYXJndW1lbnRzW2ldKTsnKTtcbiAgICAgICAgICAgIGNvZGUucHVzaChwcmVmaXggKyAnICB9Jyk7XG4gICAgICAgICAgICBjb2RlLnB1c2godGhpcy5zaWduYXR1cmUudG9Db2RlKHJlZnMsIHByZWZpeCArICcgICcpKTtcbiAgICAgICAgICAgIGNvZGUucHVzaChwcmVmaXggKyAnfScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHZhcmlhYmxlIGFyZ3VtZW50cyB3aXRoIGEgZml4ZWQgdHlwZVxuICAgICAgICAgICAgdmFyIGdldFRlc3RzID0gZnVuY3Rpb24gKHR5cGVzLCBhcmcpIHtcbiAgICAgICAgICAgICAgdmFyIHRlc3RzID0gW107XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0ZXN0c1tpXSA9IHJlZnMuYWRkKGdldFR5cGVUZXN0KHR5cGVzW2ldKSwgJ3Rlc3QnKSArICcoJyArIGFyZyArICcpJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdGVzdHMuam9pbignIHx8ICcpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgICAgICB2YXIgYWxsVHlwZXMgPSB0aGlzLnBhcmFtLnR5cGVzO1xuICAgICAgICAgICAgdmFyIGV4YWN0VHlwZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsVHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMucGFyYW0uY29udmVyc2lvbnNbaV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGV4YWN0VHlwZXMucHVzaChhbGxUeXBlc1tpXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29kZS5wdXNoKHByZWZpeCArICdpZiAoJyArIGdldFRlc3RzKGFsbFR5cGVzLCAnYXJnJyArIGluZGV4KSArICcpIHsgJyArIGNvbW1lbnQpO1xuICAgICAgICAgICAgY29kZS5wdXNoKHByZWZpeCArICcgIHZhciB2YXJBcmdzID0gW2FyZycgKyBpbmRleCArICddOycpO1xuICAgICAgICAgICAgY29kZS5wdXNoKHByZWZpeCArICcgIGZvciAodmFyIGkgPSAnICsgKGluZGV4ICsgMSkgKyAnOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7Jyk7XG4gICAgICAgICAgICBjb2RlLnB1c2gocHJlZml4ICsgJyAgICBpZiAoJyArIGdldFRlc3RzKGV4YWN0VHlwZXMsICdhcmd1bWVudHNbaV0nKSArICcpIHsnKTtcbiAgICAgICAgICAgIGNvZGUucHVzaChwcmVmaXggKyAnICAgICAgdmFyQXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7Jyk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsVHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGNvbnZlcnNpb25faSA9IHRoaXMucGFyYW0uY29udmVyc2lvbnNbaV07XG4gICAgICAgICAgICAgIGlmIChjb252ZXJzaW9uX2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGVzdCA9IHJlZnMuYWRkKGdldFR5cGVUZXN0KGFsbFR5cGVzW2ldKSwgJ3Rlc3QnKTtcbiAgICAgICAgICAgICAgICB2YXIgY29udmVydCA9IHJlZnMuYWRkKGNvbnZlcnNpb25faS5jb252ZXJ0LCAnY29udmVydCcpO1xuICAgICAgICAgICAgICAgIGNvZGUucHVzaChwcmVmaXggKyAnICAgIH0nKTtcbiAgICAgICAgICAgICAgICBjb2RlLnB1c2gocHJlZml4ICsgJyAgICBlbHNlIGlmICgnICsgdGVzdCArICcoYXJndW1lbnRzW2ldKSkgeycpO1xuICAgICAgICAgICAgICAgIGNvZGUucHVzaChwcmVmaXggKyAnICAgICAgdmFyQXJncy5wdXNoKCcgKyBjb252ZXJ0ICsgJyhhcmd1bWVudHNbaV0pKTsnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29kZS5wdXNoKHByZWZpeCArICcgICAgfSBlbHNlIHsnKTtcbiAgICAgICAgICAgIGNvZGUucHVzaChwcmVmaXggKyAnICAgICAgdGhyb3cgY3JlYXRlRXJyb3IobmFtZSwgYXJndW1lbnRzLmxlbmd0aCwgaSwgYXJndW1lbnRzW2ldLCBcXCcnICsgZXhhY3RUeXBlcy5qb2luKCcsJykgKyAnXFwnKTsnKTtcbiAgICAgICAgICAgIGNvZGUucHVzaChwcmVmaXggKyAnICAgIH0nKTtcbiAgICAgICAgICAgIGNvZGUucHVzaChwcmVmaXggKyAnICB9Jyk7XG4gICAgICAgICAgICBjb2RlLnB1c2godGhpcy5zaWduYXR1cmUudG9Db2RlKHJlZnMsIHByZWZpeCArICcgICcpKTtcbiAgICAgICAgICAgIGNvZGUucHVzaChwcmVmaXggKyAnfScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5wYXJhbS5hbnlUeXBlKSB7XG4gICAgICAgICAgICAvLyBhbnkgdHlwZVxuICAgICAgICAgICAgY29kZS5wdXNoKHByZWZpeCArICcvLyB0eXBlOiBhbnknKTtcbiAgICAgICAgICAgIGNvZGUucHVzaCh0aGlzLl9pbm5lckNvZGUocmVmcywgcHJlZml4LCBhbnlUeXBlKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gcmVndWxhciB0eXBlXG4gICAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMucGFyYW0udHlwZXNbMF07XG4gICAgICAgICAgICB2YXIgdGVzdCA9IHR5cGUgIT09ICdhbnknID8gcmVmcy5hZGQoZ2V0VHlwZVRlc3QodHlwZSksICd0ZXN0JykgOiBudWxsO1xuXG4gICAgICAgICAgICBjb2RlLnB1c2gocHJlZml4ICsgJ2lmICgnICsgdGVzdCArICcoYXJnJyArIGluZGV4ICsgJykpIHsgJyArIGNvbW1lbnQpO1xuICAgICAgICAgICAgY29kZS5wdXNoKHRoaXMuX2lubmVyQ29kZShyZWZzLCBwcmVmaXggKyAnICAnLCBhbnlUeXBlKSk7XG4gICAgICAgICAgICBjb2RlLnB1c2gocHJlZml4ICsgJ30nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyByb290IG5vZGUgKHBhdGggaXMgZW1wdHkpXG4gICAgICAgIGNvZGUucHVzaCh0aGlzLl9pbm5lckNvZGUocmVmcywgcHJlZml4LCBhbnlUeXBlKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2RlLmpvaW4oJ1xcbicpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBpbm5lciBjb2RlIGZvciB0aGlzIGdyb3VwIG9mIHNpZ25hdHVyZXMuXG4gICAgICogVGhpcyBpcyBhIGhlbHBlciBmdW5jdGlvbiBvZiBOb2RlLnByb3RvdHlwZS50b0NvZGVcbiAgICAgKiBAcGFyYW0ge1JlZnN9IHJlZnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4XG4gICAgICogQHBhcmFtIHtOb2RlIHwgdW5kZWZpbmVkfSBbYW55VHlwZV0gIFNpYmxpbmcgb2YgdGhpcyBub2RlIHdpdGggYW55IHR5cGUgcGFyYW1ldGVyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgaW5uZXIgY29kZSBhcyBzdHJpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE5vZGUucHJvdG90eXBlLl9pbm5lckNvZGUgPSBmdW5jdGlvbiAocmVmcywgcHJlZml4LCBhbnlUeXBlKSB7XG4gICAgICB2YXIgY29kZSA9IFtdO1xuICAgICAgdmFyIGk7XG5cbiAgICAgIGlmICh0aGlzLnNpZ25hdHVyZSkge1xuICAgICAgICBjb2RlLnB1c2gocHJlZml4ICsgJ2lmIChhcmd1bWVudHMubGVuZ3RoID09PSAnICsgdGhpcy5wYXRoLmxlbmd0aCArICcpIHsnKTtcbiAgICAgICAgY29kZS5wdXNoKHRoaXMuc2lnbmF0dXJlLnRvQ29kZShyZWZzLCBwcmVmaXggKyAnICAnKSk7XG4gICAgICAgIGNvZGUucHVzaChwcmVmaXggKyAnfScpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV4dEFueVR5cGU7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5jaGlsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRzW2ldLnBhcmFtLmFueVR5cGUpIHtcbiAgICAgICAgICBuZXh0QW55VHlwZSA9IHRoaXMuY2hpbGRzW2ldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmNoaWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb2RlLnB1c2godGhpcy5jaGlsZHNbaV0udG9Db2RlKHJlZnMsIHByZWZpeCwgbmV4dEFueVR5cGUpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFueVR5cGUgJiYgIXRoaXMucGFyYW0uYW55VHlwZSkge1xuICAgICAgICBjb2RlLnB1c2goYW55VHlwZS50b0NvZGUocmVmcywgcHJlZml4LCBuZXh0QW55VHlwZSkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXhjZXB0aW9ucyA9IHRoaXMuX2V4Y2VwdGlvbnMocmVmcywgcHJlZml4KTtcbiAgICAgIGlmIChleGNlcHRpb25zKSB7XG4gICAgICAgIGNvZGUucHVzaChleGNlcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvZGUuam9pbignXFxuJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGNvZGUgdG8gdGhyb3cgZXhjZXB0aW9uc1xuICAgICAqIEBwYXJhbSB7UmVmc30gcmVmc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXhcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBpbm5lciBjb2RlIGFzIHN0cmluZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgTm9kZS5wcm90b3R5cGUuX2V4Y2VwdGlvbnMgPSBmdW5jdGlvbiAocmVmcywgcHJlZml4KSB7XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLnBhdGgubGVuZ3RoO1xuXG4gICAgICBpZiAodGhpcy5jaGlsZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIFRPRE86IGNhbiB0aGlzIGNvbmRpdGlvbiBiZSBzaW1wbGlmaWVkPyAod2UgaGF2ZSBhIGZhbGwtdGhyb3VnaCBoZXJlKVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHByZWZpeCArICdpZiAoYXJndW1lbnRzLmxlbmd0aCA+ICcgKyBpbmRleCArICcpIHsnLFxuICAgICAgICAgIHByZWZpeCArICcgIHRocm93IGNyZWF0ZUVycm9yKG5hbWUsIGFyZ3VtZW50cy5sZW5ndGgsICcgKyBpbmRleCArICcsIGFyZ3VtZW50c1snICsgaW5kZXggKyAnXSk7JyxcbiAgICAgICAgICBwcmVmaXggKyAnfSdcbiAgICAgICAgXS5qb2luKCdcXG4nKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIga2V5cyA9IHt9O1xuICAgICAgICB2YXIgdHlwZXMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNoaWxkc1tpXTtcbiAgICAgICAgICBpZiAobm9kZS5wYXJhbSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2RlLnBhcmFtLnR5cGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIHZhciB0eXBlID0gbm9kZS5wYXJhbS50eXBlc1tqXTtcbiAgICAgICAgICAgICAgaWYgKCEodHlwZSBpbiBrZXlzKSAmJiAhbm9kZS5wYXJhbS5jb252ZXJzaW9uc1tqXSkge1xuICAgICAgICAgICAgICAgIGtleXNbdHlwZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2godHlwZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHJlZml4ICsgJ3Rocm93IGNyZWF0ZUVycm9yKG5hbWUsIGFyZ3VtZW50cy5sZW5ndGgsICcgKyBpbmRleCArICcsIGFyZ3VtZW50c1snICsgaW5kZXggKyAnXSwgXFwnJyArIHR5cGVzLmpvaW4oJywnKSArICdcXCcpOyc7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNwbGl0IGFsbCByYXcgc2lnbmF0dXJlcyBpbnRvIGFuIGFycmF5IHdpdGggZXhwYW5kZWQgU2lnbmF0dXJlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIEZ1bmN0aW9uPn0gcmF3U2lnbmF0dXJlc1xuICAgICAqIEByZXR1cm4ge1NpZ25hdHVyZVtdfSBSZXR1cm5zIGFuIGFycmF5IHdpdGggZXhwYW5kZWQgc2lnbmF0dXJlc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnNlU2lnbmF0dXJlcyhyYXdTaWduYXR1cmVzKSB7XG4gICAgICAvLyBGSVhNRTogbmVlZCB0byBoYXZlIGRldGVybWluaXN0aWMgb3JkZXJpbmcgb2Ygc2lnbmF0dXJlcywgZG8gbm90IGNyZWF0ZSB2aWEgb2JqZWN0XG4gICAgICB2YXIgc2lnbmF0dXJlO1xuICAgICAgdmFyIGtleXMgPSB7fTtcbiAgICAgIHZhciBzaWduYXR1cmVzID0gW107XG4gICAgICB2YXIgaTtcblxuICAgICAgZm9yICh2YXIgdHlwZXMgaW4gcmF3U2lnbmF0dXJlcykge1xuICAgICAgICBpZiAocmF3U2lnbmF0dXJlcy5oYXNPd25Qcm9wZXJ0eSh0eXBlcykpIHtcbiAgICAgICAgICB2YXIgZm4gPSByYXdTaWduYXR1cmVzW3R5cGVzXTtcbiAgICAgICAgICBzaWduYXR1cmUgPSBuZXcgU2lnbmF0dXJlKHR5cGVzLCBmbik7XG5cbiAgICAgICAgICBpZiAoc2lnbmF0dXJlLmlnbm9yZSgpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZXhwYW5kZWQgPSBzaWduYXR1cmUuZXhwYW5kKCk7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXhwYW5kZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzaWduYXR1cmVfaSA9IGV4cGFuZGVkW2ldO1xuICAgICAgICAgICAgdmFyIGtleSA9IHNpZ25hdHVyZV9pLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmcgPSBrZXlzW2tleV07XG4gICAgICAgICAgICBpZiAoIWV4aXN0aW5nKSB7XG4gICAgICAgICAgICAgIGtleXNba2V5XSA9IHNpZ25hdHVyZV9pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBjbXAgPSBTaWduYXR1cmUuY29tcGFyZShzaWduYXR1cmVfaSwgZXhpc3RpbmcpO1xuICAgICAgICAgICAgICBpZiAoY21wIDwgMCkge1xuICAgICAgICAgICAgICAgIC8vIG92ZXJyaWRlIGlmIHNvcnRlZCBmaXJzdFxuICAgICAgICAgICAgICAgIGtleXNba2V5XSA9IHNpZ25hdHVyZV9pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2lnbmF0dXJlIFwiJyArIGtleSArICdcIiBpcyBkZWZpbmVkIHR3aWNlJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gZWxzZToganVzdCBpZ25vcmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gY29udmVydCBmcm9tIG1hcCB0byBhcnJheVxuICAgICAgZm9yIChrZXkgaW4ga2V5cykge1xuICAgICAgICBpZiAoa2V5cy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgc2lnbmF0dXJlcy5wdXNoKGtleXNba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gb3JkZXIgdGhlIHNpZ25hdHVyZXNcbiAgICAgIHNpZ25hdHVyZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gU2lnbmF0dXJlLmNvbXBhcmUoYSwgYik7XG4gICAgICB9KTtcblxuICAgICAgLy8gZmlsdGVyIHJlZHVuZGFudCBjb252ZXJzaW9ucyBmcm9tIHNpZ25hdHVyZXMgd2l0aCB2YXJBcmdzXG4gICAgICAvLyBUT0RPOiBzaW1wbGlmeSB0aGlzIGxvb3Agb3IgbW92ZSBpdCB0byBhIHNlcGFyYXRlIGZ1bmN0aW9uXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgc2lnbmF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzaWduYXR1cmUgPSBzaWduYXR1cmVzW2ldO1xuXG4gICAgICAgIGlmIChzaWduYXR1cmUudmFyQXJncykge1xuICAgICAgICAgIHZhciBpbmRleCA9IHNpZ25hdHVyZS5wYXJhbXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICB2YXIgcGFyYW0gPSBzaWduYXR1cmUucGFyYW1zW2luZGV4XTtcblxuICAgICAgICAgIHZhciB0ID0gMDtcbiAgICAgICAgICB3aGlsZSAodCA8IHBhcmFtLnR5cGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHBhcmFtLmNvbnZlcnNpb25zW3RdKSB7XG4gICAgICAgICAgICAgIHZhciB0eXBlID0gcGFyYW0udHlwZXNbdF07XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzaWduYXR1cmVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG90aGVyID0gc2lnbmF0dXJlc1tqXTtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IG90aGVyLnBhcmFtc1tpbmRleF07XG5cbiAgICAgICAgICAgICAgICBpZiAob3RoZXIgIT09IHNpZ25hdHVyZSAmJlxuICAgICAgICAgICAgICAgICAgICBwICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5zKHAudHlwZXMsIHR5cGUpICYmICFwLmNvbnZlcnNpb25zW2luZGV4XSkge1xuICAgICAgICAgICAgICAgICAgLy8gdGhpcyAoY29udmVyc2lvbikgdHlwZSBhbHJlYWR5IGV4aXN0cywgcmVtb3ZlIGl0XG4gICAgICAgICAgICAgICAgICBwYXJhbS50eXBlcy5zcGxpY2UodCwgMSk7XG4gICAgICAgICAgICAgICAgICBwYXJhbS5jb252ZXJzaW9ucy5zcGxpY2UodCwgMSk7XG4gICAgICAgICAgICAgICAgICB0LS07XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNpZ25hdHVyZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY3JlYXRlIGEgbWFwIHdpdGggbm9ybWFsaXplZCBzaWduYXR1cmVzIGFzIGtleSBhbmQgdGhlIGZ1bmN0aW9uIGFzIHZhbHVlXG4gICAgICogQHBhcmFtIHtTaWduYXR1cmVbXX0gc2lnbmF0dXJlcyAgIEFuIGFycmF5IHdpdGggc3BsaXQgc2lnbmF0dXJlc1xuICAgICAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBGdW5jdGlvbj59IFJldHVybnMgYSBtYXAgd2l0aCBub3JtYWxpemVkXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlcyBhcyBrZXksIGFuZCB0aGUgZnVuY3Rpb25cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcyB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBTaWduYXR1cmVzKHNpZ25hdHVyZXMpIHtcbiAgICAgIHZhciBub3JtYWxpemVkID0ge307XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnbmF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc2lnbmF0dXJlID0gc2lnbmF0dXJlc1tpXTtcbiAgICAgICAgaWYgKHNpZ25hdHVyZS5mbiAmJiAhc2lnbmF0dXJlLmhhc0NvbnZlcnNpb25zKCkpIHtcbiAgICAgICAgICB2YXIgcGFyYW1zID0gc2lnbmF0dXJlLnBhcmFtcy5qb2luKCcsJyk7XG4gICAgICAgICAgbm9ybWFsaXplZFtwYXJhbXNdID0gc2lnbmF0dXJlLmZuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub3JtYWxpemVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHNpZ25hdHVyZXMgcmVjdXJzaXZlbHkgaW4gYSBub2RlIHRyZWUuXG4gICAgICogQHBhcmFtIHtTaWduYXR1cmVbXX0gc2lnbmF0dXJlcyAgQXJyYXkgd2l0aCBleHBhbmRlZCBzaWduYXR1cmVzXG4gICAgICogQHBhcmFtIHtQYXJhbVtdfSBwYXRoICAgICAgICAgICAgVHJhdmVyc2VkIHBhdGggb2YgcGFyYW1ldGVyIHR5cGVzXG4gICAgICogQHJldHVybiB7Tm9kZX0gICAgICAgICAgICAgICAgICAgUmV0dXJucyBhIG5vZGUgdHJlZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnNlVHJlZShzaWduYXR1cmVzLCBwYXRoKSB7XG4gICAgICB2YXIgaSwgc2lnbmF0dXJlO1xuICAgICAgdmFyIGluZGV4ID0gcGF0aC5sZW5ndGg7XG4gICAgICB2YXIgbm9kZVNpZ25hdHVyZTtcblxuICAgICAgdmFyIGZpbHRlcmVkID0gW107XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgc2lnbmF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzaWduYXR1cmUgPSBzaWduYXR1cmVzW2ldO1xuXG4gICAgICAgIC8vIGZpbHRlciB0aGUgZmlyc3Qgc2lnbmF0dXJlIHdpdGggdGhlIGNvcnJlY3QgbnVtYmVyIG9mIHBhcmFtc1xuICAgICAgICBpZiAoc2lnbmF0dXJlLnBhcmFtcy5sZW5ndGggPT09IGluZGV4ICYmICFub2RlU2lnbmF0dXJlKSB7XG4gICAgICAgICAgbm9kZVNpZ25hdHVyZSA9IHNpZ25hdHVyZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaWduYXR1cmUucGFyYW1zW2luZGV4XSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBmaWx0ZXJlZC5wdXNoKHNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gc29ydCB0aGUgZmlsdGVyZWQgc2lnbmF0dXJlcyBieSBwYXJhbVxuICAgICAgZmlsdGVyZWQuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gUGFyYW0uY29tcGFyZShhLnBhcmFtc1tpbmRleF0sIGIucGFyYW1zW2luZGV4XSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gcmVjdXJzZSBvdmVyIHRoZSBzaWduYXR1cmVzXG4gICAgICB2YXIgZW50cmllcyA9IFtdO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGZpbHRlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNpZ25hdHVyZSA9IGZpbHRlcmVkW2ldO1xuICAgICAgICAvLyBncm91cCBzaWduYXR1cmVzIHdpdGggdGhlIHNhbWUgcGFyYW0gYXQgY3VycmVudCBpbmRleFxuICAgICAgICB2YXIgcGFyYW0gPSBzaWduYXR1cmUucGFyYW1zW2luZGV4XTtcblxuICAgICAgICAvLyBUT0RPOiByZXBsYWNlIHRoZSBuZXh0IGZpbHRlciBsb29wXG4gICAgICAgIHZhciBleGlzdGluZyA9IGVudHJpZXMuZmlsdGVyKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgIHJldHVybiBlbnRyeS5wYXJhbS5vdmVybGFwcGluZyhwYXJhbSk7XG4gICAgICAgIH0pWzBdO1xuXG4gICAgICAgIC8vdmFyIGV4aXN0aW5nO1xuICAgICAgICAvL2ZvciAodmFyIGogPSAwOyBqIDwgZW50cmllcy5sZW5ndGg7IGorKykge1xuICAgICAgICAvLyAgaWYgKGVudHJpZXNbal0ucGFyYW0ub3ZlcmxhcHBpbmcocGFyYW0pKSB7XG4gICAgICAgIC8vICAgIGV4aXN0aW5nID0gZW50cmllc1tqXTtcbiAgICAgICAgLy8gICAgYnJlYWs7XG4gICAgICAgIC8vICB9XG4gICAgICAgIC8vfVxuXG4gICAgICAgIGlmIChleGlzdGluZykge1xuICAgICAgICAgIGlmIChleGlzdGluZy5wYXJhbS52YXJBcmdzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbmZsaWN0aW5nIHR5cGVzIFwiJyArIGV4aXN0aW5nLnBhcmFtICsgJ1wiIGFuZCBcIicgKyBwYXJhbSArICdcIicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBleGlzdGluZy5zaWduYXR1cmVzLnB1c2goc2lnbmF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBlbnRyaWVzLnB1c2goe1xuICAgICAgICAgICAgcGFyYW06IHBhcmFtLFxuICAgICAgICAgICAgc2lnbmF0dXJlczogW3NpZ25hdHVyZV1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBwYXJzZSB0aGUgY2hpbGRzXG4gICAgICB2YXIgY2hpbGRzID0gbmV3IEFycmF5KGVudHJpZXMubGVuZ3RoKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaV07XG4gICAgICAgIGNoaWxkc1tpXSA9IHBhcnNlVHJlZShlbnRyeS5zaWduYXR1cmVzLCBwYXRoLmNvbmNhdChlbnRyeS5wYXJhbSkpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgTm9kZShwYXRoLCBub2RlU2lnbmF0dXJlLCBjaGlsZHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGFuIGFycmF5IGxpa2UgWydhcmcwJywgJ2FyZzEnLCAnYXJnMiddXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IE51bWJlciBvZiBhcmd1bWVudHMgdG8gZ2VuZXJhdGVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgd2l0aCBhcmd1bWVudCBuYW1lc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEFyZ3MoY291bnQpIHtcbiAgICAgIC8vIGNyZWF0ZSBhbiBhcnJheSB3aXRoIGFsbCBhcmd1bWVudCBuYW1lc1xuICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBhcmdzW2ldID0gJ2FyZycgKyBpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJncztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wb3NlIGEgZnVuY3Rpb24gZnJvbSBzdWItZnVuY3Rpb25zIGVhY2ggaGFuZGxpbmcgYSBzaW5nbGUgdHlwZSBzaWduYXR1cmUuXG4gICAgICogU2lnbmF0dXJlczpcbiAgICAgKiAgIHR5cGVkKHNpZ25hdHVyZTogc3RyaW5nLCBmbjogZnVuY3Rpb24pXG4gICAgICogICB0eXBlZChuYW1lOiBzdHJpbmcsIHNpZ25hdHVyZTogc3RyaW5nLCBmbjogZnVuY3Rpb24pXG4gICAgICogICB0eXBlZChzaWduYXR1cmVzOiBPYmplY3QuPHN0cmluZywgZnVuY3Rpb24+KVxuICAgICAqICAgdHlwZWQobmFtZTogc3RyaW5nLCBzaWduYXR1cmVzOiBPYmplY3QuPHN0cmluZywgZnVuY3Rpb24+KVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsfSBuYW1lXG4gICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgRnVuY3Rpb24+fSBzaWduYXR1cmVzXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IFJldHVybnMgdGhlIHR5cGVkIGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfdHlwZWQobmFtZSwgc2lnbmF0dXJlcykge1xuICAgICAgdmFyIHJlZnMgPSBuZXcgUmVmcygpO1xuXG4gICAgICAvLyBwYXJzZSBzaWduYXR1cmVzLCBleHBhbmQgdGhlbVxuICAgICAgdmFyIF9zaWduYXR1cmVzID0gcGFyc2VTaWduYXR1cmVzKHNpZ25hdHVyZXMpO1xuICAgICAgaWYgKF9zaWduYXR1cmVzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2lnbmF0dXJlcyBwcm92aWRlZCcpO1xuICAgICAgfVxuXG4gICAgICAvLyBwYXJzZSBzaWduYXR1cmVzIGludG8gYSBub2RlIHRyZWVcbiAgICAgIHZhciBub2RlID0gcGFyc2VUcmVlKF9zaWduYXR1cmVzLCBbXSk7XG5cbiAgICAgIC8vdmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG4gICAgICAvL2NvbnNvbGUubG9nKCdST09UJyk7XG4gICAgICAvL2NvbnNvbGUubG9nKHV0aWwuaW5zcGVjdChub2RlLCB7IGRlcHRoOiBudWxsIH0pKTtcblxuICAgICAgLy8gZ2VuZXJhdGUgY29kZSBmb3IgdGhlIHR5cGVkIGZ1bmN0aW9uXG4gICAgICB2YXIgY29kZSA9IFtdO1xuICAgICAgdmFyIF9uYW1lID0gbmFtZSB8fCAnJztcbiAgICAgIHZhciBfYXJncyA9IGdldEFyZ3MobWF4UGFyYW1zKF9zaWduYXR1cmVzKSk7XG4gICAgICBjb2RlLnB1c2goJ2Z1bmN0aW9uICcgKyBfbmFtZSArICcoJyArIF9hcmdzLmpvaW4oJywgJykgKyAnKSB7Jyk7XG4gICAgICBjb2RlLnB1c2goJyAgXCJ1c2Ugc3RyaWN0XCI7Jyk7XG4gICAgICBjb2RlLnB1c2goJyAgdmFyIG5hbWUgPSBcXCcnICsgX25hbWUgKyAnXFwnOycpO1xuICAgICAgY29kZS5wdXNoKG5vZGUudG9Db2RlKHJlZnMsICcgICcpKTtcbiAgICAgIGNvZGUucHVzaCgnfScpO1xuXG4gICAgICAvLyBnZW5lcmF0ZSBib2R5IGZvciB0aGUgZmFjdG9yeSBmdW5jdGlvblxuICAgICAgdmFyIGJvZHkgPSBbXG4gICAgICAgIHJlZnMudG9Db2RlKCksXG4gICAgICAgICdyZXR1cm4gJyArIGNvZGUuam9pbignXFxuJylcbiAgICAgIF0uam9pbignXFxuJyk7XG5cbiAgICAgIC8vIGV2YWx1YXRlIHRoZSBKYXZhU2NyaXB0IGNvZGUgYW5kIGF0dGFjaCBmdW5jdGlvbiByZWZlcmVuY2VzXG4gICAgICB2YXIgZmFjdG9yeSA9IChuZXcgRnVuY3Rpb24ocmVmcy5uYW1lLCAnY3JlYXRlRXJyb3InLCBib2R5KSk7XG4gICAgICB2YXIgZm4gPSBmYWN0b3J5KHJlZnMsIGNyZWF0ZUVycm9yKTtcblxuICAgICAgLy9jb25zb2xlLmxvZygnRk5cXG4nICsgZm4udG9TdHJpbmcoKSk7IC8vIFRPRE86IGNsZWFudXBcblxuICAgICAgLy8gYXR0YWNoIHRoZSBzaWduYXR1cmVzIHdpdGggc3ViLWZ1bmN0aW9ucyB0byB0aGUgY29uc3RydWN0ZWQgZnVuY3Rpb25cbiAgICAgIGZuLnNpZ25hdHVyZXMgPSBtYXBTaWduYXR1cmVzKF9zaWduYXR1cmVzKTtcblxuICAgICAgcmV0dXJuIGZuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgbWF4aW11bSBudW1iZXIgb2YgcGFyYW1ldGVycyBpbiBnaXZlbnMgc2lnbmF0dXJlc1xuICAgICAqIEBwYXJhbSB7U2lnbmF0dXJlW119IHNpZ25hdHVyZXNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbWF4aW11bSBudW1iZXIgb2YgcGFyYW1ldGVyc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1heFBhcmFtcyhzaWduYXR1cmVzKSB7XG4gICAgICB2YXIgbWF4ID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWduYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBsZW4gPSBzaWduYXR1cmVzW2ldLnBhcmFtcy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gPiBtYXgpIHtcbiAgICAgICAgICBtYXggPSBsZW47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHR5cGUgb2YgYSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Kn0geFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgYSBzdHJpbmcgd2l0aCB0aGUgdHlwZSBvZiB2YWx1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFR5cGVPZih4KSB7XG4gICAgICB2YXIgb2JqO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkLnR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHR5cGVkLnR5cGVzW2ldO1xuXG4gICAgICAgIGlmIChlbnRyeS5uYW1lID09PSAnT2JqZWN0Jykge1xuICAgICAgICAgIC8vIEFycmF5IGFuZCBEYXRlIGFyZSBhbHNvIE9iamVjdCwgc28gdGVzdCBmb3IgT2JqZWN0IGFmdGVyd2FyZHNcbiAgICAgICAgICBvYmogPSBlbnRyeTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAoZW50cnkudGVzdCh4KSkgcmV0dXJuIGVudHJ5Lm5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gYXQgbGFzdCwgdGVzdCB3aGV0aGVyIGFuIG9iamVjdFxuICAgICAgaWYgKG9iaiAmJiBvYmoudGVzdCh4KSkgcmV0dXJuIG9iai5uYW1lO1xuXG4gICAgICByZXR1cm4gJ3Vua25vd24nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlc3Qgd2hldGhlciBhbiBhcnJheSBjb250YWlucyBzb21lIGVudHJ5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAgICAgKiBAcGFyYW0geyp9IGVudHJ5XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGFycmF5IGNvbnRhaW5zIGVudHJ5LCBmYWxzZSBpZiBub3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29udGFpbnMoYXJyYXksIGVudHJ5KSB7XG4gICAgICByZXR1cm4gYXJyYXkuaW5kZXhPZihlbnRyeSkgIT09IC0xO1xuICAgIH1cblxuICAgIC8vIGRhdGEgdHlwZSB0ZXN0c1xuICAgIHZhciB0eXBlcyA9IFtcbiAgICAgIHsgbmFtZTogJ251bWJlcicsICAgIHRlc3Q6IGZ1bmN0aW9uICh4KSB7IHJldHVybiB0eXBlb2YgeCA9PT0gJ251bWJlcicgfSB9LFxuICAgICAgeyBuYW1lOiAnc3RyaW5nJywgICAgdGVzdDogZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHR5cGVvZiB4ID09PSAnc3RyaW5nJyB9IH0sXG4gICAgICB7IG5hbWU6ICdib29sZWFuJywgICB0ZXN0OiBmdW5jdGlvbiAoeCkgeyByZXR1cm4gdHlwZW9mIHggPT09ICdib29sZWFuJyB9IH0sXG4gICAgICB7IG5hbWU6ICdGdW5jdGlvbicsICB0ZXN0OiBmdW5jdGlvbiAoeCkgeyByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbid9IH0sXG4gICAgICB7IG5hbWU6ICdBcnJheScsICAgICB0ZXN0OiBBcnJheS5pc0FycmF5IH0sXG4gICAgICB7IG5hbWU6ICdEYXRlJywgICAgICB0ZXN0OiBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCBpbnN0YW5jZW9mIERhdGUgfSB9LFxuICAgICAgeyBuYW1lOiAnUmVnRXhwJywgICAgdGVzdDogZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggaW5zdGFuY2VvZiBSZWdFeHAgfSB9LFxuICAgICAgeyBuYW1lOiAnT2JqZWN0JywgICAgdGVzdDogZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyB9IH0sXG4gICAgICB7IG5hbWU6ICdudWxsJywgICAgICB0ZXN0OiBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCA9PT0gbnVsbCB9IH0sXG4gICAgICB7IG5hbWU6ICd1bmRlZmluZWQnLCB0ZXN0OiBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCA9PT0gdW5kZWZpbmVkIH0gfVxuICAgIF07XG5cbiAgICAvLyBjb25maWd1cmF0aW9uXG4gICAgdmFyIGNvbmZpZyA9IHt9O1xuXG4gICAgLy8gdHlwZSBjb252ZXJzaW9ucy4gT3JkZXIgaXMgaW1wb3J0YW50XG4gICAgdmFyIGNvbnZlcnNpb25zID0gW107XG5cbiAgICAvLyB0eXBlcyB0byBiZSBpZ25vcmVkXG4gICAgdmFyIGlnbm9yZSA9IFtdO1xuXG4gICAgLy8gdGVtcG9yYXJ5IG9iamVjdCBmb3IgaG9sZGluZyB0eXBlcyBhbmQgY29udmVyc2lvbnMsIGZvciBjb25zdHJ1Y3RpbmdcbiAgICAvLyB0aGUgYHR5cGVkYCBmdW5jdGlvbiBpdHNlbGZcbiAgICAvLyBUT0RPOiBmaW5kIGEgbW9yZSBlbGVnYW50IHNvbHV0aW9uIGZvciB0aGlzXG4gICAgdmFyIHR5cGVkID0ge1xuICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICB0eXBlczogdHlwZXMsXG4gICAgICBjb252ZXJzaW9uczogY29udmVyc2lvbnMsXG4gICAgICBpZ25vcmU6IGlnbm9yZVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgdGhlIHR5cGVkIGZ1bmN0aW9uIGl0c2VsZiB3aXRoIHZhcmlvdXMgc2lnbmF0dXJlc1xuICAgICAqXG4gICAgICogU2lnbmF0dXJlczpcbiAgICAgKlxuICAgICAqICAgdHlwZWQoc2lnbmF0dXJlczogT2JqZWN0LjxzdHJpbmcsIGZ1bmN0aW9uPilcbiAgICAgKiAgIHR5cGVkKG5hbWU6IHN0cmluZywgc2lnbmF0dXJlczogT2JqZWN0LjxzdHJpbmcsIGZ1bmN0aW9uPilcbiAgICAgKi9cbiAgICB0eXBlZCA9IF90eXBlZCgndHlwZWQnLCB7XG4gICAgICAnT2JqZWN0JzogZnVuY3Rpb24gKHNpZ25hdHVyZXMpIHtcbiAgICAgICAgdmFyIGZucyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBzaWduYXR1cmUgaW4gc2lnbmF0dXJlcykge1xuICAgICAgICAgIGlmIChzaWduYXR1cmVzLmhhc093blByb3BlcnR5KHNpZ25hdHVyZSkpIHtcbiAgICAgICAgICAgIGZucy5wdXNoKHNpZ25hdHVyZXNbc2lnbmF0dXJlXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBuYW1lID0gZ2V0TmFtZShmbnMpO1xuXG4gICAgICAgIHJldHVybiBfdHlwZWQobmFtZSwgc2lnbmF0dXJlcyk7XG4gICAgICB9LFxuICAgICAgJ3N0cmluZywgT2JqZWN0JzogX3R5cGVkLFxuICAgICAgLy8gVE9ETzogYWRkIGEgc2lnbmF0dXJlICdBcnJheS48ZnVuY3Rpb24+J1xuICAgICAgJy4uLkZ1bmN0aW9uJzogZnVuY3Rpb24gKGZucykge1xuICAgICAgICB2YXIgZXJyO1xuICAgICAgICB2YXIgbmFtZSA9IGdldE5hbWUoZm5zKTtcbiAgICAgICAgdmFyIHNpZ25hdHVyZXMgPSB7fTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBmbiA9IGZuc1tpXTtcblxuICAgICAgICAgIC8vIHRlc3Qgd2hldGhlciB0aGlzIGlzIGEgdHlwZWQtZnVuY3Rpb25cbiAgICAgICAgICBpZiAoISh0eXBlb2YgZm4uc2lnbmF0dXJlcyA9PT0gJ29iamVjdCcpKSB7XG4gICAgICAgICAgICBlcnIgPSBuZXcgVHlwZUVycm9yKCdGdW5jdGlvbiBpcyBubyB0eXBlZC1mdW5jdGlvbiAoaW5kZXg6ICcgKyBpICsgJyknKTtcbiAgICAgICAgICAgIGVyci5kYXRhID0ge2luZGV4OiBpfTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBtZXJnZSB0aGUgc2lnbmF0dXJlc1xuICAgICAgICAgIGZvciAodmFyIHNpZ25hdHVyZSBpbiBmbi5zaWduYXR1cmVzKSB7XG4gICAgICAgICAgICBpZiAoZm4uc2lnbmF0dXJlcy5oYXNPd25Qcm9wZXJ0eShzaWduYXR1cmUpKSB7XG4gICAgICAgICAgICAgIGlmIChzaWduYXR1cmVzLmhhc093blByb3BlcnR5KHNpZ25hdHVyZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm4uc2lnbmF0dXJlc1tzaWduYXR1cmVdICE9PSBzaWduYXR1cmVzW3NpZ25hdHVyZV0pIHtcbiAgICAgICAgICAgICAgICAgIGVyciA9IG5ldyBFcnJvcignU2lnbmF0dXJlIFwiJyArIHNpZ25hdHVyZSArICdcIiBpcyBkZWZpbmVkIHR3aWNlJyk7XG4gICAgICAgICAgICAgICAgICBlcnIuZGF0YSA9IHtzaWduYXR1cmU6IHNpZ25hdHVyZX07XG4gICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVsc2U6IGJvdGggc2lnbmF0dXJlcyBwb2ludCB0byB0aGUgc2FtZSBmdW5jdGlvbiwgdGhhdCdzIGZpbmVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaWduYXR1cmVzW3NpZ25hdHVyZV0gPSBmbi5zaWduYXR1cmVzW3NpZ25hdHVyZV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3R5cGVkKG5hbWUsIHNpZ25hdHVyZXMpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogRmluZCBhIHNwZWNpZmljIHNpZ25hdHVyZSBmcm9tIGEgKGNvbXBvc2VkKSB0eXBlZCBmdW5jdGlvbiwgZm9yXG4gICAgICogZXhhbXBsZTpcbiAgICAgKlxuICAgICAqICAgdHlwZWQuZmluZChmbiwgWydudW1iZXInLCAnc3RyaW5nJ10pXG4gICAgICogICB0eXBlZC5maW5kKGZuLCAnbnVtYmVyLCBzdHJpbmcnKVxuICAgICAqXG4gICAgICogRnVuY3Rpb24gZmluZCBvbmx5IG9ubHkgd29ya3MgZm9yIGV4YWN0IG1hdGNoZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgICAgICAgICAgICAgICAgICBBIHR5cGVkLWZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBzdHJpbmdbXX0gc2lnbmF0dXJlICAgU2lnbmF0dXJlIHRvIGJlIGZvdW5kLCBjYW4gYmVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbiBhcnJheSBvciBhIGNvbW1hIHNlcGFyYXRlZCBzdHJpbmcuXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259ICAgICAgICAgICAgICAgICAgICAgUmV0dXJucyB0aGUgbWF0Y2hpbmcgc2lnbmF0dXJlLCBvclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93cyBhbiBlcnJyb3Igd2hlbiBubyBzaWduYXR1cmVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBmb3VuZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kIChmbiwgc2lnbmF0dXJlKSB7XG4gICAgICBpZiAoIWZuLnNpZ25hdHVyZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRnVuY3Rpb24gaXMgbm8gdHlwZWQtZnVuY3Rpb24nKTtcbiAgICAgIH1cblxuICAgICAgLy8gbm9ybWFsaXplIGlucHV0XG4gICAgICB2YXIgYXJyO1xuICAgICAgaWYgKHR5cGVvZiBzaWduYXR1cmUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGFyciA9IHNpZ25hdHVyZS5zcGxpdCgnLCcpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFycltpXSA9IGFycltpXS50cmltKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc2lnbmF0dXJlKSkge1xuICAgICAgICBhcnIgPSBzaWduYXR1cmU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU3RyaW5nIGFycmF5IG9yIGEgY29tbWEgc2VwYXJhdGVkIHN0cmluZyBleHBlY3RlZCcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RyID0gYXJyLmpvaW4oJywnKTtcblxuICAgICAgLy8gZmluZCBhbiBleGFjdCBtYXRjaFxuICAgICAgdmFyIG1hdGNoID0gZm4uc2lnbmF0dXJlc1tzdHJdO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH1cblxuICAgICAgLy8gVE9ETzogZXh0ZW5kIGZpbmQgdG8gbWF0Y2ggbm9uLWV4YWN0IHNpZ25hdHVyZXNcblxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU2lnbmF0dXJlIG5vdCBmb3VuZCAoc2lnbmF0dXJlOiAnICsgKGZuLm5hbWUgfHwgJ3VubmFtZWQnKSArICcoJyArIGFyci5qb2luKCcsICcpICsgJykpJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIGdpdmVuIHZhbHVlIHRvIGFub3RoZXIgZGF0YSB0eXBlLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnZlcnQgKHZhbHVlLCB0eXBlKSB7XG4gICAgICB2YXIgZnJvbSA9IGdldFR5cGVPZih2YWx1ZSk7XG5cbiAgICAgIC8vIGNoZWNrIGNvbnZlcnNpb24gaXMgbmVlZGVkXG4gICAgICBpZiAodHlwZSA9PT0gZnJvbSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZWQuY29udmVyc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvbnZlcnNpb24gPSB0eXBlZC5jb252ZXJzaW9uc1tpXTtcbiAgICAgICAgaWYgKGNvbnZlcnNpb24uZnJvbSA9PT0gZnJvbSAmJiBjb252ZXJzaW9uLnRvID09PSB0eXBlKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnZlcnNpb24uY29udmVydCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29udmVydCBmcm9tICcgKyBmcm9tICsgJyB0byAnICsgdHlwZSk7XG4gICAgfVxuXG4gICAgLy8gYXR0YWNoIHR5cGVzIGFuZCBjb252ZXJzaW9ucyB0byB0aGUgZmluYWwgYHR5cGVkYCBmdW5jdGlvblxuICAgIHR5cGVkLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0eXBlZC50eXBlcyA9IHR5cGVzO1xuICAgIHR5cGVkLmNvbnZlcnNpb25zID0gY29udmVyc2lvbnM7XG4gICAgdHlwZWQuaWdub3JlID0gaWdub3JlO1xuICAgIHR5cGVkLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICB0eXBlZC5maW5kID0gZmluZDtcbiAgICB0eXBlZC5jb252ZXJ0ID0gY29udmVydDtcblxuICAgIC8vIGFkZCBhIHR5cGVcbiAgICB0eXBlZC5hZGRUeXBlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIGlmICghdHlwZSB8fCB0eXBlb2YgdHlwZS5uYW1lICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZS50ZXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdCB3aXRoIHByb3BlcnRpZXMge25hbWU6IHN0cmluZywgdGVzdDogZnVuY3Rpb259IGV4cGVjdGVkJyk7XG4gICAgICB9XG5cbiAgICAgIHR5cGVkLnR5cGVzLnB1c2godHlwZSk7XG4gICAgfTtcblxuICAgIC8vIGFkZCBhIGNvbnZlcnNpb25cbiAgICB0eXBlZC5hZGRDb252ZXJzaW9uID0gZnVuY3Rpb24gKGNvbnZlcnNpb24pIHtcbiAgICAgIGlmICghY29udmVyc2lvblxuICAgICAgICAgIHx8IHR5cGVvZiBjb252ZXJzaW9uLmZyb20gIT09ICdzdHJpbmcnXG4gICAgICAgICAgfHwgdHlwZW9mIGNvbnZlcnNpb24udG8gIT09ICdzdHJpbmcnXG4gICAgICAgICAgfHwgdHlwZW9mIGNvbnZlcnNpb24uY29udmVydCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIHtmcm9tOiBzdHJpbmcsIHRvOiBzdHJpbmcsIGNvbnZlcnQ6IGZ1bmN0aW9ufSBleHBlY3RlZCcpO1xuICAgICAgfVxuXG4gICAgICB0eXBlZC5jb252ZXJzaW9ucy5wdXNoKGNvbnZlcnNpb24pO1xuICAgIH07XG5cbiAgICByZXR1cm4gdHlwZWQ7XG4gIH1cblxuICByZXR1cm4gY3JlYXRlKCk7XG59KSk7XG4iLCJleHBvcnQgY2xhc3MgRnVsbEdlbmVyYXRpb25hbFJlcGxhY2VtZW50XG57XG4gICAgc2VsZWN0KHBvcHVsYXRpb24sIGNoaWxkR2VuZXJhdG9yKVxuICAgIHtcbiAgICAgICAgY29uc3QgcG9wdWxhdGlvblNpemUgPSBwb3B1bGF0aW9uLmxlbmd0aDtcbiAgICAgICAgbGV0IG5leHRHZW5lcmF0aW9uICAgPSBuZXcgQXJyYXkocG9wdWxhdGlvblNpemUpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpICE9IHBvcHVsYXRpb24ubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5leHRHZW5lcmF0aW9uW2ldID0gY2hpbGRHZW5lcmF0b3IubmV4dCgpLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5leHRHZW5lcmF0aW9uO1xuICAgIH1cbn1cbiIsImltcG9ydCAqIGFzIG1hdGggZnJvbSAnbWF0aGpzJztcblxuZXhwb3J0IGNsYXNzIENyZWF0b3JcbntcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgsIHZhbHVlRGlzdHJpYnV0aW9uID0gMC41KVxuICAgIHtcbiAgICAgICAgdGhpcy5sZW5ndGggICAgICAgICAgICA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy52YWx1ZURpc3RyaWJ1dGlvbiA9IHZhbHVlRGlzdHJpYnV0aW9uO1xuICAgIH1cblxuICAgIGNyZWF0ZSgpXG4gICAge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShcbiAgICAgICAgICAgIHtsZW5ndGg6IHRoaXMubGVuZ3RofSxcbiAgICAgICAgICAgICgpID0+IE1hdGgucmFuZG9tKCkgPCB0aGlzLnZhbHVlRGlzdHJpYnV0aW9uKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBNdXRhdG9yXG57XG4gICAgY29uc3RydWN0b3IoYml0TXV0YXRpb25SYXRlKVxuICAgIHtcbiAgICAgICAgdGhpcy5iaXRNdXRhdGlvblJhdGUgPSBiaXRNdXRhdGlvblJhdGU7XG4gICAgfVxuXG4gICAgYXBwbHkodmFsdWUpXG4gICAge1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKCh2LCBpLCBhKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoTWF0aC5yYW5kb20oKSA8IHRoaXMuYml0TXV0YXRpb25SYXRlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGFbaV0gPSAhYVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIENyb3Nzb3Zlclxue1xuICAgIGNvbnN0cnVjdG9yKG1pbkNyb3Nzb3ZlclBvaW50cywgbWF4Q3Jvc3NvdmVyUG9pbnRzID0gdW5kZWZpbmVkKVxuICAgIHtcbiAgICAgICAgdGhpcy5taW5Dcm9zc292ZXJQb2ludHMgPSBtaW5Dcm9zc292ZXJQb2ludHM7XG4gICAgICAgIHRoaXMubWF4Q3Jvc3NvdmVyUG9pbnRzID0gbWF4Q3Jvc3NvdmVyUG9pbnRzIHx8IG1pbkNyb3Nzb3ZlclBvaW50cztcbiAgICB9XG5cbiAgICBhcHBseShhLCBiKVxuICAgIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHBvaW50ICA9IG1hdGgucmFuZG9tSW50KDEsIGxlbmd0aCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IHBvaW50OyBpICE9IGxlbmd0aDsgaSArPSAxKVxuICAgICAgICB7XG4gICAgICAgICAgICBbYVtpXSwgYltpXV0gPSBbYltpXSwgYVtpXV1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbYSwgYl07XG4gICAgfVxufVxuIiwiaW1wb3J0ICogYXMgbWF0aCBmcm9tICdtYXRoanMnO1xuaW1wb3J0ICogYXMgdXRpbGl0eSBmcm9tICcuLi8uLi92aS11dGlsaXR5L3ZpLXV0aWxpdHknO1xuXG5leHBvcnQgY2xhc3MgRml0bmVzc1Byb3BvcnRpb25hdGVcbntcbiAgICBwcmVwYXJlKHBvcHVsYXRpb24pXG4gICAge1xuICAgICAgICBjb25zdCBmaXRuZXNzU3VtID0gcG9wdWxhdGlvbi5yZWR1Y2UoXG4gICAgICAgICAgICAoc3VtLCBpbmRpdmlkdWFsKSA9PiBzdW0gKyBpbmRpdmlkdWFsLmZpdG5lc3MsIDApO1xuICAgICAgICByZXR1cm4geyBmaXRuZXNzU3VtOiBmaXRuZXNzU3VtIH07XG4gICAgfVxuXG4gICAgc2VsZWN0KHBvcHVsYXRpb24sIGFydGlmYWN0cylcbiAgICB7XG4gICAgICAgIGxldCBzZWxlY3RlZEluZGl2aWR1YWwgPSBudWxsO1xuICAgICAgICBsZXQgcmFuZG9tRml0bmVzc1N1bSAgID0gbWF0aC5yYW5kb20oYXJ0aWZhY3RzLmZpdG5lc3NTdW0pO1xuXG4gICAgICAgIGZvciAobGV0IGluZGl2aWR1YWwgb2YgcG9wdWxhdGlvbilcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKGluZGl2aWR1YWwuZml0bmVzcyA+IDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRJbmRpdmlkdWFsICA9IGluZGl2aWR1YWw7XG4gICAgICAgICAgICAgICAgcmFuZG9tRml0bmVzc1N1bSAgIC09IGluZGl2aWR1YWwuZml0bmVzcztcblxuICAgICAgICAgICAgICAgIGlmIChyYW5kb21GaXRuZXNzU3VtIDwgMClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxlY3RlZEluZGl2aWR1YWw7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgUmFua1xue1xuICAgIGNvbnN0cnVjdG9yKG1heEV4cGVjdGVkVmFsdWU9MS41KVxuICAgIHtcbiAgICAgICAgdGhpcy5tYXhFeHBlY3RlZFZhbHVlID0gbWF4RXhwZWN0ZWRWYWx1ZTtcbiAgICAgICAgdGhpcy5taW5FeHBlY3RlZFZhbHVlID0gMiAtIG1heEV4cGVjdGVkVmFsdWU7XG4gICAgfVxuXG4gICAgcHJlcGFyZShwb3B1bGF0aW9uKVxuICAgIHtcbiAgICAgICAgcG9wdWxhdGlvbi5zb3J0KChhLCBiKSA9PiBhLmZpdG5lc3MgLSBiLmZpdG5lc3MpO1xuICAgIH1cblxuICAgIHNlbGVjdChwb3B1bGF0aW9uLCBhcnRpZmFjdHMpXG4gICAge1xuICAgICAgICBjb25zdCBwb3B1bGF0aW9uU2l6ZSA9IHBvcHVsYXRpb24ubGVuZ3RoO1xuXG4gICAgICAgIGxldCBzZWxlY3RlZEluZGl2aWR1YWwgICAgID0gcG9wdWxhdGlvbltwb3B1bGF0aW9uU2l6ZSAtIDFdO1xuICAgICAgICBsZXQgcmFuZG9tRXhwZWN0ZWRWYWx1ZVN1bSA9IG1hdGgucmFuZG9tKHBvcHVsYXRpb25TaXplKTtcblxuICAgICAgICBmb3IgKGxldCByYW5rSW5kZXggPSBwb3B1bGF0aW9uU2l6ZTsgcmFua0luZGV4ID49IDE7IHJhbmtJbmRleC0tKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFZhbHVlID0gdGhpcy5taW5FeHBlY3RlZFZhbHVlICtcbiAgICAgICAgICAgICAgICArICh0aGlzLm1heEV4cGVjdGVkVmFsdWUgLSB0aGlzLm1pbkV4cGVjdGVkVmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICogKHJhbmtJbmRleCAtIDEpIC8gKHBvcHVsYXRpb25TaXplIC0gMSk7XG5cbiAgICAgICAgICAgIHJhbmRvbUV4cGVjdGVkVmFsdWVTdW0gLT0gZXhwZWN0ZWRWYWx1ZTtcblxuICAgICAgICAgICAgaWYgKHJhbmRvbUV4cGVjdGVkVmFsdWVTdW0gPCAwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkSW5kaXZpZHVhbCA9IHBvcHVsYXRpb25bcmFua0luZGV4IC0gMV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZWN0ZWRJbmRpdmlkdWFsO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFNpZ21hXG57XG4gICAgcHJlcGFyZShwb3B1bGF0aW9uKVxuICAgIHtcbiAgICAgICAgY29uc3QgZml0bmVzc1ZhbHVlcyAgPSBwb3B1bGF0aW9uLm1hcCh2ID0+IHYuZml0bmVzcyk7XG4gICAgICAgIGNvbnN0IGZpdG5lc3NNZWFuICAgID0gbWF0aC5tZWFuKGZpdG5lc3NWYWx1ZXMpO1xuICAgICAgICBjb25zdCBmaXRuZXNzUFN0ZERldiA9IG1hdGguc3RkKGZpdG5lc3NWYWx1ZXMsICd1bmNvcnJlY3RlZCcpO1xuXG4gICAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gZml0bmVzc1ZhbHVlcy5tYXAoXG4gICAgICAgICAgICBmaXRuZXNzVmFsdWUgPT4gMSArXG4gICAgICAgICAgICAgICAgKGZpdG5lc3NQU3RkRGV2ID4gMFxuICAgICAgICAgICAgICAgID8gKChmaXRuZXNzVmFsdWUgLSBmaXRuZXNzTWVhbikgLyAoMiAqIGZpdG5lc3NQU3RkRGV2KSlcbiAgICAgICAgICAgICAgICA6IDApKTtcblxuICAgICAgICBjb25zdCBleHBlY3RlZFZhbHVlc1N1bSA9IGV4cGVjdGVkVmFsdWVzLnJlZHVjZSgoc3VtLCBleHBlY3RlZFZhbHVlKSA9PiBzdW0gKyBleHBlY3RlZFZhbHVlLCAwKTtcblxuICAgICAgICByZXR1cm4geyBleHBlY3RlZFZhbHVlczogZXhwZWN0ZWRWYWx1ZXMsIGV4cGVjdGVkVmFsdWVzU3VtOiBleHBlY3RlZFZhbHVlc1N1bSB9O1xuICAgIH1cblxuICAgIHNlbGVjdChwb3B1bGF0aW9uLCBhcnRpZmFjdHMpXG4gICAge1xuICAgICAgICBsZXQgc2VsZWN0ZWRJbmRpdmlkdWFsICAgICA9IG51bGw7XG4gICAgICAgIGxldCByYW5kb21FeHBlY3RlZFZhbHVlU3VtID0gbWF0aC5yYW5kb20oYXJ0aWZhY3RzLmV4cGVjdGVkVmFsdWVzU3VtKTtcbiAgICAgICAgY29uc3QgcG9wdWxhdGlvblNpemUgICAgICAgPSBwb3B1bGF0aW9uLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvcHVsYXRpb25TaXplOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGl2aWR1YWwgICAgPSBwb3B1bGF0aW9uW2ldO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZSA9IGFydGlmYWN0cy5leHBlY3RlZFZhbHVlc1tpXTtcblxuICAgICAgICAgICAgc2VsZWN0ZWRJbmRpdmlkdWFsICAgICAgPSBpbmRpdmlkdWFsO1xuICAgICAgICAgICAgcmFuZG9tRXhwZWN0ZWRWYWx1ZVN1bSAtPSBleHBlY3RlZFZhbHVlO1xuXG4gICAgICAgICAgICBpZiAocmFuZG9tRXhwZWN0ZWRWYWx1ZVN1bSA8IDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZWN0ZWRJbmRpdmlkdWFsO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFRvdXJuYW1lbnRcbntcbiAgICBjb25zdHJ1Y3Rvcihncm91cFNpemUsIHJhbmRvbVNlbGVjdGlvblByb2JhYmlsaXR5KVxuICAgIHtcbiAgICAgICAgdGhpcy5ncm91cFNpemUgICAgICAgICAgICAgICAgICA9IGdyb3VwU2l6ZTtcbiAgICAgICAgdGhpcy5yYW5kb21TZWxlY3Rpb25Qcm9iYWJpbGl0eSA9IHJhbmRvbVNlbGVjdGlvblByb2JhYmlsaXR5O1xuICAgIH1cblxuICAgIHByZXBhcmUocG9wdWxhdGlvbilcbiAgICB7XG4gICAgfVxuXG4gICAgc2VsZWN0KHBvcHVsYXRpb24sIGFydGlmYWN0cylcbiAgICB7XG4gICAgICAgIGxldCBncm91cCA9IHV0aWxpdHkuc2FtcGxlKHBvcHVsYXRpb24sIHRoaXMuZ3JvdXBTaXplKTtcblxuICAgICAgICAvLyBFaXRoZXIgc2VsZWN0IHRoZSBtb3N0IGZpdCBpbmRpdmlkdWFsIGJ5IHNvcnRpbmcgdGhlIGdyb3VwLFxuICAgICAgICAvLyBvdGhlcndpc2Ugc2VsZWN0IGEgcmFuZG9tIGluZGl2aWR1YWwgZnJvbSB0aGUgZ3JvdXAgYnlcbiAgICAgICAgLy8gbm90IHNvcnRpbmcuXG5cbiAgICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPj0gdGhpcy5yYW5kb21TZWxlY3Rpb25Qcm9iYWJpbGl0eSlcbiAgICAgICAge1xuICAgICAgICAgICAgZ3JvdXAuc29ydCgoYSwgYikgPT4gYi5maXRuZXNzIC0gYS5maXRuZXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBncm91cFswXTtcbiAgICB9XG59XG5cbiIsImV4cG9ydCBjbGFzcyBTZXh1YWxcbntcbiAgICBjb25zdHJ1Y3Rvcihjcm9zc292ZXJGdW5jdGlvbiwgbXV0YXRvckZ1bmN0aW9uKVxuICAgIHtcbiAgICAgICAgdGhpcy5jcm9zc292ZXJGdW5jdGlvbiA9IGNyb3Nzb3ZlckZ1bmN0aW9uO1xuICAgICAgICB0aGlzLm11dGF0b3JGdW5jdGlvbiAgID0gbXV0YXRvckZ1bmN0aW9uO1xuICAgIH1cblxuICAgIHJlcHJvZHVjZShwYXJlbnRTZWxlY3RvcilcbiAgICB7XG4gICAgICAgIGNvbnN0IGZpcnN0UGFyZW50ICA9IHBhcmVudFNlbGVjdG9yLm5leHQoKS52YWx1ZTtcbiAgICAgICAgY29uc3Qgc2Vjb25kUGFyZW50ID0gcGFyZW50U2VsZWN0b3IubmV4dCgpLnZhbHVlO1xuXG4gICAgICAgIGxldCBmaXJzdENoaWxkR2Vub3R5cGUgID0gZmlyc3RQYXJlbnQuZ2Vub3R5cGUuc2xpY2UoKTtcbiAgICAgICAgbGV0IHNlY29uZENoaWxkR2Vub3R5cGUgPSBzZWNvbmRQYXJlbnQuZ2Vub3R5cGUuc2xpY2UoKTtcblxuICAgICAgICBbZmlyc3RDaGlsZEdlbm90eXBlLCBzZWNvbmRDaGlsZEdlbm90eXBlXSA9XG4gICAgICAgICAgICB0aGlzLmNyb3Nzb3ZlckZ1bmN0aW9uLmFwcGx5KGZpcnN0Q2hpbGRHZW5vdHlwZSwgc2Vjb25kQ2hpbGRHZW5vdHlwZSk7XG5cbiAgICAgICAgZmlyc3RDaGlsZEdlbm90eXBlICA9IHRoaXMubXV0YXRvckZ1bmN0aW9uLmFwcGx5KGZpcnN0Q2hpbGRHZW5vdHlwZSk7XG4gICAgICAgIHNlY29uZENoaWxkR2Vub3R5cGUgPSB0aGlzLm11dGF0b3JGdW5jdGlvbi5hcHBseShzZWNvbmRDaGlsZEdlbm90eXBlKTtcblxuICAgICAgICByZXR1cm4gW2ZpcnN0Q2hpbGRHZW5vdHlwZSwgc2Vjb25kQ2hpbGRHZW5vdHlwZV07XG4gICAgfVxufVxuIiwiaW1wb3J0ICogYXMgbWF0aCBmcm9tICdtYXRoanMnO1xuXG5leHBvcnQgY2xhc3MgSW5kaXZpZHVhbFxue1xuICAgIGNvbnN0cnVjdG9yKGdlbm90eXBlLCBwaGVub3R5cGUsIGZpdG5lc3MpXG4gICAge1xuICAgICAgICB0aGlzLmdlbm90eXBlICA9IGdlbm90eXBlO1xuICAgICAgICB0aGlzLnBoZW5vdHlwZSA9IHBoZW5vdHlwZTtcbiAgICAgICAgdGhpcy5maXRuZXNzICAgPSBmaXRuZXNzO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFN5c3RlbVxue1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpXG4gICAge1xuICAgICAgICB0aGlzLnBvcHVsYXRpb25TaXplICAgICAgICAgICAgPSBvcHRpb25zLnBvcHVsYXRpb25TaXplO1xuICAgICAgICB0aGlzLmVsaXRpc21Db3VudCAgICAgICAgICAgICAgPSBvcHRpb25zLmVsaXRpc21Db3VudDtcbiAgICAgICAgdGhpcy5nZW5vdHlwZUNyZWF0aW9uU3RyYXRlZ3kgID0gb3B0aW9ucy5nZW5vdHlwZUNyZWF0aW9uU3RyYXRlZ3k7XG4gICAgICAgIHRoaXMucGFyZW50U2VsZWN0aW9uU3RyYXRlZ3kgICA9IG9wdGlvbnMucGFyZW50U2VsZWN0aW9uU3RyYXRlZ3k7XG4gICAgICAgIHRoaXMuYWR1bHRTZWxlY3Rpb25TdHJhdGVneSAgICA9IG9wdGlvbnMuYWR1bHRTZWxlY3Rpb25TdHJhdGVneTtcbiAgICAgICAgdGhpcy5yZXByb2R1Y3Rpb25TdHJhdGVneSAgICAgID0gb3B0aW9ucy5yZXByb2R1Y3Rpb25TdHJhdGVneTtcbiAgICAgICAgdGhpcy5maXRuZXNzRXZhbHVhdGlvblN0cmF0ZWd5ID0gb3B0aW9ucy5maXRuZXNzRXZhbHVhdGlvblN0cmF0ZWd5O1xuICAgICAgICB0aGlzLmRldmVsb3BtZW50U3RyYXRlZ3kgICAgICAgPSBvcHRpb25zLmRldmVsb3BtZW50U3RyYXRlZ3kgfHwgbnVsbDtcblxuICAgICAgICB0aGlzLnBvcHVsYXRpb24gPSB0aGlzLmNyZWF0ZUluaXRpYWxQb3B1bGF0aW9uKCk7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGlvbiA9IDA7XG4gICAgfVxuXG4gICAgY3JlYXRlSW5pdGlhbFBvcHVsYXRpb24oKVxuICAgIHtcbiAgICAgICAgbGV0IHBvcHVsYXRpb24gPSBuZXcgQXJyYXkodGhpcy5wb3B1bGF0aW9uU2l6ZSk7XG5cbiAgICAgICAgbGV0IGluZGl2aWR1YWxHZW5lcmF0b3IgPSBnZW5lcmF0b3IuaW5kaXZpZHVhbChcbiAgICAgICAgICAgIHRoaXMuZ2Vub3R5cGVDcmVhdGlvblN0cmF0ZWd5LCB0aGlzLmZpdG5lc3NFdmFsdWF0aW9uU3RyYXRlZ3ksIHRoaXMuZGV2ZWxvcG1lbnRTdHJhdGVneSk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT0gdGhpcy5wb3B1bGF0aW9uU2l6ZTsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBwb3B1bGF0aW9uW2ldID0gaW5kaXZpZHVhbEdlbmVyYXRvci5uZXh0KCkudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9wdWxhdGlvbjtcbiAgICB9XG5cbiAgICBldm9sdmUoKVxuICAgIHtcbiAgICAgICAgbGV0IGVsaXRpc3RzID0gbnVsbDtcblxuICAgICAgICBpZiAodGhpcy5lbGl0aXNtQ291bnQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMucG9wdWxhdGlvbi5zb3J0KChhLCBiKSA9PiBiLmZpdG5lc3MgLSBhLmZpdG5lc3MpO1xuICAgICAgICAgICAgZWxpdGlzdHMgPSB0aGlzLnBvcHVsYXRpb24uc3BsaWNlKDAsIHRoaXMuZWxpdGlzbUNvdW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGFydGlmYWN0cyAgICAgID0gdGhpcy5wYXJlbnRTZWxlY3Rpb25TdHJhdGVneS5wcmVwYXJlKHRoaXMucG9wdWxhdGlvbik7XG4gICAgICAgIGNvbnN0IHBhcmVudFNlbGVjdG9yID0gZ2VuZXJhdG9yLnBhcmVudCh0aGlzLnBvcHVsYXRpb24sIGFydGlmYWN0cywgdGhpcy5wYXJlbnRTZWxlY3Rpb25TdHJhdGVneSk7XG4gICAgICAgIGNvbnN0IGNoaWxkR2VuZXJhdG9yID0gZ2VuZXJhdG9yLmNoaWxkKFxuICAgICAgICAgICAgcGFyZW50U2VsZWN0b3IsIHRoaXMucmVwcm9kdWN0aW9uU3RyYXRlZ3ksIHRoaXMuZGV2ZWxvcG1lbnRTdHJhdGVneSwgdGhpcy5maXRuZXNzRXZhbHVhdGlvblN0cmF0ZWd5KTtcblxuICAgICAgICBjb25zdCBuZXh0R2VuZXJhdGlvbiA9IHRoaXMuYWR1bHRTZWxlY3Rpb25TdHJhdGVneS5zZWxlY3QodGhpcy5wb3B1bGF0aW9uLCBjaGlsZEdlbmVyYXRvcik7XG4gICAgICAgIHRoaXMucG9wdWxhdGlvbiAgICAgID0gZWxpdGlzdHMgPyBlbGl0aXN0cy5jb25jYXQobmV4dEdlbmVyYXRpb24pIDogbmV4dEdlbmVyYXRpb247XG5cbiAgICAgICAgdGhpcy5nZW5lcmF0aW9uKys7XG4gICAgfVxuXG4gICAgc3RhdHMoKVxuICAgIHtcbiAgICAgICAgY29uc3QgZml0bmVzc1ZhbHVlcyAgPSB0aGlzLnBvcHVsYXRpb24ubWFwKHYgPT4gdi5maXRuZXNzKTtcbiAgICAgICAgY29uc3QgZml0bmVzc01lYW4gICAgPSBtYXRoLm1lYW4oZml0bmVzc1ZhbHVlcyk7XG4gICAgICAgIGNvbnN0IGZpdG5lc3NQU3RkRGV2ID0gbWF0aC5zdGQoZml0bmVzc1ZhbHVlcywgJ3VuY29ycmVjdGVkJyk7XG5cbiAgICAgICAgY29uc3QgYmVzdEluZGl2aWR1YWwgPSB0aGlzLnBvcHVsYXRpb24ucmVkdWNlKFxuICAgICAgICAgICAgKHB2LCBjdikgPT4gcHYgJiYgcHYuZml0bmVzcyA+IGN2LmZpdG5lc3MgPyBwdiA6IGN2LCBudWxsKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZml0bmVzc01lYW46ICAgIGZpdG5lc3NNZWFuLFxuICAgICAgICAgICAgZml0bmVzc1BTdGREZXY6IGZpdG5lc3NQU3RkRGV2LFxuICAgICAgICAgICAgYmVzdEluZGl2aWR1YWw6IGJlc3RJbmRpdmlkdWFsLFxuICAgICAgICAgICAgZ2VuZXJhdGlvbjogICAgIHRoaXMuZ2VuZXJhdGlvbiB9O1xuICAgIH1cbn1cblxuY29uc3QgZ2VuZXJhdG9yID0gT2JqZWN0LmZyZWV6ZShmdW5jdGlvbigpXG57XG4gICAgbGV0IGcgPSB7fTtcblxuICAgIGcuY2hpbGQgPSBmdW5jdGlvbiooXG4gICAgICAgIHBhcmVudFNlbGVjdG9yLCByZXByb2R1Y3Rpb25TdHJhdGVneSwgZGV2ZWxvcG1lbnRTdHJhdGVneSwgZml0bmVzc0V2YWx1YXRpb25TdHJhdGVneSlcbiAgICB7XG4gICAgICAgIHdoaWxlICh0cnVlKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbkdlbm90eXBlcyA9IHJlcHJvZHVjdGlvblN0cmF0ZWd5LnJlcHJvZHVjZShwYXJlbnRTZWxlY3Rvcik7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGRHZW5vdHlwZSBvZiBjaGlsZHJlbkdlbm90eXBlcylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZFBoZW5vdHlwZSA9IChkZXZlbG9wbWVudFN0cmF0ZWd5XG4gICAgICAgICAgICAgICAgICAgID8gZGV2ZWxvcG1lbnRTdHJhdGVneS5kZXZlbG9wKGNoaWxkR2Vub3R5cGUpXG4gICAgICAgICAgICAgICAgICAgIDogY2hpbGRHZW5vdHlwZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRQaGVub3R5cGUpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2hpbGRGaXRuZXNzID0gZml0bmVzc0V2YWx1YXRpb25TdHJhdGVneS5ldmFsdWF0ZShjaGlsZFBoZW5vdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIG5ldyBJbmRpdmlkdWFsKGNoaWxkR2Vub3R5cGUsIGNoaWxkUGhlbm90eXBlLCBjaGlsZEZpdG5lc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBnLmluZGl2aWR1YWwgPSBmdW5jdGlvbiooXG4gICAgICAgIGdlbm90eXBlQ3JlYXRpb25TdHJhdGVneSwgZml0bmVzc0V2YWx1YXRpb25TdHJhdGVneSwgZGV2ZWxvcG1lbnRTdHJhdGVneSA9IG51bGwpXG4gICAge1xuICAgICAgICB3aGlsZSAodHJ1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgbGV0IGdlbm90eXBlICA9IGdlbm90eXBlQ3JlYXRpb25TdHJhdGVneS5jcmVhdGUoKTtcbiAgICAgICAgICAgIGxldCBwaGVub3R5cGUgPSAoZGV2ZWxvcG1lbnRTdHJhdGVneVxuICAgICAgICAgICAgICAgID8gZGV2ZWxvcG1lbnRTdHJhdGVneS5kZXZlbG9wKGdlbm90eXBlKSA6IGdlbm90eXBlKTtcblxuICAgICAgICAgICAgaWYgKHBoZW5vdHlwZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsZXQgZml0bmVzcyA9IGZpdG5lc3NFdmFsdWF0aW9uU3RyYXRlZ3kuZXZhbHVhdGUocGhlbm90eXBlKTtcbiAgICAgICAgICAgICAgICB5aWVsZCBuZXcgSW5kaXZpZHVhbChnZW5vdHlwZSwgcGhlbm90eXBlLCBmaXRuZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBnLnBhcmVudCA9IGZ1bmN0aW9uKihwb3B1bGF0aW9uLCBhcnRpZmFjdHMsIHBhcmVudFNlbGVjdGlvblN0cmF0ZWd5KVxuICAgIHtcbiAgICAgICAgd2hpbGUgKHRydWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHlpZWxkIHBhcmVudFNlbGVjdGlvblN0cmF0ZWd5LnNlbGVjdChwb3B1bGF0aW9uLCBhcnRpZmFjdHMpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBnO1xufSgpKTtcbiIsImltcG9ydCAqIGFzIGFkdWx0U2VsZWN0aW9uIGZyb20gJy4vc3JjL2FkdWx0X3NlbGVjdGlvbic7XG5leHBvcnQgeyBhZHVsdFNlbGVjdGlvbiB9O1xuXG5pbXBvcnQgKiBhcyBmaXhlZEJpdFZlY3RvciBmcm9tICcuL3NyYy9maXhlZF9iaXRfdmVjdG9yJztcbmV4cG9ydCB7IGZpeGVkQml0VmVjdG9yIH07XG5cbmltcG9ydCAqIGFzIHJlcHJvZHVjdGlvbiBmcm9tICcuL3NyYy9yZXByb2R1Y3Rpb24nO1xuZXhwb3J0IHsgcmVwcm9kdWN0aW9uIH07XG5cbmltcG9ydCAqIGFzIHBhcmVudFNlbGVjdGlvbiBmcm9tICcuL3NyYy9wYXJlbnRfc2VsZWN0aW9uJztcbmV4cG9ydCB7IHBhcmVudFNlbGVjdGlvbiB9O1xuXG5leHBvcnQgeyBJbmRpdmlkdWFsLCBTeXN0ZW0gfSBmcm9tICcuL3NyYy9zeXN0ZW0nO1xuIiwiaW1wb3J0ICogYXMgZmxhdGxhbmRXb3JsZCBmcm9tICcuLi92aS1mbGF0bGFuZC13b3JsZC92aS1mbGF0bGFuZC13b3JsZCc7XG5pbXBvcnQgKiBhcyBhbm4gZnJvbSAnLi4vdmktYW5uL3ZpLWFubic7XG5pbXBvcnQgKiBhcyBlYSBmcm9tICcuLi92aS1lYS92aS1lYSc7XG5cbmV4cG9ydCBjb25zdCBBY3Rpb24gPVxue1xuICAgIHN0YXk6IDEsIG1vdmVMZWZ0OiAyLCBtb3ZlRm9yd2FyZDogMywgbW92ZVJpZ2h0OiA0XG59O1xuXG5leHBvcnQgY29uc3QgSGVhZGluZyA9XG57XG4gICAgdXA6IDAsIHJpZ2h0OiAxLCBkb3duOiAyLCBsZWZ0OiAzXG59O1xuXG5leHBvcnQgY29uc3QgV29ybGRFbnRpdHkgPSBPYmplY3QuZnJlZXplKFxue1xuICAgIHZvaWQ6IDAsIGZvb2Q6IDEsIHBvaXNvbjogMlxufSk7XG5cbmNvbnN0IHV0aWxpdHkgPSBPYmplY3QuZnJlZXplKGZ1bmN0aW9uKClcbntcbiAgICBsZXQgdSA9IHt9O1xuXG4gICAgdS5jbGVhckdyaWROZWlnaGJvcnMgPSBmdW5jdGlvbihjZWxscywgeCwgeSwgd2lkdGgsIGhlaWdodClcbiAgICB7XG4gICAgICAgIGlmICh4ID4gMClcbiAgICAgICAge1xuICAgICAgICAgICAgY2VsbHNbeSAqIHdpZHRoICsgeCAtIDFdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCA8IHdpZHRoIC0gMSlcbiAgICAgICAge1xuICAgICAgICAgICAgY2VsbHNbeSAqIHdpZHRoICsgeCArIDFdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeSA+IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNlbGxzWyh5IC0gMSkgKiB3aWR0aCArIHhdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeSA8IGhlaWdodCAtIDEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNlbGxzWyh5ICsgMSkgKiB3aWR0aCArIHhdID0gMDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB1LmNvbXB1dGVUYXJnZXRDZWxsID0gZnVuY3Rpb24od29ybGQsIGhlYWRpbmcpXG4gICAge1xuICAgICAgICBzd2l0Y2ggKGhlYWRpbmcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNhc2UgSGVhZGluZy51cDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4OiB3b3JsZC5hZ2VudC54LCB5OiAod29ybGQuYWdlbnQueSAtIDEgKyB3b3JsZC5oZWlnaHQpICUgd29ybGQuaGVpZ2h0IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEhlYWRpbmcuZG93bjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4OiB3b3JsZC5hZ2VudC54LCB5OiAod29ybGQuYWdlbnQueSArIDEpICUgd29ybGQuaGVpZ2h0IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEhlYWRpbmcubGVmdDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4OiAod29ybGQuYWdlbnQueCAtIDEgKyB3b3JsZC53aWR0aCkgJSB3b3JsZC53aWR0aCwgeTogd29ybGQuYWdlbnQueSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBIZWFkaW5nLnJpZ2h0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHg6ICh3b3JsZC5hZ2VudC54ICsgMSkgJSB3b3JsZC53aWR0aCwgeTogd29ybGQuYWdlbnQueSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHUuZ2V0TmVpZ2hib3JGcm9tSGVhZGluZyA9IGZ1bmN0aW9uKHdvcmxkLCBoZWFkaW5nKVxuICAgIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdS5jb21wdXRlVGFyZ2V0Q2VsbCh3b3JsZCwgaGVhZGluZyk7XG4gICAgICAgIHJldHVybiB3b3JsZC5jZWxsc1t0YXJnZXQueSAqIHdvcmxkLndpZHRoICsgdGFyZ2V0LnhdO1xuICAgIH07XG5cbiAgICB1LmdldFJhbmRvbUludEluY2x1c2l2ZSA9IGZ1bmN0aW9uKG1pbiwgbWF4KVxuICAgIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSkgKyBtaW47XG4gICAgfTtcblxuICAgIHUuc2h1ZmZsZSA9IGZ1bmN0aW9uKGFycmF5KVxuICAgIHtcbiAgICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IGFycmF5Lmxlbmd0aCwgdGVtcG9yYXJ5VmFsdWUsIHJhbmRvbUluZGV4O1xuXG4gICAgICAgIHdoaWxlIChjdXJyZW50SW5kZXggIT09IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJhbmRvbUluZGV4ICAgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgY3VycmVudEluZGV4IC09IDE7XG5cbiAgICAgICAgICAgIHRlbXBvcmFyeVZhbHVlICAgICAgPSBhcnJheVtjdXJyZW50SW5kZXhdO1xuICAgICAgICAgICAgYXJyYXlbY3VycmVudEluZGV4XSA9IGFycmF5W3JhbmRvbUluZGV4XTtcbiAgICAgICAgICAgIGFycmF5W3JhbmRvbUluZGV4XSAgPSB0ZW1wb3JhcnlWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHU7XG59KCkpO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb21Xb3JsZChcbiAgICB3b3JsZFdpZHRoLCB3b3JsZEhlaWdodCwgZm9vZFByb2JhYmlsaXR5LCBwb2lzb25Qcm9iYWJpbGl0eSlcbntcbiAgICBjb25zdCB3b3JsZENlbGxDb3VudCAgPSB3b3JsZFdpZHRoICogd29ybGRIZWlnaHQ7XG4gICAgY29uc3QgZm9vZENlbGxDb3VudCAgID0gTWF0aC5yb3VuZChmb29kUHJvYmFiaWxpdHkgKiB3b3JsZENlbGxDb3VudCk7XG4gICAgY29uc3QgcG9pc29uQ2VsbENvdW50ID0gTWF0aC5yb3VuZChcbiAgICAgICAgcG9pc29uUHJvYmFiaWxpdHkgKiAod29ybGRDZWxsQ291bnQgLSBmb29kQ2VsbENvdW50KSk7XG5cbiAgICBsZXQgd29ybGRDZWxscyA9IG5ldyBBcnJheSh3b3JsZENlbGxDb3VudCkuZmlsbChXb3JsZEVudGl0eS52b2lkKTtcblxuICAgIGxldCBhdmFpbGFibGVDZWxscyA9IHV0aWxpdHkuc2h1ZmZsZSh3b3JsZENlbGxzLm1hcCgoY3YsIGkpID0+IGkpKTtcbiAgICBjb25zdCBmb29kQ2VsbHMgICAgPSBhdmFpbGFibGVDZWxscy5zcGxpY2UoMCwgZm9vZENlbGxDb3VudCk7XG4gICAgY29uc3QgcG9pc29uQ2VsbHMgID0gYXZhaWxhYmxlQ2VsbHMuc3BsaWNlKDAsIHBvaXNvbkNlbGxDb3VudCk7XG4gICAgY29uc3QgYWdlbnRDZWxsICAgID0gYXZhaWxhYmxlQ2VsbHMuc3BsaWNlKDAsIDEpWzBdO1xuXG4gICAgZm9yIChsZXQgZm9vZENlbGwgb2YgZm9vZENlbGxzKVxuICAgIHtcbiAgICAgICAgd29ybGRDZWxsc1tmb29kQ2VsbF0gPSBXb3JsZEVudGl0eS5mb29kO1xuICAgIH1cblxuICAgIGZvciAobGV0IHBvaXNvbkNlbGwgb2YgcG9pc29uQ2VsbHMpXG4gICAge1xuICAgICAgICB3b3JsZENlbGxzW3BvaXNvbkNlbGxdID0gV29ybGRFbnRpdHkucG9pc29uO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGNlbGxzOiAgICAgICAgICAgICB3b3JsZENlbGxzLFxuICAgICAgICB3aWR0aDogICAgICAgICAgICAgd29ybGRXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiAgICAgICAgICAgIHdvcmxkSGVpZ2h0LFxuICAgICAgICBmb29kUHJvYmFiaWxpdHk6ICAgZm9vZFByb2JhYmlsaXR5LFxuICAgICAgICBwb2lzb25Qcm9iYWJpbGl0eTogcG9pc29uUHJvYmFiaWxpdHksXG4gICAgICAgIGZvb2RDZWxsQ291bnQ6ICAgICBmb29kQ2VsbENvdW50LFxuICAgICAgICBwb2lzb25DZWxsQ291bnQ6ICAgcG9pc29uQ2VsbENvdW50LFxuICAgICAgICBhZ2VudDoge1xuICAgICAgICAgICAgeDogICAgICAgYWdlbnRDZWxsICUgd29ybGRXaWR0aCxcbiAgICAgICAgICAgIHk6ICAgICAgIE1hdGguZmxvb3IoYWdlbnRDZWxsIC8gd29ybGRXaWR0aCksXG4gICAgICAgICAgICBoZWFkaW5nOiB1dGlsaXR5LmdldFJhbmRvbUludEluY2x1c2l2ZShIZWFkaW5nLnVwLCBIZWFkaW5nLnJpZ2h0KVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRHYW1lTW9kZWxGcm9tV29ybGRNb2RlbCh3b3JsZClcbntcbiAgICBjb25zdCBncmlkV2lkdGggICAgPSAyICogd29ybGQud2lkdGggLSAxO1xuICAgIGNvbnN0IGdyaWRIZWlnaHQgICA9IDIgKiB3b3JsZC5oZWlnaHQgLSAxO1xuICAgIGNvbnN0IG51bUdyaWRDZWxscyA9IGdyaWRXaWR0aCAqIGdyaWRIZWlnaHQ7XG5cbiAgICBsZXQgZ3JpZENlbGxzID0gbmV3IEFycmF5KG51bUdyaWRDZWxscykuZmlsbChmbGF0bGFuZFdvcmxkLkdhbWVFbnRpdHkudm9pZCk7XG5cbiAgICAvLyBQbGFjZSBkb3RzXG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBncmlkSGVpZ2h0OyB5ICs9IDEpXG4gICAge1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IGdyaWRXaWR0aDsgeCArPSAxKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoeSAlIDIgPT0gMCB8fCB4ICUgMiA9PSAwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ICAgICAgPSB5ICogZ3JpZFdpZHRoICsgeDtcbiAgICAgICAgICAgICAgICBncmlkQ2VsbHNbaW5kZXhdID0gZmxhdGxhbmRXb3JsZC5HYW1lRW50aXR5LmRvdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFBsYWNlIGZvb2QgYW5kIGVuZW1pZXNcblxuICAgIC8vIEZvb2QgYW5kIGVuZW15IGluZGV4IGlzIHVzZWQgc3VjaCB0aGF0IHRoZSB0eXBlIG9mIGZydWl0XG4gICAgLy8gYW5kIHR5cGUgb2YgZW5lbXkgaXMgY2hvc2VuIGRldGVybWluaXN0aWNhbGx5LiBPdGhlcndpc2UsXG4gICAgLy8gc2V2ZXJhbCBydW5zIHdpdGggdGhlIHNhbWUgbW9kZWwgd2lsbCBsb29rIGNvbmZ1c2luZy5cbiAgICBsZXQgZm9vZEluZGV4ID0gMDtcbiAgICBsZXQgZW5lbXlJbmRleCA9IDA7XG5cbiAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCB3b3JsZC5oZWlnaHQ7IHJvdyArPSAxKVxuICAgIHtcbiAgICAgICAgZm9yIChsZXQgY29sdW1uID0gMDsgY29sdW1uIDwgd29ybGQud2lkdGg7IGNvbHVtbiArPSAxKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCB3b3JsZEluZGV4ID0gcm93ICogd29ybGQud2lkdGggKyBjb2x1bW47XG4gICAgICAgICAgICBjb25zdCB3b3JsZFZhbHVlID0gd29ybGQuY2VsbHNbd29ybGRJbmRleF07XG4gICAgICAgICAgICBjb25zdCBncmlkSW5kZXggID0gMiAqIHJvdyAqIGdyaWRXaWR0aCArIDIgKiBjb2x1bW47XG5cbiAgICAgICAgICAgIGxldCBncmlkVmFsdWUgPSBmbGF0bGFuZFdvcmxkLkdhbWVFbnRpdHkudm9pZDtcblxuICAgICAgICAgICAgaWYgKHdvcmxkVmFsdWUgPT09IFdvcmxkRW50aXR5LmZvb2QpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZ3JpZFZhbHVlID0gZmxhdGxhbmRXb3JsZC5Db25zdGFudHMuZm9vZFtmb29kSW5kZXhdO1xuICAgICAgICAgICAgICAgIGZvb2RJbmRleCA9IChmb29kSW5kZXggKyAxKSAlIGZsYXRsYW5kV29ybGQuQ29uc3RhbnRzLmZvb2QubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAod29ybGRWYWx1ZSA9PT0gV29ybGRFbnRpdHkucG9pc29uKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGdyaWRWYWx1ZSA9IGZsYXRsYW5kV29ybGQuQ29uc3RhbnRzLmVuZW1pZXNbZW5lbXlJbmRleF07XG4gICAgICAgICAgICAgICAgZW5lbXlJbmRleCA9IChlbmVteUluZGV4ICsgMSkgJSBmbGF0bGFuZFdvcmxkLkNvbnN0YW50cy5lbmVtaWVzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGdyaWRWYWx1ZSAhPT0gZmxhdGxhbmRXb3JsZC5HYW1lRW50aXR5LnZvaWQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZ3JpZENlbGxzW2dyaWRJbmRleF0gPSBncmlkVmFsdWU7XG4gICAgICAgICAgICAgICAgdXRpbGl0eS5jbGVhckdyaWROZWlnaGJvcnMoXG4gICAgICAgICAgICAgICAgICAgIGdyaWRDZWxscywgMiAqIGNvbHVtbiwgMiAqIHJvdywgZ3JpZFdpZHRoLCBncmlkSGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdyaWRDZWxsc1syICogd29ybGQuYWdlbnQueSAqIGdyaWRXaWR0aCArIDIgKiB3b3JsZC5hZ2VudC54XSA9IDA7XG4gICAgdXRpbGl0eS5jbGVhckdyaWROZWlnaGJvcnMoXG4gICAgICAgIGdyaWRDZWxscywgMiAqIHdvcmxkLmFnZW50LngsIDIgKiB3b3JsZC5hZ2VudC55LCBncmlkV2lkdGgsIGdyaWRIZWlnaHQpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2VsbHM6ICBncmlkQ2VsbHMsXG4gICAgICAgIHdpZHRoOiAgZ3JpZFdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGdyaWRIZWlnaHQsXG4gICAgICAgIGFnZW50OiB7XG4gICAgICAgICAgICB4OiB3b3JsZC5hZ2VudC54ICogMixcbiAgICAgICAgICAgIHk6IHdvcmxkLmFnZW50LnkgKiAyXG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXZhbHVhdGVSdW4od29ybGQsIGFnZW50LCB0aW1lU3RlcHMpXG57XG4gICAgd29ybGQgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHdvcmxkKSk7XG5cbiAgICBsZXQgZm9vZEVhdGVuID0gMCwgcG9pc29uRWF0ZW4gPSAwLCBtb3ZlcyA9IFtdO1xuXG4gICAgd2hpbGUgKHRpbWVTdGVwcyAtLT4gMClcbiAgICB7XG4gICAgICAgIGNvbnN0IGFjdGlvbiA9IGFnZW50LmFjdCh3b3JsZCk7XG5cbiAgICAgICAgaWYgKGFjdGlvbiAhPT0gQWN0aW9uLnN0YXkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHN3aXRjaCAoYWN0aW9uKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNhc2UgQWN0aW9uLm1vdmVMZWZ0OlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgd29ybGQuYWdlbnQuaGVhZGluZyA9ICh3b3JsZC5hZ2VudC5oZWFkaW5nIC0gMSArIDQpICUgNDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgQWN0aW9uLm1vdmVSaWdodDpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmxkLmFnZW50LmhlYWRpbmcgPSAod29ybGQuYWdlbnQuaGVhZGluZyArIDEpICUgNDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzd2l0Y2ggKHdvcmxkLmFnZW50LmhlYWRpbmcpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2FzZSBIZWFkaW5nLnVwOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbW92ZXMucHVzaChmbGF0bGFuZFdvcmxkLkFjdGlvbi5tb3ZlVXApO1xuICAgICAgICAgICAgICAgICAgICB3b3JsZC5hZ2VudC55ID0gKHdvcmxkLmFnZW50LnkgLSAxICsgd29ybGQuaGVpZ2h0KSAlIHdvcmxkLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgSGVhZGluZy5kb3duOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbW92ZXMucHVzaChmbGF0bGFuZFdvcmxkLkFjdGlvbi5tb3ZlRG93bik7XG4gICAgICAgICAgICAgICAgICAgIHdvcmxkLmFnZW50LnkgPSAod29ybGQuYWdlbnQueSArIDEpICUgd29ybGQuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBIZWFkaW5nLmxlZnQ6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBtb3Zlcy5wdXNoKGZsYXRsYW5kV29ybGQuQWN0aW9uLm1vdmVMZWZ0KTtcbiAgICAgICAgICAgICAgICAgICAgd29ybGQuYWdlbnQueCA9ICh3b3JsZC5hZ2VudC54IC0gMSArIHdvcmxkLndpZHRoKSAlIHdvcmxkLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBIZWFkaW5nLnJpZ2h0OlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbW92ZXMucHVzaChmbGF0bGFuZFdvcmxkLkFjdGlvbi5tb3ZlUmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICB3b3JsZC5hZ2VudC54ID0gKHdvcmxkLmFnZW50LnggKyAxKSAlIHdvcmxkLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGVudGl0eU9mZnNldCA9IHdvcmxkLmFnZW50LnkgKiB3b3JsZC53aWR0aCArIHdvcmxkLmFnZW50Lng7XG4gICAgICAgICAgICBjb25zdCBlbnRpdHkgICAgICAgPSB3b3JsZC5jZWxsc1tlbnRpdHlPZmZzZXRdO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKGVudGl0eSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjYXNlIFdvcmxkRW50aXR5LmZvb2Q6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBmb29kRWF0ZW4gKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgV29ybGRFbnRpdHkucG9pc29uOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pc29uRWF0ZW4gKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3b3JsZC5jZWxsc1tlbnRpdHlPZmZzZXRdID0gV29ybGRFbnRpdHkudm9pZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIG1vdmVzLnB1c2goZmxhdGxhbmRXb3JsZC5BY3Rpb24uc3RheSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyBmb29kRWF0ZW46IGZvb2RFYXRlbiwgcG9pc29uRWF0ZW46IHBvaXNvbkVhdGVuLCBtb3ZlczogbW92ZXMgfTtcbn1cblxuY29uc3QgYmlhc0JpdHMgPSA0O1xuXG5mdW5jdGlvbiBzZXRCaWFzKGJpYXMsIGdlbm90eXBlLCBpbnB1dE5vZGVzLCBsYXllck5vZGVzLCBnZW5vdHlwZUxheWVyT2Zmc2V0KVxue1xuICAgIGZvciAobGV0IG5vZGUgPSAwOyBub2RlIDwgbGF5ZXJOb2Rlczsgbm9kZSsrKVxuICAgIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ICAgICA9IGdlbm90eXBlTGF5ZXJPZmZzZXQgKyBub2RlICogKDIgKiBpbnB1dE5vZGVzICsgYmlhc0JpdHMpICsgMiAqIGlucHV0Tm9kZXM7XG4gICAgICAgIGNvbnN0IGlzTmVnYXRpdmUgPSBnZW5vdHlwZVtvZmZzZXQgKyAzXTtcbiAgICAgICAgY29uc3QgdmFsdWUgICAgICA9IChnZW5vdHlwZVtvZmZzZXQgKyAwXSB8IDApICsgKGdlbm90eXBlW29mZnNldCArIDFdIHwgMCkgKiAyICsgKGdlbm90eXBlW29mZnNldCArIDJdIHwgMCkgKiA0O1xuXG4gICAgICAgIGJpYXNbbm9kZV0gPSBpc05lZ2F0aXZlID8gdmFsdWUgLSA4IDogdmFsdWU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzZXRXZWlnaHRzKHdlaWdodHMsIGdlbm90eXBlLCBpbnB1dE5vZGVzLCBsYXllck5vZGVzLCBnZW5vdHlwZU9mZnNldClcbntcbiAgICBmb3IgKGxldCBub2RlID0gMDsgbm9kZSA8IGxheWVyTm9kZXM7IG5vZGUrKylcbiAgICB7XG4gICAgICAgIGZvciAobGV0IGlucHV0Tm9kZSA9IDA7IGlucHV0Tm9kZSA8IGlucHV0Tm9kZXM7IGlucHV0Tm9kZSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBnZW5vdHlwZU9mZnNldCArIG5vZGUgKiAoMiAqIGlucHV0Tm9kZXMgKyBiaWFzQml0cykgKyAyICogaW5wdXROb2RlO1xuICAgICAgICAgICAgd2VpZ2h0c1tub2RlICogaW5wdXROb2RlcyArIGlucHV0Tm9kZV0gPSAoZ2Vub3R5cGVbb2Zmc2V0XSB8IDApICogKGdlbm90eXBlW29mZnNldCArIDFdID8gMSA6IC0xKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxubGV0IHN0ZXBGdW5jdGlvbiA9IGZ1bmN0aW9uKHN0ZXBWYWx1ZSlcbntcbiAgICByZXR1cm4gZnVuY3Rpb24oaW5wdXQpXG4gICAge1xuICAgICAgICByZXR1cm4gaW5wdXQgPj0gc3RlcFZhbHVlID8gMSA6IDA7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2Vub3R5cGVEZXZlbG9wbWVudFN0cmF0ZWd5KGdlbm90eXBlKVxue1xuICAgIGNvbnN0IGlucHV0Tm9kZXMgID0gNjtcbiAgICBjb25zdCBoaWRkZW5Ob2RlcyA9IDY7XG4gICAgY29uc3Qgb3V0cHV0Tm9kZXMgPSAzO1xuXG4gICAgbGV0IGhpZGRlbkxheWVyQmlhcyAgICA9IG5ldyBBcnJheShoaWRkZW5Ob2Rlcyk7XG4gICAgbGV0IGhpZGRlbkxheWVyV2VpZ2h0cyA9IG5ldyBBcnJheShpbnB1dE5vZGVzICogaGlkZGVuTm9kZXMpO1xuXG4gICAgc2V0V2VpZ2h0cyhoaWRkZW5MYXllcldlaWdodHMsIGdlbm90eXBlLCBpbnB1dE5vZGVzLCBoaWRkZW5Ob2RlcywgMCk7XG4gICAgc2V0QmlhcyhoaWRkZW5MYXllckJpYXMsIGdlbm90eXBlLCBpbnB1dE5vZGVzLCBoaWRkZW5Ob2RlcywgMCk7XG5cbiAgICBsZXQgb3V0cHV0TGF5ZXJCaWFzID0gbmV3IEFycmF5KG91dHB1dE5vZGVzKTtcbiAgICBsZXQgb3V0cHV0TGF5ZXJXZWlnaHRzID0gbmV3IEFycmF5KGhpZGRlbk5vZGVzICogb3V0cHV0Tm9kZXMpO1xuXG4gICAgc2V0V2VpZ2h0cyhvdXRwdXRMYXllcldlaWdodHMsIGdlbm90eXBlLCBoaWRkZW5Ob2Rlcywgb3V0cHV0Tm9kZXMsIDIgKiBpbnB1dE5vZGVzICogaGlkZGVuTm9kZXMgKyBiaWFzQml0cyAqIGhpZGRlbk5vZGVzKTtcbiAgICBzZXRCaWFzKG91dHB1dExheWVyQmlhcywgZ2Vub3R5cGUsIGhpZGRlbk5vZGVzLCBvdXRwdXROb2RlcywgMiAqIGlucHV0Tm9kZXMgKiBoaWRkZW5Ob2RlcyArIGJpYXNCaXRzICogaGlkZGVuTm9kZXMpO1xuXG4gICAgcmV0dXJuIG5ldyBhbm4uZmVlZGZvcndhcmQuTmV0d29yayhbXG4gICAgICAgIG5ldyBhbm4uZmVlZGZvcndhcmQuTGF5ZXIoaGlkZGVuTGF5ZXJCaWFzLCBoaWRkZW5MYXllcldlaWdodHMsIHN0ZXBGdW5jdGlvbigxKSksXG4gICAgICAgIG5ldyBhbm4uZmVlZGZvcndhcmQuTGF5ZXIob3V0cHV0TGF5ZXJCaWFzLCBvdXRwdXRMYXllcldlaWdodHMsIHN0ZXBGdW5jdGlvbigxKSldKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZpdG5lc3NGdW5jdGlvbih3b3JsZClcbntcbiAgICByZXR1cm4gZnVuY3Rpb24ocGhlbm90eXBlKVxuICAgIHtcbiAgICAgICAgbGV0IGFnZW50ICAgID0gbmV3IEFnZW50KHBoZW5vdHlwZSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGV2YWx1YXRlUnVuKHdvcmxkLCBhZ2VudCwgNjApO1xuICAgICAgICByZXR1cm4gKHJlc3VsdC5mb29kRWF0ZW4gLSA1ICogcmVzdWx0LnBvaXNvbkVhdGVuKSAvIHdvcmxkLmZvb2RDZWxsQ291bnQ7XG4gICAgfTtcbn1cblxuZXhwb3J0IGNsYXNzIEFnZW50XG57XG4gICAgY29uc3RydWN0b3IobmV0d29yaylcbiAgICB7XG4gICAgICAgIHRoaXMubmV0d29yayA9IG5ldHdvcms7XG4gICAgfVxuXG4gICAgYWN0KHdvcmxkKVxuICAgIHtcbiAgICAgICAgY29uc3QgbGVmdEhlYWRpbmcgID0gKHdvcmxkLmFnZW50LmhlYWRpbmcgLSAxICsgNCkgJSA0O1xuICAgICAgICBjb25zdCByaWdodEhlYWRpbmcgPSAod29ybGQuYWdlbnQuaGVhZGluZyArIDEpICUgNDtcblxuICAgICAgICBjb25zdCBsZWZ0VmFsdWUgICAgPSB1dGlsaXR5LmdldE5laWdoYm9yRnJvbUhlYWRpbmcod29ybGQsIGxlZnRIZWFkaW5nKTtcbiAgICAgICAgY29uc3QgZm9yd2FyZFZhbHVlID0gdXRpbGl0eS5nZXROZWlnaGJvckZyb21IZWFkaW5nKHdvcmxkLCB3b3JsZC5hZ2VudC5oZWFkaW5nKTtcbiAgICAgICAgY29uc3QgcmlnaHRWYWx1ZSAgID0gdXRpbGl0eS5nZXROZWlnaGJvckZyb21IZWFkaW5nKHdvcmxkLCByaWdodEhlYWRpbmcpO1xuXG4gICAgICAgIGNvbnN0IGlucHV0cyA9IFtcbiAgICAgICAgICAgIGZvcndhcmRWYWx1ZSA9PT0gV29ybGRFbnRpdHkuZm9vZCAgID8gMSA6IDAsXG4gICAgICAgICAgICBsZWZ0VmFsdWUgICAgPT09IFdvcmxkRW50aXR5LmZvb2QgICA/IDEgOiAwLFxuICAgICAgICAgICAgcmlnaHRWYWx1ZSAgID09PSBXb3JsZEVudGl0eS5mb29kICAgPyAxIDogMCxcbiAgICAgICAgICAgIGZvcndhcmRWYWx1ZSA9PT0gV29ybGRFbnRpdHkucG9pc29uID8gMSA6IDAsXG4gICAgICAgICAgICBsZWZ0VmFsdWUgICAgPT09IFdvcmxkRW50aXR5LnBvaXNvbiA/IDEgOiAwLFxuICAgICAgICAgICAgcmlnaHRWYWx1ZSAgID09PSBXb3JsZEVudGl0eS5wb2lzb24gPyAxIDogMCBdO1xuXG4gICAgICAgIGNvbnN0IG91dHB1dHMgPSB0aGlzLm5ldHdvcmsuZXZhbHVhdGUoaW5wdXRzKTtcblxuICAgICAgICBpZiAob3V0cHV0c1swXSA+IG91dHB1dHNbMV0gJiYgb3V0cHV0c1swXSA+IG91dHB1dHNbMl0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBBY3Rpb24ubW92ZUZvcndhcmQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3V0cHV0c1sxXSA+IG91dHB1dHNbMF0gJiYgb3V0cHV0c1sxXSA+IG91dHB1dHNbMl0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBBY3Rpb24ubW92ZUxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3V0cHV0c1syXSA+IG91dHB1dHNbMF0gJiYgb3V0cHV0c1syXSA+IG91dHB1dHNbMV0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBBY3Rpb24ubW92ZVJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIEFjdGlvbi5tb3ZlRm9yd2FyZDtcbiAgICAgICAgICAgIC8vcmV0dXJuIEFjdGlvbi5zdGF5O1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cbi8vbGV0IHN5c3RlbSA9IG5ldyBlYS5TeXN0ZW0oXG4vL3tcbi8vICAgIHBvcHVsYXRpb25TaXplOiAgICAgICAgICAgIDUwLFxuLy8gICAgZWxpdGlzbUNvdW50OiAgICAgICAgICAgICAgNSxcbi8vICAgIGdlbm90eXBlQ3JlYXRpb25TdHJhdGVneTogIG5ldyBlYS5maXhlZEJpdFZlY3Rvci5DcmVhdG9yKDE0NCksXG4vLyAgICBwYXJlbnRTZWxlY3Rpb25TdHJhdGVneTogICBuZXcgZWEucGFyZW50U2VsZWN0aW9uLlNpZ21hKCksXG4vLyAgICBhZHVsdFNlbGVjdGlvblN0cmF0ZWd5OiAgICBuZXcgZWEuYWR1bHRTZWxlY3Rpb24uRnVsbEdlbmVyYXRpb25hbFJlcGxhY2VtZW50KCksXG4vLyAgICByZXByb2R1Y3Rpb25TdHJhdGVneTogICAgICBuZXcgZWEucmVwcm9kdWN0aW9uLlNleHVhbChcbi8vICAgICAgICBuZXcgZWEuZml4ZWRCaXRWZWN0b3IuQ3Jvc3NvdmVyKDEpLFxuLy8gICAgICAgIG5ldyBlYS5maXhlZEJpdFZlY3Rvci5NdXRhdG9yKDAuMDA1KSksXG4vLyAgICBmaXRuZXNzRXZhbHVhdGlvblN0cmF0ZWd5OiB7IGV2YWx1YXRlOiBmaXRuZXNzRnVuY3Rpb24gfSxcbi8vICAgIGRldmVsb3BtZW50U3RyYXRlZ3k6IHsgZGV2ZWxvcDogZ2Vub3R5cGVEZXZlbG9wbWVudFN0cmF0ZWd5IH1cbi8vfSk7XG4vL1xuLy9mb3IgKGxldCBnZW5lcmF0aW9uID0gMDsgZ2VuZXJhdGlvbiA8PSAxMDAwMDsgZ2VuZXJhdGlvbiArPSAxKVxuLy97XG4vLyAgICBjb25zdCBzdGF0cyA9IHN5c3RlbS5zdGF0cygpO1xuLy8gICAgY29uc29sZS5sb2coYGdlbmVyYXRpb24gPSAke2dlbmVyYXRpb259IG1lYW4gPSAke3N0YXRzLmZpdG5lc3NNZWFufSBzdGQgPSAke3N0YXRzLmZpdG5lc3NQU3RkRGV2fSBiZXN0ID0gJHtzdGF0cy5iZXN0SW5kaXZpZHVhbC5maXRuZXNzfSAtPiAke3N0YXRzLmJlc3RJbmRpdmlkdWFsLmdlbm90eXBlfWApO1xuLy8gICAgc3lzdGVtLmV2b2x2ZSgpO1xuLy99XG5cbi8vZ2Vub3R5cGVEZXZlbG9wbWVudFN0cmF0ZWd5KFtmYWxzZSwgZmFsc2UsIHRydWUsIHRydWUsIGZhbHNlLCBmYWxzZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSwgZmFsc2UsIGZhbHNlLCB0cnVlLCBmYWxzZSwgZmFsc2UsIHRydWUsIHRydWVdKTtcblxuLy9mdW5jdGlvbiB0cmFuc2xhdGVSZWxhdGl2ZUFjdGlvbnMoaW5pdGlhbEhlYWRpbmcsIGFjdGlvbnMpXG4vL3tcbi8vICAgIGFjdGlvbnMgPSBhY3Rpb25zLnNsaWNlKCk7XG4vL1xuLy8gICAgd2hpbGUgKGFjdGlvbnMubGVuZ3RoID4gMClcbi8vICAgIHtcbi8vICAgICAgICBpZiAoYWN0aW9uIFxuLy8gICAgfVxuLy9cbi8vXG4vL31cblxuLy9jb25zdCB3b3JsZCAgPSBnZW5lcmF0ZVJhbmRvbVdvcmxkKDEwLCAxMCwgMS8zLCAxLzMpO1xuLy9jb25zdCByZXN1bHQgPSBldmFsdWF0ZVJ1bih3b3JsZCwgbmV3IEFycmF5KDYwKS5tYXAoXyA9PiB1dGlsaXR5LmdldFJhbmRvbUludEluY2x1c2l2ZShBY3Rpb24uc3RheSwgQWN0aW9uLm1vdmVSaWdodCkpKTtcbi8vXG4vL2NvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KHJlc3VsdCkpO1xuXG4vLyAgICAgICB0aGlzLm1vZGVsID0gYnVpbGRHYW1lTW9kZWxGcm9tV29ybGRNb2RlbChcbi8vICAgICAgICAgICAgZ2VuZXJhdGVSYW5kb21Xb3JsZChvcHRpb25zLndvcmxkV2lkdGgsIG9wdGlvbnMud29ybGRIZWlnaHQsIDEvMywgMS8zKSk7XG4iLCJleHBvcnQgY29uc3QgQWN0aW9uID0gT2JqZWN0LmZyZWV6ZShcbntcbiAgICBzdGF5OiAgICAgIDEsXG4gICAgbW92ZVVwOiAgICAyLFxuICAgIG1vdmVEb3duOiAgMyxcbiAgICBtb3ZlTGVmdDogIDQsXG4gICAgbW92ZVJpZ2h0OiA1LFxufSk7XG5cbmV4cG9ydCBjb25zdCBHYW1lRW50aXR5ID0gT2JqZWN0LmZyZWV6ZShcbntcbiAgICB2b2lkOiAgICAgICAgMCxcbiAgICBkb3Q6ICAgICAgICAgMSxcbiAgICBjaGVycnk6ICAgICAgMixcbiAgICBzdHJhd2JlcnJ5OiAgMyxcbiAgICBvcmFuZ2U6ICAgICAgNCxcbiAgICBhcHBsZTogICAgICAgNSxcbiAgICBtZWxvbjogICAgICAgNixcbiAgICBibGlua3k6ICAgICAgNyxcbiAgICBwaW5reTogICAgICAgOCxcbiAgICBpbmt5OiAgICAgICAgOSxcbiAgICBjbHlkZTogICAgICAxMFxufSk7XG5cbmV4cG9ydCBjb25zdCBDb25zdGFudHMgPSBPYmplY3QuZnJlZXplKGZ1bmN0aW9uKClcbntcbiAgICBsZXQgY29uc3RhbnRzID0ge307XG5cbiAgICBjb25zdGFudHMuZ2FtZUxvb3BEZWxheU1zID0gMTAwMCAvIDMwO1xuXG4gICAgY29uc3RhbnRzLmZvb2QgPVxuICAgIFtcbiAgICAgICAgR2FtZUVudGl0eS5jaGVycnksXG4gICAgICAgIEdhbWVFbnRpdHkuc3RyYXdiZXJyeSxcbiAgICAgICAgR2FtZUVudGl0eS5vcmFuZ2UsXG4gICAgICAgIEdhbWVFbnRpdHkuYXBwbGUsXG4gICAgICAgIEdhbWVFbnRpdHkubWVsb25cbiAgICBdO1xuXG4gICAgY29uc3RhbnRzLmVuZW1pZXMgPVxuICAgIFtcbiAgICAgICAgR2FtZUVudGl0eS5ibGlua3ksXG4gICAgICAgIEdhbWVFbnRpdHkucGlua3ksXG4gICAgICAgIEdhbWVFbnRpdHkuaW5reSxcbiAgICAgICAgR2FtZUVudGl0eS5jbHlkZVxuICAgIF07XG5cbiAgICBjb25zdGFudHMuc3ByaXRlSW5mbyAgICAgICAgICAgICAgICAgICAgICAgID0ge307XG4gICAgY29uc3RhbnRzLnNwcml0ZUluZm9bR2FtZUVudGl0eS5kb3RdICAgICAgICA9IHsgeDogMTc2LCB5OiAgMCwgZnJhbWVzOiAxIH07XG4gICAgY29uc3RhbnRzLnNwcml0ZUluZm9bR2FtZUVudGl0eS5jaGVycnldICAgICA9IHsgeDogMTkyLCB5OiAgMCwgZnJhbWVzOiAxIH07XG4gICAgY29uc3RhbnRzLnNwcml0ZUluZm9bR2FtZUVudGl0eS5zdHJhd2JlcnJ5XSA9IHsgeDogMTkyLCB5OiAxNiwgZnJhbWVzOiAxIH07XG4gICAgY29uc3RhbnRzLnNwcml0ZUluZm9bR2FtZUVudGl0eS5vcmFuZ2VdICAgICA9IHsgeDogMTkyLCB5OiAzMiwgZnJhbWVzOiAxIH07XG4gICAgY29uc3RhbnRzLnNwcml0ZUluZm9bR2FtZUVudGl0eS5hcHBsZV0gICAgICA9IHsgeDogMTkyLCB5OiA0OCwgZnJhbWVzOiAxIH07XG4gICAgY29uc3RhbnRzLnNwcml0ZUluZm9bR2FtZUVudGl0eS5tZWxvbl0gICAgICA9IHsgeDogMTkyLCB5OiA2NCwgZnJhbWVzOiAxIH07XG4gICAgY29uc3RhbnRzLnNwcml0ZUluZm9bR2FtZUVudGl0eS5ibGlua3ldICAgICA9IHsgeDogMTYwLCB5OiAxNiwgZnJhbWVzOiAyLCBkaXZpZGVyOiA4IH07XG4gICAgY29uc3RhbnRzLnNwcml0ZUluZm9bR2FtZUVudGl0eS5waW5reV0gICAgICA9IHsgeDogMTYwLCB5OiAzMiwgZnJhbWVzOiAyLCBkaXZpZGVyOiA4IH07XG4gICAgY29uc3RhbnRzLnNwcml0ZUluZm9bR2FtZUVudGl0eS5pbmt5XSAgICAgICA9IHsgeDogMTYwLCB5OiA0OCwgZnJhbWVzOiAyLCBkaXZpZGVyOiA4IH07XG4gICAgY29uc3RhbnRzLnNwcml0ZUluZm9bR2FtZUVudGl0eS5jbHlkZV0gICAgICA9IHsgeDogIDY0LCB5OiA2NCwgZnJhbWVzOiA4LCBkaXZpZGVyOiA4IH07XG5cbiAgICBjb25zdGFudHMuYWdlbnRTcHJpdGVJbmZvICAgICAgICAgICAgICAgICAgID0ge307XG4gICAgY29uc3RhbnRzLmFnZW50U3ByaXRlSW5mb1tBY3Rpb24uc3RheV0gICAgICA9IHsgeDogMCwgeTogMTYsIGZyYW1lczogMSB9O1xuICAgIGNvbnN0YW50cy5hZ2VudFNwcml0ZUluZm9bQWN0aW9uLm1vdmVVcF0gICAgPSB7IHg6IDAsIHk6IDE2LCBmcmFtZXM6IDQgfTtcbiAgICBjb25zdGFudHMuYWdlbnRTcHJpdGVJbmZvW0FjdGlvbi5tb3ZlRG93bl0gID0geyB4OiAwLCB5OiAzMiwgZnJhbWVzOiA0IH07XG4gICAgY29uc3RhbnRzLmFnZW50U3ByaXRlSW5mb1tBY3Rpb24ubW92ZUxlZnRdICA9IHsgeDogMCwgeTogNDgsIGZyYW1lczogNCB9O1xuICAgIGNvbnN0YW50cy5hZ2VudFNwcml0ZUluZm9bQWN0aW9uLm1vdmVSaWdodF0gPSB7IHg6IDAsIHk6IDY0LCBmcmFtZXM6IDQgfTtcblxuICAgIHJldHVybiBjb25zdGFudHM7XG59KCkpO1xuXG5leHBvcnQgY29uc3QgVXRpbGl0eSA9IE9iamVjdC5mcmVlemUoZnVuY3Rpb24oKVxue1xuICAgIGxldCB1dGlsaXR5ID0ge307XG5cbiAgICB1dGlsaXR5LmdldFJhbmRvbUludEluY2x1c2l2ZSA9IGZ1bmN0aW9uKG1pbiwgbWF4KVxuICAgIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSkgKyBtaW47XG4gICAgfTtcblxuICAgIHV0aWxpdHkuaXNFbmVteSA9IGZ1bmN0aW9uKGVudGl0eSlcbiAgICB7XG4gICAgICAgIHJldHVybiBlbnRpdHkgPj0gR2FtZUVudGl0eS5ibGlua3kgJiYgZW50aXR5IDw9IEdhbWVFbnRpdHkuY2x5ZGU7XG4gICAgfTtcblxuICAgIHV0aWxpdHkuaXNGb29kID0gZnVuY3Rpb24oZW50aXR5KVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGVudGl0eSA+PSBHYW1lRW50aXR5LmNoZXJyeSAmJiBlbnRpdHkgPD0gR2FtZUVudGl0eS5tZWxvbjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHV0aWxpdHk7XG59KCkpO1xuXG5leHBvcnQgY2xhc3MgRmxhdGxhbmRXb3JsZFxue1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpXG4gICAge1xuICAgICAgICB0aGlzLnN0ZXBDYWxsYmFjayA9IG9wdGlvbnMuc3RlcENhbGxiYWNrIHx8IG51bGw7XG4gICAgICAgIHRoaXMubW9kZWwgICAgICAgID0gb3B0aW9ucy5tb2RlbCB8fCBudWxsO1xuXG4gICAgICAgIHRoaXMucmVzZXRHYW1lU3RhdGUoKTtcblxuICAgICAgICB0aGlzLmNhbnZhcyAgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChvcHRpb25zLmVsZW1lbnRJZCk7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIHRoaXMuY29udGV4dC5pbWFnZVNtb290aGluZ0VuYWJsZWQgICAgICAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb250ZXh0LndlYmtpdEltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbnRleHQubW96SW1hZ2VTbW9vdGhpbmdFbmFibGVkICAgID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29udGV4dC5maWxsU3R5bGUgICAgICAgICAgICAgICAgICAgPSAnYmxhY2snO1xuXG4gICAgICAgIHRoaXMuc3ByaXRlcyAgICAgICAgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgdGhpcy5zcHJpdGVzLm9ubG9hZCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3csIHRoaXMudXBkYXRlLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLnNwcml0ZXMuc3JjICAgID0gb3B0aW9ucy5zcHJpdGVTb3VyY2UgfHwgJ3ZpLWZsYXRsYW5kLXdvcmxkLXNwcml0ZXMucG5nJztcbiAgICB9XG5cbiAgICBjb21wdXRlQWdlbnRTcHJpdGVQb3NpdGlvbnMoKVxuICAgIHtcbiAgICAgICAgbGV0IHggPSB0aGlzLm1vZGVsLmFnZW50LnggKiA4O1xuICAgICAgICBsZXQgeSA9IHRoaXMubW9kZWwuYWdlbnQueSAqIDg7XG4gICAgICAgIGxldCBjbG9uZVggPSB4LCBjbG9uZVkgPSB5O1xuXG4gICAgICAgIGNvbnN0IGN1cnJlbnRBY3Rpb24gPSB0aGlzLmN1cnJlbnRBY3Rpb247XG5cbiAgICAgICAgaWYgKGN1cnJlbnRBY3Rpb24gJiYgY3VycmVudEFjdGlvbiAhPT0gQWN0aW9uLnN0YXkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IG1vdmVtZW50T2Zmc2V0ID0gMiAqIHRoaXMubW92ZW1lbnRJbmRleDtcblxuICAgICAgICAgICAgc3dpdGNoIChjdXJyZW50QWN0aW9uKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNhc2UgQWN0aW9uLm1vdmVVcDpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHkgLT0gbW92ZW1lbnRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIGNsb25lWSA9IHkgPCAwID8geSArIDggKiAodGhpcy5tb2RlbC5oZWlnaHQgKyAxKSA6IHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIEFjdGlvbi5tb3ZlRG93bjpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHkgKz0gbW92ZW1lbnRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIGNsb25lWSA9ICh5ID49IDggKiAodGhpcy5tb2RlbC5oZWlnaHQgLSAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB5IC0gOCAqICh0aGlzLm1vZGVsLmhlaWdodCArIDEpIDogeSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIEFjdGlvbi5tb3ZlTGVmdDpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHggLT0gbW92ZW1lbnRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIGNsb25lWCA9IHggPCAwID8geCArIDggKiAodGhpcy5tb2RlbC53aWR0aCArIDEpIDogeDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgQWN0aW9uLm1vdmVSaWdodDpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHggKz0gbW92ZW1lbnRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIGNsb25lWCA9ICh4ID49IDggKiAodGhpcy5tb2RlbC53aWR0aCAtIDEpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHggLSA4ICogKHRoaXMubW9kZWwud2lkdGggKyAxKSA6IHgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gWyB7IHg6IHgsIHk6IHkgfSwgeyB4OiBjbG9uZVgsIHk6IGNsb25lWSB9IF07XG4gICAgfVxuXG4gICAgY29tcHV0ZVRhcmdldENlbGwocG9zaXRpb24sIGFjdGlvbiwgc3RlcHMpXG4gICAge1xuICAgICAgICBzd2l0Y2ggKGFjdGlvbilcbiAgICAgICAge1xuICAgICAgICAgICAgY2FzZSBBY3Rpb24uc3RheTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEFjdGlvbi5tb3ZlVXA6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IHBvc2l0aW9uLnkgLSBzdGVwcztcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4OiBwb3NpdGlvbi54LFxuICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHkgPCAwID8geSArIHRoaXMubW9kZWwuaGVpZ2h0ICsgMSA6IHkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgQWN0aW9uLm1vdmVEb3duOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBwb3NpdGlvbi55ICsgc3RlcHM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogcG9zaXRpb24ueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICB5OiB5ID49IHRoaXMubW9kZWwuaGVpZ2h0ID8geSAtIHRoaXMubW9kZWwuaGVpZ2h0IC0gMSA6IHkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgQWN0aW9uLm1vdmVMZWZ0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBwb3NpdGlvbi54IC0gc3RlcHM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogeCA8IDAgPyB4ICsgdGhpcy5tb2RlbC53aWR0aCArIDEgOiB4LFxuICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHBvc2l0aW9uLnkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgQWN0aW9uLm1vdmVSaWdodDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gcG9zaXRpb24ueCArIHN0ZXBzO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IHggPj0gdGhpcy5tb2RlbC53aWR0aCA/IHggLSB0aGlzLm1vZGVsLndpZHRoIC0gMTogeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICB5OiBwb3NpdGlvbi55IH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRDZWxsSW5kZXgocG9zaXRpb24pXG4gICAge1xuICAgICAgICByZXR1cm4gcG9zaXRpb24ueSAqIHRoaXMubW9kZWwud2lkdGggKyBwb3NpdGlvbi54O1xuICAgIH1cblxuICAgIHBlcmZvcm0oYWN0aW9ucylcbiAgICB7XG4gICAgICAgIHRoaXMuYWN0aW9uUXVldWUucHVzaC5hcHBseSh0aGlzLmFjdGlvblF1ZXVlLCBhY3Rpb25zKTtcbiAgICB9XG5cbiAgICByZW5kZXIoKVxuICAgIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmZpbGxSZWN0KDAsIDAsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpO1xuXG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5tb2RlbC5oZWlnaHQ7IHkgKz0gMSlcbiAgICAgICAge1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLm1vZGVsLmhlaWdodDsgeCArPSAxKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ICA9IHkgKiB0aGlzLm1vZGVsLndpZHRoICsgeDtcbiAgICAgICAgICAgICAgICBjb25zdCBlbnRpdHkgPSB0aGlzLm1vZGVsLmNlbGxzW2luZGV4XTtcblxuICAgICAgICAgICAgICAgIGlmIChlbnRpdHkgIT09IEdhbWVFbnRpdHkudm9pZClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFuaW1hdGlvbk9mZnNldCA9IHRoaXMuYW5pbWF0aW9uT2Zmc2V0c1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyU3ByaXRlKENvbnN0YW50cy5zcHJpdGVJbmZvW2VudGl0eV0sIHgsIHksIGFuaW1hdGlvbk9mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGFnZW50U3ByaXRlUG9zaXRpb24sIGFnZW50Q2xvbmVTcHJpdGVQb3NpdGlvbjtcbiAgICAgICAgW2FnZW50U3ByaXRlUG9zaXRpb24sIGFnZW50Q2xvbmVTcHJpdGVQb3NpdGlvbl0gPSB0aGlzLmNvbXB1dGVBZ2VudFNwcml0ZVBvc2l0aW9ucygpO1xuICAgICAgICB0aGlzLnJlbmRlckFnZW50KGFnZW50U3ByaXRlUG9zaXRpb24sIGFnZW50Q2xvbmVTcHJpdGVQb3NpdGlvbik7XG5cbiAgICAgICAgdGhpcy5hbmltYXRpb25JbmRleCArPSAxO1xuICAgIH1cblxuICAgIHJlbmRlckFnZW50KHBvc2l0aW9uLCBjbG9uZVBvc2l0aW9uKVxuICAgIHtcbiAgICAgICAgY29uc3Qgc3ByaXRlICAgICAgICAgID0gQ29uc3RhbnRzLmFnZW50U3ByaXRlSW5mb1t0aGlzLmN1cnJlbnRBY3Rpb24gfHwgQWN0aW9uLnN0YXldO1xuICAgICAgICBjb25zdCBmcmFtZU9mZnNldCAgICAgPSB0aGlzLm1vdmVtZW50SW5kZXggJSBzcHJpdGUuZnJhbWVzO1xuICAgICAgICBjb25zdCBzcHJpdGVBZGp1c3RlZFggPSBzcHJpdGUueCArIDE2ICogZnJhbWVPZmZzZXQ7XG5cbiAgICAgICAgdGhpcy5jb250ZXh0LmRyYXdJbWFnZSh0aGlzLnNwcml0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlQWRqdXN0ZWRYLCBzcHJpdGUueSwgMTYsIDE2LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIDE2LCAxNik7XG5cbiAgICAgICAgdGhpcy5jb250ZXh0LmRyYXdJbWFnZSh0aGlzLnNwcml0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlQWRqdXN0ZWRYLCBzcHJpdGUueSwgMTYsIDE2LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lUG9zaXRpb24ueCwgY2xvbmVQb3NpdGlvbi55LCAxNiwgMTYpO1xuICAgIH1cblxuICAgIHJlbmRlclNwcml0ZShzcHJpdGUsIHgsIHksIGFuaW1hdGlvbk9mZnNldClcbiAgICB7XG4gICAgICAgIGxldCBmcmFtZU9mZnNldCA9IDA7XG5cbiAgICAgICAgaWYgKHNwcml0ZS5mcmFtZXMgPiAwKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBkaXZpZGVkQW5pbWF0aW9uSW5kZXggPSBzcHJpdGUuZGl2aWRlciA/IE1hdGguZmxvb3IodGhpcy5hbmltYXRpb25JbmRleCAvIHNwcml0ZS5kaXZpZGVyKSA6IHRoaXMuYW5pbWF0aW9uSW5kZXg7XG4gICAgICAgICAgICBmcmFtZU9mZnNldCA9IChkaXZpZGVkQW5pbWF0aW9uSW5kZXggKyAoYW5pbWF0aW9uT2Zmc2V0IHx8IDApKSAlIHNwcml0ZS5mcmFtZXM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbnRleHQuZHJhd0ltYWdlKHRoaXMuc3ByaXRlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUueCArIDE2ICogZnJhbWVPZmZzZXQsIHNwcml0ZS55LCAxNiwgMTYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCAqIDgsIHkgKiA4LCAxNiwgMTYpO1xuICAgIH1cblxuICAgIHJlc2V0R2FtZVN0YXRlKClcbiAgICB7XG4gICAgICAgIHRoaXMuYWN0aW9uUXVldWUgICAgPSBbXTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25JbmRleCA9IDA7XG4gICAgICAgIHRoaXMuY3VycmVudEFjdGlvbiAgPSBudWxsO1xuICAgICAgICB0aGlzLm1vdmVtZW50SW5kZXggID0gMDtcbiAgICAgICAgdGhpcy5zdGF0cyAgICAgICAgICA9IHsgZm9vZEVhdGVuOiAwLCBwb2lzb25FYXRlbjogMCwgdGltZVN0ZXBzOiAwIH07XG5cbiAgICAgICAgaWYgKHRoaXMubW9kZWwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uT2Zmc2V0cyA9IHRoaXMubW9kZWwuY2VsbHMubWFwKFxuICAgICAgICAgICAgICAgIHYgPT4gdiBpbiBDb25zdGFudHMuc3ByaXRlSW5mb1xuICAgICAgICAgICAgICAgICAgICAgPyBVdGlsaXR5LmdldFJhbmRvbUludEluY2x1c2l2ZSgwLCBDb25zdGFudHMuc3ByaXRlSW5mb1t2XS5mcmFtZXMgLSAxKVxuICAgICAgICAgICAgICAgICAgICAgOiAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldEdyaWRWYWx1ZShwb3NpdGlvbiwgdmFsdWUpXG4gICAge1xuICAgICAgICBjb25zdCBpbmRleCAgICA9IHRoaXMuZ2V0Q2VsbEluZGV4KHBvc2l0aW9uKTtcbiAgICAgICAgY29uc3QgcHJldmlvdXMgPSB0aGlzLm1vZGVsLmNlbGxzW2luZGV4XTtcbiAgICAgICAgdGhpcy5tb2RlbC5jZWxsc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHByZXZpb3VzO1xuICAgIH1cblxuICAgIHNldE1vZGVsKG1vZGVsKVxuICAgIHtcbiAgICAgICAgdGhpcy5tb2RlbCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobW9kZWwpKTtcbiAgICAgICAgdGhpcy5yZXNldEdhbWVTdGF0ZSgpO1xuICAgIH1cblxuICAgIHVwZGF0ZShjdXJyZW50VGltZSlcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsKVxuICAgICAgICB7XG4gICAgICAgICAgICBsZXQgdGlja3MgPSAoY3VycmVudFRpbWUgJiYgdGhpcy5sYXN0VXBkYXRlVGltZVxuICAgICAgICAgICAgICAgICAgICAgID8gKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0VXBkYXRlVGltZSkgLyBDb25zdGFudHMuZ2FtZUxvb3BEZWxheU1zIDogMCk7XG5cbiAgICAgICAgICAgIHRoaXMubGFzdFVwZGF0ZVRpbWUgPSBjdXJyZW50VGltZTtcblxuICAgICAgICAgICAgZm9yICg7IHRpY2tzID4gMDsgdGlja3MgLT0gMSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudEFjdGlvbiA9IHRoaXMuY3VycmVudEFjdGlvbjtcblxuICAgICAgICAgICAgICAgIGlmICghY3VycmVudEFjdGlvbilcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBY3Rpb24gPSB0aGlzLmN1cnJlbnRBY3Rpb24gPSB0aGlzLmFjdGlvblF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRBY3Rpb24pXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtb3ZlbWVudEluZGV4ID0gKyt0aGlzLm1vdmVtZW50SW5kZXg7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRBY3Rpb24gIT09IEFjdGlvbi5zdGF5KVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW92ZW1lbnRJbmRleCA9PT0gNSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkb3RDZWxsID0gdGhpcy5jb21wdXRlVGFyZ2V0Q2VsbChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5hZ2VudCwgY3VycmVudEFjdGlvbiwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRHcmlkVmFsdWUoZG90Q2VsbCwgR2FtZUVudGl0eS52b2lkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1vdmVtZW50SW5kZXggPT09IDgpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZEFnZW50UG9zaXRpb24gPSB0aGlzLmNvbXB1dGVUYXJnZXRDZWxsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLmFnZW50LCBjdXJyZW50QWN0aW9uLCAyKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwuYWdlbnQgPSB1cGRhdGVkQWdlbnRQb3NpdGlvbjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlYXRlbkNlbGxWYWx1ZSA9IHRoaXMuc2V0R3JpZFZhbHVlKHVwZGF0ZWRBZ2VudFBvc2l0aW9uLCBHYW1lRW50aXR5LnZvaWQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFV0aWxpdHkuaXNGb29kKGVhdGVuQ2VsbFZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdHMuZm9vZEVhdGVuICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKFV0aWxpdHkuaXNFbmVteShlYXRlbkNlbGxWYWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRzLnBvaXNvbkVhdGVuICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vdmVtZW50SW5kZXggPT09IDgpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEFjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVtZW50SW5kZXggPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRzLnRpbWVTdGVwcyAgICAgICAgICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRzLmhhc1JlbWFpbmluZ01vdmVzICA9IHRoaXMuYWN0aW9uUXVldWUubGVuZ3RoICE9PSAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGVwQ2FsbGJhY2spXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGVwQ2FsbGJhY2sodGhpcy5zdGF0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMudXBkYXRlLmJpbmQodGhpcykpO1xuICAgIH1cbn1cbiIsImltcG9ydCAqIGFzIGFubiBmcm9tICcuLi8uLi92aS1hbm4vdmktYW5uJztcbmltcG9ydCAqIGFzIGVhIGZyb20gJy4uLy4uL3ZpLWVhL3ZpLWVhJztcbmltcG9ydCAqIGFzIGZsYXRsYW5kRWEgZnJvbSAnLi4vLi4vdmktZmxhdGxhbmQtZWEvdmktZmxhdGxhbmQtZWEnO1xuaW1wb3J0ICogYXMgZmxhdGxhbmRXb3JsZCBmcm9tICcuLi8uLi92aS1mbGF0bGFuZC13b3JsZC92aS1mbGF0bGFuZC13b3JsZCc7XG5leHBvcnQgeyBhbm4sIGVhLCBmbGF0bGFuZEVhLCBmbGF0bGFuZFdvcmxkIH07XG4iLCJpbXBvcnQgKiBhcyBtYXRoIGZyb20gJ21hdGhqcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzYW1wbGUodmFsdWVzLCBrKVxue1xuICAgIGxldCBzYW1wbGVzICAgPSBuZXcgQXJyYXkoayk7XG4gICAgbGV0IGxhc3RJbmRleCA9IHZhbHVlcy5sZW5ndGggLSAxO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrOyBpKyssIGxhc3RJbmRleC0tKVxuICAgIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWQgICAgPSBtYXRoLnJhbmRvbUludChsYXN0SW5kZXggKyAxKTtcbiAgICAgICAgY29uc3QgdmFsdWUgICAgICAgPSB2YWx1ZXNbc2VsZWN0ZWRdO1xuICAgICAgICB2YWx1ZXNbc2VsZWN0ZWRdICA9IHZhbHVlc1tsYXN0SW5kZXhdO1xuICAgICAgICB2YWx1ZXNbbGFzdEluZGV4XSA9IHZhbHVlO1xuICAgICAgICBzYW1wbGVzW2ldICAgICAgICA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBzYW1wbGVzO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHNodWZmbGUodmFsdWVzKVxue1xuICAgIGZvciAobGV0IGxhc3RJbmRleCA9IHZhbHVlcy5sZW5ndGggLSAxOyBsYXN0SW5kZXggPiAwOyBsYXN0SW5kZXgtLSlcbiAgICB7XG4gICAgICAgIGNvbnN0IHJhbmRvbUluZGV4ICAgPSBtYXRoLnJhbmRvbUludChsYXN0SW5kZXggKyAxKTtcbiAgICAgICAgY29uc3QgdmFsdWUgICAgICAgICA9IHZhbHVlc1tsYXN0SW5kZXhdO1xuICAgICAgICB2YWx1ZXNbbGFzdEluZGV4XSAgID0gdmFsdWVzW3JhbmRvbUluZGV4XTtcbiAgICAgICAgdmFsdWVzW3JhbmRvbUluZGV4XSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZXM7XG59O1xuIl19
